user_id,user_login,pull_request_url,comment_id,created_at,path,diff_hunk,content,code_smell
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/30041,900463384,2022-06-17T19:49:59Z,src/core/ext/filters/client_channel/lb_policy/rls/rls.cc,"@@ -1103,40 +1106,41 @@ LoadBalancingPolicy::PickResult RlsLb::Picker::Pick(PickArgs args) { RlsLb::Cache::Entry::BackoffTimer::BackoffTimer(RefCountedPtr<Entry> entry,                                                 Timestamp backoff_time)     : entry_(std::move(entry)) {-  GRPC_CLOSURE_INIT(&backoff_timer_callback_, OnBackoffTimer, this, nullptr);-  Ref(DEBUG_LOCATION, ""BackoffTimer"").release();-  grpc_timer_init(&backoff_timer_, backoff_time, &backoff_timer_callback_);+  backoff_timer_task_handle_ = GetDefaultEventEngine()->RunAfter(+      backoff_time - ExecCtx::Get()->Now(),+      [self = Ref(DEBUG_LOCATION, ""BackoffTimer"")] { self->OnBackoffTimer(); }); }  void RlsLb::Cache::Entry::BackoffTimer::Orphan() {-  if (armed_) {-    armed_ = false;-    grpc_timer_cancel(&backoff_timer_);+  if (backoff_timer_task_handle_.has_value()) {+    if (GetDefaultEventEngine()->Cancel(*backoff_timer_task_handle_)) {","I think this can just be combined with the previous condition rather than being a separate, nested conditional.  If the cancellation fails, we don't need to reset `backoff_timer_task_handle_`, because the callback will do it for us.",
23140989,ZhenLian,https://api.github.com/repos/grpc/grpc/pulls/29728,902128037,2022-06-21T03:22:54Z,test/core/tsi/ssl_transport_security_util_test.cc,"@@ -0,0 +1,353 @@+//+// Copyright 2021 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+//++#include ""src/core/tsi/ssl_transport_security_util.h""++#include <string>+#include <vector>++#include <gmock/gmock.h>+#include <gtest/gtest.h>+#include <openssl/bio.h>+#include <openssl/crypto.h>+#include <openssl/ssl.h>++#include ""absl/status/status.h""+#include ""absl/status/statusor.h""+#include ""absl/strings/match.h""+#include ""absl/strings/string_view.h""++#include ""src/core/tsi/transport_security.h""+#include ""src/core/tsi/transport_security_interface.h""+#include ""test/core/util/test_config.h""++namespace grpc_core {+namespace testing {++using ::testing::ContainerEq;+using ::testing::NotNull;+using ::testing::Test;+using ::testing::TestWithParam;+using ::testing::ValuesIn;++constexpr std::size_t kMaxPlaintextBytesPerTlsRecord = 16384;+constexpr std::size_t kTls13RecordOverhead = 22;++// Used for debugging.+int VerifySucceed(X509_STORE_CTX* store_ctx, void* arg) { return 1; }++absl::Status DoHandshake(SSL** out_client, SSL** out_server) {","I know this might get too long so you want to put it in a separate function. But if this is just used once, let's just put it in the `SetUp`. ",X
2811396,ejona86,https://api.github.com/repos/grpc/grpc/pulls/29985,902807699,2022-06-21T16:06:29Z,tools/run_tests/run_interop_tests.py,"@@ -959,8 +979,12 @@ def cloud_to_cloud_jobspec(language,                 language.client_cmd_http2interop(common_options))             cwd = language.http2_cwd     else:-        cmdline = bash_cmdline(-            language.client_cmd(common_options + interop_only_options))+        cmd_options = common_options + interop_only_options+        if test_case in _ORCA_TEST_CASES:",Move this condition earlier in the function and add the option to `interop_only_options`?,
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/30007,902953959,2022-06-21T18:46:23Z,src/core/lib/compression/compression_internal.cc,"@@ -35,7 +35,8 @@ #include ""src/core/lib/debug/trace.h"" #include ""src/core/lib/surface/api_trace.h"" -#define Z_DEFAULT_COMPRESSION_LOWER_BOUND  (0)+#define GRPC_MIN_COMPRESSION_MESSAGE_SIZE  (0)+#define GPRC_DEFAULT_COMPRESS_LEVEL (6)","I don't think we need our own default for this.  Instead, we should use `Z_DEFAULT_COMPRESSION`, which is already provided by the gzip library.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/30007,902955411,2022-06-21T18:48:08Z,src/core/lib/compression/message_compress.h,"@@ -19,23 +19,31 @@ #ifndef GRPC_CORE_LIB_COMPRESSION_MESSAGE_COMPRESS_H #define GRPC_CORE_LIB_COMPRESSION_MESSAGE_COMPRESS_H +#include <memory> #include <grpc/support/port_platform.h> +#include <grpc/impl/codegen/grpc_types.h> #include <grpc/impl/codegen/compression_types.h> #include <grpc/slice.h> -struct gzip_compression_options {-   int gzip_compression_level;-   int compression_lower_bound;+namespace grpc_core {+class CompressionOptions {+ public:+  virtual ~CompressionOptions() = default; }; +// Return Compression options+std::unique_ptr<CompressionOptions> MakeCompressionOptions(const grpc_channel_args* args);++}  // namespace grpc_core+ /* compress 'input' to 'output' using 'algorithm'.    On success, appends compressed slices to output and returns 1.    On failure, appends uncompressed slices to output and returns 0. */ int grpc_msg_compress(grpc_compression_algorithm algorithm,                       grpc_slice_buffer* input,                        grpc_slice_buffer* output,-                      gzip_compression_options options);+                      std::unique_ptr<grpc_core::CompressionOptions> options);","This should not take ownership, so it should not take a `unique_ptr<>`.  Instead, this parameter should be of type `const grpc_core::CompressionOptions*`.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/30007,902958792,2022-06-21T18:52:06Z,src/core/lib/compression/message_compress.cc,"@@ -94,10 +117,7 @@ static void* zalloc_gpr(void* /*opaque*/, unsigned int items, static void zfree_gpr(void* /*opaque*/, void* address) { gpr_free(address); }  static int zlib_compress(grpc_slice_buffer* input, grpc_slice_buffer* output,-                         int gzip, gzip_compression_options options) {-  if( input->length < options.compression_lower_bound ) -    return 0;-  +                         int gzip, std::unique_ptr<grpc_core::GzipCompressionOptionsImpl> options) {","The parameter should not be a `unique_ptr<>`, it should be of type `const grpc_core::GzipCompressionOptionsImpl*`.",
5564114,Vignesh2208,https://api.github.com/repos/grpc/grpc/pulls/30061,903056190,2022-06-21T20:49:50Z,src/core/lib/iomgr/tcp_client_posix.cc,"@@ -208,6 +241,14 @@ static void on_writable(void* acp, grpc_error_handle error) {   }  finish:+  if (!connect_cancelled) {+    int shard_number = ac->connection_handle % (*g_connection_shards).size();+    struct ConnectionShard* shard = &(*g_connection_shards)[shard_number];+    {+      grpc_core::MutexLock lock(&shard->mu);",Yeah good point. This lock is not acquired on every write though. The on_writable callback gets executed only once per connection after the connect() succeeds. So the lock will be acquired once before initiating the connection attempt and once after the connection attempt succeeds/fails aynchronously. I dont anticipate contention because we already have a global lock in grpc_fd_create() implementations and haven't observed any major complaints,
17583509,zeromath,https://api.github.com/repos/grpc/grpc/pulls/29728,903136559,2022-06-21T23:02:07Z,src/core/tsi/ssl_transport_security_util.h,"@@ -0,0 +1,144 @@+/*+ *+ * Copyright 2015 gRPC authors.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ *     http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ *+ */++#ifndef GRPC_CORE_TSI_SSL_TRANSPORT_SECURITY_UTIL_H_+#define GRPC_CORE_TSI_SSL_TRANSPORT_SECURITY_UTIL_H_++#include <grpc/support/port_platform.h>++#include <openssl/x509.h>++#include ""absl/strings/string_view.h""++#include <grpc/grpc_security_constants.h>++#include ""src/core/tsi/ssl/key_logging/ssl_key_logging.h""+#include ""src/core/tsi/transport_security_interface.h""++// Converts an SSL error status code to a readable string.+//+// error: the SSL error status code.+//+// return: the corresponding status string.+const char* ssl_error_string(int error);++// Logs the SSL error stack.+void log_ssl_error_stack(void);++// Performs an SSL_write and handle errors.+//+// ssl: the SSL object to write to.+// unprotected_bytes: the buffer containing the bytes for writing to |ssl|.+// unprotected_bytes_size: the size of the buffer |unprotected_bytes|.+//+// return: TSI_OK if the write operation succeeds or corresponding TSI errors.+tsi_result do_ssl_write(SSL* ssl, unsigned char* unprotected_bytes,+                        size_t unprotected_bytes_size);++// Performs an SSL_read and handle errors.+//+// ssl: the SSL object to read from.+// unprotected_bytes: the buffer to which this function will populate the read+//                    result from |ssl|.+// unprotected_bytes_size: the maximum size of the buffer |unprotected_bytes|.+//                         This will be populated with the size of the bytes+//                         read from |ssl| if this function returns TSI_OK.+//+// return: TSI_OK if the write operation succeeds or corresponding TSI errors.+tsi_result do_ssl_read(SSL* ssl, unsigned char* unprotected_bytes,+                       size_t* unprotected_bytes_size);++// Builds a maximum-size TLS frame if there is enough (|buffer_offset| ++// |unprotected_bytes_size| >= |buffers_size|) data. Otherwise it copies the","The total_size in your comment refers to the size that's needed to build a TLS frame. Let me explain it by an example: say we need 10 bytes of data to build a TLS frame (so the buffer_size is 10) and there's already 8 bytes in the buffer (offset = 8). The user/caller passes another 7 bytes of data (input data size = 7) into `ssl_protector_protect_util` function. Then this function will take 2 bytes and send 10 bytes to build a TLS frame. It also updates the `unprotected_bytes_size` with the bytes consumed (i.e., 2). So the caller knows that 2 bytes out of the 7 bytes that the caller passes to the function are consumed. Next time the caller should pass the remaining 5 bytes, and this function will copy all of them to the inner buffer.",
17583509,zeromath,https://api.github.com/repos/grpc/grpc/pulls/29728,903138680,2022-06-21T23:07:00Z,test/core/tsi/ssl_transport_security_util_test.cc,"@@ -0,0 +1,353 @@+//+// Copyright 2021 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+//++#include ""src/core/tsi/ssl_transport_security_util.h""++#include <string>+#include <vector>++#include <gmock/gmock.h>+#include <gtest/gtest.h>+#include <openssl/bio.h>+#include <openssl/crypto.h>+#include <openssl/ssl.h>++#include ""absl/status/status.h""+#include ""absl/status/statusor.h""+#include ""absl/strings/match.h""+#include ""absl/strings/string_view.h""++#include ""src/core/tsi/transport_security.h""+#include ""src/core/tsi/transport_security_interface.h""+#include ""test/core/util/test_config.h""++namespace grpc_core {+namespace testing {++using ::testing::ContainerEq;+using ::testing::NotNull;+using ::testing::Test;+using ::testing::TestWithParam;+using ::testing::ValuesIn;++constexpr std::size_t kMaxPlaintextBytesPerTlsRecord = 16384;+constexpr std::size_t kTls13RecordOverhead = 22;++// Used for debugging.+int VerifySucceed(X509_STORE_CTX* store_ctx, void* arg) { return 1; }++absl::Status DoHandshake(SSL** out_client, SSL** out_server) {+  if (out_client == nullptr || out_server == nullptr) {+    return absl::InvalidArgumentError(+        ""Client and server SSL object must not be null."");+  }+  std::string cert_pem =+      ""-----BEGIN CERTIFICATE-----\n""+      ""MIICZzCCAdCgAwIBAgIIN18/ctj3wpAwDQYJKoZIhvcNAQELBQAwKjEXMBUGA1UE\n""+      ""ChMOR29vZ2xlIFRFU1RJTkcxDzANBgNVBAMTBnRlc3RDQTAeFw0xNTAxMDEwMDAw\n""+      ""MDBaFw0yNTAxMDEwMDAwMDBaMC8xFzAVBgNVBAoTDkdvb2dsZSBURVNUSU5HMRQw\n""+      ""EgYDVQQDDAt0ZXN0X2NlcnRfMTCBnzANBgkqhkiG9w0BAQEFAAOBjQAwgYkCgYEA\n""+      ""20oOyI+fNCCeHJ3DNjGooPPP43Q6emhVvuWD8ppta582Rgxq/4j1bl9cPHdoCdyy\n""+      ""HsWFVUZzscj2qhClmlBAMEA595OU2NX2d81nSih5dwZWLMRQkEIzyxUR7Vee3eyo\n""+      ""nQD4HSamaevMSv79WTUBCozEGITqWnjYA152KUbA/IsCAwEAAaOBkDCBjTAOBgNV\n""+      ""HQ8BAf8EBAMCBaAwHQYDVR0lBBYwFAYIKwYBBQUHAwEGCCsGAQUFBwMCMAwGA1Ud\n""+      ""EwEB/wQCMAAwGQYDVR0OBBIEECnFWP/UkDrV+SoXra58k64wGwYDVR0jBBQwEoAQ\n""+      ""p7JSbajiTZaIRUDSV1C81jAWBgNVHREEDzANggt0ZXN0X2NlcnRfMTANBgkqhkiG\n""+      ""9w0BAQsFAAOBgQCpJJssfN62T3G5z+5SBB+9KCzXnGxcTHtaTJkb04KLe+19EwhV\n""+      ""yRY4lZadKHjcNS6GCBogd069wNFUVYOU9VI7uUiEPdcTO+VRV5MYW0wjSi1zlkBZ\n""+      ""e8OAfYVeGUMfvThFpJ41f8vZ6GHgg95Lwv+Zh89SL8g1J3RWll9YVG8HWw==\n""+      ""-----END CERTIFICATE-----\n"";+  std::string key_pem =+      ""-----BEGIN RSA PRIVATE KEY-----\n""+      ""MIICXQIBAAKBgQDbSg7Ij580IJ4cncM2Maig88/jdDp6aFW+5YPymm1rnzZGDGr/\n""+      ""iPVuX1w8d2gJ3LIexYVVRnOxyPaqEKWaUEAwQDn3k5TY1fZ3zWdKKHl3BlYsxFCQ\n""+      ""QjPLFRHtV57d7KidAPgdJqZp68xK/v1ZNQEKjMQYhOpaeNgDXnYpRsD8iwIDAQAB\n""+      ""AoGAbq4kZApJeo/z/dGK0/GggQxOIylo0puSm7VQMcTL8YP8asKdxrgj2D99WG+U\n""+      ""LVYc+PcM4wuaHWOnTBL24roaitCNhrpIsJfWDkexzHXMj622SYlUcCuwsfjYOEyw\n""+      ""ntoNAnh0o4S+beYAfzT5VHCh4is9G9u+mwKYiGpJXROrYUECQQD4eq4nuGq3mfYJ\n""+      ""B0+md30paDVVCyBsuZTAtnu3MbRjMXy5LLE+vhno5nocvVSTOv3QC7Wk6yAa8/bG\n""+      ""iPT/MWixAkEA4e0zqPGo8tSimVv/1ei8Chyb+YqdSx+Oj5eZpa6X/KB/C1uS1tm6\n""+      ""DTgHW2GUhV4ypqdGH+t8quprJUtFuzqH+wJBAMRiicSg789eouMt4RjrdYPFdela\n""+      ""Gu1zm4rYb10xrqV7Vl0wYoH5U5cMmdSfGvomdLX6mzzWDJDg4ti1JBWRonECQQCD\n""+      ""Umtq0j1QGQUCe5Vz8zoJ7qNDI61WU1t8X7Rxt9CkiW4PXgU2WYxpzp2IImpAM4bh\n""+      ""k+2Q9EKc3nG1VdGMiPMtAkARkQF+pL8SBrUoh8G8glCam0brh3tW/cdW8L4UGTNF\n""+      ""2ZKC/LFH6DQBjYs3UXjvMGJxz4k9LysyY6o2Nf1JG6/L\n""+      ""-----END RSA PRIVATE KEY-----\n"";++  // Create the context objects.+  SSL_CTX* client_ctx(SSL_CTX_new(TLS_method()));+  SSL_CTX* server_ctx(SSL_CTX_new(TLS_method()));++  BIO* client_cert_bio(BIO_new_mem_buf(cert_pem.c_str(), cert_pem.size()));+  X509* client_cert = PEM_read_bio_X509(client_cert_bio, /*x=*/nullptr,+                                        /*cb=*/nullptr, /*u=*/nullptr);+  BIO* client_key_bio(BIO_new_mem_buf(key_pem.c_str(), key_pem.size()));+  EVP_PKEY* client_key = PEM_read_bio_PrivateKey(client_key_bio, /*x=*/nullptr,+                                                 /*cb=*/nullptr, /*u=*/nullptr);++  BIO* server_cert_bio(BIO_new_mem_buf(cert_pem.c_str(), cert_pem.size()));+  X509* server_cert = PEM_read_bio_X509(server_cert_bio, /*x=*/nullptr,+                                        /*cb=*/nullptr, /*u=*/nullptr);+  BIO* server_key_bio(BIO_new_mem_buf(key_pem.c_str(), key_pem.size()));+  EVP_PKEY* server_key = PEM_read_bio_PrivateKey(server_key_bio, /*x=*/nullptr,+                                                 /*cb=*/nullptr, /*u=*/nullptr);++  // Set both client and server certificate and private key.+  SSL_CTX_use_certificate(client_ctx, client_cert);+  SSL_CTX_use_PrivateKey(client_ctx, client_key);+  SSL_CTX_use_certificate(server_ctx, server_cert);+  SSL_CTX_use_PrivateKey(server_ctx, server_key);++  EVP_PKEY_free(client_key);+  BIO_free(client_key_bio);+  X509_free(client_cert);+  BIO_free(client_cert_bio);++  EVP_PKEY_free(server_key);+  BIO_free(server_key_bio);+  X509_free(server_cert);+  BIO_free(server_cert_bio);++  // Configure both client and server to request (and accept any)+  // certificate but fail if none is sent.+  SSL_CTX_set_verify(client_ctx,+                     SSL_VERIFY_PEER | SSL_VERIFY_FAIL_IF_NO_PEER_CERT,+                     /*callback=*/nullptr);+  SSL_CTX_set_cert_verify_callback(client_ctx, VerifySucceed,+                                   /*arg=*/nullptr);+  SSL_CTX_set_verify(server_ctx,+                     SSL_VERIFY_PEER | SSL_VERIFY_FAIL_IF_NO_PEER_CERT,+                     /*callback=*/nullptr);+  SSL_CTX_set_cert_verify_callback(server_ctx, VerifySucceed,+                                   /*arg=*/nullptr);++  // Turns off the session caching.+  SSL_CTX_set_session_cache_mode(client_ctx, SSL_SESS_CACHE_OFF);+  SSL_CTX_set_session_cache_mode(server_ctx, SSL_SESS_CACHE_OFF);++  // Set both the min and max TLS version to 1.3+  SSL_CTX_set_min_proto_version(client_ctx, TLS1_3_VERSION);+  SSL_CTX_set_min_proto_version(server_ctx, TLS1_3_VERSION);+  SSL_CTX_set_max_proto_version(client_ctx, TLS1_3_VERSION);+  SSL_CTX_set_max_proto_version(server_ctx, TLS1_3_VERSION);++  // Create client and server connection objects and configure their BIOs.+  SSL* client(SSL_new(client_ctx));+  SSL* server(SSL_new(server_ctx));++  SSL_CTX_free(client_ctx);+  SSL_CTX_free(server_ctx);++  // Turns off issuance of session tickets by servers.+  SSL_set_options(client, SSL_OP_NO_TICKET);+  SSL_set_options(server, SSL_OP_NO_TICKET);++  SSL_set_connect_state(client);+  SSL_set_accept_state(server);+  BIO* bio1;+  BIO* bio2;+  BIO_new_bio_pair(&bio1, /*writebuf1=*/0, &bio2, /*writebuf2=*/0);+  SSL_set_bio(client, bio1, bio1);+  SSL_set_bio(server, bio2, bio2);++  // Drive both the client and server handshake operations to completion.+  while (true) {+    int client_ret = SSL_do_handshake(client);+    int client_err = SSL_get_error(client, client_ret);+    if (client_err != SSL_ERROR_NONE && client_err != SSL_ERROR_WANT_READ &&+        client_err != SSL_ERROR_WANT_WRITE &&+        client_err != SSL_ERROR_PENDING_TICKET) {+      return absl::InternalError(+          absl::StrCat(""Client error:"", SSL_error_description(client_err)));+    }++    int server_ret = SSL_do_handshake(server);+    int server_err = SSL_get_error(server, server_ret);+    if (server_err != SSL_ERROR_NONE && server_err != SSL_ERROR_WANT_READ &&+        server_err != SSL_ERROR_WANT_WRITE &&+        server_err != SSL_ERROR_PENDING_TICKET) {+      return absl::InternalError(+          absl::StrCat(""Server error:"", SSL_error_description(server_err)));+    }+    if (client_ret == 1 && server_ret == 1) {+      break;+    }+  }++  *out_client = client;+  *out_server = server;++  return absl::OkStatus();+}++std::size_t CalculateRecordSizeFromHeader(uint8_t fourth_header_byte,+                                          uint8_t fifth_header_byte) {+  return (static_cast<int>(fourth_header_byte & 0xff) << 8) ++         static_cast<int>(fifth_header_byte & 0xff);+}++struct FrameProtectorUtilTestData {+  std::size_t plaintext_size;+  std::size_t expected_encrypted_bytes_size;+};++// Generates the testing data |FrameProtectorUtilTestData|.+std::vector<FrameProtectorUtilTestData> GenerateTestData() {+  std::vector<FrameProtectorUtilTestData> data;+  for (std::size_t plaintext_size : {1, 1000, 16384, 17000}) {","They are chosen such that the first is almost zero, the second is something between zero and `kMaxPlaintextBytesPerTlsRecord`, and the last one is larger than `kMaxPlaintextBytesPerTlsRecord`.",
2793282,veblush,https://api.github.com/repos/grpc/grpc/pulls/30047,903154748,2022-06-21T23:45:09Z,test/cpp/server/server_request_call_test.cc,"@@ -135,7 +135,15 @@ TEST(ServerRequestCallTest, ShortDeadlineDoesNotCauseOkayFalse) {     ctx.set_deadline(std::chrono::system_clock::now() +                      std::chrono::milliseconds(1));     grpc::Status status = stub->Echo(&ctx, request, &response);-    EXPECT_EQ(StatusCode::DEADLINE_EXCEEDED, status.error_code());+    if (i == 0 && status.error_code() == grpc::OK) {+      // This first call may take more time to trigger a deadline excceded","As the comment say, it's because it takes longer time in Bazel-RBE environment (which doesn't have a strong machine to run the test) for the first call. This is because absl::Status uses a heap unlike grpc_error (which uses bespoke arena) and it has to take longer time to initialize it.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/30047,903157484,2022-06-21T23:52:16Z,test/cpp/server/server_request_call_test.cc,"@@ -135,7 +135,15 @@ TEST(ServerRequestCallTest, ShortDeadlineDoesNotCauseOkayFalse) {     ctx.set_deadline(std::chrono::system_clock::now() +                      std::chrono::milliseconds(1));     grpc::Status status = stub->Echo(&ctx, request, &response);-    EXPECT_EQ(StatusCode::DEADLINE_EXCEEDED, status.error_code());+    if (i == 0 && status.error_code() == grpc::OK) {+      // This first call may take more time to trigger a deadline excceded","I don't understand that explanation.  Regardless of how long it takes to allocate the `absl::Status`, that should not affect the outcome of this test.  What exact sequence of events is leading to this outcome?  Where is the `absl::Status` being allocated, and why does that prevent the deadline timer from firing on time?In principle, I think it should not be possible for this to get an OK status, because the server's response will never come before the deadline is exceeded.  If we are somehow returning OK in a case where we should be returning DEADLINE_EXCEEDED due to the `absl::Status` not being initialized when it should be, then this is a fairly serious bug, and we need to fix that bug instead of changing the test to accept the buggy output.",
2793282,veblush,https://api.github.com/repos/grpc/grpc/pulls/30047,903959478,2022-06-22T16:05:33Z,test/cpp/server/server_request_call_test.cc,"@@ -135,7 +135,15 @@ TEST(ServerRequestCallTest, ShortDeadlineDoesNotCauseOkayFalse) {     ctx.set_deadline(std::chrono::system_clock::now() +                      std::chrono::milliseconds(1));     grpc::Status status = stub->Echo(&ctx, request, &response);-    EXPECT_EQ(StatusCode::DEADLINE_EXCEEDED, status.error_code());+    if (i == 0 && status.error_code() == grpc::OK) {+      // This first call may take more time to trigger a deadline excceded","This is how it's supposed to happen.1. Client sends a call with 1ms deadline. (Set a timer for a deadline)2. Sever receives a call and waits for 50ms and returns OK.3. Deadline timer fires and passing DEADLINE_EXCEEDED. 4. Client receives DEADLINE_EXCEEDED.If the 3rd step takes longer (> 50ms), client will receive OK. That's why it happens to have OK. Again this test is pretty sensitive to timing and RBE environment doesn't assign a strong machine to it. `absl::Status` takes longer time when creating non-OK status (one of reasons is to use a heap) and heap needs time to expand in this case to store additional metadata in the status.",
4181124,yashykt,https://api.github.com/repos/grpc/grpc/pulls/29870,904111058,2022-06-22T18:35:20Z,src/core/ext/filters/client_channel/lb_policy/rls/rls.cc,"@@ -1192,46 +1192,44 @@ size_t RlsLb::Cache::Entry::Size() const { }  LoadBalancingPolicy::PickResult RlsLb::Cache::Entry::Pick(PickArgs args) {-  for (const auto& child_policy_wrapper : child_policy_wrappers_) {+  size_t i = 0;+  ChildPolicyWrapper* child_policy_wrapper = nullptr;+  // Skip targets before the last one that are in state TRANSIENT_FAILURE.+  for (; i < child_policy_wrappers_.size(); ++i) {+    child_policy_wrapper = child_policy_wrappers_[i].get();     if (child_policy_wrapper->connectivity_state() ==-        GRPC_CHANNEL_TRANSIENT_FAILURE) {+            GRPC_CHANNEL_TRANSIENT_FAILURE &&+        i < child_policy_wrappers_.size() - 1) {       if (GRPC_TRACE_FLAG_ENABLED(grpc_lb_rls_trace)) {         gpr_log(GPR_INFO,-                ""[rlslb %p] cache entry=%p %s: target %s in state ""-                ""TRANSIENT_FAILURE; skipping"",+                ""[rlslb %p] cache entry=%p %s: target %s (%"" PRIuPTR+                "" of %"" PRIuPTR "") in state TRANSIENT_FAILURE; skipping"",                 lb_policy_.get(), this, lru_iterator_->ToString().c_str(),-                child_policy_wrapper->target().c_str());+                child_policy_wrapper->target().c_str(), i,+                child_policy_wrappers_.size());       }       continue;     }-    // Child policy not in TRANSIENT_FAILURE, so delegate.-    if (GRPC_TRACE_FLAG_ENABLED(grpc_lb_rls_trace)) {-      gpr_log(-          GPR_INFO,-          ""[rlslb %p] cache entry=%p %s: target %s in state %s; ""-          ""delegating"",-          lb_policy_.get(), this, lru_iterator_->ToString().c_str(),-          child_policy_wrapper->target().c_str(),-          ConnectivityStateName(child_policy_wrapper->connectivity_state()));-    }-    // Add header data.-    if (!header_data_.empty()) {-      char* copied_header_data =-          static_cast<char*>(args.call_state->Alloc(header_data_.length() + 1));-      strcpy(copied_header_data, header_data_.c_str());-      args.initial_metadata->Add(kRlsHeaderKey, copied_header_data);-    }-    return child_policy_wrapper->Pick(args);   }-  // No child policy found.+  // Child policy not in TRANSIENT_FAILURE or is the last target in+  // the list, so delegate.   if (GRPC_TRACE_FLAG_ENABLED(grpc_lb_rls_trace)) {     gpr_log(GPR_INFO,-            ""[rlslb %p] cache entry=%p %s: no healthy target found; ""-            ""failing pick"",-            lb_policy_.get(), this, lru_iterator_->ToString().c_str());-  }-  return PickResult::Fail(-      absl::UnavailableError(""all RLS targets unreachable""));+            ""[rlslb %p] cache entry=%p %s: target %s (%"" PRIuPTR "" of %"" PRIuPTR+            "") in state %s; delegating"",+            lb_policy_.get(), this, lru_iterator_->ToString().c_str(),+            child_policy_wrapper->target().c_str(), i,+            child_policy_wrappers_.size(),+            ConnectivityStateName(child_policy_wrapper->connectivity_state()));+  }+  // Add header data.",is adding this header data useful even if we are in TRANSIENT_FAILURE?,
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/29870,904138724,2022-06-22T19:10:30Z,src/core/ext/filters/client_channel/lb_policy/rls/rls.cc,"@@ -1192,46 +1192,44 @@ size_t RlsLb::Cache::Entry::Size() const { }  LoadBalancingPolicy::PickResult RlsLb::Cache::Entry::Pick(PickArgs args) {-  for (const auto& child_policy_wrapper : child_policy_wrappers_) {+  size_t i = 0;+  ChildPolicyWrapper* child_policy_wrapper = nullptr;+  // Skip targets before the last one that are in state TRANSIENT_FAILURE.+  for (; i < child_policy_wrappers_.size(); ++i) {+    child_policy_wrapper = child_policy_wrappers_[i].get();     if (child_policy_wrapper->connectivity_state() ==-        GRPC_CHANNEL_TRANSIENT_FAILURE) {+            GRPC_CHANNEL_TRANSIENT_FAILURE &&+        i < child_policy_wrappers_.size() - 1) {       if (GRPC_TRACE_FLAG_ENABLED(grpc_lb_rls_trace)) {         gpr_log(GPR_INFO,-                ""[rlslb %p] cache entry=%p %s: target %s in state ""-                ""TRANSIENT_FAILURE; skipping"",+                ""[rlslb %p] cache entry=%p %s: target %s (%"" PRIuPTR+                "" of %"" PRIuPTR "") in state TRANSIENT_FAILURE; skipping"",                 lb_policy_.get(), this, lru_iterator_->ToString().c_str(),-                child_policy_wrapper->target().c_str());+                child_policy_wrapper->target().c_str(), i,+                child_policy_wrappers_.size());       }       continue;","Doh!  Thanks for catching this.  The problem was actually a missing ""break"" at the end of the loop body, and the fact that it was missing was a serious bug, because it meant that we would always use the last target in the list, even if the earlier targets were not in state TRANSIENT_FAILURE.I've fixed this and added a test to catch the problem.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/29870,904145365,2022-06-22T19:19:21Z,src/core/ext/filters/client_channel/lb_policy/rls/rls.cc,"@@ -1192,46 +1192,44 @@ size_t RlsLb::Cache::Entry::Size() const { }  LoadBalancingPolicy::PickResult RlsLb::Cache::Entry::Pick(PickArgs args) {-  for (const auto& child_policy_wrapper : child_policy_wrappers_) {+  size_t i = 0;+  ChildPolicyWrapper* child_policy_wrapper = nullptr;+  // Skip targets before the last one that are in state TRANSIENT_FAILURE.+  for (; i < child_policy_wrappers_.size(); ++i) {+    child_policy_wrapper = child_policy_wrappers_[i].get();     if (child_policy_wrapper->connectivity_state() ==-        GRPC_CHANNEL_TRANSIENT_FAILURE) {+            GRPC_CHANNEL_TRANSIENT_FAILURE &&+        i < child_policy_wrappers_.size() - 1) {       if (GRPC_TRACE_FLAG_ENABLED(grpc_lb_rls_trace)) {         gpr_log(GPR_INFO,-                ""[rlslb %p] cache entry=%p %s: target %s in state ""-                ""TRANSIENT_FAILURE; skipping"",+                ""[rlslb %p] cache entry=%p %s: target %s (%"" PRIuPTR+                "" of %"" PRIuPTR "") in state TRANSIENT_FAILURE; skipping"",                 lb_policy_.get(), this, lru_iterator_->ToString().c_str(),-                child_policy_wrapper->target().c_str());+                child_policy_wrapper->target().c_str(), i,+                child_policy_wrappers_.size());       }       continue;     }-    // Child policy not in TRANSIENT_FAILURE, so delegate.-    if (GRPC_TRACE_FLAG_ENABLED(grpc_lb_rls_trace)) {-      gpr_log(-          GPR_INFO,-          ""[rlslb %p] cache entry=%p %s: target %s in state %s; ""-          ""delegating"",-          lb_policy_.get(), this, lru_iterator_->ToString().c_str(),-          child_policy_wrapper->target().c_str(),-          ConnectivityStateName(child_policy_wrapper->connectivity_state()));-    }-    // Add header data.-    if (!header_data_.empty()) {-      char* copied_header_data =-          static_cast<char*>(args.call_state->Alloc(header_data_.length() + 1));-      strcpy(copied_header_data, header_data_.c_str());-      args.initial_metadata->Add(kRlsHeaderKey, copied_header_data);-    }-    return child_policy_wrapper->Pick(args);   }-  // No child policy found.+  // Child policy not in TRANSIENT_FAILURE or is the last target in+  // the list, so delegate.   if (GRPC_TRACE_FLAG_ENABLED(grpc_lb_rls_trace)) {     gpr_log(GPR_INFO,-            ""[rlslb %p] cache entry=%p %s: no healthy target found; ""-            ""failing pick"",-            lb_policy_.get(), this, lru_iterator_->ToString().c_str());-  }-  return PickResult::Fail(-      absl::UnavailableError(""all RLS targets unreachable""));+            ""[rlslb %p] cache entry=%p %s: target %s (%"" PRIuPTR "" of %"" PRIuPTR+            "") in state %s; delegating"",+            lb_policy_.get(), this, lru_iterator_->ToString().c_str(),+            child_policy_wrapper->target().c_str(), i,+            child_policy_wrappers_.size(),+            ConnectivityStateName(child_policy_wrapper->connectivity_state()));+  }+  // Add header data.","Two things here.First, we don't actually know whether or not we're in TRANSIENT_FAILURE here.  The loop above stops at either the first target that is *not* in TF or at the last target in the list, regardless of whether or not it is in TF.  If the target is not in TF, then we definitely want to add this header, because we want the header to be sent to the backend.Which brings to me to the second point, which is that even if the target is in TF, the pick could conceivably still succeed, because the picker's behavior is not strictly tied to the overall connectivity state.  In all of the common cases, the picker behavior is consistent with the overall connectivity state; for example, in pick_first and round_robin, any time they report state TF, they return a picker that will fail all RPCs.  But there are also policies like ring_hash, where the reported connectivity state is really more of a hueristic, and the actual picker behavior really depends on a property of the RPC itself.  So in general, if we're going to delegate to a child picker, we want to give it all of the info it would need for the pick to succeed, so that it can do the right thing based on which policy it is.",
2793282,veblush,https://api.github.com/repos/grpc/grpc/pulls/30047,904218966,2022-06-22T20:55:30Z,test/cpp/server/server_request_call_test.cc,"@@ -135,7 +135,15 @@ TEST(ServerRequestCallTest, ShortDeadlineDoesNotCauseOkayFalse) {     ctx.set_deadline(std::chrono::system_clock::now() +                      std::chrono::milliseconds(1));     grpc::Status status = stub->Echo(&ctx, request, &response);-    EXPECT_EQ(StatusCode::DEADLINE_EXCEEDED, status.error_code());+    if (i == 0 && status.error_code() == grpc::OK) {+      // This first call may take more time to trigger a deadline excceded",Yeah it would work too. Having a longer delay on the service side worked so it could be a solution. Just want to make sure whether it's required here or not to have a relative short delay (50ms). @markdroth,
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/30047,904289569,2022-06-22T22:20:21Z,test/cpp/server/server_request_call_test.cc,"@@ -135,7 +135,15 @@ TEST(ServerRequestCallTest, ShortDeadlineDoesNotCauseOkayFalse) {     ctx.set_deadline(std::chrono::system_clock::now() +                      std::chrono::milliseconds(1));     grpc::Status status = stub->Echo(&ctx, request, &response);-    EXPECT_EQ(StatusCode::DEADLINE_EXCEEDED, status.error_code());+    if (i == 0 && status.error_code() == grpc::OK) {+      // This first call may take more time to trigger a deadline excceded",I agree that increasing the delay is a better solution.  The purpose of this test is to show that a short deadline does not cause ok=false.  We can't prove that if the deadline timer does not fire before the RPC completes.,
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/30001,904336722,2022-06-22T22:28:22Z,src/core/ext/filters/client_channel/lb_policy/ring_hash/ring_hash.cc,"@@ -646,8 +652,17 @@ void RingHash::RingHashSubchannelList::UpdateRingHashConnectivityStateLocked(     state = GRPC_CHANNEL_TRANSIENT_FAILURE;     start_connection_attempt = true;   }-  // Pass along status only in TRANSIENT_FAILURE.-  if (state != GRPC_CHANNEL_TRANSIENT_FAILURE) status = absl::OkStatus();+  // In TRANSIENT_FAILURE, report the last reported failure.+  // Otherwise, report OK.+  if (state == GRPC_CHANNEL_TRANSIENT_FAILURE) {+    if (!status.ok()) {+      last_failure_ = absl::UnavailableError(absl::StrCat(+          ""no reachable subchannels; last error: "", status.ToString()));+    }+    status = last_failure_;+  } else {+    status = absl::OkStatus();","No, subchannels never report SHUTDOWN.  The underlying ConnectedSubchannel does report SHUTDOWN, but in that case, the subchannel reports IDLE.https://github.com/grpc/grpc/blob/86e282ba9792da83a11ac1ec03074ccc92e6d1aa/src/core/ext/filters/client_channel/subchannel.cc#L331",
2811396,ejona86,https://api.github.com/repos/grpc/grpc/pulls/30034,905179941,2022-06-23T15:38:01Z,doc/interop-test-descriptions.md,"@@ -1104,34 +1106,38 @@ test load report.     ```  The call carries a reference to receive the load report, e.g. using CallOptions.-The reference is passed to the custom LB policy as part of the `OrcaPerRequestReportListener` API.+The reference is passed to the custom LB policy as part of the +`OrcaPerRequestReportListener` API.  Client asserts: * The call is successful.-* The per-query load report reference contains a metrics report that is identical to the metrics-data sent in the request shown above. +* The per-query load report reference contains a metrics report that is +identical to the metrics data sent in the request shown above.   ### orca_oob -The client verifies that a custom LB policy, which is integrated with ORCA APIs, will receive -out-of-band metric reports from the backend.--The client will register the custom LB policy named `test_backend_metrics_load_balancer`. It has-similar and additional functions as described in the [orca_per_rpc][] test. -We use ORCA APIs to install an out-of-band report listener (configure load report interval to be 1s)-in the LB policy. The interop-testing client will run with a service config to select the load -balancing config(using argument `--service_config_json`), so that it effectively uses this newly -registered custom LB policy. A load report reference can be passed from the call to the LB policy -through, e.g. CallOptions, to receive metric reports.-The test framework will fill in the reference with the latest load report from the report listener.-This way, together with server behaviors we can verify the expected metric reports are received.+The client verifies that a custom LB policy, which is integrated with ORCA APIs, +will receive out-of-band metric reports from the backend.++The client will register the custom LB policy named +`test_backend_metrics_load_balancer`. It has similar and additional functions as+described in the [orca_per_rpc][] test. We use ORCA APIs to install an +out-of-band report listener (configure load report interval to be 1s) in the LB +policy. The interop-testing client will run with a service config to select the +load balancing config(using argument `--service_config_json`), so that it +effectively uses this newly registered custom LB policy. A load report reference+can be passed from the call to the LB policy through, e.g. CallOptions, to +receive metric reports. The test framework will fill in the reference with the +latest load report from the report listener. This way, together with server +behaviors we can verify the expected metric reports are received.  Server features: * [UnaryCall][]+* [FullDuplexCall][] * [Backend Metrics Report][]  Procedures:-* Client sends a unary call to the server. The call request sets `orca_oob_report` to a test load report.+1. Client starts a bidi-streaming and sends: ","s/bidi-streaming/full duplex call/. We're talking about a specific method, so it'd be fine to call it FullDuplexCall. The point is this needs to be specific enough so that it is clear which method needs to be called. HalfDuplexCall is also bidi-streaming. (Yes, you can infer that it isn't HalfDuplexCall from the list of server features, but still.)",X
2811396,ejona86,https://api.github.com/repos/grpc/grpc/pulls/30034,905184552,2022-06-23T15:40:46Z,doc/interop-test-descriptions.md,"@@ -1125,13 +1125,17 @@ registered custom LB policy. A load report reference can be passed from the call through, e.g. CallOptions, to receive metric reports. The test framework will fill in the reference with the latest load report from the report listener. This way, together with server behaviors we can verify the expected metric reports are received.+Note that this test client includes multiple verification steps that requires the server to keep the states.+Therefore, server side is required to have the capability of allowing only one client to perform the +`orca_oob` test case at a time, using a lock, see server features below.  Server features: * [UnaryCall][]+* [FullDuplexCall][] * [Backend Metrics Report][]  Procedures:-* Client sends a unary call to the server. The call request sets `orca_oob_report` to a test load report.+1. Client starts a bidi-streaming call to the server. In the first message the request sets `orca_oob_report` to a test load report.     ```     {       orca_oob_report:{","This was marked resolved, but it doesn't seem resolved. This comment is talking about https://github.com/grpc/grpc-java/blob/69abec5a2881afe5525f45ffdbd8f4fb23cc53ff/interop-testing/src/main/java/io/grpc/testing/integration/AbstractInteropTest.java#L1798",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/30008,905200822,2022-06-23T15:54:17Z,src/core/ext/filters/client_channel/subchannel.cc,"@@ -584,69 +583,55 @@ Subchannel::ConnectivityStateWatcherInterface::PopConnectivityStateChange() {  namespace { -BackOff::Options ParseArgsForBackoffValues(const grpc_channel_args* args,+BackOff::Options ParseArgsForBackoffValues(const ChannelArgs& args,                                            Duration* min_connect_timeout) {-  Duration initial_backoff =-      Duration::Seconds(GRPC_SUBCHANNEL_INITIAL_CONNECT_BACKOFF_SECONDS);+  const absl::optional<Duration> fixed_reconnect_backoff =+      args.GetDurationFromIntMillis(""grpc.testing.fixed_reconnect_backoff_ms"");+  if (fixed_reconnect_backoff.has_value()) {+    const Duration backoff =+        std::max(Duration::Milliseconds(100), *fixed_reconnect_backoff);+    *min_connect_timeout = backoff;+    return BackOff::Options()+        .set_initial_backoff(backoff)+        .set_multiplier(1.0)+        .set_jitter(0.0)+        .set_max_backoff(backoff);+  }+  const Duration initial_backoff = std::max(+      Duration::Milliseconds(100),+      args.GetDurationFromIntMillis(GRPC_ARG_INITIAL_RECONNECT_BACKOFF_MS)+          .value_or(Duration::Seconds(+              GRPC_SUBCHANNEL_INITIAL_CONNECT_BACKOFF_SECONDS)));   *min_connect_timeout =-      Duration::Seconds(GRPC_SUBCHANNEL_RECONNECT_MIN_TIMEOUT_SECONDS);-  Duration max_backoff =-      Duration::Seconds(GRPC_SUBCHANNEL_RECONNECT_MAX_BACKOFF_SECONDS);-  bool fixed_reconnect_backoff = false;-  if (args != nullptr) {-    for (size_t i = 0; i < args->num_args; i++) {-      if (0 == strcmp(args->args[i].key,-                      ""grpc.testing.fixed_reconnect_backoff_ms"")) {-        fixed_reconnect_backoff = true;-        initial_backoff = *min_connect_timeout = max_backoff =-            Duration::Milliseconds(grpc_channel_arg_get_integer(-                &args->args[i],-                {static_cast<int>(initial_backoff.millis()), 100, INT_MAX}));-      } else if (0 ==-                 strcmp(args->args[i].key, GRPC_ARG_MIN_RECONNECT_BACKOFF_MS)) {-        fixed_reconnect_backoff = false;-        *min_connect_timeout =-            Duration::Milliseconds(grpc_channel_arg_get_integer(-                &args->args[i],-                {static_cast<int>(min_connect_timeout->millis()), 100,-                 INT_MAX}));-      } else if (0 ==-                 strcmp(args->args[i].key, GRPC_ARG_MAX_RECONNECT_BACKOFF_MS)) {-        fixed_reconnect_backoff = false;-        max_backoff = Duration::Milliseconds(grpc_channel_arg_get_integer(-            &args->args[i],-            {static_cast<int>(max_backoff.millis()), 100, INT_MAX}));-      } else if (0 == strcmp(args->args[i].key,-                             GRPC_ARG_INITIAL_RECONNECT_BACKOFF_MS)) {-        fixed_reconnect_backoff = false;-        initial_backoff = Duration::Milliseconds(grpc_channel_arg_get_integer(-            &args->args[i],-            {static_cast<int>(initial_backoff.millis()), 100, INT_MAX}));-      }-    }-  }+      std::max(Duration::Milliseconds(100),+               args.GetDurationFromIntMillis(GRPC_ARG_MIN_RECONNECT_BACKOFF_MS)+                   .value_or(Duration::Seconds(+                       GRPC_SUBCHANNEL_RECONNECT_MIN_TIMEOUT_SECONDS)));+  const Duration max_backoff =+      std::max(Duration::Milliseconds(100),+               args.GetDurationFromIntMillis(GRPC_ARG_MAX_RECONNECT_BACKOFF_MS)+                   .value_or(Duration::Seconds(+                       GRPC_SUBCHANNEL_RECONNECT_MAX_BACKOFF_SECONDS)));   return BackOff::Options()       .set_initial_backoff(initial_backoff)-      .set_multiplier(fixed_reconnect_backoff-                          ? 1.0-                          : GRPC_SUBCHANNEL_RECONNECT_BACKOFF_MULTIPLIER)-      .set_jitter(fixed_reconnect_backoff ? 0.0-                                          : GRPC_SUBCHANNEL_RECONNECT_JITTER)+      .set_multiplier(GRPC_SUBCHANNEL_RECONNECT_BACKOFF_MULTIPLIER)+      .set_jitter(GRPC_SUBCHANNEL_RECONNECT_JITTER)       .set_max_backoff(max_backoff); }  }  // namespace  Subchannel::Subchannel(SubchannelKey key,                        OrphanablePtr<SubchannelConnector> connector,-                       const grpc_channel_args* args)+                       ChannelArgs args)     : DualRefCounted<Subchannel>(           GRPC_TRACE_FLAG_ENABLED(grpc_trace_subchannel_refcount) ? ""Subchannel""                                                                   : nullptr),-      key_(std::move(key)),+      key_(key),",Why are we no longer doing a `std::move()` for `key`?,
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/30008,905208912,2022-06-23T16:01:47Z,src/core/ext/filters/client_channel/proxy_mapper.h,"@@ -35,18 +36,16 @@ class ProxyMapperInterface {   /// If no proxy is needed, returns false.   /// Otherwise, sets \a name_to_resolve, optionally sets \a new_args,   /// and returns true.-  virtual bool MapName(const char* server_uri, const grpc_channel_args* args,-                       char** name_to_resolve,-                       grpc_channel_args** new_args) = 0;+  virtual bool MapName(absl::string_view server_uri, ChannelArgs* args,",How about changing this to return `absl::optional<std::string>` instead of returning the string via a parameter?,X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/30008,905230643,2022-06-23T16:23:04Z,src/core/ext/filters/client_channel/client_channel.cc,"@@ -878,74 +857,39 @@ class ClientChannel::ClientChannelControlHelper                              ""ClientChannelControlHelper"");   } -  RefCountedPtr<SubchannelInterface> CreateSubchannel(-      ServerAddress address, const grpc_channel_args& args) override+  RefCountedPtr<SubchannelInterface> CreateSubchannel(ServerAddress address,+                                                      ChannelArgs args) override       ABSL_EXCLUSIVE_LOCKS_REQUIRED(*chand_->work_serializer_) {     if (chand_->resolver_ == nullptr) return nullptr;  // Shutting down.     // Determine health check service name.-    absl::optional<std::string> health_check_service_name;-    const char* health_check_service_name_arg = grpc_channel_args_find_string(-        &args, GRPC_ARG_HEALTH_CHECK_SERVICE_NAME);-    if (health_check_service_name_arg != nullptr) {-      bool inhibit_health_checking = grpc_channel_args_find_bool(-          &args, GRPC_ARG_INHIBIT_HEALTH_CHECKING, false);-      if (!inhibit_health_checking) {-        health_check_service_name = health_check_service_name_arg;-      }+    absl::optional<absl::string_view> health_check_service_name =+        args.GetString(GRPC_ARG_HEALTH_CHECK_SERVICE_NAME);+    if (health_check_service_name.has_value() &&+        !args.GetBool(GRPC_ARG_INHIBIT_HEALTH_CHECKING).value_or(false)) {",This condition looks backwards to me -- we want to reset `health_check_service_name` if we're inhibiting health checks.I think the logic here would be a bit easier to follow if written as:```absl::optional<absl::string_view> health_check_service_name;if (!args.GetBool(GRPC_ARG_INHIBIT_HEALTH_CHECKING).value_or(false)) {  health_check_service_name = args.GetString(GRPC_ARG_HEALTH_CHECK_SERVICE_NAME);}```,X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/30008,905250998,2022-06-23T16:45:15Z,src/core/lib/channel/channel_args.cc,"@@ -56,6 +56,64 @@ int PointerCompare(void* a_ptr, const grpc_arg_pointer_vtable* a_vtable,  namespace grpc_core { +ChannelArgs::ChannelArgs() = default;+ChannelArgs::~ChannelArgs() = default;+ChannelArgs::ChannelArgs(const ChannelArgs& other) = default;+ChannelArgs& ChannelArgs::operator=(const ChannelArgs& other) = default;+ChannelArgs::ChannelArgs(ChannelArgs&& other) noexcept = default;+ChannelArgs& ChannelArgs::operator=(ChannelArgs&& other) noexcept = default;++ChannelArgs::Pointer::Pointer(void* p, const grpc_arg_pointer_vtable* vtable)","Can we order this file such that all the definitions related to `ChannelArgs::Pointer` are in one place and all of the definitions related to `ChannelArgs` itself are in another place, rather than having them interspersed?  I don't care which one is first, just that we have everything for each class in one place.",X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/30008,905265385,2022-06-23T17:02:02Z,src/core/ext/filters/client_channel/client_channel.cc,"@@ -879,73 +858,38 @@ class ClientChannel::ClientChannelControlHelper   }    RefCountedPtr<SubchannelInterface> CreateSubchannel(-      ServerAddress address, const grpc_channel_args& args) override+      ServerAddress address, const grpc_core::ChannelArgs& args) override       ABSL_EXCLUSIVE_LOCKS_REQUIRED(*chand_->work_serializer_) {     if (chand_->resolver_ == nullptr) return nullptr;  // Shutting down.     // Determine health check service name.-    absl::optional<std::string> health_check_service_name;-    const char* health_check_service_name_arg = grpc_channel_args_find_string(-        &args, GRPC_ARG_HEALTH_CHECK_SERVICE_NAME);-    if (health_check_service_name_arg != nullptr) {-      bool inhibit_health_checking = grpc_channel_args_find_bool(-          &args, GRPC_ARG_INHIBIT_HEALTH_CHECKING, false);-      if (!inhibit_health_checking) {-        health_check_service_name = health_check_service_name_arg;-      }+    absl::optional<absl::string_view> health_check_service_name =+        args.GetString(GRPC_ARG_HEALTH_CHECK_SERVICE_NAME);+    if (health_check_service_name.has_value() &&+        !args.GetBool(GRPC_ARG_INHIBIT_HEALTH_CHECKING).value_or(false)) {+      health_check_service_name.reset();     }     // Construct channel args for subchannel.-    // Remove channel args that should not affect subchannel uniqueness.-    absl::InlinedVector<const char*, 4> args_to_remove = {-        GRPC_ARG_HEALTH_CHECK_SERVICE_NAME,-        GRPC_ARG_INHIBIT_HEALTH_CHECKING,-        GRPC_ARG_CHANNELZ_CHANNEL_NODE,-    };-    // Add channel args needed for the subchannel.-    absl::InlinedVector<grpc_arg, 2> args_to_add = {-        SubchannelPoolInterface::CreateChannelArg(-            chand_->subchannel_pool_.get()),-    };-    // Check if default authority arg is already set.-    const char* default_authority =-        grpc_channel_args_find_string(&args, GRPC_ARG_DEFAULT_AUTHORITY);-    // Add args from subchannel address.-    if (address.args() != nullptr) {-      for (size_t j = 0; j < address.args()->num_args; ++j) {-        grpc_arg& arg = address.args()->args[j];-        if (strcmp(arg.key, GRPC_ARG_DEFAULT_AUTHORITY) == 0) {-          // Don't add default authority arg from subchannel address if-          // it's already set at the channel level -- the value from the-          // application should take precedence over what is set by the-          // resolver.-          if (default_authority != nullptr) continue;-          default_authority = arg.value.string;-        }-        args_to_add.emplace_back(arg);-      }-    }-    // If we haven't already set the default authority arg, add it from-    // the channel.-    if (default_authority == nullptr) {-      // Remove it, just in case it's actually present but is the wrong type.-      args_to_remove.push_back(GRPC_ARG_DEFAULT_AUTHORITY);-      args_to_add.push_back(grpc_channel_arg_string_create(-          const_cast<char*>(GRPC_ARG_DEFAULT_AUTHORITY),-          const_cast<char*>(chand_->default_authority_.c_str())));-    }-    grpc_channel_args* new_args = grpc_channel_args_copy_and_add_and_remove(-        &args, args_to_remove.data(), args_to_remove.size(), args_to_add.data(),-        args_to_add.size());+    ChannelArgs subchannel_args =+        address.args()+            .UnionWith(args)","This looks like a behavior change.  Previously, if an arg was present in both `args` and `address.args()`, we'd wind up adding a duplicate, but the one from `args` would be first and would therefore win in most downstream code.  Here we've reversed that such that the one from `address.args()` would win.For most args, I'm not sure there's a strong principled reason for the current behavior, although there is certainly the risk of breaking existing code that may be depending on the current behavior.  However, this behavior is actually important for the `GRPC_ARG_DEFAULT_AUTHORITY` arg for security reasons, and the existing code was being very careful to get this right.  We need to make sure that if the application explicitly sets that arg, the value it set (in `args`) takes precedence over the value returned for the individual address by the resolver (in `address.args()`), as per #27544.  (Note that this is independent of the `SetIfNotSet()` call for this arg on line 878 below, which looks correct to me: if the arg is not present in either `args` or `address.args()`, then we need to set it from the channel's default, because it needs to be set in the subchannel stack for use by the client_authority filter.)The easiest thing to do here is probably just to change it from `address.args().UnionWith(args)` to `args.UnionWith(address.args())`.  But please also add a comment explaining that the order is important, specifically for the `GRPC_ARG_DEFAULT_AUTHORITY` arg.Also, please add a TODO assigned to me to add a test for this case.  I have no idea why I didn't do that when I originally made this change.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/30008,905268147,2022-06-23T17:05:28Z,src/core/ext/filters/client_channel/client_channel.cc,"@@ -879,73 +858,38 @@ class ClientChannel::ClientChannelControlHelper   }    RefCountedPtr<SubchannelInterface> CreateSubchannel(-      ServerAddress address, const grpc_channel_args& args) override+      ServerAddress address, const grpc_core::ChannelArgs& args) override       ABSL_EXCLUSIVE_LOCKS_REQUIRED(*chand_->work_serializer_) {     if (chand_->resolver_ == nullptr) return nullptr;  // Shutting down.     // Determine health check service name.-    absl::optional<std::string> health_check_service_name;-    const char* health_check_service_name_arg = grpc_channel_args_find_string(-        &args, GRPC_ARG_HEALTH_CHECK_SERVICE_NAME);-    if (health_check_service_name_arg != nullptr) {-      bool inhibit_health_checking = grpc_channel_args_find_bool(-          &args, GRPC_ARG_INHIBIT_HEALTH_CHECKING, false);-      if (!inhibit_health_checking) {-        health_check_service_name = health_check_service_name_arg;-      }+    absl::optional<absl::string_view> health_check_service_name =+        args.GetString(GRPC_ARG_HEALTH_CHECK_SERVICE_NAME);+    if (health_check_service_name.has_value() &&+        !args.GetBool(GRPC_ARG_INHIBIT_HEALTH_CHECKING).value_or(false)) {+      health_check_service_name.reset();     }     // Construct channel args for subchannel.-    // Remove channel args that should not affect subchannel uniqueness.-    absl::InlinedVector<const char*, 4> args_to_remove = {-        GRPC_ARG_HEALTH_CHECK_SERVICE_NAME,-        GRPC_ARG_INHIBIT_HEALTH_CHECKING,-        GRPC_ARG_CHANNELZ_CHANNEL_NODE,-    };-    // Add channel args needed for the subchannel.-    absl::InlinedVector<grpc_arg, 2> args_to_add = {-        SubchannelPoolInterface::CreateChannelArg(-            chand_->subchannel_pool_.get()),-    };-    // Check if default authority arg is already set.-    const char* default_authority =-        grpc_channel_args_find_string(&args, GRPC_ARG_DEFAULT_AUTHORITY);-    // Add args from subchannel address.-    if (address.args() != nullptr) {-      for (size_t j = 0; j < address.args()->num_args; ++j) {-        grpc_arg& arg = address.args()->args[j];-        if (strcmp(arg.key, GRPC_ARG_DEFAULT_AUTHORITY) == 0) {-          // Don't add default authority arg from subchannel address if-          // it's already set at the channel level -- the value from the-          // application should take precedence over what is set by the-          // resolver.-          if (default_authority != nullptr) continue;-          default_authority = arg.value.string;-        }-        args_to_add.emplace_back(arg);-      }-    }-    // If we haven't already set the default authority arg, add it from-    // the channel.-    if (default_authority == nullptr) {-      // Remove it, just in case it's actually present but is the wrong type.-      args_to_remove.push_back(GRPC_ARG_DEFAULT_AUTHORITY);-      args_to_add.push_back(grpc_channel_arg_string_create(-          const_cast<char*>(GRPC_ARG_DEFAULT_AUTHORITY),-          const_cast<char*>(chand_->default_authority_.c_str())));-    }-    grpc_channel_args* new_args = grpc_channel_args_copy_and_add_and_remove(-        &args, args_to_remove.data(), args_to_remove.size(), args_to_add.data(),-        args_to_add.size());+    ChannelArgs subchannel_args =+        address.args()+            .UnionWith(args)+            .SetObject(chand_->subchannel_pool_)+            // If we haven't already set the default authority arg, add it from+            // the channel.+            .SetIfUnset(GRPC_ARG_DEFAULT_AUTHORITY, chand_->default_authority_)+            // Remove channel args that should not affect subchannel uniqueness.+            .Remove(GRPC_ARG_HEALTH_CHECK_SERVICE_NAME)+            .Remove(GRPC_ARG_INHIBIT_HEALTH_CHECKING)+            .Remove(GRPC_ARG_CHANNELZ_CHANNEL_NODE);     // Create subchannel.     RefCountedPtr<Subchannel> subchannel =         chand_->client_channel_factory_->CreateSubchannel(address.address(),-                                                          new_args);-    grpc_channel_args_destroy(new_args);+                                                          subchannel_args);     if (subchannel == nullptr) return nullptr;     // Make sure the subchannel has updated keepalive time.     subchannel->ThrottleKeepaliveTime(chand_->keepalive_time_);     // Create and return wrapper for the subchannel.-    return MakeRefCounted<SubchannelWrapper>(-        chand_, std::move(subchannel), std::move(health_check_service_name));+    return MakeRefCounted<SubchannelWrapper>(chand_, std::move(subchannel),+                                             health_check_service_name);","If you take my suggestion above about using `GetOwnedString()`, then I think we want to go back to using `std::move()` for this parameter.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/30008,905283657,2022-06-23T17:21:12Z,src/core/ext/filters/client_channel/http_proxy.cc,"@@ -59,13 +59,10 @@ namespace {  * credentials if present in the 'http_proxy' env var, otherwise leaves it  * unchanged. It is caller's responsibility to gpr_free user_cred.  */-// TODO(hork): change this to return std::string-char* GetHttpProxyServer(const grpc_channel_args* args, char** user_cred) {+absl::optional<std::string> GetHttpProxyServer(const ChannelArgs& args,+                                               char** user_cred) {",How about changing this parameter to be `absl::optional<std::string>*`?,
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/30008,905289878,2022-06-23T17:28:51Z,src/core/ext/filters/client_channel/lb_policy.h,"@@ -279,7 +279,7 @@ class LoadBalancingPolicy : public InternallyRefCounted<LoadBalancingPolicy> {      /// Creates a new subchannel with the specified channel args.     virtual RefCountedPtr<SubchannelInterface> CreateSubchannel(-        ServerAddress address, const grpc_channel_args& args) = 0;+        ServerAddress address, const ChannelArgs& args) = 0;","Would it make sense for this parameter to be passed in by value instead of as a const reference?  I think in almost all cases, we'll wind up making a copy internally anyway, so if a caller is passing in a temporary anyway, passing it in by value would allow the caller to avoid an unnecessary copy by using `std::move()`.",X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/30008,905311827,2022-06-23T17:55:41Z,src/core/ext/filters/client_channel/lb_policy.h,"@@ -437,6 +427,8 @@ class LoadBalancingPolicy : public InternallyRefCounted<LoadBalancingPolicy> {   grpc_pollset_set* interested_parties_;   /// Channel control helper.   std::unique_ptr<ChannelControlHelper> channel_control_helper_;+  /// Channel args passed in.+  ChannelArgs channel_args_;","When I suggested adding a protected method to access the channel args, I didn't realize that we weren't already storing them in the base class.  Adding this is okay for now, but it seems sub-optimal, because it may result in holding additional refs to things that we don't really need.  And it may cause problems due to channel args living too long on LB policy shutdown, although if that becomes an issue, we can change `Orphan()` to clear the channel args before calling `ShutdownLocked()`.In the longer term, we'll probably need to rework the way that `Args` works here to avoid this.  Can you please add a TODO about this, assigned to me?",X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/30008,905317341,2022-06-23T18:02:45Z,src/core/ext/filters/client_channel/lb_policy_registry.h,"@@ -56,7 +56,7 @@ class LoadBalancingPolicyRegistry {   /// Returns true if the LB policy factory specified by \a name exists in this   /// registry. If the load balancing policy requires a config to be specified   /// then sets \a requires_config to true.-  static bool LoadBalancingPolicyExists(const char* name,+  static bool LoadBalancingPolicyExists(absl::string_view name,","Please also change the parameter type on `CreateLoadBalancingPolicy()`, for consistency.",X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/30008,905327247,2022-06-23T18:14:29Z,src/core/ext/filters/client_channel/resolver/fake/fake_resolver.h,"@@ -82,6 +82,15 @@ class FakeResolverResponseGenerator   static RefCountedPtr<FakeResolverResponseGenerator> GetFromArgs(",I think this function and `MakeChannelArg()` should no longer be needed.,X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/30008,905337589,2022-06-23T18:26:40Z,src/core/ext/filters/client_channel/subchannel.h,"@@ -67,7 +68,7 @@ class SubchannelCall; class ConnectedSubchannel : public RefCounted<ConnectedSubchannel> {  public:   ConnectedSubchannel(-      grpc_channel_stack* channel_stack, const grpc_channel_args* args,+      grpc_channel_stack* channel_stack, const ChannelArgs& args,",Suggest taking the parameter by value instead of as a const reference.,X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/30008,905337730,2022-06-23T18:26:47Z,src/core/ext/filters/client_channel/subchannel.h,"@@ -224,11 +225,11 @@ class Subchannel : public DualRefCounted<Subchannel> {   // Creates a subchannel.   static RefCountedPtr<Subchannel> Create(       OrphanablePtr<SubchannelConnector> connector,-      const grpc_resolved_address& address, const grpc_channel_args* args);+      const grpc_resolved_address& address, const ChannelArgs& args);",Suggest taking the parameter by value instead of as a const reference.,X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/30008,905337837,2022-06-23T18:26:54Z,src/core/ext/filters/client_channel/subchannel.h,"@@ -224,11 +225,11 @@ class Subchannel : public DualRefCounted<Subchannel> {   // Creates a subchannel.   static RefCountedPtr<Subchannel> Create(       OrphanablePtr<SubchannelConnector> connector,-      const grpc_resolved_address& address, const grpc_channel_args* args);+      const grpc_resolved_address& address, const ChannelArgs& args);    // The ctor and dtor are not intended to use directly.   Subchannel(SubchannelKey key, OrphanablePtr<SubchannelConnector> connector,-             const grpc_channel_args* args);+             const grpc_core::ChannelArgs& args);",Suggest taking the parameter by value instead of as a const reference.,X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/30008,905338150,2022-06-23T18:27:19Z,src/core/ext/filters/client_channel/subchannel_pool_interface.h,"@@ -39,34 +40,20 @@ extern TraceFlag grpc_subchannel_pool_trace; // A key that can uniquely identify a subchannel. class SubchannelKey {  public:-  SubchannelKey(const grpc_resolved_address& address,-                const grpc_channel_args* args);+  SubchannelKey(const grpc_resolved_address& address, const ChannelArgs& args);",Suggest taking the parameter by value instead of as a const reference.,X
23140989,ZhenLian,https://api.github.com/repos/grpc/grpc/pulls/29728,905352049,2022-06-23T18:45:11Z,src/core/tsi/ssl_transport_security_util.h,"@@ -0,0 +1,139 @@+/*+ *+ * Copyright 2022 gRPC authors.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ *     http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ *+ */++#ifndef GRPC_CORE_TSI_SSL_TRANSPORT_SECURITY_UTIL_H_+#define GRPC_CORE_TSI_SSL_TRANSPORT_SECURITY_UTIL_H_++#include <grpc/support/port_platform.h>++#include <openssl/x509.h>++#include ""absl/strings/string_view.h""++#include <grpc/grpc_security_constants.h>++#include ""src/core/tsi/ssl/key_logging/ssl_key_logging.h""+#include ""src/core/tsi/transport_security_interface.h""++// Converts an SSL error status code to a readable string.+//+// error: the SSL error status code.+//+// return: the corresponding status string.+const char* ssl_error_string(int error);++// Logs the SSL error stack.+void log_ssl_error_stack(void);++// Performs an SSL_write and handle errors.+//+// ssl: the SSL object to write to.+// unprotected_bytes: the buffer containing the bytes for writing to |ssl|.+// unprotected_bytes_size: the size of the buffer |unprotected_bytes|.+//+// return: TSI_OK if the write operation succeeds or corresponding TSI errors.+tsi_result do_ssl_write(SSL* ssl, unsigned char* unprotected_bytes,","Let's use C++ semantics for names, e.g. DoSslWrite, etc. Same for all the functions defined in this file.",X
23140989,ZhenLian,https://api.github.com/repos/grpc/grpc/pulls/29728,905360863,2022-06-23T18:56:17Z,src/core/tsi/ssl_transport_security_util.h,"@@ -0,0 +1,139 @@+/*+ *+ * Copyright 2022 gRPC authors.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ *     http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ *+ */++#ifndef GRPC_CORE_TSI_SSL_TRANSPORT_SECURITY_UTIL_H_+#define GRPC_CORE_TSI_SSL_TRANSPORT_SECURITY_UTIL_H_++#include <grpc/support/port_platform.h>++#include <openssl/x509.h>++#include ""absl/strings/string_view.h""++#include <grpc/grpc_security_constants.h>++#include ""src/core/tsi/ssl/key_logging/ssl_key_logging.h""+#include ""src/core/tsi/transport_security_interface.h""++// Converts an SSL error status code to a readable string.+//+// error: the SSL error status code.+//+// return: the corresponding status string.+const char* ssl_error_string(int error);++// Logs the SSL error stack.+void log_ssl_error_stack(void);++// Performs an SSL_write and handle errors.+//+// ssl: the SSL object to write to.+// unprotected_bytes: the buffer containing the bytes for writing to |ssl|.+// unprotected_bytes_size: the size of the buffer |unprotected_bytes|.+//+// return: TSI_OK if the write operation succeeds or corresponding TSI errors.+tsi_result do_ssl_write(SSL* ssl, unsigned char* unprotected_bytes,+                        size_t unprotected_bytes_size);++// Performs an SSL_read and handle errors.+//+// ssl: the SSL object to read from.+// unprotected_bytes: the buffer to which this function will populate the read+//                    result from |ssl|.+// unprotected_bytes_size: the maximum size of the buffer |unprotected_bytes|.+//                         This will be populated with the size of the bytes+//                         read from |ssl| if this function returns TSI_OK.+//+// return: TSI_OK if the write operation succeeds or corresponding TSI errors.+tsi_result do_ssl_read(SSL* ssl, unsigned char* unprotected_bytes,+                       size_t* unprotected_bytes_size);++// Builds a maximum-size TLS frame if there is enough (|buffer_offset| ++// |unprotected_bytes_size| >= |buffers_size|) data. Otherwise it copies the+// |unprotected_bytes| into |buffer| and returns TSI_OK.+//+// unprotected_bytes: pointing to the buffer containing the plaintext to be+//                    protected.+// buffer_size: the size of |buffer|. If |buffer_offset| equals |buffer_size|,+//              then we have enough data to create a TLS frame.+// buffer_offset: the offset of |buffer|. The data in |buffer| up to+//                |buffer_offset| are valid data. This will be updated whenever+//                new data are copied into |buffer|.+// buffer: the buffer holding the data that has not been sent for protecting.+// ssl: the |SSL| object that protects the data.+// network_io: the |BIO| object associated with |ssl|.+// unprotected_bytes_size: the size of the unprotected plaintext. This will be+//                         populated with the size of data that is consumed by+//                         this function. Caller can use this to see the size of+//                         unconsumed data in |unprotected_bytes|.+// protected_output_frames: the TLS frames built out of the plaintext.+// protected_output_frames_size: the size of the TLS frames built.+//+// return: TSI_OK if either successfully created a TSI frame or copied the+//         |unprotected_data| into |buffer|. Returns corresponding TSI errors+//         otherwise.+tsi_result ssl_protector_protect_util(+    const unsigned char* unprotected_bytes, const size_t buffer_size,+    size_t& buffer_offset, unsigned char* buffer, SSL* ssl, BIO* network_io,+    std::size_t* unprotected_bytes_size, unsigned char* protected_output_frames,+    size_t* protected_output_frames_size);++// Builds a TLS frame out of the remaining plaintext bytes that's left in+// buffer. Populates the size of the remianing TLS frame to+// |still_pending_size|.+//+// buffer_size: the size of |buffer|. If |buffer_offset| equals |buffer_size|,+//              then we have enough data to create a TLS frame.+// buffer_offset: the offset of |buffer|. The data in |buffer| up to+//                |buffer_offset| are valid data. This will be updated whenever+//                new data are copied into |buffer|.+// buffer: the buffer holding the data that has not been sent for protecting.+// ssl: the |SSL| object that protects the data.+// network_io: the |BIO| object associated with |ssl|.+// protected_output_frames: the TLS frames built out of the plaintext.+// protected_output_frames_size: the size of the TLS frames built.+// still_pending_size: the size of the bytes that remains in |network_io|.+//+// return: TSI_OK if successfully created a TSI frame. Returns corresponding TSI+//         errors otherwise.+tsi_result ssl_protector_protect_flush_util(+    size_t& buffer_offset, unsigned char* buffer, SSL* ssl, BIO* network_io,+    unsigned char* protected_output_frames,+    size_t* protected_output_frames_size, size_t* still_pending_size);++// Extracts the plaintext from a TLS frame.+//+// protected_frames_bytes: the TLS frame to extract plaintext from.+// ssl: the |SSL| object that protects the data.+// network_io: the |BIO| object associated with |ssl|.+// unprotected_bytes_size: the size of the unprotected plaintext. This will be+//                         populated with the size of data that is consumed by+//                         this function. Caller can use this to see the size of+//                         unconsumed data in |unprotected_bytes|.+// protected_output_frames: the TLS frames built out of the plaintext.+// protected_output_frames_size: the size of the TLS frames built.+//+// return: TSI_OK if either successfully created a TSI frame or copied the+//         |unprotected_data| into |buffer|. Returns corresponding TSI errors+//         otherwise.+tsi_result ssl_protector_unprotect_util(+    const unsigned char* protected_frames_bytes, SSL* ssl, BIO* network_io,+    size_t* protected_frames_bytes_size, unsigned char* unprotected_bytes,+    size_t* unprotected_bytes_size);++#endif  // GRPC_CORE_TSI_SSL_TRANSPORT_SECURITY_UTIL_H_","As an example of the style guide for the util functions, you can probably check https://github.com/grpc/grpc/blob/master/src/core/lib/security/credentials/tls/tls_utils.h",X
23140989,ZhenLian,https://api.github.com/repos/grpc/grpc/pulls/29728,905362232,2022-06-23T18:58:01Z,src/core/tsi/ssl_transport_security_util.h,"@@ -0,0 +1,139 @@+/*+ *+ * Copyright 2022 gRPC authors.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ *     http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ *+ */++#ifndef GRPC_CORE_TSI_SSL_TRANSPORT_SECURITY_UTIL_H_+#define GRPC_CORE_TSI_SSL_TRANSPORT_SECURITY_UTIL_H_++#include <grpc/support/port_platform.h>++#include <openssl/x509.h>++#include ""absl/strings/string_view.h""++#include <grpc/grpc_security_constants.h>++#include ""src/core/tsi/ssl/key_logging/ssl_key_logging.h""+#include ""src/core/tsi/transport_security_interface.h""++// Converts an SSL error status code to a readable string.+//+// error: the SSL error status code.+//+// return: the corresponding status string.+const char* ssl_error_string(int error);++// Logs the SSL error stack.+void log_ssl_error_stack(void);++// Performs an SSL_write and handle errors.+//+// ssl: the SSL object to write to.+// unprotected_bytes: the buffer containing the bytes for writing to |ssl|.+// unprotected_bytes_size: the size of the buffer |unprotected_bytes|.+//+// return: TSI_OK if the write operation succeeds or corresponding TSI errors.+tsi_result do_ssl_write(SSL* ssl, unsigned char* unprotected_bytes,+                        size_t unprotected_bytes_size);++// Performs an SSL_read and handle errors.+//+// ssl: the SSL object to read from.+// unprotected_bytes: the buffer to which this function will populate the read+//                    result from |ssl|.+// unprotected_bytes_size: the maximum size of the buffer |unprotected_bytes|.+//                         This will be populated with the size of the bytes+//                         read from |ssl| if this function returns TSI_OK.+//+// return: TSI_OK if the write operation succeeds or corresponding TSI errors.+tsi_result do_ssl_read(SSL* ssl, unsigned char* unprotected_bytes,+                       size_t* unprotected_bytes_size);++// Builds a maximum-size TLS frame if there is enough (|buffer_offset| ++// |unprotected_bytes_size| >= |buffers_size|) data. Otherwise it copies the+// |unprotected_bytes| into |buffer| and returns TSI_OK.+//+// unprotected_bytes: pointing to the buffer containing the plaintext to be+//                    protected.+// buffer_size: the size of |buffer|. If |buffer_offset| equals |buffer_size|,+//              then we have enough data to create a TLS frame.+// buffer_offset: the offset of |buffer|. The data in |buffer| up to+//                |buffer_offset| are valid data. This will be updated whenever+//                new data are copied into |buffer|.+// buffer: the buffer holding the data that has not been sent for protecting.+// ssl: the |SSL| object that protects the data.+// network_io: the |BIO| object associated with |ssl|.+// unprotected_bytes_size: the size of the unprotected plaintext. This will be+//                         populated with the size of data that is consumed by+//                         this function. Caller can use this to see the size of+//                         unconsumed data in |unprotected_bytes|.+// protected_output_frames: the TLS frames built out of the plaintext.+// protected_output_frames_size: the size of the TLS frames built.+//+// return: TSI_OK if either successfully created a TSI frame or copied the+//         |unprotected_data| into |buffer|. Returns corresponding TSI errors+//         otherwise.+tsi_result ssl_protector_protect_util(+    const unsigned char* unprotected_bytes, const size_t buffer_size,+    size_t& buffer_offset, unsigned char* buffer, SSL* ssl, BIO* network_io,+    std::size_t* unprotected_bytes_size, unsigned char* protected_output_frames,+    size_t* protected_output_frames_size);++// Builds a TLS frame out of the remaining plaintext bytes that's left in+// buffer. Populates the size of the remianing TLS frame to+// |still_pending_size|.+//+// buffer_size: the size of |buffer|. If |buffer_offset| equals |buffer_size|,+//              then we have enough data to create a TLS frame.+// buffer_offset: the offset of |buffer|. The data in |buffer| up to+//                |buffer_offset| are valid data. This will be updated whenever+//                new data are copied into |buffer|.+// buffer: the buffer holding the data that has not been sent for protecting.+// ssl: the |SSL| object that protects the data.+// network_io: the |BIO| object associated with |ssl|.+// protected_output_frames: the TLS frames built out of the plaintext.+// protected_output_frames_size: the size of the TLS frames built.+// still_pending_size: the size of the bytes that remains in |network_io|.+//+// return: TSI_OK if successfully created a TSI frame. Returns corresponding TSI+//         errors otherwise.+tsi_result ssl_protector_protect_flush_util(+    size_t& buffer_offset, unsigned char* buffer, SSL* ssl, BIO* network_io,+    unsigned char* protected_output_frames,+    size_t* protected_output_frames_size, size_t* still_pending_size);++// Extracts the plaintext from a TLS frame.+//+// protected_frames_bytes: the TLS frame to extract plaintext from.+// ssl: the |SSL| object that protects the data.+// network_io: the |BIO| object associated with |ssl|.+// unprotected_bytes_size: the size of the unprotected plaintext. This will be+//                         populated with the size of data that is consumed by+//                         this function. Caller can use this to see the size of+//                         unconsumed data in |unprotected_bytes|.+// protected_output_frames: the TLS frames built out of the plaintext.+// protected_output_frames_size: the size of the TLS frames built.+//+// return: TSI_OK if either successfully created a TSI frame or copied the+//         |unprotected_data| into |buffer|. Returns corresponding TSI errors+//         otherwise.+tsi_result ssl_protector_unprotect_util(+    const unsigned char* protected_frames_bytes, SSL* ssl, BIO* network_io,+    size_t* protected_frames_bytes_size, unsigned char* unprotected_bytes,+    size_t* unprotected_bytes_size);++#endif  // GRPC_CORE_TSI_SSL_TRANSPORT_SECURITY_UTIL_H_","BTW I just noticed that our other util files are named as `xx_utils`...it's not a big problem but would you mind changing yours to be consistent with it, please?",X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/30008,905367853,2022-06-23T19:05:21Z,src/core/lib/security/security_connector/fake/fake_security_connector.cc,"@@ -320,10 +320,11 @@ grpc_core::RefCountedPtr<grpc_channel_security_connector> grpc_fake_channel_security_connector_create(     grpc_core::RefCountedPtr<grpc_channel_credentials> channel_creds,     grpc_core::RefCountedPtr<grpc_call_credentials> request_metadata_creds,-    const char* target, const grpc_channel_args* args) {-  return grpc_core::MakeRefCounted<grpc_fake_channel_security_connector>(+    const char* target, const grpc_core::ChannelArgs& args) {+  auto r = grpc_core::MakeRefCounted<grpc_fake_channel_security_connector>(","Why add the temporary variable here, when we're just going to immediately return it?",X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/30008,905377171,2022-06-23T19:18:18Z,src/core/lib/security/credentials/credentials.h,"@@ -112,8 +112,7 @@ struct grpc_channel_credentials   virtual grpc_core::RefCountedPtr<grpc_channel_security_connector>   create_security_connector(       grpc_core::RefCountedPtr<grpc_call_credentials> call_creds,-      const char* target, const grpc_channel_args* args,-      grpc_channel_args** new_args) = 0;+      const char* target, grpc_core::ChannelArgs* args) = 0;",Please update the wording in the comment above about the `args` and `new_args` parameters.,
23140989,ZhenLian,https://api.github.com/repos/grpc/grpc/pulls/29728,905382476,2022-06-23T19:25:48Z,test/core/tsi/ssl_transport_security_util_test.cc,"@@ -0,0 +1,353 @@+//+// Copyright 2021 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+//++#include ""src/core/tsi/ssl_transport_security_util.h""++#include <string>+#include <vector>++#include <gmock/gmock.h>+#include <gtest/gtest.h>+#include <openssl/bio.h>+#include <openssl/crypto.h>+#include <openssl/ssl.h>++#include ""absl/status/status.h""+#include ""absl/status/statusor.h""+#include ""absl/strings/match.h""+#include ""absl/strings/string_view.h""++#include ""src/core/tsi/transport_security.h""+#include ""src/core/tsi/transport_security_interface.h""+#include ""test/core/util/test_config.h""++namespace grpc_core {+namespace testing {++using ::testing::ContainerEq;+using ::testing::NotNull;+using ::testing::Test;+using ::testing::TestWithParam;+using ::testing::ValuesIn;++constexpr std::size_t kMaxPlaintextBytesPerTlsRecord = 16384;+constexpr std::size_t kTls13RecordOverhead = 22;++// Used for debugging.+int VerifySucceed(X509_STORE_CTX* store_ctx, void* arg) { return 1; }++absl::Status DoHandshake(SSL** out_client, SSL** out_server) {+  if (out_client == nullptr || out_server == nullptr) {+    return absl::InvalidArgumentError(+        ""Client and server SSL object must not be null."");+  }+  std::string cert_pem =+      ""-----BEGIN CERTIFICATE-----\n""+      ""MIICZzCCAdCgAwIBAgIIN18/ctj3wpAwDQYJKoZIhvcNAQELBQAwKjEXMBUGA1UE\n""+      ""ChMOR29vZ2xlIFRFU1RJTkcxDzANBgNVBAMTBnRlc3RDQTAeFw0xNTAxMDEwMDAw\n""+      ""MDBaFw0yNTAxMDEwMDAwMDBaMC8xFzAVBgNVBAoTDkdvb2dsZSBURVNUSU5HMRQw\n""+      ""EgYDVQQDDAt0ZXN0X2NlcnRfMTCBnzANBgkqhkiG9w0BAQEFAAOBjQAwgYkCgYEA\n""+      ""20oOyI+fNCCeHJ3DNjGooPPP43Q6emhVvuWD8ppta582Rgxq/4j1bl9cPHdoCdyy\n""+      ""HsWFVUZzscj2qhClmlBAMEA595OU2NX2d81nSih5dwZWLMRQkEIzyxUR7Vee3eyo\n""+      ""nQD4HSamaevMSv79WTUBCozEGITqWnjYA152KUbA/IsCAwEAAaOBkDCBjTAOBgNV\n""+      ""HQ8BAf8EBAMCBaAwHQYDVR0lBBYwFAYIKwYBBQUHAwEGCCsGAQUFBwMCMAwGA1Ud\n""+      ""EwEB/wQCMAAwGQYDVR0OBBIEECnFWP/UkDrV+SoXra58k64wGwYDVR0jBBQwEoAQ\n""+      ""p7JSbajiTZaIRUDSV1C81jAWBgNVHREEDzANggt0ZXN0X2NlcnRfMTANBgkqhkiG\n""+      ""9w0BAQsFAAOBgQCpJJssfN62T3G5z+5SBB+9KCzXnGxcTHtaTJkb04KLe+19EwhV\n""+      ""yRY4lZadKHjcNS6GCBogd069wNFUVYOU9VI7uUiEPdcTO+VRV5MYW0wjSi1zlkBZ\n""+      ""e8OAfYVeGUMfvThFpJ41f8vZ6GHgg95Lwv+Zh89SL8g1J3RWll9YVG8HWw==\n""+      ""-----END CERTIFICATE-----\n"";+  std::string key_pem =+      ""-----BEGIN RSA PRIVATE KEY-----\n""+      ""MIICXQIBAAKBgQDbSg7Ij580IJ4cncM2Maig88/jdDp6aFW+5YPymm1rnzZGDGr/\n""+      ""iPVuX1w8d2gJ3LIexYVVRnOxyPaqEKWaUEAwQDn3k5TY1fZ3zWdKKHl3BlYsxFCQ\n""+      ""QjPLFRHtV57d7KidAPgdJqZp68xK/v1ZNQEKjMQYhOpaeNgDXnYpRsD8iwIDAQAB\n""+      ""AoGAbq4kZApJeo/z/dGK0/GggQxOIylo0puSm7VQMcTL8YP8asKdxrgj2D99WG+U\n""+      ""LVYc+PcM4wuaHWOnTBL24roaitCNhrpIsJfWDkexzHXMj622SYlUcCuwsfjYOEyw\n""+      ""ntoNAnh0o4S+beYAfzT5VHCh4is9G9u+mwKYiGpJXROrYUECQQD4eq4nuGq3mfYJ\n""+      ""B0+md30paDVVCyBsuZTAtnu3MbRjMXy5LLE+vhno5nocvVSTOv3QC7Wk6yAa8/bG\n""+      ""iPT/MWixAkEA4e0zqPGo8tSimVv/1ei8Chyb+YqdSx+Oj5eZpa6X/KB/C1uS1tm6\n""+      ""DTgHW2GUhV4ypqdGH+t8quprJUtFuzqH+wJBAMRiicSg789eouMt4RjrdYPFdela\n""+      ""Gu1zm4rYb10xrqV7Vl0wYoH5U5cMmdSfGvomdLX6mzzWDJDg4ti1JBWRonECQQCD\n""+      ""Umtq0j1QGQUCe5Vz8zoJ7qNDI61WU1t8X7Rxt9CkiW4PXgU2WYxpzp2IImpAM4bh\n""+      ""k+2Q9EKc3nG1VdGMiPMtAkARkQF+pL8SBrUoh8G8glCam0brh3tW/cdW8L4UGTNF\n""+      ""2ZKC/LFH6DQBjYs3UXjvMGJxz4k9LysyY6o2Nf1JG6/L\n""+      ""-----END RSA PRIVATE KEY-----\n"";++  // Create the context objects.+  SSL_CTX* client_ctx(SSL_CTX_new(TLS_method()));+  SSL_CTX* server_ctx(SSL_CTX_new(TLS_method()));++  BIO* client_cert_bio(BIO_new_mem_buf(cert_pem.c_str(), cert_pem.size()));+  X509* client_cert = PEM_read_bio_X509(client_cert_bio, /*x=*/nullptr,+                                        /*cb=*/nullptr, /*u=*/nullptr);+  BIO* client_key_bio(BIO_new_mem_buf(key_pem.c_str(), key_pem.size()));+  EVP_PKEY* client_key = PEM_read_bio_PrivateKey(client_key_bio, /*x=*/nullptr,+                                                 /*cb=*/nullptr, /*u=*/nullptr);++  BIO* server_cert_bio(BIO_new_mem_buf(cert_pem.c_str(), cert_pem.size()));+  X509* server_cert = PEM_read_bio_X509(server_cert_bio, /*x=*/nullptr,+                                        /*cb=*/nullptr, /*u=*/nullptr);+  BIO* server_key_bio(BIO_new_mem_buf(key_pem.c_str(), key_pem.size()));+  EVP_PKEY* server_key = PEM_read_bio_PrivateKey(server_key_bio, /*x=*/nullptr,+                                                 /*cb=*/nullptr, /*u=*/nullptr);++  // Set both client and server certificate and private key.+  SSL_CTX_use_certificate(client_ctx, client_cert);+  SSL_CTX_use_PrivateKey(client_ctx, client_key);+  SSL_CTX_use_certificate(server_ctx, server_cert);+  SSL_CTX_use_PrivateKey(server_ctx, server_key);++  EVP_PKEY_free(client_key);+  BIO_free(client_key_bio);+  X509_free(client_cert);+  BIO_free(client_cert_bio);++  EVP_PKEY_free(server_key);+  BIO_free(server_key_bio);+  X509_free(server_cert);+  BIO_free(server_cert_bio);++  // Configure both client and server to request (and accept any)+  // certificate but fail if none is sent.+  SSL_CTX_set_verify(client_ctx,+                     SSL_VERIFY_PEER | SSL_VERIFY_FAIL_IF_NO_PEER_CERT,+                     /*callback=*/nullptr);+  SSL_CTX_set_cert_verify_callback(client_ctx, VerifySucceed,+                                   /*arg=*/nullptr);+  SSL_CTX_set_verify(server_ctx,+                     SSL_VERIFY_PEER | SSL_VERIFY_FAIL_IF_NO_PEER_CERT,+                     /*callback=*/nullptr);+  SSL_CTX_set_cert_verify_callback(server_ctx, VerifySucceed,+                                   /*arg=*/nullptr);++  // Turns off the session caching.+  SSL_CTX_set_session_cache_mode(client_ctx, SSL_SESS_CACHE_OFF);+  SSL_CTX_set_session_cache_mode(server_ctx, SSL_SESS_CACHE_OFF);++  // Set both the min and max TLS version to 1.3+  SSL_CTX_set_min_proto_version(client_ctx, TLS1_3_VERSION);+  SSL_CTX_set_min_proto_version(server_ctx, TLS1_3_VERSION);+  SSL_CTX_set_max_proto_version(client_ctx, TLS1_3_VERSION);+  SSL_CTX_set_max_proto_version(server_ctx, TLS1_3_VERSION);++  // Create client and server connection objects and configure their BIOs.+  SSL* client(SSL_new(client_ctx));+  SSL* server(SSL_new(server_ctx));++  SSL_CTX_free(client_ctx);+  SSL_CTX_free(server_ctx);++  // Turns off issuance of session tickets by servers.+  SSL_set_options(client, SSL_OP_NO_TICKET);+  SSL_set_options(server, SSL_OP_NO_TICKET);++  SSL_set_connect_state(client);+  SSL_set_accept_state(server);+  BIO* bio1;+  BIO* bio2;+  BIO_new_bio_pair(&bio1, /*writebuf1=*/0, &bio2, /*writebuf2=*/0);+  SSL_set_bio(client, bio1, bio1);+  SSL_set_bio(server, bio2, bio2);++  // Drive both the client and server handshake operations to completion.+  while (true) {+    int client_ret = SSL_do_handshake(client);+    int client_err = SSL_get_error(client, client_ret);+    if (client_err != SSL_ERROR_NONE && client_err != SSL_ERROR_WANT_READ &&+        client_err != SSL_ERROR_WANT_WRITE &&+        client_err != SSL_ERROR_PENDING_TICKET) {+      return absl::InternalError(+          absl::StrCat(""Client error:"", SSL_error_description(client_err)));+    }++    int server_ret = SSL_do_handshake(server);+    int server_err = SSL_get_error(server, server_ret);+    if (server_err != SSL_ERROR_NONE && server_err != SSL_ERROR_WANT_READ &&+        server_err != SSL_ERROR_WANT_WRITE &&+        server_err != SSL_ERROR_PENDING_TICKET) {+      return absl::InternalError(+          absl::StrCat(""Server error:"", SSL_error_description(server_err)));+    }+    if (client_ret == 1 && server_ret == 1) {+      break;+    }+  }++  *out_client = client;+  *out_server = server;++  return absl::OkStatus();+}++std::size_t CalculateRecordSizeFromHeader(uint8_t fourth_header_byte,+                                          uint8_t fifth_header_byte) {+  return (static_cast<int>(fourth_header_byte & 0xff) << 8) ++         static_cast<int>(fifth_header_byte & 0xff);+}++struct FrameProtectorUtilTestData {+  std::size_t plaintext_size;+  std::size_t expected_encrypted_bytes_size;+};++// Generates the testing data |FrameProtectorUtilTestData|.+std::vector<FrameProtectorUtilTestData> GenerateTestData() {+  std::vector<FrameProtectorUtilTestData> data;+  for (std::size_t plaintext_size : {1, 1000, 16384, 17000}) {+    std::size_t expected_size = plaintext_size + kTls13RecordOverhead;+    if (plaintext_size > kMaxPlaintextBytesPerTlsRecord) {+      expected_size = kMaxPlaintextBytesPerTlsRecord + kTls13RecordOverhead;+    }+    data.push_back({plaintext_size, expected_size});+  }+  return data;+}++void SslFrameProtectorUtilFunctionTestHelper(+    const std::size_t plaintext_size,+    const std::size_t expected_encrypted_bytes_size, SSL* ssl, BIO* bio,+    std::vector<uint8_t>& buffer, std::size_t& buffer_offset, SSL* peer_ssl,+    BIO* peer_bio, std::vector<uint8_t>& peer_buffer,+    std::size_t& peer_buffer_offset) {+  std::vector<uint8_t> unprotected_bytes(plaintext_size, 'a');+  std::size_t unprotected_bytes_size = unprotected_bytes.size();++  std::vector<uint8_t> protected_output_frames(expected_encrypted_bytes_size);+  std::size_t protected_output_frames_size = protected_output_frames.size();++  EXPECT_EQ(ssl_protector_protect_util(+                unprotected_bytes.data(), buffer.size(), buffer_offset,+                buffer.data(), ssl, bio, &unprotected_bytes_size,+                protected_output_frames.data(), &protected_output_frames_size),+            tsi_result::TSI_OK);++  // If |plaintext_size| is larger than the inner buffer size+  // (kMaxPlaintextBytesPerTlsRecord), then |Protect| will copy up to+  // |kMaxPlaintextBytesPerTlsRecord| bytes and output the protected+  // frame. Otherwise we need to manually flush the copied data in order+  // to get the protected frame.+  if (plaintext_size >= kMaxPlaintextBytesPerTlsRecord) {+    EXPECT_EQ(unprotected_bytes_size, kMaxPlaintextBytesPerTlsRecord);+  } else {+    EXPECT_EQ(unprotected_bytes_size, plaintext_size);+    EXPECT_EQ(protected_output_frames_size, 0);+    protected_output_frames_size = protected_output_frames.size();++    std::size_t still_pending_size = 0;+    EXPECT_EQ(ssl_protector_protect_flush_util(+                  buffer_offset, buffer.data(), ssl, bio,+                  protected_output_frames.data(), &protected_output_frames_size,+                  &still_pending_size),+              tsi_result::TSI_OK);+    EXPECT_EQ(still_pending_size, 0);+  }++  EXPECT_EQ(protected_output_frames_size, expected_encrypted_bytes_size);+  // The first three bytes are always 0x17, 0x03, 0x03.+  EXPECT_EQ(protected_output_frames[0], '\x17');+  EXPECT_EQ(protected_output_frames[1], '\x03');+  EXPECT_EQ(protected_output_frames[2], '\x03');+  // The next two bytes are the size of the record, which is 5 bytes less+  // than the size of the whole frame.+  EXPECT_EQ(CalculateRecordSizeFromHeader(protected_output_frames[3],+                                          protected_output_frames[4]),+            expected_encrypted_bytes_size - 5);++  std::vector<uint8_t> unprotected_output_bytes(plaintext_size);+  std::size_t unprotected_output_bytes_size = unprotected_output_bytes.size();++  // This frame should be decrypted by peer correctly.+  EXPECT_EQ(ssl_protector_unprotect_util(+                protected_output_frames.data(), peer_ssl, peer_bio,+                &protected_output_frames_size, unprotected_output_bytes.data(),+                &unprotected_output_bytes_size),+            tsi_result::TSI_OK);+  EXPECT_EQ(unprotected_output_bytes_size, unprotected_bytes_size);+  unprotected_output_bytes.resize(unprotected_output_bytes_size);+  unprotected_bytes.resize(unprotected_bytes_size);+  EXPECT_THAT(unprotected_output_bytes, ContainerEq(unprotected_bytes));+}++class FlowTest : public TestWithParam<FrameProtectorUtilTestData> {+ protected:+  void SetUp() override {+    ASSERT_EQ(DoHandshake(&client_ssl, &server_ssl), absl::OkStatus());++    ASSERT_THAT(client_ssl, NotNull());+    ASSERT_THAT(server_ssl, NotNull());++    BIO* client_ssl_bio = nullptr;+    ASSERT_EQ(BIO_new_bio_pair(&client_bio, /*writebuf1=*/0, &client_ssl_bio,+                               /*writebuf2=*/0),+              1);+    SSL_set_bio(client_ssl, client_ssl_bio, client_ssl_bio);++    BIO* server_ssl_bio = nullptr;+    ASSERT_EQ(BIO_new_bio_pair(&server_bio, /*writebuf1=*/0, &server_ssl_bio,+                               /*writebuf2=*/0),+              1);+    SSL_set_bio(server_ssl, server_ssl_bio, server_ssl_bio);++    client_buffer_offset = 0;+    client_buffer.resize(kMaxPlaintextBytesPerTlsRecord);+    server_buffer_offset = 0;+    server_buffer.resize(kMaxPlaintextBytesPerTlsRecord);+  }++  void TearDown() override {+    BIO_free(client_bio);+    SSL_free(client_ssl);+    BIO_free(server_bio);+    SSL_free(server_ssl);+  }++  SSL* client_ssl;+  BIO* client_bio;+  std::vector<uint8_t> client_buffer;+  std::size_t client_buffer_offset;++  SSL* server_ssl;+  BIO* server_bio;+  std::vector<uint8_t> server_buffer;+  std::size_t server_buffer_offset;+};++TEST_P(FlowTest, TestWorkFlows) {+  SslFrameProtectorUtilFunctionTestHelper(+      GetParam().plaintext_size, GetParam().expected_encrypted_bytes_size,+      client_ssl, client_bio, client_buffer, client_buffer_offset, server_ssl,+      server_bio, server_buffer, server_buffer_offset);+  SslFrameProtectorUtilFunctionTestHelper(","Sorry I wasn't clear. I wasn't suggesting to change the code logic; I was just recommending another way to structure things out.The idea behind this is that I am generally not a fan of ""XXXTestHelper"". In my opinion, it doesn't contain much information, and readers still have to look into that helper to understand what it really does. What I was suggesting was something like ```TEST_P(TsiFrameProtectorTest, ClientToServerBufferTests) {   // ... some preparation  EXPECT_EQ(ssl_protector_protect_util(...), tsi_result::TSI_OK);  // check buffer size&content, etc, this can be a static function shared by two test functions  CheckBufferAfterProtection(...);  EXPECT_EQ(ssl_protector_unprotect_util(...), tsi_result::TSI_OK);  // check buffer size&content, etc, this can be a static function shared by two test functions  CheckBufferAfterUnprotection(...);} TEST_P(TsiFrameProtectorTest, ServerToClientBufferTests) {   // similar as above }```That way, it's clear for the reader that only the part `ssl_protector_protect_util` and `ssl_protector_unprotect_util` changed between two tests, and it's clear what these two tests are for.",X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/30008,905385820,2022-06-23T19:30:30Z,src/core/ext/xds/xds_client.h,"@@ -162,6 +162,10 @@ class XdsClient : public DualRefCounted<XdsClient> {   grpc_arg MakeChannelArg() const;",These two methods are no longer needed.,X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/30008,905388522,2022-06-23T19:34:24Z,src/core/ext/xds/xds_channel_stack_modifier.h,"@@ -47,6 +47,11 @@ class XdsChannelStackModifier : public RefCounted<XdsChannelStackModifier> {   grpc_arg MakeChannelArg() const;",These two methods should no longer be needed.,X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/30008,905389729,2022-06-23T19:36:08Z,src/core/ext/xds/xds_certificate_provider.h,"@@ -50,6 +50,15 @@ class XdsCertificateProvider : public grpc_tls_certificate_provider {   XdsCertificateProvider();   ~XdsCertificateProvider() override; +  static absl::string_view ChannelArgName() {",I think we no longer need the `MakeChannelArg()` or `GetFromChannelArgs()` methods below.,X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/30008,905391041,2022-06-23T19:38:03Z,src/core/ext/transport/chttp2/server/chttp2_server.h,"@@ -35,13 +36,13 @@ namespace grpc_core { // configured with a config fetcher. Not invoked if there is no config fetcher // added to the server. Takes ownership of the args.  Caller takes ownership of",This comment no longer needs to discuss ownership.,
672669,sergiitk,https://api.github.com/repos/grpc/grpc/pulls/29954,905431027,2022-06-23T20:22:14Z,tools/run_tests/xds_k8s_test_driver/tests/bootstrap_generator_test.py,"@@ -0,0 +1,216 @@+# Copyright 2022 gRPC authors.+#+# Licensed under the Apache License, Version 2.0 (the ""License"");+# you may not use this file except in compliance with the License.+# You may obtain a copy of the License at+#+#     http://www.apache.org/licenses/LICENSE-2.0+#+# Unless required by applicable law or agreed to in writing, software+# distributed under the License is distributed on an ""AS IS"" BASIS,+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+# See the License for the specific language governing permissions and+# limitations under the License.+import datetime+import logging+from typing import Optional++from absl import flags+from absl.testing import absltest+from absl.testing import parameterized++from framework import bootstrap_generator_testcase+from framework import xds_k8s_testcase+from framework.helpers import rand as helpers_rand+from framework.helpers import retryers+from framework.infrastructure import k8s+from framework.infrastructure import traffic_director+from framework.test_app import client_app+from framework.test_app import server_app++logger = logging.getLogger(__name__)+flags.adopt_module_key_flags(xds_k8s_testcase)++# Type aliases+XdsTestServer = xds_k8s_testcase.XdsTestServer+XdsTestClient = xds_k8s_testcase.XdsTestClient+KubernetesServerRunner = server_app.KubernetesServerRunner+KubernetesClientRunner = client_app.KubernetesClientRunner+_timedelta = datetime.timedelta+++class BootstrapGeneratorClientTest(+        bootstrap_generator_testcase.BootstrapGeneratorBaseTest,+        parameterized.TestCase):+    server_runner: KubernetesServerRunner+    test_server: XdsTestServer++    @classmethod+    def setUpClass(cls):+        """"""Hook method for setting up class fixture before running tests in+        the class.+        """"""+        super().setUpClass()++        # For client tests, we use a single server instance that can be shared+        # across all the parameterized clients. And this server runner will use+        # the version of the bootstrap generator as configured via the+        # --td_bootstrap_image flag.+        cls.server_runner = cls.initKubernetesServerRunner()+        cls.test_server = BootstrapGeneratorClientTest.startTestServer(+            server_runner=cls.server_runner,+            port=cls.server_port,+            maintenance_port=cls.server_maintenance_port,+            xds_host=cls.server_xds_host,+            xds_port=cls.server_xds_port)++        # Load backends.+        neg_name, neg_zones = cls.server_runner.k8s_namespace.get_service_neg(+            cls.server_runner.service_name, cls.server_port)++        # Add backends to the Backend Service.+        cls.td.backend_service_add_neg_backends(neg_name, neg_zones)+        cls.td.wait_for_backends_healthy_status()++    @classmethod+    def tearDownClass(cls):+        # Remove backends from the Backend Service before closing the server+        # runner.+        neg_name, neg_zones = cls.server_runner.k8s_namespace.get_service_neg(+            cls.server_runner.service_name, cls.server_port)+        cls.td.backend_service_remove_neg_backends(neg_name, neg_zones)+        cls.server_runner.cleanup(force=cls.force_cleanup)+        super().tearDownClass()++    def tearDown(self):+        logger.info('----- TestMethod %s teardown -----', self.id())+        retryer = retryers.constant_retryer(wait_fixed=_timedelta(seconds=10),+                                            attempts=3,+                                            log_level=logging.INFO)+        try:+            retryer(self._cleanup)+        except retryers.RetryError:+            logger.exception('Got error during teardown')+        super().tearDown()++    def _cleanup(self):+        self.client_runner.cleanup(force=self.force_cleanup)++    @parameterized.named_parameters(+        # Add images corresponding to future releases here.+        #+        # TODO: Update bootstrap generator release instructions to add a newly+        # released version to this list.+        ('v0.14.0',+         'gcr.io/grpc-testing/td-grpc-bootstrap:d6baaf7b0e0c63054ac4d9bedc09021ff261d599'+        ),+        ('v0.13.0',+         'gcr.io/grpc-testing/td-grpc-bootstrap:203db6ce70452996f4183c30dd4c5ecaada168b0'+        ),+        ('v0.12.0',+         'gcr.io/grpc-testing/td-grpc-bootstrap:8765051ef3b742bc5cd20f16de078ae7547f2ba2'+        ),+        ('v0.11.0',+         'gcr.io/grpc-testing/td-grpc-bootstrap:b96f7a73314668aee83cbf86ab1e40135a0542fc'+        ),+        # v0.10.0 uses v2 xDS transport protocol by default. TD only supports v3+        # and we can force the bootstrap generator to emit config with v3+        # support by setting the --include-v3-features-experimental flag to+        # true.+        #+        # TODO: Figure out how to pass flags to the bootstrap generator via the+        # client and server runners, and uncomment this version.+        # ('v0.10.0', 'gcr.io/grpc-testing/td-grpc-bootstrap:66de7ea0e170351c9fae17232b81adbfb3e80ec3'),+    )+    def test_baseline_in_client_with_bootstrap_version(self, image):+        """"""Runs the baseline test for multiple versions of the bootstrap+        generator on the client.+        """"""+        self.client_runner = self.initKubernetesClientRunner(+            td_bootstrap_image=image)+        test_client: XdsTestClient = self.startTestClient(self.test_server)+        self.assertXdsConfigExists(test_client)+        self.assertSuccessfulRpcs(test_client)+++# TODO: Use unique client and server deployment names while creating the+# corresponding runners, by suffixing the version of the bootstrap generator+# being tested. Then, run these in parallel.+class BootstrapGeneratorServerTest(+        bootstrap_generator_testcase.BootstrapGeneratorBaseTest,+        parameterized.TestCase):+    server_runner: KubernetesServerRunner+    client_runner: KubernetesClientRunner+    test_server: XdsTestServer++    def tearDown(self):+        logger.info('----- TestMethod %s teardown -----', self.id())+        retryer = retryers.constant_retryer(wait_fixed=_timedelta(seconds=10),+                                            attempts=3,+                                            log_level=logging.INFO)+        try:+            retryer(self._cleanup)+        except retryers.RetryError:+            logger.exception('Got error during teardown')+        super().tearDown()++    def _cleanup(self):+        self.client_runner.cleanup(force=self.force_cleanup)+        self.removeServerBackends()+        self.server_runner.cleanup(force=self.force_cleanup)++    @parameterized.named_parameters(+        # Add images corresponding to future releases here.+        #+        # TODO: Update bootstrap generator release instructions to add a newly+        # released version to this list.+        ('v0.14.0',+         'gcr.io/grpc-testing/td-grpc-bootstrap:d6baaf7b0e0c63054ac4d9bedc09021ff261d599'+        ),+        ('v0.13.0',+         'gcr.io/grpc-testing/td-grpc-bootstrap:203db6ce70452996f4183c30dd4c5ecaada168b0'+        ),+        ('v0.12.0',+         'gcr.io/grpc-testing/td-grpc-bootstrap:8765051ef3b742bc5cd20f16de078ae7547f2ba2'+        ),+        ('v0.11.0',+         'gcr.io/grpc-testing/td-grpc-bootstrap:b96f7a73314668aee83cbf86ab1e40135a0542fc'+        ),+        # v0.10.0 uses v2 xDS transport protocol by default. TD only supports v3+        # and we can force the bootstrap generator to emit config with v3+        # support by setting the --include-v3-features-experimental flag to+        # true.+        #+        # TODO: Figure out how to pass flags to the bootstrap generator via the+        # client and server runners, and uncomment this version.+        # ('v0.10.0', 'gcr.io/grpc-testing/td-grpc-bootstrap:66de7ea0e170351c9fae17232b81adbfb3e80ec3'),","It will be amazing if you could move this block, and its copy above to a method. You won't have to repeat it then. Take a look at this [absl usage example](https://github.com/abseil/abseil-py/blob/58ead8c22230a2493006fa0ab9f76776b6e7280f/absl/testing/parameterized.py#L117-L128):```Inputs from Iterables=====================If parameters should be shared across several test cases, or are dynamicallycreated from other sources, a single non-tuple iterable can be passed intothe decorator. This iterable will be used to obtain the test cases:  class AdditionExample(parameterized.TestCase):    @parameterized.parameters(      c.op1, c.op2, c.result for c in testcases    )    def testAddition(self, op1, op2, result):      self.assertEqual(result, op1 + op2)```I think it'll be something like (just an illustration, didn't test the code).This is just defined at the top level in this file:```pydef bootstrap_version_testcases() -> List:  return (        ('v0.14.0',         'gcr.io/grpc-testing/td-grpc-bootstrap:d6baaf7b0e0c63054ac4d9bedc09021ff261d599'        ),        ('v0.13.0',         'gcr.io/grpc-testing/td-grpc-bootstrap:203db6ce70452996f4183c30dd4c5ecaada168b0'        ),        # ...    )```and then parametrized could be ```py@parameterized.parameters(bootstrap_version_testcases())def test_baseline_in_server_with_bootstrap_version(self, image):```",X
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/30101,906187787,2022-06-24T15:45:30Z,src/core/lib/iomgr/ev_posix.cc,"@@ -163,77 +167,68 @@ static bool is(const char* want, const char* have) { }  static void try_engine(const char* engine) {-  for (size_t i = 0; i < GPR_ARRAY_SIZE(g_factories); i++) {-    if (g_factories[i].factory != nullptr && is(engine, g_factories[i].name)) {-      if ((g_event_engine = g_factories[i].factory(-               0 == strcmp(engine, g_factories[i].name)))) {-        g_poll_strategy_name = g_factories[i].name;-        gpr_log(GPR_DEBUG, ""Using polling engine: %s"", g_factories[i].name);-        return;-      }+  for (size_t i = 0; i < GPR_ARRAY_SIZE(g_vtables); i++) {+    if (g_vtables[i] != nullptr && is(engine, g_vtables[i]->name) &&+        g_vtables[i]->check_engine_available(+            0 == strcmp(engine, g_vtables[i]->name))) {+      g_event_engine = g_vtables[i];+      gpr_log(GPR_DEBUG, ""Using polling engine: %s"", g_event_engine->name);+      return;     }   } }  /* Call this before calling grpc_event_engine_init() */-void grpc_register_event_engine_factory(const char* name,-                                        event_engine_factory_fn factory,+void grpc_register_event_engine_factory(const grpc_event_engine_vtable* vtable,                                         bool add_at_head) {-  const char* custom_match =-      add_at_head ? ENGINE_HEAD_CUSTOM : ENGINE_TAIL_CUSTOM;+  const grpc_event_engine_vtable** first_null = nullptr;+  const grpc_event_engine_vtable** last_null = nullptr;    // Overwrite an existing registration if already registered",This no longer overwrites an existing registration.,X
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/30101,906199084,2022-06-24T15:59:13Z,src/core/lib/iomgr/ev_epoll1_linux.cc,"@@ -1319,47 +1324,59 @@ static void reset_event_manager_on_fork() {   }   gpr_mu_unlock(&fork_fd_list_mu);   shutdown_engine();-  grpc_init_epoll1_linux(true);+  init_epoll1_linux(); }  /* It is possible that GLIBC has epoll but the underlying kernel doesn't.  * Create epoll_fd (epoll_set_init() takes care of that) to make sure epoll  * support is available */-const grpc_event_engine_vtable* grpc_init_epoll1_linux(-    bool /*explicit_request*/) {+static bool init_epoll1_linux() {   if (!grpc_has_wakeup_fd()) {     gpr_log(GPR_ERROR, ""Skipping epoll1 because of no wakeup fd."");-    return nullptr;+    return false;   }    if (!epoll_set_init()) {-    return nullptr;+    return false;   }    fd_global_init();    if (!GRPC_LOG_IF_ERROR(""pollset_global_init"", pollset_global_init())) {     fd_global_shutdown();     epoll_set_shutdown();-    return nullptr;+    return false;   }    if (grpc_core::Fork::Enabled()) {     gpr_mu_init(&fork_fd_list_mu);     grpc_core::Fork::SetResetChildPollingEngineFunc(         reset_event_manager_on_fork);   }-  return &vtable;+  return true; }  #else /* defined(GRPC_LINUX_EPOLL) */ #if defined(GRPC_POSIX_SOCKET_EV_EPOLL1) #include ""src/core/lib/iomgr/ev_epoll1_linux.h""-/* If GRPC_LINUX_EPOLL is not defined, it means epoll is not available. Return- * NULL */-const grpc_event_engine_vtable* grpc_init_epoll1_linux(-    bool /*explicit_request*/) {-  return nullptr;-}+const grpc_event_engine_vtable grpc_ev_epoll1_posix = {+    1,       true,     false,++    nullptr, nullptr,  nullptr,+    nullptr, nullptr,  nullptr,+    nullptr, nullptr,  nullptr,+    nullptr, nullptr,++    nullptr, nullptr,  nullptr,+    nullptr, nullptr,  nullptr,++    nullptr, nullptr,  nullptr,+    nullptr, nullptr,  nullptr,+    nullptr, nullptr,++    nullptr, ""epoll1"", [](bool) { return false; },","Similar to the above, I think it's worth naming which arguments these are.",X
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/30101,906215094,2022-06-24T16:20:37Z,src/core/lib/iomgr/ev_posix.h,"@@ -85,16 +85,18 @@ typedef struct grpc_event_engine_vtable {   void (*pollset_set_del_fd)(grpc_pollset_set* pollset_set, grpc_fd* fd);    bool (*is_any_background_poller_thread)(void);+  const char* name;+  bool (*check_engine_available)(bool explicit_request);",that'd be a semantic change to how we initialize this stuff... so future pr (maybe when we fork this stuff for ee),
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/30108,907023662,2022-06-27T06:39:05Z,third_party/toolchains/rbe_win2019/Dockerfile,"@@ -1,94 +1,79 @@-# This dockerfile is taken from go/rbe-windows-user-guide-# (including the fix --compilation_mode=dbg)--# This Dockerfile creates an image that:-# - Has the correct MTU setting for networking from inside the container to work.-# - Has Visual Studio 2015 Build Tools installed.-# - Has msys2 + git, curl, zip, unzip installed.-# - Has Python 2.7 installed.-# TODO(jsharpe): Consider replacing ""ADD $URI $DEST"" with ""Invoke-WebRequest -Method Get -Uri $URI -OutFile $DEST""-# Use the latest Windows Server Core image.-#-# WARNING: What's the `:ltsc2019` about?-# There are two versions of Windows Server 2019:-# 1. A ""regular"" one (corresponding to `mcr.microsoft.com/windows/servercore:ltsc2019`)-# is on a slow release cadence and is the Long-Term Servicing Channel.-# Mainstream support for this image will end on 1/9/2024.-# 2. A ""fast"" release cadence one (corresponding to-# `mcr.microsoft.com/windows/servercore:1909`) is the Semi-Annual Channel.-# Mainstream support for this image will end on 5/11/2021.-#-# If you choose a different-# image than described above, change the `:ltsc2019` tag.-# Start a temporary container in which we install 7-Zip to extract msys2-FROM mcr.microsoft.com/windows/servercore:ltsc2019 as extract-msys2-SHELL [""powershell.exe"", ""-ExecutionPolicy"", ""Bypass"", ""-Command"", ""$ErrorActionPreference='Stop'; $ProgressPreference='SilentlyContinue'; $VerbosePreference = 'Continue';""]-# Install 7-Zip and add it to the path.-ADD https://www.7-zip.org/a/7z1801-x64.msi C:\\TEMP\\7z.msi-RUN Start-Process msiexec.exe -ArgumentList \""/i C:\\TEMP\\7z.msi /qn /norestart /log C:\\TEMP\\7z_install_log.txt\"" -wait-RUN $oldpath = (Get-ItemProperty -Path 'Registry::HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\Session Manager\Environment' -Name PATH).path; \-  $newpath = \""$oldpath;C:\Program Files\7-Zip\""; \-  Set-ItemProperty -Path 'Registry::HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\Session Manager\Environment' -Name PATH -Value $newPath-# Extract msys2-ADD http://repo.msys2.org/distrib/x86_64/msys2-base-x86_64-20181211.tar.xz C:\\TEMP\\msys2.tar.xz-RUN 7z x C:\TEMP\msys2.tar.xz -oC:\TEMP\msys2.tar-RUN 7z x C:\TEMP\msys2.tar -oC:\tools-# Start building the actual image+# This Dockerfile creates an image that has the following:","According to my investigation, just upgrading the docker image won't be enough:- the `https://github.com/grpc/grpc/tree/master/third_party/toolchains/bazel_0.26.0_rbe_windows` needs to be upgraded as well (as it contains the paths to the VC++ tools etc - so it basically has the VS version hardcoded in it).- looks like since we're using bazel4.x currently, we'll need to use VS2019 (see comment in the dockerfile).",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/30008,907621828,2022-06-27T17:21:45Z,src/core/ext/filters/client_channel/config_selector.h,"@@ -101,16 +101,18 @@ class ConfigSelector : public RefCounted<ConfigSelector> {   // to determine what set of dynamic filters will be configured.   virtual std::vector<const grpc_channel_filter*> GetFilters() { return {}; }   // Modifies channel args to be passed to the dynamic filter stack.-  // Takes ownership of argument.  Caller takes ownership of result.-  virtual grpc_channel_args* ModifyChannelArgs(grpc_channel_args* args) {-    return args;-  }+  virtual ChannelArgs ModifyChannelArgs(ChannelArgs args) { return args; }    virtual CallConfig GetCallConfig(GetCallConfigArgs args) = 0;    grpc_arg MakeChannelArg() const;","this one specifically I'm not sure: there's a bunch of these still in use though - since this PR doesn't convert the entire codebase just yet, so I'd propose a general cleanup of this pattern as a later step",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/30008,907630939,2022-06-27T17:32:35Z,src/core/ext/filters/client_channel/http_proxy.cc,"@@ -74,43 +71,53 @@ char* GetHttpProxyServer(const grpc_channel_args* args, char** user_cred) {    * 4. http_proxy environment variable    * If none of the above are set, then no HTTP proxy will be used.    */-  auto uri_str = UniquePtr<char>(-      gpr_strdup(grpc_channel_args_find_string(args, GRPC_ARG_HTTP_PROXY)));-  if (uri_str == nullptr) uri_str = UniquePtr<char>(gpr_getenv(""grpc_proxy""));-  if (uri_str == nullptr) uri_str = UniquePtr<char>(gpr_getenv(""https_proxy""));-  if (uri_str == nullptr) uri_str = UniquePtr<char>(gpr_getenv(""http_proxy""));-  if (uri_str == nullptr) return nullptr;+  absl::optional<std::string> uri_str =+      args.GetOwnedString(GRPC_ARG_HTTP_PROXY);+  auto get_env = [](const char* name) -> absl::optional<std::string> {+    char* v = gpr_getenv(name);+    if (v == nullptr) return absl::nullopt;+    std::string s(v);+    gpr_free(v);+    return s;+  };+  if (!uri_str.has_value()) uri_str = get_env(""grpc_proxy"");+  if (!uri_str.has_value()) uri_str = get_env(""https_proxy"");+  if (!uri_str.has_value()) uri_str = get_env(""http_proxy"");+  if (!uri_str.has_value()) return absl::nullopt;   // an emtpy value means ""don't use proxy""-  if (uri_str.get()[0] == '\0') return nullptr;-  uri = URI::Parse(uri_str.get());+  if (uri_str->empty()) return absl::nullopt;+  uri = URI::Parse(*uri_str);   if (!uri.ok() || uri->authority().empty()) {     gpr_log(GPR_ERROR, ""cannot parse value of 'http_proxy' env var. Error: %s"",             uri.status().ToString().c_str());-    return nullptr;+    return absl::nullopt;   }   if (uri->scheme() != ""http"") {     gpr_log(GPR_ERROR, ""'%s' scheme not supported in proxy URI"",             uri->scheme().c_str());-    return nullptr;+    return absl::nullopt;   }   /* Split on '@' to separate user credentials from host */+  char** authority_strs = nullptr;+  size_t authority_nstrs;   gpr_string_split(uri->authority().c_str(), ""@"", &authority_strs,","i'll leave that as a followup, the intent of this pr is to introduce channel args, not to address every piece of tech debt in the path",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/30008,907631190,2022-06-27T17:32:49Z,src/core/ext/filters/client_channel/http_proxy.cc,"@@ -59,13 +59,10 @@ namespace {  * credentials if present in the 'http_proxy' env var, otherwise leaves it  * unchanged. It is caller's responsibility to gpr_free user_cred.  */-// TODO(hork): change this to return std::string-char* GetHttpProxyServer(const grpc_channel_args* args, char** user_cred) {+absl::optional<std::string> GetHttpProxyServer(const ChannelArgs& args,+                                               char** user_cred) {","i'll leave that as a followup, the intent of this pr is to introduce channel args, not to address every piece of tech debt in the path",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/30008,907633563,2022-06-27T17:35:46Z,src/core/ext/filters/client_channel/lb_policy.h,"@@ -279,7 +279,7 @@ class LoadBalancingPolicy : public InternallyRefCounted<LoadBalancingPolicy> {      /// Creates a new subchannel with the specified channel args.     virtual RefCountedPtr<SubchannelInterface> CreateSubchannel(-        ServerAddress address, const grpc_channel_args& args) = 0;+        ServerAddress address, const ChannelArgs& args) = 0;",The decision to use `const&` everywhere was carefully made with measurements of bloat.`std::move` would mean that we need to do some work at every call site (to null the sending object and create the receiving object) and oftentimes also call a destructor - whereas `const&` makes the passing of channel args free - since we're just moving a pointer.With the way that we've plumbed channel args through many small forwarding functions this makes a relatively large difference in overall bloat.,X
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/30008,907640410,2022-06-27T17:41:44Z,src/core/ext/filters/client_channel/lb_policy_registry.h,"@@ -56,7 +56,7 @@ class LoadBalancingPolicyRegistry {   /// Returns true if the LB policy factory specified by \a name exists in this   /// registry. If the load balancing policy requires a config to be specified   /// then sets \a requires_config to true.-  static bool LoadBalancingPolicyExists(const char* name,+  static bool LoadBalancingPolicyExists(absl::string_view name,","let's do that as a different step: the intent of this PR is to get channel args moved, not to address every piece of tech debt.",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/30008,907648772,2022-06-27T17:51:17Z,src/core/lib/transport/http_connect_handshaker.cc,"@@ -311,14 +309,15 @@ void HttpConnectHandshaker::DoHandshake(grpc_tcp_server_acceptor* /*acceptor*/,     return;   }   // Get headers from channel args.-  arg = grpc_channel_args_find(args->args, GRPC_ARG_HTTP_CONNECT_HEADERS);-  char* arg_header_string = grpc_channel_arg_get_string(arg);+  absl::optional<absl::string_view> arg_header_string =+      args->args.GetString(GRPC_ARG_HTTP_CONNECT_HEADERS);   grpc_http_header* headers = nullptr;   size_t num_headers = 0;   char** header_strings = nullptr;   size_t num_header_strings = 0;-  if (arg_header_string != nullptr) {-    gpr_string_split(arg_header_string, ""\n"", &header_strings,+  if (arg_header_string.has_value()) {+    std::string buffer(*arg_header_string);+    gpr_string_split(buffer.c_str(), ""\n"", &header_strings,","Let's make that a later change: this change is intended to get the new channel args introduced, not to address every piece of tech debt.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/30028,907858731,2022-06-27T22:45:13Z,src/core/lib/iomgr/tcp_posix.cc,"@@ -1711,44 +1739,24 @@ grpc_endpoint* grpc_tcp_create(grpc_fd* em_fd,       grpc_core::TcpZerocopySendCtx::kDefaultSendBytesThreshold;   int tcp_tx_zerocopy_max_simult_sends =       grpc_core::TcpZerocopySendCtx::kDefaultMaxSends;-  if (channel_args != nullptr) {-    for (size_t i = 0; i < channel_args->num_args; i++) {-      if (0 ==-          strcmp(channel_args->args[i].key, GRPC_ARG_TCP_READ_CHUNK_SIZE)) {-        grpc_integer_options options = {tcp_read_chunk_size, 1, MAX_CHUNK_SIZE};-        tcp_read_chunk_size =-            grpc_channel_arg_get_integer(&channel_args->args[i], options);-      } else if (0 == strcmp(channel_args->args[i].key,-                             GRPC_ARG_TCP_MIN_READ_CHUNK_SIZE)) {-        grpc_integer_options options = {tcp_read_chunk_size, 1, MAX_CHUNK_SIZE};-        tcp_min_read_chunk_size =-            grpc_channel_arg_get_integer(&channel_args->args[i], options);-      } else if (0 == strcmp(channel_args->args[i].key,-                             GRPC_ARG_TCP_MAX_READ_CHUNK_SIZE)) {-        grpc_integer_options options = {tcp_read_chunk_size, 1, MAX_CHUNK_SIZE};-        tcp_max_read_chunk_size =-            grpc_channel_arg_get_integer(&channel_args->args[i], options);-      } else if (0 == strcmp(channel_args->args[i].key,-                             GRPC_ARG_TCP_TX_ZEROCOPY_ENABLED)) {-        tcp_tx_zerocopy_enabled = grpc_channel_arg_get_bool(-            &channel_args->args[i], kZerocpTxEnabledDefault);-      } else if (0 == strcmp(channel_args->args[i].key,-                             GRPC_ARG_TCP_TX_ZEROCOPY_SEND_BYTES_THRESHOLD)) {-        grpc_integer_options options = {-            grpc_core::TcpZerocopySendCtx::kDefaultSendBytesThreshold, 0,-            INT_MAX};-        tcp_tx_zerocopy_send_bytes_thresh =-            grpc_channel_arg_get_integer(&channel_args->args[i], options);-      } else if (0 == strcmp(channel_args->args[i].key,-                             GRPC_ARG_TCP_TX_ZEROCOPY_MAX_SIMULT_SENDS)) {-        grpc_integer_options options = {-            grpc_core::TcpZerocopySendCtx::kDefaultMaxSends, 0, INT_MAX};-        tcp_tx_zerocopy_max_simult_sends =-            grpc_channel_arg_get_integer(&channel_args->args[i], options);-      }-    }-  }-+  UpdateConfigIntegerValue(options, GRPC_ARG_TCP_READ_CHUNK_SIZE,","As mentioned elsewhere, we should do all of this clamping when we construct the `grpc_tcp_generic_options` struct, not here.Also, we should not extract values from `grpc_tcp_generic_options` and save them in the individual fields in the `grpc_tcp` struct.  Instead, we should remove all of those individual fields from the `grpc_tcp` struct and instead give it a data member of type `grpc_tcp_generic_options`.  (This is why it is important for `grpc_tcp_generic_options` to have an individual `int` field for each option rather than a map.)",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/30028,907861596,2022-06-27T22:48:22Z,src/core/lib/iomgr/tcp_windows.h,"@@ -36,12 +36,13 @@ #ifdef GRPC_WINSOCK_SOCKET #include ""src/core/lib/iomgr/endpoint.h"" #include ""src/core/lib/iomgr/socket_windows.h""+#include ""src/core/lib/iomgr/tcp_generic_options.h""  /* Create a tcp endpoint given a winsock handle.  * Takes ownership of the handle.  */ grpc_endpoint* grpc_tcp_create(grpc_winsocket* socket,-                               grpc_channel_args* channel_args,+                               const grpc_tcp_generic_options& options,","Might as well just remove this parameter, since it never gets used.",X
23140989,ZhenLian,https://api.github.com/repos/grpc/grpc/pulls/29810,907865720,2022-06-27T22:56:08Z,src/core/tsi/ssl_transport_security.cc,"@@ -2109,16 +2085,45 @@ tsi_result tsi_create_ssl_client_handshaker_factory_with_options(       SSL_CTX_set_next_proto_select_cb(           ssl_context, client_handshaker_factory_npn_callback, impl);     }++    if (options->skip_server_certificate_verification) {+      SSL_CTX_set_verify(ssl_context, SSL_VERIFY_PEER, NullVerifyCallback);+      *factory = impl;+      return TSI_OK;+    }++    if (options->pem_root_certs == nullptr && options->root_store == nullptr) {+      result = TSI_INVALID_ARGUMENT;+      break;+    }++    result = populate_ssl_context(ssl_context, options->pem_key_cert_pair,","Shouldn't these parameters of setting key-cert pairs, cipher suites and ssl version(L2100 - L2119) all happens before we set for skip_verify(L2090)? If we return early at L2092, then we are never going to set these parameters later. ",X
23140989,ZhenLian,https://api.github.com/repos/grpc/grpc/pulls/29810,907872260,2022-06-27T23:09:50Z,src/core/tsi/ssl_transport_security.cc,"@@ -2066,27 +2063,6 @@ tsi_result tsi_create_ssl_client_handshaker_factory_with_options(   }    do {","This is irrelevant to this change, but in regards to the pattern the code is using: ```do {  // ...} while (false);```it seems the only reason for using this pattern is to save space for doing `tsi_ssl_handshaker_factory_unref` in multiple places. But I think it sort of affects the readability, so I am not sure what's the best way in normal C++ style guide to handle this case. Might need @markdroth 's opinion on this...",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/30078,907875108,2022-06-27T23:15:45Z,src/core/lib/iomgr/resolve_address.h,"@@ -60,17 +61,38 @@ class DNSResolver {   // address this.   //   // \a interested_parties may be deleted after a request is cancelled.-  virtual TaskHandle ResolveName(-      absl::string_view name, absl::string_view default_port,-      grpc_pollset_set* interested_parties,+  virtual TaskHandle LookupHostname(       std::function<void(absl::StatusOr<std::vector<grpc_resolved_address>>)>-          on_done) = 0;+          on_resolved,+      absl::string_view name, absl::string_view default_port, Duration timeout,+      grpc_pollset_set* interested_parties, absl::string_view name_server) = 0;    // Resolve name in a blocking fashion. Use \a default_port if a port isn't   // designated in \a name, otherwise use the port in \a name.   virtual absl::StatusOr<std::vector<grpc_resolved_address>>-  ResolveNameBlocking(absl::string_view name,-                      absl::string_view default_port) = 0;+  LookupHostnameBlocking(absl::string_view name,+                         absl::string_view default_port) = 0;++  // Asynchronously resolve an SRV Record per gRFC A5: Load Balancing and DNS.+  // On completion, \a on_done is invoked with the result.+  //+  // The same caveats in \a LookupHostname apply here as well.+  //+  // Reference: https://github.com/grpc/proposal/blob/master/A5-grpclb-in-dns.md+  virtual TaskHandle LookupSRV(+      std::function<void(absl::StatusOr<std::vector<grpc_resolved_address>>)>","I think we want to keep the semantics here basically the same as in the EE API.  This should return a vector of [SRV records](https://github.com/grpc/grpc/blob/720bed25bca2b7cec085e987855eb9758c41c749/include/grpc/event_engine/event_engine.h#L302), not a vector of `grpc_resolved_address`.  The client channel resolver will be responsible for making a subsequent `LookupHostname()` call for each resulting SRV record to get the corresponding address.  This way, we keep the logic specific to grpclb-in-DNS in the client channel code instead of moving it into the iomgr impl.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/30078,907881263,2022-06-27T23:29:06Z,src/core/ext/filters/client_channel/resolver/dns/c_ares/grpc_ares_wrapper.cc,"@@ -827,46 +828,23 @@ static void on_txt_done_locked(void* arg, int status, int /*timeouts*/,   r->error = grpc_error_add_child(error, r->error); } -void grpc_dns_lookup_ares_continue_after_check_localhost_and_ip_literals_locked(-    grpc_ares_request* r, const char* dns_server, const char* name,-    const char* default_port, grpc_pollset_set* interested_parties,-    int query_timeout_ms) ABSL_EXCLUSIVE_LOCKS_REQUIRED(r->mu) {-  grpc_error_handle error = GRPC_ERROR_NONE;-  grpc_ares_hostbyname_request* hr = nullptr;-  /* parse name, splitting it into host and port parts */-  std::string host;-  std::string port;-  grpc_core::SplitHostPort(name, &host, &port);-  if (host.empty()) {-    error = grpc_error_set_str(-        GRPC_ERROR_CREATE_FROM_STATIC_STRING(""unparseable host:port""),-        GRPC_ERROR_STR_TARGET_ADDRESS, name);-    goto error_cleanup;-  } else if (port.empty()) {-    if (default_port == nullptr || strlen(default_port) == 0) {-      error = grpc_error_set_str(-          GRPC_ERROR_CREATE_FROM_STATIC_STRING(""no port in name""),-          GRPC_ERROR_STR_TARGET_ADDRESS, name);-      goto error_cleanup;-    }-    port = default_port;-  }-  error = grpc_ares_ev_driver_create_locked(&r->ev_driver, interested_parties,-                                            query_timeout_ms, r);-  if (!GRPC_ERROR_IS_NONE(error)) goto error_cleanup;-  // If dns_server is specified, use it.-  if (dns_server != nullptr && dns_server[0] != '\0') {-    GRPC_CARES_TRACE_LOG(""request:%p Using DNS server %s"", r, dns_server);+grpc_error_handle set_request_dns_server(grpc_ares_request* r,+                                         absl::string_view dns_server,+                                         const char* name)","I don't think we need the `name` parameter here.  The one place we're using it in an error message, the error message should probably use `dns_server` instead.",X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/30078,907902718,2022-06-27T23:59:32Z,src/core/ext/filters/client_channel/resolver/dns/c_ares/grpc_ares_wrapper.h,"@@ -78,23 +78,36 @@ struct grpc_ares_request {   grpc_error_handle error ABSL_GUARDED_BY(mu) = GRPC_ERROR_NONE; }; -/* Asynchronously resolve \a name. It will try to resolve grpclb SRV records in-  addition to the normal address records. For normal address records, it uses-  \a default_port if a port isn't designated in \a name, otherwise it uses the-  port in \a name. grpc_ares_init() must be called at least once before this-  function. The returned grpc_ares_request object is owned by the caller and it-  is safe to free after on_done is called back.+/* Asynchronously resolve \a name (A/AAAA records only).+  It uses \a default_port if a port isn't designated in \a name, otherwise it+  uses the port in \a name. grpc_ares_init() must be called at least once before+  this function. The returned grpc_ares_request object is owned by the caller+  and it is safe to free after on_done is called back.    Note on synchronization: \a as on_done might be called from another thread   ~immediately, access to the grpc_ares_request* return value must be   synchronized by the caller. TODO(apolcyn): we should remove this requirement   by changing this API to use two phase initialization - one API to create   the grpc_ares_request* and another to start the async work. */-extern grpc_ares_request* (*grpc_dns_lookup_ares)(+extern grpc_ares_request* (*grpc_dns_lookup_hostname_ares)(     const char* dns_server, const char* name, const char* default_port,     grpc_pollset_set* interested_parties, grpc_closure* on_done,     std::unique_ptr<grpc_core::ServerAddressList>* addresses,+    int query_timeout_ms);++// Asynchronously resolve a SRV record.+// See \a grpc_dns_lookup_hostname_ares for usage details and caveats.+extern grpc_ares_request* (*grpc_dns_lookup_srv_ares)(","There's a bit of a paradigm difference between how this code is currently structured and how the EE API will work.  In the current implementation, `grpc_ares_request` includes both state for whatever individual requests (A/AAAA, TXT, SRV) are currently in flight and overall state for the c-ares integration as a whole (i.e., the EV driver and integration into the underlying event loop).  However, in the EE API, we'll want the c-ares event-loop state to be in the `EventEngine::DNSResolver` object returned by `EventEngine::GetDNSResolver()`, and we'll want there to be a separate object (not exposed in the EE API, but stored internally in the EE impl) to track each individual request that is currently in flight on the resolver.It looks like this PR is changing the code such that we create a separate `grpc_ares_request` object for each individual request.  That can work, but it does mean that we're now duplicating all of the c-ares event-loop state for each individual DNS request rather than sharing it across all requests.There's obviously some increased overhead here, but I don't know how much.  It may or may not be enough to worry about.  @apolcyn, can you advise here as to how much we'd be duplicating and how much overhead that's likely to impose?  Are there any other down-sides here in terms of state that would no longer be shared across the various DNS requests?I see three basic alternatives here:1. Just accept this duplication permanently.  We can go forward with this PR and the next two steps (moving this code into iomgr and then moving it into the EE impl) all without changing this paradigm.  This would probably work, but it would somewhat defeat the purpose of having a separate `DNSResolver` object in the EE API, since that object was designed to support the c-ares event-loop code, but instead our EE impl wouldn't actually use that object for anything other than a sort of factory for the individual request methods.2. An alternative would be to refactor this code such that it's structured the same way that we want it to be structured in the EE API.  @apolcyn had actually done this as part of #25108, but that PR got reverted due to b/183105719, and we never put in the time to figure out what happened and get it rolled forward.  It might be worth looking into what happened there and seeing if we can get that PR rolled forward before we proceed with this one.   - Note: Under this option, we'll need one other small change in the iomgr API.  The iomgr `GetDNSResolver()` function currently returns a raw pointer that the caller does not own (it's intended to return a global singleton).  However, since we'd now be building c-ares event-loop state into that object, we'd need to change that function to return an owned object.  We can probably have it return `OrphanablePtr<DNSResolver>`; in the native implementation, that object can still be a singleton, where `Orphan()` is a no-op, but the c-ares implementation can return a separate `InternallyRefCounted<>` object for each call.  This doesn't seem like a big change, though.3. Accept the duplication for now, but plan to fix it later.  This would basically mean doing option 1, and then after we get all of the code moved into the EE impl, we can refactor it to de-duplicate the event-loop integration.  This might be faster in the short term, but (a) once we've already finished migrating the code into the EE impl, there won't be much motivation to do this refactoring, so we may never get to it, and (b) we may miss problems in the EE API design that might be uncovered by actually using the `DNSResolver` object as it's intended to be used.My preference would be for option 2.",X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/30078,908619410,2022-06-28T15:22:59Z,src/core/ext/filters/client_channel/resolver/dns/c_ares/dns_resolver_ares.cc,"@@ -363,51 +439,45 @@ class AresClientChannelDNSResolverFactory : public ResolverFactory {  class AresDNSResolver : public DNSResolver {  public:+  // Abstract class that centralizes common request handling logic via the","The interactions between the base class and the subclasses here is fairly complex and hard to follow.  I think this is a symptom of the problem I pointed out in my other comment, where the paradigm of the current c-ares code does not match that of the EE API.  I think if we clean up that underlying problem, then this code will get a lot simpler, because a lot of the state that is currently being stored in the `AresRequest` base class will instead be able to be stored in the `DNSResolver` class itself, which all of the individual request objects will have a ref to.",X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/30078,908621268,2022-06-28T15:24:39Z,src/core/ext/filters/client_channel/resolver/dns/c_ares/dns_resolver_ares.cc,"@@ -416,65 +486,224 @@ class AresDNSResolver : public DNSResolver {       return {reinterpret_cast<intptr_t>(this), aba_token_};     } +   protected:+    AresRequest(grpc_pollset_set* interested_parties, AresDNSResolver* resolver,+                intptr_t aba_token)+        : pollset_set_(grpc_pollset_set_create()),+          interested_parties_(interested_parties),+          completed_(false),+          resolver_(resolver),+          aba_token_(aba_token) {+      GRPC_CLOSURE_INIT(&on_dns_lookup_done_, OnDnsLookupDone, this,+                        grpc_schedule_on_exec_ctx);+      grpc_pollset_set_add_pollset_set(pollset_set_, interested_parties_);+    }++    // closure to call when the ares resolution request completes. Subclasses+    // should use this as the ares callback in MakeRequestLocked()+    grpc_closure on_dns_lookup_done_ ABSL_GUARDED_BY(mu_);+    // locally owned pollset_set, required to support cancellation of requests+    // while ares still needs a valid pollset_set. Subclasses should give this+    // pollset to ares in MakeRequestLocked();+    grpc_pollset_set* pollset_set_;+    private:     // Called by ares when lookup has completed or when cancelled. It is always-    // called exactly once.+    // called exactly once, and it triggers self-deletion.     static void OnDnsLookupDone(void* arg, grpc_error_handle error) {-      AresRequest* request = static_cast<AresRequest*>(arg);-      GRPC_CARES_TRACE_LOG(""AresRequest:%p OnDnsLookupDone"", request);-      // This request is deleted and unregistered upon any exit.-      std::unique_ptr<AresRequest> deleter(request);-      std::vector<grpc_resolved_address> resolved_addresses;+      AresRequest* r = static_cast<AresRequest*>(arg);+      auto deleter = std::unique_ptr<AresRequest>(r);       {-        MutexLock lock(&request->mu_);-        if (request->completed_) return;-        request->completed_ = true;-        if (request->addresses_ != nullptr) {-          resolved_addresses.reserve(request->addresses_->size());-          for (const auto& server_address : *request->addresses_) {-            resolved_addresses.push_back(server_address.address());-          }+        MutexLock lock(&r->mu_);+        grpc_pollset_set_del_pollset_set(r->pollset_set_,+                                         r->interested_parties_);+        if (r->completed_) {+          return;         }+        r->completed_ = true;       }-      grpc_pollset_set_del_pollset_set(request->pollset_set_,-                                       request->interested_parties_);-      if (!GRPC_ERROR_IS_NONE(error)) {-        request->on_resolve_address_done_(grpc_error_to_absl_status(error));-        return;-      }-      request->on_resolve_address_done_(std::move(resolved_addresses));+      r->OnComplete(error);     }      // mutex to synchronize access to this object (but not to the ares_request     // object itself).     Mutex mu_;+    // parties interested in our I/O+    grpc_pollset_set* const interested_parties_;+    // underlying cares_request that the query is performed on+    std::unique_ptr<grpc_ares_request> grpc_ares_request_ ABSL_GUARDED_BY(mu_);+    // Set when the callback is either cancelled or executed.+    // It is not the subclasses' responsibility to set this flag.+    bool completed_ ABSL_GUARDED_BY(mu_);+    // Parent resolver that created this request+    AresDNSResolver* resolver_;+    // Unique token to help distinguish this request from others that may later+    // be created in the same memory location.+    intptr_t aba_token_;+  };++  class AresHostnameRequest : public AresRequest {+   public:+    AresHostnameRequest(+        absl::string_view name, absl::string_view default_port,+        absl::string_view name_server, Duration timeout,+        grpc_pollset_set* interested_parties,+        std::function<void(absl::StatusOr<std::vector<grpc_resolved_address>>)>+            on_resolve_address_done,+        AresDNSResolver* resolver, intptr_t aba_token)+        : AresRequest(interested_parties, resolver, aba_token),+          name_(std::string(name)),+          default_port_(std::string(default_port)),+          name_server_(std::string(name_server)),+          timeout_(timeout),+          on_resolve_address_done_(std::move(on_resolve_address_done)) {+      GRPC_CARES_TRACE_LOG(""AresHostnameRequest:%p ctor"", this);+    }++    std::unique_ptr<grpc_ares_request> MakeRequestLocked() override {+      auto ares_request =+          std::unique_ptr<grpc_ares_request>(grpc_dns_lookup_hostname_ares(+              name_server_.c_str(), name_.c_str(), default_port_.c_str(),+              pollset_set_, &on_dns_lookup_done_, &addresses_,+              timeout_.millis()));+      GRPC_CARES_TRACE_LOG(""AresHostnameRequest:%p Start ares_request_:%p"",+                           this, ares_request.get());+      return ares_request;+    }++    void OnComplete(grpc_error_handle error) override {+      GRPC_CARES_TRACE_LOG(""AresHostnameRequest:%p OnComplete"", this);+      if (!GRPC_ERROR_IS_NONE(error)) {+        on_resolve_address_done_(grpc_error_to_absl_status(error));+        return;+      }+      std::vector<grpc_resolved_address> resolved_addresses;+      if (addresses_ != nullptr) {+        resolved_addresses.reserve(addresses_->size());+        for (const auto& server_address : *addresses_) {+          resolved_addresses.push_back(server_address.address());+        }+      }+      on_resolve_address_done_(std::move(resolved_addresses));+    }+     // the name to resolve     const std::string name_;","The `name_`, `name_server_`, and `timeout_` members are common to all subclasses.  Maybe move these to the base class, with protected accessor methods?",X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/30078,908633122,2022-06-28T15:35:26Z,src/core/lib/iomgr/resolve_address_posix.cc,"@@ -82,19 +85,20 @@ NativeDNSResolver* NativeDNSResolver::GetOrCreate() {   return instance; } -DNSResolver::TaskHandle NativeDNSResolver::ResolveName(-    absl::string_view name, absl::string_view default_port,-    grpc_pollset_set* /* interested_parties */,+DNSResolver::TaskHandle NativeDNSResolver::LookupHostname(     std::function<void(absl::StatusOr<std::vector<grpc_resolved_address>>)>-        on_done) {+        on_done,+    absl::string_view name, absl::string_view default_port,+    Duration /* timeout */, grpc_pollset_set* /* interested_parties */,","It seems a little sub-optimal for this code not to support the timeout parameter.  Presumably, we can support that by starting a timer, and if the timer fires before it gets cancelled, we cancel the DNS request.",
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/30078,908785722,2022-06-28T17:54:22Z,src/core/ext/filters/client_channel/resolver/dns/c_ares/dns_resolver_ares.cc,"@@ -276,15 +317,51 @@ std::string ChooseServiceConfig(char* service_config_choice_json,   return service_config->Dump(); } -void AresClientChannelDNSResolver::AresRequestWrapper::OnResolved(+void AresClientChannelDNSResolver::AresRequestWrapper::OnHostnameResolved(+    void* arg, grpc_error_handle error) {+  auto* self = static_cast<AresRequestWrapper*>(arg);+  {+    MutexLock lock(&self->on_resolved_mu_);+    self->hostname_request_.reset();+    self->OnResolvedLocked(error);+  }+  self->Unref(DEBUG_LOCATION, ""OnHostnameResolved"");+}++void AresClientChannelDNSResolver::AresRequestWrapper::OnSRVResolved(+    void* arg, grpc_error_handle error) {+  auto* self = static_cast<AresRequestWrapper*>(arg);+  {+    MutexLock lock(&self->on_resolved_mu_);+    self->srv_request_.reset();+    self->OnResolvedLocked(error);+  }+  self->Unref(DEBUG_LOCATION, ""OnSRVResolved"");+}++void AresClientChannelDNSResolver::AresRequestWrapper::OnTXTResolved(     void* arg, grpc_error_handle error) {   auto* self = static_cast<AresRequestWrapper*>(arg);-  self->OnResolved(error);+  {+    MutexLock lock(&self->on_resolved_mu_);+    self->txt_request_.reset();+    self->OnResolvedLocked(error);+  }+  self->Unref(DEBUG_LOCATION, ""OnTXTResolved""); } -void AresClientChannelDNSResolver::AresRequestWrapper::OnResolved(-    grpc_error_handle error) {-  GRPC_CARES_TRACE_LOG(""resolver:%p OnResolved()"", this);+void AresClientChannelDNSResolver::AresRequestWrapper::OnResolvedLocked(+    grpc_error_handle error) ABSL_EXCLUSIVE_LOCKS_REQUIRED(on_resolved_mu_) {+  if (hostname_request_ != nullptr || srv_request_ != nullptr ||+      txt_request_ != nullptr) {+    GRPC_CARES_TRACE_LOG(+        ""resolver:%p OnResolved() waiting for results (hostname: %s, srv: %s, ""+        ""txt: %s)"",+        this, hostname_request_ ? ""waiting"" : ""done"",","Done. For future reference though, as is, this code uses unique_ptr's `operator bool` overload, which I think is fine https://en.cppreference.com/w/cpp/memory/unique_ptr/operator_bool. I don't believe it's against the style guide, given that the conversion operator already exists, and I think the usage is unambiguous in this statement.",
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/30078,908827738,2022-06-28T18:47:21Z,src/core/lib/iomgr/resolve_address.h,"@@ -60,17 +61,38 @@ class DNSResolver {   // address this.   //   // \a interested_parties may be deleted after a request is cancelled.-  virtual TaskHandle ResolveName(-      absl::string_view name, absl::string_view default_port,-      grpc_pollset_set* interested_parties,+  virtual TaskHandle LookupHostname(       std::function<void(absl::StatusOr<std::vector<grpc_resolved_address>>)>-          on_done) = 0;+          on_resolved,+      absl::string_view name, absl::string_view default_port, Duration timeout,+      grpc_pollset_set* interested_parties, absl::string_view name_server) = 0;    // Resolve name in a blocking fashion. Use \a default_port if a port isn't   // designated in \a name, otherwise use the port in \a name.   virtual absl::StatusOr<std::vector<grpc_resolved_address>>-  ResolveNameBlocking(absl::string_view name,-                      absl::string_view default_port) = 0;+  LookupHostnameBlocking(absl::string_view name,+                         absl::string_view default_port) = 0;++  // Asynchronously resolve an SRV Record per gRFC A5: Load Balancing and DNS.+  // On completion, \a on_done is invoked with the result.+  //+  // The same caveats in \a LookupHostname apply here as well.+  //+  // Reference: https://github.com/grpc/proposal/blob/master/A5-grpclb-in-dns.md+  virtual TaskHandle LookupSRV(+      std::function<void(absl::StatusOr<std::vector<grpc_resolved_address>>)>","That is the plan, but currently that's a step away. I've already made some progress on it in a followup branch that brings in other EE changes as well. I can consider merging that in to this PR instead, but felt it belonged with a broader set of EE type and semantics changes.",
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/30078,908933552,2022-06-28T20:47:12Z,src/core/ext/filters/client_channel/resolver/dns/c_ares/dns_resolver_ares.cc,"@@ -363,51 +439,45 @@ class AresClientChannelDNSResolverFactory : public ResolverFactory {  class AresDNSResolver : public DNSResolver {  public:+  // Abstract class that centralizes common request handling logic via the","This is classic Template Method Pattern. I'm not a huge fan of behavior or state inheritance in general, but it's not confusing to me when viewed with the pattern in mind. This code will change when we land the broader EE semantics, but that may be a thing for a subsequent stage (see my other comment about this).",
702191,arjunroy,https://api.github.com/repos/grpc/grpc/pulls/29961,909025771,2022-06-28T21:50:48Z,src/core/lib/iomgr/tcp_posix.cc,"@@ -312,7 +316,51 @@ class TcpZerocopySendCtx {   // zerocopy is not useful for small transfers.   size_t threshold_bytes() const { return threshold_bytes_; } +  // Expected to be called by handler reading messages from the err queue.+  // It is used to indicate that some OMem meory is now available. It returns+  // true to tell the caller to mark the file descriptor as immediately+  // writable.","Please enumerate also the cases where it might return false. ie. something like:""If a write is currently in progress on the socket (ie. we have issued a sendmsg() and are about to check its return value) then we set omem state to CHECK to make the sending thread knows that some tcp_omem was concurrently freed even if sendmsg() returns ENOBUFS. In this case, since there is already an active send thread, we do not need to mark the socket writeable, so we return false.""""If there was no write in progress on the socket, and the socket was not marked as FULL, then we need not mark the socket writeable now that some tcp_omem memory is freed since it was not considered as blocked on tcp_omem to begin with. So in this case, return false.""""But, if a write was _not_ in progress and the omem state was FULL, then we need to mark the socket writeable since it is no longer blocked by tcp_omem. In this case, return true.""",
9566254,apolcyn,https://api.github.com/repos/grpc/grpc/pulls/30081,909226195,2022-06-29T05:59:08Z,src/ruby/ext/grpc/extconf.rb,"@@ -85,6 +86,7 @@ def env_append(name, string)  env_append 'CPPFLAGS', '-DGPR_BACKWARDS_COMPATIBILITY_MODE' env_append 'CPPFLAGS', '-DGRPC_XDS_USER_AGENT_NAME_SUFFIX=""\""RUBY\""""'+env_append 'CPPFLAGS', '-DGPR_WINDOWS_UCRT' if windows_ucrt","minor naming nit: this isn't a typical ""GPR"" macro, like the rest of the ones defined [here](https://github.com/grpc/grpc/blob/master/include/grpc/impl/codegen/port_platform.h) for the C-core library, so it feels out of place to use that here.Can we rename this to `GRPC_RUBY_WINDOWS_UCRT` ?",X
9566254,apolcyn,https://api.github.com/repos/grpc/grpc/pulls/30078,909287612,2022-06-29T07:25:50Z,src/core/ext/filters/client_channel/resolver/dns/c_ares/grpc_ares_wrapper.h,"@@ -78,23 +78,36 @@ struct grpc_ares_request {   grpc_error_handle error ABSL_GUARDED_BY(mu) = GRPC_ERROR_NONE; }; -/* Asynchronously resolve \a name. It will try to resolve grpclb SRV records in-  addition to the normal address records. For normal address records, it uses-  \a default_port if a port isn't designated in \a name, otherwise it uses the-  port in \a name. grpc_ares_init() must be called at least once before this-  function. The returned grpc_ares_request object is owned by the caller and it-  is safe to free after on_done is called back.+/* Asynchronously resolve \a name (A/AAAA records only).+  It uses \a default_port if a port isn't designated in \a name, otherwise it+  uses the port in \a name. grpc_ares_init() must be called at least once before+  this function. The returned grpc_ares_request object is owned by the caller+  and it is safe to free after on_done is called back.    Note on synchronization: \a as on_done might be called from another thread   ~immediately, access to the grpc_ares_request* return value must be   synchronized by the caller. TODO(apolcyn): we should remove this requirement   by changing this API to use two phase initialization - one API to create   the grpc_ares_request* and another to start the async work. */-extern grpc_ares_request* (*grpc_dns_lookup_ares)(+extern grpc_ares_request* (*grpc_dns_lookup_hostname_ares)(     const char* dns_server, const char* name, const char* default_port,     grpc_pollset_set* interested_parties, grpc_closure* on_done,     std::unique_ptr<grpc_core::ServerAddressList>* addresses,+    int query_timeout_ms);++// Asynchronously resolve a SRV record.+// See \a grpc_dns_lookup_hostname_ares for usage details and caveats.+extern grpc_ares_request* (*grpc_dns_lookup_srv_ares)(","I think I favor option 1), because this should amount to the simplest code, and at the moment I'm skeptical that the benefits of the shared state approach are worth the complexity.In particular, I'm thinking about the following:a) Since grpclb is deprecated, SRV queries should actually go away long term.b) TXT queries aren't enabled by default. This point might be reconsidered once they are or are soon to be.c) I don't know of a use case that really relies on large amounts of concurrent SRV and/or TXT queries. E.g.., personally I'd be surprised if an extra file descriptor or two per DNS resolution caused problems.> That said, @apolcyn was it terribly difficult to debug the problems with the refactored resolver? I'm curious about your time investment there.The problem I ran into was basically a problem with an integration test I was unfamiliar with, and which I couldn't (easily) run myself or gather more info about, to debug further. I then just didn't find time to push forward on it :(That said, when I originally submitted that PR, it was using a work serializer. I know at least one bug fix has been made to the work serializer since then. Also, the c-ares wrapper code has since changed to use a mutex. So I wouldn't be surprised if the bug has been fixed in the interim, and maybe we could retry the test.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/30138,910097065,2022-06-29T15:17:07Z,test/cpp/end2end/xds/xds_end2end_test.cc,"@@ -356,59 +370,37 @@ class XdsSecurityTest : public XdsEnd2endTest {     }     balancer_->ads_service()->SetCdsResource(cluster);     // The updates might take time to have an effect, so use a retry loop.-    constexpr int kRetryCount = 100;-    int num_tries = 0;-    for (; num_tries < kRetryCount; num_tries++) {-      // Restart the servers to force a reconnection so that previously-      // connected subchannels are not used for the RPC.-      ShutdownBackend(0);-      StartBackend(0);-      if (test_expects_failure) {+    if (test_expects_failure) {+      auto overall_deadline = absl::Now() + absl::Seconds(20);+      while (absl::Now() < overall_deadline) {+        // TODO(yashykt): Change individual test cases to expect the exact error+        // message here.         if (SendRpc().ok()) {           gpr_log(GPR_ERROR, ""RPC succeeded. Failure expected. Trying again."");           continue;         }-      } else {-        WaitForBackend(DEBUG_LOCATION, 0, [](const RpcResult& result) {-          if (!result.status.ok()) {-            EXPECT_EQ(result.status.error_code(), StatusCode::UNAVAILABLE);-            // TODO(yashkt): Rework this test suite such that the caller-            // explicitly indicates which failure they're allowed to see here,-            // rather than blindly allowing every possibility in every test.-            // TODO(roth): Plumb a better error out of the handshakers-            // as part of https://github.com/grpc/grpc/issues/22883.-            EXPECT_THAT(-                result.status.error_message(),-                ::testing::MatchesRegex(-                    ""connections to all backends failing; last error: ""-                    ""(UNKNOWN: Failed to connect to remote host: Connection ""-                    ""(refused|reset by peer)|UNAVAILABLE: Failed to connect ""-                    ""to remote host: FD shutdown|UNKNOWN: Tls handshake failed|""-                    ""UNAVAILABLE: Socket closed|UNAVAILABLE: Broken pipe)""));-          }-        });-        Status status = SendRpc();-        if (!status.ok()) {-          gpr_log(GPR_ERROR, ""RPC failed. code=%d message=%s Trying again."",-                  status.error_code(), status.error_message().c_str());-          continue;-        }-        if (backends_[0]->backend_service()->last_peer_identity() !=-            expected_authenticated_identity) {-          gpr_log(-              GPR_ERROR,-              ""Expected client identity does not match. (actual) %s vs ""-              ""(expected) %s Trying again."",-              absl::StrJoin(-                  backends_[0]->backend_service()->last_peer_identity(), "","")-                  .c_str(),-              absl::StrJoin(expected_authenticated_identity, "","").c_str());-          continue;-        }+        break;       }-      break;+      EXPECT_LT(absl::Now(), overall_deadline);+    } else {+      // Make sure that we are hitting the correct backend.+      backends_[backend_index_]->backend_service()->ResetCounters();+      SendRpcsUntil(","The lambda you're currently using with `SendRpcsUntil()` is effectively the same one that is used by `WaitForBackend()`, with the exception that it is not checking that the RPCs actually succeed -- and we should be doing that check here.  So I think this should be:```WaitForBackend(    DEBUG_LOCATION, backend_index_, /*check_status=*/nullptr,    WaitForBackendOptions().set_timeout_ms(20 * 1000));```",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/30138,910111544,2022-06-29T15:28:03Z,test/cpp/end2end/xds/xds_end2end_test.cc,"@@ -321,7 +322,20 @@ class XdsSecurityTest : public XdsEnd2endTest {       const std::vector<StringMatcher>& san_matchers,       const std::vector<std::string>& expected_authenticated_identity,       bool test_expects_failure = false) {+    // Change the backend and use a unique service name to use so that we know+    // that the CDS update was applied.+    std::string service_name = absl::StrCat(+        ""eds_service_name"",+        absl::FormatTime(""%H%M%E3S"", absl::Now(), absl::LocalTimeZone()));","Instead of dynamically creating a new EDS resource each time and using a timestamp in the name, I suggest changing `SetUp()` to unconditionally create a second EDS resource pointing to backend 1 with a fixed name, and then toggling between the two EDS names here.  I'm thinking you can use something like this:```backend_index_ = (backend_index_ + 1) % 2;std::string eds_resource_name =    absl::StrCat(kDefaultEdsServiceName, backend_index_ > 0 ? backend_index_ : """");```",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/30058,910122233,2022-06-29T15:36:31Z,src/core/lib/security/authorization/grpc_authorization_policy_provider.cc,"@@ -130,6 +141,14 @@ FileWatcherAuthorizationPolicyProvider::FileWatcherAuthorizationPolicyProvider(   refresh_thread_->Start(); } +void FileWatcherAuthorizationPolicyProvider::SetCallbackForTesting(+    std::function<void(grpc_status_code code, const char* error_details)> cb) {+  MutexLock lock(&mu_);+  if (cb_ == nullptr) {","Why check if it's null?  Presumably, if this method is called a second time, that indicates that the caller wants to change the callback, and I don't see any reason not to allow that.  I think we should just set `cb_` unconditionally here.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/30058,910134928,2022-06-29T15:46:49Z,src/core/lib/security/authorization/grpc_authorization_policy_provider.cc,"@@ -140,6 +159,7 @@ absl::Status FileWatcherAuthorizationPolicyProvider::ForceUpdate() {     return absl::OkStatus();   }   file_contents_ = std::move(*file_contents);+  execute_cb_ = true;","The logic around `execute_cb_` is extremely hard to follow.  It looks like the callback is not being executed when the file read fails, nor is it being executed if the file contents have not changed, but it is being executed for all other cases, which seems a little arbitrary.  The intended semantic here wasn't clear from reading the code; it took me a while to understand that the intent was to invoke the callback only when the policy has been updated.I think we should move this complexity from the production code into the test code.  I suggest that we add a parameter to the callback to indicate whether the file contents have changed, and then we unconditionally invoke it every time we call `ForceUpdate()`, and let the test code deal with the duplicate calls.  For example:```// Define a convenient lambda to ensure that we invoke the callback as we return.bool contents_changed = false;auto done_early = [&](absl::Status status) {  {    MutexLock lock(&mu_);    if (cb_ != nullptr) cb_(contents_changed, status);  }  return status;};```Then, between the top of the function and the point where we grab the lock (line 167), change every line that says `return status;` to instead say `return done_early(status);`.Once we know that the file contents have changed, we can set `contents_changed` to true.  This will ensure that the lambda passes the right value to the callback.Once we do grab the lock on line 167, we can't use the lambda, because we'll already be holding the lock.  So in that case, we just invoke the callback manually right before we return:```if (cb_ != nullptr) cb_(true, absl::OkStatus());```",X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/30058,910138854,2022-06-29T15:50:32Z,test/core/end2end/tests/grpc_authz.cc,"@@ -15,6 +15,8 @@ #include <stdio.h> #include <string.h> +#include ""absl/synchronization/notification.h""","As per https://github.com/grpc/grpc/blob/master/third_party/ABSEIL_MANUAL.md, it is not yet safe to use absl synchronization code in C-core.  Instead of using `absl::Notification`, please use `gpr_event`.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/30058,910171538,2022-06-29T16:23:15Z,test/core/end2end/tests/grpc_authz.cc,"@@ -546,6 +540,16 @@ static void test_file_watcher_valid_policy_reload(           tmp_policy.name().c_str(), /*refresh_interval_sec=*/1, &code,           &error_details);   GPR_ASSERT(GRPC_STATUS_OK == code);+  absl::Notification on_reload_done;+  std::function<void(grpc_status_code code, const char* error_details)>+      callback = [&on_reload_done](grpc_status_code status,+                                   const char* error_details) {+        GPR_ASSERT(GRPC_STATUS_OK == status);+        GPR_ASSERT(nullptr == error_details);+        on_reload_done.Notify();+      };+  dynamic_cast<grpc_core::FileWatcherAuthorizationPolicyProvider*>(provider)+      ->SetCallbackForTesting(std::move(callback));","To be safe, I think we should reset the callback to null at the end of each test, to make sure that the lambda does not get called again after we return from this function, because the state captured by the lambda will no longer be valid then.Same thing in all tests.",
55257063,ashithasantosh,https://api.github.com/repos/grpc/grpc/pulls/30058,911195180,2022-06-30T15:54:44Z,src/core/lib/security/authorization/grpc_authorization_policy_provider.h,"@@ -101,7 +106,12 @@ class FileWatcherAuthorizationPolicyProvider   std::unique_ptr<Thread> refresh_thread_;   gpr_event shutdown_event_; +  bool execute_cb_ = false;","Since this variable is only used by the refresh thread, I didn't use a mutex here. The current code no longer uses this variable,",X
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/30135,911235407,2022-06-30T16:35:12Z,src/core/lib/event_engine/iomgr_engine/ev_posix.h,"@@ -0,0 +1,107 @@+// Copyright 2022 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++#ifndef GRPC_CORE_LIB_EVENT_ENGINE_IOMGR_ENGINE_EV_POSIX_H+#define GRPC_CORE_LIB_EVENT_ENGINE_IOMGR_ENGINE_EV_POSIX_H+#include <grpc/support/port_platform.h>++#include <vector>++#include ""absl/status/status.h""+#include ""absl/strings/string_view.h""++#include <grpc/event_engine/event_engine.h>++#include ""src/core/lib/event_engine/iomgr_engine/closure.h""+#include ""src/core/lib/gprpp/time.h""++namespace grpc_event_engine {+namespace iomgr_engine {++class EventHandle {+ public:+  virtual ~EventHandle() = default;+};++class EventPoller {+ public:+  // Return an opaque handle to perform actions on the provided file descriptor.+  virtual EventHandle* CreateHandle(int fd, absl::string_view name,+                                    bool track_err) = 0;+  // Return wrapped file descriptor corresponding to the handle.+  virtual int WrappedFd(EventHandle* handle) = 0;+  // Delete the handle and optionally close the underlying file descriptor if+  // release_fd != nullptr. The on_done closure is scheduled to be invoked+  // after the operation is complete. After this operation, NotifyXXX and SetXXX+  // operations cannot be performed on the handle.+  virtual void OrphanHandle(EventHandle* handle, IomgrEngineClosure* on_done,+                            int* release_fd, absl::string_view reason) = 0;+  // Shutdown a handle. After this operation, NotifyXXX and SetXXX operations+  // cannot be performed.+  virtual void ShutdownHandle(EventHandle* handle, absl::Status why) = 0;+  // Schedule on_read to be invoked when the underlying file descriptor+  // becomes readable.+  virtual void NotifyOnRead(EventHandle* handle,+                            IomgrEngineClosure* on_read) = 0;+  // Schedule on_write to be invoked when the underlying file descriptor+  // becomes writable.+  virtual void NotifyOnWrite(EventHandle* handle,+                             IomgrEngineClosure* on_write) = 0;+  // Schedule on_error to be invoked when the underlying file descriptor+  // encounters errors.+  virtual void NotifyOnError(EventHandle* handle,+                             IomgrEngineClosure* on_error) = 0;+  // Force set a readable event on the underlying file descriptor.+  virtual void SetReadable(EventHandle* handle) = 0;+  // Force set a writable event on the underlying file descriptor.+  virtual void SetWritable(EventHandle* handle) = 0;+  // Force set a error event on the underlying file descriptor.+  virtual void SetHasError(EventHandle* handle) = 0;+  // Returns true if the handle has been shutdown.+  virtual bool IsHandleShutdown(EventHandle* handle) = 0;+  // Execute any pending actions that may have been set to a handle after the+  // last invocation of Work(...) function.+  virtual void ExecutePendingActions(EventHandle* handle) = 0;+  // Shuts down and deletes the poller. It is legal to call this function+  // only when no other poller method is in progress. For instance, it is+  // not safe to call this method, while a thread is blocked on Work(...).+  // A graceful way to terminate the poller could be to:+  // 1. First orphan all created handles.+  // 2. Send a Kick() to the thread executing Work(...) and wait for the+  //    thread to return.+  // 3. Call Shutdown() on the poller.+  virtual void Shutdown() = 0;+  // Poll all the underlying file descriptors for the specified period+  // and return a vector containing a list of handles which have pending+  // events. The calling thread should invoke ExecutePendingActions on each+  // returned handle to take the necessary pending actions. Only one thread+  // may invoke the Work function at any given point in time. The Work(...)+  // method returns an absl Non-OK status if it was Kicked.+  virtual absl::Status Work(grpc_core::Timestamp deadline,+                            std::vector<EventHandle*>& pending_events) = 0;+  // Trigger the thread executing Work(..) to break out as soon as possible.+  // This function is useful in tests. It may also be used to break a thread+  // out of Work(...) before calling Shutdown() on the poller.+  virtual void Kick() = 0;",The big use of this will be when we integrate polling with timers! (when a timer is scheduled before the first currently scheduled timer we need to break out of our wait loop),
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/30135,911240033,2022-06-30T16:40:34Z,src/core/lib/event_engine/iomgr_engine/ev_posix.cc,"@@ -0,0 +1,30 @@+// Copyright 2022 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++#include <grpc/support/port_platform.h>++#include ""src/core/lib/event_engine/iomgr_engine/ev_posix.h""++#include ""src/core/lib/event_engine/iomgr_engine/ev_epoll1_linux.h""++namespace grpc_event_engine {+namespace iomgr_engine {++EventPoller* GetDefaultPoller(experimental::EventEngine* engine) {",move to a default_poller.cc so that the base class target does not need to depend on the implementation target in the bazel build file,X
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/30135,911243332,2022-06-30T16:43:48Z,src/core/lib/event_engine/iomgr_engine/ev_epoll1_linux.h,"@@ -0,0 +1,85 @@+// Copyright 2022 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++#ifndef GRPC_CORE_LIB_EVENT_ENGINE_IOMGR_ENGINE_EV_EPOLL1_LINUX_H+#define GRPC_CORE_LIB_EVENT_ENGINE_IOMGR_ENGINE_EV_EPOLL1_LINUX_H++#include <grpc/support/port_platform.h>++#include <list>+#include <memory>+#include <vector>++#include ""absl/base/thread_annotations.h""+#include ""absl/status/status.h""+#include ""absl/strings/string_view.h""+#include ""absl/synchronization/mutex.h""++#include <grpc/event_engine/event_engine.h>++#include ""src/core/lib/event_engine/iomgr_engine/closure.h""+#include ""src/core/lib/event_engine/iomgr_engine/ev_posix.h""+#include ""src/core/lib/event_engine/iomgr_engine/wakeup_fd_posix.h""+#include ""src/core/lib/gprpp/time.h""++namespace grpc_event_engine {+namespace iomgr_engine {++typedef struct epoll_set epoll_set;++// Definition of epoll1 based poller.+class Epoll1Poller : public EventPoller {+ public:+  explicit Epoll1Poller(experimental::EventEngine* engine);+  EventHandle* CreateHandle(int fd, absl::string_view name,+                            bool track_err) override;+  int WrappedFd(EventHandle* handle) override;+  void OrphanHandle(EventHandle* handle, IomgrEngineClosure* on_done,+                    int* release_fd, absl::string_view reason) override;+  void ShutdownHandle(EventHandle* handle, absl::Status why) override;+  void NotifyOnRead(EventHandle* handle, IomgrEngineClosure* on_read) override;+  void NotifyOnWrite(EventHandle* handle,+                     IomgrEngineClosure* on_write) override;+  void NotifyOnError(EventHandle* handle,+                     IomgrEngineClosure* on_error) override;+  void SetReadable(EventHandle* handle) override;+  void SetWritable(EventHandle* handle) override;+  void SetHasError(EventHandle* handle) override;+  bool IsHandleShutdown(EventHandle* handle) override;+  void ExecutePendingActions(EventHandle* handle) override;+  absl::Status Work(grpc_core::Timestamp deadline,+                    std::vector<EventHandle*>& pending_events) override;+  void Kick() override;+  experimental::EventEngine* Engine() { return engine_; }+  void Shutdown() override;+  ~Epoll1Poller() override;++ private:+  absl::Mutex mu_;+  experimental::EventEngine* engine_;+  // A singleton epoll set+  epoll_set* g_epoll_set_;",We can roll the epoll_set members into `Epoll1Poller` (we'll want a different set per instantiation of this anyway),
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/30135,911244245,2022-06-30T16:44:48Z,src/core/lib/event_engine/iomgr_engine/ev_epoll1_linux.cc,"@@ -0,0 +1,673 @@+// Copyright 2022 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++#include <grpc/support/port_platform.h>++#include ""src/core/lib/event_engine/iomgr_engine/ev_epoll1_linux.h""++#include <stdint.h>++#include <algorithm>+#include <memory>++#include ""absl/memory/memory.h""+#include ""absl/status/statusor.h""+#include ""absl/strings/str_cat.h""++#include <grpc/impl/codegen/gpr_types.h>+#include <grpc/support/log.h>+#include <grpc/support/sync.h>+#include <grpc/support/time.h>++#include ""src/core/lib/iomgr/port.h""++// This polling engine is only relevant on linux kernels supporting epoll+// epoll_create() or epoll_create1()+#ifdef GRPC_LINUX_EPOLL+#include <errno.h>+#include <limits.h>+#include <string.h>+#include <sys/epoll.h>+#include <sys/socket.h>+#include <unistd.h>++#include <vector>++#include ""absl/synchronization/mutex.h""++#include <grpc/event_engine/event_engine.h>+#include <grpc/support/alloc.h>++#include ""src/core/lib/event_engine/iomgr_engine/closure.h""+#include ""src/core/lib/event_engine/iomgr_engine/ev_posix.h""+#include ""src/core/lib/event_engine/iomgr_engine/lockfree_event.h""+#include ""src/core/lib/event_engine/iomgr_engine/wakeup_fd_posix.h""+#include ""src/core/lib/gprpp/fork.h""+#include ""src/core/lib/gprpp/time.h""++using ::grpc_event_engine::iomgr_engine::LockfreeEvent;+using ::grpc_event_engine::iomgr_engine::WakeupFd;++#define MAX_EPOLL_EVENTS 100+#define MAX_EPOLL_EVENTS_HANDLED_PER_ITERATION 1++namespace grpc_event_engine {+namespace iomgr_engine {++//  NOTE ON SYNCHRONIZATION:+//  - Fields in this struct are only modified by the designated poller. Hence+//    there is no need for any locks to protect the struct.+typedef struct epoll_set {",move into Epoll1Poller class,X
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/30135,911246401,2022-06-30T16:47:19Z,src/core/lib/event_engine/iomgr_engine/ev_epoll1_linux.cc,"@@ -0,0 +1,673 @@+// Copyright 2022 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++#include <grpc/support/port_platform.h>++#include ""src/core/lib/event_engine/iomgr_engine/ev_epoll1_linux.h""++#include <stdint.h>++#include <algorithm>+#include <memory>++#include ""absl/memory/memory.h""+#include ""absl/status/statusor.h""+#include ""absl/strings/str_cat.h""++#include <grpc/impl/codegen/gpr_types.h>+#include <grpc/support/log.h>+#include <grpc/support/sync.h>+#include <grpc/support/time.h>++#include ""src/core/lib/iomgr/port.h""++// This polling engine is only relevant on linux kernels supporting epoll+// epoll_create() or epoll_create1()+#ifdef GRPC_LINUX_EPOLL+#include <errno.h>+#include <limits.h>+#include <string.h>+#include <sys/epoll.h>+#include <sys/socket.h>+#include <unistd.h>++#include <vector>++#include ""absl/synchronization/mutex.h""++#include <grpc/event_engine/event_engine.h>+#include <grpc/support/alloc.h>++#include ""src/core/lib/event_engine/iomgr_engine/closure.h""+#include ""src/core/lib/event_engine/iomgr_engine/ev_posix.h""+#include ""src/core/lib/event_engine/iomgr_engine/lockfree_event.h""+#include ""src/core/lib/event_engine/iomgr_engine/wakeup_fd_posix.h""+#include ""src/core/lib/gprpp/fork.h""+#include ""src/core/lib/gprpp/time.h""++using ::grpc_event_engine::iomgr_engine::LockfreeEvent;+using ::grpc_event_engine::iomgr_engine::WakeupFd;++#define MAX_EPOLL_EVENTS 100+#define MAX_EPOLL_EVENTS_HANDLED_PER_ITERATION 1++namespace grpc_event_engine {+namespace iomgr_engine {++//  NOTE ON SYNCHRONIZATION:+//  - Fields in this struct are only modified by the designated poller. Hence+//    there is no need for any locks to protect the struct.+typedef struct epoll_set {+  int epfd;++  // The epoll_events after the last call to epoll_wait()+  struct epoll_event events[MAX_EPOLL_EVENTS];++  // The number of epoll_events after the last call to epoll_wait()+  int num_events;++  // Index of the first event in epoll_events that has to be processed. This+  // field is only valid if num_events > 0+  int cursor;+} epoll_set;++namespace {++bool kEpoll1PollerSupported = false;+gpr_once g_init_epoll1_poller = GPR_ONCE_INIT;++int EpollCreateAndCloexec() {+#ifdef GRPC_LINUX_EPOLL_CREATE1+  int fd = epoll_create1(EPOLL_CLOEXEC);+  if (fd < 0) {+    gpr_log(GPR_ERROR, ""epoll_create1 unavailable"");+  }+#else+  int fd = epoll_create(MAX_EPOLL_EVENTS);+  if (fd < 0) {+    gpr_log(GPR_ERROR, ""epoll_create unavailable"");+  } else if (fcntl(fd, F_SETFD, FD_CLOEXEC) != 0) {+    gpr_log(GPR_ERROR, ""fcntl following epoll_create failed"");+    return -1;+  }+#endif+  return fd;+}++class Epoll1EventHandle;++// Only used when GRPC_ENABLE_FORK_SUPPORT=1",This stuff should be moved inside the class or eliminated,X
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/30128,911273642,2022-06-30T17:15:44Z,src/core/lib/channel/channel_args.h,"@@ -86,6 +88,32 @@ struct ChannelArgTypeTraits<   }; }; +// Specialization for shared_ptr",I'd still rather get us to a place that we don't need to write `GetObjectRef<std::shared_ptr<T>>`...As I see it the big reason we can't is that we can't go from `GetObjectRef<EventEngine>` to the conclusion that we need to wrap in a std::shared_ptr... so maybe we just give ourselves that hint:```template <typename T> struct WrapInSharedPtr : std::false_type {};template <> struct WrapInSharedPtr<EventEngine> : std::true_type {};```and I suspect the rest of this shakes out so that SetObject/GetObject/GetObjectRef do as we'd like them to do.,
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/30128,911367328,2022-06-30T19:11:10Z,src/core/lib/channel/channel_args.h,"@@ -86,6 +88,32 @@ struct ChannelArgTypeTraits<   }; }; +// Specialization for shared_ptr","This PR adds general shared_ptr support to ChannelArgs, not just for EventEngine. I'd like to land it generally if possible. We could special-case EventEngine here if we wanted to add the same special cases for any other type we want to add as a shared_ptr.I think the bigger blocker was `GetObject<T>` where we expect to return a raw pointer `p` in most cases, but `p->get()` when a shared_ptr is stored in channel_args. I can take another look.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/30078,911400864,2022-06-30T19:59:27Z,src/core/lib/iomgr/resolve_address.h,"@@ -60,17 +61,38 @@ class DNSResolver {   // address this.   //   // \a interested_parties may be deleted after a request is cancelled.-  virtual TaskHandle ResolveName(-      absl::string_view name, absl::string_view default_port,-      grpc_pollset_set* interested_parties,+  virtual TaskHandle LookupHostname(       std::function<void(absl::StatusOr<std::vector<grpc_resolved_address>>)>-          on_done) = 0;+          on_resolved,+      absl::string_view name, absl::string_view default_port, Duration timeout,+      grpc_pollset_set* interested_parties, absl::string_view name_server) = 0;    // Resolve name in a blocking fashion. Use \a default_port if a port isn't   // designated in \a name, otherwise use the port in \a name.   virtual absl::StatusOr<std::vector<grpc_resolved_address>>-  ResolveNameBlocking(absl::string_view name,-                      absl::string_view default_port) = 0;+  LookupHostnameBlocking(absl::string_view name,+                         absl::string_view default_port) = 0;++  // Asynchronously resolve an SRV Record per gRFC A5: Load Balancing and DNS.+  // On completion, \a on_done is invoked with the result.+  //+  // The same caveats in \a LookupHostname apply here as well.+  //+  // Reference: https://github.com/grpc/proposal/blob/master/A5-grpclb-in-dns.md+  virtual TaskHandle LookupSRV(+      std::function<void(absl::StatusOr<std::vector<grpc_resolved_address>>)>","Okay.  It seems a little weird to introduce a semantic to the iomgr API here and then change it in another PR, but as long as that change happens quickly enough after this one, we can live with it.For now, please add a TODO so that it's clear that this will be changing.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/30078,911408983,2022-06-30T20:11:40Z,src/core/ext/filters/client_channel/resolver/dns/c_ares/dns_resolver_ares.cc,"@@ -276,15 +317,51 @@ std::string ChooseServiceConfig(char* service_config_choice_json,   return service_config->Dump(); } -void AresClientChannelDNSResolver::AresRequestWrapper::OnResolved(+void AresClientChannelDNSResolver::AresRequestWrapper::OnHostnameResolved(+    void* arg, grpc_error_handle error) {+  auto* self = static_cast<AresRequestWrapper*>(arg);+  {+    MutexLock lock(&self->on_resolved_mu_);+    self->hostname_request_.reset();+    self->OnResolvedLocked(error);+  }+  self->Unref(DEBUG_LOCATION, ""OnHostnameResolved"");+}++void AresClientChannelDNSResolver::AresRequestWrapper::OnSRVResolved(+    void* arg, grpc_error_handle error) {+  auto* self = static_cast<AresRequestWrapper*>(arg);+  {+    MutexLock lock(&self->on_resolved_mu_);+    self->srv_request_.reset();+    self->OnResolvedLocked(error);+  }+  self->Unref(DEBUG_LOCATION, ""OnSRVResolved"");+}++void AresClientChannelDNSResolver::AresRequestWrapper::OnTXTResolved(     void* arg, grpc_error_handle error) {   auto* self = static_cast<AresRequestWrapper*>(arg);-  self->OnResolved(error);+  {+    MutexLock lock(&self->on_resolved_mu_);+    self->txt_request_.reset();+    self->OnResolvedLocked(error);+  }+  self->Unref(DEBUG_LOCATION, ""OnTXTResolved""); } -void AresClientChannelDNSResolver::AresRequestWrapper::OnResolved(-    grpc_error_handle error) {-  GRPC_CARES_TRACE_LOG(""resolver:%p OnResolved()"", this);+void AresClientChannelDNSResolver::AresRequestWrapper::OnResolvedLocked(+    grpc_error_handle error) ABSL_EXCLUSIVE_LOCKS_REQUIRED(on_resolved_mu_) {+  if (hostname_request_ != nullptr || srv_request_ != nullptr ||+      txt_request_ != nullptr) {+    GRPC_CARES_TRACE_LOG(+        ""resolver:%p OnResolved() waiting for results (hostname: %s, srv: %s, ""+        ""txt: %s)"",+        this, hostname_request_ ? ""waiting"" : ""done"",","Yeah, there's nothing illegal about this, but I think depending on `operator bool` is an anti-pattern, because it makes it harder for the reader to notice that the underlying type is a pointer and not a bool.  In most of our code, we explicitly say `!= nullptr` on pointer types.",
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/30128,911419503,2022-06-30T20:27:45Z,src/core/lib/channel/channel_args.h,"@@ -86,6 +88,32 @@ struct ChannelArgTypeTraits<   }; }; +// Specialization for shared_ptr","Update: thanks for the collaboration! I did both, generalizing for classes that derive from `enable_shared_from_this`, and for now keeping EventEngine specializations in ChannelArgs.We could expose some of these internal details in the public EventEngine API (ChannelArgName and deriving from std::enable_shared_from_this), but I'm fine to keep the ChannelArg specialization as is for now.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/30028,911427804,2022-06-30T20:40:00Z,src/core/lib/iomgr/tcp_generic_options.h,"@@ -27,91 +27,108 @@ #include ""src/core/lib/iomgr/socket_mutator.h"" #include ""src/core/lib/resource_quota/api.h"" -typedef struct grpc_tcp_generic_options {-  absl::flat_hash_map<absl::string_view, int> int_options;-  grpc_core::RefCountedPtr<grpc_core::ResourceQuota> resource_quota = nullptr;-  struct grpc_socket_mutator* socket_mutator = nullptr;-  grpc_tcp_generic_options()-      : resource_quota(nullptr), socket_mutator(nullptr) {}+struct TcpGenericOptions {+  int tcp_read_chunk_size;","Leaving these fields uninitialized seems a little unsafe, because it makes it possible to accidentally use an uninitialized struct and get bogus values.  Instead, I suggest setting them to their default values here (i.e., the values you currently have in constants like `kDefaultReadChunkSize`, `kDefaultMinReadChunksize`, etc).  Then, when we populate this from `EndpointConfig`, we can simply overwrite only those fields for which the channel args are set; anything that is not set can be left alone, so it stays with the default value.",X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/30028,911431788,2022-06-30T20:45:50Z,src/core/lib/iomgr/tcp_generic_options.cc,"@@ -22,33 +22,42 @@  using ::grpc_event_engine::experimental::EndpointConfig; +#define MAX_CHUNK_SIZE (32 * 1024 * 1024)",This does not appear to be used anywhere.  It looks like a duplicate of `kMaxChunkSize`.,X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/30028,911436518,2022-06-30T20:53:03Z,src/core/lib/iomgr/tcp_posix.cc,"@@ -1734,44 +1707,9 @@ static const grpc_endpoint_vtable vtable = {tcp_read,  #define MAX_CHUNK_SIZE (32 * 1024 * 1024)",Looks like this is no longer needed.,X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/30028,911444675,2022-06-30T21:05:32Z,src/core/lib/event_engine/channel_args_endpoint_config.h,"@@ -16,27 +16,35 @@  #include <grpc/support/port_platform.h> +#include <memory>+ #include ""absl/strings/string_view.h""  #include <grpc/event_engine/endpoint_config.h> #include <grpc/impl/codegen/grpc_types.h> +#include ""src/core/lib/channel/channel_args.h""+ namespace grpc_event_engine { namespace experimental { -/// A readonly \a EndpointConfig based on grpc_channel_args. This class does not-/// take ownership of the grpc_endpoint_args*, and instances of this class-/// should not be used after the underlying args are destroyed. class ChannelArgsEndpointConfig : public EndpointConfig {  public:-  explicit ChannelArgsEndpointConfig(const grpc_channel_args* args)+  explicit ChannelArgsEndpointConfig(const grpc_core::ChannelArgs& args)       : args_(args) {}-  Setting Get(absl::string_view key) const override;+  explicit ChannelArgsEndpointConfig(const grpc_channel_args* args)+      : args_(grpc_core::ChannelArgs::FromC(args)) {}+  EndpointConfig::Setting Get(absl::string_view key) const override;   private:-  const grpc_channel_args* args_;+  grpc_core::ChannelArgs args_; }; +std::unique_ptr<EndpointConfig> CreateEndpointConfig(","These factory functions don't seem to add much value, and they force the caller to use dynamic allocation for no real benefit.  Instead, I think callers can just instantiate `ChannelArgsEndpointConfig` directly.  For example, the chttp2 client code can do this:```ChannelArgsEndpointConfig config(final_args);grpc_endpoint* client = grpc_tcp_create_from_fd(    grpc_fd_create(fd, ""client"", true), config, ""fd-client"");```Note that `ChannelArgs` is copyable and movable, so there's no reason `ChannelArgsEndpointConfig` can't be as well.",X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/30028,911451454,2022-06-30T21:16:49Z,src/core/lib/iomgr/tcp_generic_options.h,"@@ -0,0 +1,134 @@+// Copyright 2022 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++#ifndef GRPC_CORE_LIB_IOMGR_TCP_GENERIC_OPTIONS_H+#define GRPC_CORE_LIB_IOMGR_TCP_GENERIC_OPTIONS_H++#include <grpc/support/port_platform.h>++#include ""absl/container/flat_hash_map.h""+#include ""absl/strings/string_view.h""++#include <grpc/event_engine/endpoint_config.h>+#include <grpc/impl/codegen/grpc_types.h>++#include ""src/core/lib/channel/channel_args.h""+#include ""src/core/lib/iomgr/socket_mutator.h""+#include ""src/core/lib/resource_quota/api.h""++struct TcpGenericOptions {+  int tcp_read_chunk_size;+  int tcp_min_read_chunk_size;+  int tcp_max_read_chunk_size;+  int tcp_tx_zerocopy_send_bytes_threshold;+  int tcp_tx_zerocopy_max_simultaneous_sends;+  int tcp_tx_zero_copy_enabled;+  int keep_alive_time_ms;+  int keep_alive_timeout_ms;+  int expand_wildcard_addrs;+  int allow_reuse_port;+  grpc_core::RefCountedPtr<grpc_core::ResourceQuota> resource_quota;+  struct grpc_socket_mutator* socket_mutator;+  TcpGenericOptions() : resource_quota(nullptr), socket_mutator(nullptr) {}+  // Move ctor+  TcpGenericOptions(TcpGenericOptions&& other) noexcept {+    socket_mutator = absl::exchange(other.socket_mutator, nullptr);+    resource_quota = std::move(other.resource_quota);+    ResetAllIntegerOptions(other);+  }+  // Move assignment+  TcpGenericOptions& operator=(TcpGenericOptions&& other) noexcept {+    if (socket_mutator != nullptr) {+      grpc_socket_mutator_unref(socket_mutator);+    }+    socket_mutator = absl::exchange(other.socket_mutator, nullptr);+    resource_quota = std::move(other.resource_quota);+    ResetAllIntegerOptions(other);+    return *this;+  }+  // Copy ctor+  TcpGenericOptions(const TcpGenericOptions& other) {+    if (other.socket_mutator != nullptr) {+      socket_mutator = grpc_socket_mutator_ref(other.socket_mutator);+    } else {+      socket_mutator = nullptr;+    }+    resource_quota = other.resource_quota;+    ResetAllIntegerOptions(other);+  }+  // Copy assignment+  TcpGenericOptions& operator=(const TcpGenericOptions& other) {+    if (&other == this) {+      return *this;+    }+    if (socket_mutator != nullptr) {+      grpc_socket_mutator_unref(socket_mutator);+      socket_mutator = nullptr;+    }+    if (other.socket_mutator != nullptr) {+      socket_mutator = grpc_socket_mutator_ref(other.socket_mutator);+    }+    resource_quota = other.resource_quota;+    ResetAllIntegerOptions(other);+    return *this;+  }+  // Destructor.+  ~TcpGenericOptions() {+    if (socket_mutator != nullptr) {+      grpc_socket_mutator_unref(socket_mutator);+    }+  }++ private:+  void ResetAllIntegerOptions(const TcpGenericOptions& other) {+    tcp_read_chunk_size = other.tcp_read_chunk_size;+    tcp_min_read_chunk_size = other.tcp_min_read_chunk_size;+    tcp_max_read_chunk_size = other.tcp_max_read_chunk_size;+    tcp_tx_zerocopy_send_bytes_threshold =+        other.tcp_tx_zerocopy_send_bytes_threshold;+    tcp_tx_zerocopy_max_simultaneous_sends =+        other.tcp_tx_zerocopy_max_simultaneous_sends;+    tcp_tx_zero_copy_enabled = other.tcp_tx_zero_copy_enabled;+    keep_alive_time_ms = other.keep_alive_time_ms;+    keep_alive_timeout_ms = other.keep_alive_timeout_ms;+    expand_wildcard_addrs = other.expand_wildcard_addrs;+    allow_reuse_port = other.allow_reuse_port;+  }+};++// Initialize the tcp generic options struct members. This method can be used+// to initialize dynamically allocated struct objects.+void grpc_tcp_generic_options_init(TcpGenericOptions* options);","Doesn't look like you addressed my earlier comment about this, but I don't think we need these init and destroy functions.  The options struct is a C++ type, and we should just instantiate and destroy it in the normal C++ ways.",X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/30028,911452385,2022-06-30T21:18:16Z,src/core/lib/iomgr/tcp_generic_options.h,"@@ -0,0 +1,134 @@+// Copyright 2022 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++#ifndef GRPC_CORE_LIB_IOMGR_TCP_GENERIC_OPTIONS_H+#define GRPC_CORE_LIB_IOMGR_TCP_GENERIC_OPTIONS_H++#include <grpc/support/port_platform.h>++#include ""absl/container/flat_hash_map.h""+#include ""absl/strings/string_view.h""++#include <grpc/event_engine/endpoint_config.h>+#include <grpc/impl/codegen/grpc_types.h>++#include ""src/core/lib/channel/channel_args.h""+#include ""src/core/lib/iomgr/socket_mutator.h""+#include ""src/core/lib/resource_quota/api.h""++struct TcpGenericOptions {","Now that we're not using this in the Windows iomgr impl, it looks like this is specific to the POSIX iomgr impl.  Given that, I suggest moving it to socket_utils_posix.h and renaming it to something like `PosixTcpOptions`.",X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/30028,911462172,2022-06-30T21:35:19Z,test/cpp/end2end/connection_delay_injector.h,"@@ -67,26 +68,28 @@ class ConnectionAttemptInjector {    public:     QueuedAttempt(grpc_closure* closure, grpc_endpoint** ep,                   grpc_pollset_set* interested_parties,-                  const grpc_channel_args* channel_args,+                  TcpGenericOptions&& options,                   const grpc_resolved_address* addr,                   grpc_core::Timestamp deadline)         : closure_(closure),           endpoint_(ep),           interested_parties_(interested_parties),-          channel_args_(grpc_channel_args_copy(channel_args)),+          options_(std::move(options)),           deadline_(deadline) {       memcpy(&address_, addr, sizeof(address_));     }      ~QueuedAttempt() {       GPR_ASSERT(closure_ == nullptr);-      grpc_channel_args_destroy(channel_args_);+      grpc_tcp_generic_options_destroy(&options_);     }      // Caller must invoke this from a thread with an ExecCtx.     void Resume() {       GPR_ASSERT(closure_ != nullptr);-      AttemptConnection(closure_, endpoint_, interested_parties_, channel_args_,+      auto config = grpc_event_engine::experimental::CreateEndpointConfig(+          TcpOptionsIntoChannelArgs(options_));","I agree, we shouldn't be using `TcpGenericOptions` in this code.  Instead, I suggest having this code down-cast from `EndpointConfig` to `ChannelArgsEndpointConfig`, which should be made copyable, and we can then store that internally when we delay a connection attempt.Craig, you're right, we're definitely going to need to make some changes to this library as part of the EE migration, since this code currently reaches into iomgr internals to work.  In the long run, I was thinking that we would basically make this a wrapper EE impl that wraps around a real EE impl so that it can intercept the relevant API calls.  You're right that we could also consider making it a handshaker, but I suspect that will be a little harder to implement, and it would be slightly less general-purpose, because there may be use-cases in which we create a TCP connection but don't use handshakers (although to be fair, we are not actually using this library for any such case right now).But yeah, let's definitely talk about how to deal with this during the migration.  The interim phases of the migration may be a little challenging here.",X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/30078,911519691,2022-06-30T23:53:52Z,src/core/ext/filters/client_channel/resolver/dns/c_ares/grpc_ares_wrapper.h,"@@ -78,23 +78,36 @@ struct grpc_ares_request {   grpc_error_handle error ABSL_GUARDED_BY(mu) = GRPC_ERROR_NONE; }; -/* Asynchronously resolve \a name. It will try to resolve grpclb SRV records in-  addition to the normal address records. For normal address records, it uses-  \a default_port if a port isn't designated in \a name, otherwise it uses the-  port in \a name. grpc_ares_init() must be called at least once before this-  function. The returned grpc_ares_request object is owned by the caller and it-  is safe to free after on_done is called back.+/* Asynchronously resolve \a name (A/AAAA records only).+  It uses \a default_port if a port isn't designated in \a name, otherwise it+  uses the port in \a name. grpc_ares_init() must be called at least once before+  this function. The returned grpc_ares_request object is owned by the caller+  and it is safe to free after on_done is called back.    Note on synchronization: \a as on_done might be called from another thread   ~immediately, access to the grpc_ares_request* return value must be   synchronized by the caller. TODO(apolcyn): we should remove this requirement   by changing this API to use two phase initialization - one API to create   the grpc_ares_request* and another to start the async work. */-extern grpc_ares_request* (*grpc_dns_lookup_ares)(+extern grpc_ares_request* (*grpc_dns_lookup_hostname_ares)(     const char* dns_server, const char* name, const char* default_port,     grpc_pollset_set* interested_parties, grpc_closure* on_done,     std::unique_ptr<grpc_core::ServerAddressList>* addresses,+    int query_timeout_ms);++// Asynchronously resolve a SRV record.+// See \a grpc_dns_lookup_hostname_ares for usage details and caveats.+extern grpc_ares_request* (*grpc_dns_lookup_srv_ares)(","If nothing else, I think there will be additional memory usage here from allocating all of the state separately for each request, and given how expensive RAM is right now, that doesn't seem like a win.  Prior to this PR, we were not paying that cost, so this is making things worse, and I don't think we should do that if we have a reasonable alternative -- and I think we do.  I am willing to live with this in the short term, but I want to make sure that we will clean it up before we are finished with the EE migration.As I said to AJ offline, I think that we are going to need to make changes to the event-loop integration anyway as part of moving this code into the EE impl, since that integration will no longer use things like pollset_set.  And since we're going to be changing that code anyway, I think centralizing it into a parent object should be reasonable to do at the same time.As a completely separate matter, I think that if we are making a significant changes to a piece of code anyway, we should convert that code to C++ if it's still in C.  That does not necessarily mean that we need to convert every line of c-ares code, but if we're touching some given part of it anyway, I think it makes sense to convert it.  I would say the same thing about any piece of code in our codebase.Alex, I think we should also try to learn from this for the future.  If we don't get your PR rolled forward -- and neither of you seem to want to take the time to do that, so it seems like it's not going to happen -- then the fact that we didn't follow up on it means that all the time you spent on it was basically completely wasted, because we didn't wind up getting any benefit from it.  I think we should try really hard to avoid that in the future.  If something is worth spending time on, it's worth doing it right and getting it done; if it's not, then we shouldn't spend time on it in the first place.",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/30008,912093027,2022-07-01T16:16:30Z,src/core/lib/channel/channel_args.cc,"@@ -56,6 +56,64 @@ int PointerCompare(void* a_ptr, const grpc_arg_pointer_vtable* a_vtable,  namespace grpc_core { +ChannelArgs::ChannelArgs() = default;","the linker de-dupes any repetitions of this function for sure... the problem is that this function is relatively small and called from many call sites - so the compiler makes the decision repeatedly to inline the constructor, and the inlining is just slightly bigger than the non-inlined version. No big deal in the small, but across our entire codebase it adds up to something customers will feel.",X
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/30181,912323690,2022-07-02T05:38:46Z,test/core/util/BUILD,"@@ -227,3 +227,22 @@ grpc_cc_library(     srcs = [""build.cc""],     hdrs = [""build.h""], )++grpc_cc_library(+    name = ""gtest_main"",+    srcs = [""gtest_main.cc""],+    external_deps = [""gtest""],+    language = ""C++"",+    deps = [+        "":grpc_test_util_base"",","This pulls in all of //:grpc which I think is the wrong default, especially moving forward.I'd propose a gtest_main that is free of that dependency for unit tests, and a gtest_main_for_end2end that does include the extras.",
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/30134,912737845,2022-07-04T08:09:14Z,src/csharp/Grpc.Core.Tests/CallCancellationTest.cs,"@@ -179,6 +179,122 @@ public async Task ServerStreamingCall_CancelClientSideRead()             }         } +        [Test]+        public async Task ServerStreamingCall_DisposeCallBeforeAllRead()+        {+            // Test to reproduce https://github.com/grpc/grpc/issues/8451+            // ""Client channel socket leaks unless read stream drained explicitly""+            // This version of the test disposes the call before the response stream is+            // fully read.++            helper.ServerStreamingHandler = new ServerStreamingServerMethod<string, string>(async (request, responseStream, context) => {+                try+                {+                    // send responses to the client with a short delay between each response+                    foreach (string resp in request.Split(new[] { ' ' }))+                    {+                        await responseStream.WriteAsync(resp);+                        await Task.Delay(50);+                    }+                    context.ResponseTrailers.Add(""xyz"", """");+                }+                catch (RpcException ex)+                {+                    // server may get an exception when the client cancels+                    Assert.AreEqual(StatusCode.Cancelled, ex.Status.StatusCode);","Checking the status code in the server side handler isn't necessary (you can just eat the exception or simply let the handler throw, the grpc glue code will handle that. Also, the status  code it's really a thing on the server side (as the server sends status code to the client, not the other way round).So let's remove the try catch block?",
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/30141,912825331,2022-07-04T09:43:58Z,src/csharp/Grpc.Core/Channel.cs,"@@ -223,6 +223,17 @@ protected override async Task ShutdownAsyncCore()             shutdownTokenSource.Cancel();              var activeCallCount = activeCallCounter.Count;++            // Part of fix for https://github.com/grpc/grpc/issues/28153 memory leak+            if (activeCallCount > 0)+            {+                // There may be a race condition when disposing of a call and then+                // immediately closing the channel. This reduces the chance although+                // not completely eliminating it. It gives callbacks a chance to happen.+                await Task.Delay(200);","this seems very arbitrary. We can't have a random delay in the shutdown procedure like this.Is this `. only about avoiding the warning message to be printed (while the call is disposed properly) or 2. is that actually needed for the call to be disposed at all?If it's 1., I think we can live with the message being printed if the channel is abandoned too early. If it's 2. that's a bigger problems since we can't have the call sometimes ending up disposed properly and sometimes not.",
672669,sergiitk,https://api.github.com/repos/grpc/grpc/pulls/30222,915131153,2022-07-06T18:18:44Z,tools/run_tests/xds_k8s_test_driver/tests/custom_lb_test.py,"@@ -19,19 +19,27 @@ import grpc  from framework import xds_k8s_testcase+from framework.helpers import skips  logger = logging.getLogger(__name__) flags.adopt_module_key_flags(xds_k8s_testcase)  # Type aliases _XdsTestServer = xds_k8s_testcase.XdsTestServer _XdsTestClient = xds_k8s_testcase.XdsTestClient+_Lang = skips.Lang  _EXPECTED_STATUS = grpc.StatusCode.DATA_LOSS   class CustomLbTest(xds_k8s_testcase.RegularXdsKubernetesTestCase): +    @staticmethod+    def is_supported(config: skips.TestConfig) -> bool:+        if config.client_lang in _Lang.JAVA:","Minor: let's add a quick comment explaining why it's only enabled in Java `v1.47.x`.Usually I link https://github.com/grpc/grpc/blob/master/doc/grpc_xds_features.md, but I couldn't find your feature there. Should it be added?",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/30189,915167348,2022-07-06T19:05:24Z,src/core/ext/xds/xds_client.cc,"@@ -188,15 +193,16 @@ class XdsClient::ChannelState::AdsCallState       if (state.resource != nullptr) return;       // Start timer.       ads_calld_ = std::move(ads_calld);-      Ref(DEBUG_LOCATION, ""timer"").release();-      timer_pending_ = true;-      grpc_timer_init(-          &timer_,-          ExecCtx::Get()->Now() + ads_calld_->xds_client()->request_timeout_,-          &timer_callback_);+      timer_handle_ = GetDefaultEventEngine()->RunAfter(","Because `XdsClient` is a global object, we definitely do not want to use the EE impl used by the calling channel.  That wouldn't make sense semantically, since the same `XdsClient` could be used by two different channels that each use a different EE impl.I think using `GetDefaultEventEngine()` is fine for now.  If we need a way to override the default just for the `XdsClient` in the future, we can add a special `SetEventEngineFactoryForXdsClient()` API.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/30189,915176474,2022-07-06T19:17:46Z,src/core/ext/xds/xds_client.cc,"@@ -209,57 +215,48 @@ class XdsClient::ChannelState::AdsCallState       // For details, see https://github.com/grpc/grpc/issues/29583.       // TODO(roth): Find a way to write a test for this case.       timer_start_needed_ = false;-      if (timer_pending_) {-        grpc_timer_cancel(&timer_);-        timer_pending_ = false;+      if (timer_handle_.has_value()) {+        GetDefaultEventEngine()->Cancel(*timer_handle_);","We don't actually need to drain the queue in the case where the timer is cancelled.  The code was doing that prior to this PR just because it was easier to write it that way than to go out of our way to skip it if the timer was cancelled.  (This isn't performance-sensitive code, so the unnecessary work wasn't a big deal.)In the `XdsClient`, the `WorkSerializer` is used only for the purpose of ensuring that we send watcher notifications (a) in order and (b) without causing deadlocks in cases where the watcher calls back into the `XdsClient`.  So we need to drain the queue after releasing the mutex only if we schedule a watcher notification (by calling `NotifyWatchersOnResourceDoesNotExist()`), which happens only when the timer is *not* cancelled.As it happens, once the EE migration gets to a point where we have dedicated polling threads, we will be able to simplify this by completely eliminating the mutex and using the `WorkSerializer` instead.  The reason we can't do that now is that the C-core `grpc_dump_xds_configs()` API, which is used for the CSDS RPC service, accesses the `XdsClient` internals in a synchronous way, and if we switched to a `WorkSerializer`, we'd have to make it async, which would involve dragging in a bunch of `pollset_set` and CQ stuff to ensure that we continue to poll until the result is returned.  But once we have dedicated polling threads, we'll be able change that API to be async without any of that stuff, at which point we can just replace the mutex with the `WorkSerializer` and do all of the watcher notifications synchronously from inside the `XdsClient`.",
933495,dennycd,https://api.github.com/repos/grpc/grpc/pulls/30174,916289037,2022-07-07T21:18:55Z,src/compiler/objective_c_generator.cc,"@@ -38,6 +38,15 @@ using ::std::set; namespace grpc_objective_c_generator { namespace { +inline bool ShouldIncludeMethod(const MethodDescriptor* method) {",NIT: consider moving this inline util to [objective_c_generator_helpers.h](https://github.com/grpc/grpc/blob/master/src/compiler/objective_c_generator_helpers.h),
672669,sergiitk,https://api.github.com/repos/grpc/grpc/pulls/30236,916323902,2022-07-07T22:24:34Z,tools/run_tests/xds_k8s_test_driver/tests/custom_lb_test.py,"@@ -38,8 +38,17 @@ def test_custom_lb_config(self):          # Configures a custom, test LB on the client to instruct the servers         # to always respond with a specific error code.+        #+        # The first policy in the list is a non-existent one to assure that+        # the gRPC client can gracefully move down the list to the valid one+        # once it determines the first one is not available.         with self.subTest('1_create_backend_service'):             self.td.create_backend_service(locality_lb_policies=[{+                'customPolicy': {+                    'name': 'test.ThisLoadBalancerDoesNotExist',+                    'data': f'{{ ""foo"": ""bar"" }}'","```suggestion                    'data': '{ ""foo"": ""bar"" }'```f-string not needed since we don't interpolate vars. I'm surprised style checks didn't catch that - IRRC pylint normally nags about it.",X
672669,sergiitk,https://api.github.com/repos/grpc/grpc/pulls/30236,916326257,2022-07-07T22:30:28Z,tools/run_tests/xds_k8s_test_driver/tests/custom_lb_test.py,"@@ -38,8 +38,17 @@ def test_custom_lb_config(self):          # Configures a custom, test LB on the client to instruct the servers         # to always respond with a specific error code.+        #+        # The first policy in the list is a non-existent one to assure that","```suggestion        # The first policy in the list is a non-existent one to verify that```nit: disambiguate _assure_ - I originally thought it's used in the sense of ""to _guarantee_ (force) a behavior"", not ""to _verify_ a behavior"".",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/30235,917532351,2022-07-11T04:28:18Z,src/core/lib/event_engine/event_engine_factory.h,"@@ -11,13 +11,12 @@ // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",happy to but let's make it a different cl... the internal changes that pair with this right now are pretty substantial,
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/30256,918131806,2022-07-11T16:27:04Z,src/core/lib/gprpp/debug_location.h,"@@ -36,7 +36,7 @@ class DebugLocation {   private:   const char* file_;-  const int line_;+  int line_;",Need to be able to copy DebugLocation around to store it in data structures.,
672669,sergiitk,https://api.github.com/repos/grpc/grpc/pulls/30250,918432010,2022-07-11T23:47:42Z,tools/run_tests/xds_k8s_test_driver/tests/outlier_detection_test.py,"@@ -0,0 +1,95 @@+# Copyright 2022 gRPC authors.+#+# Licensed under the Apache License, Version 2.0 (the ""License"");+# you may not use this file except in compliance with the License.+# You may obtain a copy of the License at+#+#     http://www.apache.org/licenses/LICENSE-2.0+#+# Unless required by applicable law or agreed to in writing, software+# distributed under the License is distributed on an ""AS IS"" BASIS,+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+# See the License for the specific language governing permissions and+# limitations under the License.+import logging+from typing import List++from absl import flags+from absl.testing import absltest++from framework import xds_k8s_testcase+from framework import xds_url_map_testcase+from framework.infrastructure import k8s+from framework.test_app import server_app",These are unused.```suggestion```,X
672669,sergiitk,https://api.github.com/repos/grpc/grpc/pulls/30250,918432473,2022-07-11T23:48:50Z,tools/run_tests/xds_k8s_test_driver/tests/outlier_detection_test.py,"@@ -0,0 +1,95 @@+# Copyright 2022 gRPC authors.+#+# Licensed under the Apache License, Version 2.0 (the ""License"");+# you may not use this file except in compliance with the License.+# You may obtain a copy of the License at+#+#     http://www.apache.org/licenses/LICENSE-2.0+#+# Unless required by applicable law or agreed to in writing, software+# distributed under the License is distributed on an ""AS IS"" BASIS,+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+# See the License for the specific language governing permissions and+# limitations under the License.+import logging+from typing import List++from absl import flags+from absl.testing import absltest++from framework import xds_k8s_testcase+from framework import xds_url_map_testcase+from framework.infrastructure import k8s+from framework.test_app import server_app++logger = logging.getLogger(__name__)+flags.adopt_module_key_flags(xds_k8s_testcase)++# Type aliases+RpcTypeUnaryCall = xds_url_map_testcase.RpcTypeUnaryCall+RpcTypeEmptyCall = xds_url_map_testcase.RpcTypeEmptyCall+_XdsTestServer = xds_k8s_testcase.XdsTestServer+_XdsTestClient = xds_k8s_testcase.XdsTestClient+++class OutlierDetectionTest(xds_k8s_testcase.RegularXdsKubernetesTestCase):++    def test_outlier_detection(self) -> None:+        REPLICA_COUNT = 5",Move this to the module or class level. Method-level variables should be lowercase.,X
672669,sergiitk,https://api.github.com/repos/grpc/grpc/pulls/30250,918433555,2022-07-11T23:51:20Z,tools/run_tests/xds_k8s_test_driver/tests/outlier_detection_test.py,"@@ -0,0 +1,95 @@+# Copyright 2022 gRPC authors.+#+# Licensed under the Apache License, Version 2.0 (the ""License"");+# you may not use this file except in compliance with the License.+# You may obtain a copy of the License at+#+#     http://www.apache.org/licenses/LICENSE-2.0+#+# Unless required by applicable law or agreed to in writing, software+# distributed under the License is distributed on an ""AS IS"" BASIS,+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+# See the License for the specific language governing permissions and+# limitations under the License.+import logging+from typing import List++from absl import flags+from absl.testing import absltest++from framework import xds_k8s_testcase+from framework import xds_url_map_testcase+from framework.infrastructure import k8s+from framework.test_app import server_app++logger = logging.getLogger(__name__)+flags.adopt_module_key_flags(xds_k8s_testcase)++# Type aliases+RpcTypeUnaryCall = xds_url_map_testcase.RpcTypeUnaryCall+RpcTypeEmptyCall = xds_url_map_testcase.RpcTypeEmptyCall+_XdsTestServer = xds_k8s_testcase.XdsTestServer+_XdsTestClient = xds_k8s_testcase.XdsTestClient+++class OutlierDetectionTest(xds_k8s_testcase.RegularXdsKubernetesTestCase):++    def test_outlier_detection(self) -> None:+        REPLICA_COUNT = 5++        with self.subTest('00_create_health_check'):+            self.td.create_health_check()++        with self.subTest('01_create_backend_service'):+            self.td.create_backend_service(+                outlier_detection={+                    'interval': {+                        'seconds': 2,+                        'nanos': 0+                    },+                    'successRateRequestVolume': 20+                })++        with self.subTest('02_create_url_map'):+            self.td.create_url_map(self.server_xds_host, self.server_xds_port)++        with self.subTest('03_create_target_proxy'):+            self.td.create_target_proxy()++        with self.subTest('04_create_forwarding_rule'):+            self.td.create_forwarding_rule(self.server_xds_port)++        test_servers: List[_XdsTestServer]+        with self.subTest('05_start_test_servers'):+            test_servers = self.startTestServers(replica_count=REPLICA_COUNT)++        with self.subTest('06_add_server_backends_to_backend_services'):+            self.setupServerBackends()++        test_client: _XdsTestClient+        with self.subTest('07_start_test_client'):+            test_client = self.startTestClient(test_servers[0], qps=100)++        with self.subTest('08_test_client_xds_config_exists'):+            self.assertXdsConfigExists(test_client)++        with self.subTest('09_test_servers_received_rpcs_from_test_client'):+            self.assertRpcsEventuallyGoToGivenServers(test_client, test_servers)++        rpc_types = [RpcTypeUnaryCall]","nit: if the list is not going to be modified, prefer a tuple```suggestion        rpc_types = (RpcTypeUnaryCall, )``````suggestion        rpc_types = [RpcTypeUnaryCall]```",
5564114,Vignesh2208,https://api.github.com/repos/grpc/grpc/pulls/30268,918436587,2022-07-11T23:59:14Z,src/core/lib/resource_quota/memory_quota.h,"@@ -299,7 +299,7 @@ class GrpcMemoryAllocatorImpl final : public EventEngineMemoryAllocatorImpl {     // from  0 to non-zero, then we have more to do, otherwise, we're actually     // done.     size_t prev_free = free_bytes_.fetch_add(n, std::memory_order_release);-    if (prev_free + n > kMaxQuotaBufferSize) {+    if (donate_back_.Tick()) {","Should we have both conditions here: i.e, if (donate_back_.Tick() || prev_free + n > kMaxQuotaBufferSize) ?",
2793282,veblush,https://api.github.com/repos/grpc/grpc/pulls/30270,919276879,2022-07-12T18:19:34Z,src/cpp/client/client_context.cc,"@@ -77,8 +77,12 @@ ClientContext::ClientContext() }  ClientContext::~ClientContext() {-  if (call_) {-    grpc_call_unref(call_);+  {+    internal::MutexLock lock(&mu_);","Setting `call_` to nullptr in the dtor of ClientContext would be reasonable to address the case where the global hook might want to access it in its callback but using the lock doesn't sound right in this case because we don't support case where a ClientContext instance is being destroyed and one of its methods is being called by different threads, which is a race condition.",
832059,LittleCVR,https://api.github.com/repos/grpc/grpc/pulls/30270,919636172,2022-07-13T04:28:46Z,src/cpp/client/client_context.cc,"@@ -77,8 +77,12 @@ ClientContext::ClientContext() }  ClientContext::~ClientContext() {-  if (call_) {-    grpc_call_unref(call_);+  {+    internal::MutexLock lock(&mu_);","Thanks for replying!@ctiller I do agree we shouldn't use the object once its destructor is called to some extent. But it is gRPC who offers the `GlobalCallbacks` class and its `Destructor()` function here for people to access the object even after its destructor is called (but not yet finished). The `Destructor()` function is given the `ClientContext` object as its argument. What kind of operation does gRPC expect the user to do in the `Destructor()` function if no one should use the object once its destructor is called? (See below paragraph for our use case :)@veblush The test code is trying to adopt an easy way to ""cancel all other calls if a particular `ClientContext` is going to be destroyed"". The test code is not randomly calling `TryCancel()` in some random thread in this case, it keeps track of all `ClientContext` when `DefaultConstructor()` is called, and removes them in `Destructor()`. It carefully uses a mutex to ensure that if a `ClientContext` has been fully destroyed, `TryCancel()` will not be called. If this is not enough, then sounds like the `GlobalCallbacks` is not a good candidate to achieve such goal (cancel other calls when a particular `ClientContext` is going to be destroyed). Is there a suggested way to do that? Of course we can go all the way back to our context manager and add a function like ""CancelAllCallsForTesting()`, but `GlobalCallbacks` looks like a good and simple shortcut that we really want to use :)",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/30135,921532171,2022-07-14T20:10:45Z,BUILD,"@@ -2352,6 +2352,160 @@ grpc_cc_library(     ], ) +grpc_cc_library(+    name = ""iomgr_ee_poller_common_hdrs"",","I'd probably just call this 'iomgr_ee_event_poller' - i think the _hdrs targets are an anti-pattern we should be avoiding - these are targets that export an interface, and that they don't have cc files is a coincidence rather than something that should be part of their name",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/30230,922386227,2022-07-15T17:36:49Z,test/core/event_engine/iomgr_event_engine/event_poller_posix_test.cc,"@@ -479,16 +480,20 @@ int main(int argc, char** argv) {   ::testing::InitGoogleTest(&argc, argv);   auto engine =       absl::make_unique<grpc_event_engine::experimental::IomgrEventEngine>();+  int result = 0;   EXPECT_NE(engine, nullptr);   grpc_event_engine::iomgr_engine::TestScheduler scheduler(engine.get());-  g_event_poller =-      grpc_event_engine::iomgr_engine::GetDefaultPoller(&scheduler);-  if (g_event_poller == nullptr) {-    // Poller is not supported on this system.-    return 0;+  // Try both pollers (epoll1 and poll) one after the other.+  g_event_poller = grpc_event_engine::iomgr_engine::GetEpoll1Poller(&scheduler);","Let's do a test fixture, and parameterize the test based on poller implementation?",
672669,sergiitk,https://api.github.com/repos/grpc/grpc/pulls/30250,922421025,2022-07-15T18:24:25Z,tools/run_tests/xds_k8s_test_driver/tests/outlier_detection_test.py,"@@ -29,11 +29,21 @@ _XdsTestServer = xds_k8s_testcase.XdsTestServer _XdsTestClient = xds_k8s_testcase.XdsTestClient +# Testing consts+_QPS = 100+_REPLICA_COUNT = 5  class OutlierDetectionTest(xds_k8s_testcase.RegularXdsKubernetesTestCase): +    @staticmethod+    def is_supported(config: skips.TestConfig) -> bool:+        if config.client_lang == _Lang.CPP:+            return not config.version_lt('v1.48.x')","`version_lt` is no longer available, please use `version_gte`",
672669,sergiitk,https://api.github.com/repos/grpc/grpc/pulls/30250,922425142,2022-07-15T18:29:09Z,tools/run_tests/xds_k8s_test_driver/tests/outlier_detection_test.py,"@@ -0,0 +1,106 @@+# Copyright 2022 gRPC authors.+#+# Licensed under the Apache License, Version 2.0 (the ""License"");+# you may not use this file except in compliance with the License.+# You may obtain a copy of the License at+#+#     http://www.apache.org/licenses/LICENSE-2.0+#+# Unless required by applicable law or agreed to in writing, software+# distributed under the License is distributed on an ""AS IS"" BASIS,+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+# See the License for the specific language governing permissions and+# limitations under the License.+import logging+from typing import List++from absl import flags+from absl.testing import absltest++from framework import xds_k8s_testcase+from framework import xds_url_map_testcase++logger = logging.getLogger(__name__)+flags.adopt_module_key_flags(xds_k8s_testcase)++# Type aliases+RpcTypeUnaryCall = xds_url_map_testcase.RpcTypeUnaryCall+RpcTypeEmptyCall = xds_url_map_testcase.RpcTypeEmptyCall+_XdsTestServer = xds_k8s_testcase.XdsTestServer+_XdsTestClient = xds_k8s_testcase.XdsTestClient++# Testing consts+_QPS = 100+_REPLICA_COUNT = 5+++class OutlierDetectionTest(xds_k8s_testcase.RegularXdsKubernetesTestCase):","Would be amazing to add a brief comment here and link https://github.com/grpc/grpc/blob/master/doc/xds-test-descriptions.md#outlier_detection.I know we don't do this in other places, but it's a good time to start being more descriptive in our tests.The body of the comment could be the same as in the test spec:> This test verifies that the client applies the outlier detection configuration and temporarily drops traffic to a server that fails requests.",
9566254,apolcyn,https://api.github.com/repos/grpc/grpc/pulls/30266,923560255,2022-07-18T16:17:01Z,src/core/ext/xds/xds_client.cc,"@@ -1414,6 +1414,13 @@ void XdsClient::Orphan() {   // Clear cache and any remaining watchers that may not have been cancelled.   authority_state_map_.clear();   invalid_watchers_.clear();+  // We may still be sending lingering queued load report data, so don't+  // just clear the load reporting map, but we do want to clear the refs+  // we're holding to the ChannelState objects, to make sure that+  // everything shuts down properly.+  for (auto& p : xds_load_report_server_map_) {+    p.second.channel_state.reset(DEBUG_LOCATION, ""XdsClient::Orphan()"");","just checking, is it possible for an LRS call's `OnReportDoneLocked` to be called after this `Orphan` completes, and so possibly crash in [here](https://github.com/grpc/grpc/blob/0aba64fa077ee9e9c2762b883e1c8935c2d0b0a4/src/core/ext/xds/xds_client.cc#L1198) ?",
5564114,Vignesh2208,https://api.github.com/repos/grpc/grpc/pulls/30230,923792835,2022-07-18T19:44:00Z,src/core/lib/event_engine/iomgr_engine/event_poller_posix_default.cc,"@@ -15,13 +15,18 @@ #include <grpc/support/port_platform.h>  #include ""src/core/lib/event_engine/iomgr_engine/ev_epoll1_linux.h""+#include ""src/core/lib/event_engine/iomgr_engine/ev_poll_posix.h"" #include ""src/core/lib/event_engine/iomgr_engine/event_poller.h""  namespace grpc_event_engine { namespace iomgr_engine {  EventPoller* GetDefaultPoller(Scheduler* scheduler) {   EventPoller* poller = GetEpoll1Poller(scheduler);",Done. I added a grpc_poll_strategy config flag which can a comma separated list of pollers to try in order of preference. Some more code is copied from iomgr/ev_posix.cc to aid in string parsing.,
5564114,Vignesh2208,https://api.github.com/repos/grpc/grpc/pulls/30230,923793660,2022-07-18T19:45:10Z,src/core/lib/event_engine/iomgr_engine/ev_poll_posix.cc,"@@ -0,0 +1,835 @@+// Copyright 2022 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++#include <grpc/support/port_platform.h>++#include ""src/core/lib/event_engine/iomgr_engine/ev_poll_posix.h""++#include <stdint.h>++#include <algorithm>+#include <atomic>+#include <memory>++#include ""absl/status/statusor.h""+#include ""absl/strings/str_cat.h""++#include <grpc/impl/codegen/gpr_types.h>+#include <grpc/support/log.h>+#include <grpc/support/sync.h>+#include <grpc/support/time.h>++#include ""src/core/lib/event_engine/iomgr_engine/event_poller.h""+#include ""src/core/lib/event_engine/iomgr_engine/iomgr_engine_closure.h""+#include ""src/core/lib/iomgr/port.h""++#ifdef GRPC_POSIX_SOCKET_EV_POLL++#include <assert.h>+#include <errno.h>+#include <limits.h>+#include <poll.h>+#include <string.h>+#include <sys/socket.h>+#include <unistd.h>++#include <vector>++#include ""absl/synchronization/mutex.h""++#include <grpc/event_engine/event_engine.h>+#include <grpc/support/alloc.h>++#include ""src/core/lib/event_engine/iomgr_engine/event_poller.h""+#include ""src/core/lib/event_engine/iomgr_engine/iomgr_engine_closure.h""+#include ""src/core/lib/event_engine/iomgr_engine/wakeup_fd_posix.h""+#include ""src/core/lib/event_engine/iomgr_engine/wakeup_fd_posix_default.h""+#include ""src/core/lib/gprpp/fork.h""+#include ""src/core/lib/gprpp/time.h""++using ::grpc_event_engine::iomgr_engine::WakeupFd;++#define CLOSURE_NOT_READY ((IomgrEngineClosure*)0)+#define CLOSURE_READY ((IomgrEngineClosure*)1)+#define POLLOUT_CHECK (POLLOUT | POLLHUP | POLLERR)+#define POLLIN_CHECK (POLLIN | POLLHUP | POLLERR)++namespace grpc_event_engine {+namespace iomgr_engine {++class PollEventHandle : public EventHandle {+ public:+  PollEventHandle(int fd, PollPoller* poller)+      : fd_(fd),+        pending_actions_(0),+        fork_fd_list_(),+        poller_handles_list_(),+        poller_(poller),+        scheduler_(poller->GetScheduler()),+        is_orphaned_(false),+        is_shutdown_(false),+        closed_(false),+        released_(false),+        pollhup_(false),+        watch_mask_(-1),+        shutdown_error_(absl::OkStatus()),+        on_done_(nullptr),+        read_closure_(CLOSURE_NOT_READY),+        write_closure_(CLOSURE_NOT_READY) {+    poller_->Ref();+    absl::MutexLock lock(&poller_->mu_);+    poller_->PollerHandlesListAddHandle(this);+  }+  PollPoller* Poller() { return poller_; }+  void SetPendingActions(bool pending_read, bool pending_write) {+    pending_actions_ |= pending_read;+    if (pending_write) {+      pending_actions_ |= (1 << 2);+    }+  }+  void ForceRemoveHandleFromPoller() {+    absl::MutexLock lock(&poller_->mu_);+    poller_->PollerHandlesListRemoveHandle(this);+  }+  int WrappedFd() override { return fd_; }+  bool IsOrphaned() const ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu_) {+    return is_orphaned_;+  }+  void CloseFd() ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu_) {+    if (!released_ && !closed_) {+      closed_ = true;+      close(fd_);+    }+  }+  bool IsPollhup() const ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu_) { return pollhup_; }+  void SetPollhup(bool pollhup) ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu_) {+    pollhup_ = pollhup;+  }+  bool IsWatched(int& watch_mask) const ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu_) {+    watch_mask = watch_mask_;+    return watch_mask_ != -1;+  }+  bool IsWatched() const ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu_) {+    return watch_mask_ != -1;+  }+  void SetWatched(int watch_mask) ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu_) {+    watch_mask_ = watch_mask;+  }+  void OrphanHandle(IomgrEngineClosure* on_done, int* release_fd,+                    absl::string_view reason) override;+  void ShutdownHandle(absl::Status why) override;+  void NotifyOnRead(IomgrEngineClosure* on_read) override;+  void NotifyOnWrite(IomgrEngineClosure* on_write) override;+  void NotifyOnError(IomgrEngineClosure* on_error) override;+  void SetReadable() override;+  void SetWritable() override;+  void SetHasError() override;+  bool IsHandleShutdown() override {+    absl::MutexLock lock(&mu_);+    return is_shutdown_;+  };+  void ExecutePendingActions() override {+    int kick = 0;+    {+      absl::MutexLock lock(&mu_);+      if ((pending_actions_ & 1UL)) {+        if (SetReadyLocked(&read_closure_)) {+          kick = 1;+        }+      }+      if (((pending_actions_ >> 2) & 1UL)) {+        if (SetReadyLocked(&write_closure_)) {+          kick = 1;+        }+      }+      pending_actions_ = 0;+    }+    if (kick) {+      // SetReadyLocked immediately scheduled some closure. It would have set+      // the closure state to NOT_READY. We need to wakeup the Work(...) thread+      // to start polling on this fd. If this call is not made, it is possible+      // that the poller will reach a state where all the fds under the+      // poller's control are not polled for POLLIN/POLLOUT events thus leading+      // to an indefinitely blocked Work(..) method.+      poller_->KickExternal(false);+    }+    Unref();+  }+  void Ref() { ref_count_.fetch_add(1, std::memory_order_relaxed); }+  void Unref() {+    if (ref_count_.fetch_sub(1, std::memory_order_acq_rel) == 1) {+      if (on_done_ != nullptr) {+        scheduler_->Run(on_done_);+      }+      poller_->Unref();+      delete this;+    }+  }+  ~PollEventHandle() override = default;+  absl::Mutex* mu() ABSL_LOCK_RETURNED(mu_) { return &mu_; }+  PollPoller::HandlesList& ForkFdListPos() { return fork_fd_list_; }+  PollPoller::HandlesList& PollerHandlesListPos() {+    return poller_handles_list_;+  }+  uint32_t BeginPollLocked(uint32_t read_mask, uint32_t write_mask)+      ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu_);+  bool EndPollLocked(int got_read, int got_write)+      ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu_);++ private:+  int SetReadyLocked(IomgrEngineClosure** st);+  int NotifyOnLocked(IomgrEngineClosure** st, IomgrEngineClosure* closure);+  // See Epoll1Poller::ShutdownHandle for explanation on why a mutex is+  // required.+  absl::Mutex mu_;+  std::atomic<int> ref_count_{1};+  int fd_;+  int pending_actions_;+  PollPoller::HandlesList fork_fd_list_;+  PollPoller::HandlesList poller_handles_list_;+  PollPoller* poller_;+  Scheduler* scheduler_;+  bool is_orphaned_;+  bool is_shutdown_;+  bool closed_;+  bool released_;+  bool pollhup_;+  int watch_mask_;+  absl::Status shutdown_error_;+  IomgrEngineClosure* on_done_;+  IomgrEngineClosure* read_closure_;+  IomgrEngineClosure* write_closure_;+};++namespace {++bool kPollPollerSupported = false;",I'm not sure what else you had in mind here ? Should I make this static to the PollPoller class ? These variables need to be used by every PollPoller instance,
5564114,Vignesh2208,https://api.github.com/repos/grpc/grpc/pulls/30307,923916456,2022-07-18T22:41:03Z,src/core/lib/json/json_reader.cc,"@@ -137,29 +138,44 @@ class JsonReader { };  bool JsonReader::StringAddChar(uint32_t c) {-  switch (utf8_bytes_remaining_) {-    case 0:-      if ((c & 0x80) == 0) {-        utf8_bytes_remaining_ = 0;-      } else if ((c & 0xe0) == 0xc0) {-        utf8_bytes_remaining_ = 1;-      } else if ((c & 0xf0) == 0xe0) {-        utf8_bytes_remaining_ = 2;-      } else if ((c & 0xf8) == 0xf0) {-        utf8_bytes_remaining_ = 3;-      } else {-        return false;-      }-      break;-    case 1:-    case 2:-    case 3:-      if ((c & 0xc0) != 0x80) return false;-      --utf8_bytes_remaining_;-      break;-    default:-      abort();+  if (utf8_bytes_remaining_ == 0) {+    if ((c & 0x80) == 0) {+      utf8_bytes_remaining_ = 0;+    } else if ((c & 0xe0) == 0xc0 && c > 0xc1) {+      utf8_bytes_remaining_ = 1;+    } else if ((c & 0xf0) == 0xe0) {+      utf8_bytes_remaining_ = 2;+    } else if ((c & 0xf8) == 0xf0) {+      utf8_bytes_remaining_ = 3;+    } else {+      return false;+    }+    utf8_first_byte_ = c;+  } else if (utf8_bytes_remaining_ == 1) {+    if ((c & 0xc0) != 0x80) {+      return false;+    }+    --utf8_bytes_remaining_;+  } else if (utf8_bytes_remaining_ == 2) {+    /// Reference: https://www.unicode.org/versions/Unicode14.0.0/ch03.pdf",Please add the list of UTF-8 characters this is supposed to filter out directly inside the comment itself and then provide the link to the document.,
5564114,Vignesh2208,https://api.github.com/repos/grpc/grpc/pulls/30307,923917953,2022-07-18T22:44:33Z,test/core/json/json_test.cc,"@@ -109,6 +116,14 @@ TEST(Json, Utf8) {   RunSuccessTest(""{\""\\ud834\\udd1e\"":0}"",                  Json::Object{{""\xf0\x9d\x84\x9e"", 0}},                  ""{\""\\ud834\\udd1e\"":0}"");++  EXPECT_THAT(""\""\xa0\"""", ContainsInvalidUtf8());",Please add statements to test for parsing success for each or atleast some of the boundary cases listed in the table,
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/30230,924596813,2022-07-19T14:47:22Z,BUILD,"@@ -2508,6 +2508,34 @@ grpc_cc_library(     ], ) +grpc_cc_library(+    name = ""iomgr_ee_poller_posix_poll"",+    srcs = [+        ""src/core/lib/event_engine/iomgr_engine/ev_poll_posix.cc"",+    ],+    hdrs = [+        ""src/core/lib/event_engine/iomgr_engine/ev_poll_posix.h"",+    ],+    external_deps = [+        ""absl/status:statusor"",+        ""absl/strings"",+        ""absl/synchronization"",+    ],+    tags = [""grpc-autodeps""],",no longer needed!,X
16571023,ananda1066,https://api.github.com/repos/grpc/grpc/pulls/30305,924965262,2022-07-19T21:17:58Z,test/core/memory_usage/callback_client.cc,"@@ -0,0 +1,108 @@+/*+ *+ * Copyright 2022 gRPC authors.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ *     http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ *+ */++#include <stdio.h>+#include <string.h>++#include <gtest/gtest.h>++#include ""absl/algorithm/container.h""+#include ""absl/flags/flag.h""+#include ""absl/flags/parse.h""+#include ""util/logging.h""++#include <grpc/byte_buffer.h>+#include <grpc/byte_buffer_reader.h>+#include <grpc/grpc.h>+#include <grpc/grpc_security.h>+#include <grpc/support/alloc.h>+#include <grpc/support/log.h>+#include <grpc/support/time.h>+#include <grpcpp/grpcpp.h>+#include <grpcpp/support/client_callback.h>++#include ""src/core/lib/address_utils/sockaddr_utils.h""+#include ""src/core/lib/channel/channel_args.h""+#include ""src/core/lib/gpr/env.h""+#include ""src/core/lib/gpr/string.h""+#include ""src/core/lib/gpr/useful.h""+#include ""src/core/lib/gprpp/host_port.h""+#include ""src/core/lib/iomgr/exec_ctx.h""+#include ""src/core/lib/iomgr/sockaddr.h""+#include ""src/core/lib/iomgr/socket_utils.h""+#include ""src/core/lib/security/credentials/credentials.h""+#include ""src/cpp/client/secure_credentials.h""+#include ""src/proto/grpc/testing/benchmark_service.grpc.pb.h""+#include ""test/core/memory_usage/memstats.h""+#include ""test/core/util/port.h""+#include ""test/core/util/subprocess.h""+#include ""test/core/util/test_config.h""++ABSL_FLAG(std::string, target, ""localhost:443"", ""Target host:port"");+ABSL_FLAG(bool, secure, false, ""Use SSL Credentials"");++void UnaryCall(std::shared_ptr<grpc::ChannelCredentials> creds) {+  // Create a channel to the server and a stub+  std::shared_ptr<grpc::Channel> channel =+      CreateChannel(absl::GetFlag(FLAGS_target), creds);+  std::unique_ptr<grpc::testing::BenchmarkService::Stub> stub_ =","Per style guide, only class variables should end in ""_"", please rename to stub. We also prefer keeping whitespace to a minimum; try to only add new lines when there are distinctive blocks of code (see https://google.github.io/styleguide/cppguide.html#Vertical_Whitespace for more info). Please remove the unnecessary whitespaces in both client and server files.",
16230296,nancylucy01,https://api.github.com/repos/grpc/grpc/pulls/30305,925035806,2022-07-19T23:26:00Z,test/core/memory_usage/callback_client.cc,"@@ -0,0 +1,108 @@+/*+ *+ * Copyright 2022 gRPC authors.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ *     http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ *+ */++#include <stdio.h>+#include <string.h>++#include <gtest/gtest.h>++#include ""absl/algorithm/container.h""+#include ""absl/flags/flag.h""+#include ""absl/flags/parse.h""+#include ""util/logging.h""++#include <grpc/byte_buffer.h>+#include <grpc/byte_buffer_reader.h>+#include <grpc/grpc.h>+#include <grpc/grpc_security.h>+#include <grpc/support/alloc.h>+#include <grpc/support/log.h>+#include <grpc/support/time.h>+#include <grpcpp/grpcpp.h>+#include <grpcpp/support/client_callback.h>++#include ""src/core/lib/address_utils/sockaddr_utils.h""+#include ""src/core/lib/channel/channel_args.h""+#include ""src/core/lib/gpr/env.h""+#include ""src/core/lib/gpr/string.h""+#include ""src/core/lib/gpr/useful.h""+#include ""src/core/lib/gprpp/host_port.h""+#include ""src/core/lib/iomgr/exec_ctx.h""+#include ""src/core/lib/iomgr/sockaddr.h""+#include ""src/core/lib/iomgr/socket_utils.h""+#include ""src/core/lib/security/credentials/credentials.h""+#include ""src/cpp/client/secure_credentials.h""+#include ""src/proto/grpc/testing/benchmark_service.grpc.pb.h""+#include ""test/core/memory_usage/memstats.h""+#include ""test/core/util/port.h""+#include ""test/core/util/subprocess.h""+#include ""test/core/util/test_config.h""++ABSL_FLAG(std::string, target, ""localhost:443"", ""Target host:port"");+ABSL_FLAG(bool, secure, false, ""Use SSL Credentials"");++void UnaryCall(std::shared_ptr<grpc::ChannelCredentials> creds) {+  // Create a channel to the server and a stub+  std::shared_ptr<grpc::Channel> channel =+      CreateChannel(absl::GetFlag(FLAGS_target), creds);+  std::unique_ptr<grpc::testing::BenchmarkService::Stub> stub_ =+      grpc::testing::BenchmarkService::NewStub(channel);++  struct CallParams {+    grpc::ClientContext context;+    grpc::testing::SimpleRequest request;+    grpc::testing::SimpleResponse response;+  };++  CallParams* params = new CallParams();++  auto callback = [](const grpc::Status& status) {",Is this what you meant? I moved it within the parameters of UnaryCall,
16230296,nancylucy01,https://api.github.com/repos/grpc/grpc/pulls/30305,925035921,2022-07-19T23:26:18Z,test/core/memory_usage/callback_server.cc,"@@ -0,0 +1,109 @@+/*+ *+ * Copyright 2022 gRPC authors.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ *     http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ *+ */++#include <stdio.h>+#include <string.h>++#include <thread>++#include <gtest/gtest.h>++#include ""absl/algorithm/container.h""+#include ""absl/flags/flag.h""+#include ""absl/flags/parse.h""+#include ""util/logging.h""++#include <grpc/grpc.h>+#include <grpc/grpc_security.h>+#include <grpc/support/alloc.h>+#include <grpc/support/log.h>+#include <grpc/support/time.h>+#include <grpcpp/grpcpp.h>+#include <grpcpp/support/client_callback.h>++#include ""src/core/lib/address_utils/sockaddr_utils.h""+#include ""src/core/lib/channel/channel_args.h""+#include ""src/core/lib/gpr/env.h""+#include ""src/core/lib/gpr/string.h""+#include ""src/core/lib/gpr/useful.h""+#include ""src/core/lib/gprpp/host_port.h""+#include ""src/core/lib/security/credentials/credentials.h""+#include ""src/cpp/client/secure_credentials.h""+#include ""src/proto/grpc/testing/benchmark_service.grpc.pb.h""+#include ""test/core/memory_usage/memstats.h""+#include ""test/core/util/port.h""+#include ""test/core/util/subprocess.h""+#include ""test/core/util/test_config.h""++class ServerCallbackImpl final+    : public grpc::testing::BenchmarkService::CallbackService {+  grpc::ServerUnaryReactor* UnaryCall(+      grpc::CallbackServerContext* context,+      const grpc::testing::SimpleRequest* request,+      grpc::testing::SimpleResponse* response) override {+    gpr_log(GPR_INFO, ""RPC CALL RECEIVED"");++    auto* reactor = context->DefaultReactor();+    reactor->Finish(grpc::Status::OK);+    return reactor;+  }+};++static void sigint_handler(int /*x*/) { _exit(0); }++ABSL_FLAG(std::string, bind, """", ""Bind host:port"");+ABSL_FLAG(bool, secure, false, ""Use SSL Credentials"");++int main(int argc, char** argv) {+  absl::ParseCommandLine(argc, argv);+  char* fake_argv[1];++  GPR_ASSERT(argc >= 1);+  fake_argv[0] = argv[0];+  grpc::testing::TestEnvironment env(&argc, argv);++  grpc_init();+  std::string server_address = absl::GetFlag(FLAGS_bind);+  gpr_log(GPR_INFO, ""Server port: %s"", server_address.c_str());++  ServerCallbackImpl callback_server;+  grpc::ServerBuilder builder;++  // Set the authentication mechanism.+  std::shared_ptr<grpc::ServerCredentials> creds =+      grpc::InsecureServerCredentials();+  if (absl::GetFlag(FLAGS_secure)) {+    gpr_log(GPR_INFO, ""Supposed to be secure, is not yet"");+    // TODO (chennancy) Add in secure credentials+  }+  builder.AddListeningPort(server_address, creds);++  // Register ""service"" as the instance through which we'll communicate with+  // clients.+  builder.RegisterService(&callback_server);++  signal(SIGINT, sigint_handler);","Added the per_call comment ""We have some sort of deadlock, so let's not exit gracefully for now.""Also added a TODO for graceful shutdown",
16571023,ananda1066,https://api.github.com/repos/grpc/grpc/pulls/30305,925039416,2022-07-19T23:34:00Z,test/core/memory_usage/memory_usage_test.cc,"@@ -125,6 +128,31 @@ int main(int argc, char** argv) {       return 1;     } +    svr.Interrupt();+    return svr.Join() == 0 ? 0 : 2;+  } else if (absl::GetFlag(FLAGS_benchmark_name) == ""channel"") {+    /* Per-channel benchmark*/+    /* start the server */+    std::vector<std::string> server_flags = {+        absl::StrCat(root, ""/memory_usage_callback_server"",+                     gpr_subprocess_binary_extension()),+        ""--bind"", grpc_core::JoinHostPort(""::"", port)};+    Subprocess svr(server_flags);++    // Wait one second before starting client to avoid race conditions+    gpr_sleep_until(grpc_timeout_seconds_to_deadline(1));","Ok sounds good, we should expand on the comment to explain what the possible race condition is then",
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/30209,925817468,2022-07-20T16:24:41Z,test/core/iomgr/tcp_client_posix_test.cc,"@@ -214,24 +217,25 @@ void test_connect_cancellation_succeeds(void) {    /* create a phony server */   svr_fd = socket(AF_INET, SOCK_STREAM, 0);-  GPR_ASSERT(svr_fd >= 0);-  GPR_ASSERT(-      0 == bind(svr_fd, (struct sockaddr*)addr, (socklen_t)resolved_addr.len));-  GPR_ASSERT(0 == listen(svr_fd, 1));+  ASSERT_GE(svr_fd, 0);+  ASSERT_EQ(0,","nit: most of these tests use the ordering `ASSERT_*(variable, expected_value)`. It would be nice to make that consistent throughout. See https://en.wikipedia.org/wiki/Yoda_conditions",
5564114,Vignesh2208,https://api.github.com/repos/grpc/grpc/pulls/30230,926129727,2022-07-20T23:27:44Z,src/core/lib/event_engine/iomgr_engine/ev_poll_posix.cc,"@@ -0,0 +1,835 @@+// Copyright 2022 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++#include <grpc/support/port_platform.h>++#include ""src/core/lib/event_engine/iomgr_engine/ev_poll_posix.h""++#include <stdint.h>++#include <algorithm>+#include <atomic>+#include <memory>++#include ""absl/status/statusor.h""+#include ""absl/strings/str_cat.h""++#include <grpc/impl/codegen/gpr_types.h>+#include <grpc/support/log.h>+#include <grpc/support/sync.h>+#include <grpc/support/time.h>++#include ""src/core/lib/event_engine/iomgr_engine/event_poller.h""+#include ""src/core/lib/event_engine/iomgr_engine/iomgr_engine_closure.h""+#include ""src/core/lib/iomgr/port.h""++#ifdef GRPC_POSIX_SOCKET_EV_POLL++#include <assert.h>+#include <errno.h>+#include <limits.h>+#include <poll.h>+#include <string.h>+#include <sys/socket.h>+#include <unistd.h>++#include <vector>++#include ""absl/synchronization/mutex.h""++#include <grpc/event_engine/event_engine.h>+#include <grpc/support/alloc.h>++#include ""src/core/lib/event_engine/iomgr_engine/event_poller.h""+#include ""src/core/lib/event_engine/iomgr_engine/iomgr_engine_closure.h""+#include ""src/core/lib/event_engine/iomgr_engine/wakeup_fd_posix.h""+#include ""src/core/lib/event_engine/iomgr_engine/wakeup_fd_posix_default.h""+#include ""src/core/lib/gprpp/fork.h""+#include ""src/core/lib/gprpp/time.h""++using ::grpc_event_engine::iomgr_engine::WakeupFd;++#define CLOSURE_NOT_READY ((IomgrEngineClosure*)0)+#define CLOSURE_READY ((IomgrEngineClosure*)1)+#define POLLOUT_CHECK (POLLOUT | POLLHUP | POLLERR)+#define POLLIN_CHECK (POLLIN | POLLHUP | POLLERR)++namespace grpc_event_engine {+namespace iomgr_engine {++class PollEventHandle : public EventHandle {+ public:+  PollEventHandle(int fd, PollPoller* poller)+      : fd_(fd),+        pending_actions_(0),+        fork_fd_list_(),+        poller_handles_list_(),+        poller_(poller),+        scheduler_(poller->GetScheduler()),+        is_orphaned_(false),+        is_shutdown_(false),+        closed_(false),+        released_(false),+        pollhup_(false),+        watch_mask_(-1),+        shutdown_error_(absl::OkStatus()),+        on_done_(nullptr),+        read_closure_(CLOSURE_NOT_READY),+        write_closure_(CLOSURE_NOT_READY) {+    poller_->Ref();+    absl::MutexLock lock(&poller_->mu_);+    poller_->PollerHandlesListAddHandle(this);+  }+  PollPoller* Poller() { return poller_; }+  void SetPendingActions(bool pending_read, bool pending_write) {+    pending_actions_ |= pending_read;+    if (pending_write) {+      pending_actions_ |= (1 << 2);+    }+  }+  void ForceRemoveHandleFromPoller() {+    absl::MutexLock lock(&poller_->mu_);+    poller_->PollerHandlesListRemoveHandle(this);+  }+  int WrappedFd() override { return fd_; }+  bool IsOrphaned() const ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu_) {+    return is_orphaned_;+  }+  void CloseFd() ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu_) {+    if (!released_ && !closed_) {+      closed_ = true;+      close(fd_);+    }+  }+  bool IsPollhup() const ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu_) { return pollhup_; }+  void SetPollhup(bool pollhup) ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu_) {+    pollhup_ = pollhup;+  }+  bool IsWatched(int& watch_mask) const ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu_) {+    watch_mask = watch_mask_;+    return watch_mask_ != -1;+  }+  bool IsWatched() const ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu_) {+    return watch_mask_ != -1;+  }+  void SetWatched(int watch_mask) ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu_) {+    watch_mask_ = watch_mask;+  }+  void OrphanHandle(IomgrEngineClosure* on_done, int* release_fd,+                    absl::string_view reason) override;+  void ShutdownHandle(absl::Status why) override;+  void NotifyOnRead(IomgrEngineClosure* on_read) override;+  void NotifyOnWrite(IomgrEngineClosure* on_write) override;+  void NotifyOnError(IomgrEngineClosure* on_error) override;+  void SetReadable() override;+  void SetWritable() override;+  void SetHasError() override;+  bool IsHandleShutdown() override {+    absl::MutexLock lock(&mu_);+    return is_shutdown_;+  };+  void ExecutePendingActions() override {+    int kick = 0;+    {+      absl::MutexLock lock(&mu_);+      if ((pending_actions_ & 1UL)) {+        if (SetReadyLocked(&read_closure_)) {+          kick = 1;+        }+      }+      if (((pending_actions_ >> 2) & 1UL)) {+        if (SetReadyLocked(&write_closure_)) {+          kick = 1;+        }+      }+      pending_actions_ = 0;+    }+    if (kick) {+      // SetReadyLocked immediately scheduled some closure. It would have set+      // the closure state to NOT_READY. We need to wakeup the Work(...) thread+      // to start polling on this fd. If this call is not made, it is possible+      // that the poller will reach a state where all the fds under the+      // poller's control are not polled for POLLIN/POLLOUT events thus leading+      // to an indefinitely blocked Work(..) method.+      poller_->KickExternal(false);+    }+    Unref();+  }+  void Ref() { ref_count_.fetch_add(1, std::memory_order_relaxed); }+  void Unref() {+    if (ref_count_.fetch_sub(1, std::memory_order_acq_rel) == 1) {+      if (on_done_ != nullptr) {+        scheduler_->Run(on_done_);+      }+      poller_->Unref();+      delete this;+    }+  }+  ~PollEventHandle() override = default;+  absl::Mutex* mu() ABSL_LOCK_RETURNED(mu_) { return &mu_; }+  PollPoller::HandlesList& ForkFdListPos() { return fork_fd_list_; }+  PollPoller::HandlesList& PollerHandlesListPos() {+    return poller_handles_list_;+  }+  uint32_t BeginPollLocked(uint32_t read_mask, uint32_t write_mask)+      ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu_);+  bool EndPollLocked(int got_read, int got_write)+      ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu_);++ private:+  int SetReadyLocked(IomgrEngineClosure** st);+  int NotifyOnLocked(IomgrEngineClosure** st, IomgrEngineClosure* closure);+  // See Epoll1Poller::ShutdownHandle for explanation on why a mutex is+  // required.+  absl::Mutex mu_;+  std::atomic<int> ref_count_{1};+  int fd_;+  int pending_actions_;+  PollPoller::HandlesList fork_fd_list_;+  PollPoller::HandlesList poller_handles_list_;+  PollPoller* poller_;+  Scheduler* scheduler_;+  bool is_orphaned_;+  bool is_shutdown_;+  bool closed_;+  bool released_;+  bool pollhup_;+  int watch_mask_;+  absl::Status shutdown_error_;+  IomgrEngineClosure* on_done_;+  IomgrEngineClosure* read_closure_;+  IomgrEngineClosure* write_closure_;+};++namespace {++bool kPollPollerSupported = false;",I think I see what you mean here. I changed it not to a static variable local to GetPollPoller. I also noticed similar issue in epoll1 poller so I included the change there too.,
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/30305,926182269,2022-07-21T01:49:21Z,test/core/memory_usage/memory_usage_test.cc,"@@ -25,15 +25,18 @@ #include ""absl/flags/flag.h"" #include ""absl/flags/parse.h"" #include ""absl/strings/str_cat.h""+#include ""util/logging.h""  #include <grpc/support/alloc.h> #include <grpc/support/log.h> #include <grpc/support/string_util.h>+#include <grpc/support/time.h>  #include ""src/core/lib/gpr/string.h"" #include ""src/core/lib/gprpp/host_port.h"" #include ""test/core/util/port.h"" #include ""test/core/util/subprocess.h""+#include ""test/core/util/test_config.h""  ABSL_FLAG(std::string, benchmark_name, ""call"", ""Which benchmark to run"");","the `grpc_cc_test` will invoke the binary with no arguments - we can tweak it to add some arguments, but that will be clumsy.Another way to approach this might be:1. Split out the RunCallBenchmark, RunChannelBenchmark functions into a new library (or libraries)2. have the main.cc file call these3. have a call_test.cc, channel_test.cc program that just calls the appropriate benchmark driver",
672669,sergiitk,https://api.github.com/repos/grpc/grpc/pulls/30250,926933937,2022-07-21T17:26:02Z,tools/run_tests/xds_k8s_test_driver/tests/outlier_detection_test.py,"@@ -0,0 +1,115 @@+# Copyright 2022 gRPC authors.+#+# Licensed under the Apache License, Version 2.0 (the ""License"");+# you may not use this file except in compliance with the License.+# You may obtain a copy of the License at+#+#     http://www.apache.org/licenses/LICENSE-2.0+#+# Unless required by applicable law or agreed to in writing, software+# distributed under the License is distributed on an ""AS IS"" BASIS,+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+# See the License for the specific language governing permissions and+# limitations under the License.+import logging+from typing import List++from absl import flags+from absl.testing import absltest++from framework import xds_k8s_testcase+from framework import xds_url_map_testcase+from framework.helpers import skips++logger = logging.getLogger(__name__)+flags.adopt_module_key_flags(xds_k8s_testcase)++# Type aliases+RpcTypeUnaryCall = xds_url_map_testcase.RpcTypeUnaryCall+RpcTypeEmptyCall = xds_url_map_testcase.RpcTypeEmptyCall+_XdsTestServer = xds_k8s_testcase.XdsTestServer+_XdsTestClient = xds_k8s_testcase.XdsTestClient+_Lang = skips.Lang++# Testing consts+_QPS = 100+_REPLICA_COUNT = 5+++class OutlierDetectionTest(xds_k8s_testcase.RegularXdsKubernetesTestCase):+    '''+    Implementation of https://github.com/grpc/grpc/blob/master/doc/xds-test-descriptions.md#outlier_detection++    This test verifies that the client applies the outlier detection+    configuration and temporarily drops traffic to a server that fails+    requests.+    '''","```suggestion    """"""    Implementation of https://github.com/grpc/grpc/blob/master/doc/xds-test-descriptions.md#outlier_detection    This test verifies that the client applies the outlier detection    configuration and temporarily drops traffic to a server that fails    requests.    """"""```",
11522026,ralphchung,https://api.github.com/repos/grpc/grpc/pulls/30379,927078924,2022-07-21T20:32:45Z,test/core/transport/chttp2/hpack_encoder_test.cc,"@@ -219,6 +221,152 @@ TEST(HpackEncoderTest, TestBasicHeaders) {   delete g_compressor; } +grpc_slice EncodeHeaderIntoBytes(",This helper function mainly copies from https://github.com/grpc/grpc/blob/0536a75167cd4df5298f788df4b640c9f791c973/test/core/transport/chttp2/hpack_encoder_test.cc#L157-L158I am not sure if I should reuse it or do what I have here.,
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/30379,927806536,2022-07-22T16:14:09Z,test/core/transport/chttp2/hpack_encoder_test.cc,"@@ -219,6 +221,152 @@ TEST(HpackEncoderTest, TestBasicHeaders) {   delete g_compressor; } +grpc_slice EncodeHeaderIntoBytes(","If we're introducing a new function that's largely the same, let's do the work to merge the two.",X
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/30389,929134058,2022-07-25T17:33:17Z,src/core/lib/event_engine/windows/event_poller.h,"@@ -0,0 +1,100 @@+// Copyright 2022 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+#ifndef GRPC_CORE_LIB_EVENT_ENGINE_WINDOWS_EVENT_POLLER_H+#define GRPC_CORE_LIB_EVENT_ENGINE_WINDOWS_EVENT_POLLER_H++#include <grpc/support/port_platform.h>++#ifdef GPR_WINDOWS++// ---------------------------------------------------------------------------+// TODO(hork): I forked this from the iomgr_engine due to some slight+// differences in types. Both are being actively worked on, so the idea is to+// develop in parallel and netogiate a reunification once things settle.+//+// This is most valuable if WrappedSocket/EventHandler and EventPoller can be+// treated generally by the same TCP code. If not, unification might not be that+// valuable.+// ---------------------------------------------------------------------------+++#include <vector>++#include ""absl/status/status.h""+#include ""absl/strings/string_view.h""++#include <grpc/event_engine/event_engine.h>++#include ""src/core/lib/gprpp/time.h""++namespace grpc_event_engine {+namespace experimental {++class WrappedSocket {+ public:+  virtual SOCKET Socket() = 0;+  // Shutdown a WrappedSocket. After this operation, NotifyXXX and SetXXX+  // operations cannot be performed.+  virtual void MaybeShutdown(absl::Status why) = 0;+  // Schedule on_read to be invoked when the underlying socket+  // becomes readable.+  virtual void NotifyOnRead(absl::AnyInvocable<void()> on_read) = 0;+  // Schedule on_write to be invoked when the underlying socket+  // becomes writable.+  virtual void NotifyOnWrite(absl::AnyInvocable<void()> on_write) = 0;+  // Force set a readable event on the underlying socket.+  virtual void SetReadable() = 0;+  // Force set a writable event on the underlying socket.+  virtual void SetWritable() = 0;+  // Returns true if the WrappedSocket has been shutdown.+  virtual bool IsShutdown() = 0;+  virtual ~WrappedSocket() = default;+};++// A low-level poller that watches for socket events and dispatches+// notifications.+class EventPoller {","Likely the split we want is:class Poller { public:  Shutdown();   Work(Duration);  Kick();};for posix: readable/writable notifications go into a PosixPoller type that we implement from each poller interfacefor windows: IOCP just exports a Watch method, because we don't need the indirection",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/30389,929138354,2022-07-25T17:38:47Z,src/core/lib/event_engine/windows/iocp.cc,"@@ -0,0 +1,146 @@+// Copyright 2022 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+#include <grpc/support/port_platform.h>++#ifdef GPR_WINDOWS+#include <chrono>++#include ""absl/strings/str_format.h""++#include <grpc/support/alloc.h>+#include <grpc/support/log_windows.h>++#include ""src/core/lib/event_engine/trace.h""+#include ""src/core/lib/event_engine/windows/iocp.h""+#include ""src/core/lib/event_engine/windows/socket.h""++namespace grpc_event_engine {+namespace experimental {++IOCP::IOCP(EventEngine* event_engine) noexcept+    : event_engine_(event_engine),+      iocp_handle_(CreateIoCompletionPort(INVALID_HANDLE_VALUE, NULL,+                                          (ULONG_PTR)NULL, 0)) {+  GPR_ASSERT(iocp_handle_);+  WSASocketFlagsInit();+}++// Shutdown must be called prior to deletion+IOCP::~IOCP() {}++WrappedSocket* IOCP::Watch(SOCKET socket) {+  WinWrappedSocket* wrapped_socket =+      new WinWrappedSocket(socket, event_engine_);+  HANDLE ret =+      CreateIoCompletionPort(reinterpret_cast<HANDLE>(socket), iocp_handle_,+                             reinterpret_cast<uintptr_t>(wrapped_socket), 0);+  if (!ret) {+    char* utf8_message = gpr_format_message(WSAGetLastError());+    gpr_log(GPR_ERROR, ""Unable to add socket to iocp: %s"", utf8_message);+    gpr_free(utf8_message);+    __debugbreak();+    abort();+  }+  GPR_ASSERT(ret == iocp_handle_);+  return wrapped_socket;+}++void IOCP::Shutdown() {+  while (outstanding_kicks_.load() > 0) {+    Work(std::chrono::hours(42));+  }+  GPR_ASSERT(CloseHandle(iocp_handle_));+}++absl::Status IOCP::Work(EventEngine::Duration timeout) {+  DWORD bytes = 0;+  ULONG_PTR completion_key;+  LPOVERLAPPED overlapped;+  if (GRPC_TRACE_FLAG_ENABLED(grpc_event_engine_trace)) {+    gpr_log(GPR_DEBUG, ""IOCP::%p doing work"", this);+  }+  BOOL success = GetQueuedCompletionStatus(+      iocp_handle_, &bytes, &completion_key, &overlapped,+      static_cast<DWORD>(+          std::chrono::duration_cast<std::chrono::milliseconds>(timeout)+              .count()));+  if (success == 0 && overlapped == NULL) {+    if (GRPC_TRACE_FLAG_ENABLED(grpc_event_engine_trace)) {+      gpr_log(GPR_DEBUG, ""IOCP::%p deadline exceeded"", this);+    }+    return absl::DeadlineExceededError(","note that deadline exceeded will eventually happen for every timer expiry, so we probably don't want to be allocating here",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/30028,929153283,2022-07-25T17:56:44Z,src/core/lib/iomgr/socket_utils_posix.cc,"@@ -21,15 +21,104 @@ #include ""src/core/lib/iomgr/port.h""  #ifdef GRPC_POSIX_SOCKETUTILS- #include <fcntl.h> #include <sys/socket.h> #include <unistd.h> +#include <grpc/impl/codegen/grpc_types.h> #include <grpc/support/log.h>  #include ""src/core/lib/iomgr/sockaddr.h"" #include ""src/core/lib/iomgr/socket_utils_posix.h""+#endif++#ifdef GRPC_POSIX_SOCKET_TCP++#include ""src/core/lib/event_engine/channel_args_endpoint_config.h""+#include ""src/core/lib/iomgr/socket_utils_posix.h""++using ::grpc_event_engine::experimental::EndpointConfig;++#define MAX_CHUNK_SIZE (32 * 1024 * 1024)++using ::grpc_core::PosixTcpOptions;++namespace {++int Clamp(int default_value, int min_value, int max_value, int actual_value) {","If this continues to exist, name it something different to Clamp (ApplyDefaultValue maybe?) to avoid ambiguity with the `grpc_core::Clamp` function that does something different.",X
11522026,ralphchung,https://api.github.com/repos/grpc/grpc/pulls/30404,929159755,2022-07-25T18:04:59Z,src/core/lib/gpr/time.cc,"@@ -77,16 +77,19 @@ static gpr_timespec to_seconds_from_sub_second_time(int64_t time_in_units,   } else if (time_in_units == INT64_MIN) {     out = gpr_inf_past(type);   } else {-    if (time_in_units >= 0) {-      out.tv_sec = time_in_units / units_per_sec;-    } else {-      out.tv_sec = (-((units_per_sec - 1) - (time_in_units + units_per_sec)) /-                    units_per_sec) --                   1;-    }+    out.tv_sec = time_in_units / units_per_sec;+    /// Our current usage does not seem to cause precision issues. Division for",My understanding is we should treat every number in the chain of operations `(time_in_units - (out.tv_sec * units_per_sec)) * (GPR_NS_PER_SEC / units_per_sec)` as floating numbers to avoid losing precision from division with remainders. I did not do that since current usage does not seem to cause that.,
702191,arjunroy,https://api.github.com/repos/grpc/grpc/pulls/30320,929427526,2022-07-26T00:40:27Z,src/core/lib/iomgr/tcp_posix.cc,"@@ -381,10 +385,15 @@ class TcpZerocopySendCtx {   //   // Please refer to the STATE TRANSITION DIAGRAM below for more details.   //-  bool UpdateZeroCopyOMemStateAfterSend(bool seen_enobuf) {+  bool UpdateZeroCopyOMemStateAfterSend(bool seen_enobuf, bool& cont) {","See comment below. Can we just elide this parameter by returning ""true"" in any scenario where we would have set this to true?",
5564114,Vignesh2208,https://api.github.com/repos/grpc/grpc/pulls/30413,930285830,2022-07-26T18:23:57Z,BUILD,"@@ -2235,6 +2235,17 @@ grpc_cc_library(     deps = [""gpr_base""], ) +grpc_cc_library(+    name = ""event_engine_poller"",+    hdrs = [+        ""src/core/lib/event_engine/poller.h"",+    ],+    external_deps = [+        ""absl/container:inlined_vector"",",I think absl statusor header should be included in the header file and it should  also be added here as a dependency,
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/30413,930311321,2022-07-26T18:53:09Z,src/core/lib/event_engine/poller.h,"@@ -0,0 +1,53 @@+// Copyright 2022 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+#ifndef GRPC_CORE_LIB_EVENT_ENGINE_POLLER_H+#define GRPC_CORE_LIB_EVENT_ENGINE_POLLER_H++#include <grpc/support/port_platform.h>++#include ""absl/container/inlined_vector.h""+#include ""absl/status/statusor.h""++#include <grpc/event_engine/event_engine.h>++namespace grpc_event_engine {+namespace experimental {++namespace {+constexpr size_t kInitialSize = 5;",move this into `class Poller` - generally we don't want anonymous namespaces in headers anyway,
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/30413,930317535,2022-07-26T19:01:06Z,src/core/lib/event_engine/poller.h,"@@ -0,0 +1,53 @@+// Copyright 2022 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+#ifndef GRPC_CORE_LIB_EVENT_ENGINE_POLLER_H+#define GRPC_CORE_LIB_EVENT_ENGINE_POLLER_H++#include <grpc/support/port_platform.h>++#include ""absl/container/inlined_vector.h""+#include ""absl/status/statusor.h""++#include <grpc/event_engine/event_engine.h>++namespace grpc_event_engine {+namespace experimental {++namespace {+constexpr size_t kInitialSize = 5;+}  // namespace++// A generic cross-platform ""poller"" concept.+// Concrete implementations will likely manage a set of sockets/file+// descriptors/etc, allowing threads to drive polling and event processing via+// Work(...).+class Poller {+ public:+  using Events = absl::InlinedVector<EventEngine::Closure*, kInitialSize>;+  virtual ~Poller() = default;+  // Poll once for events, returning a collection of Closures to be executed.+  //+  // Returns:+  //  * absl::AbortedError if it was Kicked.+  //  * absl::DeadlineExceeded if timeout occurred+  //  * A collection of closures to execute, otherwise+  virtual absl::StatusOr<Events> Work(EventEngine::Duration timeout) = 0;","AbortedError and DeadlineExceeded both require a string which must be copied - and consequently an allocation made to hold that string. Since this is fast path and both kicks and deadline exceeded are on that fast path, let's instead define this as:```using Events = ...;struct DeadlineExceeded {};struct Kicked {};using WorkResult = absl::variant<Events, DeadlineExceeded, Kicked>;virtual WorkResult Work(Duration timeout) = 0;```",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/30028,930332536,2022-07-26T19:21:02Z,src/core/lib/event_engine/channel_args_endpoint_config.h,"@@ -32,17 +32,18 @@ class ChannelArgsEndpointConfig : public EndpointConfig {       : args_(args) {}   explicit ChannelArgsEndpointConfig(const grpc_channel_args* args)","I suggest removing this ctor.  We're trying to get all internal callers to use `grpc_core::ChannelArgs` instead of `grpc_channel_args*`, since it's more efficient.  Any caller that has the latter can convert it to the former before instantiating this object.  And the presence of this ctor makes it easy to misuse: I see a few places where the caller has both forms but you're currently passing in the latter form, which is much less efficient, since it requires a deep copy of every arg.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/30028,930338738,2022-07-26T19:29:20Z,src/core/lib/event_engine/channel_args_endpoint_config.cc,"@@ -47,14 +47,32 @@ EndpointConfig::Setting ChannelArgsEndpointConfig::Get(   GPR_UNREACHABLE_CODE(return absl::monostate()); } -std::unique_ptr<EndpointConfig> CreateEndpointConfig(-    const grpc_core::ChannelArgs& args) {-  return absl::make_unique<ChannelArgsEndpointConfig>(args);+absl::optional<int> ChannelArgsEndpointConfig::GetInt(+    absl::string_view key) const {+  auto value = args_.Get(key);+  if (value != nullptr && absl::holds_alternative<int>(*value)) {+    return absl::get<int>(*value);+  }+  return absl::nullopt;+}++absl::optional<std::string> ChannelArgsEndpointConfig::GetString(+    absl::string_view key) const {+  auto value = args_.Get(key);+  if (value != nullptr && absl::holds_alternative<std::string>(*value)) {+    return absl::get<std::string>(*value);+  }+  return absl::nullopt; } -std::unique_ptr<EndpointConfig> CreateEndpointConfig(-    const grpc_channel_args* args) {-  return absl::make_unique<ChannelArgsEndpointConfig>(args);+absl::optional<void*> ChannelArgsEndpointConfig::GetPointer(","Note that the underlying `ChannelArgs` type does not have this interface.  The closest method I see is `GetVoidPointer()`, which does not differentiate between ""the key is not present"" and ""the key has a value of null"".@ctiller, do we want these two interfaces to be consistent?  Maybe we should either (a) add this method to `ChannelArgs` or (b) change this API to instead provide a method similar to `ChannelArgs::GetVoidPointer()`?",
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/30419,931325047,2022-07-27T17:30:04Z,src/core/lib/event_engine/iomgr_engine/ev_epoll1_linux.cc,"@@ -487,24 +506,26 @@ void Epoll1EventHandle::SetWritable() { write_closure_->SetReady(); }  void Epoll1EventHandle::SetHasError() { error_closure_->SetReady(); } -absl::Status Epoll1Poller::Work(grpc_core::Timestamp deadline,-                                std::vector<EventHandle*>& pending_events) {+Poller::WorkResult Epoll1Poller::Work(EventEngine::Duration timeout) {+  Poller::Events pending_events;+  grpc_core::Timestamp deadline = ToTimestamp(timeout);   if (g_epoll_set_.cursor == g_epoll_set_.num_events) {-    auto status = DoEpollWait(deadline);-    if (!status.ok()) {-      return status;+    if (DoEpollWait(deadline) == 0) {","This converts a timeout to a deadline, then `DoEpollWait` converts the deadline back to a timeout. I suggest changing the signature to `DoEpollWait(EventEngine::Duration timeout)`.Please review and use this: https://github.com/grpc/grpc/pull/30427. I forked it off from my IOCP poller branch, I think it will work nicely here.",
16230296,nancylucy01,https://api.github.com/repos/grpc/grpc/pulls/30390,931342844,2022-07-27T17:51:00Z,test/core/memory_usage/memstats.h,"@@ -18,15 +18,53 @@ #include <stdlib.h> #include <sys/resource.h> +#include <fstream>+#include <iostream>++#include ""absl/strings/str_cat.h""+ // IWYU pragma: no_include <bits/types/struct_rusage.h> +// Get the memory usage of either the calling process or another process using+// the pid+long GetMemUsage(absl::optional<int> pid = absl::nullopt) {+  // Default is getting memory usage for self (calling process)+  std::string path = ""/proc/self/stat"";+  if (pid != absl::nullopt) {+    path = absl::StrCat(""/proc/"", pid.value(), ""/stat"");+  }+  std::ifstream stat_stream(path, std::ios_base::in);++  double resident_set = 0.0;+  // Temporary variables for irrelevant leading entries in stats+  std::string temp_pid, comm, state, ppid, pgrp, session, tty_nr;+  std::string tpgid, flags, minflt, cminflt, majflt, cmajflt;+  std::string utime, stime, cutime, cstime, priority, nice;+  std::string O, itrealvalue, starttime, vsize;++  // Get rss to find memory usage+  long rss;+  stat_stream >> temp_pid >> comm >> state >> ppid >> pgrp >> session >>+      tty_nr >> tpgid >> flags >> minflt >> cminflt >> majflt >> cmajflt >>+      utime >> stime >> cutime >> cstime >> priority >> nice >> O >>+      itrealvalue >> starttime >> vsize >> rss;+  stat_stream.close();++  // pid does not connect to an existing process+  if (state == """") {+    printf(""PID does not exist"");+    return 0;","Is returning 0 enough? The previous code aborted when getrusage wasn't a success, but I figured the memory usage of a non-existing process is technically 0.",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/30390,931348252,2022-07-27T17:57:25Z,test/core/memory_usage/memstats.h,"@@ -18,15 +18,53 @@ #include <stdlib.h> #include <sys/resource.h> +#include <fstream>+#include <iostream>++#include ""absl/strings/str_cat.h""+ // IWYU pragma: no_include <bits/types/struct_rusage.h> +// Get the memory usage of either the calling process or another process using+// the pid+long GetMemUsage(absl::optional<int> pid = absl::nullopt) {","free functions in headers need to be inline or they'll produce ODR violations, however this function is probably larger than I'd like to see inlined... soo let's leave a function prototype here and move the implementation into memstats.cc.",X
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/30419,931355472,2022-07-27T18:06:10Z,src/core/lib/event_engine/iomgr_engine/iomgr_engine_closure.h,"@@ -43,14 +44,39 @@ class IomgrEngineClosure final   ~IomgrEngineClosure() final = default;   void SetStatus(absl::Status status) { status_ = status; }   void Run() override {+    if (is_permanent_) {+      // Take a ref to protect against premature deletion of this closure by+      // cb_;+      Ref();+    }     cb_(absl::exchange(status_, absl::OkStatus()));-    if (!is_permanent_) {+    // For the ref taken at the beginning of this function. If it is a temporary+    // closure, it will get deleted immediately.+    Unref();+  }++  // Ref/Unref methods should only be called on permanent closures.","I don't see why this is necessary yet. We chatted a bit offline, but I'm not convinced this needs a ref-counted closure type (and the overhead, both in client usage complexity and added atomic operations). Once in context of TCP code it might be more obvious, but I don't see it yet. I think the caller will know when its connections are closed, and can safely delete its permanent closures.That said, maybe @ctiller has a better picture.",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/30389,931465170,2022-07-27T18:37:09Z,src/core/lib/event_engine/windows/socket.h,"@@ -0,0 +1,115 @@+// Copyright 2022 gRPC authors.","suggest renaming to win_socket.{h,cc} to match the class name",X
11522026,ralphchung,https://api.github.com/repos/grpc/grpc/pulls/30379,931469455,2022-07-27T18:41:25Z,test/core/transport/chttp2/hpack_encoder_test.cc,"@@ -219,6 +237,117 @@ TEST(HpackEncoderTest, TestBasicHeaders) {   delete g_compressor; } +MATCHER(HasLiteralHeaderFieldNewNameFlagIncrementalIndexing, """") {+  constexpr size_t kHttp2FrameHeaderSize = 9u;+  constexpr uint8_t kLiteralHeaderFieldNewNameFlagIncrementalIndexing = 0x40;","I feel like the long variable name should be somehow self-explanatory, but it should be ok to add comments here.",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/30379,931477776,2022-07-27T18:51:12Z,test/core/transport/chttp2/hpack_encoder_test.cc,"@@ -152,43 +154,59 @@ static void CrashOnAppendError(absl::string_view, const grpc_core::Slice&) {   abort(); } -/* verify that the output generated by encoding the stream matches the-   hexstring passed in */-static void verify(const verify_params params, const char* expected,-                   size_t nheaders, ...) {-  grpc_slice_buffer output;-  grpc_slice merged;-  grpc_slice expect = parse_hexstring(expected);-  size_t i;-  va_list l;+grpc_slice EncodeHeaderIntoBytes(+    const verify_params& params,+    const std::vector<std::pair<std::string, std::string>>& header_fields) {+  std::unique_ptr<grpc_core::HPackCompressor> compressor =+      std::make_unique<grpc_core::HPackCompressor>();+   auto arena = grpc_core::MakeScopedArena(1024, g_memory_allocator);   grpc_metadata_batch b(arena.get()); -  va_start(l, nheaders);-  for (i = 0; i < nheaders; i++) {-    char* key = va_arg(l, char*);-    char* value = va_arg(l, char*);-    b.Append(key, grpc_core::Slice::FromStaticString(value),+  for (const auto& field : header_fields) {+    b.Append(field.first,+             grpc_core::Slice::FromStaticString(field.second.c_str()),              CrashOnAppendError);   }-  va_end(l); -  grpc_slice_buffer_init(&output);--  grpc_transport_one_way_stats stats;-  stats = {};+  grpc_transport_one_way_stats stats = {};   grpc_core::HPackCompressor::EncodeHeaderOptions hopt{       0xdeadbeef,                      /* stream_id */       params.eof,                      /* is_eof */       params.use_true_binary_metadata, /* use_true_binary_metadata */       16384,                           /* max_frame_size */       &stats                           /* stats */   };-  g_compressor->EncodeHeaders(hopt, b, &output);+  grpc_slice_buffer output;+  grpc_slice_buffer_init(&output);++  compressor->EncodeHeaders(hopt, b, &output);   verify_frames(output, params.eof);-  merged = grpc_slice_merge(output.slices, output.count);++  grpc_slice ret = grpc_slice_merge(output.slices, output.count);   grpc_slice_buffer_destroy_internal(&output); +  return ret;+}++/* verify that the output generated by encoding the stream matches the+   hexstring passed in */+static void verify(const verify_params params, const char* expected,","Let's update things so that the `size_t nheaders, ...` becomes `std::vector<std::pair<std::string, std::string>> header_fields` directly: the reason for the variadic arguments is that this used to be c89 code and there was no good way to write a test verifying a list.",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/30379,931488367,2022-07-27T19:02:29Z,test/core/transport/chttp2/hpack_encoder_test.cc,"@@ -152,43 +154,59 @@ static void CrashOnAppendError(absl::string_view, const grpc_core::Slice&) {   abort(); } -/* verify that the output generated by encoding the stream matches the-   hexstring passed in */-static void verify(const verify_params params, const char* expected,-                   size_t nheaders, ...) {-  grpc_slice_buffer output;-  grpc_slice merged;-  grpc_slice expect = parse_hexstring(expected);-  size_t i;-  va_list l;+grpc_slice EncodeHeaderIntoBytes(+    const verify_params& params,+    const std::vector<std::pair<std::string, std::string>>& header_fields) {+  std::unique_ptr<grpc_core::HPackCompressor> compressor =+      std::make_unique<grpc_core::HPackCompressor>();+   auto arena = grpc_core::MakeScopedArena(1024, g_memory_allocator);   grpc_metadata_batch b(arena.get()); -  va_start(l, nheaders);-  for (i = 0; i < nheaders; i++) {-    char* key = va_arg(l, char*);-    char* value = va_arg(l, char*);-    b.Append(key, grpc_core::Slice::FromStaticString(value),+  for (const auto& field : header_fields) {+    b.Append(field.first,+             grpc_core::Slice::FromStaticString(field.second.c_str()),              CrashOnAppendError);   }-  va_end(l); -  grpc_slice_buffer_init(&output);--  grpc_transport_one_way_stats stats;-  stats = {};+  grpc_transport_one_way_stats stats = {};   grpc_core::HPackCompressor::EncodeHeaderOptions hopt{       0xdeadbeef,                      /* stream_id */       params.eof,                      /* is_eof */       params.use_true_binary_metadata, /* use_true_binary_metadata */       16384,                           /* max_frame_size */       &stats                           /* stats */   };-  g_compressor->EncodeHeaders(hopt, b, &output);+  grpc_slice_buffer output;+  grpc_slice_buffer_init(&output);++  compressor->EncodeHeaders(hopt, b, &output);   verify_frames(output, params.eof);-  merged = grpc_slice_merge(output.slices, output.count);++  grpc_slice ret = grpc_slice_merge(output.slices, output.count);   grpc_slice_buffer_destroy_internal(&output); +  return ret;+}++/* verify that the output generated by encoding the stream matches the+   hexstring passed in */+static void verify(const verify_params params, const char* expected,","Also, use_true_binary_metadata seems never to be used here, so maybe we could eliminate verify_params and just pass a `bool eof`",X
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/30389,931551465,2022-07-27T20:26:46Z,src/core/lib/event_engine/iomgr_engine/posix_poller.h,"@@ -0,0 +1,40 @@+// Copyright 2022 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+#ifndef GRPC_CORE_LIB_EVENT_ENGINE_IOMGR_ENGINE_POSIX_POLLER_H+#define GRPC_CORE_LIB_EVENT_ENGINE_IOMGR_ENGINE_POSIX_POLLER_H++#include <grpc/support/port_platform.h>++#include ""src/core/lib/event_engine/poller.h""++namespace grpc_event_engine {+namespace iomgr_engine {++// Interface for posix pollers+class PosixPoller : public experimental::Poller {+ public:+  virtual ~Poller() = default;+  virtual absl::Status Work(grpc_core::Duration timeout) = 0;","I've removed the file, it was speculative and Vignesh is working on the Posix version at the moment.",X
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/30389,931568384,2022-07-27T20:48:57Z,src/core/lib/event_engine/windows/socket.h,"@@ -0,0 +1,115 @@+// Copyright 2022 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+#ifndef GRPC_CORE_LIB_EVENT_ENGINE_WINDOWS_SOCKET_H+#define GRPC_CORE_LIB_EVENT_ENGINE_WINDOWS_SOCKET_H++#include <grpc/support/port_platform.h>++#ifdef GPR_WINDOWS++#include ""absl/base/thread_annotations.h""+#include ""absl/functional/any_invocable.h""++#include <grpc/event_engine/event_engine.h>++#include ""src/core/lib/event_engine/socket_notifier.h""+#include ""src/core/lib/gprpp/sync.h""++namespace grpc_event_engine {+namespace experimental {++class WinSocket final : public SocketNotifier {+ public:+  // State related to a Read or Write socket operation+  class OpState {+   public:+    explicit OpState(WinSocket* win_socket) noexcept;+    // Signal a result has returned+    // If a callback is already primed for notification, it will be executed via+    // the WinSocket's EventEngine. Otherwise, a ""pending iocp"" flag will+    // be set.+    void SetReady();+    // Set error results for a completed op+    void SetError(int wsa_error);+    // Retrieve results of overlapped operation (via Winsock API)+    void GetOverlappedResult();+    // OVERLAPPED, needed for Winsock API calls+    OVERLAPPED* overlapped() { return &overlapped_; }+    // Data from the previous operation, set via GetOverlappedResult+    DWORD bytes_transferred() const { return bytes_transferred_; }+    // Previous error if set.+    int wsa_error() const { return wsa_error_; }+    EventEngine::Closure* closure() { return closure_; }++   private:+    friend class WinSocket;++    OVERLAPPED overlapped_;+    WinSocket* win_socket_ = nullptr;+    EventEngine::Closure* closure_ = nullptr;+    bool has_pending_iocp_ = false;+    DWORD bytes_transferred_;+    int wsa_error_;+  };++  WinSocket(SOCKET socket, EventEngine* event_engine) noexcept;+  ~WinSocket();+  // Calling NotifyOnRead means either of two things:+  //  - The IOCP already completed in the background, and we need to call+  //    the callback now.+  //  - The IOCP hasn't completed yet, and we're queuing it for later.+  void NotifyOnRead(EventEngine::Closure* on_read) override;+  void NotifyOnWrite(EventEngine::Closure* on_write) override;+  void SetReadable() override;+  void SetWritable() override;+  // Schedule a shutdown of the socket operations. Will call the pending+  // operations to abort them. We need to do that this way because of the+  // various callsites of that function, which happens to be in various+  // mutex hold states, and that'd be unsafe to call them directly.+  void MaybeShutdown(absl::Status why) override;+  bool IsShutdown() override;++  // Return the appropriate OpState for a given OVERLAPPED+  // Returns nullptr if the overlapped does not match either read or write ops.+  OpState* GetOpInfoForOverlapped(OVERLAPPED* overlapped);+  // -------------------------------------------------+  // TODO(hork): We need access to these for WSA* ops in TCP code.+  // Maybe we can encapsulate these calls inside of the OpState class. Would need+  // to rename it.+  OpState* read_info() { return &read_info_; }+  OpState* write_info() { return &write_info_; }+  // -------------------------------------------------+  // Accessor method for underlying socket+  SOCKET socket();++ private:+  void NotifyOnReady(OpState& info, EventEngine::Closure* callback);++  SOCKET socket_;+  grpc_core::Mutex mu_;+  bool is_shutdown_ ABSL_GUARDED_BY(mu_) = false;+  EventEngine* event_engine_;","Yes, as we discussed, I was considering a subset of the EventEngine API, something like ```class Executor {  virtual ~Executor() = default;  virtual void Run(Closure* closure) = 0;  virtual void Run(absl::AnyInvocable<void()> closure) = 0;  };```The idea would be, though, that some EventEngine implementation would be plugged into it. i.e., `class MyEventEngine : public EventEngine, Executor { ... };`. So it doesn't make much difference until there are alternative implementations to plug into it.",
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/30419,932683094,2022-07-28T21:26:15Z,src/core/lib/event_engine/iomgr_engine/ev_epoll1_linux.cc,"@@ -77,17 +91,24 @@ class Epoll1EventHandle : public EventHandle {     write_closure_->InitEvent();     error_closure_->InitEvent();     pending_actions_ = 0;+    exec_actions_closure_ = std::make_unique<Epoll1ExecActionsClosure>(this);","I don't think the custom Closure type is necessary, nor the forward declaration / circular dependency. If you use something like a basic lambda-wrapped closure, which we've written a few times now, I think this gets simpler. For example:```class Epoll1EventHandle {... private:  AnyInvocableClosure exec_actions_closure_;};```Then in your constructor`Epoll1EventHandle(...) : exec_actions_closure_([this] { ExecutePendingActions(); Unref(); } )`Or`Epoll1EventHandle(...) : exec_actions_closure_([this] { DoCallback(); } )`I extracted some common, tested closure types I've hacked together a few times (including in my poller) and added them here https://github.com/grpc/grpc/pull/30438. Please review, and we can both use them.",X
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/30419,932784308,2022-07-29T00:59:42Z,src/core/lib/event_engine/iomgr_engine/ev_poll_posix.cc,"@@ -211,13 +227,13 @@ class PollEventHandle : public EventHandle {   bool pollhup_;   int watch_mask_;   absl::Status shutdown_error_;+  experimental::AnyInvocableClosure exec_actions_closure_;","This should be consistent at least. In the namespace `grpc_event_engine::iomgr_engine`, using anything from the `grpc_event_engine::experimental` namespace should either use the full namespace for unambiguity, or use just `experimental`, but I'd argue not a mix of both.",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/30389,934674121,2022-08-01T15:45:41Z,src/core/lib/event_engine/windows/win_socket.cc,"@@ -0,0 +1,201 @@+// Copyright 2022 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+#include <grpc/support/port_platform.h>++#ifdef GPR_WINDOWS+#include <grpc/support/alloc.h>+#include <grpc/support/log_windows.h>++#include ""src/core/lib/event_engine/executor/executor.h""+#include ""src/core/lib/event_engine/trace.h""+#include ""src/core/lib/event_engine/windows/win_socket.h""+#include ""src/core/lib/gprpp/sync.h""+#include ""src/core/lib/iomgr/error.h""++#if defined(__MSYS__) && defined(GPR_ARCH_64)+/* Nasty workaround for nasty bug when using the 64 bits msys compiler+   in conjunction with Microsoft Windows headers. */+#define GRPC_FIONBIO _IOW('f', 126, uint32_t)+#else+#define GRPC_FIONBIO FIONBIO+#endif++namespace grpc_event_engine {+namespace experimental {++WinSocket::WinSocket(SOCKET socket, Executor* executor) noexcept+    : socket_(socket),+      executor_(executor),+      read_info_(OpState(this)),+      write_info_(OpState(this)) {}++WinSocket::~WinSocket() { GPR_ASSERT(is_shutdown_); }++SOCKET WinSocket::socket() { return socket_; }++void WinSocket::MaybeShutdown(absl::Status why) {+  grpc_core::MutexLock lock(&mu_);+  // if already shutdown, return early. Otherwise, set the shutdown flag.+  if (is_shutdown_) {+    if (GRPC_TRACE_FLAG_ENABLED(grpc_event_engine_trace)) {+      gpr_log(GPR_DEBUG, ""WinSocket::%p already shutting down"", this);+    }+    return;+  }+  is_shutdown_ = true;+  if (GRPC_TRACE_FLAG_ENABLED(grpc_event_engine_trace)) {+    gpr_log(GPR_DEBUG, ""WinSocket::%p shutting down now. Reason: %s"", this,+            why.ToString().c_str());+  }+  // Grab the function pointer for DisconnectEx for that specific socket.+  // It may change depending on the interface.+  GUID guid = WSAID_DISCONNECTEX;+  LPFN_DISCONNECTEX DisconnectEx;+  DWORD ioctl_num_bytes;+  int status = WSAIoctl(socket_, SIO_GET_EXTENSION_FUNCTION_POINTER, &guid,+                        sizeof(guid), &DisconnectEx, sizeof(DisconnectEx),+                        &ioctl_num_bytes, NULL, NULL);++  if (status == 0) {+    DisconnectEx(socket_, NULL, 0, 0);+  } else {+    char* utf8_message = gpr_format_message(WSAGetLastError());+    gpr_log(GPR_INFO, ""Unable to retrieve DisconnectEx pointer : %s"",+            utf8_message);+    gpr_free(utf8_message);+  }+  closesocket(socket_);+}++void WinSocket::NotifyOnReady(OpState& info, EventEngine::Closure* closure) {+  grpc_core::MutexLock lock(&mu_);+  if (IsShutdown()) {+    info.SetError(WSAESHUTDOWN);+    executor_->Run(closure);+    return;+  };+  if (info.has_pending_iocp_) {","nit: nowadays I'm getting into the habit of writing `if (absl::exchange(info.has_pending_iocp_, false)) {` for this pattern to more clearly & concisely label that it's a state edge",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/29873,935643806,2022-08-02T14:08:35Z,src/core/ext/transport/chttp2/transport/hpack_encoder.cc,"@@ -211,7 +211,7 @@ class BinaryStringValue {   explicit BinaryStringValue(Slice value, bool use_true_binary_metadata)       : wire_value_(             GetWireValue(std::move(value), use_true_binary_metadata, true)),-        len_val_(wire_value_.length) {}+        len_val_(static_cast<uint32_t>(wire_value_.length)) {}",These static casts are impacting the readability of this code substantially - and we ought to be asserting the range rather than silently truncating. Suggest instead having the `VarIntWriter<>` constructor take a `size_t` and assert the length is within bounds.,X
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/30419,935816098,2022-08-02T16:48:40Z,src/core/lib/event_engine/posix_engine/ev_poll_posix.cc,"@@ -87,20 +92,32 @@ class PollEventHandle : public EventHandle {         pollhup_(false),         watch_mask_(-1),         shutdown_error_(absl::OkStatus()),+        exec_actions_closure_([this]() { ExecutePendingActions(); }),         on_done_(nullptr),-        read_closure_(reinterpret_cast<IomgrEngineClosure*>(kClosureNotReady)),+        read_closure_(reinterpret_cast<PosixEngineClosure*>(kClosureNotReady)),         write_closure_(-            reinterpret_cast<IomgrEngineClosure*>(kClosureNotReady)) {+            reinterpret_cast<PosixEngineClosure*>(kClosureNotReady)) {+    poller_handles_list_.next = nullptr;","nit: I'd recommend having a `HandleList` handle its own member initialization, either via member default values or via a constructor.For example:```  class HandlesList {   public:    explicit HandlesList(PollEventHandle* handle) : handle(handle) {}    PollEventHandle* handle;    PollEventHandle* next = nullptr;    PollEventHandle* prev = nullptr;  };```",
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/30419,935825290,2022-08-02T16:57:46Z,test/core/event_engine/posix/event_poller_posix_test.cc,"@@ -513,7 +544,196 @@ TEST_P(EventPollerTest, TestEventPollerHandleChange) {   close(sv[1]); } -INSTANTIATE_TEST_SUITE_P(EventPoller, EventPollerTest,+std::atomic<int> kTotalActiveWakeupFdHandles{0};++// A helper class representing one file descriptor. Its implemented using+// a WakeupFd. It registers itself with the poller and waits to be notified+// of read events. Upon receiving a read event, (1) it processes it,+// (2) registes to be notified of the next read event and (3) schedules+// generation of the next read event. The Fd orphanes itself after processing+// a specified number of read events.+class WakeupFdHandle {+ public:+  WakeupFdHandle(int num_wakeups, Scheduler* scheduler,+                 PosixEventPoller* poller)+      : num_wakeups_(num_wakeups),+        scheduler_(scheduler),+        poller_(poller),+        on_read_(+            PosixEngineClosure::ToPermanentClosure([this](absl::Status status) {+              EXPECT_TRUE(status.ok());+              status = ReadPipe();+              if (!status.ok()) {+                // Rarely epoll1 poller may generate an EPOLLHUP - which is a+                // spurious wakeup. Poll based poller may also likely generate a+                // lot of spurious wakeups because of the level triggered nature+                // of poll In such cases do not bother changing the number of+                // wakeups received.+                EXPECT_EQ(status, absl::InternalError(""Spurious Wakeup""));+                handle_->NotifyOnRead(on_read_);+                return;+              }+              if (--num_wakeups_ == 0) {+                // This should invoke the registered NotifyOnRead callbacks with+                // the shutdown error. When those callbacks call Unref(), the+                // WakeupFdHandle should call OrphanHandle in the Unref() method+                // implementation.+                handle_->ShutdownHandle(absl::InternalError(""Shutting down""));+                Unref();+              } else {+                handle_->NotifyOnRead(on_read_);+                Ref();+                // Schedule next wakeup to trigger the registered NotifyOnRead+                // callback.+                scheduler_->Run(SelfDeletingClosure::Create([this]() {+                  // Send next wakeup.+                  EXPECT_TRUE(wakeup_fd_->Wakeup().ok());+                  Unref();+                }));+              }+            })) {+    ++kTotalActiveWakeupFdHandles;+    EXPECT_GT(num_wakeups_, 0);+    EXPECT_NE(scheduler_, nullptr);+    EXPECT_NE(poller_, nullptr);+    wakeup_fd_ = *PipeWakeupFd::CreatePipeWakeupFd();+    handle_ = poller_->CreateHandle(wakeup_fd_->ReadFd(), ""test"", false);+    EXPECT_NE(handle_, nullptr);+    handle_->NotifyOnRead(on_read_);+    //  Send a wakeup initially.+    EXPECT_TRUE(wakeup_fd_->Wakeup().ok());+  }++  ~WakeupFdHandle() { delete on_read_; }++ private:+  absl::Status ReadPipe() {+    char buf[128];+    ssize_t r;+    int total_bytes_read = 0;+    for (;;) {+      r = read(wakeup_fd_->ReadFd(), buf, sizeof(buf));+      if (r > 0) {+        total_bytes_read += r;+        continue;+      }+      if (r == 0) return absl::OkStatus();+      switch (errno) {+        case EAGAIN:+          return total_bytes_read > 0 ? absl::OkStatus()+                                      : absl::InternalError(""Spurious Wakeup"");+        case EINTR:+          continue;+        default:+          return absl::Status(absl::StatusCode::kInternal,+                              absl::StrCat(""read: "", strerror(errno)));+      }+    }+  }+  void Ref() { ref_count_.fetch_add(1, std::memory_order_relaxed); }+  void Unref() {+    if (ref_count_.fetch_sub(1, std::memory_order_acq_rel) == 1) {+      // Once the handle has orphaned itself, decrement+      // kTotalActiveWakeupFdHandles. Once all handles have orphaned themselves,+      // send a Kick to the poller.+      handle_->OrphanHandle(+          PosixEngineClosure::TestOnlyToClosure(+              [poller = poller_, wakeupfd_handle = this](absl::Status status) {+                EXPECT_TRUE(status.ok());+                if (--kTotalActiveWakeupFdHandles == 0) {+                  poller->Kick();+                }+                delete wakeupfd_handle;+              }),+          nullptr, """");+    }+  }+  int num_wakeups_;+  Scheduler* scheduler_;+  PosixEventPoller* poller_;+  PosixEngineClosure* on_read_;+  std::atomic<int> ref_count_{1};+  std::unique_ptr<WakeupFd> wakeup_fd_;+  EventHandle* handle_;+};++// A helper class to create Fds and drive the polling for these Fds. It+// repeatedly calls the Work(..) method on the poller to get pet pending events,+// then schedules another parallel Work(..) instantiation and processes these+// pending events. This continues until all Fds have orphaned themselves.+class Worker {+ public:+  Worker(Scheduler* scheduler, PosixEventPoller* poller, int num_handles,+         int num_wakeups_per_handle)+      : scheduler_(scheduler), poller_(poller) {+    handles_.reserve(num_handles);+    for (int i = 0; i < num_handles; i++) {+      handles_.push_back(+          new WakeupFdHandle(num_wakeups_per_handle, scheduler_, poller_));+    }+  }+  void Ref() { ref_count_.fetch_add(1, std::memory_order_relaxed); }+  void Unref() {+    if (ref_count_.fetch_sub(1, std::memory_order_acq_rel) == 1) {+      promise.Set(true);+    }+  }++  void Start() {+    // Start executing Work(..).+    scheduler_->Run([this]() { Work(); });+  }++  void Wait() { EXPECT_TRUE(promise.Get()); }","suggestion: You can use `promise.WaitWithTimeout` to time-box this test. By default, tests run for 5 minutes, which is a long time if you're deadlocked within a second or two.",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/30459,935918323,2022-08-02T18:47:01Z,src/core/lib/promise/detail/basic_seq.h,"@@ -404,8 +414,7 @@ class BasicSeq { // At each element, the accumulator A and the current value V is passed to some // function of type F as f(V, A); f is expected to return a promise that // resolves to Traits::WrappedType.-template <template <typename Wrapped> class Traits, typename F, typename Arg,-          typename Iter>+template <class Traits, typename F, typename Arg, typename Iter>","If we're going this far, could we also just remove the `typename F, typename Arg, typename Iter` from this type, so that we end up with `template <class Traits> class BasicSeqIter` (same for the others here)",
11522026,ralphchung,https://api.github.com/repos/grpc/grpc/pulls/30414,936050034,2022-08-02T21:41:01Z,BUILD,"@@ -6700,6 +6699,7 @@ grpc_cc_library(     tags = [""nofixdeps""],     visibility = [""@grpc:public""],     deps = [+        ""grpc++_base"",","I think this is a better place to bring the dependency given that we are removing `grpc++_codegen_base` and `grpc++_codegen_base_src` in the future.Also, this change makes the blaze rule in Google internal not need to add the dependency.",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/30491,937961252,2022-08-04T15:48:56Z,src/core/lib/gprpp/no_destruct.h,"@@ -0,0 +1,62 @@+// Copyright 2022 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++#ifndef GRPC_CORE_LIB_GPRPP_NO_DESTRUCT_H+#define GRPC_CORE_LIB_GPRPP_NO_DESTRUCT_H++#include <grpc/support/port_platform.h>++#include <utility>++#include ""src/core/lib/gprpp/construct_destruct.h""++namespace grpc_core {++template <typename T>+class NoDestruct {","added a comment... this is useful directly but harder (whereas the singleton type is *really* easy to use, but doesn't cover everything you'd want)",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/30473,938209988,2022-08-04T20:14:17Z,src/core/lib/event_engine/forkable.h,"@@ -0,0 +1,60 @@+// Copyright 2022 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+#ifndef GRPC_CORE_LIB_EVENT_ENGINE_FORKABLE_H+#define GRPC_CORE_LIB_EVENT_ENGINE_FORKABLE_H++#include <grpc/support/port_platform.h>++namespace grpc_event_engine {+namespace experimental {++// Register fork handlers with the system, enabling fork support.+//+// This provides pthread-based support for fork events. Any objects that+// implement Forkable can register themselves with this system using+// ManageForkable, and their respective methods will be called upon fork.+//+// This should be called once upon grpc_initialization.+void RegisterForkHandlers();++// Global callback for pthread_atfork's *prepare argument+void PrepareFork();+// Global callback for pthread_atfork's *parent argument+void PostforkParent();+// Global callback for pthread_atfork's *child argument+void PostforkChild();++// An interface to be implemented by EventEngines that wish to have managed fork+// support.+class Forkable {+ public:+  virtual ~Forkable() = default;","prefer `protected: ~Forkable() = default;` here -- there should be nothing that deletes a forkable directly, so hiding the destructor prevents that, at which point we don't need the virtual destructor, saving one word per forkable.",
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/30539,940731214,2022-08-08T22:54:43Z,src/core/lib/event_engine/posix_engine/traced_buffer_list.cc,"@@ -0,0 +1,305 @@+// Copyright 2022 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++#include <grpc/support/port_platform.h>++#include ""src/core/lib/event_engine/posix_engine/traced_buffer_list.h""++#include ""absl/functional/any_invocable.h""++#include <grpc/support/log.h>++#include ""src/core/lib/iomgr/port.h""++#ifdef GRPC_LINUX_ERRQUEUE+#include <netinet/in.h>+#include <string.h>+#include <time.h>++namespace grpc_event_engine {+namespace posix_engine {++namespace {+// Fills gpr_timespec gts based on values from timespec ts.+void FillGprFromTimestamp(gpr_timespec* gts, const struct timespec* ts) {+  gts->tv_sec = ts->tv_sec;+  gts->tv_nsec = static_cast<int32_t>(ts->tv_nsec);+  gts->clock_type = GPR_CLOCK_REALTIME;+}++void DefaultTimestampsCallback(void* /*arg*/, Timestamps* /*ts*/,+                               absl::Status /*shudown_err*/) {+  gpr_log(GPR_DEBUG, ""Timestamps callback has not been registered"");+}++// The saved callback function that will be invoked when we get all the+// timestamps that we are going to get for a TracedBuffer.+absl::AnyInvocable<void(void*, Timestamps*, absl::Status)>+    g_timestamps_callback =+        []() -> absl::AnyInvocable<void(void*, Timestamps*, absl::Status)> {+  return DefaultTimestampsCallback;+}();++// Used to extract individual opt stats from cmsg, so as to avoid troubles with+// unaligned reads.+template <typename T>+T ReadUnaligned(const void* ptr) {+  T val;+  memcpy(&val, ptr, sizeof(val));+  return val;+}++// Extracts opt stats from the tcp_info struct \a info to \a metrics+void ExtractOptStatsFromTcpInfo(ConnectionMetrics* metrics,+                                const tcp_info* info) {+  if (info == nullptr) {+    return;+  }+  if (info->length > offsetof(tcp_info, tcpi_sndbuf_limited)) {+    metrics->recurring_retrans.emplace(info->tcpi_retransmits);+    metrics->is_delivery_rate_app_limited.emplace(+        info->tcpi_delivery_rate_app_limited);+    metrics->congestion_window.emplace(info->tcpi_snd_cwnd);+    metrics->reordering.emplace(info->tcpi_reordering);+    metrics->packet_retx.emplace(info->tcpi_total_retrans);+    metrics->pacing_rate.emplace(info->tcpi_pacing_rate);+    metrics->data_notsent.emplace(info->tcpi_notsent_bytes);+    if (info->tcpi_min_rtt != UINT32_MAX) {+      metrics->min_rtt.emplace(info->tcpi_min_rtt);+    }+    metrics->packet_sent.emplace(info->tcpi_data_segs_out);+    metrics->delivery_rate.emplace(info->tcpi_delivery_rate);+    metrics->busy_usec.emplace(info->tcpi_busy_time);+    metrics->rwnd_limited_usec.emplace(info->tcpi_rwnd_limited);+    metrics->sndbuf_limited_usec.emplace(info->tcpi_sndbuf_limited);+  }+  if (info->length > offsetof(tcp_info, tcpi_dsack_dups)) {+    metrics->data_sent.emplace(info->tcpi_bytes_sent);+    metrics->data_retx.emplace(info->tcpi_bytes_retrans);+    metrics->packet_spurious_retx.emplace(info->tcpi_dsack_dups);+  }+}++// Extracts opt stats from the given control message \a opt_stats to the+// connection metrics \a metrics.+void ExtractOptStatsFromCmsg(ConnectionMetrics* metrics,+                             const cmsghdr* opt_stats) {+  if (opt_stats == nullptr) {+    return;+  }+  const auto* data = CMSG_DATA(opt_stats);+  constexpr int64_t cmsg_hdr_len = CMSG_ALIGN(sizeof(struct cmsghdr));+  const int64_t len = opt_stats->cmsg_len - cmsg_hdr_len;+  int64_t offset = 0;++  while (offset < len) {+    const auto* attr = reinterpret_cast<const nlattr*>(data + offset);+    const void* val = data + offset + NLA_HDRLEN;+    switch (attr->nla_type) {+      case TCP_NLA_BUSY: {+        metrics->busy_usec.emplace(ReadUnaligned<uint64_t>(val));+        break;+      }+      case TCP_NLA_RWND_LIMITED: {+        metrics->rwnd_limited_usec.emplace(ReadUnaligned<uint64_t>(val));+        break;+      }+      case TCP_NLA_SNDBUF_LIMITED: {+        metrics->sndbuf_limited_usec.emplace(ReadUnaligned<uint64_t>(val));+        break;+      }+      case TCP_NLA_PACING_RATE: {+        metrics->pacing_rate.emplace(ReadUnaligned<uint64_t>(val));+        break;+      }+      case TCP_NLA_DELIVERY_RATE: {+        metrics->delivery_rate.emplace(ReadUnaligned<uint64_t>(val));+        break;+      }+      case TCP_NLA_DELIVERY_RATE_APP_LMT: {+        metrics->is_delivery_rate_app_limited.emplace(+            ReadUnaligned<uint8_t>(val));+        break;+      }+      case TCP_NLA_SND_CWND: {+        metrics->congestion_window.emplace(ReadUnaligned<uint32_t>(val));+        break;+      }+      case TCP_NLA_MIN_RTT: {+        metrics->min_rtt.emplace(ReadUnaligned<uint32_t>(val));+        break;+      }+      case TCP_NLA_SRTT: {+        metrics->srtt.emplace(ReadUnaligned<uint32_t>(val));+        break;+      }+      case TCP_NLA_RECUR_RETRANS: {+        metrics->recurring_retrans.emplace(ReadUnaligned<uint8_t>(val));+        break;+      }+      case TCP_NLA_BYTES_SENT: {+        metrics->data_sent.emplace(ReadUnaligned<uint64_t>(val));+        break;+      }+      case TCP_NLA_DATA_SEGS_OUT: {+        metrics->packet_sent.emplace(ReadUnaligned<uint64_t>(val));+        break;+      }+      case TCP_NLA_TOTAL_RETRANS: {+        metrics->packet_retx.emplace(ReadUnaligned<uint64_t>(val));+        break;+      }+      case TCP_NLA_DELIVERED: {+        metrics->packet_delivered.emplace(ReadUnaligned<uint32_t>(val));+        break;+      }+      case TCP_NLA_DELIVERED_CE: {+        metrics->packet_delivered_ce.emplace(ReadUnaligned<uint32_t>(val));+        break;+      }+      case TCP_NLA_BYTES_RETRANS: {+        metrics->data_retx.emplace(ReadUnaligned<uint64_t>(val));+        break;+      }+      case TCP_NLA_DSACK_DUPS: {+        metrics->packet_spurious_retx.emplace(ReadUnaligned<uint32_t>(val));+        break;+      }+      case TCP_NLA_REORDERING: {+        metrics->reordering.emplace(ReadUnaligned<uint32_t>(val));+        break;+      }+      case TCP_NLA_SND_SSTHRESH: {+        metrics->snd_ssthresh.emplace(ReadUnaligned<uint32_t>(val));+        break;+      }+    }+    offset += NLA_ALIGN(attr->nla_len);+  }+}++int GetSocketTcpInfo(tcp_info* info, int fd) {+  memset(info, 0, sizeof(*info));+  info->length = offsetof(tcp_info, length);+  return getsockopt(fd, IPPROTO_TCP, TCP_INFO, info, &(info->length));+}+}  // namespace.++void TracedBuffer::AddNewEntry(TracedBuffer** head, uint32_t seq_no, int fd,+                               void* arg) {+  GPR_DEBUG_ASSERT(head != nullptr);+  TracedBuffer* new_elem = new TracedBuffer(seq_no, arg);+  // Store the current time as the sendmsg time.+  new_elem->ts_.sendmsg_time.time = gpr_now(GPR_CLOCK_REALTIME);+  new_elem->ts_.scheduled_time.time = gpr_inf_past(GPR_CLOCK_REALTIME);+  new_elem->ts_.sent_time.time = gpr_inf_past(GPR_CLOCK_REALTIME);+  new_elem->ts_.acked_time.time = gpr_inf_past(GPR_CLOCK_REALTIME);++  if (GetSocketTcpInfo(&new_elem->ts_.info, fd) == 0) {+    ExtractOptStatsFromTcpInfo(&new_elem->ts_.sendmsg_time.metrics,+                               &new_elem->ts_.info);+  }+  if (*head == nullptr) {+    *head = new_elem;+    return;+  }+  // Append at the end.+  TracedBuffer* ptr = *head;+  while (ptr->next_ != nullptr) {+    ptr = ptr->next_;+  }+  ptr->next_ = new_elem;+}++void TracedBuffer::ProcessTimestamp(TracedBuffer** head,+                                    struct sock_extended_err* serr,+                                    struct cmsghdr* opt_stats,+                                    struct scm_timestamping* tss) {+  GPR_DEBUG_ASSERT(head != nullptr);+  TracedBuffer* elem = *head;",Is there a reason something like a `std::list<TracedBuffer>` wouldn't work here? It would eliminate a fair bit of boilerplate (and room for error),
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/30539,940732181,2022-08-08T22:56:55Z,src/core/lib/event_engine/posix_engine/traced_buffer_list.cc,"@@ -0,0 +1,305 @@+// Copyright 2022 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++#include <grpc/support/port_platform.h>++#include ""src/core/lib/event_engine/posix_engine/traced_buffer_list.h""++#include ""absl/functional/any_invocable.h""++#include <grpc/support/log.h>++#include ""src/core/lib/iomgr/port.h""++#ifdef GRPC_LINUX_ERRQUEUE+#include <netinet/in.h>+#include <string.h>+#include <time.h>++namespace grpc_event_engine {+namespace posix_engine {++namespace {+// Fills gpr_timespec gts based on values from timespec ts.+void FillGprFromTimestamp(gpr_timespec* gts, const struct timespec* ts) {+  gts->tv_sec = ts->tv_sec;+  gts->tv_nsec = static_cast<int32_t>(ts->tv_nsec);+  gts->clock_type = GPR_CLOCK_REALTIME;+}++void DefaultTimestampsCallback(void* /*arg*/, Timestamps* /*ts*/,+                               absl::Status /*shudown_err*/) {+  gpr_log(GPR_DEBUG, ""Timestamps callback has not been registered"");+}++// The saved callback function that will be invoked when we get all the+// timestamps that we are going to get for a TracedBuffer.+absl::AnyInvocable<void(void*, Timestamps*, absl::Status)>+    g_timestamps_callback =+        []() -> absl::AnyInvocable<void(void*, Timestamps*, absl::Status)> {+  return DefaultTimestampsCallback;+}();++// Used to extract individual opt stats from cmsg, so as to avoid troubles with+// unaligned reads.+template <typename T>+T ReadUnaligned(const void* ptr) {+  T val;+  memcpy(&val, ptr, sizeof(val));+  return val;+}++// Extracts opt stats from the tcp_info struct \a info to \a metrics+void ExtractOptStatsFromTcpInfo(ConnectionMetrics* metrics,+                                const tcp_info* info) {+  if (info == nullptr) {+    return;+  }+  if (info->length > offsetof(tcp_info, tcpi_sndbuf_limited)) {+    metrics->recurring_retrans.emplace(info->tcpi_retransmits);+    metrics->is_delivery_rate_app_limited.emplace(+        info->tcpi_delivery_rate_app_limited);+    metrics->congestion_window.emplace(info->tcpi_snd_cwnd);+    metrics->reordering.emplace(info->tcpi_reordering);+    metrics->packet_retx.emplace(info->tcpi_total_retrans);+    metrics->pacing_rate.emplace(info->tcpi_pacing_rate);+    metrics->data_notsent.emplace(info->tcpi_notsent_bytes);+    if (info->tcpi_min_rtt != UINT32_MAX) {+      metrics->min_rtt.emplace(info->tcpi_min_rtt);+    }+    metrics->packet_sent.emplace(info->tcpi_data_segs_out);+    metrics->delivery_rate.emplace(info->tcpi_delivery_rate);+    metrics->busy_usec.emplace(info->tcpi_busy_time);+    metrics->rwnd_limited_usec.emplace(info->tcpi_rwnd_limited);+    metrics->sndbuf_limited_usec.emplace(info->tcpi_sndbuf_limited);+  }+  if (info->length > offsetof(tcp_info, tcpi_dsack_dups)) {+    metrics->data_sent.emplace(info->tcpi_bytes_sent);+    metrics->data_retx.emplace(info->tcpi_bytes_retrans);+    metrics->packet_spurious_retx.emplace(info->tcpi_dsack_dups);+  }+}++// Extracts opt stats from the given control message \a opt_stats to the+// connection metrics \a metrics.+void ExtractOptStatsFromCmsg(ConnectionMetrics* metrics,+                             const cmsghdr* opt_stats) {+  if (opt_stats == nullptr) {+    return;+  }+  const auto* data = CMSG_DATA(opt_stats);+  constexpr int64_t cmsg_hdr_len = CMSG_ALIGN(sizeof(struct cmsghdr));+  const int64_t len = opt_stats->cmsg_len - cmsg_hdr_len;+  int64_t offset = 0;++  while (offset < len) {+    const auto* attr = reinterpret_cast<const nlattr*>(data + offset);+    const void* val = data + offset + NLA_HDRLEN;+    switch (attr->nla_type) {+      case TCP_NLA_BUSY: {+        metrics->busy_usec.emplace(ReadUnaligned<uint64_t>(val));+        break;+      }+      case TCP_NLA_RWND_LIMITED: {+        metrics->rwnd_limited_usec.emplace(ReadUnaligned<uint64_t>(val));+        break;+      }+      case TCP_NLA_SNDBUF_LIMITED: {+        metrics->sndbuf_limited_usec.emplace(ReadUnaligned<uint64_t>(val));+        break;+      }+      case TCP_NLA_PACING_RATE: {+        metrics->pacing_rate.emplace(ReadUnaligned<uint64_t>(val));+        break;+      }+      case TCP_NLA_DELIVERY_RATE: {+        metrics->delivery_rate.emplace(ReadUnaligned<uint64_t>(val));+        break;+      }+      case TCP_NLA_DELIVERY_RATE_APP_LMT: {+        metrics->is_delivery_rate_app_limited.emplace(+            ReadUnaligned<uint8_t>(val));+        break;+      }+      case TCP_NLA_SND_CWND: {+        metrics->congestion_window.emplace(ReadUnaligned<uint32_t>(val));+        break;+      }+      case TCP_NLA_MIN_RTT: {+        metrics->min_rtt.emplace(ReadUnaligned<uint32_t>(val));+        break;+      }+      case TCP_NLA_SRTT: {+        metrics->srtt.emplace(ReadUnaligned<uint32_t>(val));+        break;+      }+      case TCP_NLA_RECUR_RETRANS: {+        metrics->recurring_retrans.emplace(ReadUnaligned<uint8_t>(val));+        break;+      }+      case TCP_NLA_BYTES_SENT: {+        metrics->data_sent.emplace(ReadUnaligned<uint64_t>(val));+        break;+      }+      case TCP_NLA_DATA_SEGS_OUT: {+        metrics->packet_sent.emplace(ReadUnaligned<uint64_t>(val));+        break;+      }+      case TCP_NLA_TOTAL_RETRANS: {+        metrics->packet_retx.emplace(ReadUnaligned<uint64_t>(val));+        break;+      }+      case TCP_NLA_DELIVERED: {+        metrics->packet_delivered.emplace(ReadUnaligned<uint32_t>(val));+        break;+      }+      case TCP_NLA_DELIVERED_CE: {+        metrics->packet_delivered_ce.emplace(ReadUnaligned<uint32_t>(val));+        break;+      }+      case TCP_NLA_BYTES_RETRANS: {+        metrics->data_retx.emplace(ReadUnaligned<uint64_t>(val));+        break;+      }+      case TCP_NLA_DSACK_DUPS: {+        metrics->packet_spurious_retx.emplace(ReadUnaligned<uint32_t>(val));+        break;+      }+      case TCP_NLA_REORDERING: {+        metrics->reordering.emplace(ReadUnaligned<uint32_t>(val));+        break;+      }+      case TCP_NLA_SND_SSTHRESH: {+        metrics->snd_ssthresh.emplace(ReadUnaligned<uint32_t>(val));+        break;+      }+    }+    offset += NLA_ALIGN(attr->nla_len);+  }+}++int GetSocketTcpInfo(tcp_info* info, int fd) {","This seems generally valuable beyond this class, consider putting it with other network utils.",
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/30539,940733799,2022-08-08T23:00:40Z,src/core/lib/event_engine/posix_engine/traced_buffer_list.cc,"@@ -0,0 +1,305 @@+// Copyright 2022 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++#include <grpc/support/port_platform.h>++#include ""src/core/lib/event_engine/posix_engine/traced_buffer_list.h""++#include ""absl/functional/any_invocable.h""++#include <grpc/support/log.h>++#include ""src/core/lib/iomgr/port.h""++#ifdef GRPC_LINUX_ERRQUEUE+#include <netinet/in.h>+#include <string.h>+#include <time.h>++namespace grpc_event_engine {+namespace posix_engine {++namespace {+// Fills gpr_timespec gts based on values from timespec ts.+void FillGprFromTimestamp(gpr_timespec* gts, const struct timespec* ts) {+  gts->tv_sec = ts->tv_sec;+  gts->tv_nsec = static_cast<int32_t>(ts->tv_nsec);+  gts->clock_type = GPR_CLOCK_REALTIME;+}++void DefaultTimestampsCallback(void* /*arg*/, Timestamps* /*ts*/,+                               absl::Status /*shudown_err*/) {+  gpr_log(GPR_DEBUG, ""Timestamps callback has not been registered"");+}++// The saved callback function that will be invoked when we get all the+// timestamps that we are going to get for a TracedBuffer.+absl::AnyInvocable<void(void*, Timestamps*, absl::Status)>+    g_timestamps_callback =+        []() -> absl::AnyInvocable<void(void*, Timestamps*, absl::Status)> {+  return DefaultTimestampsCallback;+}();++// Used to extract individual opt stats from cmsg, so as to avoid troubles with+// unaligned reads.+template <typename T>+T ReadUnaligned(const void* ptr) {+  T val;+  memcpy(&val, ptr, sizeof(val));+  return val;+}++// Extracts opt stats from the tcp_info struct \a info to \a metrics+void ExtractOptStatsFromTcpInfo(ConnectionMetrics* metrics,+                                const tcp_info* info) {+  if (info == nullptr) {+    return;+  }+  if (info->length > offsetof(tcp_info, tcpi_sndbuf_limited)) {+    metrics->recurring_retrans.emplace(info->tcpi_retransmits);+    metrics->is_delivery_rate_app_limited.emplace(+        info->tcpi_delivery_rate_app_limited);+    metrics->congestion_window.emplace(info->tcpi_snd_cwnd);+    metrics->reordering.emplace(info->tcpi_reordering);+    metrics->packet_retx.emplace(info->tcpi_total_retrans);+    metrics->pacing_rate.emplace(info->tcpi_pacing_rate);+    metrics->data_notsent.emplace(info->tcpi_notsent_bytes);+    if (info->tcpi_min_rtt != UINT32_MAX) {+      metrics->min_rtt.emplace(info->tcpi_min_rtt);+    }+    metrics->packet_sent.emplace(info->tcpi_data_segs_out);+    metrics->delivery_rate.emplace(info->tcpi_delivery_rate);+    metrics->busy_usec.emplace(info->tcpi_busy_time);+    metrics->rwnd_limited_usec.emplace(info->tcpi_rwnd_limited);+    metrics->sndbuf_limited_usec.emplace(info->tcpi_sndbuf_limited);+  }+  if (info->length > offsetof(tcp_info, tcpi_dsack_dups)) {+    metrics->data_sent.emplace(info->tcpi_bytes_sent);+    metrics->data_retx.emplace(info->tcpi_bytes_retrans);+    metrics->packet_spurious_retx.emplace(info->tcpi_dsack_dups);+  }+}++// Extracts opt stats from the given control message \a opt_stats to the+// connection metrics \a metrics.+void ExtractOptStatsFromCmsg(ConnectionMetrics* metrics,+                             const cmsghdr* opt_stats) {+  if (opt_stats == nullptr) {+    return;+  }+  const auto* data = CMSG_DATA(opt_stats);+  constexpr int64_t cmsg_hdr_len = CMSG_ALIGN(sizeof(struct cmsghdr));+  const int64_t len = opt_stats->cmsg_len - cmsg_hdr_len;+  int64_t offset = 0;++  while (offset < len) {+    const auto* attr = reinterpret_cast<const nlattr*>(data + offset);+    const void* val = data + offset + NLA_HDRLEN;+    switch (attr->nla_type) {+      case TCP_NLA_BUSY: {+        metrics->busy_usec.emplace(ReadUnaligned<uint64_t>(val));+        break;+      }+      case TCP_NLA_RWND_LIMITED: {+        metrics->rwnd_limited_usec.emplace(ReadUnaligned<uint64_t>(val));+        break;+      }+      case TCP_NLA_SNDBUF_LIMITED: {+        metrics->sndbuf_limited_usec.emplace(ReadUnaligned<uint64_t>(val));+        break;+      }+      case TCP_NLA_PACING_RATE: {+        metrics->pacing_rate.emplace(ReadUnaligned<uint64_t>(val));+        break;+      }+      case TCP_NLA_DELIVERY_RATE: {+        metrics->delivery_rate.emplace(ReadUnaligned<uint64_t>(val));+        break;+      }+      case TCP_NLA_DELIVERY_RATE_APP_LMT: {+        metrics->is_delivery_rate_app_limited.emplace(+            ReadUnaligned<uint8_t>(val));+        break;+      }+      case TCP_NLA_SND_CWND: {+        metrics->congestion_window.emplace(ReadUnaligned<uint32_t>(val));+        break;+      }+      case TCP_NLA_MIN_RTT: {+        metrics->min_rtt.emplace(ReadUnaligned<uint32_t>(val));+        break;+      }+      case TCP_NLA_SRTT: {+        metrics->srtt.emplace(ReadUnaligned<uint32_t>(val));+        break;+      }+      case TCP_NLA_RECUR_RETRANS: {+        metrics->recurring_retrans.emplace(ReadUnaligned<uint8_t>(val));+        break;+      }+      case TCP_NLA_BYTES_SENT: {+        metrics->data_sent.emplace(ReadUnaligned<uint64_t>(val));+        break;+      }+      case TCP_NLA_DATA_SEGS_OUT: {+        metrics->packet_sent.emplace(ReadUnaligned<uint64_t>(val));+        break;+      }+      case TCP_NLA_TOTAL_RETRANS: {+        metrics->packet_retx.emplace(ReadUnaligned<uint64_t>(val));+        break;+      }+      case TCP_NLA_DELIVERED: {+        metrics->packet_delivered.emplace(ReadUnaligned<uint32_t>(val));+        break;+      }+      case TCP_NLA_DELIVERED_CE: {+        metrics->packet_delivered_ce.emplace(ReadUnaligned<uint32_t>(val));+        break;+      }+      case TCP_NLA_BYTES_RETRANS: {+        metrics->data_retx.emplace(ReadUnaligned<uint64_t>(val));+        break;+      }+      case TCP_NLA_DSACK_DUPS: {+        metrics->packet_spurious_retx.emplace(ReadUnaligned<uint32_t>(val));+        break;+      }+      case TCP_NLA_REORDERING: {+        metrics->reordering.emplace(ReadUnaligned<uint32_t>(val));+        break;+      }+      case TCP_NLA_SND_SSTHRESH: {+        metrics->snd_ssthresh.emplace(ReadUnaligned<uint32_t>(val));+        break;+      }+    }+    offset += NLA_ALIGN(attr->nla_len);+  }+}++int GetSocketTcpInfo(tcp_info* info, int fd) {+  memset(info, 0, sizeof(*info));+  info->length = offsetof(tcp_info, length);+  return getsockopt(fd, IPPROTO_TCP, TCP_INFO, info, &(info->length));+}+}  // namespace.++void TracedBuffer::AddNewEntry(TracedBuffer** head, uint32_t seq_no, int fd,+                               void* arg) {+  GPR_DEBUG_ASSERT(head != nullptr);+  TracedBuffer* new_elem = new TracedBuffer(seq_no, arg);","This static method is effectively a conjoined TracedBuffer constructor and a list append operation. I'd recommend splitting them up and protect the interfaces a bit better via encapsulation.Consider something like:```std::list<TracedBuffer> traced_buffer list;traced_buffer_list.emplace_front(seq_no, fd, arg);```... or similar with pointers if heap allocation is necessary here.",X
5564114,Vignesh2208,https://api.github.com/repos/grpc/grpc/pulls/30539,940792094,2022-08-09T01:11:55Z,src/core/lib/event_engine/posix_engine/traced_buffer_list.cc,"@@ -0,0 +1,305 @@+// Copyright 2022 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++#include <grpc/support/port_platform.h>++#include ""src/core/lib/event_engine/posix_engine/traced_buffer_list.h""++#include ""absl/functional/any_invocable.h""++#include <grpc/support/log.h>++#include ""src/core/lib/iomgr/port.h""++#ifdef GRPC_LINUX_ERRQUEUE+#include <netinet/in.h>+#include <string.h>+#include <time.h>++namespace grpc_event_engine {+namespace posix_engine {++namespace {+// Fills gpr_timespec gts based on values from timespec ts.+void FillGprFromTimestamp(gpr_timespec* gts, const struct timespec* ts) {+  gts->tv_sec = ts->tv_sec;+  gts->tv_nsec = static_cast<int32_t>(ts->tv_nsec);+  gts->clock_type = GPR_CLOCK_REALTIME;+}++void DefaultTimestampsCallback(void* /*arg*/, Timestamps* /*ts*/,+                               absl::Status /*shudown_err*/) {+  gpr_log(GPR_DEBUG, ""Timestamps callback has not been registered"");+}++// The saved callback function that will be invoked when we get all the+// timestamps that we are going to get for a TracedBuffer.+absl::AnyInvocable<void(void*, Timestamps*, absl::Status)>+    g_timestamps_callback =+        []() -> absl::AnyInvocable<void(void*, Timestamps*, absl::Status)> {+  return DefaultTimestampsCallback;+}();++// Used to extract individual opt stats from cmsg, so as to avoid troubles with+// unaligned reads.+template <typename T>+T ReadUnaligned(const void* ptr) {+  T val;+  memcpy(&val, ptr, sizeof(val));+  return val;+}++// Extracts opt stats from the tcp_info struct \a info to \a metrics+void ExtractOptStatsFromTcpInfo(ConnectionMetrics* metrics,+                                const tcp_info* info) {+  if (info == nullptr) {+    return;+  }+  if (info->length > offsetof(tcp_info, tcpi_sndbuf_limited)) {+    metrics->recurring_retrans.emplace(info->tcpi_retransmits);+    metrics->is_delivery_rate_app_limited.emplace(+        info->tcpi_delivery_rate_app_limited);+    metrics->congestion_window.emplace(info->tcpi_snd_cwnd);+    metrics->reordering.emplace(info->tcpi_reordering);+    metrics->packet_retx.emplace(info->tcpi_total_retrans);+    metrics->pacing_rate.emplace(info->tcpi_pacing_rate);+    metrics->data_notsent.emplace(info->tcpi_notsent_bytes);+    if (info->tcpi_min_rtt != UINT32_MAX) {+      metrics->min_rtt.emplace(info->tcpi_min_rtt);+    }+    metrics->packet_sent.emplace(info->tcpi_data_segs_out);+    metrics->delivery_rate.emplace(info->tcpi_delivery_rate);+    metrics->busy_usec.emplace(info->tcpi_busy_time);+    metrics->rwnd_limited_usec.emplace(info->tcpi_rwnd_limited);+    metrics->sndbuf_limited_usec.emplace(info->tcpi_sndbuf_limited);+  }+  if (info->length > offsetof(tcp_info, tcpi_dsack_dups)) {+    metrics->data_sent.emplace(info->tcpi_bytes_sent);+    metrics->data_retx.emplace(info->tcpi_bytes_retrans);+    metrics->packet_spurious_retx.emplace(info->tcpi_dsack_dups);+  }+}++// Extracts opt stats from the given control message \a opt_stats to the+// connection metrics \a metrics.+void ExtractOptStatsFromCmsg(ConnectionMetrics* metrics,+                             const cmsghdr* opt_stats) {+  if (opt_stats == nullptr) {+    return;+  }+  const auto* data = CMSG_DATA(opt_stats);+  constexpr int64_t cmsg_hdr_len = CMSG_ALIGN(sizeof(struct cmsghdr));+  const int64_t len = opt_stats->cmsg_len - cmsg_hdr_len;+  int64_t offset = 0;++  while (offset < len) {+    const auto* attr = reinterpret_cast<const nlattr*>(data + offset);+    const void* val = data + offset + NLA_HDRLEN;+    switch (attr->nla_type) {+      case TCP_NLA_BUSY: {+        metrics->busy_usec.emplace(ReadUnaligned<uint64_t>(val));+        break;+      }+      case TCP_NLA_RWND_LIMITED: {+        metrics->rwnd_limited_usec.emplace(ReadUnaligned<uint64_t>(val));+        break;+      }+      case TCP_NLA_SNDBUF_LIMITED: {+        metrics->sndbuf_limited_usec.emplace(ReadUnaligned<uint64_t>(val));+        break;+      }+      case TCP_NLA_PACING_RATE: {+        metrics->pacing_rate.emplace(ReadUnaligned<uint64_t>(val));+        break;+      }+      case TCP_NLA_DELIVERY_RATE: {+        metrics->delivery_rate.emplace(ReadUnaligned<uint64_t>(val));+        break;+      }+      case TCP_NLA_DELIVERY_RATE_APP_LMT: {+        metrics->is_delivery_rate_app_limited.emplace(+            ReadUnaligned<uint8_t>(val));+        break;+      }+      case TCP_NLA_SND_CWND: {+        metrics->congestion_window.emplace(ReadUnaligned<uint32_t>(val));+        break;+      }+      case TCP_NLA_MIN_RTT: {+        metrics->min_rtt.emplace(ReadUnaligned<uint32_t>(val));+        break;+      }+      case TCP_NLA_SRTT: {+        metrics->srtt.emplace(ReadUnaligned<uint32_t>(val));+        break;+      }+      case TCP_NLA_RECUR_RETRANS: {+        metrics->recurring_retrans.emplace(ReadUnaligned<uint8_t>(val));+        break;+      }+      case TCP_NLA_BYTES_SENT: {+        metrics->data_sent.emplace(ReadUnaligned<uint64_t>(val));+        break;+      }+      case TCP_NLA_DATA_SEGS_OUT: {+        metrics->packet_sent.emplace(ReadUnaligned<uint64_t>(val));+        break;+      }+      case TCP_NLA_TOTAL_RETRANS: {+        metrics->packet_retx.emplace(ReadUnaligned<uint64_t>(val));+        break;+      }+      case TCP_NLA_DELIVERED: {+        metrics->packet_delivered.emplace(ReadUnaligned<uint32_t>(val));+        break;+      }+      case TCP_NLA_DELIVERED_CE: {+        metrics->packet_delivered_ce.emplace(ReadUnaligned<uint32_t>(val));+        break;+      }+      case TCP_NLA_BYTES_RETRANS: {+        metrics->data_retx.emplace(ReadUnaligned<uint64_t>(val));+        break;+      }+      case TCP_NLA_DSACK_DUPS: {+        metrics->packet_spurious_retx.emplace(ReadUnaligned<uint32_t>(val));+        break;+      }+      case TCP_NLA_REORDERING: {+        metrics->reordering.emplace(ReadUnaligned<uint32_t>(val));+        break;+      }+      case TCP_NLA_SND_SSTHRESH: {+        metrics->snd_ssthresh.emplace(ReadUnaligned<uint32_t>(val));+        break;+      }+    }+    offset += NLA_ALIGN(attr->nla_len);+  }+}++int GetSocketTcpInfo(tcp_info* info, int fd) {+  memset(info, 0, sizeof(*info));+  info->length = offsetof(tcp_info, length);+  return getsockopt(fd, IPPROTO_TCP, TCP_INFO, info, &(info->length));+}+}  // namespace.++void TracedBuffer::AddNewEntry(TracedBuffer** head, uint32_t seq_no, int fd,+                               void* arg) {+  GPR_DEBUG_ASSERT(head != nullptr);+  TracedBuffer* new_elem = new TracedBuffer(seq_no, arg);+  // Store the current time as the sendmsg time.+  new_elem->ts_.sendmsg_time.time = gpr_now(GPR_CLOCK_REALTIME);+  new_elem->ts_.scheduled_time.time = gpr_inf_past(GPR_CLOCK_REALTIME);+  new_elem->ts_.sent_time.time = gpr_inf_past(GPR_CLOCK_REALTIME);+  new_elem->ts_.acked_time.time = gpr_inf_past(GPR_CLOCK_REALTIME);++  if (GetSocketTcpInfo(&new_elem->ts_.info, fd) == 0) {+    ExtractOptStatsFromTcpInfo(&new_elem->ts_.sendmsg_time.metrics,+                               &new_elem->ts_.info);+  }+  if (*head == nullptr) {+    *head = new_elem;+    return;+  }+  // Append at the end.+  TracedBuffer* ptr = *head;+  while (ptr->next_ != nullptr) {+    ptr = ptr->next_;+  }+  ptr->next_ = new_elem;+}++void TracedBuffer::ProcessTimestamp(TracedBuffer** head,+                                    struct sock_extended_err* serr,+                                    struct cmsghdr* opt_stats,+                                    struct scm_timestamping* tss) {+  GPR_DEBUG_ASSERT(head != nullptr);+  TracedBuffer* elem = *head;",Updated to use std::list<TracedBuffer*>. Still doing heap allocations to avoid copying of TracedBuffer objects each time the list is popped,
5564114,Vignesh2208,https://api.github.com/repos/grpc/grpc/pulls/30539,940792793,2022-08-09T01:14:00Z,src/core/lib/event_engine/posix_engine/traced_buffer_list.cc,"@@ -0,0 +1,305 @@+// Copyright 2022 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++#include <grpc/support/port_platform.h>++#include ""src/core/lib/event_engine/posix_engine/traced_buffer_list.h""++#include ""absl/functional/any_invocable.h""++#include <grpc/support/log.h>++#include ""src/core/lib/iomgr/port.h""++#ifdef GRPC_LINUX_ERRQUEUE+#include <netinet/in.h>+#include <string.h>+#include <time.h>++namespace grpc_event_engine {+namespace posix_engine {++namespace {+// Fills gpr_timespec gts based on values from timespec ts.+void FillGprFromTimestamp(gpr_timespec* gts, const struct timespec* ts) {+  gts->tv_sec = ts->tv_sec;+  gts->tv_nsec = static_cast<int32_t>(ts->tv_nsec);+  gts->clock_type = GPR_CLOCK_REALTIME;+}++void DefaultTimestampsCallback(void* /*arg*/, Timestamps* /*ts*/,+                               absl::Status /*shudown_err*/) {+  gpr_log(GPR_DEBUG, ""Timestamps callback has not been registered"");+}++// The saved callback function that will be invoked when we get all the+// timestamps that we are going to get for a TracedBuffer.+absl::AnyInvocable<void(void*, Timestamps*, absl::Status)>+    g_timestamps_callback =+        []() -> absl::AnyInvocable<void(void*, Timestamps*, absl::Status)> {+  return DefaultTimestampsCallback;+}();++// Used to extract individual opt stats from cmsg, so as to avoid troubles with+// unaligned reads.+template <typename T>+T ReadUnaligned(const void* ptr) {+  T val;+  memcpy(&val, ptr, sizeof(val));+  return val;+}++// Extracts opt stats from the tcp_info struct \a info to \a metrics+void ExtractOptStatsFromTcpInfo(ConnectionMetrics* metrics,+                                const tcp_info* info) {+  if (info == nullptr) {+    return;+  }+  if (info->length > offsetof(tcp_info, tcpi_sndbuf_limited)) {+    metrics->recurring_retrans.emplace(info->tcpi_retransmits);+    metrics->is_delivery_rate_app_limited.emplace(+        info->tcpi_delivery_rate_app_limited);+    metrics->congestion_window.emplace(info->tcpi_snd_cwnd);+    metrics->reordering.emplace(info->tcpi_reordering);+    metrics->packet_retx.emplace(info->tcpi_total_retrans);+    metrics->pacing_rate.emplace(info->tcpi_pacing_rate);+    metrics->data_notsent.emplace(info->tcpi_notsent_bytes);+    if (info->tcpi_min_rtt != UINT32_MAX) {+      metrics->min_rtt.emplace(info->tcpi_min_rtt);+    }+    metrics->packet_sent.emplace(info->tcpi_data_segs_out);+    metrics->delivery_rate.emplace(info->tcpi_delivery_rate);+    metrics->busy_usec.emplace(info->tcpi_busy_time);+    metrics->rwnd_limited_usec.emplace(info->tcpi_rwnd_limited);+    metrics->sndbuf_limited_usec.emplace(info->tcpi_sndbuf_limited);+  }+  if (info->length > offsetof(tcp_info, tcpi_dsack_dups)) {+    metrics->data_sent.emplace(info->tcpi_bytes_sent);+    metrics->data_retx.emplace(info->tcpi_bytes_retrans);+    metrics->packet_spurious_retx.emplace(info->tcpi_dsack_dups);+  }+}++// Extracts opt stats from the given control message \a opt_stats to the+// connection metrics \a metrics.+void ExtractOptStatsFromCmsg(ConnectionMetrics* metrics,+                             const cmsghdr* opt_stats) {+  if (opt_stats == nullptr) {+    return;+  }+  const auto* data = CMSG_DATA(opt_stats);+  constexpr int64_t cmsg_hdr_len = CMSG_ALIGN(sizeof(struct cmsghdr));+  const int64_t len = opt_stats->cmsg_len - cmsg_hdr_len;+  int64_t offset = 0;++  while (offset < len) {+    const auto* attr = reinterpret_cast<const nlattr*>(data + offset);+    const void* val = data + offset + NLA_HDRLEN;+    switch (attr->nla_type) {+      case TCP_NLA_BUSY: {+        metrics->busy_usec.emplace(ReadUnaligned<uint64_t>(val));+        break;+      }+      case TCP_NLA_RWND_LIMITED: {+        metrics->rwnd_limited_usec.emplace(ReadUnaligned<uint64_t>(val));+        break;+      }+      case TCP_NLA_SNDBUF_LIMITED: {+        metrics->sndbuf_limited_usec.emplace(ReadUnaligned<uint64_t>(val));+        break;+      }+      case TCP_NLA_PACING_RATE: {+        metrics->pacing_rate.emplace(ReadUnaligned<uint64_t>(val));+        break;+      }+      case TCP_NLA_DELIVERY_RATE: {+        metrics->delivery_rate.emplace(ReadUnaligned<uint64_t>(val));+        break;+      }+      case TCP_NLA_DELIVERY_RATE_APP_LMT: {+        metrics->is_delivery_rate_app_limited.emplace(+            ReadUnaligned<uint8_t>(val));+        break;+      }+      case TCP_NLA_SND_CWND: {+        metrics->congestion_window.emplace(ReadUnaligned<uint32_t>(val));+        break;+      }+      case TCP_NLA_MIN_RTT: {+        metrics->min_rtt.emplace(ReadUnaligned<uint32_t>(val));+        break;+      }+      case TCP_NLA_SRTT: {+        metrics->srtt.emplace(ReadUnaligned<uint32_t>(val));+        break;+      }+      case TCP_NLA_RECUR_RETRANS: {+        metrics->recurring_retrans.emplace(ReadUnaligned<uint8_t>(val));+        break;+      }+      case TCP_NLA_BYTES_SENT: {+        metrics->data_sent.emplace(ReadUnaligned<uint64_t>(val));+        break;+      }+      case TCP_NLA_DATA_SEGS_OUT: {+        metrics->packet_sent.emplace(ReadUnaligned<uint64_t>(val));+        break;+      }+      case TCP_NLA_TOTAL_RETRANS: {+        metrics->packet_retx.emplace(ReadUnaligned<uint64_t>(val));+        break;+      }+      case TCP_NLA_DELIVERED: {+        metrics->packet_delivered.emplace(ReadUnaligned<uint32_t>(val));+        break;+      }+      case TCP_NLA_DELIVERED_CE: {+        metrics->packet_delivered_ce.emplace(ReadUnaligned<uint32_t>(val));+        break;+      }+      case TCP_NLA_BYTES_RETRANS: {+        metrics->data_retx.emplace(ReadUnaligned<uint64_t>(val));+        break;+      }+      case TCP_NLA_DSACK_DUPS: {+        metrics->packet_spurious_retx.emplace(ReadUnaligned<uint32_t>(val));+        break;+      }+      case TCP_NLA_REORDERING: {+        metrics->reordering.emplace(ReadUnaligned<uint32_t>(val));+        break;+      }+      case TCP_NLA_SND_SSTHRESH: {+        metrics->snd_ssthresh.emplace(ReadUnaligned<uint32_t>(val));+        break;+      }+    }+    offset += NLA_ALIGN(attr->nla_len);+  }+}++int GetSocketTcpInfo(tcp_info* info, int fd) {+  memset(info, 0, sizeof(*info));+  info->length = offsetof(tcp_info, length);+  return getsockopt(fd, IPPROTO_TCP, TCP_INFO, info, &(info->length));+}+}  // namespace.++void TracedBuffer::AddNewEntry(TracedBuffer** head, uint32_t seq_no, int fd,+                               void* arg) {+  GPR_DEBUG_ASSERT(head != nullptr);+  TracedBuffer* new_elem = new TracedBuffer(seq_no, arg);",I updated the method now to use lists. However it doesn't make sense to have two methods here because the TracedBuffer type is not used externally by the TCP code. So all the manipulations need to be done only within the static methods.,
5564114,Vignesh2208,https://api.github.com/repos/grpc/grpc/pulls/30539,940793232,2022-08-09T01:14:58Z,src/core/lib/event_engine/posix_engine/traced_buffer_list.h,"@@ -0,0 +1,155 @@+// Copyright 2022 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++#ifndef GRPC_CORE_LIB_EVENT_ENGINE_POSIX_ENGINE_TRACED_BUFFER_LIST_H+#define GRPC_CORE_LIB_EVENT_ENGINE_POSIX_ENGINE_TRACED_BUFFER_LIST_H++#include <grpc/support/port_platform.h>++#include ""absl/functional/any_invocable.h""+#include ""absl/status/status.h""+#include ""absl/types/optional.h""++#include <grpc/support/time.h>++#include ""src/core/lib/event_engine/posix_engine/internal_errqueue.h""+#include ""src/core/lib/iomgr/port.h""++namespace grpc_event_engine {+namespace posix_engine {++struct ConnectionMetrics {+  /* Delivery rate in Bytes/s. */+  absl::optional<uint64_t> delivery_rate;+  /* If the delivery rate is limited by the application, this is set to true. */+  absl::optional<bool> is_delivery_rate_app_limited;+  /* Total packets retransmitted. */+  absl::optional<uint32_t> packet_retx;+  /* Total packets retransmitted spuriously. This metric is smaller than or+  equal to packet_retx. */+  absl::optional<uint32_t> packet_spurious_retx;+  /* Total packets sent. */+  absl::optional<uint32_t> packet_sent;+  /* Total packets delivered. */+  absl::optional<uint32_t> packet_delivered;+  /* Total packets delivered with ECE marked. This metric is smaller than or+  equal to packet_delivered. */+  absl::optional<uint32_t> packet_delivered_ce;+  /* Total bytes lost so far. */+  absl::optional<uint64_t> data_retx;+  /* Total bytes sent so far. */+  absl::optional<uint64_t> data_sent;+  /* Total bytes in write queue but not sent. */+  absl::optional<uint64_t> data_notsent;+  /* Pacing rate of the connection in Bps */+  absl::optional<uint64_t> pacing_rate;+  /* Minimum RTT observed in usec. */+  absl::optional<uint32_t> min_rtt;+  /* Smoothed RTT in usec */+  absl::optional<uint32_t> srtt;+  /* Send congestion window. */+  absl::optional<uint32_t> congestion_window;+  /* Slow start threshold in packets. */+  absl::optional<uint32_t> snd_ssthresh;+  /* Maximum degree of reordering (i.e., maximum number of packets reodered)+   on the connection. */+  absl::optional<uint32_t> reordering;+  /* Represents the number of recurring retransmissions of the first sequence+  that is not acknowledged yet. */+  absl::optional<uint8_t> recurring_retrans;+  /* The cumulative time (in usec) that the transport protocol was busy+   sending data. */+  absl::optional<uint64_t> busy_usec;+  /* The cumulative time (in usec) that the transport protocol was limited by+   the receive window size. */+  absl::optional<uint64_t> rwnd_limited_usec;+  /* The cumulative time (in usec) that the transport protocol was limited by+   the send buffer size. */+  absl::optional<uint64_t> sndbuf_limited_usec;+};++struct BufferTimestamp {+  gpr_timespec time;+  ConnectionMetrics metrics; /* Metrics collected with this timestamp */+};++struct Timestamps {+  BufferTimestamp sendmsg_time;+  BufferTimestamp scheduled_time;+  BufferTimestamp sent_time;+  BufferTimestamp acked_time;++  uint32_t byte_offset; /* byte offset relative to the start of the RPC */++#ifdef GRPC_LINUX_ERRQUEUE+  tcp_info info; /* tcp_info collected on sendmsg */+#endif           /* GRPC_LINUX_ERRQUEUE */+};++// TracedBuffer is a class to keep track of timestamps for a specific buffer in+// the TCP layer. We are only tracking timestamps for Linux kernels and hence+// this class would only be used by Linux platforms. For all other platforms,+// TracedBuffer would be an empty class.+// The timestamps collected are according to Timestamps declared above A+// TracedBuffer list is kept track of using the head element of the list. If+// *the head element of the list is nullptr, then the list is empty.+#ifdef GRPC_LINUX_ERRQUEUE+class TracedBuffer {",I added a traced_buffer_list_test now.,
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/30280,940850231,2022-08-09T03:11:06Z,src/core/lib/event_engine/default_event_engine.h,"@@ -17,16 +17,25 @@  #include <grpc/support/port_platform.h> +#include <memory>+ #include <grpc/event_engine/event_engine.h> +#include ""src/core/lib/promise/context.h""++namespace grpc_core {+template <>","This is probably misplaced, but adding a new header for it seems overkill too. No need to change this unless it triggers a brilliant idea.",
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/30539,941652090,2022-08-09T18:06:36Z,src/core/lib/event_engine/posix_engine/traced_buffer_list.cc,"@@ -0,0 +1,305 @@+// Copyright 2022 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++#include <grpc/support/port_platform.h>++#include ""src/core/lib/event_engine/posix_engine/traced_buffer_list.h""++#include ""absl/functional/any_invocable.h""++#include <grpc/support/log.h>++#include ""src/core/lib/iomgr/port.h""++#ifdef GRPC_LINUX_ERRQUEUE+#include <netinet/in.h>+#include <string.h>+#include <time.h>++namespace grpc_event_engine {+namespace posix_engine {++namespace {+// Fills gpr_timespec gts based on values from timespec ts.+void FillGprFromTimestamp(gpr_timespec* gts, const struct timespec* ts) {+  gts->tv_sec = ts->tv_sec;+  gts->tv_nsec = static_cast<int32_t>(ts->tv_nsec);+  gts->clock_type = GPR_CLOCK_REALTIME;+}++void DefaultTimestampsCallback(void* /*arg*/, Timestamps* /*ts*/,+                               absl::Status /*shudown_err*/) {+  gpr_log(GPR_DEBUG, ""Timestamps callback has not been registered"");+}++// The saved callback function that will be invoked when we get all the+// timestamps that we are going to get for a TracedBuffer.+absl::AnyInvocable<void(void*, Timestamps*, absl::Status)>+    g_timestamps_callback =+        []() -> absl::AnyInvocable<void(void*, Timestamps*, absl::Status)> {+  return DefaultTimestampsCallback;+}();++// Used to extract individual opt stats from cmsg, so as to avoid troubles with+// unaligned reads.+template <typename T>+T ReadUnaligned(const void* ptr) {+  T val;+  memcpy(&val, ptr, sizeof(val));+  return val;+}++// Extracts opt stats from the tcp_info struct \a info to \a metrics+void ExtractOptStatsFromTcpInfo(ConnectionMetrics* metrics,+                                const tcp_info* info) {+  if (info == nullptr) {+    return;+  }+  if (info->length > offsetof(tcp_info, tcpi_sndbuf_limited)) {+    metrics->recurring_retrans.emplace(info->tcpi_retransmits);+    metrics->is_delivery_rate_app_limited.emplace(+        info->tcpi_delivery_rate_app_limited);+    metrics->congestion_window.emplace(info->tcpi_snd_cwnd);+    metrics->reordering.emplace(info->tcpi_reordering);+    metrics->packet_retx.emplace(info->tcpi_total_retrans);+    metrics->pacing_rate.emplace(info->tcpi_pacing_rate);+    metrics->data_notsent.emplace(info->tcpi_notsent_bytes);+    if (info->tcpi_min_rtt != UINT32_MAX) {+      metrics->min_rtt.emplace(info->tcpi_min_rtt);+    }+    metrics->packet_sent.emplace(info->tcpi_data_segs_out);+    metrics->delivery_rate.emplace(info->tcpi_delivery_rate);+    metrics->busy_usec.emplace(info->tcpi_busy_time);+    metrics->rwnd_limited_usec.emplace(info->tcpi_rwnd_limited);+    metrics->sndbuf_limited_usec.emplace(info->tcpi_sndbuf_limited);+  }+  if (info->length > offsetof(tcp_info, tcpi_dsack_dups)) {+    metrics->data_sent.emplace(info->tcpi_bytes_sent);+    metrics->data_retx.emplace(info->tcpi_bytes_retrans);+    metrics->packet_spurious_retx.emplace(info->tcpi_dsack_dups);+  }+}++// Extracts opt stats from the given control message \a opt_stats to the+// connection metrics \a metrics.+void ExtractOptStatsFromCmsg(ConnectionMetrics* metrics,+                             const cmsghdr* opt_stats) {+  if (opt_stats == nullptr) {+    return;+  }+  const auto* data = CMSG_DATA(opt_stats);+  constexpr int64_t cmsg_hdr_len = CMSG_ALIGN(sizeof(struct cmsghdr));+  const int64_t len = opt_stats->cmsg_len - cmsg_hdr_len;+  int64_t offset = 0;++  while (offset < len) {+    const auto* attr = reinterpret_cast<const nlattr*>(data + offset);+    const void* val = data + offset + NLA_HDRLEN;+    switch (attr->nla_type) {+      case TCP_NLA_BUSY: {+        metrics->busy_usec.emplace(ReadUnaligned<uint64_t>(val));+        break;+      }+      case TCP_NLA_RWND_LIMITED: {+        metrics->rwnd_limited_usec.emplace(ReadUnaligned<uint64_t>(val));+        break;+      }+      case TCP_NLA_SNDBUF_LIMITED: {+        metrics->sndbuf_limited_usec.emplace(ReadUnaligned<uint64_t>(val));+        break;+      }+      case TCP_NLA_PACING_RATE: {+        metrics->pacing_rate.emplace(ReadUnaligned<uint64_t>(val));+        break;+      }+      case TCP_NLA_DELIVERY_RATE: {+        metrics->delivery_rate.emplace(ReadUnaligned<uint64_t>(val));+        break;+      }+      case TCP_NLA_DELIVERY_RATE_APP_LMT: {+        metrics->is_delivery_rate_app_limited.emplace(+            ReadUnaligned<uint8_t>(val));+        break;+      }+      case TCP_NLA_SND_CWND: {+        metrics->congestion_window.emplace(ReadUnaligned<uint32_t>(val));+        break;+      }+      case TCP_NLA_MIN_RTT: {+        metrics->min_rtt.emplace(ReadUnaligned<uint32_t>(val));+        break;+      }+      case TCP_NLA_SRTT: {+        metrics->srtt.emplace(ReadUnaligned<uint32_t>(val));+        break;+      }+      case TCP_NLA_RECUR_RETRANS: {+        metrics->recurring_retrans.emplace(ReadUnaligned<uint8_t>(val));+        break;+      }+      case TCP_NLA_BYTES_SENT: {+        metrics->data_sent.emplace(ReadUnaligned<uint64_t>(val));+        break;+      }+      case TCP_NLA_DATA_SEGS_OUT: {+        metrics->packet_sent.emplace(ReadUnaligned<uint64_t>(val));+        break;+      }+      case TCP_NLA_TOTAL_RETRANS: {+        metrics->packet_retx.emplace(ReadUnaligned<uint64_t>(val));+        break;+      }+      case TCP_NLA_DELIVERED: {+        metrics->packet_delivered.emplace(ReadUnaligned<uint32_t>(val));+        break;+      }+      case TCP_NLA_DELIVERED_CE: {+        metrics->packet_delivered_ce.emplace(ReadUnaligned<uint32_t>(val));+        break;+      }+      case TCP_NLA_BYTES_RETRANS: {+        metrics->data_retx.emplace(ReadUnaligned<uint64_t>(val));+        break;+      }+      case TCP_NLA_DSACK_DUPS: {+        metrics->packet_spurious_retx.emplace(ReadUnaligned<uint32_t>(val));+        break;+      }+      case TCP_NLA_REORDERING: {+        metrics->reordering.emplace(ReadUnaligned<uint32_t>(val));+        break;+      }+      case TCP_NLA_SND_SSTHRESH: {+        metrics->snd_ssthresh.emplace(ReadUnaligned<uint32_t>(val));+        break;+      }+    }+    offset += NLA_ALIGN(attr->nla_len);+  }+}++int GetSocketTcpInfo(tcp_info* info, int fd) {+  memset(info, 0, sizeof(*info));+  info->length = offsetof(tcp_info, length);+  return getsockopt(fd, IPPROTO_TCP, TCP_INFO, info, &(info->length));+}+}  // namespace.++void TracedBuffer::AddNewEntry(TracedBuffer** head, uint32_t seq_no, int fd,+                               void* arg) {+  GPR_DEBUG_ASSERT(head != nullptr);+  TracedBuffer* new_elem = new TracedBuffer(seq_no, arg);","This is still a bit C-ish, I think you're missing an opportunity here to do away with leaked internal details via some better type design. Consider something like:```class TracedBufferList { public:  void AddEntry(int32_t seq_no, int fd, void* arg);  void ProcessTimestamp(struct sock_extended_err* serr,                               struct cmsghdr* opt_stats,                               struct scm_timestamping* tss);  Shutdown(); private:  std::list<TracedBuffer> buffer_list;}```There are no more static methods that operate on an object's internals, no more passing around pointers to pointers to heads of lists.",
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/30539,941654410,2022-08-09T18:09:19Z,src/core/lib/event_engine/posix_engine/traced_buffer_list.h,"@@ -0,0 +1,155 @@+// Copyright 2022 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++#ifndef GRPC_CORE_LIB_EVENT_ENGINE_POSIX_ENGINE_TRACED_BUFFER_LIST_H+#define GRPC_CORE_LIB_EVENT_ENGINE_POSIX_ENGINE_TRACED_BUFFER_LIST_H++#include <grpc/support/port_platform.h>++#include ""absl/functional/any_invocable.h""+#include ""absl/status/status.h""+#include ""absl/types/optional.h""++#include <grpc/support/time.h>++#include ""src/core/lib/event_engine/posix_engine/internal_errqueue.h""+#include ""src/core/lib/iomgr/port.h""++namespace grpc_event_engine {+namespace posix_engine {++struct ConnectionMetrics {+  /* Delivery rate in Bytes/s. */+  absl::optional<uint64_t> delivery_rate;","I'm wondering instead if a collection of named metrics would be better. You'd then be able to iterate across key-values, and it'll only contain the data that's actually available.",
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/30539,941686235,2022-08-09T18:38:00Z,src/core/lib/event_engine/posix_engine/traced_buffer_list.cc,"@@ -0,0 +1,289 @@+// Copyright 2022 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++#include <grpc/support/port_platform.h>++#include ""src/core/lib/event_engine/posix_engine/traced_buffer_list.h""++#include <stddef.h>+#include <stdlib.h>++#include <cstdint>+#include <utility>++#include ""absl/functional/any_invocable.h""++#include <grpc/support/log.h>+#include <grpc/support/time.h>++#include ""src/core/lib/iomgr/port.h""++#ifdef GRPC_LINUX_ERRQUEUE++namespace grpc_event_engine {+namespace posix_engine {++namespace {+// Fills gpr_timespec gts based on values from timespec ts.+void FillGprFromTimestamp(gpr_timespec* gts, const struct timespec* ts) {+  gts->tv_sec = ts->tv_sec;+  gts->tv_nsec = static_cast<int32_t>(ts->tv_nsec);+  gts->clock_type = GPR_CLOCK_REALTIME;+}++void DefaultTimestampsCallback(void* /*arg*/, Timestamps* /*ts*/,+                               absl::Status /*shudown_err*/) {+  gpr_log(GPR_DEBUG, ""Timestamps callback has not been registered"");+}++// The saved callback function that will be invoked when we get all the+// timestamps that we are going to get for a TracedBuffer.+absl::AnyInvocable<void(void*, Timestamps*, absl::Status)>+    g_timestamps_callback =+        []() -> absl::AnyInvocable<void(void*, Timestamps*, absl::Status)> {+  return DefaultTimestampsCallback;+}();++// Used to extract individual opt stats from cmsg, so as to avoid troubles with+// unaligned reads.+template <typename T>+T ReadUnaligned(const void* ptr) {+  T val;+  memcpy(&val, ptr, sizeof(val));+  return val;+}++// Extracts opt stats from the tcp_info struct \a info to \a metrics+void ExtractOptStatsFromTcpInfo(ConnectionMetrics* metrics,+                                const tcp_info* info) {+  if (info == nullptr) {+    return;+  }+  if (info->length > offsetof(tcp_info, tcpi_sndbuf_limited)) {+    metrics->recurring_retrans = info->tcpi_retransmits;+    metrics->is_delivery_rate_app_limited =+        info->tcpi_delivery_rate_app_limited;+    metrics->congestion_window = info->tcpi_snd_cwnd;+    metrics->reordering = info->tcpi_reordering;+    metrics->packet_retx = info->tcpi_total_retrans;+    metrics->pacing_rate = info->tcpi_pacing_rate;+    metrics->data_notsent = info->tcpi_notsent_bytes;+    if (info->tcpi_min_rtt != UINT32_MAX) {+      metrics->min_rtt = info->tcpi_min_rtt;+    }+    metrics->packet_sent = info->tcpi_data_segs_out;+    metrics->delivery_rate = info->tcpi_delivery_rate;+    metrics->busy_usec = info->tcpi_busy_time;+    metrics->rwnd_limited_usec = info->tcpi_rwnd_limited;+    metrics->sndbuf_limited_usec = info->tcpi_sndbuf_limited;+  }+  if (info->length > offsetof(tcp_info, tcpi_dsack_dups)) {+    metrics->data_sent = info->tcpi_bytes_sent;+    metrics->data_retx = info->tcpi_bytes_retrans;+    metrics->packet_spurious_retx = info->tcpi_dsack_dups;+  }+}++// Extracts opt stats from the given control message \a opt_stats to the+// connection metrics \a metrics.+void ExtractOptStatsFromCmsg(ConnectionMetrics* metrics,+                             const cmsghdr* opt_stats) {+  if (opt_stats == nullptr) {+    return;+  }+  const auto* data = CMSG_DATA(opt_stats);+  constexpr int64_t cmsg_hdr_len = CMSG_ALIGN(sizeof(struct cmsghdr));+  const int64_t len = opt_stats->cmsg_len - cmsg_hdr_len;+  int64_t offset = 0;++  while (offset < len) {+    const auto* attr = reinterpret_cast<const nlattr*>(data + offset);+    const void* val = data + offset + NLA_HDRLEN;+    switch (attr->nla_type) {+      case TCP_NLA_BUSY: {+        metrics->busy_usec = ReadUnaligned<uint64_t>(val);+        break;+      }+      case TCP_NLA_RWND_LIMITED: {+        metrics->rwnd_limited_usec = ReadUnaligned<uint64_t>(val);+        break;+      }+      case TCP_NLA_SNDBUF_LIMITED: {+        metrics->sndbuf_limited_usec = ReadUnaligned<uint64_t>(val);+        break;+      }+      case TCP_NLA_PACING_RATE: {+        metrics->pacing_rate = ReadUnaligned<uint64_t>(val);+        break;+      }+      case TCP_NLA_DELIVERY_RATE: {+        metrics->delivery_rate = ReadUnaligned<uint64_t>(val);+        break;+      }+      case TCP_NLA_DELIVERY_RATE_APP_LMT: {+        metrics->is_delivery_rate_app_limited = ReadUnaligned<uint8_t>(val);+        break;+      }+      case TCP_NLA_SND_CWND: {+        metrics->congestion_window = ReadUnaligned<uint32_t>(val);+        break;+      }+      case TCP_NLA_MIN_RTT: {+        metrics->min_rtt = ReadUnaligned<uint32_t>(val);+        break;+      }+      case TCP_NLA_SRTT: {+        metrics->srtt = ReadUnaligned<uint32_t>(val);+        break;+      }+      case TCP_NLA_RECUR_RETRANS: {+        metrics->recurring_retrans = ReadUnaligned<uint8_t>(val);+        break;+      }+      case TCP_NLA_BYTES_SENT: {+        metrics->data_sent = ReadUnaligned<uint64_t>(val);+        break;+      }+      case TCP_NLA_DATA_SEGS_OUT: {+        metrics->packet_sent = ReadUnaligned<uint64_t>(val);+        break;+      }+      case TCP_NLA_TOTAL_RETRANS: {+        metrics->packet_retx = ReadUnaligned<uint64_t>(val);+        break;+      }+      case TCP_NLA_DELIVERED: {+        metrics->packet_delivered = ReadUnaligned<uint32_t>(val);+        break;+      }+      case TCP_NLA_DELIVERED_CE: {+        metrics->packet_delivered_ce = ReadUnaligned<uint32_t>(val);+        break;+      }+      case TCP_NLA_BYTES_RETRANS: {+        metrics->data_retx = ReadUnaligned<uint64_t>(val);+        break;+      }+      case TCP_NLA_DSACK_DUPS: {+        metrics->packet_spurious_retx = ReadUnaligned<uint32_t>(val);+        break;+      }+      case TCP_NLA_REORDERING: {+        metrics->reordering = ReadUnaligned<uint32_t>(val);+        break;+      }+      case TCP_NLA_SND_SSTHRESH: {+        metrics->snd_ssthresh = ReadUnaligned<uint32_t>(val);+        break;+      }+    }+    offset += NLA_ALIGN(attr->nla_len);+  }+}+}  // namespace.++void TracedBuffer::AddNewEntry(std::list<TracedBuffer*>& traced_buffers,","This can be a std::forward_list, actually, since it's never going backwards. Saves some memory.And if that type was encapsulated inside a `TraceBufferList` class, you'd have a much smaller set of places where this change would need to be made.",
5564114,Vignesh2208,https://api.github.com/repos/grpc/grpc/pulls/30539,941836779,2022-08-09T21:56:35Z,src/core/lib/event_engine/posix_engine/traced_buffer_list.cc,"@@ -0,0 +1,289 @@+// Copyright 2022 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++#include <grpc/support/port_platform.h>++#include ""src/core/lib/event_engine/posix_engine/traced_buffer_list.h""++#include <stddef.h>+#include <stdlib.h>++#include <cstdint>+#include <utility>++#include ""absl/functional/any_invocable.h""++#include <grpc/support/log.h>+#include <grpc/support/time.h>++#include ""src/core/lib/iomgr/port.h""++#ifdef GRPC_LINUX_ERRQUEUE++namespace grpc_event_engine {+namespace posix_engine {++namespace {+// Fills gpr_timespec gts based on values from timespec ts.+void FillGprFromTimestamp(gpr_timespec* gts, const struct timespec* ts) {+  gts->tv_sec = ts->tv_sec;+  gts->tv_nsec = static_cast<int32_t>(ts->tv_nsec);+  gts->clock_type = GPR_CLOCK_REALTIME;+}++void DefaultTimestampsCallback(void* /*arg*/, Timestamps* /*ts*/,+                               absl::Status /*shudown_err*/) {+  gpr_log(GPR_DEBUG, ""Timestamps callback has not been registered"");+}++// The saved callback function that will be invoked when we get all the+// timestamps that we are going to get for a TracedBuffer.+absl::AnyInvocable<void(void*, Timestamps*, absl::Status)>+    g_timestamps_callback =+        []() -> absl::AnyInvocable<void(void*, Timestamps*, absl::Status)> {+  return DefaultTimestampsCallback;+}();++// Used to extract individual opt stats from cmsg, so as to avoid troubles with+// unaligned reads.+template <typename T>+T ReadUnaligned(const void* ptr) {+  T val;+  memcpy(&val, ptr, sizeof(val));+  return val;+}++// Extracts opt stats from the tcp_info struct \a info to \a metrics+void ExtractOptStatsFromTcpInfo(ConnectionMetrics* metrics,+                                const tcp_info* info) {+  if (info == nullptr) {+    return;+  }+  if (info->length > offsetof(tcp_info, tcpi_sndbuf_limited)) {+    metrics->recurring_retrans = info->tcpi_retransmits;+    metrics->is_delivery_rate_app_limited =+        info->tcpi_delivery_rate_app_limited;+    metrics->congestion_window = info->tcpi_snd_cwnd;+    metrics->reordering = info->tcpi_reordering;+    metrics->packet_retx = info->tcpi_total_retrans;+    metrics->pacing_rate = info->tcpi_pacing_rate;+    metrics->data_notsent = info->tcpi_notsent_bytes;+    if (info->tcpi_min_rtt != UINT32_MAX) {+      metrics->min_rtt = info->tcpi_min_rtt;+    }+    metrics->packet_sent = info->tcpi_data_segs_out;+    metrics->delivery_rate = info->tcpi_delivery_rate;+    metrics->busy_usec = info->tcpi_busy_time;+    metrics->rwnd_limited_usec = info->tcpi_rwnd_limited;+    metrics->sndbuf_limited_usec = info->tcpi_sndbuf_limited;+  }+  if (info->length > offsetof(tcp_info, tcpi_dsack_dups)) {+    metrics->data_sent = info->tcpi_bytes_sent;+    metrics->data_retx = info->tcpi_bytes_retrans;+    metrics->packet_spurious_retx = info->tcpi_dsack_dups;+  }+}++// Extracts opt stats from the given control message \a opt_stats to the+// connection metrics \a metrics.+void ExtractOptStatsFromCmsg(ConnectionMetrics* metrics,+                             const cmsghdr* opt_stats) {+  if (opt_stats == nullptr) {+    return;+  }+  const auto* data = CMSG_DATA(opt_stats);+  constexpr int64_t cmsg_hdr_len = CMSG_ALIGN(sizeof(struct cmsghdr));+  const int64_t len = opt_stats->cmsg_len - cmsg_hdr_len;+  int64_t offset = 0;++  while (offset < len) {+    const auto* attr = reinterpret_cast<const nlattr*>(data + offset);+    const void* val = data + offset + NLA_HDRLEN;+    switch (attr->nla_type) {+      case TCP_NLA_BUSY: {+        metrics->busy_usec = ReadUnaligned<uint64_t>(val);+        break;+      }+      case TCP_NLA_RWND_LIMITED: {+        metrics->rwnd_limited_usec = ReadUnaligned<uint64_t>(val);+        break;+      }+      case TCP_NLA_SNDBUF_LIMITED: {+        metrics->sndbuf_limited_usec = ReadUnaligned<uint64_t>(val);+        break;+      }+      case TCP_NLA_PACING_RATE: {+        metrics->pacing_rate = ReadUnaligned<uint64_t>(val);+        break;+      }+      case TCP_NLA_DELIVERY_RATE: {+        metrics->delivery_rate = ReadUnaligned<uint64_t>(val);+        break;+      }+      case TCP_NLA_DELIVERY_RATE_APP_LMT: {+        metrics->is_delivery_rate_app_limited = ReadUnaligned<uint8_t>(val);+        break;+      }+      case TCP_NLA_SND_CWND: {+        metrics->congestion_window = ReadUnaligned<uint32_t>(val);+        break;+      }+      case TCP_NLA_MIN_RTT: {+        metrics->min_rtt = ReadUnaligned<uint32_t>(val);+        break;+      }+      case TCP_NLA_SRTT: {+        metrics->srtt = ReadUnaligned<uint32_t>(val);+        break;+      }+      case TCP_NLA_RECUR_RETRANS: {+        metrics->recurring_retrans = ReadUnaligned<uint8_t>(val);+        break;+      }+      case TCP_NLA_BYTES_SENT: {+        metrics->data_sent = ReadUnaligned<uint64_t>(val);+        break;+      }+      case TCP_NLA_DATA_SEGS_OUT: {+        metrics->packet_sent = ReadUnaligned<uint64_t>(val);+        break;+      }+      case TCP_NLA_TOTAL_RETRANS: {+        metrics->packet_retx = ReadUnaligned<uint64_t>(val);+        break;+      }+      case TCP_NLA_DELIVERED: {+        metrics->packet_delivered = ReadUnaligned<uint32_t>(val);+        break;+      }+      case TCP_NLA_DELIVERED_CE: {+        metrics->packet_delivered_ce = ReadUnaligned<uint32_t>(val);+        break;+      }+      case TCP_NLA_BYTES_RETRANS: {+        metrics->data_retx = ReadUnaligned<uint64_t>(val);+        break;+      }+      case TCP_NLA_DSACK_DUPS: {+        metrics->packet_spurious_retx = ReadUnaligned<uint32_t>(val);+        break;+      }+      case TCP_NLA_REORDERING: {+        metrics->reordering = ReadUnaligned<uint32_t>(val);+        break;+      }+      case TCP_NLA_SND_SSTHRESH: {+        metrics->snd_ssthresh = ReadUnaligned<uint32_t>(val);+        break;+      }+    }+    offset += NLA_ALIGN(attr->nla_len);+  }+}+}  // namespace.++void TracedBuffer::AddNewEntry(std::list<TracedBuffer*>& traced_buffers,",I don't think it can be forward_list because that type doesn't seem to support a push_back method to append new entries to the back of the list.  We have to do that to ensure sequence numbers are processed from oldest to newest order in ProcessTimestamp.,
5564114,Vignesh2208,https://api.github.com/repos/grpc/grpc/pulls/30539,941844025,2022-08-09T22:09:08Z,src/core/lib/event_engine/posix_engine/traced_buffer_list.cc,"@@ -0,0 +1,289 @@+// Copyright 2022 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++#include <grpc/support/port_platform.h>++#include ""src/core/lib/event_engine/posix_engine/traced_buffer_list.h""++#include <stddef.h>+#include <stdlib.h>++#include <cstdint>+#include <utility>++#include ""absl/functional/any_invocable.h""++#include <grpc/support/log.h>+#include <grpc/support/time.h>++#include ""src/core/lib/iomgr/port.h""++#ifdef GRPC_LINUX_ERRQUEUE++namespace grpc_event_engine {+namespace posix_engine {++namespace {+// Fills gpr_timespec gts based on values from timespec ts.+void FillGprFromTimestamp(gpr_timespec* gts, const struct timespec* ts) {+  gts->tv_sec = ts->tv_sec;+  gts->tv_nsec = static_cast<int32_t>(ts->tv_nsec);+  gts->clock_type = GPR_CLOCK_REALTIME;+}++void DefaultTimestampsCallback(void* /*arg*/, Timestamps* /*ts*/,+                               absl::Status /*shudown_err*/) {+  gpr_log(GPR_DEBUG, ""Timestamps callback has not been registered"");+}++// The saved callback function that will be invoked when we get all the+// timestamps that we are going to get for a TracedBuffer.+absl::AnyInvocable<void(void*, Timestamps*, absl::Status)>+    g_timestamps_callback =+        []() -> absl::AnyInvocable<void(void*, Timestamps*, absl::Status)> {+  return DefaultTimestampsCallback;+}();++// Used to extract individual opt stats from cmsg, so as to avoid troubles with+// unaligned reads.+template <typename T>+T ReadUnaligned(const void* ptr) {+  T val;+  memcpy(&val, ptr, sizeof(val));+  return val;+}++// Extracts opt stats from the tcp_info struct \a info to \a metrics+void ExtractOptStatsFromTcpInfo(ConnectionMetrics* metrics,+                                const tcp_info* info) {+  if (info == nullptr) {+    return;+  }+  if (info->length > offsetof(tcp_info, tcpi_sndbuf_limited)) {+    metrics->recurring_retrans = info->tcpi_retransmits;+    metrics->is_delivery_rate_app_limited =+        info->tcpi_delivery_rate_app_limited;+    metrics->congestion_window = info->tcpi_snd_cwnd;+    metrics->reordering = info->tcpi_reordering;+    metrics->packet_retx = info->tcpi_total_retrans;+    metrics->pacing_rate = info->tcpi_pacing_rate;+    metrics->data_notsent = info->tcpi_notsent_bytes;+    if (info->tcpi_min_rtt != UINT32_MAX) {+      metrics->min_rtt = info->tcpi_min_rtt;+    }+    metrics->packet_sent = info->tcpi_data_segs_out;+    metrics->delivery_rate = info->tcpi_delivery_rate;+    metrics->busy_usec = info->tcpi_busy_time;+    metrics->rwnd_limited_usec = info->tcpi_rwnd_limited;+    metrics->sndbuf_limited_usec = info->tcpi_sndbuf_limited;+  }+  if (info->length > offsetof(tcp_info, tcpi_dsack_dups)) {+    metrics->data_sent = info->tcpi_bytes_sent;+    metrics->data_retx = info->tcpi_bytes_retrans;+    metrics->packet_spurious_retx = info->tcpi_dsack_dups;+  }+}++// Extracts opt stats from the given control message \a opt_stats to the+// connection metrics \a metrics.+void ExtractOptStatsFromCmsg(ConnectionMetrics* metrics,+                             const cmsghdr* opt_stats) {+  if (opt_stats == nullptr) {+    return;+  }+  const auto* data = CMSG_DATA(opt_stats);+  constexpr int64_t cmsg_hdr_len = CMSG_ALIGN(sizeof(struct cmsghdr));+  const int64_t len = opt_stats->cmsg_len - cmsg_hdr_len;+  int64_t offset = 0;++  while (offset < len) {+    const auto* attr = reinterpret_cast<const nlattr*>(data + offset);+    const void* val = data + offset + NLA_HDRLEN;+    switch (attr->nla_type) {+      case TCP_NLA_BUSY: {+        metrics->busy_usec = ReadUnaligned<uint64_t>(val);+        break;+      }+      case TCP_NLA_RWND_LIMITED: {+        metrics->rwnd_limited_usec = ReadUnaligned<uint64_t>(val);+        break;+      }+      case TCP_NLA_SNDBUF_LIMITED: {+        metrics->sndbuf_limited_usec = ReadUnaligned<uint64_t>(val);+        break;+      }+      case TCP_NLA_PACING_RATE: {+        metrics->pacing_rate = ReadUnaligned<uint64_t>(val);+        break;+      }+      case TCP_NLA_DELIVERY_RATE: {+        metrics->delivery_rate = ReadUnaligned<uint64_t>(val);+        break;+      }+      case TCP_NLA_DELIVERY_RATE_APP_LMT: {+        metrics->is_delivery_rate_app_limited = ReadUnaligned<uint8_t>(val);+        break;+      }+      case TCP_NLA_SND_CWND: {+        metrics->congestion_window = ReadUnaligned<uint32_t>(val);+        break;+      }+      case TCP_NLA_MIN_RTT: {+        metrics->min_rtt = ReadUnaligned<uint32_t>(val);+        break;+      }+      case TCP_NLA_SRTT: {+        metrics->srtt = ReadUnaligned<uint32_t>(val);+        break;+      }+      case TCP_NLA_RECUR_RETRANS: {+        metrics->recurring_retrans = ReadUnaligned<uint8_t>(val);+        break;+      }+      case TCP_NLA_BYTES_SENT: {+        metrics->data_sent = ReadUnaligned<uint64_t>(val);+        break;+      }+      case TCP_NLA_DATA_SEGS_OUT: {+        metrics->packet_sent = ReadUnaligned<uint64_t>(val);+        break;+      }+      case TCP_NLA_TOTAL_RETRANS: {+        metrics->packet_retx = ReadUnaligned<uint64_t>(val);+        break;+      }+      case TCP_NLA_DELIVERED: {+        metrics->packet_delivered = ReadUnaligned<uint32_t>(val);+        break;+      }+      case TCP_NLA_DELIVERED_CE: {+        metrics->packet_delivered_ce = ReadUnaligned<uint32_t>(val);+        break;+      }+      case TCP_NLA_BYTES_RETRANS: {+        metrics->data_retx = ReadUnaligned<uint64_t>(val);+        break;+      }+      case TCP_NLA_DSACK_DUPS: {+        metrics->packet_spurious_retx = ReadUnaligned<uint32_t>(val);+        break;+      }+      case TCP_NLA_REORDERING: {+        metrics->reordering = ReadUnaligned<uint32_t>(val);+        break;+      }+      case TCP_NLA_SND_SSTHRESH: {+        metrics->snd_ssthresh = ReadUnaligned<uint32_t>(val);+        break;+      }+    }+    offset += NLA_ALIGN(attr->nla_len);+  }+}+}  // namespace.++void TracedBuffer::AddNewEntry(std::list<TracedBuffer*>& traced_buffers,+                               uint32_t seq_no, int fd, void* arg) {+  TracedBuffer* new_elem = new TracedBuffer(seq_no, arg);+  // Store the current time as the sendmsg time.+  new_elem->ts_.sendmsg_time.time = gpr_now(GPR_CLOCK_REALTIME);+  new_elem->ts_.scheduled_time.time = gpr_inf_past(GPR_CLOCK_REALTIME);+  new_elem->ts_.sent_time.time = gpr_inf_past(GPR_CLOCK_REALTIME);+  new_elem->ts_.acked_time.time = gpr_inf_past(GPR_CLOCK_REALTIME);++  if (GetSocketTcpInfo(&new_elem->ts_.info, fd) == 0) {+    ExtractOptStatsFromTcpInfo(&new_elem->ts_.sendmsg_time.metrics,+                               &new_elem->ts_.info);+  }++  traced_buffers.push_back(new_elem);+}++void TracedBuffer::ProcessTimestamp(std::list<TracedBuffer*>& traced_buffers,+                                    struct sock_extended_err* serr,+                                    struct cmsghdr* opt_stats,+                                    struct scm_timestamping* tss) {+  auto it = traced_buffers.begin();","This is giving a ""Non-const lvalue reference to type '_List_iterator<...>' cannot bind to a temporary of type"" compile time error",
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/30539,942719598,2022-08-10T17:29:44Z,src/core/lib/event_engine/posix_engine/traced_buffer_list.cc,"@@ -0,0 +1,289 @@+// Copyright 2022 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++#include <grpc/support/port_platform.h>++#include ""src/core/lib/event_engine/posix_engine/traced_buffer_list.h""++#include <stddef.h>+#include <stdlib.h>++#include <cstdint>+#include <utility>++#include ""absl/functional/any_invocable.h""++#include <grpc/support/log.h>+#include <grpc/support/time.h>++#include ""src/core/lib/iomgr/port.h""++#ifdef GRPC_LINUX_ERRQUEUE++namespace grpc_event_engine {+namespace posix_engine {++namespace {+// Fills gpr_timespec gts based on values from timespec ts.+void FillGprFromTimestamp(gpr_timespec* gts, const struct timespec* ts) {+  gts->tv_sec = ts->tv_sec;+  gts->tv_nsec = static_cast<int32_t>(ts->tv_nsec);+  gts->clock_type = GPR_CLOCK_REALTIME;+}++void DefaultTimestampsCallback(void* /*arg*/, Timestamps* /*ts*/,+                               absl::Status /*shudown_err*/) {+  gpr_log(GPR_DEBUG, ""Timestamps callback has not been registered"");+}++// The saved callback function that will be invoked when we get all the+// timestamps that we are going to get for a TracedBuffer.+absl::AnyInvocable<void(void*, Timestamps*, absl::Status)>+    g_timestamps_callback =+        []() -> absl::AnyInvocable<void(void*, Timestamps*, absl::Status)> {+  return DefaultTimestampsCallback;+}();++// Used to extract individual opt stats from cmsg, so as to avoid troubles with+// unaligned reads.+template <typename T>+T ReadUnaligned(const void* ptr) {+  T val;+  memcpy(&val, ptr, sizeof(val));+  return val;+}++// Extracts opt stats from the tcp_info struct \a info to \a metrics+void ExtractOptStatsFromTcpInfo(ConnectionMetrics* metrics,+                                const tcp_info* info) {+  if (info == nullptr) {+    return;+  }+  if (info->length > offsetof(tcp_info, tcpi_sndbuf_limited)) {+    metrics->recurring_retrans = info->tcpi_retransmits;+    metrics->is_delivery_rate_app_limited =+        info->tcpi_delivery_rate_app_limited;+    metrics->congestion_window = info->tcpi_snd_cwnd;+    metrics->reordering = info->tcpi_reordering;+    metrics->packet_retx = info->tcpi_total_retrans;+    metrics->pacing_rate = info->tcpi_pacing_rate;+    metrics->data_notsent = info->tcpi_notsent_bytes;+    if (info->tcpi_min_rtt != UINT32_MAX) {+      metrics->min_rtt = info->tcpi_min_rtt;+    }+    metrics->packet_sent = info->tcpi_data_segs_out;+    metrics->delivery_rate = info->tcpi_delivery_rate;+    metrics->busy_usec = info->tcpi_busy_time;+    metrics->rwnd_limited_usec = info->tcpi_rwnd_limited;+    metrics->sndbuf_limited_usec = info->tcpi_sndbuf_limited;+  }+  if (info->length > offsetof(tcp_info, tcpi_dsack_dups)) {+    metrics->data_sent = info->tcpi_bytes_sent;+    metrics->data_retx = info->tcpi_bytes_retrans;+    metrics->packet_spurious_retx = info->tcpi_dsack_dups;+  }+}++// Extracts opt stats from the given control message \a opt_stats to the+// connection metrics \a metrics.+void ExtractOptStatsFromCmsg(ConnectionMetrics* metrics,+                             const cmsghdr* opt_stats) {+  if (opt_stats == nullptr) {+    return;+  }+  const auto* data = CMSG_DATA(opt_stats);+  constexpr int64_t cmsg_hdr_len = CMSG_ALIGN(sizeof(struct cmsghdr));+  const int64_t len = opt_stats->cmsg_len - cmsg_hdr_len;+  int64_t offset = 0;++  while (offset < len) {+    const auto* attr = reinterpret_cast<const nlattr*>(data + offset);+    const void* val = data + offset + NLA_HDRLEN;+    switch (attr->nla_type) {+      case TCP_NLA_BUSY: {+        metrics->busy_usec = ReadUnaligned<uint64_t>(val);+        break;+      }+      case TCP_NLA_RWND_LIMITED: {+        metrics->rwnd_limited_usec = ReadUnaligned<uint64_t>(val);+        break;+      }+      case TCP_NLA_SNDBUF_LIMITED: {+        metrics->sndbuf_limited_usec = ReadUnaligned<uint64_t>(val);+        break;+      }+      case TCP_NLA_PACING_RATE: {+        metrics->pacing_rate = ReadUnaligned<uint64_t>(val);+        break;+      }+      case TCP_NLA_DELIVERY_RATE: {+        metrics->delivery_rate = ReadUnaligned<uint64_t>(val);+        break;+      }+      case TCP_NLA_DELIVERY_RATE_APP_LMT: {+        metrics->is_delivery_rate_app_limited = ReadUnaligned<uint8_t>(val);+        break;+      }+      case TCP_NLA_SND_CWND: {+        metrics->congestion_window = ReadUnaligned<uint32_t>(val);+        break;+      }+      case TCP_NLA_MIN_RTT: {+        metrics->min_rtt = ReadUnaligned<uint32_t>(val);+        break;+      }+      case TCP_NLA_SRTT: {+        metrics->srtt = ReadUnaligned<uint32_t>(val);+        break;+      }+      case TCP_NLA_RECUR_RETRANS: {+        metrics->recurring_retrans = ReadUnaligned<uint8_t>(val);+        break;+      }+      case TCP_NLA_BYTES_SENT: {+        metrics->data_sent = ReadUnaligned<uint64_t>(val);+        break;+      }+      case TCP_NLA_DATA_SEGS_OUT: {+        metrics->packet_sent = ReadUnaligned<uint64_t>(val);+        break;+      }+      case TCP_NLA_TOTAL_RETRANS: {+        metrics->packet_retx = ReadUnaligned<uint64_t>(val);+        break;+      }+      case TCP_NLA_DELIVERED: {+        metrics->packet_delivered = ReadUnaligned<uint32_t>(val);+        break;+      }+      case TCP_NLA_DELIVERED_CE: {+        metrics->packet_delivered_ce = ReadUnaligned<uint32_t>(val);+        break;+      }+      case TCP_NLA_BYTES_RETRANS: {+        metrics->data_retx = ReadUnaligned<uint64_t>(val);+        break;+      }+      case TCP_NLA_DSACK_DUPS: {+        metrics->packet_spurious_retx = ReadUnaligned<uint32_t>(val);+        break;+      }+      case TCP_NLA_REORDERING: {+        metrics->reordering = ReadUnaligned<uint32_t>(val);+        break;+      }+      case TCP_NLA_SND_SSTHRESH: {+        metrics->snd_ssthresh = ReadUnaligned<uint32_t>(val);+        break;+      }+    }+    offset += NLA_ALIGN(attr->nla_len);+  }+}+}  // namespace.++void TracedBuffer::AddNewEntry(std::list<TracedBuffer*>& traced_buffers,","I see, thanks. It's probably worth documenting that the list needs to be processed in a FIFO manner.",
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/30539,942722984,2022-08-10T17:33:43Z,src/core/lib/event_engine/posix_engine/traced_buffer_list.h,"@@ -0,0 +1,179 @@+// Copyright 2022 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++#ifndef GRPC_CORE_LIB_EVENT_ENGINE_POSIX_ENGINE_TRACED_BUFFER_LIST_H+#define GRPC_CORE_LIB_EVENT_ENGINE_POSIX_ENGINE_TRACED_BUFFER_LIST_H++#include <grpc/support/port_platform.h>++#include <stdint.h>++#include <list>++#include ""absl/functional/any_invocable.h""+#include ""absl/status/status.h""+#include ""absl/types/optional.h""++#include <grpc/impl/codegen/gpr_types.h>++#include ""src/core/lib/event_engine/posix_engine/internal_errqueue.h""+#include ""src/core/lib/iomgr/port.h""++#ifdef GRPC_LINUX_ERRQUEUE+#include <linux/errqueue.h>+#include <linux/netlink.h>+#include <netinet/in.h>+#include <string.h>+#include <sys/socket.h>+#include <sys/types.h>+#include <time.h>+#endif /* GRPC_LINUX_ERRQUEUE */++namespace grpc_event_engine {+namespace posix_engine {++struct ConnectionMetrics { /* Delivery rate in Bytes/s. */+  absl::optional<uint64_t> delivery_rate;+  /* If the delivery rate is limited by the application, this is set to true. */+  absl::optional<bool> is_delivery_rate_app_limited;+  /* Total packets retransmitted. */+  absl::optional<uint32_t> packet_retx;+  /* Total packets retransmitted spuriously. This metric is smaller than or+  equal to packet_retx. */+  absl::optional<uint32_t> packet_spurious_retx;+  /* Total packets sent. */+  absl::optional<uint32_t> packet_sent;+  /* Total packets delivered. */+  absl::optional<uint32_t> packet_delivered;+  /* Total packets delivered with ECE marked. This metric is smaller than or+  equal to packet_delivered. */+  absl::optional<uint32_t> packet_delivered_ce;+  /* Total bytes lost so far. */+  absl::optional<uint64_t> data_retx;+  /* Total bytes sent so far. */+  absl::optional<uint64_t> data_sent;+  /* Total bytes in write queue but not sent. */+  absl::optional<uint64_t> data_notsent;+  /* Pacing rate of the connection in Bps */+  absl::optional<uint64_t> pacing_rate;+  /* Minimum RTT observed in usec. */+  absl::optional<uint32_t> min_rtt;+  /* Smoothed RTT in usec */+  absl::optional<uint32_t> srtt;+  /* Send congestion window. */+  absl::optional<uint32_t> congestion_window;+  /* Slow start threshold in packets. */+  absl::optional<uint32_t> snd_ssthresh;+  /* Maximum degree of reordering (i.e., maximum number of packets reodered)+   on the connection. */+  absl::optional<uint32_t> reordering;+  /* Represents the number of recurring retransmissions of the first sequence+  that is not acknowledged yet. */+  absl::optional<uint8_t> recurring_retrans;+  /* The cumulative time (in usec) that the transport protocol was busy+   sending data. */+  absl::optional<uint64_t> busy_usec;+  /* The cumulative time (in usec) that the transport protocol was limited by+   the receive window size. */+  absl::optional<uint64_t> rwnd_limited_usec;+  /* The cumulative time (in usec) that the transport protocol was limited by+   the send buffer size. */+  absl::optional<uint64_t> sndbuf_limited_usec;+};++struct BufferTimestamp {+  gpr_timespec time;+  ConnectionMetrics metrics; /* Metrics collected with this timestamp */+};++struct Timestamps {+  BufferTimestamp sendmsg_time;+  BufferTimestamp scheduled_time;+  BufferTimestamp sent_time;+  BufferTimestamp acked_time;++  uint32_t byte_offset; /* byte offset relative to the start of the RPC */++#ifdef GRPC_LINUX_ERRQUEUE+  tcp_info info; /* tcp_info collected on sendmsg */+#endif           /* GRPC_LINUX_ERRQUEUE */+};++// TracedBuffer is a class to keep track of timestamps for a specific buffer in+// the TCP layer. We are only tracking timestamps for Linux kernels and hence+// this class would only be used by Linux platforms. For all other platforms,+// TracedBuffer would be an empty class.+// The timestamps collected are according to Timestamps declared above A+// TracedBuffer list is kept track of using the head element of the list. If+// *the head element of the list is nullptr, then the list is empty.+#ifdef GRPC_LINUX_ERRQUEUE++class TracedBufferList {+ public:+  // Add a new entry in the TracedBuffer list pointed to by head. Also saves+  // sendmsg_time with the current timestamp.+  void AddNewEntry(int32_t seq_no, int fd, void* arg);+  // Processes a received timestamp based on sock_extended_err and+  // scm_timestamping structures. It will invoke the timestamps callback if the+  // timestamp type is SCM_TSTAMP_ACK.+  void ProcessTimestamp(struct sock_extended_err* serr,+                        struct cmsghdr* opt_stats,+                        struct scm_timestamping* tss);+  int Size() { return buffer_list_.size(); }+  // Cleans the list by calling the callback for each traced buffer in the list+  // with timestamps that it has.+  void Shutdown(void* /*remaining*/, absl::Status /*shutdown_err*/);++ private:+  class TracedBuffer {+   public:+    TracedBuffer(uint32_t seq_no, void* arg) : seq_no_(seq_no), arg_(arg) {}++   private:+    friend class TracedBufferList;+    uint32_t seq_no_; /* The sequence number for the last byte in the buffer */+    void* arg_;       /* The arg to pass to timestamps_callback */+    Timestamps ts_;   /* The timestamps corresponding to this buffer */+  };+  std::list<TracedBuffer*> buffer_list_;+};++#else  /* GRPC_LINUX_ERRQUEUE */+class TracedBufferList {+ public:+  // Add a new entry in the TracedBuffer list pointed to by head. Also saves","nit: these comments don't describe this class's operations. Would suggest removing them all from this no-op class, documenting that it's no-op, and leaving the comments on the supported implementation.",X
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/30539,942724895,2022-08-10T17:35:52Z,src/core/lib/event_engine/posix_engine/traced_buffer_list.h,"@@ -0,0 +1,155 @@+// Copyright 2022 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++#ifndef GRPC_CORE_LIB_EVENT_ENGINE_POSIX_ENGINE_TRACED_BUFFER_LIST_H+#define GRPC_CORE_LIB_EVENT_ENGINE_POSIX_ENGINE_TRACED_BUFFER_LIST_H++#include <grpc/support/port_platform.h>++#include ""absl/functional/any_invocable.h""+#include ""absl/status/status.h""+#include ""absl/types/optional.h""++#include <grpc/support/time.h>++#include ""src/core/lib/event_engine/posix_engine/internal_errqueue.h""+#include ""src/core/lib/iomgr/port.h""++namespace grpc_event_engine {+namespace posix_engine {++struct ConnectionMetrics {+  /* Delivery rate in Bytes/s. */+  absl::optional<uint64_t> delivery_rate;","As discussed offline, this is fine as is. Keys could be enum classes to save some space, but I'm happy to not bikeshed this any further.",
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/30539,942728874,2022-08-10T17:40:39Z,src/core/lib/event_engine/posix_engine/traced_buffer_list.cc,"@@ -0,0 +1,289 @@+// Copyright 2022 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++#include <grpc/support/port_platform.h>++#include ""src/core/lib/event_engine/posix_engine/traced_buffer_list.h""++#include <linux/errqueue.h>+#include <linux/netlink.h>+#include <stddef.h>+#include <stdlib.h>+#include <string.h>+#include <sys/socket.h>+#include <time.h>++#include <utility>++#include ""absl/functional/any_invocable.h""++#include <grpc/support/log.h>+#include <grpc/support/time.h>++#include ""src/core/lib/iomgr/port.h""++#ifdef GRPC_LINUX_ERRQUEUE++namespace grpc_event_engine {+namespace posix_engine {++namespace {+// Fills gpr_timespec gts based on values from timespec ts.+void FillGprFromTimestamp(gpr_timespec* gts, const struct timespec* ts) {+  gts->tv_sec = ts->tv_sec;+  gts->tv_nsec = static_cast<int32_t>(ts->tv_nsec);+  gts->clock_type = GPR_CLOCK_REALTIME;+}++void DefaultTimestampsCallback(void* /*arg*/, Timestamps* /*ts*/,+                               absl::Status /*shudown_err*/) {+  gpr_log(GPR_DEBUG, ""Timestamps callback has not been registered"");+}++// The saved callback function that will be invoked when we get all the+// timestamps that we are going to get for a TracedBuffer.+absl::AnyInvocable<void(void*, Timestamps*, absl::Status)>+    g_timestamps_callback =+        []() -> absl::AnyInvocable<void(void*, Timestamps*, absl::Status)> {+  return DefaultTimestampsCallback;+}();++// Used to extract individual opt stats from cmsg, so as to avoid troubles with+// unaligned reads.+template <typename T>+T ReadUnaligned(const void* ptr) {+  T val;+  memcpy(&val, ptr, sizeof(val));+  return val;+}++// Extracts opt stats from the tcp_info struct \a info to \a metrics+void ExtractOptStatsFromTcpInfo(ConnectionMetrics* metrics,+                                const tcp_info* info) {+  if (info == nullptr) {+    return;+  }+  if (info->length > offsetof(tcp_info, tcpi_sndbuf_limited)) {+    metrics->recurring_retrans = info->tcpi_retransmits;+    metrics->is_delivery_rate_app_limited =+        info->tcpi_delivery_rate_app_limited;+    metrics->congestion_window = info->tcpi_snd_cwnd;+    metrics->reordering = info->tcpi_reordering;+    metrics->packet_retx = info->tcpi_total_retrans;+    metrics->pacing_rate = info->tcpi_pacing_rate;+    metrics->data_notsent = info->tcpi_notsent_bytes;+    if (info->tcpi_min_rtt != UINT32_MAX) {+      metrics->min_rtt = info->tcpi_min_rtt;+    }+    metrics->packet_sent = info->tcpi_data_segs_out;+    metrics->delivery_rate = info->tcpi_delivery_rate;+    metrics->busy_usec = info->tcpi_busy_time;+    metrics->rwnd_limited_usec = info->tcpi_rwnd_limited;+    metrics->sndbuf_limited_usec = info->tcpi_sndbuf_limited;+  }+  if (info->length > offsetof(tcp_info, tcpi_dsack_dups)) {+    metrics->data_sent = info->tcpi_bytes_sent;+    metrics->data_retx = info->tcpi_bytes_retrans;+    metrics->packet_spurious_retx = info->tcpi_dsack_dups;+  }+}++// Extracts opt stats from the given control message \a opt_stats to the+// connection metrics \a metrics.+void ExtractOptStatsFromCmsg(ConnectionMetrics* metrics,+                             const cmsghdr* opt_stats) {+  if (opt_stats == nullptr) {+    return;+  }+  const auto* data = CMSG_DATA(opt_stats);+  constexpr int64_t cmsg_hdr_len = CMSG_ALIGN(sizeof(struct cmsghdr));+  const int64_t len = opt_stats->cmsg_len - cmsg_hdr_len;+  int64_t offset = 0;++  while (offset < len) {+    const auto* attr = reinterpret_cast<const nlattr*>(data + offset);+    const void* val = data + offset + NLA_HDRLEN;+    switch (attr->nla_type) {+      case TCP_NLA_BUSY: {+        metrics->busy_usec = ReadUnaligned<uint64_t>(val);+        break;+      }+      case TCP_NLA_RWND_LIMITED: {+        metrics->rwnd_limited_usec = ReadUnaligned<uint64_t>(val);+        break;+      }+      case TCP_NLA_SNDBUF_LIMITED: {+        metrics->sndbuf_limited_usec = ReadUnaligned<uint64_t>(val);+        break;+      }+      case TCP_NLA_PACING_RATE: {+        metrics->pacing_rate = ReadUnaligned<uint64_t>(val);+        break;+      }+      case TCP_NLA_DELIVERY_RATE: {+        metrics->delivery_rate = ReadUnaligned<uint64_t>(val);+        break;+      }+      case TCP_NLA_DELIVERY_RATE_APP_LMT: {+        metrics->is_delivery_rate_app_limited = ReadUnaligned<uint8_t>(val);+        break;+      }+      case TCP_NLA_SND_CWND: {+        metrics->congestion_window = ReadUnaligned<uint32_t>(val);+        break;+      }+      case TCP_NLA_MIN_RTT: {+        metrics->min_rtt = ReadUnaligned<uint32_t>(val);+        break;+      }+      case TCP_NLA_SRTT: {+        metrics->srtt = ReadUnaligned<uint32_t>(val);+        break;+      }+      case TCP_NLA_RECUR_RETRANS: {+        metrics->recurring_retrans = ReadUnaligned<uint8_t>(val);+        break;+      }+      case TCP_NLA_BYTES_SENT: {+        metrics->data_sent = ReadUnaligned<uint64_t>(val);+        break;+      }+      case TCP_NLA_DATA_SEGS_OUT: {+        metrics->packet_sent = ReadUnaligned<uint64_t>(val);+        break;+      }+      case TCP_NLA_TOTAL_RETRANS: {+        metrics->packet_retx = ReadUnaligned<uint64_t>(val);+        break;+      }+      case TCP_NLA_DELIVERED: {+        metrics->packet_delivered = ReadUnaligned<uint32_t>(val);+        break;+      }+      case TCP_NLA_DELIVERED_CE: {+        metrics->packet_delivered_ce = ReadUnaligned<uint32_t>(val);+        break;+      }+      case TCP_NLA_BYTES_RETRANS: {+        metrics->data_retx = ReadUnaligned<uint64_t>(val);+        break;+      }+      case TCP_NLA_DSACK_DUPS: {+        metrics->packet_spurious_retx = ReadUnaligned<uint32_t>(val);+        break;+      }+      case TCP_NLA_REORDERING: {+        metrics->reordering = ReadUnaligned<uint32_t>(val);+        break;+      }+      case TCP_NLA_SND_SSTHRESH: {+        metrics->snd_ssthresh = ReadUnaligned<uint32_t>(val);+        break;+      }+    }+    offset += NLA_ALIGN(attr->nla_len);+  }+}+}  // namespace.++void TracedBufferList::AddNewEntry(int32_t seq_no, int fd, void* arg) {+  TracedBuffer* new_elem = new TracedBuffer(seq_no, arg);","nit: you can let the list manage the lifetimes by using a `std::list<TracedBuffer>` (non-pointer). `list::emplace` uses placement-new under the hood, and it would allow us to avoid having to call `delete` manually (and avoid us having to debug leaks when we failed to do so).",
527862,zyxue,https://api.github.com/repos/grpc/grpc/pulls/28567,943922084,2022-08-11T20:40:19Z,doc/fork_support.md,"@@ -1,46 +1,39 @@-# Background #--In Python, multithreading is ineffective at concurrency for CPU bound tasks-due to the GIL (global interpreter lock).  Extension modules can release-the GIL in CPU bound tasks, but that isn't an option in pure Python.-Users use libraries such as multiprocessing, subprocess, concurrent.futures.ProcessPoolExecutor,-etc, to work around the GIL. These modules call ```fork()``` underneath the hood. Various issues have-been reported when using these modules with gRPC Python.  gRPC Python wraps-gRPC core, which uses multithreading for performance, and hence doesn't support ```fork()```.-Historically, we didn't support forking in gRPC, but some users seemed-to be doing fine until their code started to break on version 1.6.  This was-likely caused by the addition of background c-threads and a background-Python thread.--# Current Status #--## 1.11 ##-The background Python thread was removed entirely.  This allows forking-after creating a channel.  However, the channel must not have issued any-RPCs prior to the fork.  Attempting to fork with an active channel that-has been used can result in deadlocks/corrupted wire data.--## 1.9 ##-A regression was noted in cases where users are doing fork/exec. This-was due to ```pthread_atfork()``` handler that was added in 1.7 to partially-support forking in gRPC. A deadlock can happen when pthread_atfork-handler is running, and an application thread is calling into gRPC.-We have provided a workaround for this issue by allowing users to turn-off the handler using env flag ```GRPC_ENABLE_FORK_SUPPORT=False```.-This should be set whenever a user expects to always call exec-immediately following fork.  It will disable the fork handlers.--## 1.7 ##-A ```pthread_atfork()``` handler was added in 1.7 to automatically shut down-the background c-threads when fork was called.  This does not shut down the-background Python thread, so users could not have any open channels when-forking.--# Future Work #--## 1.13 ##-The workaround when using fork/exec by setting-```GRPC_ENABLE_FORK_SUPPORT=False``` should no longer be needed.  Following-[this PR](https://github.com/grpc/grpc/pull/14647), fork-handlers will not automatically run when multiple threads are calling-into gRPC.+# Background++In Python, multithreading is ineffective at concurrency for CPU bound tasks due+to the GIL (global interpreter lock).  Extension modules can release the GIL in+CPU bound tasks, but that isn't an option in pure Python. Users use libraries+such as multiprocessing, subprocess, concurrent.futures.ProcessPoolExecutor,+etc, to work around the GIL. These modules call `fork()` underneath the hood.+Various issues have been reported when using these modules with gRPC Python.+gRPC Python wraps gRPC core, which uses multithreading for performance, and+hence doesn't support `fork()`. Historically, we didn't support forking in gRPC,+but some users seemed to be doing fine until their code started to break on+version 1.6.  This was likely caused by the addition of background c-threads and+a background Python thread.++# Current Status++gRPC Python applications can enable client-side forking when two environment+variables are given:++```+export GRPC_ENABLE_FORK_SUPPORT=true+export GRPC_POLL_STRATEGY=poll+```++The fork-support effort only works with ""epoll1"" and ""poll"" polling strategy.",is `epoll1` a typo?https://github.com/grpc/grpc/blob/master/doc/environment_variables.md says it's `epoll` instead.> `epoll (linux-only) - a polling engine based around the epoll family of system calls`,
7394928,lidizheng,https://api.github.com/repos/grpc/grpc/pulls/28567,943929647,2022-08-11T20:51:15Z,doc/fork_support.md,"@@ -1,46 +1,39 @@-# Background #--In Python, multithreading is ineffective at concurrency for CPU bound tasks-due to the GIL (global interpreter lock).  Extension modules can release-the GIL in CPU bound tasks, but that isn't an option in pure Python.-Users use libraries such as multiprocessing, subprocess, concurrent.futures.ProcessPoolExecutor,-etc, to work around the GIL. These modules call ```fork()``` underneath the hood. Various issues have-been reported when using these modules with gRPC Python.  gRPC Python wraps-gRPC core, which uses multithreading for performance, and hence doesn't support ```fork()```.-Historically, we didn't support forking in gRPC, but some users seemed-to be doing fine until their code started to break on version 1.6.  This was-likely caused by the addition of background c-threads and a background-Python thread.--# Current Status #--## 1.11 ##-The background Python thread was removed entirely.  This allows forking-after creating a channel.  However, the channel must not have issued any-RPCs prior to the fork.  Attempting to fork with an active channel that-has been used can result in deadlocks/corrupted wire data.--## 1.9 ##-A regression was noted in cases where users are doing fork/exec. This-was due to ```pthread_atfork()``` handler that was added in 1.7 to partially-support forking in gRPC. A deadlock can happen when pthread_atfork-handler is running, and an application thread is calling into gRPC.-We have provided a workaround for this issue by allowing users to turn-off the handler using env flag ```GRPC_ENABLE_FORK_SUPPORT=False```.-This should be set whenever a user expects to always call exec-immediately following fork.  It will disable the fork handlers.--## 1.7 ##-A ```pthread_atfork()``` handler was added in 1.7 to automatically shut down-the background c-threads when fork was called.  This does not shut down the-background Python thread, so users could not have any open channels when-forking.--# Future Work #--## 1.13 ##-The workaround when using fork/exec by setting-```GRPC_ENABLE_FORK_SUPPORT=False``` should no longer be needed.  Following-[this PR](https://github.com/grpc/grpc/pull/14647), fork-handlers will not automatically run when multiple threads are calling-into gRPC.+# Background++In Python, multithreading is ineffective at concurrency for CPU bound tasks due+to the GIL (global interpreter lock).  Extension modules can release the GIL in+CPU bound tasks, but that isn't an option in pure Python. Users use libraries+such as multiprocessing, subprocess, concurrent.futures.ProcessPoolExecutor,+etc, to work around the GIL. These modules call `fork()` underneath the hood.+Various issues have been reported when using these modules with gRPC Python.+gRPC Python wraps gRPC core, which uses multithreading for performance, and+hence doesn't support `fork()`. Historically, we didn't support forking in gRPC,+but some users seemed to be doing fine until their code started to break on+version 1.6.  This was likely caused by the addition of background c-threads and+a background Python thread.++# Current Status++gRPC Python applications can enable client-side forking when two environment+variables are given:++```+export GRPC_ENABLE_FORK_SUPPORT=true+export GRPC_POLL_STRATEGY=poll+```++The fork-support effort only works with ""epoll1"" and ""poll"" polling strategy.","This is intended. For actual selections of supported polling engines, see https://github.com/grpc/grpc/blob/master/doc/core/grpc-polling-engines.md.",
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/30561,944029213,2022-08-12T00:15:38Z,src/core/lib/promise/activity.h,"@@ -85,19 +97,50 @@ class Waker {   }   private:-  struct Unwakeable final : public Wakeable {-    void Wakeup() override {}-    void Drop() override {}-  };-  static Unwakeable* unwakeable() {-    return NoDestructSingleton<Unwakeable>::Get();-  }+  friend class AtomicWaker; -  Wakeable* Take() { return absl::exchange(wakeable_, unwakeable()); }+  Wakeable* Take() {+    return absl::exchange(wakeable_, activity_detail::unwakeable());+  }    Wakeable* wakeable_; }; +// An atomic variant of Waker - this type is non-copyable and non-movable.+class AtomicWaker {+ public:+  explicit AtomicWaker(Wakeable* wakeable) : wakeable_(wakeable) {}+  AtomicWaker() : AtomicWaker(activity_detail::unwakeable()) {}+  explicit AtomicWaker(Waker waker) : AtomicWaker(waker.Take()) {}+  ~AtomicWaker() { wakeable_.load(std::memory_order_relaxed)->Drop(); }+  AtomicWaker(const AtomicWaker&) = delete;+  AtomicWaker& operator=(const AtomicWaker&) = delete;+  AtomicWaker(AtomicWaker&& other) noexcept = delete;+  AtomicWaker& operator=(AtomicWaker&& other) noexcept = delete;++  // Wake the underlying activity.+  void Wakeup() { Take()->Wakeup(); }++  // Return true if there is a not-unwakeable wakeable present.+  bool Armed() const noexcept {+    return wakeable_.load(std::memory_order_relaxed) !=+           activity_detail::unwakeable();+  }++  // Set to some new waker+  void Set(Waker waker) {+    wakeable_.exchange(waker.Take(), std::memory_order_relaxed)->Drop();","Should there be any preconditions asserted on what sort of waker is being overwritten? For example, if a caller expects it to be in an unwakeable state, but there's a race for setting the value, this method could overwrite some other thread's waker that was set just beforehand.",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/30561,944129663,2022-08-12T05:41:46Z,test/core/promise/activity_test.cc,"@@ -321,6 +325,73 @@ TEST(WakerTest, CanWakeupEmptyWaker) {   Waker().Wakeup(); } +TEST(AtomicWakerTest, CanWakeupEmptyWaker) {+  // Empty wakers should not do anything upon wakeup.+  AtomicWaker waker;+  EXPECT_FALSE(waker.Armed());+  waker.Wakeup();+}++TEST(AtomicWakerTest, ThreadStress) {+  AtomicWaker waker;+  std::vector<std::thread> threads;+  std::atomic<bool> done{false};+  std::atomic<int> wakeups{0};+  std::atomic<int> drops{0};+  std::atomic<int> armed{0};+  std::atomic<int> not_armed{0};++  threads.reserve(90);+  for (int i = 0; i < 30; i++) {+    threads.emplace_back([&] {+      while (!done.load(std::memory_order_relaxed)) {+        waker.Wakeup();+      }+    });+  }+  for (int i = 0; i < 30; i++) {+    threads.emplace_back([&] {+      while (!done.load(std::memory_order_relaxed)) {+        class TestWakeable final : public Wakeable {+         public:+          TestWakeable(std::atomic<int>* wakeups, std::atomic<int>* drops)+              : wakeups_(wakeups), drops_(drops) {}+          void Wakeup() override {+            wakeups_->fetch_add(1, std::memory_order_relaxed);+            delete this;+          }+          void Drop() override {+            drops_->fetch_add(1, std::memory_order_relaxed);+            delete this;+          }++         private:+          std::atomic<int>* const wakeups_;+          std::atomic<int>* const drops_;+        };+        waker.Set(Waker(new TestWakeable(&wakeups, &drops)));+      }+    });+  }+  for (int i = 0; i < 30; i++) {+    threads.emplace_back([&] {+      while (!done.load(std::memory_order_relaxed)) {+        (waker.Armed() ? &armed : &not_armed)+            ->fetch_add(1, std::memory_order_relaxed);+      }+    });+  }++  do {+    std::this_thread::sleep_for(std::chrono::seconds(1));","yeah, most runs I expect one iteration here... if it takes longer it's not *bad* it's just weird CI load... if it takes forever (i.e. times out) it's broken.",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/30561,944130674,2022-08-12T05:44:21Z,src/core/lib/promise/activity.h,"@@ -85,19 +97,50 @@ class Waker {   }   private:-  struct Unwakeable final : public Wakeable {-    void Wakeup() override {}-    void Drop() override {}-  };-  static Unwakeable* unwakeable() {-    return NoDestructSingleton<Unwakeable>::Get();-  }+  friend class AtomicWaker; -  Wakeable* Take() { return absl::exchange(wakeable_, unwakeable()); }+  Wakeable* Take() {+    return absl::exchange(wakeable_, activity_detail::unwakeable());+  }    Wakeable* wakeable_; }; +// An atomic variant of Waker - this type is non-copyable and non-movable.+class AtomicWaker {+ public:+  explicit AtomicWaker(Wakeable* wakeable) : wakeable_(wakeable) {}+  AtomicWaker() : AtomicWaker(activity_detail::unwakeable()) {}+  explicit AtomicWaker(Waker waker) : AtomicWaker(waker.Take()) {}+  ~AtomicWaker() { wakeable_.load(std::memory_order_relaxed)->Drop(); }+  AtomicWaker(const AtomicWaker&) = delete;+  AtomicWaker& operator=(const AtomicWaker&) = delete;+  AtomicWaker(AtomicWaker&& other) noexcept = delete;+  AtomicWaker& operator=(AtomicWaker&& other) noexcept = delete;++  // Wake the underlying activity.+  void Wakeup() { Take()->Wakeup(); }++  // Return true if there is a not-unwakeable wakeable present.+  bool Armed() const noexcept {+    return wakeable_.load(std::memory_order_relaxed) !=+           activity_detail::unwakeable();+  }++  // Set to some new waker+  void Set(Waker waker) {+    wakeable_.exchange(waker.Take(), std::memory_order_relaxed)->Drop();","I think I need some more experience with this before deciding what's good or bad there... but we should actually be defaulting to Wakeup here just in case, so fixed that.",
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/30561,944568152,2022-08-12T15:15:43Z,test/core/promise/activity_test.cc,"@@ -321,6 +325,73 @@ TEST(WakerTest, CanWakeupEmptyWaker) {   Waker().Wakeup(); } +TEST(AtomicWakerTest, CanWakeupEmptyWaker) {+  // Empty wakers should not do anything upon wakeup.+  AtomicWaker waker;+  EXPECT_FALSE(waker.Armed());+  waker.Wakeup();+}++TEST(AtomicWakerTest, ThreadStress) {+  AtomicWaker waker;+  std::vector<std::thread> threads;+  std::atomic<bool> done{false};+  std::atomic<int> wakeups{0};+  std::atomic<int> drops{0};+  std::atomic<int> armed{0};+  std::atomic<int> not_armed{0};++  threads.reserve(90);+  for (int i = 0; i < 30; i++) {+    threads.emplace_back([&] {+      while (!done.load(std::memory_order_relaxed)) {+        waker.Wakeup();+      }+    });+  }+  for (int i = 0; i < 30; i++) {+    threads.emplace_back([&] {+      while (!done.load(std::memory_order_relaxed)) {+        class TestWakeable final : public Wakeable {+         public:+          TestWakeable(std::atomic<int>* wakeups, std::atomic<int>* drops)+              : wakeups_(wakeups), drops_(drops) {}+          void Wakeup() override {+            wakeups_->fetch_add(1, std::memory_order_relaxed);+            delete this;+          }+          void Drop() override {+            drops_->fetch_add(1, std::memory_order_relaxed);+            delete this;+          }++         private:+          std::atomic<int>* const wakeups_;+          std::atomic<int>* const drops_;+        };+        waker.Set(Waker(new TestWakeable(&wakeups, &drops)));+      }+    });+  }+  for (int i = 0; i < 30; i++) {+    threads.emplace_back([&] {+      while (!done.load(std::memory_order_relaxed)) {+        (waker.Armed() ? &armed : &not_armed)+            ->fetch_add(1, std::memory_order_relaxed);+      }+    });+  }++  do {+    std::this_thread::sleep_for(std::chrono::seconds(1));","Since this test could sleep ~indefinitely under a broken implementation, how about setting an overall deadline at 5s then? If it is broken, I think the usual timeout for medium sized tests is 5 minutes.",
11522026,ralphchung,https://api.github.com/repos/grpc/grpc/pulls/30570,944689454,2022-08-12T17:57:01Z,BUILD,"@@ -468,7 +474,6 @@ grpc_cc_library(             ""//conditions:default"": GRPC_XDS_TARGETS,         },     ],-    standalone = True,",Nothing.I found the parameter is unused in both Github and google3.https://github.com/grpc/grpc/blob/master/bazel/grpc_build_system.bzl#L145https://source.corp.google.com/piper///depot/google3/third_party/grpc/bazel/grpc_build_system.bzl;l=657,
933495,dennycd,https://api.github.com/repos/grpc/grpc/pulls/30439,944817376,2022-08-12T20:23:33Z,src/objective-c/tests/BUILD,"@@ -220,6 +242,13 @@ ios_unit_test(     ], ) +grpc_objc_ios_unit_test(+    name = ""CronetTests"",",https://github.com/grpc/grpc/blob/009dadbb743f4575b60997fb723919eba0bcb00a/src/objective-c/tests/Podfile#L44,
14166415,sanjaypujare,https://api.github.com/repos/grpc/grpc/pulls/30571,944865200,2022-08-12T21:18:38Z,BUILD,"@@ -7247,6 +7247,28 @@ grpc_cc_library(     ], ) +# This is an EXPERIMENTAL target subject to change.+grpc_cc_library(+    name = ""grpcpp_opencensus_gcp_observability_plugin"",",I know we have called this observability code as plugin in various places but it is not really based on any plugin arch nor is it pluggable AFAICS. Again the name as opencensus in it whereas I thought we are going to hide that,X
14166415,sanjaypujare,https://api.github.com/repos/grpc/grpc/pulls/30571,944870272,2022-08-12T21:25:59Z,BUILD,"@@ -7247,6 +7247,28 @@ grpc_cc_library(     ], ) +# This is an EXPERIMENTAL target subject to change.+grpc_cc_library(+    name = ""grpcpp_opencensus_gcp_observability_plugin"",","As discussed offline: the goal of observability is to hide opencensus (or OTel in future) as implementation details but the C++ app developer is only aware of the grpc observability API.  So the name (in my opinion) should be `""grpcpp_gcp_observability_plugin""`",X
10396166,DNVindhya,https://api.github.com/repos/grpc/grpc/pulls/30571,945968743,2022-08-15T17:24:46Z,src/cpp/ext/gcp_observability/gcp_observability.cc,"@@ -0,0 +1,65 @@+//+// Copyright 2022 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+//++#include <grpc/support/port_platform.h>++#include ""src/cpp/ext/gcp_observability/gcp_observability.h""++#include <stdint.h>++#include <utility>++#include ""opencensus/exporters/stats/stackdriver/stackdriver_exporter.h""+#include ""opencensus/exporters/trace/stackdriver/stackdriver_exporter.h""+#include ""opencensus/trace/sampler.h""+#include ""opencensus/trace/trace_config.h""++#include <grpcpp/opencensus.h>++namespace grpc {+namespace experimental {++namespace {+// TODO(yashykt): These constants are currently derived from the example at+// https://cloud.google.com/traffic-director/docs/observability-proxyless#c++.+// We might want these to be configurable.","Yes, in Java we only configure the trace sampler based on Observability Config and for rest we use [default](https://github.com/census-instrumentation/opencensus-java/blob/master/api/src/main/java/io/opencensus/trace/config/TraceParams.java#L50) values.",
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/30590,946233077,2022-08-16T00:05:46Z,test/core/end2end/tests/connectivity.cc,"@@ -65,14 +66,18 @@ static void test_connectivity(grpc_end2end_test_config config) {   grpc_core::CqVerifier cqv(f.cq);   child_events ce; -  grpc_channel_args client_args;-  grpc_arg arg_array[1];+  grpc_arg arg_array[] = {+      grpc_channel_arg_integer_create(+          const_cast<char*>(GRPC_ARG_INITIAL_RECONNECT_BACKOFF_MS), 1000),+      grpc_channel_arg_integer_create(+          const_cast<char*>(GRPC_ARG_MAX_RECONNECT_BACKOFF_MS), 1000),+      grpc_channel_arg_integer_create(+          const_cast<char*>(GRPC_ARG_MIN_RECONNECT_BACKOFF_MS), 5000)};   arg_array[0].type = GRPC_ARG_INTEGER;",This overwrites the first value in the fixed list.,
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/30429,946508017,2022-08-16T08:53:29Z,src/csharp/Grpc.Core/Internal/AsyncCall.cs,"@@ -122,6 +122,9 @@ public TResponse UnaryCall(TRequest msg)                             catch (Exception e)                             {                                 Logger.Error(e, ""Exception occurred while invoking completion delegate."");+                                unaryResponseTcs.SetException(new RpcException(","I think there are problems with this fix:-  since in https://github.com/grpc/grpc/issues/29854, ctx.GetReceivedStatusOnClient() throws an exception, the `HandleUnaryResponse()` (which is responsible for cleaning up after the call) never gets invoked, so there is high likelyhood that the call won't get cleaned up properly and it will leak.- in principle, if the message detail in GetReceivedStatusOnClient can get corrupt (and stop being unmarshallable as UTF-8),  the exact same thing can likely happen for other call types than just syncUnary (e.g. async Unary and potentially some of the streaming ones as well). Rather than fixing the same problem in multiple places, it would be better to make sure we understand why exactly does `ctx.GetReceivedStatusOnClient()` fail and whether that's caused by a bug in C-core or not.",
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/30290,946541236,2022-08-16T09:26:56Z,src/csharp/Grpc.Core/Internal/AsyncCallBase.cs,"@@ -154,6 +154,22 @@ protected Task<TRead> ReadMessageInternalAsync()                     return streamingReadTcs.Task;                 } +                if (IsInErrorStateClientOnly)+                {+                    // The gRPC call has already failed with an error, so return that error in+                    // any subsequent MoveNext attempts.+                    // Without this check an InvalidOperationException would have been thrown+                    // instead of the expected RcpException.++                    if (streamingReadTcs == null)+                    {+                        streamingReadTcs = new TaskCompletionSource<TRead>();+                        streamingReadTcs.SetException(GetRpcExceptionClientOnly());","why ""GetRpcExceptionClientOnly()""?There seems to be no reason to throw RpcException from ReadMessageInternalAsync() -to emulate the end of reponse stream on a client after you've disposed the call's resources,you can simply make sure the streamingReadTcs returns a task of null. (this will indicate that the stream has ended and the exception from finishedStatus will be thrown by this snippethttps://github.com/grpc/grpc/blob/c34b22eda3e5770f6dc970885feaa9d06eae5d76/src/csharp/Grpc.Core/Internal/ClientResponseStream.cs#L57You just need to make sure that after you've disposed the call ""early"" (after seeing a non-ok status), there will be no more reads started.",
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/30575,946995042,2022-08-16T16:22:51Z,test/core/promise/activity_test.cc,"@@ -360,25 +360,28 @@ TEST(AtomicWakerTest, ThreadStress) {   AtomicWaker waker;    threads.reserve(90);-  for (int i = 0; i < 30; i++) {+  for (int i = 0; i < 5; i++) {     threads.emplace_back([&] {       while (!done.load(std::memory_order_relaxed)) {         waker.Wakeup();+        std::this_thread::sleep_for(std::chrono::milliseconds(1));","My main concerns is if this indicates we're going to need similar hacks in production code. The activity_test is timing out on Windows, so adding a sleep to every thread seems like maybe this test is now hacking around a race in production code? https://source.cloud.google.com/results/invocations/f3604bbf-18b8-47c9-b758-e425a9b7e62c/targets/%2F%2Ftest%2Fcore%2Fpromise:activity_test/log",
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/30405,947859019,2022-08-17T12:18:47Z,src/csharp/BUILD-INTEGRATION.md,"@@ -91,6 +91,14 @@ button](https://stackoverflow.com/a/9770061). Click on it, and choose ""Add as link"". If you do not select this option, Visual Studio will copy files to the project directory instead. +Alternatively, you can also specify `AdditionalImportDirs` to give the location of proto files outside","rephrase ""to give the location of proto files outsidethe project"" as e.g. ""to provide the list of directories in which the protocol buffer compiler will search for imported proto files"".(your original phrasing seems a bit vague).",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/30620,948397814,2022-08-17T20:43:07Z,test/cpp/util/channelz_sampler_test.cc,"@@ -164,6 +165,12 @@ TEST(ChannelzSamplerTest, SimpleTest) {   client_thread_2.join(); } +int GenerateUniuquePortNumber() {",Prefer to use `grpc_pick_unused_port_or_die()`,
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/30621,948469676,2022-08-17T22:02:10Z,test/cpp/end2end/xds/xds_end2end_test_lib.cc,"@@ -1014,7 +1014,9 @@ absl::optional<AdsServiceImpl::ResponseState> XdsEnd2endTest::WaitForNack(            response_state->state != AdsServiceImpl::ResponseState::NACKED;   };   do {-    const Status status = SendRpc();+    // Some tests for example the XdsSecurityTests need a higher timeout from+    // the default 1000ms for some builds.+    const Status status = SendRpc(RpcOptions().set_timeout_ms(5000));","Please add an optional parameter to this method to pass in the `RpcOptions` and then override it only in the affected tests, rather than hard-coding this default for all tests.",X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/30621,948505058,2022-08-17T22:46:20Z,test/cpp/end2end/xds/xds_end2end_test_lib.cc,"@@ -1014,7 +1014,9 @@ absl::optional<AdsServiceImpl::ResponseState> XdsEnd2endTest::WaitForNack(            response_state->state != AdsServiceImpl::ResponseState::NACKED;   };   do {-    const Status status = SendRpc();+    // Some tests for example the XdsSecurityTests need a higher timeout from",I think this comment is no longer necessary.,X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/30623,949497286,2022-08-18T18:57:28Z,test/cpp/end2end/xds/xds_fault_injection_end2end_test.cc,"@@ -204,7 +204,13 @@ TEST_P(FaultInjectionTest, XdsFaultInjectionPercentageAbortViaHeaders) {  TEST_P(FaultInjectionTest, XdsFaultInjectionPercentageDelay) {   CreateAndStartBackends(1);+  const uint32_t kFixedDelayMilliseconds = 100000;+#ifndef NDEBUG",I'm really not keen on putting `#ifndef`s in the middle of individual tests.  Can we not just increase the timeout even for opt builds?,
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/30629,949502256,2022-08-18T19:03:50Z,test/cpp/end2end/client_lb_end2end_test.cc,"@@ -2328,6 +2333,11 @@ TEST_F(ClientLbInterceptTrailingMetadataTest,     auto stream = stub->BidiStream(&ctx);     ctx.TryCancel();   }+  {+    // Wait for stream to be cancelled.+    grpc::internal::MutexLock lock(&mu_);+    cond_.WaitWithTimeout(&mu_, absl::Seconds(3));","condition variables can wake spuriously so it's best to add a loop with a variable that becomes signalled:```while (!trailers_intercepted()) {  cond_.WaitWithTimeout(&mu_, absl::Seconds(3));}```",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/30629,949505347,2022-08-18T19:08:10Z,test/cpp/end2end/client_lb_end2end_test.cc,"@@ -2251,6 +2251,9 @@ class ClientLbInterceptTrailingMetadataTest : public ClientLbEnd2endTest {     return std::move(load_report_);   } +  grpc::internal::Mutex mu_;","Please make these data members private, and add a method to wait for the next event:```void WaitForLbCallback() {  grpc::internal::MutexLock lock(&mu_);  cond_.WaitWithTimeout(&mu_, absl::Seconds(3));}```",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/30629,949616403,2022-08-18T21:26:11Z,test/cpp/end2end/client_lb_end2end_test.cc,"@@ -2251,6 +2251,9 @@ class ClientLbInterceptTrailingMetadataTest : public ClientLbEnd2endTest {     return std::move(load_report_);   } +  grpc::internal::Mutex mu_;","Thinking about this further, a more general solution might be to have a queue of LB callback data and then have a method to get the latest result within some specified timeout.  For example:```public:  absl::optional<LbTrailingMetadataCallbackData> GetNextTrailingMetadataCallbackData(absl::Duration timeout) {    grpc::internal::MutexLock lock(&mu_);    if (queue_.empty()) {      grpc::internal::CondVar cv;      cv_ = cv;      if (!cv.WaitWithTimeout(&mu_, timeout)) {        cv_ = nullptr;        return absl::nullopt;      }    }    auto result = std::move(queue_.front());    queue_.pop_front();    return result;  } private:  struct LbTrailingMetadataCallbackData { ... };  static void ReportTrailerIntercepted(      const grpc_core::TrailingMetadataArgsSeen& args_seen) {    LbTrailingMetadataCallbackData entry = // ...convert from args_seen ...    ClientLbInterceptTrailingMetadataTest* self = current_test_instance_;    grpc::internal::MutexLock lock(&self->mu_);    queue_.push_back(std::move(entry));    if (cv_ != nullptr) {      cv_->Signal();      cv_ = nullptr;    }  }  grpc::internal::Mutex mu_;  grpc::internal::CondVar* cv_ ABSL_GUARDED_BY(&mu_) = nullptr;  std::deque<LbTrailingMetadataCallbackData> queue_ ABSL_GUARDED_BY(&mu_);```This way, we're not reusing the same `CondVar` for multiple LB callbacks.",
4181124,yashykt,https://api.github.com/repos/grpc/grpc/pulls/30623,949632027,2022-08-18T21:51:13Z,test/cpp/end2end/xds/xds_fault_injection_end2end_test.cc,"@@ -204,11 +204,11 @@ TEST_P(FaultInjectionTest, XdsFaultInjectionPercentageAbortViaHeaders) {  TEST_P(FaultInjectionTest, XdsFaultInjectionPercentageDelay) {   CreateAndStartBackends(1);-  const uint32_t kRpcTimeoutMilliseconds = grpc_test_slowdown_factor() * 3000;+  const uint32_t kRpcTimeoutMilliseconds = 10000;","This is used in RpcOptions, and RpcOptions has it's own grpc_test_slowdown_factor() multiplier -https://github.com/grpc/grpc/blob/2a7286a67c71e2e0c0eee5e49ba1a719fcabb3a8/test/cpp/end2end/xds/xds_end2end_test_lib.cc#L419https://github.com/grpc/grpc/blob/2a7286a67c71e2e0c0eee5e49ba1a719fcabb3a8/test/core/util/test_config.cc#L81",
16571023,ananda1066,https://api.github.com/repos/grpc/grpc/pulls/30629,949642541,2022-08-18T22:10:36Z,test/cpp/end2end/client_lb_end2end_test.cc,"@@ -2251,6 +2251,9 @@ class ClientLbInterceptTrailingMetadataTest : public ClientLbEnd2endTest {     return std::move(load_report_);   } +  grpc::internal::Mutex mu_;",Hm so I have run the test many times and I'm pretty sure this test case is the only place where this race is happening - I'm wondering if we need to add this complexity? I updated with the previous review comment and the test is passing in 100k runs,
16571023,ananda1066,https://api.github.com/repos/grpc/grpc/pulls/30629,949642798,2022-08-18T22:11:07Z,test/cpp/end2end/client_lb_end2end_test.cc,"@@ -2328,6 +2333,11 @@ TEST_F(ClientLbInterceptTrailingMetadataTest,     auto stream = stub->BidiStream(&ctx);     ctx.TryCancel();   }+  {+    // Wait for stream to be cancelled.+    grpc::internal::MutexLock lock(&mu_);+    cond_.WaitWithTimeout(&mu_, absl::Seconds(3));",Ah I saw this pattern in some other places and was wondering why it was needed - done,
672669,sergiitk,https://api.github.com/repos/grpc/grpc/pulls/30643,950513724,2022-08-19T19:44:26Z,tools/run_tests/xds_k8s_test_driver/framework/rpc/grpc.py,"@@ -26,15 +26,26 @@   class GrpcClientHelper:-    channel: grpc.Channel     DEFAULT_RPC_DEADLINE_SEC = 90--    def __init__(self, channel: grpc.Channel, stub_class: Any):+    channel: grpc.Channel+    # This is purely cosmetic to make RPC logs look like method calls.+    log_service_name: str+    # This is purely cosmetic to output the RPC target. Normally set to the+    # hostname:port of the remote service, but it doesn't have to be the+    # real target. This is done so that when RPC are routed to the proxy+    # or port forwarding, this still is set to a useful name.+    log_target: str++    def __init__(self,+                 channel: grpc.Channel,+                 stub_class: Any,+                 *,+                 log_target: Optional[str] = ''):         self.channel = channel         self.stub = stub_class(channel)-        # This is purely cosmetic to make RPC logs look like method calls.         self.log_service_name = re.sub('Stub$', '',                                        self.stub.__class__.__name__)+        self.log_target = log_target or ''","It is `Optional`, so technically someone could pass `None`. This is just a safeguard.",
4181124,yashykt,https://api.github.com/repos/grpc/grpc/pulls/30649,950524033,2022-08-19T20:02:49Z,test/cpp/end2end/xds/xds_routing_end2end_test.cc,"@@ -2289,6 +2289,10 @@ TEST_P(LdsRdsTest, XdsRetryPolicyMaxBackOff) {   max_interval->set_seconds(1 * grpc_test_slowdown_factor());   max_interval->set_nanos(0);   SetRouteConfiguration(balancer_.get(), new_route_config);+  // Send an initial RPC to make sure we get connected (we don't want",is a similar fix needed at other places?,
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/30689,951534079,2022-08-22T14:47:10Z,test/core/end2end/flaky.bzl,"@@ -24,6 +24,8 @@ FLAKY_TESTS = [     ""h2_compress_test@max_connection_age"",     ""h2_compress_test@max_connection_idle"",     ""h2_compress_test@retry_cancellation"",+    ""h2_compress_test@retry_per_attempt_recv_timeout"",","The churn in this file suggests that we might want to change this list to identify flaky tests by the individual test, independent of the test fixture.  Most flakiness comes from the tests themselves, not the fixtures, so a test that is flaky in one fixture is very likely to also be flaky in other fixtures.  Identifying the flaky tests by both fixture and test will probably lead to a lot of churn based on which particular fixtures each test case has happened to flake on most recently, which is probably not a very useful signal.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/30688,951576482,2022-08-22T15:23:29Z,src/core/lib/resolver/address_parser_registry.h,"@@ -0,0 +1,82 @@+// Copyright 2022 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++#ifndef GRPC_CORE_LIB_RESOLVER_ADDRESS_PARSER_REGISTRY_H+#define GRPC_CORE_LIB_RESOLVER_ADDRESS_PARSER_REGISTRY_H++#include <grpc/support/port_platform.h>++#include <functional>+#include <utility>+#include <vector>++#include ""absl/status/statusor.h""+#include ""absl/strings/string_view.h""++#include ""src/core/lib/iomgr/resolved_address.h""+#include ""src/core/lib/uri/uri_parser.h""++namespace grpc_core {++using AddressParser =+    std::function<absl::StatusOr<grpc_resolved_address>(absl::string_view)>;++// Handle mapping of address-like URIs to grpc_resolved_address structs.+// Used by the sockaddr resolver and server construction to parse addresses.+class AddressParserRegistry {+ private:+  struct Parser {+    absl::string_view scheme;+    AddressParser parser;+  };++ public:+  class Builder {+   public:+    void AddScheme(absl::string_view scheme, AddressParser parser);++    AddressParserRegistry Build();++   private:+    std::vector<Parser> parsers_;+  };++  AddressParserRegistry(AddressParserRegistry&&) = default;+  AddressParserRegistry& operator=(AddressParserRegistry&&) = default;++  // Parse URI using an appropriate parser, return a list of resolved addresses.+  absl::StatusOr<std::vector<grpc_resolved_address>> Parse(","As per our previous design discussions about this, I think the idea is for us to eventually move to a model where the name resolver returns address URI strings instead of `grpc_resolved_address` structs.  And I know that we already have cases where we pass URI strings around in channel args and various other APIs, so it seems like URI strings are going to be the common way of representing a single address.  Given that, I would strongly prefer that address resolvers can return only one address, and only name resolvers can return multiple addresses.  Otherwise, we may wind up encountering strange cases like trying to create a transport for multiple addresses, which inherently makes no sense.I assume that the reason for having this here is that we currently support a single URI yielding multiple addresses in the sockaddr name resolver (which I've always considered a bit of an ugly hack).  If so, I suggest keeping that functionality in the sockaddr name resolver.  The idea would be that if the sockaddr name resolver sees a URI like ""ipv4:a,b,c"", it will return a list of addresses [""ipv4:a"", ""ipv4:b"", ""ipv4:c""], each of which can then be resolved via the ipv4 address resolver and is guaranteed to resolve to only one address.  (This does mean that we'll have both a name resolver and an address resolver for these URI schemes, but that seems fine, since they'll need two different registries and resolver types anyway.)",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/30664,951579712,2022-08-22T15:26:29Z,test/cpp/end2end/test_service_impl.cc,"@@ -631,6 +636,8 @@ CallbackTestServiceImpl::BidiStream(CallbackServerContext* context) {     bool setup_done_{false};     std::thread finish_thread_;     bool client_try_cancel_ = false;+    std::promise<void> cancel_notifier_;","I think it's not yet safe to use `absl::Notification`, as per https://github.com/grpc/grpc/blob/master/third_party/ABSEIL_MANUAL.md.  That's why most of our tests currently use `grpc_core::CondVar` or `gpr_event` instead.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/30664,951645178,2022-08-22T16:30:05Z,test/cpp/end2end/test_service_impl.cc,"@@ -631,6 +636,8 @@ CallbackTestServiceImpl::BidiStream(CallbackServerContext* context) {     bool setup_done_{false};     std::thread finish_thread_;     bool client_try_cancel_ = false;+    std::promise<void> cancel_notifier_;","@veblush, can you confirm what the current state is of the absl synchronization library?  Is it actually okay to use gRPC at this point?",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/30690,951649757,2022-08-22T16:34:59Z,test/cpp/end2end/xds/xds_outlier_detection_end2end_test.cc,"@@ -38,6 +38,13 @@ class OutlierDetectionTest : public XdsEnd2endTest {     return absl::StrCat(ipv6_only_ ? ""[::1]"" : ""127.0.0.1"", "":"",                         backends_[index]->port(), ""_0"");   }+  void set_test_interval(absl::Duration interval) { test_interval_ = interval; }","I don't understand why this machinery is needed, especially since this setter method is never actually being called anywhere.  Storing this value in the base class makes the individual tests less hermetic and doesn't seem to actually add any value.  I think it would be better to remove this and just directly use the appropriate values in the individual tests.",X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/30695,951771279,2022-08-22T18:28:51Z,test/cpp/end2end/client_lb_end2end_test.cc,"@@ -429,7 +429,7 @@ class ClientLbEnd2endTest : public ::testing::Test {       cond_.Signal();     } -    void Shutdown() {+    void Shutdown(int timeout_ms = 0) {","It doesn't look like this parameter is actually being used, which means that this PR is actually a no-op.Also, even if you did use this parameter to pass to `server_->Shutdown()` on line 435 instead of the hard-coded timeout (which I assume is what you intended to do), I don't think that would actually solve the problem.  Unfortunately, we have a long-standing known issue where there is not actually any API to do a true graceful shutdown on a C++ server.  Even with a non-zero timeout, the server still shuts down immediately from the perspective of the transport (i.e., the transport sends a GOAWAY and then immediately closes the connection), which means that the client may think the call was actually started on the server (and thus not eligible for a transparent retry), so when the connection is closed, the client fails the call with ""Broken pipe"" instead of being transparently retried.Normally when we see this, we fix it by changing the test to call `StopListeningAndSendGoaways()` (an internal API we added to the test) instead of `Shutdown()`, so that it does do a graceful shutdown at the transport level.  In this case, though, we'll probably need something a little more complicated, because we need to restart the server immediately after.I'll put together a separate PR for this.",X
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/30550,951810525,2022-08-22T19:06:21Z,src/core/ext/transport/chttp2/transport/flow_control.cc,"@@ -296,9 +296,12 @@ FlowControlAction TransportFlowControl::PeriodicUpdate() {     // target might change based on how much memory pressure we are under     // TODO(ncteisen): experiment with setting target to be huge under low     // memory pressure.-    double target = kSmoothMemoryPressure-                        ? TargetInitialWindowSizeBasedOnMemoryPressureAndBdp()-                        : pow(2, SmoothLogBdp(TargetLogBdp()));+    uint32_t target = static_cast<uint32_t>(RoundUpToPowerOf2(+        Clamp(kSmoothMemoryPressure+                  ? TargetInitialWindowSizeBasedOnMemoryPressureAndBdp()+                  : pow(2, SmoothLogBdp(TargetLogBdp())),+              0.0, static_cast<double>(kMaxInitialWindowSize))));","`kMinInitialWindowSize` is 0 - which is where it should be. We want resource quota to be able to stop reading from streams, not to stall after some small number of bytes (meaning we need to allocate a little bit of memory for every stream).Previously we had a bit of a sloppiness factor due to some bugs. I'm going to argue that the fuzzer we have in place is showing good evidence that those bugs no longer remain.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/30690,952927780,2022-08-23T17:26:55Z,test/cpp/end2end/xds/xds_outlier_detection_end2end_test.cc,"@@ -38,6 +38,13 @@ class OutlierDetectionTest : public XdsEnd2endTest {     return absl::StrCat(ipv6_only_ ? ""[::1]"" : ""127.0.0.1"", "":"",                         backends_[index]->port(), ""_0"");   }+  void set_test_interval(absl::Duration interval) { test_interval_ = interval; }","Please also remove the `get_test_interval()` method and the `test_interval_` data member.  All of this should be local within the individual tests, not in the test framework.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/30690,952952216,2022-08-23T17:55:14Z,test/cpp/end2end/xds/xds_outlier_detection_end2end_test.cc,"@@ -194,7 +202,8 @@ TEST_P(OutlierDetectionTest, SuccessRateMaxPercent) {                           .set_server_expected_error(StatusCode::CANCELLED));   CheckRpcSendOk(DEBUG_LOCATION, 1, rpc_options2);   CheckRpcSendOk(DEBUG_LOCATION, 1, rpc_options3);-  gpr_sleep_until(grpc_timeout_milliseconds_to_deadline(100));+  gpr_sleep_until(grpc_timeout_milliseconds_to_deadline(","Looks like you're right that most of the tests don't do ejection.  I had thought that was a minority, but it looks like it's not.  I guess we don't have any alternative to sleeping for those.For the tests that wait for a subset of backends to be ejected, I don't think it's that hard to make them check for an ejection.  For example, here in `SuccessRateMaxPercent`, we can do something like this:```// Wait for either backend 0 or 1 to be ejected.absl::Time deadline = absl::Now() + absl::Seconds(5);while (true) {  ResetBackendCounters();  CheckRpcSendOk(DEBUG_LOCATION, 1, rpc_options);  CheckRpcSendOk(DEBUG_LOCATION, 1, rpc_options1);  if (backends_[0]->backend_service()->request_count() == 0 ||      backends_[1]->backend_service()->request_count() == 0) {    break;  }  EXPECT_LE(absl::Now(), deadline);  if (absl::Now() >= deadline) break;}```",
85715732,yousukseung,https://api.github.com/repos/grpc/grpc/pulls/30690,953041951,2022-08-23T19:36:46Z,test/cpp/end2end/xds/xds_outlier_detection_end2end_test.cc,"@@ -194,7 +202,8 @@ TEST_P(OutlierDetectionTest, SuccessRateMaxPercent) {                           .set_server_expected_error(StatusCode::CANCELLED));   CheckRpcSendOk(DEBUG_LOCATION, 1, rpc_options2);   CheckRpcSendOk(DEBUG_LOCATION, 1, rpc_options3);-  gpr_sleep_until(grpc_timeout_milliseconds_to_deadline(100));+  gpr_sleep_until(grpc_timeout_milliseconds_to_deadline(","I guess I was not clear in saying not easy. Yes, above works in one hand, but these tests should also ensure if not more than expected # of backends switched, so I feel using a timeout can be justified for the same reason we use it in the first group of tests to ensure we have proper coverage for false positives.I considered adding something similar to above followed by a timeout, but then found this does not help with extra complexity as long as the total max timeout value is the same.WDYT?",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/30483,953416194,2022-08-24T06:54:16Z,src/core/lib/load_balancing/lb_policy_registry.cc,"@@ -146,16 +123,13 @@ absl::StatusOr<Json::Object::const_iterator> ParseLoadBalancingConfigHelper(       ""No known policies in list: "", absl::StrJoin(policies_tried, "" ""))); } -}  // namespace- absl::StatusOr<RefCountedPtr<LoadBalancingPolicy::Config>>-LoadBalancingPolicyRegistry::ParseLoadBalancingConfig(const Json& json) {-  GPR_ASSERT(g_state != nullptr);+LoadBalancingPolicyRegistry::ParseLoadBalancingConfig(const Json& json) const {   auto policy = ParseLoadBalancingConfigHelper(json);   if (!policy.ok()) return policy.status();   // Find factory.   LoadBalancingPolicyFactory* factory =-      g_state->GetLoadBalancingPolicyFactory((*policy)->first.c_str());+      GetLoadBalancingPolicyFactory((*policy)->first.c_str());","Not directly related to this PR, but I think the `.c_str()` is no longer needed here.",X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/30483,953422881,2022-08-24T07:02:36Z,src/core/ext/filters/client_channel/resolver_result_parsing.cc,"@@ -111,8 +112,8 @@ ClientChannelServiceConfigParser::ParseGlobalParams(const ChannelArgs& /*args*/,         lb_policy_name[i] = tolower(lb_policy_name[i]);       }       bool requires_config = false;-      if (!LoadBalancingPolicyRegistry::LoadBalancingPolicyExists(-              lb_policy_name.c_str(), &requires_config)) {+      if (!lb_policy_registry.LoadBalancingPolicyExists(lb_policy_name.c_str(),","Not new in this PR, but it looks like the `.c_str()` is no longer needed.",X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/30483,953430919,2022-08-24T07:11:00Z,src/core/ext/filters/client_channel/lb_policy/grpclb/grpclb.cc,"@@ -1903,16 +1903,10 @@ class GrpcLbFactory : public LoadBalancingPolicyFactory { // Plugin registration // -void grpc_lb_policy_grpclb_init() {-  grpc_core::LoadBalancingPolicyRegistry::Builder::-      RegisterLoadBalancingPolicyFactory(-          absl::make_unique<grpc_core::GrpcLbFactory>());-}--void grpc_lb_policy_grpclb_shutdown() {}- namespace grpc_core { void RegisterGrpcLbLoadReportingFilter(CoreConfiguration::Builder* builder) {","Suggest renaming this to `RegisterGrpcLbPolicy()`, since the LB policy is the main thing here, not the filter (the filter is needed only to provide some functionality for the LB policy).",X
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/30734,954243796,2022-08-24T19:53:17Z,test/cpp/end2end/xds/xds_end2end_test_lib.h,"@@ -720,7 +721,7 @@ class XdsEnd2endTest : public ::testing::TestWithParam<XdsTestType> {     // Dev note: If a timeout or Deadline Exceeded error is occurring in an XDS     // end2end test, consider changing that test's timeout instead of this     // global default.-    int timeout_ms = 1000;+    int timeout_ms = BuiltUnderMsan() ? 2000 : 1000;","We can, but it's more of a shotgun approach. That'd be setting expected slowdowns of:* 4x for MSAN* 5x for UBSAN (which is not a problem for XDS tests)* 3x for ASAN (which is not a problem for XDS tests)* 5x for TSAN (which is not a problem for XDS tests)",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/30734,954250405,2022-08-24T20:00:50Z,test/cpp/end2end/xds/xds_end2end_test_lib.h,"@@ -720,7 +721,7 @@ class XdsEnd2endTest : public ::testing::TestWithParam<XdsTestType> {     // Dev note: If a timeout or Deadline Exceeded error is occurring in an XDS     // end2end test, consider changing that test's timeout instead of this     // global default.-    int timeout_ms = 1000;+    int timeout_ms = BuiltUnderMsan() ? 2000 : 1000;","The test framework uses `grpc_timeout_milliseconds_to_deadline()` on the value of `timeout_ms`:https://github.com/grpc/grpc/blob/03b6b01043f778e76b1f1380f5619067a7c5a42a/test/cpp/end2end/xds/xds_end2end_test_lib.cc#L419And `grpc_timeout_milliseconds_to_deadline()` already multiplies by `grpc_test_slowdown_factor()`:https://github.com/grpc/grpc/blob/93fbacb5343ea8cf993f779cee0847aed107bdc7/test/core/util/test_config.cc#L90If we multiplied by that factor here, we'd be applying that multiplier twice, which I don't think we want.",
1644595,gnossen,https://api.github.com/repos/grpc/grpc/pulls/30594,955474866,2022-08-25T22:38:47Z,tools/run_tests/xds_k8s_test_driver/framework/test_app/runners/base_runner.py,"@@ -16,15 +16,55 @@ """""" from abc import ABCMeta from abc import abstractmethod+import functools+import pathlib+import threading from typing import Dict, Optional import urllib.parse +from absl import flags++from framework import xds_flags+from framework.helpers import logs++flags.adopt_module_key_flags(logs)+_LOGS_SUBDIR = 'test_app_logs'+  class RunnerError(Exception):     """"""Error running xDS Test App running remotely.""""""   class BaseRunner(metaclass=ABCMeta):+    _logs_subdir: Optional[pathlib.Path] = None+    _log_stop_event: Optional[threading.Event] = None++    def __init__(self):+        if xds_flags.COLLECT_APP_LOGS.value:+            self._logs_subdir = logs.log_dir_mkdir(_LOGS_SUBDIR)+            self._log_stop_event = threading.Event()++    @property+    @functools.lru_cache(None)+    def should_collect_logs(self) -> bool:+        return self._logs_subdir is not None++    @property+    @functools.lru_cache(None)+    def logs_subdir(self) -> pathlib.Path:+        if not self.should_collect_logs:+            raise FileNotFoundError('Log collection is not enabled.')+        return self._logs_subdir++    @property+    def log_stop_event(self) -> threading.Event:+        if not self.should_collect_logs:+            raise ValueError('Log collection is not enabled.')+        return self._log_stop_event++    def stop_logging_if_needed(self):",Nit: `maybe_stop_logging` is a more established naming pattern.,
1644595,gnossen,https://api.github.com/repos/grpc/grpc/pulls/30594,955481294,2022-08-25T22:54:13Z,tools/run_tests/xds_k8s_test_driver/framework/infrastructure/k8s_internal/k8s_log_collector.py,"@@ -0,0 +1,129 @@+# Copyright 2022 gRPC authors.+#+# Licensed under the Apache License, Version 2.0 (the ""License"");+# you may not use this file except in compliance with the License.+# You may obtain a copy of the License at+#+#     http://www.apache.org/licenses/LICENSE-2.0+#+# Unless required by applicable law or agreed to in writing, software+# distributed under the License is distributed on an ""AS IS"" BASIS,+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+# See the License for the specific language governing permissions and+# limitations under the License.+import logging+import os+import pathlib+import threading+from typing import Any, Callable, Optional, TextIO++from kubernetes import client+from kubernetes.watch import watch++logger = logging.getLogger(__name__)+++class PodLogCollector(threading.Thread):","There are [a bunch of landmines](https://stackoverflow.com/questions/660961/overriding-python-threading-thread-run) when subclassing `threading.Thread` rather than just passing a callable to the `threading.Thread` constructor, but it looks like you've managed to avoid them all. No complaints on my end as long you've confirmed that it's all working as intended.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/30755,955494693,2022-08-25T23:23:46Z,include/grpcpp/support/channel_arguments.h,"@@ -70,6 +70,9 @@ class ChannelArguments {   /// the resolver.   void SetGrpclbFallbackTimeout(int fallback_timeout); +  /// Set the channel args to be used for the channel to grpclb server.+  void SetGrpclbChannelArgs(const ChannelArguments& grpclb_channel_args);","Let's not add a first-class API for this.  That would require a gRFC, and I don't think it's something we want anyway, since this is an edge case, not really a first-class knob that we're providing.I think it's fine for users to use `SetPointer()` or `SetPointerWithVtable()` for this arg.",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/30764,956169245,2022-08-26T15:34:52Z,src/core/lib/surface/init.cc,"@@ -208,6 +211,8 @@ void grpc_shutdown(void) {     grpc_core::ApplicationCallbackExecCtx* acec =         grpc_core::ApplicationCallbackExecCtx::Get();     if (!grpc_iomgr_is_any_background_poller_thread() &&+        !grpc_event_engine::posix_engine::TimerManager::",That would tie grpc initialization to timer manager and create a dependency loop.,
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/30755,956486156,2022-08-26T22:46:54Z,test/cpp/end2end/grpclb_end2end_test.cc,"@@ -210,12 +230,12 @@ class BalancerServiceImpl : public BalancerService {       if (serverlist_done_) goto done;     }     {-      // The loadbalancer should see a dummy user agent because it was+      // The loadbalancer should see a test user agent because it was       // specifically configured at the client using       // GRPC_ARG_GRPCLB_CHANNEL_ARGS       auto it = context->client_metadata().find(""user-agent"");-      EXPECT_TRUE(it != context->client_metadata().end());-      EXPECT_TRUE(it->second.starts_with(kGrpclbSpecificUserAgentString));+      GPR_ASSERT((it != context->client_metadata().end()));","Here I suggest saying:```EXPECT_TRUE(it != context->client_metadata().end());if (it != context->client_metadata().end()) {  EXPECT_THAT(it->second, ::testing::StartsWith(kGrpclbSpecificUserAgentString));}```",
4181124,yashykt,https://api.github.com/repos/grpc/grpc/pulls/30778,956880639,2022-08-29T04:13:40Z,src/core/lib/event_engine/posix_engine/timer_manager.cc,"@@ -35,7 +35,7 @@ #include ""src/core/lib/gpr/tls.h"" #include ""src/core/lib/gprpp/thd.h"" -static GPR_THREAD_LOCAL(bool) g_timer_thread = false;+static GPR_THREAD_LOCAL(bool) g_timer_thread;",hmm looks like gpr thread local variables no longer need initialization,X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/30789,960073658,2022-08-31T22:26:15Z,src/core/lib/security/transport/client_auth_filter.cc,"@@ -157,7 +160,15 @@ ArenaPromise<absl::StatusOr<CallArgs>> ClientAuthFilter::GetCallCredsMetadata(    auto client_initial_metadata = std::move(call_args.client_initial_metadata);   return TrySeq(-      creds->GetRequestMetadata(std::move(client_initial_metadata), &args_),+      Seq(creds->GetRequestMetadata(std::move(client_initial_metadata), &args_),","The goal here is not to check all filters.  The [gRFC](https://github.com/grpc/proposal/blob/master/A54-restrict-control-plane-status-codes.md#proposal) specifies 4 individual cases that need to be covered, and those are the ones covered in this PR.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/30784,960088662,2022-08-31T22:58:52Z,src/core/ext/filters/client_channel/subchannel.cc,"@@ -838,7 +837,18 @@ const char* SubchannelConnectivityStateChangeString( void Subchannel::SetConnectivityStateLocked(grpc_connectivity_state state,                                             const absl::Status& status) {   state_ = state;-  status_ = status;+  if (status.ok()) {+    status_ = status;+  } else {+    // Augment status message to include IP address.+    status_ = absl::Status(status.code(),+                           absl::StrCat(grpc_sockaddr_to_uri(&key_.address())+                                            .value_or(""<unknown address type>""),+                                        "": "", status.message()));+    status.ForEachPayload(+        [this](absl::string_view key, const absl::Cord& value)+            ABSL_NO_THREAD_SAFETY_ANALYSIS { status_.SetPayload(key, value); });","No, it doesn't.  That's why I said in the comment that it won't work.The problem is that if we mark the lambda as `ABSL_EXCLUSIVE_LOCKS_REQUIRED(&mu_)`, the compiler complains, because the lambda is being invoked by `absl::Status::ForEachPayload()`, which is not itself marked as `ABSL_EXCLUSIVE_LOCKS_REQUIRED(&Subchannel::mu_)` -- and it cannot be marked as such, because (a) the absl code doesn't know anything about the gRPC `Subchannel` class, and (b) `mu_` is a private member of `Subchannel`, so the absl code wouldn't have access to it anyway.We've run into a similar pattern before with `Orphanable`, `InternallyRefCounted<>`, and `DualRefCounted<>`, where the `Orphan()` method gets invoked via a smart pointer being reset or destroyed.  The smart pointer methods are not specific to the class with the `Orphan()` method, so they can't be marked with the right lock annotation, which means we can't use `ABSL_EXCLUSIVE_LOCKS_REQUIRED()` on the `Orphan()` method.  So the only option is to use `ABSL_NO_THREAD_SAFETY_ANALYSIS`.  Here are a couple of examples:https://github.com/grpc/grpc/blob/cbed2cef570ee6ffdc3c7f86056dbfcb8375a15b/src/core/ext/filters/client_channel/lb_policy/rls/rls.cc#L269https://github.com/grpc/grpc/blob/cbed2cef570ee6ffdc3c7f86056dbfcb8375a15b/src/core/ext/filters/client_channel/resolver/dns/c_ares/dns_resolver_ares.cc#L157",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/30688,960247545,2022-09-01T06:00:44Z,src/core/lib/resolver/address_parser_registry.h,"@@ -0,0 +1,82 @@+// Copyright 2022 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++#ifndef GRPC_CORE_LIB_RESOLVER_ADDRESS_PARSER_REGISTRY_H+#define GRPC_CORE_LIB_RESOLVER_ADDRESS_PARSER_REGISTRY_H++#include <grpc/support/port_platform.h>++#include <functional>+#include <utility>+#include <vector>++#include ""absl/status/statusor.h""+#include ""absl/strings/string_view.h""++#include ""src/core/lib/iomgr/resolved_address.h""+#include ""src/core/lib/uri/uri_parser.h""++namespace grpc_core {++using AddressParser =+    std::function<absl::StatusOr<grpc_resolved_address>(absl::string_view)>;++// Handle mapping of address-like URIs to grpc_resolved_address structs.+// Used by the sockaddr resolver and server construction to parse addresses.+class AddressParserRegistry {+ private:+  struct Parser {+    absl::string_view scheme;+    AddressParser parser;+  };++ public:+  class Builder {+   public:+    void AddScheme(absl::string_view scheme, AddressParser parser);++    AddressParserRegistry Build();++   private:+    std::vector<Parser> parsers_;+  };++  AddressParserRegistry(AddressParserRegistry&&) = default;+  AddressParserRegistry& operator=(AddressParserRegistry&&) = default;++  // Parse URI using an appropriate parser, return a list of resolved addresses.+  absl::StatusOr<std::vector<grpc_resolved_address>> Parse(+      const URI& uri) const;++  absl::StatusOr<grpc_resolved_address> ParseSingleAddress(+      const URI& uri) const;++  // Does the registry have a given scheme?+  bool HasScheme(absl::string_view scheme) const;++ private:+  AddressParserRegistry() = delete;+  explicit AddressParserRegistry(std::vector<Parser> parsers)+      : parsers_(std::move(parsers)) {}+  AddressParserRegistry(const AddressParserRegistry&) = delete;+  AddressParserRegistry& operator=(const AddressParserRegistry&) = delete;++  absl::StatusOr<const AddressParser*> GetParser(const URI& uri) const;++  std::vector<Parser> parsers_;",marginally... we really need something that presents something similar to std::map but is backed by std::vector to save on bloat,
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/30688,960250935,2022-09-01T06:06:53Z,src/core/ext/transport/chttp2/server/chttp2_server.cc,"@@ -916,19 +911,17 @@ grpc_error_handle Chttp2ServerAddPort(Server* server, const char* addr,                                                     args_modifier);   }   *port_num = -1;-  absl::StatusOr<std::vector<grpc_resolved_address>> resolved_or;   std::vector<grpc_error_handle> error_list;   std::string parsed_addr = URI::PercentDecode(addr);-  absl::string_view parsed_addr_unprefixed{parsed_addr};   // Using lambda to avoid use of goto.   grpc_error_handle error = [&]() {     grpc_error_handle error = GRPC_ERROR_NONE;-    if (absl::ConsumePrefix(&parsed_addr_unprefixed, kUnixUriPrefix)) {-      resolved_or = grpc_resolve_unix_domain_address(parsed_addr_unprefixed);-    } else if (absl::ConsumePrefix(&parsed_addr_unprefixed,-                                   kUnixAbstractUriPrefix)) {-      resolved_or =-          grpc_resolve_unix_abstract_domain_address(parsed_addr_unprefixed);+    auto uri = URI::Parse(parsed_addr);+    const auto& address_parser_registry =+        CoreConfiguration::Get().address_parser_registry();+    absl::StatusOr<std::vector<grpc_resolved_address>> resolved_or;+    if (uri.ok() && address_parser_registry.HasScheme(uri->scheme())) {+      resolved_or = address_parser_registry.Parse(*uri);","Removed the support for comma separated addresses.We do not support DNS names now, nor have we ever. We do support resolution via getaddrinfo, which means ""please read from /etc/hosts"". IMHO the biggest mistake here was to place that API under the DNS abstraction.",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/30822,961262830,2022-09-02T03:43:24Z,src/core/lib/experiments/config.cc,"@@ -0,0 +1,71 @@+// Copyright 2022 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++#include ""src/core/lib/experiments/config.h""++#include ""absl/strings/str_split.h""++#include <grpc/support/log.h>++#include ""src/core/lib/experiments/config.h""+#include ""src/core/lib/experiments/experiments.h""+#include ""src/core/lib/gprpp/global_config.h""+#include ""src/core/lib/gprpp/no_destruct.h""++GPR_GLOBAL_CONFIG_DEFINE_STRING(+    grpc_experiments, """",+    ""List of grpc experiments to enable (or with a '-' prefix to disable)."");","I might do something analogous to trace then, and have a 'list_experiments' experiment.My worry is when we start having internal experiments and wanting to merge the lists and what not things are going to get crazy with the help text.Eventually we'll codegen a .md file too I guess.",
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/30777,961514461,2022-09-02T10:03:18Z,tools/internal_ci/linux/grpc_sample_fuzzers.sh,"@@ -15,13 +15,23 @@  set -ex +# avoid slow finalization after the script has exited.","since the contents of this script is basically that of https://github.com/grpc/grpc/blob/master/tools/internal_ci/linux/grpc_bazel_rbe.sh, can't you simply use that script.Also, it looks like what you're doing is basically trying to create one more of the bazel_rbe linux jobs, with a slightly different config. So it sounds like you should actually create one more job  (e.g. prod:grpc/core/master/linux/bazel_rbe/grpc_bazel_rbe_asan_fuzzer?) that is setup in exactly the same way as all the other bazel_rbe jobs, with only the config and bazel commandline being slightly different (you should still be able to call `grpc_bazel_rbe.sh`). That would make it much simpler to use the right flags/settings correctly, based on whether it's master/PR job (e.g. caching, bigquery test results uploading etc.) https://github.com/grpc/grpc/blob/3353d61c5afa98fd87a854aa1e21f42ee7d9adc0/tools/internal_ci/linux/grpc_bazel_rbe_asan.cfg#L37-L46",
394885,soheilhy,https://api.github.com/repos/grpc/grpc/pulls/30821,961881065,2022-09-02T17:25:14Z,src/core/lib/event_engine/workqueue.h,"@@ -0,0 +1,238 @@+// Copyright 2022 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+#ifndef GRPC_CORE_LIB_EVENT_ENGINE_WORKQUEUE_H+#define GRPC_CORE_LIB_EVENT_ENGINE_WORKQUEUE_H++#include <grpc/support/port_platform.h>++#include <stddef.h>++#include <atomic>+#include <deque>+#include <utility>++#include ""absl/base/internal/spinlock.h""+#include ""absl/base/thread_annotations.h""+#include ""absl/cleanup/cleanup.h""+#include ""absl/synchronization/mutex.h""+#include ""absl/types/optional.h""++#include ""src/core/lib/gprpp/sync.h""+#include ""src/core/lib/gprpp/time.h""+#include ""src/core/lib/iomgr/exec_ctx.h""++namespace grpc_event_engine {+namespace experimental {++// A fast work queue based lightly on an internal Google implementation.+//+// This uses atomics and lightweight spinlocks to access the most recent element+// in the queue, making it fast for LIFO operations. Accessing the oldest (next)+// element requires taking a mutex lock.+template <typename T>+class WorkQueue {+ public:+  static const grpc_core::Timestamp kInvalidTimestamp;++  class Storage {+   public:+    Storage() = default;+    Storage(T element, grpc_core::Timestamp enqueued)+        : element_(element), enqueued_(enqueued) {}+    ~Storage() = default;+    // not copyable+    Storage(const Storage&) = delete;+    Storage& operator=(const Storage&) = delete;+    // moveable+    Storage(Storage&& other) noexcept+        : element_(other.element_), enqueued_(other.enqueued_) {}+    Storage& operator=(Storage&& other) noexcept {+      std::swap(element_, other.element_);+      std::swap(enqueued_, other.enqueued_);+      return *this;+    }+    grpc_core::Timestamp enqueued() const { return enqueued_; }+    T&& TakeElement() { return std::move(element_); }++   private:+    T element_;+    grpc_core::Timestamp enqueued_ = kInvalidTimestamp;+  };++  WorkQueue() = default;++  // Returns whether the queue is empty+  bool Empty() const {+    return (most_recent_element_enqueue_timestamp_.load(+                std::memory_order_relaxed) == kInvalidTimestamp &&+            oldest_enqueued_timestamp_.load(std::memory_order_relaxed) ==+                kInvalidTimestamp);+  }++  // Returns the number of elements in the queue+  // TODO(hork): this is an expensive method. consider caching the size in an+  // atomic.+  size_t Size() {+    grpc_core::MutexLock lock(&mu_);+    return elements_.size() ++           (most_recent_element_enqueue_timestamp_.load(+                std::memory_order_relaxed) == kInvalidTimestamp+                ? 0+                : 1);+  }+  // Returns the Timestamp of when the most recently-added element was+  // enqueued.+  grpc_core::Timestamp OldestEnqueuedTimestamp() const {+    grpc_core::Timestamp front_of_queue_timestamp =+        oldest_enqueued_timestamp_.load(std::memory_order_relaxed);+    return front_of_queue_timestamp != kInvalidTimestamp+               ? front_of_queue_timestamp+               : most_recent_element_enqueue_timestamp_.load(+                     std::memory_order_relaxed);+  }+  // Returns the next (oldest) element from the queue, or nullopt if empty+  absl::optional<T> PopFront() ABSL_LOCKS_EXCLUDED(mu_) {+    if (oldest_enqueued_timestamp_.load(std::memory_order_relaxed) !=+        kInvalidTimestamp) {+      absl::optional<T> t = TryLockAndPop(/*front=*/true);+      if (t.has_value()) return t;+    }+    if (most_recent_element_enqueue_timestamp_.load(+            std::memory_order_relaxed) != kInvalidTimestamp) {+      return TryPopMostRecentElement();+    }+    return absl::nullopt;+  }+  // Returns the most recent element from the queue, or nullopt if empty+  absl::optional<T> PopBack() {+    if (most_recent_element_enqueue_timestamp_.load(+            std::memory_order_relaxed) != kInvalidTimestamp) {+      return TryPopMostRecentElement();+    }+    if (oldest_enqueued_timestamp_.load(std::memory_order_relaxed) !=+        kInvalidTimestamp) {+      absl::optional<T> t = TryLockAndPop(/*front=*/false);+      if (t.has_value()) return *t;+    }+    return absl::nullopt;+  }+  // Adds an element to the back of the queue+  void Add(T element) {+    grpc_core::ExecCtx exec_ctx;+    T previous_most_recent;+    grpc_core::Timestamp previous_ts;+    {+      absl::optional<T> tmp_element;+      auto now = exec_ctx.Now();+      {+        absl::base_internal::SpinLockHolder lock(&most_recent_element_lock_);+        tmp_element = std::exchange(most_recent_element_, element);+        previous_ts = most_recent_element_enqueue_timestamp_.exchange(+            now, std::memory_order_relaxed);+      }+      if (!tmp_element.has_value() || previous_ts == kInvalidTimestamp) return;+      previous_most_recent = std::move(*tmp_element);+    }+    absl::MutexLock lock(&mu_);+    if (elements_.empty()) {+      oldest_enqueued_timestamp_.store(previous_ts, std::memory_order_relaxed);+    }+    elements_.push_back(Storage{std::move(previous_most_recent), previous_ts});+  }++ private:+  // Attempts to pop from the front of the queue (oldest).+  // This will return nullopt if the queue is empty, or if other workers+  // are already attempting to pop from this queue.+  absl::optional<T> TryLockAndPop(bool front) ABSL_LOCKS_EXCLUDED(mu_) {+    // Do not block the worker if there are other workers trying to pop+    // tasks from this queue.+    if (!mu_.TryLock()) return absl::nullopt;+    auto mu_cleanup = absl::MakeCleanup([this]() {+      mu_.AssertHeld();+      mu_.Unlock();+    });+    if (GPR_UNLIKELY(elements_.empty())) {+      if (most_recent_element_enqueue_timestamp_.load(+              std::memory_order_relaxed) == kInvalidTimestamp) {+        return absl::nullopt;+      }+      if (!most_recent_element_lock_.TryLock()) return absl::nullopt;+      absl::optional<T> ret = absl::nullopt;+      if (GPR_LIKELY(most_recent_element_.has_value())) {+        most_recent_element_enqueue_timestamp_.store(kInvalidTimestamp,+                                                     std::memory_order_relaxed);+        ret = std::exchange(most_recent_element_, absl::nullopt);+      }+      most_recent_element_lock_.Unlock();+      return ret;+    }+    // the queue has elements, let's pop one and update timestamps+    Storage ret_s;+    if (front) {+      ret_s = std::move(elements_.front());+      elements_.pop_front();+    } else {+      ret_s = std::move(elements_.back());+      elements_.pop_back();+    }+    if (elements_.empty()) {+      oldest_enqueued_timestamp_.store(kInvalidTimestamp,+                                       std::memory_order_relaxed);+    } else if (front) {+      oldest_enqueued_timestamp_.store(elements_.front().enqueued(),+                                       std::memory_order_relaxed);+    }+    return ret_s.TakeElement();+  }++  // Attempts to pop from the back of the queue (most recent).+  // This will return nullopt if the queue is empty, or if other workers+  // are already attempting to pop from this queue.+  absl::optional<T> TryPopMostRecentElement() {+    if (!most_recent_element_lock_.TryLock()) return absl::nullopt;+    if (GPR_UNLIKELY(!most_recent_element_.has_value())) {+      most_recent_element_lock_.Unlock();+      return absl::nullopt;+    }+    most_recent_element_enqueue_timestamp_.store(kInvalidTimestamp,+                                                 std::memory_order_relaxed);+    absl::optional<T> tmp = std::exchange(most_recent_element_, absl::nullopt);+    most_recent_element_lock_.Unlock();+    return tmp;+  }++  // The managed items in the queue+  std::deque<Storage> elements_ ABSL_GUARDED_BY(mu_);","Internally, I have implemented a linked ring-buffer.I suspect we won't use this class internally and use the executors we have, right?",X
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/30828,962056524,2022-09-02T23:01:37Z,src/core/lib/event_engine/poller.h,"@@ -30,20 +30,23 @@ namespace experimental { // Work(...). class Poller {  public:-  // This initial vector size may need to be tuned-  using Events = absl::InlinedVector<EventEngine::Closure*, 5>;+  struct Ok {};   struct DeadlineExceeded {};   struct Kicked {};-  using WorkResult = absl::variant<Events, DeadlineExceeded, Kicked>;","```enum class WorkResult { kOk, kDeadlineExceeded, kKicked };```",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/30550,962103228,2022-09-03T04:45:05Z,src/core/ext/transport/chttp2/transport/flow_control.cc,"@@ -307,23 +310,13 @@ FlowControlAction TransportFlowControl::PeriodicUpdate() {     }     // Though initial window 'could' drop to 0, we keep the floor at     // kMinInitialWindowSize-    UpdateSetting(-        &target_initial_window_size_,-        static_cast<int32_t>(Clamp(target, double(kMinInitialWindowSize),-                                   double(kMaxInitialWindowSize))),-        &action, &FlowControlAction::set_send_initial_window_update);--    // get bandwidth estimate and update max_frame accordingly.-    double bw_dbl = bdp_estimator_.EstimateBandwidth();+    UpdateSetting(GRPC_CHTTP2_SETTINGS_INITIAL_WINDOW_SIZE,+                  &target_initial_window_size_, target, &action,+                  &FlowControlAction::set_send_initial_window_update);     // we target the max of BDP or bandwidth in microseconds.-    UpdateSetting(-        &target_frame_size_,-        static_cast<int32_t>(Clamp(-            std::max(static_cast<int32_t>(Clamp(bw_dbl, 0.0, double(INT_MAX))) /-                         1000,-                     static_cast<int32_t>(target_initial_window_size_)),-            16384, 16777215)),-        &action, &FlowControlAction::set_send_max_frame_size_update);+    UpdateSetting(GRPC_CHTTP2_SETTINGS_MAX_FRAME_SIZE, &target_frame_size_,","We originally used it to try and make sure that we could switch between frames reasonably rapidly, but I don't think it helps: If that's bigger than max_initial_size we probably still want to use that anyway, and if it's smaller we've been just throwing away.",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/30821,962107686,2022-09-03T05:39:39Z,src/core/lib/event_engine/workqueue.h,"@@ -0,0 +1,238 @@+// Copyright 2022 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+#ifndef GRPC_CORE_LIB_EVENT_ENGINE_WORKQUEUE_H+#define GRPC_CORE_LIB_EVENT_ENGINE_WORKQUEUE_H++#include <grpc/support/port_platform.h>++#include <stddef.h>++#include <atomic>+#include <deque>+#include <utility>++#include ""absl/base/internal/spinlock.h""+#include ""absl/base/thread_annotations.h""+#include ""absl/cleanup/cleanup.h""+#include ""absl/synchronization/mutex.h""+#include ""absl/types/optional.h""++#include ""src/core/lib/gprpp/sync.h""+#include ""src/core/lib/gprpp/time.h""+#include ""src/core/lib/iomgr/exec_ctx.h""++namespace grpc_event_engine {+namespace experimental {++// A fast work queue based lightly on an internal Google implementation.+//+// This uses atomics and lightweight spinlocks to access the most recent element+// in the queue, making it fast for LIFO operations. Accessing the oldest (next)+// element requires taking a mutex lock.+template <typename T>+class WorkQueue {+ public:+  static const grpc_core::Timestamp kInvalidTimestamp;++  class Storage {+   public:+    Storage() = default;+    Storage(T element, grpc_core::Timestamp enqueued)+        : element_(element), enqueued_(enqueued) {}+    ~Storage() = default;+    // not copyable+    Storage(const Storage&) = delete;+    Storage& operator=(const Storage&) = delete;+    // moveable+    Storage(Storage&& other) noexcept+        : element_(other.element_), enqueued_(other.enqueued_) {}+    Storage& operator=(Storage&& other) noexcept {+      std::swap(element_, other.element_);+      std::swap(enqueued_, other.enqueued_);+      return *this;+    }+    grpc_core::Timestamp enqueued() const { return enqueued_; }+    T&& TakeElement() { return std::move(element_); }++   private:+    T element_;+    grpc_core::Timestamp enqueued_ = kInvalidTimestamp;+  };++  WorkQueue() = default;++  // Returns whether the queue is empty+  bool Empty() const {+    return (most_recent_element_enqueue_timestamp_.load(+                std::memory_order_relaxed) == kInvalidTimestamp &&+            oldest_enqueued_timestamp_.load(std::memory_order_relaxed) ==+                kInvalidTimestamp);+  }++  // Returns the number of elements in the queue+  // TODO(hork): this is an expensive method. consider caching the size in an+  // atomic.+  size_t Size() {+    grpc_core::MutexLock lock(&mu_);+    return elements_.size() ++           (most_recent_element_enqueue_timestamp_.load(+                std::memory_order_relaxed) == kInvalidTimestamp+                ? 0+                : 1);+  }+  // Returns the Timestamp of when the most recently-added element was+  // enqueued.+  grpc_core::Timestamp OldestEnqueuedTimestamp() const {+    grpc_core::Timestamp front_of_queue_timestamp =+        oldest_enqueued_timestamp_.load(std::memory_order_relaxed);+    return front_of_queue_timestamp != kInvalidTimestamp+               ? front_of_queue_timestamp+               : most_recent_element_enqueue_timestamp_.load(+                     std::memory_order_relaxed);+  }+  // Returns the next (oldest) element from the queue, or nullopt if empty+  absl::optional<T> PopFront() ABSL_LOCKS_EXCLUDED(mu_) {+    if (oldest_enqueued_timestamp_.load(std::memory_order_relaxed) !=+        kInvalidTimestamp) {+      absl::optional<T> t = TryLockAndPop(/*front=*/true);+      if (t.has_value()) return t;+    }+    if (most_recent_element_enqueue_timestamp_.load(+            std::memory_order_relaxed) != kInvalidTimestamp) {+      return TryPopMostRecentElement();+    }+    return absl::nullopt;+  }+  // Returns the most recent element from the queue, or nullopt if empty+  absl::optional<T> PopBack() {+    if (most_recent_element_enqueue_timestamp_.load(+            std::memory_order_relaxed) != kInvalidTimestamp) {+      return TryPopMostRecentElement();+    }+    if (oldest_enqueued_timestamp_.load(std::memory_order_relaxed) !=+        kInvalidTimestamp) {+      absl::optional<T> t = TryLockAndPop(/*front=*/false);+      if (t.has_value()) return *t;+    }+    return absl::nullopt;+  }+  // Adds an element to the back of the queue+  void Add(T element) {+    grpc_core::ExecCtx exec_ctx;+    T previous_most_recent;+    grpc_core::Timestamp previous_ts;+    {+      absl::optional<T> tmp_element;+      auto now = exec_ctx.Now();+      {+        absl::base_internal::SpinLockHolder lock(&most_recent_element_lock_);+        tmp_element = std::exchange(most_recent_element_, element);+        previous_ts = most_recent_element_enqueue_timestamp_.exchange(+            now, std::memory_order_relaxed);+      }+      if (!tmp_element.has_value() || previous_ts == kInvalidTimestamp) return;+      previous_most_recent = std::move(*tmp_element);+    }+    absl::MutexLock lock(&mu_);+    if (elements_.empty()) {+      oldest_enqueued_timestamp_.store(previous_ts, std::memory_order_relaxed);+    }+    elements_.push_back(Storage{std::move(previous_most_recent), previous_ts});+  }++ private:+  // Attempts to pop from the front of the queue (oldest).+  // This will return nullopt if the queue is empty, or if other workers+  // are already attempting to pop from this queue.+  absl::optional<T> TryLockAndPop(bool front) ABSL_LOCKS_EXCLUDED(mu_) {+    // Do not block the worker if there are other workers trying to pop+    // tasks from this queue.+    if (!mu_.TryLock()) return absl::nullopt;+    auto mu_cleanup = absl::MakeCleanup([this]() {+      mu_.AssertHeld();+      mu_.Unlock();+    });+    if (GPR_UNLIKELY(elements_.empty())) {+      if (most_recent_element_enqueue_timestamp_.load(+              std::memory_order_relaxed) == kInvalidTimestamp) {+        return absl::nullopt;+      }+      if (!most_recent_element_lock_.TryLock()) return absl::nullopt;+      absl::optional<T> ret = absl::nullopt;+      if (GPR_LIKELY(most_recent_element_.has_value())) {+        most_recent_element_enqueue_timestamp_.store(kInvalidTimestamp,+                                                     std::memory_order_relaxed);+        ret = std::exchange(most_recent_element_, absl::nullopt);+      }+      most_recent_element_lock_.Unlock();+      return ret;+    }+    // the queue has elements, let's pop one and update timestamps+    Storage ret_s;+    if (front) {+      ret_s = std::move(elements_.front());+      elements_.pop_front();+    } else {+      ret_s = std::move(elements_.back());+      elements_.pop_back();+    }+    if (elements_.empty()) {+      oldest_enqueued_timestamp_.store(kInvalidTimestamp,+                                       std::memory_order_relaxed);+    } else if (front) {+      oldest_enqueued_timestamp_.store(elements_.front().enqueued(),+                                       std::memory_order_relaxed);+    }+    return ret_s.TakeElement();+  }++  // Attempts to pop from the back of the queue (most recent).+  // This will return nullopt if the queue is empty, or if other workers+  // are already attempting to pop from this queue.+  absl::optional<T> TryPopMostRecentElement() {+    if (!most_recent_element_lock_.TryLock()) return absl::nullopt;+    if (GPR_UNLIKELY(!most_recent_element_.has_value())) {+      most_recent_element_lock_.Unlock();+      return absl::nullopt;+    }+    most_recent_element_enqueue_timestamp_.store(kInvalidTimestamp,+                                                 std::memory_order_relaxed);+    absl::optional<T> tmp = std::exchange(most_recent_element_, absl::nullopt);+    most_recent_element_lock_.Unlock();+    return tmp;+  }++  // The managed items in the queue+  std::deque<Storage> elements_ ABSL_GUARDED_BY(mu_);","Internally in the data center I expect we won't use this class.We will for any non data center apps (mobile, other small devices).",
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/30763,965165395,2022-09-07T18:42:07Z,src/core/lib/event_engine/thread_pool.cc,"@@ -20,138 +20,135 @@  #include ""src/core/lib/event_engine/thread_pool.h"" +#include <memory> #include <utility> +#include <grpc/support/log.h>+ #include ""src/core/lib/gprpp/thd.h""  namespace grpc_event_engine { namespace experimental { -ThreadPool::Thread::Thread(ThreadPool* pool)-    : pool_(pool),-      thd_(-          ""posix_eventengine_pool"",-          [](void* th) { static_cast<ThreadPool::Thread*>(th)->ThreadFunc(); },-          this, nullptr, grpc_core::Thread::Options().set_tracked(false)) {-  thd_.Start();+void ThreadPool::StartThread(StatePtr state) {+  state->thread_count.Add();+  grpc_core::Thread(+      ""event_engine"",+      [](void* arg) {+        ThreadFunc(*std::unique_ptr<StatePtr>(static_cast<StatePtr*>(arg)));+      },+      new StatePtr(state), nullptr,+      grpc_core::Thread::Options().set_tracked(false).set_joinable(false))+      .Start(); }-ThreadPool::Thread::~Thread() { thd_.Join(); }--void ThreadPool::Thread::ThreadFunc() {-  pool_->ThreadFunc();-  // Now that we have killed ourselves, we should reduce the thread count-  grpc_core::MutexLock lock(&pool_->mu_);-  pool_->nthreads_--;-  // Move ourselves to dead list-  pool_->dead_threads_.push_back(this);--  if (pool_->nthreads_ == 0) {-    if (pool_->forking_) pool_->fork_cv_.Signal();-    if (pool_->shutdown_) pool_->shutdown_cv_.Signal();++void ThreadPool::ThreadFunc(StatePtr state) {+  while (state->queue.Step()) {   }+  state->thread_count.Remove(); } -void ThreadPool::ThreadFunc() {-  for (;;) {-    // Wait until work is available or we are shutting down.-    grpc_core::ReleasableMutexLock lock(&mu_);-    if (!forking_ && !shutdown_ && callbacks_.empty()) {-      // If there are too many threads waiting, then quit this thread-      if (threads_waiting_ >= reserve_threads_) {-        break;-      }-      threads_waiting_++;-      cv_.Wait(&mu_);-      threads_waiting_--;-    }-    // a fork could be initiated while the thread was waiting-    if (forking_) return;-    // Drain callbacks before considering shutdown to ensure all work-    // gets completed.-    if (!callbacks_.empty()) {-      auto cb = std::move(callbacks_.front());-      callbacks_.pop();-      lock.Release();-      cb();-    } else if (shutdown_) {+bool ThreadPool::Queue::Step() {+  grpc_core::ReleasableMutexLock lock(&mu_);+  // Wait until work is available or we are shutting down.+  while (state_ == State::kRunning && callbacks_.empty()) {+    // If there are too many threads waiting, then quit this thread.+    // TODO(ctiller): wait some time in this case to be sure.+    if (threads_waiting_ >= reserve_threads_) return false;+    threads_waiting_++;+    cv_.Wait(&mu_);+    threads_waiting_--;+  }+  switch (state_) {+    case State::kRunning:       break;-    }+    case State::kShutdown:+    case State::kForking:+      if (!callbacks_.empty()) break;","I think this change in behavior could cause a hang on fork or shutdown. If a callback queues more callbacks, `Queue::Add` will take those on even if state==kForking, and ThreadFunc will continue to execute until all the callbacks are exhausted. Instead, callback execution could be halted until the fork completes.I believe it's straightforward to test. Create a callback that sleeps a bit and schedules its own next iteration, then exits when some post-fork condition is met. Then start a thread that calls PreFork (which I think will hang) and PostForkParent, then sets the post-fork condition. The whole thing should complete in < 5s conservatively (probably millis on an unloaded system).",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/30580,965327321,2022-09-07T21:45:58Z,test/core/end2end/tests/hpack_size.cc,"@@ -386,11 +392,22 @@ void hpack_size(grpc_end2end_test_config config) {                                           1000, 32768, 4 * 1024 * 1024};   size_t i, j; +  std::vector<std::shared_ptr<absl::Notification>> dones;   for (i = 0; i < GPR_ARRAY_SIZE(interesting_sizes); i++) {     for (j = 0; j < GPR_ARRAY_SIZE(interesting_sizes); j++) {-      test_size(config, interesting_sizes[i], interesting_sizes[j]);+      auto done = std::make_shared<absl::Notification>();+      dones.push_back(done);+      grpc_event_engine::experimental::GetDefaultEventEngine()->Run(+          [done, config, i, j] {","true... but without it we don't need an indexing scheme, so it's kind of brain dead - which I think is the right tradeoff for a test",
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/30902,966514620,2022-09-09T00:05:31Z,bazel/grpc_deps.bzl,"@@ -254,11 +254,11 @@ def grpc_deps():     if ""com_github_google_benchmark"" not in native.existing_rules():         http_archive(             name = ""com_github_google_benchmark"",-            sha256 = ""0b921a3bc39e35f4275c8dcc658af2391c150fb966102341287b0401ff2e6f21"",-            strip_prefix = ""benchmark-0baacde3618ca617da95375e0af13ce1baadea47"",+            sha256 = ""3a43368d3ec48afe784573cf962fe98c084e89a1e3d176c00715a84366316e7d"",+            strip_prefix = ""benchmark-361e8d1cfe0c6c36d30b39f1b61302ece5507320"",             urls = [-                ""https://storage.googleapis.com/grpc-bazel-mirror/github.com/google/benchmark/archive/0baacde3618ca617da95375e0af13ce1baadea47.tar.gz"",-                ""https://github.com/google/benchmark/archive/0baacde3618ca617da95375e0af13ce1baadea47.tar.gz"",+                ""https://storage.googleapis.com/grpc-bazel-mirror/github.com/google/benchmark/archive/361e8d1cfe0c6c36d30b39f1b61302ece5507320.tar.gz"",+                ""https://github.com/google/benchmark/archive/361e8d1cfe0c6c36d30b39f1b61302ece5507320.tar.gz"",","Reverted. The `check_bazel_workspace.py` sanity check doesn't support tags generally, it expects git hashes. That improvement is out of scope for a dependency upgrade PR.",
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/30821,966519043,2022-09-09T00:16:31Z,src/core/lib/event_engine/workqueue.h,"@@ -0,0 +1,238 @@+// Copyright 2022 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+#ifndef GRPC_CORE_LIB_EVENT_ENGINE_WORKQUEUE_H+#define GRPC_CORE_LIB_EVENT_ENGINE_WORKQUEUE_H++#include <grpc/support/port_platform.h>++#include <stddef.h>++#include <atomic>+#include <deque>+#include <utility>++#include ""absl/base/internal/spinlock.h""+#include ""absl/base/thread_annotations.h""+#include ""absl/cleanup/cleanup.h""+#include ""absl/synchronization/mutex.h""+#include ""absl/types/optional.h""++#include ""src/core/lib/gprpp/sync.h""+#include ""src/core/lib/gprpp/time.h""+#include ""src/core/lib/iomgr/exec_ctx.h""++namespace grpc_event_engine {+namespace experimental {++// A fast work queue based lightly on an internal Google implementation.+//+// This uses atomics and lightweight spinlocks to access the most recent element+// in the queue, making it fast for LIFO operations. Accessing the oldest (next)+// element requires taking a mutex lock.+template <typename T>+class WorkQueue {+ public:+  static const grpc_core::Timestamp kInvalidTimestamp;++  class Storage {+   public:+    Storage() = default;+    Storage(T element, grpc_core::Timestamp enqueued)+        : element_(element), enqueued_(enqueued) {}+    ~Storage() = default;+    // not copyable+    Storage(const Storage&) = delete;+    Storage& operator=(const Storage&) = delete;+    // moveable+    Storage(Storage&& other) noexcept+        : element_(other.element_), enqueued_(other.enqueued_) {}+    Storage& operator=(Storage&& other) noexcept {+      std::swap(element_, other.element_);+      std::swap(enqueued_, other.enqueued_);+      return *this;+    }+    grpc_core::Timestamp enqueued() const { return enqueued_; }+    T&& TakeElement() { return std::move(element_); }++   private:+    T element_;+    grpc_core::Timestamp enqueued_ = kInvalidTimestamp;+  };++  WorkQueue() = default;++  // Returns whether the queue is empty+  bool Empty() const {+    return (most_recent_element_enqueue_timestamp_.load(+                std::memory_order_relaxed) == kInvalidTimestamp &&+            oldest_enqueued_timestamp_.load(std::memory_order_relaxed) ==+                kInvalidTimestamp);+  }++  // Returns the number of elements in the queue+  // TODO(hork): this is an expensive method. consider caching the size in an+  // atomic.+  size_t Size() {+    grpc_core::MutexLock lock(&mu_);+    return elements_.size() ++           (most_recent_element_enqueue_timestamp_.load(+                std::memory_order_relaxed) == kInvalidTimestamp+                ? 0+                : 1);+  }+  // Returns the Timestamp of when the most recently-added element was+  // enqueued.+  grpc_core::Timestamp OldestEnqueuedTimestamp() const {+    grpc_core::Timestamp front_of_queue_timestamp =+        oldest_enqueued_timestamp_.load(std::memory_order_relaxed);+    return front_of_queue_timestamp != kInvalidTimestamp+               ? front_of_queue_timestamp+               : most_recent_element_enqueue_timestamp_.load(+                     std::memory_order_relaxed);+  }+  // Returns the next (oldest) element from the queue, or nullopt if empty+  absl::optional<T> PopFront() ABSL_LOCKS_EXCLUDED(mu_) {+    if (oldest_enqueued_timestamp_.load(std::memory_order_relaxed) !=+        kInvalidTimestamp) {+      absl::optional<T> t = TryLockAndPop(/*front=*/true);+      if (t.has_value()) return t;+    }+    if (most_recent_element_enqueue_timestamp_.load(+            std::memory_order_relaxed) != kInvalidTimestamp) {+      return TryPopMostRecentElement();+    }+    return absl::nullopt;+  }+  // Returns the most recent element from the queue, or nullopt if empty+  absl::optional<T> PopBack() {+    if (most_recent_element_enqueue_timestamp_.load(+            std::memory_order_relaxed) != kInvalidTimestamp) {+      return TryPopMostRecentElement();+    }+    if (oldest_enqueued_timestamp_.load(std::memory_order_relaxed) !=+        kInvalidTimestamp) {+      absl::optional<T> t = TryLockAndPop(/*front=*/false);+      if (t.has_value()) return *t;+    }+    return absl::nullopt;+  }+  // Adds an element to the back of the queue+  void Add(T element) {+    grpc_core::ExecCtx exec_ctx;+    T previous_most_recent;+    grpc_core::Timestamp previous_ts;+    {+      absl::optional<T> tmp_element;+      auto now = exec_ctx.Now();+      {+        absl::base_internal::SpinLockHolder lock(&most_recent_element_lock_);+        tmp_element = std::exchange(most_recent_element_, element);+        previous_ts = most_recent_element_enqueue_timestamp_.exchange(+            now, std::memory_order_relaxed);+      }+      if (!tmp_element.has_value() || previous_ts == kInvalidTimestamp) return;+      previous_most_recent = std::move(*tmp_element);+    }+    absl::MutexLock lock(&mu_);+    if (elements_.empty()) {+      oldest_enqueued_timestamp_.store(previous_ts, std::memory_order_relaxed);+    }+    elements_.push_back(Storage{std::move(previous_most_recent), previous_ts});+  }++ private:+  // Attempts to pop from the front of the queue (oldest).+  // This will return nullopt if the queue is empty, or if other workers+  // are already attempting to pop from this queue.+  absl::optional<T> TryLockAndPop(bool front) ABSL_LOCKS_EXCLUDED(mu_) {+    // Do not block the worker if there are other workers trying to pop+    // tasks from this queue.+    if (!mu_.TryLock()) return absl::nullopt;+    auto mu_cleanup = absl::MakeCleanup([this]() {+      mu_.AssertHeld();+      mu_.Unlock();+    });+    if (GPR_UNLIKELY(elements_.empty())) {+      if (most_recent_element_enqueue_timestamp_.load(+              std::memory_order_relaxed) == kInvalidTimestamp) {+        return absl::nullopt;+      }+      if (!most_recent_element_lock_.TryLock()) return absl::nullopt;+      absl::optional<T> ret = absl::nullopt;+      if (GPR_LIKELY(most_recent_element_.has_value())) {+        most_recent_element_enqueue_timestamp_.store(kInvalidTimestamp,+                                                     std::memory_order_relaxed);+        ret = std::exchange(most_recent_element_, absl::nullopt);+      }+      most_recent_element_lock_.Unlock();+      return ret;+    }+    // the queue has elements, let's pop one and update timestamps+    Storage ret_s;+    if (front) {+      ret_s = std::move(elements_.front());+      elements_.pop_front();+    } else {+      ret_s = std::move(elements_.back());+      elements_.pop_back();+    }+    if (elements_.empty()) {+      oldest_enqueued_timestamp_.store(kInvalidTimestamp,+                                       std::memory_order_relaxed);+    } else if (front) {+      oldest_enqueued_timestamp_.store(elements_.front().enqueued(),+                                       std::memory_order_relaxed);+    }+    return ret_s.TakeElement();+  }++  // Attempts to pop from the back of the queue (most recent).+  // This will return nullopt if the queue is empty, or if other workers+  // are already attempting to pop from this queue.+  absl::optional<T> TryPopMostRecentElement() {+    if (!most_recent_element_lock_.TryLock()) return absl::nullopt;+    if (GPR_UNLIKELY(!most_recent_element_.has_value())) {+      most_recent_element_lock_.Unlock();+      return absl::nullopt;+    }+    most_recent_element_enqueue_timestamp_.store(kInvalidTimestamp,+                                                 std::memory_order_relaxed);+    absl::optional<T> tmp = std::exchange(most_recent_element_, absl::nullopt);+    most_recent_element_lock_.Unlock();+    return tmp;+  }++  // The managed items in the queue+  std::deque<Storage> elements_ ABSL_GUARDED_BY(mu_);","Most of the 4k would be unused in our current use cases, so I can see about a ring buffer implementation. From what I've seen so far though, I'd expect under 10 threads in the pool for the current workloads, so < 50Kb added memory with the global queue included. That's well within the ""medium bloat"" labeling.",
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/30763,967411172,2022-09-09T19:45:07Z,src/core/lib/event_engine/thread_pool.cc,"@@ -20,138 +20,135 @@  #include ""src/core/lib/event_engine/thread_pool.h"" +#include <memory> #include <utility> +#include <grpc/support/log.h>+ #include ""src/core/lib/gprpp/thd.h""  namespace grpc_event_engine { namespace experimental { -ThreadPool::Thread::Thread(ThreadPool* pool)-    : pool_(pool),-      thd_(-          ""posix_eventengine_pool"",-          [](void* th) { static_cast<ThreadPool::Thread*>(th)->ThreadFunc(); },-          this, nullptr, grpc_core::Thread::Options().set_tracked(false)) {-  thd_.Start();+void ThreadPool::StartThread(StatePtr state) {+  state->thread_count.Add();+  grpc_core::Thread(+      ""event_engine"",+      [](void* arg) {+        ThreadFunc(*std::unique_ptr<StatePtr>(static_cast<StatePtr*>(arg)));+      },+      new StatePtr(state), nullptr,+      grpc_core::Thread::Options().set_tracked(false).set_joinable(false))+      .Start(); }-ThreadPool::Thread::~Thread() { thd_.Join(); }--void ThreadPool::Thread::ThreadFunc() {-  pool_->ThreadFunc();-  // Now that we have killed ourselves, we should reduce the thread count-  grpc_core::MutexLock lock(&pool_->mu_);-  pool_->nthreads_--;-  // Move ourselves to dead list-  pool_->dead_threads_.push_back(this);--  if (pool_->nthreads_ == 0) {-    if (pool_->forking_) pool_->fork_cv_.Signal();-    if (pool_->shutdown_) pool_->shutdown_cv_.Signal();++void ThreadPool::ThreadFunc(StatePtr state) {+  while (state->queue.Step()) {   }+  state->thread_count.Remove(); } -void ThreadPool::ThreadFunc() {-  for (;;) {-    // Wait until work is available or we are shutting down.-    grpc_core::ReleasableMutexLock lock(&mu_);-    if (!forking_ && !shutdown_ && callbacks_.empty()) {-      // If there are too many threads waiting, then quit this thread-      if (threads_waiting_ >= reserve_threads_) {-        break;-      }-      threads_waiting_++;-      cv_.Wait(&mu_);-      threads_waiting_--;-    }-    // a fork could be initiated while the thread was waiting-    if (forking_) return;-    // Drain callbacks before considering shutdown to ensure all work-    // gets completed.-    if (!callbacks_.empty()) {-      auto cb = std::move(callbacks_.front());-      callbacks_.pop();-      lock.Release();-      cb();-    } else if (shutdown_) {+bool ThreadPool::Queue::Step() {+  grpc_core::ReleasableMutexLock lock(&mu_);+  // Wait until work is available or we are shutting down.+  while (state_ == State::kRunning && callbacks_.empty()) {+    // If there are too many threads waiting, then quit this thread.+    // TODO(ctiller): wait some time in this case to be sure.+    if (threads_waiting_ >= reserve_threads_) return false;+    threads_waiting_++;+    cv_.Wait(&mu_);+    threads_waiting_--;+  }+  switch (state_) {+    case State::kRunning:       break;-    }+    case State::kShutdown:+    case State::kForking:+      if (!callbacks_.empty()) break;","Fair point, that test is problematic, but the broader problem still exists. My suggestion is to either (A) queue but not run all new closures until the fork is complete, or (B) refuse accepting new closures until the fork completes. I think (B) is more problematic because closures will have to handle pool refusals when they should be able to ignore forks. Doing neither I believe guarantees the possibility of a never-ending fork.```void ScheduleChainedCallback(ThreadPool& pool, Promise& forked, Promise& done) {  // do work, then ...  if (forked.WaitWithTimeout(Duration::Zero())) {    done.Set(true);    return;  }  pool.Add([&] { ScheduleChainedCallback(pool, forked, done); });}TEST(ThreadPoolTest, ForkProceeds) {  ThreadPool pool(1);  grpc_event_engine::experimental::Promise<bool> forked(false);  grpc_event_engine::experimental::Promise<bool> done(false);  ScheduleChainedCallback(pool, forked, done);  pool.PrepareFork();  pool.PostforkParent();  forked.Set(true);  ASSERT_TRUE(done.Get());}```You can replace the fork promise check with any real-life boundary condition appropriate for that work (i.e., keep doing this work until X, assuming a fork happens before X). I think that's a legitimate use case, one we've talked about with the poller interface in fact. Does that make sense?",
4181124,yashykt,https://api.github.com/repos/grpc/grpc/pulls/30823,967487878,2022-09-09T21:15:32Z,test/core/xds/xds_transport_fake.h,"@@ -0,0 +1,180 @@+//+// Copyright 2022 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+//++#ifndef GRPC_CORE_EXT_XDS_XDS_TRANSPORT_FAKE_H+#define GRPC_CORE_EXT_XDS_XDS_TRANSPORT_FAKE_H++#include <grpc/support/port_platform.h>++#include <deque>+#include <functional>+#include <memory>+#include <string>++#include ""absl/status/status.h""+#include ""absl/types/optional.h""++#include ""src/core/ext/xds/xds_bootstrap.h""+#include ""src/core/ext/xds/xds_transport.h""+#include ""src/core/lib/gprpp/orphanable.h""+#include ""src/core/lib/gprpp/ref_counted_ptr.h""+#include ""src/core/lib/gprpp/sync.h""++namespace grpc_core {++class FakeXdsTransportFactory : public XdsTransportFactory {+ private:+  class FakeXdsTransport;++ public:+  static constexpr char kAdsMethod[] =+      ""/envoy.service.discovery.v3.AggregatedDiscoveryService/""+      ""StreamAggregatedResources"";+  static constexpr char kAdsV2Method[] =+      ""/envoy.service.discovery.v2.AggregatedDiscoveryService/""+      ""StreamAggregatedResources"";++  class FakeStreamingCall : public XdsTransport::StreamingCall {+   public:+    FakeStreamingCall(+        RefCountedPtr<FakeXdsTransport> transport, const char* method,+        std::unique_ptr<StreamingCall::EventHandler> event_handler)+        : transport_(std::move(transport)),+          method_(method),+          event_handler_(MakeRefCounted<RefCountedEventHandler>(+              std::move(event_handler))) {}++    void Orphan() override;++    using StreamingCall::Ref;  // Make it public.++    bool HaveMessageFromClient();+    absl::optional<std::string> WaitForMessageFromClient(+        absl::Duration timeout);++    void SendMessageToClient(absl::string_view payload);+    void MaybeSendStatusToClient(absl::Status status);++   private:+    class RefCountedEventHandler : public RefCounted<RefCountedEventHandler> {",would it make sense to just make `EventHandler` as a Refcounted class,
5564114,Vignesh2208,https://api.github.com/repos/grpc/grpc/pulls/30383,967543548,2022-09-09T23:47:28Z,src/core/lib/event_engine/posix_engine/tcp_socket_utils.cc,"@@ -0,0 +1,851 @@+// Copyright 2022 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++#include <grpc/support/port_platform.h>++#include <netinet/in.h>++#include <grpc/event_engine/event_engine.h>++#include ""src/core/lib/iomgr/port.h""++#ifdef GRPC_POSIX_SOCKET_UTILS_COMMON+#ifdef GRPC_LINUX_TCP_H+#include <linux/tcp.h>+#else+#include <netinet/tcp.h>+#endif+#include <fcntl.h>+#include <sys/socket.h>+#include <unistd.h>+#endif++#include <cstring>++#include ""absl/status/status.h""+#include ""absl/strings/str_format.h""++#include <grpc/impl/codegen/grpc_types.h>+#include <grpc/support/log.h>++#include ""src/core/lib/event_engine/posix_engine/tcp_socket_utils.h""+#include ""src/core/lib/gprpp/host_port.h""++#ifdef GRPC_HAVE_UNIX_SOCKET+#include <sys/un.h>+#endif++namespace grpc_event_engine {+namespace posix_engine {++using ::grpc_event_engine::experimental::EndpointConfig;+using ::grpc_event_engine::experimental::EventEngine;++namespace {++int AdjustValue(int default_value, int min_value, int max_value,+                absl::optional<int> actual_value) {+  if (!actual_value.has_value() || *actual_value < min_value ||","I checked this. I don't think we should be using a Clamp here. Some parameters such as keep_alive_time_ms is set to 0  (default) to disable it if its not included in the EndpointConfig. Clamping this parameter would result in keep_alive_time_ms getting enabled and set a value of 1ms when that wasn't the original intention. The same is true for a few other parameters as well. For these parameters, a value of 0 is interpreted differently compared to positive values.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/30823,967544079,2022-09-09T23:49:56Z,test/core/xds/xds_transport_fake.h,"@@ -0,0 +1,180 @@+//+// Copyright 2022 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+//++#ifndef GRPC_CORE_EXT_XDS_XDS_TRANSPORT_FAKE_H+#define GRPC_CORE_EXT_XDS_XDS_TRANSPORT_FAKE_H++#include <grpc/support/port_platform.h>++#include <deque>+#include <functional>+#include <memory>+#include <string>++#include ""absl/status/status.h""+#include ""absl/types/optional.h""++#include ""src/core/ext/xds/xds_bootstrap.h""+#include ""src/core/ext/xds/xds_transport.h""+#include ""src/core/lib/gprpp/orphanable.h""+#include ""src/core/lib/gprpp/ref_counted_ptr.h""+#include ""src/core/lib/gprpp/sync.h""++namespace grpc_core {++class FakeXdsTransportFactory : public XdsTransportFactory {+ private:+  class FakeXdsTransport;++ public:+  static constexpr char kAdsMethod[] =+      ""/envoy.service.discovery.v3.AggregatedDiscoveryService/""+      ""StreamAggregatedResources"";+  static constexpr char kAdsV2Method[] =+      ""/envoy.service.discovery.v2.AggregatedDiscoveryService/""+      ""StreamAggregatedResources"";++  class FakeStreamingCall : public XdsTransport::StreamingCall {+   public:+    FakeStreamingCall(+        RefCountedPtr<FakeXdsTransport> transport, const char* method,+        std::unique_ptr<StreamingCall::EventHandler> event_handler)+        : transport_(std::move(transport)),+          method_(method),+          event_handler_(MakeRefCounted<RefCountedEventHandler>(+              std::move(event_handler))) {}++    void Orphan() override;++    using StreamingCall::Ref;  // Make it public.++    bool HaveMessageFromClient();+    absl::optional<std::string> WaitForMessageFromClient(+        absl::Duration timeout);++    void SendMessageToClient(absl::string_view payload);+    void MaybeSendStatusToClient(absl::Status status);++   private:+    class RefCountedEventHandler : public RefCounted<RefCountedEventHandler> {","In the production code, it doesn't actually need to be ref-counted; the ref-counting is needed only here in the test code.  I don't think it makes sense to add complexity to the production code for something we need only in the test.",
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/30815,967544224,2022-09-09T23:50:30Z,src/core/lib/gprpp/time.h,"@@ -70,6 +100,8 @@ class Timestamp {   static Timestamp FromCycleCounterRoundUp(gpr_cycle_counter c);   static Timestamp FromCycleCounterRoundDown(gpr_cycle_counter c); +  static Timestamp Now() { return source_->Now(); }",Every replacement of `ExecCtx::Now` with `Timestamp::Now` in this PR is no longer using cached time. Was that intentional?,
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/30763,967557811,2022-09-10T01:03:29Z,src/core/lib/event_engine/thread_pool.cc,"@@ -20,138 +20,135 @@  #include ""src/core/lib/event_engine/thread_pool.h"" +#include <memory> #include <utility> +#include <grpc/support/log.h>+ #include ""src/core/lib/gprpp/thd.h""  namespace grpc_event_engine { namespace experimental { -ThreadPool::Thread::Thread(ThreadPool* pool)-    : pool_(pool),-      thd_(-          ""posix_eventengine_pool"",-          [](void* th) { static_cast<ThreadPool::Thread*>(th)->ThreadFunc(); },-          this, nullptr, grpc_core::Thread::Options().set_tracked(false)) {-  thd_.Start();+void ThreadPool::StartThread(StatePtr state) {+  state->thread_count.Add();+  grpc_core::Thread(+      ""event_engine"",+      [](void* arg) {+        ThreadFunc(*std::unique_ptr<StatePtr>(static_cast<StatePtr*>(arg)));+      },+      new StatePtr(state), nullptr,+      grpc_core::Thread::Options().set_tracked(false).set_joinable(false))+      .Start(); }-ThreadPool::Thread::~Thread() { thd_.Join(); }--void ThreadPool::Thread::ThreadFunc() {-  pool_->ThreadFunc();-  // Now that we have killed ourselves, we should reduce the thread count-  grpc_core::MutexLock lock(&pool_->mu_);-  pool_->nthreads_--;-  // Move ourselves to dead list-  pool_->dead_threads_.push_back(this);--  if (pool_->nthreads_ == 0) {-    if (pool_->forking_) pool_->fork_cv_.Signal();-    if (pool_->shutdown_) pool_->shutdown_cv_.Signal();++void ThreadPool::ThreadFunc(StatePtr state) {+  while (state->queue.Step()) {   }+  state->thread_count.Remove(); } -void ThreadPool::ThreadFunc() {-  for (;;) {-    // Wait until work is available or we are shutting down.-    grpc_core::ReleasableMutexLock lock(&mu_);-    if (!forking_ && !shutdown_ && callbacks_.empty()) {-      // If there are too many threads waiting, then quit this thread-      if (threads_waiting_ >= reserve_threads_) {-        break;-      }-      threads_waiting_++;-      cv_.Wait(&mu_);-      threads_waiting_--;-    }-    // a fork could be initiated while the thread was waiting-    if (forking_) return;-    // Drain callbacks before considering shutdown to ensure all work-    // gets completed.-    if (!callbacks_.empty()) {-      auto cb = std::move(callbacks_.front());-      callbacks_.pop();-      lock.Release();-      cb();-    } else if (shutdown_) {+bool ThreadPool::Queue::Step() {+  grpc_core::ReleasableMutexLock lock(&mu_);+  // Wait until work is available or we are shutting down.+  while (state_ == State::kRunning && callbacks_.empty()) {+    // If there are too many threads waiting, then quit this thread.+    // TODO(ctiller): wait some time in this case to be sure.+    if (threads_waiting_ >= reserve_threads_) return false;+    threads_waiting_++;+    cv_.Wait(&mu_);+    threads_waiting_--;+  }+  switch (state_) {+    case State::kRunning:       break;-    }+    case State::kShutdown:+    case State::kForking:+      if (!callbacks_.empty()) break;","So my contention here is still: if that X wants to go forever, it needs to factor in wanting to fork as being the end of its forever.The real life instance that I can think of for wanting to continually call a callback is for polling/timer checks, and that I think should be fork aware. I think other instances are the same, but would be happy to see a contra case.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/30931,968656310,2022-09-12T16:54:49Z,src/core/ext/filters/client_channel/lb_policy/oob_backend_metric.cc,"@@ -384,14 +384,23 @@ OrcaWatcher::~OrcaWatcher() { }  void OrcaWatcher::SetSubchannel(Subchannel* subchannel) {+  bool created = false;   // Check if our producer is already registered with the subchannel.-  // If not, create a new one, which will register itself with the subchannel.-  auto* p = static_cast<OrcaProducer*>(-      subchannel->GetDataProducer(OrcaProducer::Type()));-  if (p != nullptr) producer_ = p->RefIfNonZero();-  if (producer_ == nullptr) {-    producer_ = MakeRefCounted<OrcaProducer>(subchannel->Ref());-  }+  // If not, create a new one.+  subchannel->GetOrAddDataProducer(+      OrcaProducer::Type(), [&](Subchannel::DataProducerInterface** producer) {+        if (*producer != nullptr) producer_ = (*producer)->RefIfNonZero();+        if (producer_ == nullptr) {+          producer_ = MakeRefCounted<OrcaProducer>();+          *producer = producer_.get();+          created = true;+        }+      });+  // If we just created the producer, start it.+  // This needs to be done outside of the lambda passed to+  // GetOrAddDataProducer() to avoid deadlocking by re-acquiring the+  // subchannel lock while already holding it.+  if (created) producer_->Start(subchannel->Ref());   // Register ourself with the producer.   producer_->AddWatcher(this);","I think this would already be handled properly.  Note that `Start()` does not actually start the ORCA stream; what it starts is the connectivity state watch on the subchannel.  When the connectivity state watch reports READY, then if the watcher map is non-empty, we start the ORCA stream:https://github.com/grpc/grpc/blob/bcd8c991e62b4d6326e6dc61ff1aa3bea2b3f35a/src/core/ext/filters/client_channel/lb_policy/oob_backend_metric.cc#L371So I don't think it matters if `AddWatcher()` is called before `Start()`.  The only distinction that does matter is whether `AddWatcher()` is called before or after we see READY state, and I think the code is already handling this properly.",
11522026,ralphchung,https://api.github.com/repos/grpc/grpc/pulls/30414,968704762,2022-09-12T17:27:49Z,include/grpcpp/impl/grpc_library.h,"@@ -24,25 +24,34 @@ #include <grpc/grpc.h> #include <grpcpp/impl/codegen/config.h> #include <grpcpp/impl/codegen/core_codegen.h>-#include <grpcpp/impl/codegen/grpc_library.h>  // IWYU pragma: export  namespace grpc {  namespace internal {-class GrpcLibrary final : public GrpcLibraryInterface {++/// Classes that require gRPC to be initialized should inherit from this class.+class GrpcLibrary {  public:-  void init() override { grpc_init(); }-  void shutdown() override { grpc_shutdown(); }+  explicit GrpcLibrary(bool call_grpc_init = true) : grpc_init_called_(false) {+    if (call_grpc_init) {+      grpc_init();",It seems calling `grpc_core::InitInternally()` here might experience race condition. @ctiller do you have any suggestion on this?,
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/29598,968765023,2022-09-12T18:20:43Z,src/core/lib/surface/call.cc,"@@ -1740,8 +1794,1024 @@ void FilterStackCall::ContextSet(grpc_context_index elem, void* value,   context_[elem].destroy = destroy; } +///////////////////////////////////////////////////////////////////////////////+// PromiseBasedCall+// Will be folded into Call once the promise conversion is done++class PromiseBasedCall : public Call, public Activity, public Wakeable {+ public:+  PromiseBasedCall(Arena* arena, const grpc_call_create_args& args);++  void ContextSet(grpc_context_index elem, void* value,+                  void (*destroy)(void* value)) override;+  void* ContextGet(grpc_context_index elem) const override;+  void SetCompletionQueue(grpc_completion_queue* cq) override;++  // Implementation of call refcounting: move this to DualRefCounted once we","Maybe try making `PromiseBasedCall` use `DualRefCounted<>` and have the {Internal,External}{Ref,Unref} methods from the `Call` base class delegate to the corresponding `DualRefCounting<>` methods?As discussed, feel free to give this a quick try and fail fast if it doesn't work for some reason.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/29598,968805070,2022-09-12T18:54:25Z,src/core/lib/surface/call.cc,"@@ -1740,8 +1794,1024 @@ void FilterStackCall::ContextSet(grpc_context_index elem, void* value,   context_[elem].destroy = destroy; } +///////////////////////////////////////////////////////////////////////////////+// PromiseBasedCall+// Will be folded into Call once the promise conversion is done++class PromiseBasedCall : public Call, public Activity, public Wakeable {+ public:+  PromiseBasedCall(Arena* arena, const grpc_call_create_args& args);++  void ContextSet(grpc_context_index elem, void* value,+                  void (*destroy)(void* value)) override;+  void* ContextGet(grpc_context_index elem) const override;+  void SetCompletionQueue(grpc_completion_queue* cq) override;++  // Implementation of call refcounting: move this to DualRefCounted once we+  // don't need to maintain FilterStackCall compatibility+  void ExternalRef() final {+    refs_.fetch_add(MakeRefPair(1, 0), std::memory_order_relaxed);+  }+  void ExternalUnref() final {+    const uint64_t prev_ref_pair =+        refs_.fetch_add(MakeRefPair(-1, 1), std::memory_order_acq_rel);+    const uint32_t strong_refs = GetStrongRefs(prev_ref_pair);+    if (GPR_UNLIKELY(strong_refs == 1)) {+      Orphan();+    }+    // Now drop the weak ref.+    InternalUnref(""external_ref"");+  }+  void InternalRef(const char*) final {+    refs_.fetch_add(MakeRefPair(0, 1), std::memory_order_relaxed);+  }+  void InternalUnref(const char*) final {+    const uint64_t prev_ref_pair =+        refs_.fetch_sub(MakeRefPair(0, 1), std::memory_order_acq_rel);+    if (GPR_UNLIKELY(prev_ref_pair == MakeRefPair(0, 1))) {+      DeleteThis();+    }+  }++  // Activity methods+  void ForceImmediateRepoll() ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu_) override;+  Waker MakeOwningWaker() ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu_) override {+    InternalRef(""wakeup"");+#if defined(__has_feature)+#if __has_feature(address_sanitizer)+#define GRPC_CALL_USES_ASAN_WAKER+    class AsanWaker final : public Wakeable {+     public:+      explicit AsanWaker(PromiseBasedCall* call) : call_(call) {}++      void Wakeup() override {+        call_->Wakeup();+        delete this;+      }++      void Drop() override {+        call_->Drop();+        delete this;+      }++      std::string ActivityDebugTag() const override {+        return call_->DebugTag();+      }++     private:+      PromiseBasedCall* call_;+    };+    return Waker(new AsanWaker(this));+#endif+#endif+#ifndef GRPC_CALL_USES_ASAN_WAKER+    return Waker(this);+#endif+  }+  Waker MakeNonOwningWaker() ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu_) override;++  // Wakeable methods+  void Wakeup() override {+    grpc_event_engine::experimental::GetDefaultEventEngine()->Run([this] {+      ApplicationCallbackExecCtx app_exec_ctx;+      ExecCtx exec_ctx;+      {+        ScopedContext activity_context(this);+        MutexLock lock(&mu_);+        Update();+      }+      InternalUnref(""wakeup"");+    });+  }+  void Drop() override { InternalUnref(""wakeup""); }++  void InContext(absl::AnyInvocable<void()> fn) {+    if (Activity::current() == this) {+      fn();+    } else {+      InternalRef(""in_context"");+      grpc_event_engine::experimental::GetDefaultEventEngine()->Run(+          [this, fn = std::move(fn)]() mutable {+            ExecCtx exec_ctx;+            {+              ScopedContext activity_context(this);+              MutexLock lock(&mu_);+              fn();+              Update();+            }+            InternalUnref(""in_context"");+          });+    }+  }++  grpc_compression_algorithm test_only_compression_algorithm() override {+    abort();+  }+  uint32_t test_only_message_flags() override { abort(); }+  uint32_t test_only_encodings_accepted_by_peer() override { abort(); }+  grpc_compression_algorithm compression_for_level(+      grpc_compression_level level) override {+    abort();+  }++  // This should return nullptr for the promise stack (and alternative means+  // for that functionality be invented)+  grpc_call_stack* call_stack() override { return nullptr; }++ protected:+  class ScopedContext+      : public ScopedActivity,+        public promise_detail::Context<Arena>,+        public promise_detail::Context<grpc_call_context_element>,+        public promise_detail::Context<CallContext>,+        public promise_detail::Context<CallFinalization>,+        public promise_detail::Context<FragmentAllocator> {+   public:+    explicit ScopedContext(PromiseBasedCall* call)+        : ScopedActivity(call),+          promise_detail::Context<Arena>(call->arena()),+          promise_detail::Context<grpc_call_context_element>(call->context_),+          promise_detail::Context<CallContext>(&call->call_context_),+          promise_detail::Context<CallFinalization>(&call->finalization_),+          promise_detail::Context<FragmentAllocator>(+              &call->fragment_allocator_) {}+  };++  class Completion {+   public:+    Completion() : index_(kNullIndex) {}+    ~Completion() { GPR_ASSERT(index_ == kNullIndex); }+    explicit Completion(uint8_t index) : index_(index) {}+    Completion(const Completion& other) = delete;+    Completion& operator=(const Completion& other) = delete;+    Completion(Completion&& other) noexcept : index_(other.index_) {+      other.index_ = kNullIndex;+    }+    Completion& operator=(Completion&& other) noexcept {+      GPR_ASSERT(index_ == kNullIndex);+      index_ = other.index_;+      other.index_ = kNullIndex;+      return *this;+    }++    uint8_t index() const { return index_; }+    uint8_t TakeIndex() { return absl::exchange(index_, kNullIndex); }+    bool has_value() const { return index_ != kNullIndex; }++    std::string ToString() const {+      return index_ == kNullIndex ? ""null""+                                  : std::to_string(static_cast<int>(index_));+    }++   private:+    enum : uint8_t { kNullIndex = 0xff };+    uint8_t index_;+  };++  ~PromiseBasedCall() override {+    if (non_owning_wakeable_) non_owning_wakeable_->DropActivity();+    if (cq_) GRPC_CQ_INTERNAL_UNREF(cq_, ""bind"");+  }++  enum class PauseReason {+    kStartingBatch = 0,+    kReceiveInitialMetadata,+    kReceiveStatusOnClient,+    kSendMessage,+    kReceiveMessage,+  };++  static constexpr const char* PauseReasonString(PauseReason reason) {+    switch (reason) {+      case PauseReason::kStartingBatch:+        return ""StartingBatch"";+      case PauseReason::kReceiveInitialMetadata:+        return ""ReceiveInitialMetadata"";+      case PauseReason::kReceiveStatusOnClient:+        return ""ReceiveStatusOnClient"";+      case PauseReason::kSendMessage:+        return ""SendMessage"";+      case PauseReason::kReceiveMessage:+        return ""ReceiveMessage"";+    }+    return ""Unknown"";+  }++  static constexpr uint8_t PauseReasonBit(PauseReason reason) {+    return 1 << static_cast<int>(reason);+  }++  Mutex* mu() const ABSL_LOCK_RETURNED(mu_) { return &mu_; }++  Completion StartCompletion(void* tag, bool is_closure, const grpc_op* ops,+                             size_t num_ops) ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu_);+  void FinishCompletion(Completion* completion, PauseReason reason)+      ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu_);+  void FailCompletion(const Completion& completion);+  Completion PauseCompletion(const Completion& completion, PauseReason reason)+      ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu_);+  void Update() ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu_);+  virtual void UpdateOnce() ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu_) = 0;++  grpc_completion_queue* cq() ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu_) { return cq_; }++  void CToMetadata(grpc_metadata* metadata, size_t count,+                   grpc_metadata_batch* batch);++  std::string ActivityDebugTag() const override { return DebugTag(); }++  void RunFinalization(grpc_status_code status, const char* status_details) {+    grpc_call_final_info final_info;+    final_info.stats = *call_context_.call_stats();+    final_info.error_string = status_details;+    finalization_.Run(&final_info);+  }++ private:+  union CompletionInfo {+    struct Pending {+      uint8_t pause_bits;+      bool is_closure;+      bool success;+      void* tag;+    } pending;+    grpc_cq_completion completion;+  };++  class NonOwningWakable final : public Wakeable {+   public:+    explicit NonOwningWakable(PromiseBasedCall* call) : call_(call) {}++    // Ref the Handle (not the activity).+    void Ref() { refs_.fetch_add(1, std::memory_order_relaxed); }++    // Activity is going away... drop its reference and sever the connection+    // back.+    void DropActivity() ABSL_LOCKS_EXCLUDED(mu_) {+      mu_.Lock();+      GPR_ASSERT(call_ != nullptr);+      call_ = nullptr;+      mu_.Unlock();+      Unref();+    }++    // Activity needs to wake up (if it still exists!) - wake it up, and drop+    // the ref that was kept for this handle.+    void Wakeup() override ABSL_LOCKS_EXCLUDED(mu_) {+      mu_.Lock();+      // Note that activity refcount can drop to zero, but we could win the lock+      // against DropActivity, so we need to only increase activities refcount+      // if it is non-zero.+      if (call_ && call_->RefIfNonZero()) {+        PromiseBasedCall* call = call_;+        mu_.Unlock();+        // Activity still exists and we have a reference: wake it up, which will+        // drop the ref.+        call->Wakeup();+      } else {+        // Could not get the activity - it's either gone or going. No need to+        // wake it up!+        mu_.Unlock();+      }+      // Drop the ref to the handle (we have one ref = one wakeup semantics).+      Unref();+    }++    std::string ActivityDebugTag() const override {+      MutexLock lock(&mu_);+      return call_ == nullptr ? ""<unknown>"" : call_->DebugTag();+    }++    void Drop() override { Unref(); }++   private:+    // Unref the Handle (not the activity).+    void Unref() {+      if (1 == refs_.fetch_sub(1, std::memory_order_acq_rel)) {+        delete this;+      }+    }++    mutable Mutex mu_;+    std::atomic<size_t> refs_{2};+    PromiseBasedCall* call_ ABSL_GUARDED_BY(mu_);+  };++  static void OnDestroy(void* arg, grpc_error_handle error) {+    auto* call = static_cast<PromiseBasedCall*>(arg);+    ScopedContext context(call);+    call->DeleteThis();+  }++  // First 32 bits are strong refs, next 32 bits are weak refs.+  static uint64_t MakeRefPair(uint32_t strong, uint32_t weak) {+    return (static_cast<uint64_t>(strong) << 32) + static_cast<int64_t>(weak);+  }+  static uint32_t GetStrongRefs(uint64_t ref_pair) {+    return static_cast<uint32_t>(ref_pair >> 32);+  }+  static uint32_t GetWeakRefs(uint64_t ref_pair) {+    return static_cast<uint32_t>(ref_pair & 0xffffffffu);+  }++  bool RefIfNonZero() {+    uint64_t prev_ref_pair = refs_.load(std::memory_order_acquire);+    do {+      const uint32_t strong_refs = GetStrongRefs(prev_ref_pair);+      if (strong_refs == 0) return false;+    } while (!refs_.compare_exchange_weak(+        prev_ref_pair, prev_ref_pair + MakeRefPair(1, 0),+        std::memory_order_acq_rel, std::memory_order_acquire));+    return true;+  }++  mutable Mutex mu_;+  std::atomic<uint64_t> refs_{MakeRefPair(1, 0)};+  CallContext call_context_{this};+  bool keep_polling_ ABSL_GUARDED_BY(mu()) = false;++  /* Contexts for various subsystems (security, tracing, ...). */+  grpc_call_context_element context_[GRPC_CONTEXT_COUNT] = {};+  grpc_completion_queue* cq_ ABSL_GUARDED_BY(mu_);+  FragmentAllocator fragment_allocator_ ABSL_GUARDED_BY(mu_);+  NonOwningWakable* non_owning_wakeable_ ABSL_GUARDED_BY(mu_) = nullptr;+  CompletionInfo completion_info_[6];+  CallFinalization finalization_;+};++template <typename T>+grpc_error_handle MakePromiseBasedCall(grpc_call_create_args* args,+                                       grpc_call** out_call) {+  Channel* channel = args->channel.get();++  Arena* arena;+  PromiseBasedCall* call;+  std::pair<Arena*, void*> arena_with_call = Arena::CreateWithAlloc(+      channel->CallSizeEstimate(), sizeof(T), channel->allocator());+  arena = arena_with_call.first;+  call = new (arena_with_call.second) T(arena, args);+  *out_call = call->c_ptr();+  GPR_DEBUG_ASSERT(Call::FromC(*out_call) == call);+  return GRPC_ERROR_NONE;+}++PromiseBasedCall::PromiseBasedCall(Arena* arena,+                                   const grpc_call_create_args& args)+    : Call(arena, args.server_transport_data == nullptr, args.send_deadline,+           args.channel->Ref()),+      cq_(args.cq) {+  if (args.cq != nullptr) {+    GPR_ASSERT(args.pollset_set_alternative == nullptr &&+               ""Only one of 'cq' and 'pollset_set_alternative' should be ""+               ""non-nullptr."");+    GRPC_CQ_INTERNAL_REF(args.cq, ""bind"");+    call_context_.pollent_ =+        grpc_polling_entity_create_from_pollset(grpc_cq_pollset(args.cq));+  }+  if (args.pollset_set_alternative != nullptr) {+    call_context_.pollent_ = grpc_polling_entity_create_from_pollset_set(+        args.pollset_set_alternative);+  }+}++Waker PromiseBasedCall::MakeNonOwningWaker() {+  if (non_owning_wakeable_ == nullptr) {+    non_owning_wakeable_ = new NonOwningWakable(this);+  } else {+    non_owning_wakeable_->Ref();+  }+  return Waker(non_owning_wakeable_);+}++void PromiseBasedCall::CToMetadata(grpc_metadata* metadata, size_t count,+                                   grpc_metadata_batch* b) {+  // DO NOT SUBMIT+  // Need to add a ValidateMetadata to the op validation loop.+  for (size_t i = 0; i < count; i++) {+    grpc_metadata* md = &metadata[i];+    auto key = StringViewFromSlice(md->key);+    // Filter ""content-length metadata""+    if (key == ""content-length"") continue;+    b->Append(key, Slice(grpc_slice_ref_internal(md->value)),+              [md](absl::string_view error, const Slice& value) {+                gpr_log(GPR_DEBUG, ""Append error: %s"",+                        absl::StrCat(""key="", StringViewFromSlice(md->key),+                                     "" error="", error,+                                     "" value="", value.as_string_view())+                            .c_str());+              });+  }+}++void PromiseBasedCall::ContextSet(grpc_context_index elem, void* value,+                                  void (*destroy)(void*)) {+  if (context_[elem].destroy) {+    context_[elem].destroy(context_[elem].value);+  }+  context_[elem].value = value;+  context_[elem].destroy = destroy;+}++void* PromiseBasedCall::ContextGet(grpc_context_index elem) const {+  return context_[elem].value;+}++PromiseBasedCall::Completion PromiseBasedCall::StartCompletion(+    void* tag, bool is_closure, const grpc_op* ops, size_t num_ops) {+  Completion c(BatchSlotForOp(ops[0].op));+  if (grpc_call_trace.enabled()) {+    gpr_log(GPR_INFO, ""%sStartCompletion %s tag=%p"", DebugTag().c_str(),+            c.ToString().c_str(), tag);+  }+  if (!is_closure) {+    grpc_cq_begin_op(cq(), tag);+  }+  completion_info_[c.index()].pending = {+      PauseReasonBit(PauseReason::kStartingBatch), is_closure, true, tag};+  return c;+}++PromiseBasedCall::Completion PromiseBasedCall::PauseCompletion(+    const Completion& completion, PauseReason reason) {+  if (grpc_call_trace.enabled()) {+    gpr_log(GPR_INFO, ""%sPauseCompletion %s %s"", DebugTag().c_str(),+            completion.ToString().c_str(), PauseReasonString(reason));+  }+  auto& pause_bits = completion_info_[completion.index()].pending.pause_bits;+  GPR_ASSERT((pause_bits & PauseReasonBit(reason)) == 0);+  pause_bits |= PauseReasonBit(reason);+  return Completion(completion.index());+}++void PromiseBasedCall::FailCompletion(const Completion& completion) {+  if (grpc_call_trace.enabled()) {+    gpr_log(GPR_INFO, ""%sFailCompletion %s"", DebugTag().c_str(),+            completion.ToString().c_str());+  }+  completion_info_[completion.index()].pending.success = false;+}++void PromiseBasedCall::FinishCompletion(Completion* completion,+                                        PauseReason reason) {+  if (grpc_call_trace.enabled()) {+    auto pause_bits = completion_info_[completion->index()].pending.pause_bits;+    bool success = completion_info_[completion->index()].pending.success;+    std::vector<const char*> pending;+    for (size_t i = 0; i < 8 * sizeof(pause_bits); i++) {+      if (static_cast<PauseReason>(i) == reason) continue;+      if (pause_bits & (1 << i)) {+        pending.push_back(PauseReasonString(static_cast<PauseReason>(i)));+      }+    }+    gpr_log(GPR_INFO, ""%sFinishCompletion %s %s %s"", DebugTag().c_str(),+            completion->ToString().c_str(), PauseReasonString(reason),+            (pending.empty()+                 ? (success ? std::string(""done"") : std::string(""failed""))","Nit: Suggest writing this as:```? (success ? ""done"" : ""failed""): absl::StrFormat(...).c_str()```That way, we aren't needlessly allocating new temporary strings when `pending` is empty.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/29598,968813142,2022-09-12T18:58:17Z,src/core/lib/surface/call.cc,"@@ -1740,8 +1794,1024 @@ void FilterStackCall::ContextSet(grpc_context_index elem, void* value,   context_[elem].destroy = destroy; } +///////////////////////////////////////////////////////////////////////////////+// PromiseBasedCall+// Will be folded into Call once the promise conversion is done++class PromiseBasedCall : public Call, public Activity, public Wakeable {+ public:+  PromiseBasedCall(Arena* arena, const grpc_call_create_args& args);++  void ContextSet(grpc_context_index elem, void* value,+                  void (*destroy)(void* value)) override;+  void* ContextGet(grpc_context_index elem) const override;+  void SetCompletionQueue(grpc_completion_queue* cq) override;++  // Implementation of call refcounting: move this to DualRefCounted once we+  // don't need to maintain FilterStackCall compatibility+  void ExternalRef() final {+    refs_.fetch_add(MakeRefPair(1, 0), std::memory_order_relaxed);+  }+  void ExternalUnref() final {+    const uint64_t prev_ref_pair =+        refs_.fetch_add(MakeRefPair(-1, 1), std::memory_order_acq_rel);+    const uint32_t strong_refs = GetStrongRefs(prev_ref_pair);+    if (GPR_UNLIKELY(strong_refs == 1)) {+      Orphan();+    }+    // Now drop the weak ref.+    InternalUnref(""external_ref"");+  }+  void InternalRef(const char*) final {+    refs_.fetch_add(MakeRefPair(0, 1), std::memory_order_relaxed);+  }+  void InternalUnref(const char*) final {+    const uint64_t prev_ref_pair =+        refs_.fetch_sub(MakeRefPair(0, 1), std::memory_order_acq_rel);+    if (GPR_UNLIKELY(prev_ref_pair == MakeRefPair(0, 1))) {+      DeleteThis();+    }+  }++  // Activity methods+  void ForceImmediateRepoll() ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu_) override;+  Waker MakeOwningWaker() ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu_) override {+    InternalRef(""wakeup"");+#if defined(__has_feature)+#if __has_feature(address_sanitizer)+#define GRPC_CALL_USES_ASAN_WAKER+    class AsanWaker final : public Wakeable {+     public:+      explicit AsanWaker(PromiseBasedCall* call) : call_(call) {}++      void Wakeup() override {+        call_->Wakeup();+        delete this;+      }++      void Drop() override {+        call_->Drop();+        delete this;+      }++      std::string ActivityDebugTag() const override {+        return call_->DebugTag();+      }++     private:+      PromiseBasedCall* call_;+    };+    return Waker(new AsanWaker(this));+#endif+#endif+#ifndef GRPC_CALL_USES_ASAN_WAKER+    return Waker(this);+#endif+  }+  Waker MakeNonOwningWaker() ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu_) override;++  // Wakeable methods+  void Wakeup() override {+    grpc_event_engine::experimental::GetDefaultEventEngine()->Run([this] {+      ApplicationCallbackExecCtx app_exec_ctx;+      ExecCtx exec_ctx;+      {+        ScopedContext activity_context(this);+        MutexLock lock(&mu_);+        Update();+      }+      InternalUnref(""wakeup"");+    });+  }+  void Drop() override { InternalUnref(""wakeup""); }++  void InContext(absl::AnyInvocable<void()> fn) {+    if (Activity::current() == this) {+      fn();+    } else {+      InternalRef(""in_context"");+      grpc_event_engine::experimental::GetDefaultEventEngine()->Run(+          [this, fn = std::move(fn)]() mutable {+            ExecCtx exec_ctx;+            {+              ScopedContext activity_context(this);+              MutexLock lock(&mu_);+              fn();+              Update();+            }+            InternalUnref(""in_context"");+          });+    }+  }++  grpc_compression_algorithm test_only_compression_algorithm() override {+    abort();+  }+  uint32_t test_only_message_flags() override { abort(); }+  uint32_t test_only_encodings_accepted_by_peer() override { abort(); }+  grpc_compression_algorithm compression_for_level(+      grpc_compression_level level) override {+    abort();+  }++  // This should return nullptr for the promise stack (and alternative means+  // for that functionality be invented)+  grpc_call_stack* call_stack() override { return nullptr; }++ protected:+  class ScopedContext+      : public ScopedActivity,+        public promise_detail::Context<Arena>,+        public promise_detail::Context<grpc_call_context_element>,+        public promise_detail::Context<CallContext>,+        public promise_detail::Context<CallFinalization>,+        public promise_detail::Context<FragmentAllocator> {+   public:+    explicit ScopedContext(PromiseBasedCall* call)+        : ScopedActivity(call),+          promise_detail::Context<Arena>(call->arena()),+          promise_detail::Context<grpc_call_context_element>(call->context_),+          promise_detail::Context<CallContext>(&call->call_context_),+          promise_detail::Context<CallFinalization>(&call->finalization_),+          promise_detail::Context<FragmentAllocator>(+              &call->fragment_allocator_) {}+  };++  class Completion {+   public:+    Completion() : index_(kNullIndex) {}+    ~Completion() { GPR_ASSERT(index_ == kNullIndex); }+    explicit Completion(uint8_t index) : index_(index) {}+    Completion(const Completion& other) = delete;+    Completion& operator=(const Completion& other) = delete;+    Completion(Completion&& other) noexcept : index_(other.index_) {+      other.index_ = kNullIndex;+    }+    Completion& operator=(Completion&& other) noexcept {+      GPR_ASSERT(index_ == kNullIndex);+      index_ = other.index_;+      other.index_ = kNullIndex;+      return *this;+    }++    uint8_t index() const { return index_; }+    uint8_t TakeIndex() { return absl::exchange(index_, kNullIndex); }+    bool has_value() const { return index_ != kNullIndex; }++    std::string ToString() const {+      return index_ == kNullIndex ? ""null""+                                  : std::to_string(static_cast<int>(index_));+    }++   private:+    enum : uint8_t { kNullIndex = 0xff };+    uint8_t index_;+  };++  ~PromiseBasedCall() override {+    if (non_owning_wakeable_) non_owning_wakeable_->DropActivity();+    if (cq_) GRPC_CQ_INTERNAL_UNREF(cq_, ""bind"");+  }++  enum class PauseReason {+    kStartingBatch = 0,+    kReceiveInitialMetadata,+    kReceiveStatusOnClient,+    kSendMessage,+    kReceiveMessage,+  };++  static constexpr const char* PauseReasonString(PauseReason reason) {+    switch (reason) {+      case PauseReason::kStartingBatch:+        return ""StartingBatch"";+      case PauseReason::kReceiveInitialMetadata:+        return ""ReceiveInitialMetadata"";+      case PauseReason::kReceiveStatusOnClient:+        return ""ReceiveStatusOnClient"";+      case PauseReason::kSendMessage:+        return ""SendMessage"";+      case PauseReason::kReceiveMessage:+        return ""ReceiveMessage"";+    }+    return ""Unknown"";+  }++  static constexpr uint8_t PauseReasonBit(PauseReason reason) {+    return 1 << static_cast<int>(reason);+  }++  Mutex* mu() const ABSL_LOCK_RETURNED(mu_) { return &mu_; }++  Completion StartCompletion(void* tag, bool is_closure, const grpc_op* ops,+                             size_t num_ops) ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu_);+  void FinishCompletion(Completion* completion, PauseReason reason)","It looks like this function actually finishes the pending operation described by `reason`, which may or may not actually trigger a batch completion.  Given that, I suggest renaming this to either `FinishOperation()` or `MaybeFinishCompletion()`.",X
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/30763,968979345,2022-09-12T22:14:19Z,src/core/lib/event_engine/thread_pool.cc,"@@ -20,138 +20,135 @@  #include ""src/core/lib/event_engine/thread_pool.h"" +#include <memory> #include <utility> +#include <grpc/support/log.h>+ #include ""src/core/lib/gprpp/thd.h""  namespace grpc_event_engine { namespace experimental { -ThreadPool::Thread::Thread(ThreadPool* pool)-    : pool_(pool),-      thd_(-          ""posix_eventengine_pool"",-          [](void* th) { static_cast<ThreadPool::Thread*>(th)->ThreadFunc(); },-          this, nullptr, grpc_core::Thread::Options().set_tracked(false)) {-  thd_.Start();+void ThreadPool::StartThread(StatePtr state) {+  state->thread_count.Add();+  grpc_core::Thread(+      ""event_engine"",+      [](void* arg) {+        ThreadFunc(*std::unique_ptr<StatePtr>(static_cast<StatePtr*>(arg)));+      },+      new StatePtr(state), nullptr,+      grpc_core::Thread::Options().set_tracked(false).set_joinable(false))+      .Start(); }-ThreadPool::Thread::~Thread() { thd_.Join(); }--void ThreadPool::Thread::ThreadFunc() {-  pool_->ThreadFunc();-  // Now that we have killed ourselves, we should reduce the thread count-  grpc_core::MutexLock lock(&pool_->mu_);-  pool_->nthreads_--;-  // Move ourselves to dead list-  pool_->dead_threads_.push_back(this);--  if (pool_->nthreads_ == 0) {-    if (pool_->forking_) pool_->fork_cv_.Signal();-    if (pool_->shutdown_) pool_->shutdown_cv_.Signal();++void ThreadPool::ThreadFunc(StatePtr state) {+  while (state->queue.Step()) {   }+  state->thread_count.Remove(); } -void ThreadPool::ThreadFunc() {-  for (;;) {-    // Wait until work is available or we are shutting down.-    grpc_core::ReleasableMutexLock lock(&mu_);-    if (!forking_ && !shutdown_ && callbacks_.empty()) {-      // If there are too many threads waiting, then quit this thread-      if (threads_waiting_ >= reserve_threads_) {-        break;-      }-      threads_waiting_++;-      cv_.Wait(&mu_);-      threads_waiting_--;-    }-    // a fork could be initiated while the thread was waiting-    if (forking_) return;-    // Drain callbacks before considering shutdown to ensure all work-    // gets completed.-    if (!callbacks_.empty()) {-      auto cb = std::move(callbacks_.front());-      callbacks_.pop();-      lock.Release();-      cb();-    } else if (shutdown_) {+bool ThreadPool::Queue::Step() {+  grpc_core::ReleasableMutexLock lock(&mu_);+  // Wait until work is available or we are shutting down.+  while (state_ == State::kRunning && callbacks_.empty()) {+    // If there are too many threads waiting, then quit this thread.+    // TODO(ctiller): wait some time in this case to be sure.+    if (threads_waiting_ >= reserve_threads_) return false;+    threads_waiting_++;+    cv_.Wait(&mu_);+    threads_waiting_--;+  }+  switch (state_) {+    case State::kRunning:       break;-    }+    case State::kShutdown:+    case State::kForking:+      if (!callbacks_.empty()) break;","I can agree with making more things fork-aware as a solution. However that could add complexity to things that don't actually care if a fork happens (they do the same thing before and after regardless, but have to orchestrate an extra stop and start). That would be work done exclusively to prevent hangs due to a side effect of how the thread pool works, which seems like a leaky abstraction. Maybe it's a small set of edge cases, to your point. And we may find them if there are random hangs in pre-fork.If the thread pool halts execution with callbacks still in queue, and some callback really wanted to do something pre-fork, its owner can opt in to being fork-aware. Otherwise the default expectation can be that callbacks are unbothered by forking.",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/30763,969110776,2022-09-13T03:16:57Z,src/core/lib/event_engine/thread_pool.cc,"@@ -20,138 +20,135 @@  #include ""src/core/lib/event_engine/thread_pool.h"" +#include <memory> #include <utility> +#include <grpc/support/log.h>+ #include ""src/core/lib/gprpp/thd.h""  namespace grpc_event_engine { namespace experimental { -ThreadPool::Thread::Thread(ThreadPool* pool)-    : pool_(pool),-      thd_(-          ""posix_eventengine_pool"",-          [](void* th) { static_cast<ThreadPool::Thread*>(th)->ThreadFunc(); },-          this, nullptr, grpc_core::Thread::Options().set_tracked(false)) {-  thd_.Start();+void ThreadPool::StartThread(StatePtr state) {+  state->thread_count.Add();+  grpc_core::Thread(+      ""event_engine"",+      [](void* arg) {+        ThreadFunc(*std::unique_ptr<StatePtr>(static_cast<StatePtr*>(arg)));+      },+      new StatePtr(state), nullptr,+      grpc_core::Thread::Options().set_tracked(false).set_joinable(false))+      .Start(); }-ThreadPool::Thread::~Thread() { thd_.Join(); }--void ThreadPool::Thread::ThreadFunc() {-  pool_->ThreadFunc();-  // Now that we have killed ourselves, we should reduce the thread count-  grpc_core::MutexLock lock(&pool_->mu_);-  pool_->nthreads_--;-  // Move ourselves to dead list-  pool_->dead_threads_.push_back(this);--  if (pool_->nthreads_ == 0) {-    if (pool_->forking_) pool_->fork_cv_.Signal();-    if (pool_->shutdown_) pool_->shutdown_cv_.Signal();++void ThreadPool::ThreadFunc(StatePtr state) {+  while (state->queue.Step()) {   }+  state->thread_count.Remove(); } -void ThreadPool::ThreadFunc() {-  for (;;) {-    // Wait until work is available or we are shutting down.-    grpc_core::ReleasableMutexLock lock(&mu_);-    if (!forking_ && !shutdown_ && callbacks_.empty()) {-      // If there are too many threads waiting, then quit this thread-      if (threads_waiting_ >= reserve_threads_) {-        break;-      }-      threads_waiting_++;-      cv_.Wait(&mu_);-      threads_waiting_--;-    }-    // a fork could be initiated while the thread was waiting-    if (forking_) return;-    // Drain callbacks before considering shutdown to ensure all work-    // gets completed.-    if (!callbacks_.empty()) {-      auto cb = std::move(callbacks_.front());-      callbacks_.pop();-      lock.Release();-      cb();-    } else if (shutdown_) {+bool ThreadPool::Queue::Step() {+  grpc_core::ReleasableMutexLock lock(&mu_);+  // Wait until work is available or we are shutting down.+  while (state_ == State::kRunning && callbacks_.empty()) {+    // If there are too many threads waiting, then quit this thread.+    // TODO(ctiller): wait some time in this case to be sure.+    if (threads_waiting_ >= reserve_threads_) return false;+    threads_waiting_++;+    cv_.Wait(&mu_);+    threads_waiting_--;+  }+  switch (state_) {+    case State::kRunning:       break;-    }+    case State::kShutdown:+    case State::kForking:+      if (!callbacks_.empty()) break;","So I'm going to claim that we don't do forever chains of callbacks in gRPC (except in places that need to be fork aware anyway), and I think this is true for other things too - I can't think of a compelling case I've seen that would need forever rescheduled callbacks and forks and not be able to handle that.That said, accidents happen and it'd be better to be able to diagnose them, so I've added some diagnostics to help find this when it does happen (and a test to ensure that it works).",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/29598,969805515,2022-09-13T15:51:37Z,src/core/lib/channel/connected_channel.cc,"@@ -203,39 +242,606 @@ static void connected_channel_get_channel_info(     grpc_channel_element* /*elem*/, const grpc_channel_info* /*channel_info*/) { } -const grpc_channel_filter grpc_connected_filter = {-    connected_channel_start_transport_stream_op_batch,-    nullptr,-    connected_channel_start_transport_op,-    sizeof(call_data),-    connected_channel_init_call_elem,-    set_pollset_or_pollset_set,-    connected_channel_destroy_call_elem,-    sizeof(channel_data),-    connected_channel_init_channel_elem,-    [](grpc_channel_stack* channel_stack, grpc_channel_element* elem) {-      /* HACK(ctiller): increase call stack size for the channel to make space-         for channel data. We need a cleaner (but performant) way to do this,-         and I'm not sure what that is yet.-         This is only ""safe"" because call stacks place no additional data after-         the last call element, and the last call element MUST be the connected-         channel. */-      channel_stack->call_stack_size += grpc_transport_stream_size(-          static_cast<channel_data*>(elem->channel_data)->transport);-    },-    connected_channel_destroy_channel_elem,-    connected_channel_get_channel_info,-    ""connected"",+namespace grpc_core {+namespace {++class ClientStream : public Orphanable {+ public:+  ClientStream(grpc_transport* transport, CallArgs call_args)+      : transport_(transport),+        stream_(nullptr, StreamDeleter(this)),+        server_initial_metadata_latch_(call_args.server_initial_metadata),+        client_to_server_messages_(call_args.outgoing_messages),+        server_to_client_messages_(call_args.incoming_messages),+        client_initial_metadata_(std::move(call_args.client_initial_metadata)) {+    call_context_->IncrementRefCount(""client_stream"");+    GRPC_STREAM_REF_INIT(+        &stream_refcount_, 1,+        [](void* p, grpc_error_handle) {+          static_cast<ClientStream*>(p)->BeginDestroy();+        },+        this, ""client_stream"");+    if (grpc_call_trace.enabled()) {+      gpr_log(GPR_INFO, ""%sInitImpl: intitial_metadata=%s"",+              Activity::current()->DebugTag().c_str(),+              client_initial_metadata_->DebugString().c_str());+    }+  }++  void Orphan() override {+    if (grpc_call_trace.enabled()) {+      MutexLock lock(&mu_);+      gpr_log(GPR_INFO, ""%sDropStream: %s"",+              Activity::current()->DebugTag().c_str(),+              ActiveOpsString().c_str());+    }+    if (!finished_) {+      IncrementRefCount(""shutdown client stream"");+      auto* cancel_op =+          GetContext<Arena>()->New<grpc_transport_stream_op_batch>();+      cancel_op->cancel_stream = true;+      cancel_op->payload = &batch_payload_;+      auto* stream = stream_.get();+      cancel_op->on_complete = NewClosure(+          [this](grpc_error_handle) { Unref(""shutdown client stream""); });+      batch_payload_.cancel_stream.cancel_error = GRPC_ERROR_CANCELLED;+      grpc_transport_perform_stream_op(transport_, stream, cancel_op);+    }+    Unref(""orphan client stream"");+  }++  void IncrementRefCount(const char* reason) {+#ifndef NDEBUG+    grpc_stream_ref(&stream_refcount_, reason);+#else+    grpc_stream_ref(&stream_refcount_);+#endif+  }++  void Unref(const char* reason) {+#ifndef NDEBUG+    grpc_stream_unref(&stream_refcount_, reason);+#else+    grpc_stream_unref(&stream_refcount_);+#endif+  }++  void BeginDestroy() {+    if (stream_ != nullptr) {+      stream_.reset();+    } else {+      StreamDestroyed();+    }+  }++  Poll<ServerMetadataHandle> PollOnce() {+    MutexLock lock(&mu_);+    GPR_ASSERT(!finished_);++    if (grpc_call_trace.enabled()) {+      gpr_log(GPR_INFO, ""%sPollConnectedChannel: %s"",+              Activity::current()->DebugTag().c_str(),+              ActiveOpsString().c_str());+    }++    auto push_recv_message = [this]() ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu_) {+      recv_message_state_ = PendingReceiveMessage{};+      auto& pending_recv_message =+          absl::get<PendingReceiveMessage>(recv_message_state_);+      memset(&recv_message_, 0, sizeof(recv_message_));+      recv_message_.payload = &batch_payload_;+      recv_message_.on_complete = nullptr;+      recv_message_.recv_message = true;+      batch_payload_.recv_message.recv_message = &pending_recv_message.payload;+      batch_payload_.recv_message.flags = &pending_recv_message.flags;+      batch_payload_.recv_message.call_failed_before_recv_message = nullptr;+      batch_payload_.recv_message.recv_message_ready =+          &recv_message_batch_done_;+      IncrementRefCount(""recv_message"");+      recv_message_waker_ = Activity::current()->MakeOwningWaker();+      push_recv_message_ = true;+      SchedulePush();+    };++    if (!absl::exchange(requested_metadata_, true)) {+      if (grpc_call_trace.enabled()) {+        gpr_log(GPR_INFO, ""%sPollConnectedChannel: requesting metadata"",+                Activity::current()->DebugTag().c_str());+      }+      stream_.reset(static_cast<grpc_stream*>(+          GetContext<Arena>()->Alloc(transport_->vtable->sizeof_stream)));+      grpc_transport_init_stream(transport_, stream_.get(), &stream_refcount_,+                                 nullptr, GetContext<Arena>());+      grpc_transport_set_pops(transport_, stream_.get(),+                              GetContext<CallContext>()->polling_entity());+      memset(&metadata_, 0, sizeof(metadata_));+      metadata_.send_initial_metadata = true;+      metadata_.recv_initial_metadata = true;+      metadata_.recv_trailing_metadata = true;+      metadata_.payload = &batch_payload_;+      metadata_.on_complete = &metadata_batch_done_;+      batch_payload_.send_initial_metadata.send_initial_metadata =+          client_initial_metadata_.get();+      batch_payload_.send_initial_metadata.peer_string =+          GetContext<CallContext>()->peer_string_atm_ptr();+      server_initial_metadata_ =+          GetContext<FragmentAllocator>()->MakeServerMetadata();+      batch_payload_.recv_initial_metadata.recv_initial_metadata =+          server_initial_metadata_.get();+      batch_payload_.recv_initial_metadata.recv_initial_metadata_ready =+          &recv_initial_metadata_ready_;+      batch_payload_.recv_initial_metadata.trailing_metadata_available =+          nullptr;+      batch_payload_.recv_initial_metadata.peer_string = nullptr;+      server_trailing_metadata_ =+          GetContext<FragmentAllocator>()->MakeClientMetadata();+      batch_payload_.recv_trailing_metadata.recv_trailing_metadata =+          server_trailing_metadata_.get();+      batch_payload_.recv_trailing_metadata.collect_stats =+          &GetContext<CallContext>()->call_stats()->transport_stream_stats;+      batch_payload_.recv_trailing_metadata.recv_trailing_metadata_ready =+          &recv_trailing_metadata_ready_;+      push_metadata_ = true;+      IncrementRefCount(""metadata_batch_done"");+      IncrementRefCount(""initial_metadata_ready"");+      IncrementRefCount(""trailing_metadata_ready"");+      initial_metadata_waker_ = Activity::current()->MakeOwningWaker();+      trailing_metadata_waker_ = Activity::current()->MakeOwningWaker();+      SchedulePush();+    }+    if (absl::holds_alternative<Closed>(send_message_state_)) {+      message_to_send_.reset();+    }+    if (absl::holds_alternative<Idle>(send_message_state_)) {+      message_to_send_.reset();+      send_message_state_ = client_to_server_messages_->Next();+    }+    if (auto* next = absl::get_if<PipeReceiver<MessageHandle>::NextType>(+            &send_message_state_)) {+      auto r = (*next)();+      if (auto* p = absl::get_if<absl::optional<MessageHandle>>(&r)) {+        memset(&send_message_, 0, sizeof(send_message_));+        send_message_.payload = &batch_payload_;+        send_message_.on_complete = &send_message_batch_done_;+        if (p->has_value()) {+          message_to_send_ = std::move(**p);+          send_message_state_ = SendMessageToTransport{};+          send_message_.send_message = true;+          batch_payload_.send_message.send_message =+              message_to_send_->payload();+          batch_payload_.send_message.flags = message_to_send_->flags();+        } else {+          GPR_ASSERT(!absl::holds_alternative<Closed>(send_message_state_));+          client_trailing_metadata_ =+              GetContext<FragmentAllocator>()->MakeClientMetadata();+          send_message_state_ = Closed{};+          send_message_.send_trailing_metadata = true;+          batch_payload_.send_trailing_metadata.send_trailing_metadata =+              client_trailing_metadata_.get();+          // DO NOT SUBMIT: figure this field out+          batch_payload_.send_trailing_metadata.sent = nullptr;+        }+        IncrementRefCount(""send_message"");+        send_message_waker_ = Activity::current()->MakeOwningWaker();+        push_send_message_ = true;+        SchedulePush();+      }+    }+    if (auto* pending =+            absl::get_if<PendingReceiveMessage>(&recv_message_state_)) {+      if (pending->received) {+        if (pending->payload.has_value()) {+          if (grpc_call_trace.enabled()) {+            gpr_log(GPR_INFO,+                    ""%sRecvMessageBatchDone: received payload of %"" PRIdPTR+                    "" bytes"",+                    recv_message_waker_.ActivityDebugTag().c_str(),+                    pending->payload->Length());+          }+          recv_message_state_ = server_to_client_messages_->Push(+              GetContext<FragmentAllocator>()->MakeMessage(+                  std::move(*pending->payload), pending->flags, nullptr));+        } else {+          if (grpc_call_trace.enabled()) {+            gpr_log(GPR_INFO, ""%sRecvMessageBatchDone: received no payload"",+                    recv_message_waker_.ActivityDebugTag().c_str());+          }+          recv_message_state_ = Closed{};+          absl::exchange(server_to_client_messages_, nullptr)->Close();+        }+      }+    }+    if (absl::exchange(queued_initial_metadata_, false)) {+      server_initial_metadata_latch_->Set(server_initial_metadata_.get());+    }+    if (!absl::holds_alternative<PipeSender<MessageHandle>::PushType>(","Suggest moving the recv_message handling from line 471 to right here, so that we've already dealt with recv_message before we deal with recv_trailing_metadata.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/29598,969831259,2022-09-13T16:13:32Z,src/core/lib/transport/transport.cc,"@@ -186,6 +186,36 @@ void grpc_transport_stream_op_batch_queue_finish_with_failure(   GRPC_ERROR_UNREF(error); } +void grpc_transport_stream_op_batch_finish_with_failure_without_call_combiner(","Suggest renaming this to `grpc_transport_stream_op_batch_finish_with_failure_from_transport()`.Also, please document in the .h file that this should be used only when failing a batch from the transport itself, below the layer of the call combiner or activity code.",X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/29598,969840870,2022-09-13T16:23:16Z,test/core/end2end/generate_tests.bzl,"@@ -249,11 +259,12 @@ END2END_TESTS = {     ""max_concurrent_streams"": _test_options(         proxyable = False,         exclude_inproc = True,+        exclude_minstack = True,","Is there a case in the max_concurrent_streams test that can run without a deadline?  If so, maybe plumb this into the code instead of just excluding the entire test?",
28025951,HannahShiSFB,https://api.github.com/repos/grpc/grpc/pulls/30439,970087653,2022-09-13T21:13:42Z,test/core/end2end/generate_tests.bzl,"@@ -429,6 +429,9 @@ def grpc_end2end_tests():             ""//test/core/compression:args_utils"",             ""//:grpc_http_filters"",         ],+        visibility = [+            ""//src/objective-c/tests:__subpackages__"",","e2e code is called from cornet test cases, therefore this dependency",
1644595,gnossen,https://api.github.com/repos/grpc/grpc/pulls/30964,970141311,2022-09-13T22:47:52Z,examples/python/helloworld/greeter_server.py,"@@ -28,10 +28,12 @@ def SayHello(self, request, context):   def serve():+    port = '50051'     server = grpc.server(futures.ThreadPoolExecutor(max_workers=10))     helloworld_pb2_grpc.add_GreeterServicer_to_server(Greeter(), server)-    server.add_insecure_port('[::]:50051')+    server.add_insecure_port('[::]:' + port)     server.start()+    print(""Server started, listening on "" + port)","If we're going to be reporting the port that we're listening on, we want the gRPC library to tell us the resolved port. In the case of port 50051, this will also be 50051. But If `port` is 0, the resolved port may be anything: `resolved_port = server.add_insecure_port('[::]:' + port)`Then print `resolved_port`. You may also consider letting port be specified as a flag for the process.",
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/30815,971166227,2022-09-14T18:30:49Z,src/core/lib/gprpp/time.h,"@@ -70,6 +100,8 @@ class Timestamp {   static Timestamp FromCycleCounterRoundUp(gpr_cycle_counter c);   static Timestamp FromCycleCounterRoundDown(gpr_cycle_counter c); +  static Timestamp Now() { return source_->Now(); }","I see, that's what you meant by ""Add a caching time source, and install it in ExecCtx."" ... When an ExecCtx is instantiated, the caching time source is installed as the thread's time source via a constructor side effect, and the thread's time source is reset upon ExecCtx destruction.I have some concern that folks may remove `exec_ctx` instances thinking they aren't being used, and that would silently eliminate time caching. We might not find out until we see some performance decrease and have to backtrack. And call sites wouldn't know whether they need to call `InvalidateNow`, given they don't know if their time is being cached or not. Would it be better to have explicit `Now` and `CachedNow` methods to control the ambiguity?",
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/30815,971190315,2022-09-14T18:58:36Z,src/core/lib/gprpp/time.h,"@@ -70,6 +100,8 @@ class Timestamp {   static Timestamp FromCycleCounterRoundUp(gpr_cycle_counter c);   static Timestamp FromCycleCounterRoundDown(gpr_cycle_counter c); +  static Timestamp Now() { return source_->Now(); }","Summary of our chat: Until the promise call end state is reached, * folks should not remove ExecCtx instances unless they explicitly mean to eliminate time caching (even if ExecCtx is apparently unused, its presence enables time caching)* callers should assume that their TimeSource is cached, and still call InvalidateNow() when needed (even if it's not actually cached yet).* eventually, InvalidateNow goes away as a concept.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/30815,971197814,2022-09-14T19:07:29Z,src/core/lib/gprpp/time.h,"@@ -116,6 +148,21 @@ class Timestamp {   explicit constexpr Timestamp(int64_t millis) : millis_(millis) {}    int64_t millis_ = 0;+  static GPR_THREAD_LOCAL(Timestamp::Source*) source_;","Should we have some naming convention for thread-locals, like the way we use a `g_` prefix for globals?  The reason I ask is that `source_` implies that this is a normal class data member, which is not the case here, and it took me a while to figure out where it was coming from.",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/30815,971236824,2022-09-14T19:52:41Z,src/core/lib/gprpp/time.h,"@@ -61,6 +65,32 @@ class Duration; // Timestamp represents a discrete point in time. class Timestamp {  public:+  // Base interface for time providers.+  class Source {+   public:+    // Return the current time.+    virtual Timestamp Now() = 0;+    virtual void InvalidateCache() {}++   protected:+    ~Source() = default;","No, this is right. We make it protected so it can't be called from the base class (which is what the virtual-ness is for).",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/30815,971238338,2022-09-14T19:54:32Z,src/core/lib/gprpp/time.cc,"@@ -133,6 +142,14 @@ int64_t TimespanToMillisRoundDown(gpr_timespec ts) {  }  // namespace +GPR_THREAD_LOCAL(Timestamp::Source*)+Timestamp::source_{NoDestructSingleton<GprNowTimeSource>::Get()};++Timestamp ScopedTimeCache::Now() {+  if (!cached_time_.has_value()) cached_time_ = previous()->Now();",`previous()` here is the previous time source. By always using it we'll be able to do some fancy stuff later (like implanting custom time mocks in scoped segments of code).,
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/30815,971244648,2022-09-14T20:02:22Z,src/core/ext/xds/xds_client.cc,"@@ -46,6 +46,7 @@ #include ""src/core/lib/gprpp/orphanable.h"" #include ""src/core/lib/gprpp/ref_counted_ptr.h"" #include ""src/core/lib/gprpp/sync.h""+#include ""src/core/lib/iomgr/exec_ctx.h""","I guess I don't care too much, since it's not really a new dependency.  If you can't figure it out quickly, it's probably not worth spending time on.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/30815,971249221,2022-09-14T20:08:18Z,src/core/lib/gprpp/time.cc,"@@ -133,6 +142,14 @@ int64_t TimespanToMillisRoundDown(gpr_timespec ts) {  }  // namespace +GPR_THREAD_LOCAL(Timestamp::Source*)+Timestamp::source_{NoDestructSingleton<GprNowTimeSource>::Get()};++Timestamp ScopedTimeCache::Now() {+  if (!cached_time_.has_value()) cached_time_ = previous()->Now();","My concern is that this seems like a behavior change.  Currently, if a nested `ExecCtx` is created, then `Now()` starts returning a new time (the one from the nested `ExecCtx` instance), not the one from the previous `ExecCtx` instance.  But with this change, we're no longer doing that, so creating a new nested `ExecCtx` no longer increases the current time, whereas I think it did so before this PR.I do realize that this is partially a bug fix, because we don't want the time to go backwards when the nested `ExecCtx` is destroyed and we revert to the previous `ExecCtx`.  But that's why I suggested using the new time and then invalidating the time in the previous time source: that way, we will still increment the time when we create the nested `ExecCtx`, but we'll also avoid the time going backwards when the nested `ExecCtx` is destroyed.As an alternative, how about simply calling `InvalidateNow()` on the previous time source when we instantiate a nested time source?  That way, we can get the same behavior while still depending on the previous instance for the value of now.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/30815,971251773,2022-09-14T20:11:33Z,src/core/lib/gprpp/time.h,"@@ -116,6 +148,21 @@ class Timestamp {   explicit constexpr Timestamp(int64_t millis) : millis_(millis) {}    int64_t millis_ = 0;+  static GPR_THREAD_LOCAL(Timestamp::Source*) source_;","Yeah, I realize that.  I suspect the main reason that the Google style guide doesn't have a naming convention for this is that they discourage use of globals to begin with.  We tend to use a lot of them in gRPC, and it seems like we're now starting to use more thread-locals too.If nothing else, suggest calling this something like `thread_local_time_source_`.",
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/30978,971259780,2022-09-14T20:22:13Z,src/core/lib/event_engine/posix_engine/posix_engine.cc,"@@ -92,6 +95,18 @@ void PosixEventEngine::Run(EventEngine::Closure* closure) {   executor_.Run(closure); } +absl::Status PosixEventEngine::WaitForPendingTasks(Duration timeout) {","In benchmark and testing cases, I'd expect we assert a failure. If some production code is using it to attempt a safe engine shutdown, maybe logging to indicate a leak, similar to what we have on gRPC shutdown today.",
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/30978,971417361,2022-09-15T00:51:29Z,src/core/lib/event_engine/posix_engine/posix_engine.cc,"@@ -92,6 +95,18 @@ void PosixEventEngine::Run(EventEngine::Closure* closure) {   executor_.Run(closure); } +absl::Status PosixEventEngine::WaitForPendingTasks(Duration timeout) {","That could work. The one exception I can imagine at the moment is an engine that wants to offer a best effort flush of its queue on shutdown or fork, but that can be managed internally to the engine.Some of the tests in the test suite will need to be death tests now, which are not terribly friendly on all platforms. Do you think we should make the change anyway?",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/30821,971465875,2022-09-15T02:34:47Z,src/core/lib/event_engine/workqueue.h,"@@ -0,0 +1,126 @@+// Copyright 2022 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+#ifndef GRPC_CORE_LIB_EVENT_ENGINE_WORKQUEUE_H+#define GRPC_CORE_LIB_EVENT_ENGINE_WORKQUEUE_H++#include <grpc/support/port_platform.h>++#include <stddef.h>+#include <stdint.h>++#include <atomic>+#include <deque>++#include ""absl/base/thread_annotations.h""+#include ""absl/functional/any_invocable.h""+#include ""absl/types/optional.h""++#include <grpc/event_engine/event_engine.h>++#include ""src/core/lib/gprpp/sync.h""+#include ""src/core/lib/gprpp/time.h""++namespace grpc_event_engine {+namespace experimental {++// A fast work queue based lightly on an internal Google implementation.+//+// This uses atomics to access the most recent element in the queue, making it+// fast for LIFO operations. Accessing the oldest (next) element requires taking+// a mutex lock.+class WorkQueue {+ public:+  // comparable to Timestamp::milliseconds_after_process_epoch()+  static const int64_t kInvalidTimestamp = -1;++  class Storage {",this seems like it could be private (along with AddInternal) with each of the Add methods being wrappers.,X
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/30821,971475663,2022-09-15T02:58:52Z,test/core/event_engine/work_queue_test.cc,"@@ -0,0 +1,176 @@+// Copyright 2022 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+#include <grpc/support/port_platform.h>++#include <thread>++#include <gtest/gtest.h>++#include ""src/core/lib/event_engine/common_closures.h""+#include ""src/core/lib/event_engine/workqueue.h""+#include ""src/core/lib/iomgr/exec_ctx.h""+#include ""test/core/util/test_config.h""++namespace {+using ::grpc_event_engine::experimental::AnyInvocableClosure;+using ::grpc_event_engine::experimental::EventEngine;+using ::grpc_event_engine::experimental::WorkQueue;++TEST(WorkQueueTest, StartsEmpty) {+  WorkQueue queue;+  ASSERT_TRUE(queue.Empty());+  ASSERT_EQ(queue.Size(), 0);+}++TEST(WorkQueueTest, TakesClosures) {+  WorkQueue queue;+  bool ran = false;+  AnyInvocableClosure closure([&ran] { ran = true; });+  queue.Add(&closure);+  ASSERT_EQ(queue.Size(), 1);+  ASSERT_FALSE(queue.Empty());+  absl::optional<EventEngine::Closure*> popped = queue.PopFront();+  ASSERT_TRUE(popped.has_value());+  (*popped)->Run();+  ASSERT_TRUE(ran);+  ASSERT_TRUE(queue.Empty());+}++TEST(WorkQueueTest, TakesAnyInvocables) {+  WorkQueue queue;+  bool ran = false;+  queue.Add([&ran] { ran = true; });+  ASSERT_EQ(queue.Size(), 1);+  ASSERT_FALSE(queue.Empty());+  absl::optional<EventEngine::Closure*> popped = queue.PopFront();+  ASSERT_TRUE(popped.has_value());+  (*popped)->Run();+  ASSERT_TRUE(ran);+  ASSERT_TRUE(queue.Empty());+}++TEST(WorkQueueTest, BecomesEmptyOnPopBack) {+  WorkQueue queue;+  bool ran = false;+  queue.Add([&ran] { ran = true; });+  ASSERT_EQ(queue.Size(), 1);+  ASSERT_FALSE(queue.Empty());+  absl::optional<EventEngine::Closure*> closure = queue.PopBack();+  ASSERT_TRUE(closure.has_value());+  (*closure)->Run();+  ASSERT_TRUE(ran);+  ASSERT_TRUE(queue.Empty());+}++TEST(WorkQueueTest, PopFrontIsFIFO) {+  WorkQueue queue;+  int flag = 0;+  queue.Add([&flag] { flag |= 1; });+  queue.Add([&flag] { flag |= 2; });+  ASSERT_EQ(queue.Size(), 2);+  (*queue.PopFront())->Run();+  EXPECT_TRUE(flag & 1);+  EXPECT_FALSE(flag & 2);+  (*queue.PopFront())->Run();+  EXPECT_TRUE(flag & 1);+  EXPECT_TRUE(flag & 2);+  ASSERT_TRUE(queue.Empty());+}++TEST(WorkQueueTest, PopBackIsLIFO) {+  WorkQueue queue;+  int flag = 0;+  queue.Add([&flag] { flag |= 1; });+  queue.Add([&flag] { flag |= 2; });+  ASSERT_EQ(queue.Size(), 2);+  (*queue.PopBack())->Run();+  EXPECT_FALSE(flag & 1);+  EXPECT_TRUE(flag & 2);+  (*queue.PopBack())->Run();+  EXPECT_TRUE(flag & 1);+  EXPECT_TRUE(flag & 2);+  ASSERT_TRUE(queue.Empty());+}++TEST(WorkQueueTest, OldestEnqueuedTimestampIsSane) {+  grpc_core::ExecCtx exec_ctx;+  WorkQueue queue;+  ASSERT_EQ(queue.OldestEnqueuedTimestamp(), grpc_core::Timestamp::InfPast());+  queue.Add([] {});+  ASSERT_LE(queue.OldestEnqueuedTimestamp(), exec_ctx.Now());+  auto popped = queue.PopFront();+  ASSERT_EQ(queue.OldestEnqueuedTimestamp(), grpc_core::Timestamp::InfPast());+  // prevent leaks by executing or deleting the closure+  delete *popped;+}++TEST(WorkQueueTest, OldestEnqueuedTimestampOrderingIsCorrect) {+  WorkQueue queue;+  grpc_core::ExecCtx exec_ctx;+  AnyInvocableClosure closure([] {});+  queue.Add(&closure);+  absl::SleepFor(absl::Milliseconds(2));+  queue.Add(&closure);+  absl::SleepFor(absl::Milliseconds(2));+  queue.Add(&closure);+  absl::SleepFor(absl::Milliseconds(2));+  auto oldest_ts = queue.OldestEnqueuedTimestamp();+  ASSERT_LE(oldest_ts, exec_ctx.Now());+  absl::optional<EventEngine::Closure*> popped;+  // pop the oldest, and ensure the next oldest is younger+  popped = queue.PopFront();+  ASSERT_TRUE(popped.has_value());+  auto second_oldest_ts = queue.OldestEnqueuedTimestamp();+  ASSERT_GT(second_oldest_ts, oldest_ts);+  // pop the oldest, and ensure the last one is youngest+  popped = queue.PopFront();+  ASSERT_TRUE(popped.has_value());+  auto youngest_ts = queue.OldestEnqueuedTimestamp();+  ASSERT_GT(youngest_ts, second_oldest_ts);+  ASSERT_GT(youngest_ts, oldest_ts);+}++TEST(WorkQueueTest, ThreadedStress) {+  WorkQueue queue;+  constexpr int thd_count = 33;+  constexpr int element_count_per_thd = 3333;+  std::vector<std::thread> threads;+  threads.reserve(thd_count);+  AnyInvocableClosure closure([] {});+  for (int i = 0; i < thd_count; i++) {+    threads.emplace_back([&] {+      int cnt = 0;+      do {+        queue.Add(&closure);","Let's instead make a:```class TestClosure : public Closure { public:  void Run() { delete this; }};```and here do `queue.Add(new TestClosure());`and when we're popping, go ahead and just run the closure we pop:```while (cnt < element_count_per_thd) {  if (auto* c = queue.PopFront()) c->Run();}```in this way we leverage ASAN to tell us whether we've got any bugs where closures can get aliased internally and returned twice or such (or not returned)",
4978962,brettmc,https://api.github.com/repos/grpc/grpc/pulls/30997,971535913,2022-09-15T05:22:04Z,src/php/tests/unit_tests/TimevalTest.php,"@@ -62,9 +64,12 @@ public function testConstructorWithHex()         $this->assertSame('Grpc\Timeval', get_class($this->time));     } +    /**+     * @todo in PHP 8.1+ implicit conversion from float to int is deprecated+     */     public function testConstructorWithFloat()     {-        $this->time = new Grpc\Timeval(123.456);+        $this->time = new Grpc\Timeval((int)123.456);","I wasn't sure what to do with this test, since it no longer tests what it claims to. Perhaps revert the cast, and skip the test for 8.1+ ? (see https://php.watch/versions/8.1/deprecate-implicit-conversion-incompatible-float-string)",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/30978,972037905,2022-09-15T14:10:06Z,src/core/lib/event_engine/thread_pool.cc,"@@ -93,32 +94,41 @@ void ThreadPool::Add(absl::AnyInvocable<void()> callback) {   } } +bool ThreadPool::IsBusy() {+  return state_->queue.IsBusy(state_->thread_count.threads());+}+ bool ThreadPool::Queue::Add(absl::AnyInvocable<void()> callback) {   grpc_core::MutexLock lock(&mu_);   // Add works to the callbacks list   callbacks_.push(std::move(callback));   cv_.Signal();   switch (state_) {-    case State::kRunning:-    case State::kShutdown:+    case QueueState::kRunning:+    case QueueState::kShutdown:       return threads_waiting_ == 0;-    case State::kForking:+    case QueueState::kForking:       return false;   }   GPR_UNREACHABLE_CODE(return false); } -void ThreadPool::Queue::SetState(State state) {+void ThreadPool::Queue::SetState(QueueState state) {   grpc_core::MutexLock lock(&mu_);-  if (state == State::kRunning) {-    GPR_ASSERT(state_ != State::kRunning);+  if (state == QueueState::kRunning) {+    GPR_ASSERT(state_ != QueueState::kRunning);   } else {-    GPR_ASSERT(state_ == State::kRunning);+    GPR_ASSERT(state_ == QueueState::kRunning);   }   state_ = state;   cv_.SignalAll(); } +bool ThreadPool::Queue::IsBusy(int expected_idle_threads) {","I don't think this is implementable once we have a work stealing implementation... Indeed I'm not convinced it is now.The problem now:I don't think this counts threads that are not waiting but are currently executing callbacks - for that we need to wait for thread termination.The problem with work queues:This gets much harder because now we can't lock the entire data structure at once, because doing so would imply having a thread pool wide mutex on the enqueue path - which we endeavor to avoid.I suspect that the only reasonable way to get this done is to do something like the thread quiesce we do for fork, and in #30996 on the shutdown path too.",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/30978,972046797,2022-09-15T14:16:49Z,src/core/lib/event_engine/posix_engine/posix_engine.cc,"@@ -92,6 +95,18 @@ void PosixEventEngine::Run(EventEngine::Closure* closure) {   executor_.Run(closure); } +absl::Status PosixEventEngine::WaitForPendingTasks(Duration timeout) {","The best effort flush thing is a really dangerous pattern. It's never worked well for iomgr, I should not have added it, and we should not bring it forward. It's a relic pattern from when we didn't have sanitizers, but since it leaves the application in an undefined state it leaves the application vulnerable to data corruption or other problems post call.Which is to say, either the application relies on callbacks being done (meaning this should be an OrDie function) or applications do not rely on being able to do this and so we should not export this function at all.",
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/30978,972210760,2022-09-15T16:36:47Z,src/core/lib/event_engine/posix_engine/posix_engine.cc,"@@ -92,6 +95,18 @@ void PosixEventEngine::Run(EventEngine::Closure* closure) {   executor_.Run(closure); } +absl::Status PosixEventEngine::WaitForPendingTasks(Duration timeout) {","Changed to `WaitForPendingTasksOrDie`, with one death test.",X
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/30821,972478338,2022-09-15T22:52:47Z,test/core/event_engine/work_queue/corpora/a02dfa6454c3047ba1eb04274980c636d1e56875,"@@ -0,0 +1,96 @@+actions {","I'd probably drop these for now, and just check in one 'empty' file - the fuzzing backends will keep a big corpus for us, so this mostly just increases the number of bytes we need to check out to get to building.We used to check in big corpora to github and I don't think I've seen any benefit.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/31008,973040805,2022-09-16T13:44:07Z,src/core/lib/gprpp/notification.h,"@@ -0,0 +1,67 @@+// Copyright 2022 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++#ifndef GRPC_CORE_LIB_GPRPP_NOTIFICATION_H+#define GRPC_CORE_LIB_GPRPP_NOTIFICATION_H++#include <grpc/support/port_platform.h>++#include ""absl/time/clock.h""+#include ""absl/time/time.h""++#include ""src/core/lib/gprpp/sync.h""++namespace grpc_core {++// Polyfill for absl::Notification until we can use that type.+class Notification {","How about using our own impl only if `GPR_ABSEIL_SYNC` is not defined, just like we do for `Mutex` and `CondVar` in sync.h?  That way, it's less likely for this impl to accidentally diverge from the absl API.",
28025951,HannahShiSFB,https://api.github.com/repos/grpc/grpc/pulls/30439,973315122,2022-09-16T19:07:30Z,src/objective-c/tests/CronetTests/CronetUnitTests.mm,"@@ -39,7 +39,11 @@ #import ""test/core/end2end/data/ssl_test_data.h"" #import ""test/core/util/test_config.h"" -#import <openssl_grpc/ssl.h>+#if COCOAPODS","unfortunately, cocoapod install scripts only modified src/core/ not obj-c/.will delete the temporary code for pod build when bazel migration finish.",
28025951,HannahShiSFB,https://api.github.com/repos/grpc/grpc/pulls/30439,973332206,2022-09-16T19:36:51Z,src/objective-c/tests/BUILD,"@@ -220,6 +242,13 @@ ios_unit_test(     ], ) +grpc_objc_ios_unit_test(+    name = ""CronetTests"",",> https://github.com/grpc/grpc/blob/009dadbb743f4575b60997fb723919eba0bcb00a/src/objective-c/tests/Podfile#L44exactly,
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/31009,974526636,2022-09-19T17:55:28Z,src/core/lib/event_engine/posix_engine/tcp_socket_utils.cc,"@@ -771,6 +817,39 @@ absl::StatusOr<PosixSocketWrapper> PosixSocketWrapper::CreateDualStackSocket(   return PosixSocketWrapper(newfd); } +absl::StatusOr<PosixSocketWrapper>+PosixSocketWrapper::CreateAndPrepareTcpClientSocket(+    PosixTcpOptions& options, const EventEngine::ResolvedAddress& target_addr,+    EventEngine::ResolvedAddress& output_mapped_target_addr) {+  PosixSocketWrapper::DSMode dsmode;+  absl::StatusOr<PosixSocketWrapper> status;","Suggest renaming this variable to `posix_socket_wrapper`. Best practice is to name `StatusOr` variables as the variable type, not the status. See http://go/totw/labs/statusor-patterns-and-antipatterns",X
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/31009,974531491,2022-09-19T18:01:07Z,src/core/lib/event_engine/posix_engine/tcp_socket_utils.h,"@@ -301,6 +301,21 @@ class PosixSocketWrapper {       const experimental::EventEngine::ResolvedAddress& addr, int type,       int protocol, DSMode& dsmode); +  // Return a PosixSocketWrapper which manages a configured, unbound,+  // unconnected TCP client fd.+  //  options: may contain custom tcp settings for the fd.+  //  target_addr: the destination address.+  //  output_mapped_target_addr: A out parameter. It is target_addr mapped to an","Can `output_mapped_target_addr` be replaced by a member of the PosixSocketWrapper? Should it always map to PeerAddress? It would be a cleaner API to have either a return value or output parameters, not both.",
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/30559,974535405,2022-09-19T18:06:08Z,test/core/event_engine/posix/posix_endpoint_test.cc,"@@ -0,0 +1,410 @@+// Copyright 2022 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++#include ""src/core/lib/event_engine/posix_engine/posix_endpoint.h""++#include <fcntl.h>+#include <poll.h>++#include <chrono>+#include <memory>+#include <random>+#include <string>+#include <thread>++#include <gtest/gtest.h>++#include ""absl/strings/str_cat.h""++#include <grpc/event_engine/event_engine.h>++#include ""src/core/lib/channel/channel_args.h""+#include ""src/core/lib/event_engine/channel_args_endpoint_config.h""+#include ""src/core/lib/event_engine/posix_engine/event_poller.h""+#include ""src/core/lib/event_engine/posix_engine/event_poller_posix_default.h""+#include ""src/core/lib/event_engine/posix_engine/posix_engine.h""+#include ""src/core/lib/event_engine/posix_engine/posix_engine_closure.h""+#include ""src/core/lib/event_engine/posix_engine/tcp_socket_utils.h""+#include ""src/core/lib/gprpp/dual_ref_counted.h""+#include ""src/core/lib/gprpp/global_config.h""+#include ""src/core/lib/iomgr/port.h""+#include ""test/core/event_engine/test_suite/event_engine_test_utils.h""+#include ""test/core/event_engine/test_suite/oracle_event_engine_posix.h""+#include ""test/core/util/port.h""++GPR_GLOBAL_CONFIG_DECLARE_STRING(grpc_poll_strategy);++namespace grpc_event_engine {+namespace posix_engine {++using ::grpc_event_engine::experimental::ChannelArgsEndpointConfig;+using ::grpc_event_engine::experimental::EventEngine;+using ::grpc_event_engine::experimental::Poller;+using ::grpc_event_engine::experimental::PosixEventEngine;+using ::grpc_event_engine::experimental::PosixOracleEventEngine;+using ::grpc_event_engine::experimental::Promise;+using ::grpc_event_engine::experimental::URIToResolvedAddress;+using Endpoint = ::grpc_event_engine::experimental::EventEngine::Endpoint;+using Listener = ::grpc_event_engine::experimental::EventEngine::Listener;+using namespace std::chrono_literals;++namespace {++constexpr int kMinMessageSize = 1024;+constexpr int kMaxMessageSize = 8192;+constexpr int kNumConnections = 10;+constexpr int kNumExchangedMessages = 100;+std::atomic<int> g_num_active_connections{0};++// Returns a random message with bounded length.+std::string GetNextSendMessage() {",This is copy-pasted from another test. Please deduplicate.,X
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/30559,974536362,2022-09-19T18:07:20Z,test/core/event_engine/posix/posix_endpoint_test.cc,"@@ -0,0 +1,410 @@+// Copyright 2022 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++#include ""src/core/lib/event_engine/posix_engine/posix_endpoint.h""++#include <fcntl.h>+#include <poll.h>++#include <chrono>+#include <memory>+#include <random>+#include <string>+#include <thread>++#include <gtest/gtest.h>++#include ""absl/strings/str_cat.h""++#include <grpc/event_engine/event_engine.h>++#include ""src/core/lib/channel/channel_args.h""+#include ""src/core/lib/event_engine/channel_args_endpoint_config.h""+#include ""src/core/lib/event_engine/posix_engine/event_poller.h""+#include ""src/core/lib/event_engine/posix_engine/event_poller_posix_default.h""+#include ""src/core/lib/event_engine/posix_engine/posix_engine.h""+#include ""src/core/lib/event_engine/posix_engine/posix_engine_closure.h""+#include ""src/core/lib/event_engine/posix_engine/tcp_socket_utils.h""+#include ""src/core/lib/gprpp/dual_ref_counted.h""+#include ""src/core/lib/gprpp/global_config.h""+#include ""src/core/lib/iomgr/port.h""+#include ""test/core/event_engine/test_suite/event_engine_test_utils.h""+#include ""test/core/event_engine/test_suite/oracle_event_engine_posix.h""+#include ""test/core/util/port.h""++GPR_GLOBAL_CONFIG_DECLARE_STRING(grpc_poll_strategy);++namespace grpc_event_engine {+namespace posix_engine {++using ::grpc_event_engine::experimental::ChannelArgsEndpointConfig;+using ::grpc_event_engine::experimental::EventEngine;+using ::grpc_event_engine::experimental::Poller;+using ::grpc_event_engine::experimental::PosixEventEngine;+using ::grpc_event_engine::experimental::PosixOracleEventEngine;+using ::grpc_event_engine::experimental::Promise;+using ::grpc_event_engine::experimental::URIToResolvedAddress;+using Endpoint = ::grpc_event_engine::experimental::EventEngine::Endpoint;+using Listener = ::grpc_event_engine::experimental::EventEngine::Listener;+using namespace std::chrono_literals;++namespace {++constexpr int kMinMessageSize = 1024;+constexpr int kMaxMessageSize = 8192;+constexpr int kNumConnections = 10;+constexpr int kNumExchangedMessages = 100;+std::atomic<int> g_num_active_connections{0};++// Returns a random message with bounded length.+std::string GetNextSendMessage() {+  static const char alphanum[] =+      ""0123456789""+      ""ABCDEFGHIJKLMNOPQRSTUVWXYZ""+      ""abcdefghijklmnopqrstuvwxyz"";+  static std::random_device rd;+  static std::seed_seq seed{rd()};+  static std::mt19937 gen(seed);+  static std::uniform_real_distribution<> dis(kMinMessageSize, kMaxMessageSize);+  static grpc_core::Mutex g_mu;+  std::string tmp_s;+  int len;+  {+    grpc_core::MutexLock lock(&g_mu);+    len = dis(gen);+  }+  tmp_s.reserve(len);+  for (int i = 0; i < len; ++i) {+    tmp_s += alphanum[rand() % (sizeof(alphanum) - 1)];+  }+  return tmp_s;+}++std::shared_ptr<EventEngine> GetPosixEE() {+  static std::shared_ptr<EventEngine> posix_ee =","This will keep an EventEngine alive through the end of the process, which can result in leaked threads under TSAN. I've seen it flake in similar situations, I'm not entirely sure why it isn't consistently failing.",
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/30559,974538173,2022-09-19T18:09:46Z,test/core/event_engine/posix/posix_endpoint_test.cc,"@@ -0,0 +1,410 @@+// Copyright 2022 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++#include ""src/core/lib/event_engine/posix_engine/posix_endpoint.h""++#include <fcntl.h>+#include <poll.h>++#include <chrono>+#include <memory>+#include <random>+#include <string>+#include <thread>++#include <gtest/gtest.h>++#include ""absl/strings/str_cat.h""++#include <grpc/event_engine/event_engine.h>++#include ""src/core/lib/channel/channel_args.h""+#include ""src/core/lib/event_engine/channel_args_endpoint_config.h""+#include ""src/core/lib/event_engine/posix_engine/event_poller.h""+#include ""src/core/lib/event_engine/posix_engine/event_poller_posix_default.h""+#include ""src/core/lib/event_engine/posix_engine/posix_engine.h""+#include ""src/core/lib/event_engine/posix_engine/posix_engine_closure.h""+#include ""src/core/lib/event_engine/posix_engine/tcp_socket_utils.h""+#include ""src/core/lib/gprpp/dual_ref_counted.h""+#include ""src/core/lib/gprpp/global_config.h""+#include ""src/core/lib/iomgr/port.h""+#include ""test/core/event_engine/test_suite/event_engine_test_utils.h""+#include ""test/core/event_engine/test_suite/oracle_event_engine_posix.h""+#include ""test/core/util/port.h""++GPR_GLOBAL_CONFIG_DECLARE_STRING(grpc_poll_strategy);++namespace grpc_event_engine {+namespace posix_engine {++using ::grpc_event_engine::experimental::ChannelArgsEndpointConfig;+using ::grpc_event_engine::experimental::EventEngine;+using ::grpc_event_engine::experimental::Poller;+using ::grpc_event_engine::experimental::PosixEventEngine;+using ::grpc_event_engine::experimental::PosixOracleEventEngine;+using ::grpc_event_engine::experimental::Promise;+using ::grpc_event_engine::experimental::URIToResolvedAddress;+using Endpoint = ::grpc_event_engine::experimental::EventEngine::Endpoint;+using Listener = ::grpc_event_engine::experimental::EventEngine::Listener;+using namespace std::chrono_literals;++namespace {++constexpr int kMinMessageSize = 1024;+constexpr int kMaxMessageSize = 8192;+constexpr int kNumConnections = 10;+constexpr int kNumExchangedMessages = 100;+std::atomic<int> g_num_active_connections{0};++// Returns a random message with bounded length.+std::string GetNextSendMessage() {+  static const char alphanum[] =+      ""0123456789""+      ""ABCDEFGHIJKLMNOPQRSTUVWXYZ""+      ""abcdefghijklmnopqrstuvwxyz"";+  static std::random_device rd;+  static std::seed_seq seed{rd()};+  static std::mt19937 gen(seed);+  static std::uniform_real_distribution<> dis(kMinMessageSize, kMaxMessageSize);+  static grpc_core::Mutex g_mu;+  std::string tmp_s;+  int len;+  {+    grpc_core::MutexLock lock(&g_mu);+    len = dis(gen);+  }+  tmp_s.reserve(len);+  for (int i = 0; i < len; ++i) {+    tmp_s += alphanum[rand() % (sizeof(alphanum) - 1)];+  }+  return tmp_s;+}++std::shared_ptr<EventEngine> GetPosixEE() {+  static std::shared_ptr<EventEngine> posix_ee =+      std::make_shared<PosixEventEngine>();+  return posix_ee;+}++EventEngine* GetOracleEE() {+  static EventEngine* oracle_ee = new PosixOracleEventEngine();+  return oracle_ee;+}++class TestScheduler : public Scheduler {",This is copy-pasted from another test. Please deduplicate.,X
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/30559,974544825,2022-09-19T18:18:09Z,test/core/event_engine/posix/posix_endpoint_test.cc,"@@ -0,0 +1,410 @@+// Copyright 2022 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++#include ""src/core/lib/event_engine/posix_engine/posix_endpoint.h""++#include <fcntl.h>+#include <poll.h>++#include <chrono>+#include <memory>+#include <random>+#include <string>+#include <thread>++#include <gtest/gtest.h>++#include ""absl/strings/str_cat.h""++#include <grpc/event_engine/event_engine.h>++#include ""src/core/lib/channel/channel_args.h""+#include ""src/core/lib/event_engine/channel_args_endpoint_config.h""+#include ""src/core/lib/event_engine/posix_engine/event_poller.h""+#include ""src/core/lib/event_engine/posix_engine/event_poller_posix_default.h""+#include ""src/core/lib/event_engine/posix_engine/posix_engine.h""+#include ""src/core/lib/event_engine/posix_engine/posix_engine_closure.h""+#include ""src/core/lib/event_engine/posix_engine/tcp_socket_utils.h""+#include ""src/core/lib/gprpp/dual_ref_counted.h""+#include ""src/core/lib/gprpp/global_config.h""+#include ""src/core/lib/iomgr/port.h""+#include ""test/core/event_engine/test_suite/event_engine_test_utils.h""+#include ""test/core/event_engine/test_suite/oracle_event_engine_posix.h""+#include ""test/core/util/port.h""++GPR_GLOBAL_CONFIG_DECLARE_STRING(grpc_poll_strategy);++namespace grpc_event_engine {+namespace posix_engine {++using ::grpc_event_engine::experimental::ChannelArgsEndpointConfig;+using ::grpc_event_engine::experimental::EventEngine;+using ::grpc_event_engine::experimental::Poller;+using ::grpc_event_engine::experimental::PosixEventEngine;+using ::grpc_event_engine::experimental::PosixOracleEventEngine;+using ::grpc_event_engine::experimental::Promise;+using ::grpc_event_engine::experimental::URIToResolvedAddress;+using Endpoint = ::grpc_event_engine::experimental::EventEngine::Endpoint;+using Listener = ::grpc_event_engine::experimental::EventEngine::Listener;+using namespace std::chrono_literals;++namespace {++constexpr int kMinMessageSize = 1024;+constexpr int kMaxMessageSize = 8192;+constexpr int kNumConnections = 10;+constexpr int kNumExchangedMessages = 100;+std::atomic<int> g_num_active_connections{0};++// Returns a random message with bounded length.+std::string GetNextSendMessage() {+  static const char alphanum[] =+      ""0123456789""+      ""ABCDEFGHIJKLMNOPQRSTUVWXYZ""+      ""abcdefghijklmnopqrstuvwxyz"";+  static std::random_device rd;+  static std::seed_seq seed{rd()};+  static std::mt19937 gen(seed);+  static std::uniform_real_distribution<> dis(kMinMessageSize, kMaxMessageSize);+  static grpc_core::Mutex g_mu;+  std::string tmp_s;+  int len;+  {+    grpc_core::MutexLock lock(&g_mu);+    len = dis(gen);+  }+  tmp_s.reserve(len);+  for (int i = 0; i < len; ++i) {+    tmp_s += alphanum[rand() % (sizeof(alphanum) - 1)];+  }+  return tmp_s;+}++std::shared_ptr<EventEngine> GetPosixEE() {+  static std::shared_ptr<EventEngine> posix_ee =+      std::make_shared<PosixEventEngine>();+  return posix_ee;+}++EventEngine* GetOracleEE() {+  static EventEngine* oracle_ee = new PosixOracleEventEngine();+  return oracle_ee;+}++class TestScheduler : public Scheduler {+ public:+  explicit TestScheduler(EventEngine* engine) : engine_(engine) {}+  void Run(EventEngine::Closure* closure) override { engine_->Run(closure); }++  void Run(absl::AnyInvocable<void()> cb) override {+    engine_->Run(std::move(cb));+  }++ private:+  EventEngine* engine_;+};++std::list<std::tuple<std::unique_ptr<EventEngine::Endpoint>,+                     std::unique_ptr<EventEngine::Endpoint>>>+CreateConnectedEndpoints(PosixEventPoller* poller, bool is_zero_copy_enabled,+                         int num_connections) {+  EXPECT_NE(GetOracleEE(), nullptr);+  EXPECT_NE(GetPosixEE(), nullptr);+  EXPECT_NE(poller, nullptr);+  std::list<std::tuple<std::unique_ptr<EventEngine::Endpoint>,+                       std::unique_ptr<EventEngine::Endpoint>>>+      connections;+  auto memory_quota = absl::make_unique<grpc_core::MemoryQuota>(""bar"");+  std::string target_addr = absl::StrCat(+      ""ipv6:[::1]:"", std::to_string(grpc_pick_unused_port_or_die()));+  EventEngine::ResolvedAddress resolved_addr =+      URIToResolvedAddress(target_addr);+  Promise<std::unique_ptr<EventEngine::Endpoint>> server_endpoint_promise;++  Listener::AcceptCallback accept_cb =+      [&server_endpoint_promise](+          std::unique_ptr<Endpoint> ep,+          grpc_core::MemoryAllocator /*memory_allocator*/) {+        server_endpoint_promise.Set(std::move(ep));+      };+  grpc_core::ChannelArgs args;+  auto quota = grpc_core::ResourceQuota::Default();+  args = args.Set(GRPC_ARG_RESOURCE_QUOTA, quota);+  if (is_zero_copy_enabled) {+    args = args.Set(GRPC_ARG_TCP_TX_ZEROCOPY_ENABLED, 1);+    args = args.Set(GRPC_ARG_TCP_TX_ZEROCOPY_SEND_BYTES_THRESHOLD,+                    kMinMessageSize);+  }+  ChannelArgsEndpointConfig config(args);+  auto status = GetOracleEE()->CreateListener(","Per a totw I linked you to earlier, I suggest:```auto listener = oracle_ee->CreateListener(...)ASSERT_TRUE(listener.ok());listener->Bind(...);listener->Start(...);```",
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/30559,974554390,2022-09-19T18:30:11Z,test/core/event_engine/posix/posix_endpoint_test.cc,"@@ -0,0 +1,410 @@+// Copyright 2022 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++#include ""src/core/lib/event_engine/posix_engine/posix_endpoint.h""++#include <fcntl.h>+#include <poll.h>++#include <chrono>+#include <memory>+#include <random>+#include <string>+#include <thread>++#include <gtest/gtest.h>++#include ""absl/strings/str_cat.h""++#include <grpc/event_engine/event_engine.h>++#include ""src/core/lib/channel/channel_args.h""+#include ""src/core/lib/event_engine/channel_args_endpoint_config.h""+#include ""src/core/lib/event_engine/posix_engine/event_poller.h""+#include ""src/core/lib/event_engine/posix_engine/event_poller_posix_default.h""+#include ""src/core/lib/event_engine/posix_engine/posix_engine.h""+#include ""src/core/lib/event_engine/posix_engine/posix_engine_closure.h""+#include ""src/core/lib/event_engine/posix_engine/tcp_socket_utils.h""+#include ""src/core/lib/gprpp/dual_ref_counted.h""+#include ""src/core/lib/gprpp/global_config.h""+#include ""src/core/lib/iomgr/port.h""+#include ""test/core/event_engine/test_suite/event_engine_test_utils.h""+#include ""test/core/event_engine/test_suite/oracle_event_engine_posix.h""+#include ""test/core/util/port.h""++GPR_GLOBAL_CONFIG_DECLARE_STRING(grpc_poll_strategy);++namespace grpc_event_engine {+namespace posix_engine {++using ::grpc_event_engine::experimental::ChannelArgsEndpointConfig;+using ::grpc_event_engine::experimental::EventEngine;+using ::grpc_event_engine::experimental::Poller;+using ::grpc_event_engine::experimental::PosixEventEngine;+using ::grpc_event_engine::experimental::PosixOracleEventEngine;+using ::grpc_event_engine::experimental::Promise;+using ::grpc_event_engine::experimental::URIToResolvedAddress;+using Endpoint = ::grpc_event_engine::experimental::EventEngine::Endpoint;+using Listener = ::grpc_event_engine::experimental::EventEngine::Listener;+using namespace std::chrono_literals;++namespace {++constexpr int kMinMessageSize = 1024;+constexpr int kMaxMessageSize = 8192;+constexpr int kNumConnections = 10;+constexpr int kNumExchangedMessages = 100;+std::atomic<int> g_num_active_connections{0};++// Returns a random message with bounded length.+std::string GetNextSendMessage() {+  static const char alphanum[] =+      ""0123456789""+      ""ABCDEFGHIJKLMNOPQRSTUVWXYZ""+      ""abcdefghijklmnopqrstuvwxyz"";+  static std::random_device rd;+  static std::seed_seq seed{rd()};+  static std::mt19937 gen(seed);+  static std::uniform_real_distribution<> dis(kMinMessageSize, kMaxMessageSize);+  static grpc_core::Mutex g_mu;+  std::string tmp_s;+  int len;+  {+    grpc_core::MutexLock lock(&g_mu);+    len = dis(gen);+  }+  tmp_s.reserve(len);+  for (int i = 0; i < len; ++i) {+    tmp_s += alphanum[rand() % (sizeof(alphanum) - 1)];+  }+  return tmp_s;+}++std::shared_ptr<EventEngine> GetPosixEE() {+  static std::shared_ptr<EventEngine> posix_ee =+      std::make_shared<PosixEventEngine>();+  return posix_ee;+}++EventEngine* GetOracleEE() {+  static EventEngine* oracle_ee = new PosixOracleEventEngine();+  return oracle_ee;+}++class TestScheduler : public Scheduler {+ public:+  explicit TestScheduler(EventEngine* engine) : engine_(engine) {}+  void Run(EventEngine::Closure* closure) override { engine_->Run(closure); }++  void Run(absl::AnyInvocable<void()> cb) override {+    engine_->Run(std::move(cb));+  }++ private:+  EventEngine* engine_;+};++std::list<std::tuple<std::unique_ptr<EventEngine::Endpoint>,+                     std::unique_ptr<EventEngine::Endpoint>>>+CreateConnectedEndpoints(PosixEventPoller* poller, bool is_zero_copy_enabled,+                         int num_connections) {+  EXPECT_NE(GetOracleEE(), nullptr);+  EXPECT_NE(GetPosixEE(), nullptr);+  EXPECT_NE(poller, nullptr);+  std::list<std::tuple<std::unique_ptr<EventEngine::Endpoint>,+                       std::unique_ptr<EventEngine::Endpoint>>>+      connections;+  auto memory_quota = absl::make_unique<grpc_core::MemoryQuota>(""bar"");+  std::string target_addr = absl::StrCat(+      ""ipv6:[::1]:"", std::to_string(grpc_pick_unused_port_or_die()));+  EventEngine::ResolvedAddress resolved_addr =+      URIToResolvedAddress(target_addr);+  Promise<std::unique_ptr<EventEngine::Endpoint>> server_endpoint_promise;++  Listener::AcceptCallback accept_cb =+      [&server_endpoint_promise](+          std::unique_ptr<Endpoint> ep,+          grpc_core::MemoryAllocator /*memory_allocator*/) {+        server_endpoint_promise.Set(std::move(ep));+      };+  grpc_core::ChannelArgs args;+  auto quota = grpc_core::ResourceQuota::Default();+  args = args.Set(GRPC_ARG_RESOURCE_QUOTA, quota);+  if (is_zero_copy_enabled) {+    args = args.Set(GRPC_ARG_TCP_TX_ZEROCOPY_ENABLED, 1);+    args = args.Set(GRPC_ARG_TCP_TX_ZEROCOPY_SEND_BYTES_THRESHOLD,+                    kMinMessageSize);+  }+  ChannelArgsEndpointConfig config(args);+  auto status = GetOracleEE()->CreateListener(+      std::move(accept_cb),+      [](absl::Status status) { ASSERT_TRUE(status.ok()); }, config,+      absl::make_unique<grpc_core::MemoryQuota>(""foo""));+  EXPECT_TRUE(status.ok());++  std::unique_ptr<Listener> listener = std::move(*status);+  EXPECT_TRUE(listener->Bind(resolved_addr).ok());+  EXPECT_TRUE(listener->Start().ok());++  // Create client socket and connect to the target address.+  for (int i = 0; i < num_connections; ++i) {+    int client_fd;+    int one = 1;+    int flags;++    client_fd = socket(AF_INET6, SOCK_STREAM, 0);+    setsockopt(client_fd, SOL_SOCKET, SO_REUSEADDR, &one, sizeof(one));+    // Make fd non-blocking.+    flags = fcntl(client_fd, F_GETFL, 0);+    EXPECT_EQ(fcntl(client_fd, F_SETFL, flags | O_NONBLOCK), 0);++    if (connect(client_fd,",This appears to be the third copy of this code in the codebase. Please deduplicate.,X
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/30559,974575404,2022-09-19T18:57:42Z,BUILD,"@@ -2749,6 +2749,32 @@ grpc_cc_library(     ], ) +grpc_cc_library(+    name = ""posix_event_engine_endpoint"",","Other than in some select tests, no external targets should depended upon this independently. I'd suggest rolling this and any other wholy-owned components of the PosixEventEngine into a single target.",
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/30559,974578614,2022-09-19T19:01:50Z,src/core/lib/event_engine/posix_engine/posix_endpoint.h,"@@ -0,0 +1,239 @@+// Copyright 2022 gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++#ifndef GRPC_CORE_LIB_EVENT_ENGINE_POSIX_ENGINE_POSIX_ENDPOINT_H+#define GRPC_CORE_LIB_EVENT_ENGINE_POSIX_ENGINE_POSIX_ENDPOINT_H++#include <grpc/support/port_platform.h>++#include <memory>++#include <grpc/event_engine/endpoint_config.h>+#include <grpc/event_engine/event_engine.h>+#include <grpc/event_engine/slice_buffer.h>++#include ""src/core/lib/event_engine/posix_engine/event_poller.h""+#include ""src/core/lib/event_engine/posix_engine/posix_engine_closure.h""+#include ""src/core/lib/event_engine/posix_engine/tcp_socket_utils.h""+#include ""src/core/lib/event_engine/posix_engine/traced_buffer_list.h""+#include ""src/core/lib/iomgr/port.h""++namespace grpc_event_engine {+namespace posix_engine {++#ifdef GRPC_POSIX_SOCKET_TCP++using ::grpc_event_engine::experimental::EndpointConfig;+using ::grpc_event_engine::experimental::EventEngine;+using ::grpc_event_engine::experimental::SliceBuffer;++class TcpZerocopySendCtx;",This does not appear to require a forward declaration. Did I miss a circular dependency?,X
933495,dennycd,https://api.github.com/repos/grpc/grpc/pulls/30439,974593378,2022-09-19T19:21:12Z,WORKSPACE,"@@ -88,3 +88,32 @@ pip_install(     name = ""grpc_python_dependencies"",     requirements = ""@com_github_grpc_grpc//:requirements.bazel.txt"", )++http_archive(+    name = ""build_bazel_rules_swift"",",sg. https://github.com/grpc/grpc-ios/issues/104 will track the task to introduce bazel based CronetFramework build so we can remove this cocoapod dependency in our bazel tool tree.,
933495,dennycd,https://api.github.com/repos/grpc/grpc/pulls/30439,974598080,2022-09-19T19:27:39Z,src/objective-c/BUILD,"@@ -239,6 +239,18 @@ grpc_objc_library(     ], ) +grpc_objc_library(+    name = ""grpc_objc_client_core_cronet_testing"",+    srcs = glob([""GRPCClient/private/GRPCCore/GRPCCoreCronet/*.m""]),",Consider refactor this out to a separate target e.g. GRPCCoreCronet similar to how we structure our Cocoapod (https://github.com/grpc/grpc/blob/27e5b4e1877840b58c92d5d853c20ab713d19187/gRPC.podspec#L150) and have the test target depends on it instead,X
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/30971,975547304,2022-09-20T15:52:05Z,src/core/lib/transport/handshaker_factory.h,"@@ -35,11 +37,38 @@ namespace grpc_core {  class HandshakeManager; +// Enum representing the priority of the client handshakers.+// The order of the client handshakers is decided by the priority.+// For example kPreTCPConnect handshakers are called before kTCPConnect and so+// on.+enum class HandshakerClientPriority : int {+  kPreTCPConnect,+  kTCPConnect,+  kHTTPConnect,+  kSecurity,+};++// Enum representing the priority of the server handshakers.+// The order of the server handshakers is decided by the priority.+// For example kReadHeadSecurity handshakers are called before kSecurity and so+// on.+enum class HandshakerServerPriority : int {+  kReadHeadSecurity,+  kSecurity,+};++using HandshakerPriority =","This is probably reaching for a too large a hammer for the job.Consider folding HandshakerClientPriority/HandshakerServerPriority into one enum ... we can comment client/server only if necessary (heck, we can introduce a IsServer/IsClient if necessary too... but I don't think it's practically useful)",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/30960,975550943,2022-09-20T15:55:26Z,BUILD,"@@ -2169,7 +2167,7 @@ grpc_cc_library(     deps = [         ""gpr"",         ""gpr_spinlock"",-        ""grpc_codegen"",+        ""grpc_public_hdrs"",","It seems like here and in other places we want some concrete target, not the headers only target - or am I missing something?Please check that we're only consuming interface not implementation, and either fix the dependency or include a note in the review for why this is safe here and in all places we're using this target.",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/30559,975552759,2022-09-20T15:57:05Z,BUILD,"@@ -2749,6 +2749,32 @@ grpc_cc_library(     ], ) +grpc_cc_library(+    name = ""posix_event_engine_endpoint"",","please don't... rolling these things into single targets invites circular dependencies between layers over time that make the codebase incrementally hard to reason about. Always prefer creating the smallest target set that you can: our ambition should be one header, one cc file per bazel target.",X
11522026,ralphchung,https://api.github.com/repos/grpc/grpc/pulls/30960,975655745,2022-09-20T17:48:29Z,BUILD,"@@ -2169,7 +2167,7 @@ grpc_cc_library(     deps = [         ""gpr"",         ""gpr_spinlock"",-        ""grpc_codegen"",+        ""grpc_public_hdrs"",","Have checked with original build target https://github.com/grpc/grpc/blob/master/BUILD#L4263-L4278. It has only public headers, which best corresponds to the `grpc_public_hdrs`.Previous try was using `grpc_base`. However, cherry picking fails due to linkage error. This is mysterious and I have no idea so far.",
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/31075,975916413,2022-09-21T00:34:19Z,src/core/lib/event_engine/thread_pool.cc,"@@ -89,7 +98,7 @@ bool ThreadPool::Queue::Step() { ThreadPool::ThreadPool(int reserve_threads)     : reserve_threads_(reserve_threads) {   for (int i = 0; i < reserve_threads; i++) {-    StartThread(state_);+    StartThread(state_, false);",Thanks. The clang tidy [bugprone-argument-comment](https://clang.llvm.org/extra/clang-tidy/checks/bugprone/argument-comment.html) check can help in the long run if the argument's name or meaning ever changes.,
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/31009,977084997,2022-09-22T00:38:19Z,src/core/lib/event_engine/posix_engine/tcp_socket_utils.cc,"@@ -771,6 +803,42 @@ absl::StatusOr<PosixSocketWrapper> PosixSocketWrapper::CreateDualStackSocket(   return PosixSocketWrapper(newfd); } +absl::StatusOr<PosixSocketWrapper::PosixSocketCreateResult>+PosixSocketWrapper::CreateAndPrepareTcpClientSocket(+    const PosixTcpOptions& options,+    const EventEngine::ResolvedAddress& target_addr) {+  PosixSocketWrapper::DSMode dsmode;+  EventEngine::ResolvedAddress output_mapped_target_addr;",This argument is no longer output-mapped. Please change the name.,
5564114,Vignesh2208,https://api.github.com/repos/grpc/grpc/pulls/31009,977104562,2022-09-22T01:29:45Z,src/core/lib/event_engine/posix_engine/tcp_socket_utils.h,"@@ -301,10 +303,33 @@ class PosixSocketWrapper {       const experimental::EventEngine::ResolvedAddress& addr, int type,       int protocol, DSMode& dsmode); +  struct PosixSocketCreateResult;",It wasn't letting me compile otherwise because the PosixSocketWrapper definition is not complete at that point. So I moved the CreateAndPrepareTcpClientSocket function outside the class definition and made it non static.,
5564114,Vignesh2208,https://api.github.com/repos/grpc/grpc/pulls/30559,977860583,2022-09-22T16:22:57Z,src/core/lib/event_engine/posix_engine/posix_endpoint.h,"@@ -0,0 +1,239 @@+// Copyright 2022 gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++#ifndef GRPC_CORE_LIB_EVENT_ENGINE_POSIX_ENGINE_POSIX_ENDPOINT_H+#define GRPC_CORE_LIB_EVENT_ENGINE_POSIX_ENGINE_POSIX_ENDPOINT_H++#include <grpc/support/port_platform.h>++#include <memory>++#include <grpc/event_engine/endpoint_config.h>+#include <grpc/event_engine/event_engine.h>+#include <grpc/event_engine/slice_buffer.h>++#include ""src/core/lib/event_engine/posix_engine/event_poller.h""+#include ""src/core/lib/event_engine/posix_engine/posix_engine_closure.h""+#include ""src/core/lib/event_engine/posix_engine/tcp_socket_utils.h""+#include ""src/core/lib/event_engine/posix_engine/traced_buffer_list.h""+#include ""src/core/lib/iomgr/port.h""++namespace grpc_event_engine {+namespace posix_engine {++#ifdef GRPC_POSIX_SOCKET_TCP++using ::grpc_event_engine::experimental::EndpointConfig;+using ::grpc_event_engine::experimental::EventEngine;+using ::grpc_event_engine::experimental::SliceBuffer;++class TcpZerocopySendCtx;",I moved the entire class definition over to the header file now.,X
5564114,Vignesh2208,https://api.github.com/repos/grpc/grpc/pulls/30559,977860911,2022-09-22T16:23:21Z,src/core/lib/event_engine/posix_engine/posix_endpoint.h,"@@ -0,0 +1,239 @@+// Copyright 2022 gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++#ifndef GRPC_CORE_LIB_EVENT_ENGINE_POSIX_ENGINE_POSIX_ENDPOINT_H+#define GRPC_CORE_LIB_EVENT_ENGINE_POSIX_ENGINE_POSIX_ENDPOINT_H++#include <grpc/support/port_platform.h>++#include <memory>++#include <grpc/event_engine/endpoint_config.h>+#include <grpc/event_engine/event_engine.h>+#include <grpc/event_engine/slice_buffer.h>++#include ""src/core/lib/event_engine/posix_engine/event_poller.h""+#include ""src/core/lib/event_engine/posix_engine/posix_engine_closure.h""+#include ""src/core/lib/event_engine/posix_engine/tcp_socket_utils.h""+#include ""src/core/lib/event_engine/posix_engine/traced_buffer_list.h""+#include ""src/core/lib/iomgr/port.h""++namespace grpc_event_engine {+namespace posix_engine {++#ifdef GRPC_POSIX_SOCKET_TCP++using ::grpc_event_engine::experimental::EndpointConfig;+using ::grpc_event_engine::experimental::EventEngine;+using ::grpc_event_engine::experimental::SliceBuffer;++class TcpZerocopySendCtx;+class TcpZerocopySendRecord;",I moved the entire class definition of TcpZerocopySendRecord over to the header file now.,X
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/30559,978064763,2022-09-22T20:39:30Z,src/core/lib/event_engine/posix_engine/posix_endpoint.h,"@@ -0,0 +1,637 @@+// Copyright 2022 gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++#ifndef GRPC_CORE_LIB_EVENT_ENGINE_POSIX_ENGINE_POSIX_ENDPOINT_H+#define GRPC_CORE_LIB_EVENT_ENGINE_POSIX_ENGINE_POSIX_ENDPOINT_H++#include <grpc/support/port_platform.h>++#include <atomic>+#include <memory>+#include <unordered_map>++#include <grpc/event_engine/endpoint_config.h>+#include <grpc/event_engine/event_engine.h>+#include <grpc/event_engine/slice_buffer.h>+#include <grpc/support/alloc.h>+#include <grpc/support/log.h>++#include ""src/core/lib/event_engine/posix_engine/event_poller.h""+#include ""src/core/lib/event_engine/posix_engine/posix_engine_closure.h""+#include ""src/core/lib/event_engine/posix_engine/tcp_socket_utils.h""+#include ""src/core/lib/event_engine/posix_engine/traced_buffer_list.h""+#include ""src/core/lib/iomgr/port.h""++namespace grpc_event_engine {+namespace posix_engine {++#ifdef GRPC_POSIX_SOCKET_TCP++#ifdef GRPC_MSG_IOVLEN_TYPE+typedef GRPC_MSG_IOVLEN_TYPE msg_iovlen_type;+#else+typedef size_t msg_iovlen_type;+#endif++class TcpZerocopySendRecord {+ public:+  TcpZerocopySendRecord() { buf_.Clear(); };++  ~TcpZerocopySendRecord() { AssertEmpty(); }++  // Given the slices that we wish to send, and the current offset into the+  //   slice buffer (indicating which have already been sent), populate an iovec+  //   array that will be used for a zerocopy enabled sendmsg().+  msg_iovlen_type PopulateIovs(size_t* unwind_slice_idx,+                               size_t* unwind_byte_idx, size_t* sending_length,+                               iovec* iov);++  // A sendmsg() may not be able to send the bytes that we requested at this+  // time, returning EAGAIN (possibly due to backpressure). In this case,+  // unwind the offset into the slice buffer so we retry sending these bytes.+  void UnwindIfThrottled(size_t unwind_slice_idx, size_t unwind_byte_idx) {+    out_offset_.byte_idx = unwind_byte_idx;+    out_offset_.slice_idx = unwind_slice_idx;+  }++  // Update the offset into the slice buffer based on how much we wanted to sent+  // vs. what sendmsg() actually sent (which may be lower, possibly due to+  // backpressure).+  void UpdateOffsetForBytesSent(size_t sending_length, size_t actually_sent);++  // Indicates whether all underlying data has been sent or not.+  bool AllSlicesSent() { return out_offset_.slice_idx == buf_.Count(); }++  // Reset this structure for a new tcp_write() with zerocopy.+  void PrepareForSends(+      grpc_event_engine::experimental::SliceBuffer& slices_to_send) {+    AssertEmpty();+    out_offset_.slice_idx = 0;+    out_offset_.byte_idx = 0;+    buf_.Swap(slices_to_send);+    Ref();+  }++  // References: 1 reference per sendmsg(), and 1 for the tcp_write().+  void Ref() { ref_.fetch_add(1, std::memory_order_relaxed); }++  // Unref: called when we get an error queue notification for a sendmsg(), if a+  //  sendmsg() failed or when tcp_write() is done.+  bool Unref() {+    const intptr_t prior = ref_.fetch_sub(1, std::memory_order_acq_rel);+    GPR_DEBUG_ASSERT(prior > 0);+    if (prior == 1) {+      AllSendsComplete();+      return true;+    }+    return false;+  }++ private:+  struct OutgoingOffset {+    size_t slice_idx = 0;+    size_t byte_idx = 0;+  };++  void AssertEmpty() {","Consider renaming to `DebugAssertEmpty`, since it's a no-op on non-debug builds.",X
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/30559,978070722,2022-09-22T20:44:39Z,src/core/lib/event_engine/posix_engine/posix_endpoint.h,"@@ -0,0 +1,637 @@+// Copyright 2022 gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++#ifndef GRPC_CORE_LIB_EVENT_ENGINE_POSIX_ENGINE_POSIX_ENDPOINT_H+#define GRPC_CORE_LIB_EVENT_ENGINE_POSIX_ENGINE_POSIX_ENDPOINT_H++#include <grpc/support/port_platform.h>++#include <atomic>+#include <memory>+#include <unordered_map>++#include <grpc/event_engine/endpoint_config.h>+#include <grpc/event_engine/event_engine.h>+#include <grpc/event_engine/slice_buffer.h>+#include <grpc/support/alloc.h>+#include <grpc/support/log.h>++#include ""src/core/lib/event_engine/posix_engine/event_poller.h""+#include ""src/core/lib/event_engine/posix_engine/posix_engine_closure.h""+#include ""src/core/lib/event_engine/posix_engine/tcp_socket_utils.h""+#include ""src/core/lib/event_engine/posix_engine/traced_buffer_list.h""+#include ""src/core/lib/iomgr/port.h""++namespace grpc_event_engine {+namespace posix_engine {++#ifdef GRPC_POSIX_SOCKET_TCP++#ifdef GRPC_MSG_IOVLEN_TYPE+typedef GRPC_MSG_IOVLEN_TYPE msg_iovlen_type;+#else+typedef size_t msg_iovlen_type;+#endif++class TcpZerocopySendRecord {+ public:+  TcpZerocopySendRecord() { buf_.Clear(); };++  ~TcpZerocopySendRecord() { AssertEmpty(); }++  // Given the slices that we wish to send, and the current offset into the+  //   slice buffer (indicating which have already been sent), populate an iovec+  //   array that will be used for a zerocopy enabled sendmsg().+  msg_iovlen_type PopulateIovs(size_t* unwind_slice_idx,+                               size_t* unwind_byte_idx, size_t* sending_length,+                               iovec* iov);++  // A sendmsg() may not be able to send the bytes that we requested at this+  // time, returning EAGAIN (possibly due to backpressure). In this case,+  // unwind the offset into the slice buffer so we retry sending these bytes.+  void UnwindIfThrottled(size_t unwind_slice_idx, size_t unwind_byte_idx) {+    out_offset_.byte_idx = unwind_byte_idx;+    out_offset_.slice_idx = unwind_slice_idx;+  }++  // Update the offset into the slice buffer based on how much we wanted to sent+  // vs. what sendmsg() actually sent (which may be lower, possibly due to+  // backpressure).+  void UpdateOffsetForBytesSent(size_t sending_length, size_t actually_sent);++  // Indicates whether all underlying data has been sent or not.+  bool AllSlicesSent() { return out_offset_.slice_idx == buf_.Count(); }++  // Reset this structure for a new tcp_write() with zerocopy.+  void PrepareForSends(+      grpc_event_engine::experimental::SliceBuffer& slices_to_send) {+    AssertEmpty();+    out_offset_.slice_idx = 0;+    out_offset_.byte_idx = 0;+    buf_.Swap(slices_to_send);+    Ref();+  }++  // References: 1 reference per sendmsg(), and 1 for the tcp_write().+  void Ref() { ref_.fetch_add(1, std::memory_order_relaxed); }++  // Unref: called when we get an error queue notification for a sendmsg(), if a+  //  sendmsg() failed or when tcp_write() is done.+  bool Unref() {+    const intptr_t prior = ref_.fetch_sub(1, std::memory_order_acq_rel);+    GPR_DEBUG_ASSERT(prior > 0);+    if (prior == 1) {+      AllSendsComplete();+      return true;+    }+    return false;+  }++ private:+  struct OutgoingOffset {+    size_t slice_idx = 0;+    size_t byte_idx = 0;+  };++  void AssertEmpty() {+    GPR_DEBUG_ASSERT(buf_.Count() == 0);+    GPR_DEBUG_ASSERT(buf_.Length() == 0);+    GPR_DEBUG_ASSERT(ref_.load(std::memory_order_relaxed) == 0);+  }++  // When all sendmsg() calls associated with this tcp_write() have been+  // completed (ie. we have received the notifications for each sequence number+  // for each sendmsg()) and all reference counts have been dropped, drop our+  // reference to the underlying data since we no longer need it.+  void AllSendsComplete() {+    GPR_DEBUG_ASSERT(ref_.load(std::memory_order_relaxed) == 0);+    buf_.Clear();+  }++  grpc_event_engine::experimental::SliceBuffer buf_;+  std::atomic<intptr_t> ref_{0};+  OutgoingOffset out_offset_;+};++class TcpZerocopySendCtx {+ public:+  static constexpr int kDefaultMaxSends = 4;+  static constexpr size_t kDefaultSendBytesThreshold = 16 * 1024;  // 16KB++  explicit TcpZerocopySendCtx(+      int max_sends = kDefaultMaxSends,+      size_t send_bytes_threshold = kDefaultSendBytesThreshold)+      : max_sends_(max_sends),+        free_send_records_size_(max_sends),+        threshold_bytes_(send_bytes_threshold) {+    send_records_ = static_cast<TcpZerocopySendRecord*>(+        gpr_malloc(max_sends * sizeof(*send_records_)));+    free_send_records_ = static_cast<TcpZerocopySendRecord**>(+        gpr_malloc(max_sends * sizeof(*free_send_records_)));+    if (send_records_ == nullptr || free_send_records_ == nullptr) {+      gpr_free(send_records_);+      gpr_free(free_send_records_);+      gpr_log(GPR_INFO, ""Disabling TCP TX zerocopy due to memory pressure.\n"");+      memory_limited_ = true;+    } else {+      for (int idx = 0; idx < max_sends_; ++idx) {+        new (send_records_ + idx) TcpZerocopySendRecord();+        free_send_records_[idx] = send_records_ + idx;+      }+    }+  }++  ~TcpZerocopySendCtx() {+    if (send_records_ != nullptr) {+      for (int idx = 0; idx < max_sends_; ++idx) {+        send_records_[idx].~TcpZerocopySendRecord();+      }+    }+    gpr_free(send_records_);+    gpr_free(free_send_records_);+  }++  // True if we were unable to allocate the various bookkeeping structures at+  // transport initialization time. If memory limited, we do not zerocopy.+  bool MemoryLimited() const { return memory_limited_; }++  // TCP send zerocopy maintains an implicit sequence number for every+  // successful sendmsg() with zerocopy enabled; the kernel later gives us an+  // error queue notification with this sequence number indicating that the+  // underlying data buffers that we sent can now be released. Once that+  // notification is received, we can release the buffers associated with this+  // zerocopy send record. Here, we associate the sequence number with the data+  // buffers that were sent with the corresponding call to sendmsg().+  void NoteSend(TcpZerocopySendRecord* record) {+    record->Ref();+    {+      absl::MutexLock guard(&lock_);+      is_in_write_ = true;+      AssociateSeqWithSendRecordLocked(last_send_, record);+    }+    ++last_send_;+  }++  // If sendmsg() actually failed, though, we need to revert the sequence number+  // that we speculatively bumped before calling sendmsg(). Note that we bump+  // this sequence number and perform relevant bookkeeping (see: NoteSend())+  // *before* calling sendmsg() since, if we called it *after* sendmsg(), then+  // there is a possible race with the release notification which could occur on+  // another thread before we do the necessary bookkeeping. Hence, calling+  // NoteSend() *before* sendmsg() and implementing an undo function is needed.+  void UndoSend() {+    --last_send_;+    if (ReleaseSendRecord(last_send_)->Unref()) {+      // We should still be holding the ref taken by tcp_write().+      GPR_DEBUG_ASSERT(0);+    }+  }++  // Simply associate this send record (and the underlying sent data buffers)+  // with the implicit sequence number for this zerocopy sendmsg().+  void AssociateSeqWithSendRecordLocked(uint32_t seq,+                                        TcpZerocopySendRecord* record) {+    ctx_lookup_.emplace(seq, record);+  }++  // Get a send record for a send that we wish to do with zerocopy.+  TcpZerocopySendRecord* GetSendRecord() {+    absl::MutexLock guard(&lock_);+    return TryGetSendRecordLocked();+  }++  // A given send record corresponds to a single tcp_write() with zerocopy+  // enabled. This can result in several sendmsg() calls to flush all of the+  // data to wire. Each sendmsg() takes a reference on the+  // TcpZerocopySendRecord, and corresponds to a single sequence number.+  // ReleaseSendRecord releases a reference on TcpZerocopySendRecord for a+  // single sequence number. This is called either when we receive the relevant+  // error queue notification (saying that we can discard the underlying+  // buffers for this sendmsg()) is received from the kernel - or, in case+  // sendmsg() was unsuccessful to begin with.+  TcpZerocopySendRecord* ReleaseSendRecord(uint32_t seq) {+    absl::MutexLock guard(&lock_);","Please avoid all direct uses of abseil's sync types in this codebase. Instead, use `grpc_core::MutexLock` and that whole family of similar sync shims (Mutex, Condvar, Notification, etc) for consistency across the codebase. This implementation may end up being used in MacOS environments, where abseil types could be problematic.",
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/30559,978083084,2022-09-22T21:02:24Z,src/core/lib/event_engine/posix_engine/posix_endpoint.cc,"@@ -0,0 +1,1135 @@+// Copyright 2022 gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+#include <grpc/support/port_platform.h>++#include ""src/core/lib/event_engine/posix_engine/posix_endpoint.h""++#include <memory>++#include ""absl/functional/any_invocable.h""+#include ""absl/status/status.h""+#include ""absl/synchronization/mutex.h""++#include <grpc/event_engine/endpoint_config.h>+#include <grpc/event_engine/slice.h>+#include <grpc/event_engine/slice_buffer.h>+#include <grpc/support/alloc.h>+#include <grpc/support/log.h>++#include ""src/core/lib/event_engine/posix_engine/event_poller.h""+#include ""src/core/lib/event_engine/posix_engine/internal_errqueue.h""+#include ""src/core/lib/event_engine/posix_engine/tcp_socket_utils.h""+#include ""src/core/lib/experiments/experiments.h""+#include ""src/core/lib/gprpp/global_config_generic.h""++#ifdef GRPC_POSIX_SOCKET_TCP+#ifdef GRPC_LINUX_ERRQUEUE+#include <linux/netlink.h>  // IWYU pragma: keep+#endif++#ifndef SOL_TCP+#define SOL_TCP IPPROTO_TCP+#endif++#ifndef TCP_INQ+#define TCP_INQ 36+#define TCP_CM_INQ TCP_INQ+#endif++#ifdef GRPC_HAVE_MSG_NOSIGNAL+#define SENDMSG_FLAGS MSG_NOSIGNAL+#else+#define SENDMSG_FLAGS 0+#endif++// TCP zero copy sendmsg flag.+// NB: We define this here as a fallback in case we're using an older set of+// library headers that has not defined MSG_ZEROCOPY. Since this constant is+// part of the kernel, we are guaranteed it will never change/disagree so+// defining it here is safe.+#ifndef MSG_ZEROCOPY+#define MSG_ZEROCOPY 0x4000000+#endif++#define MAX_READ_IOVEC 64++namespace grpc_event_engine {+namespace posix_engine {++namespace {++using ::grpc_event_engine::experimental::EndpointConfig;+using ::grpc_event_engine::experimental::EventEngine;+using ::grpc_event_engine::experimental::Slice;+using ::grpc_event_engine::experimental::SliceBuffer;++// A wrapper around sendmsg. It sends \a msg over \a fd and returns the number+// of bytes sent.+ssize_t TcpSend(int fd, const struct msghdr* msg, int* saved_errno,+                int additional_flags = 0) {+  ssize_t sent_length;+  do {+    sent_length = sendmsg(fd, msg, SENDMSG_FLAGS | additional_flags);+  } while (sent_length < 0 && (*saved_errno = errno) == EINTR);+  return sent_length;+}++#ifdef GRPC_LINUX_ERRQUEUE+// Whether the cmsg received from error queue is of the IPv4 or IPv6 levels.+bool CmsgIsIpLevel(const cmsghdr& cmsg) {+  return (cmsg.cmsg_level == SOL_IPV6 && cmsg.cmsg_type == IPV6_RECVERR) ||+         (cmsg.cmsg_level == SOL_IP && cmsg.cmsg_type == IP_RECVERR);+}++bool CmsgIsZeroCopy(const cmsghdr& cmsg) {+  if (!CmsgIsIpLevel(cmsg)) {+    return false;+  }+  auto serr = reinterpret_cast<const sock_extended_err*> CMSG_DATA(&cmsg);+  return serr->ee_errno == 0 && serr->ee_origin == SO_EE_ORIGIN_ZEROCOPY;+}+#endif  // GRPC_LINUX_ERRQUEUE++}  // namespace++#if defined(IOV_MAX) && IOV_MAX < 260+#define MAX_WRITE_IOVEC IOV_MAX+#else+#define MAX_WRITE_IOVEC 260+#endif+msg_iovlen_type TcpZerocopySendRecord::PopulateIovs(size_t* unwind_slice_idx,+                                                    size_t* unwind_byte_idx,+                                                    size_t* sending_length,+                                                    iovec* iov) {+  msg_iovlen_type iov_size;+  *unwind_slice_idx = out_offset_.slice_idx;+  *unwind_byte_idx = out_offset_.byte_idx;+  for (iov_size = 0;+       out_offset_.slice_idx != buf_.Count() && iov_size != MAX_WRITE_IOVEC;+       iov_size++) {+    auto slice = buf_.RefSlice(out_offset_.slice_idx);+    iov[iov_size].iov_base =+        const_cast<uint8_t*>(slice.begin()) + out_offset_.byte_idx;+    iov[iov_size].iov_len = slice.length() - out_offset_.byte_idx;+    *sending_length += iov[iov_size].iov_len;+    ++(out_offset_.slice_idx);+    out_offset_.byte_idx = 0;+  }+  GPR_DEBUG_ASSERT(iov_size > 0);+  return iov_size;+}++void TcpZerocopySendRecord::UpdateOffsetForBytesSent(size_t sending_length,+                                                     size_t actually_sent) {+  size_t trailing = sending_length - actually_sent;+  while (trailing > 0) {+    size_t slice_length;+    out_offset_.slice_idx--;+    slice_length = buf_.RefSlice(out_offset_.slice_idx).length();+    if (slice_length > trailing) {+      out_offset_.byte_idx = slice_length - trailing;+      break;+    } else {+      trailing -= slice_length;+    }+  }+}++void PosixEndpointImpl::AddToEstimate(size_t bytes) {+  bytes_read_this_round_ += static_cast<double>(bytes);+}++void PosixEndpointImpl::FinishEstimate() {+  // If we read >80% of the target buffer in one read loop, increase the size of+  // the target buffer to either the amount read, or twice its previous value.+  if (bytes_read_this_round_ > target_length_ * 0.8) {+    target_length_ = std::max(2 * target_length_, bytes_read_this_round_);+  } else {+    target_length_ = 0.99 * target_length_ + 0.01 * bytes_read_this_round_;+  }+  bytes_read_this_round_ = 0;+}++// Returns true if data available to read or error other than EAGAIN.+bool PosixEndpointImpl::TcpDoRead(absl::Status& status) {+  struct msghdr msg;+  struct iovec iov[MAX_READ_IOVEC];+  ssize_t read_bytes;+  size_t total_read_bytes = 0;+  size_t iov_len = std::min<size_t>(MAX_READ_IOVEC, incoming_buffer_->Count());+#ifdef GRPC_LINUX_ERRQUEUE+  constexpr size_t cmsg_alloc_space =+      CMSG_SPACE(sizeof(scm_timestamping)) + CMSG_SPACE(sizeof(int));+#else+  constexpr size_t cmsg_alloc_space = 24 /* CMSG_SPACE(sizeof(int)) */;+#endif /* GRPC_LINUX_ERRQUEUE */+  char cmsgbuf[cmsg_alloc_space];+  for (size_t i = 0; i < iov_len; i++) {+    Slice slice = incoming_buffer_->RefSlice(i);+    iov[i].iov_base = const_cast<uint8_t*>(slice.begin());+    iov[i].iov_len = slice.length();+  }++  GPR_ASSERT(incoming_buffer_->Length() != 0);+  GPR_DEBUG_ASSERT(min_progress_size_ > 0);++  do {+    // Assume there is something on the queue. If we receive TCP_INQ from+    // kernel, we will update this value, otherwise, we have to assume there is+    // always something to read until we get EAGAIN.+    inq_ = 1;++    msg.msg_name = nullptr;+    msg.msg_namelen = 0;+    msg.msg_iov = iov;+    msg.msg_iovlen = static_cast<msg_iovlen_type>(iov_len);+    if (inq_capable_) {+      msg.msg_control = cmsgbuf;+      msg.msg_controllen = sizeof(cmsgbuf);+    } else {+      msg.msg_control = nullptr;+      msg.msg_controllen = 0;+    }+    msg.msg_flags = 0;++    do {+      read_bytes = recvmsg(fd_, &msg, 0);+    } while (read_bytes < 0 && errno == EINTR);++    // We have read something in previous reads. We need to deliver those bytes+    // to the upper layer.+    if (read_bytes <= 0 &&+        total_read_bytes >= static_cast<size_t>(min_progress_size_)) {+      inq_ = 1;+      break;+    }++    if (read_bytes < 0) {+      // NB: After calling call_read_cb a parallel call of the read handler may+      // be running.+      if (errno == EAGAIN) {+        if (total_read_bytes > 0) {+          break;+        }+        FinishEstimate();+        inq_ = 0;+        return false;+      } else {+        incoming_buffer_->Clear();+        status =+            absl::InternalError(absl::StrCat(""recvmsg:"", std::strerror(errno)));+        return true;+      }+    }+    if (read_bytes == 0) {+      // 0 read size ==> end of stream+      //+      // We may have read something, i.e., total_read_bytes > 0, but since the+      // connection is closed we will drop the data here, because we can't call+      // the callback multiple times.+      incoming_buffer_->Clear();+      status = absl::InternalError(""Socket closed"");+      return true;+    }++    AddToEstimate(static_cast<size_t>(read_bytes));+    GPR_DEBUG_ASSERT((size_t)read_bytes <=+                     incoming_buffer_->Length() - total_read_bytes);++#ifdef GRPC_HAVE_TCP_INQ+    if (inq_capable_) {+      GPR_DEBUG_ASSERT(!(msg.msg_flags & MSG_CTRUNC));+      struct cmsghdr* cmsg = CMSG_FIRSTHDR(&msg);+      for (; cmsg != nullptr; cmsg = CMSG_NXTHDR(&msg, cmsg)) {+        if (cmsg->cmsg_level == SOL_TCP && cmsg->cmsg_type == TCP_CM_INQ &&+            cmsg->cmsg_len == CMSG_LEN(sizeof(int))) {+          inq_ = *reinterpret_cast<int*>(CMSG_DATA(cmsg));+          break;+        }+      }+    }+#endif  // GRPC_HAVE_TCP_INQ++    total_read_bytes += read_bytes;+    if (inq_ == 0 || total_read_bytes == incoming_buffer_->Length()) {+      break;+    }++    // We had a partial read, and still have space to read more data. So, adjust+    // IOVs and try to read more.+    size_t remaining = read_bytes;+    size_t j = 0;+    for (size_t i = 0; i < iov_len; i++) {+      if (remaining >= iov[i].iov_len) {+        remaining -= iov[i].iov_len;+        continue;+      }+      if (remaining > 0) {+        iov[j].iov_base = static_cast<char*>(iov[i].iov_base) + remaining;+        iov[j].iov_len = iov[i].iov_len - remaining;+        remaining = 0;+      } else {+        iov[j].iov_base = iov[i].iov_base;+        iov[j].iov_len = iov[i].iov_len;+      }+      ++j;+    }+    iov_len = j;+  } while (true);++  if (inq_ == 0) {+    FinishEstimate();+  }++  GPR_DEBUG_ASSERT(total_read_bytes > 0);+  status = absl::OkStatus();+  if (frame_size_tuning_enabled_) {+    // Update min progress size based on the total number of bytes read in+    // this round.+    min_progress_size_ -= total_read_bytes;+    if (min_progress_size_ > 0) {+      // There is still some bytes left to be read before we can signal+      // the read as complete. Append the bytes read so far into+      // last_read_buffer which serves as a staging buffer. Return false+      // to indicate tcp_handle_read needs to be scheduled again.+      incoming_buffer_->MoveFirstNBytesIntoSliceBuffer(total_read_bytes,+                                                       last_read_buffer_);+      return false;+    } else {+      // The required number of bytes have been read. Append the bytes+      // read in this round into last_read_buffer. Then swap last_read_buffer+      // and incoming_buffer. Now incoming buffer contains all the bytes+      // read since the start of the last tcp_read operation. last_read_buffer+      // would contain any spare space left in the incoming buffer. This+      // space will be used in the next tcp_read operation.+      min_progress_size_ = 1;+      incoming_buffer_->MoveFirstNBytesIntoSliceBuffer(total_read_bytes,+                                                       last_read_buffer_);+      incoming_buffer_->Swap(last_read_buffer_);+      return true;+    }+  }+  if (total_read_bytes < incoming_buffer_->Length()) {+    incoming_buffer_->RemoveLastNBytesIntoSliceBuffer(+        incoming_buffer_->Length() - total_read_bytes, last_read_buffer_);+    // last_read_buffer_.Clear();+  }+  return true;+}++void PosixEndpointImpl::PerformReclamation() {+  read_mu_.Lock();+  if (incoming_buffer_ != nullptr) {+    incoming_buffer_->Clear();+  }+  has_posted_reclaimer_ = false;+  read_mu_.Unlock();+}++void PosixEndpointImpl::MaybePostReclaimer() {+  if (!has_posted_reclaimer_) {+    has_posted_reclaimer_ = true;+    memory_owner_.PostReclaimer(+        grpc_core::ReclamationPass::kBenign,+        [this](absl::optional<grpc_core::ReclamationSweep> sweep) {+          if (!sweep.has_value()) return;+          PerformReclamation();+        });+  }+}++void PosixEndpointImpl::UpdateRcvLowat() {+  if (!grpc_core::IsTcpRcvLowatEnabled()) return;++  // TODO(ctiller): Check if supported by OS.+  // TODO(ctiller): Allow some adjustments instead of hardcoding things.++  static constexpr int kRcvLowatMax = 16 * 1024 * 1024;+  static constexpr int kRcvLowatThreshold = 16 * 1024;++  int remaining = std::min(static_cast<int>(incoming_buffer_->Length()),+                           min_progress_size_);+  remaining = std::min(remaining, kRcvLowatMax);++  // Setting SO_RCVLOWAT for small quantities does not save on CPU.+  if (remaining < kRcvLowatThreshold) {+    remaining = 0;+  }++  // If zerocopy is off, wake shortly before the full RPC is here. More can+  // show up partway through recvmsg() since it takes a while to copy data.+  // So an early wakeup aids latency.+  if (!tcp_zerocopy_send_ctx_->Enabled() && remaining > 0) {+    remaining -= kRcvLowatThreshold;+  }++  // We still do not know the RPC size. Do not set SO_RCVLOWAT.+  if (set_rcvlowat_ <= 1 && remaining <= 1) return;++  // Previous value is still valid. No change needed in SO_RCVLOWAT.+  if (set_rcvlowat_ == remaining) {+    return;+  }+  auto result = sock_.SetSocketRcvLowat(remaining);+  if (result.ok()) {+    set_rcvlowat_ = *result;+  } else {+    gpr_log(GPR_ERROR, ""%s"",+            absl::StrCat(""ERROR in SO_RCVLOWAT: "", result.status().message())+                .c_str());+  }+}++void PosixEndpointImpl::MaybeMakeReadSlices() {+  if (grpc_core::IsTcpReadChunksEnabled()) {+    static const int kBigAlloc = 64 * 1024;+    static const int kSmallAlloc = 8 * 1024;+    if (incoming_buffer_->Length() < static_cast<size_t>(min_progress_size_)) {+      size_t allocate_length = min_progress_size_;+      const size_t target_length = static_cast<size_t>(target_length_);+      // If memory pressure is low and we think there will be more than+      // min_progress_size bytes to read, allocate a bit more.+      const bool low_memory_pressure =+          memory_owner_.GetPressureInfo().pressure_control_value < 0.8;+      if (low_memory_pressure && target_length > allocate_length) {+        allocate_length = target_length;+      }+      int extra_wanted =+          allocate_length - static_cast<int>(incoming_buffer_->Length());+      if (extra_wanted >=+          (low_memory_pressure ? kSmallAlloc * 3 / 2 : kBigAlloc)) {+        while (extra_wanted > 0) {+          extra_wanted -= kBigAlloc;+          incoming_buffer_->AppendIndexed(+              Slice(memory_owner_.MakeSlice(kBigAlloc)));+          // GRPC_STATS_INC_TCP_READ_ALLOC_64K();+        }+      } else {+        while (extra_wanted > 0) {+          extra_wanted -= kSmallAlloc;+          incoming_buffer_->AppendIndexed(+              Slice(memory_owner_.MakeSlice(kSmallAlloc)));+          // GRPC_STATS_INC_TCP_READ_ALLOC_8K();+        }+      }+      MaybePostReclaimer();+    }+  } else {+    if (incoming_buffer_->Length() < static_cast<size_t>(min_progress_size_) &&+        incoming_buffer_->Count() < MAX_READ_IOVEC) {+      int target_length =+          std::max(static_cast<int>(target_length_), min_progress_size_);+      int extra_wanted =+          target_length - static_cast<int>(incoming_buffer_->Length());+      int min_read_chunk_size =+          std::max(min_read_chunk_size_, min_progress_size_);+      int max_read_chunk_size =+          std::max(max_read_chunk_size_, min_progress_size_);+      incoming_buffer_->AppendIndexed(+          Slice(memory_owner_.MakeSlice(grpc_core::MemoryRequest(+              min_read_chunk_size,+              grpc_core::Clamp(extra_wanted, min_read_chunk_size,+                               max_read_chunk_size)))));+      MaybePostReclaimer();+    }+  }+}++void PosixEndpointImpl::HandleRead(absl::Status status) {+  read_mu_.Lock();+  if (status.ok()) {+    MaybeMakeReadSlices();+    if (!TcpDoRead(status)) {+      // We've consumed the edge, request a new one.+      read_mu_.Unlock();+      handle_->NotifyOnRead(on_read_);+      return;+    }+  } else {+    incoming_buffer_->Clear();+    last_read_buffer_.Clear();+  }+  absl::AnyInvocable<void(absl::Status)> cb = std::move(read_cb_);+  read_cb_ = nullptr;+  incoming_buffer_ = nullptr;+  read_mu_.Unlock();+  cb(status);+  Unref();+}++void PosixEndpointImpl::Read(absl::AnyInvocable<void(absl::Status)> on_read,+                             SliceBuffer* buffer,+                             const EventEngine::Endpoint::ReadArgs* args) {+  GPR_ASSERT(read_cb_ == nullptr);+  read_mu_.Lock();+  read_cb_ = std::move(on_read);+  incoming_buffer_ = buffer;+  incoming_buffer_->Clear();+  incoming_buffer_->Swap(last_read_buffer_);+  read_mu_.Unlock();+  if (args != nullptr && frame_size_tuning_enabled_) {+    min_progress_size_ = args->read_hint_bytes;+  } else {+    min_progress_size_ = 1;+  }+  Ref();+  if (is_first_read_) {+    // Endpoint read called for the very first time. Register read callback+    // with the polling engine.+    is_first_read_ = false;+    handle_->NotifyOnRead(on_read_);+  } else if (inq_ == 0) {+    // Upper layer asked to read more but we know there is no pending data to+    // read from previous reads. So, wait for POLLIN.+    handle_->NotifyOnRead(on_read_);+  } else {+    on_read_->SetStatus(absl::OkStatus());+    engine_->Run(on_read_);+  }+}++#ifdef GRPC_LINUX_ERRQUEUE+TcpZerocopySendRecord* PosixEndpointImpl::TcpGetSendZerocopyRecord(+    SliceBuffer& buf) {+  TcpZerocopySendRecord* zerocopy_send_record = nullptr;+  const bool use_zerocopy =+      tcp_zerocopy_send_ctx_->Enabled() &&+      tcp_zerocopy_send_ctx_->ThresholdBytes() < buf.Length();+  if (use_zerocopy) {+    zerocopy_send_record = tcp_zerocopy_send_ctx_->GetSendRecord();+    if (zerocopy_send_record == nullptr) {+      ProcessErrors();+      zerocopy_send_record = tcp_zerocopy_send_ctx_->GetSendRecord();+    }+    if (zerocopy_send_record != nullptr) {+      zerocopy_send_record->PrepareForSends(buf);+      GPR_DEBUG_ASSERT(buf.Count() == 0);+      GPR_DEBUG_ASSERT(buf.Length() == 0);+      outgoing_byte_idx_ = 0;+      outgoing_buffer_ = nullptr;+    }+  }+  return zerocopy_send_record;+}++// For linux platforms, reads the socket's error queue and processes error+// messages from the queue.+bool PosixEndpointImpl::ProcessErrors() {+  bool processed_err = false;+  struct iovec iov;+  iov.iov_base = nullptr;+  iov.iov_len = 0;+  struct msghdr msg;+  msg.msg_name = nullptr;+  msg.msg_namelen = 0;+  msg.msg_iov = &iov;+  msg.msg_iovlen = 0;+  msg.msg_flags = 0;+  // Allocate enough space so we don't need to keep increasing this as size of+  // OPT_STATS increase.+  constexpr size_t cmsg_alloc_space =+      CMSG_SPACE(sizeof(scm_timestamping)) ++      CMSG_SPACE(sizeof(sock_extended_err) + sizeof(sockaddr_in)) ++      CMSG_SPACE(32 * NLA_ALIGN(NLA_HDRLEN + sizeof(uint64_t)));+  // Allocate aligned space for cmsgs received along with timestamps.+  union {+    char rbuf[cmsg_alloc_space];+    struct cmsghdr align;+  } aligned_buf;+  msg.msg_control = aligned_buf.rbuf;+  int r, saved_errno;+  while (true) {+    msg.msg_controllen = sizeof(aligned_buf.rbuf);+    do {+      r = recvmsg(fd_, &msg, MSG_ERRQUEUE);+      saved_errno = errno;+    } while (r < 0 && saved_errno == EINTR);++    if (r < 0 && saved_errno == EAGAIN) {+      return processed_err;  // No more errors to process+    } else if (r < 0) {+      return processed_err;+    }+    if (ABSL_PREDICT_FALSE((msg.msg_flags & MSG_CTRUNC) != 0)) {+      gpr_log(GPR_ERROR, ""Error message was truncated."");+    }++    if (msg.msg_controllen == 0) {+      // There was no control message found. It was probably spurious.+      return processed_err;+    }+    bool seen = false;+    for (auto cmsg = CMSG_FIRSTHDR(&msg); cmsg && cmsg->cmsg_len;+         cmsg = CMSG_NXTHDR(&msg, cmsg)) {+      if (CmsgIsZeroCopy(*cmsg)) {+        ProcessZerocopy(cmsg);+        seen = true;+        processed_err = true;+      } else if (cmsg->cmsg_level == SOL_SOCKET &&+                 cmsg->cmsg_type == SCM_TIMESTAMPING) {+        cmsg = ProcessTimestamp(&msg, cmsg);+        seen = true;+        processed_err = true;+      } else {+        // Got a control message that is not a timestamp or zerocopy. Don't know+        // how to handle this.+        return processed_err;+      }+    }+    if (!seen) {+      return processed_err;+    }+  }+}++void PosixEndpointImpl::ZerocopyDisableAndWaitForRemaining() {+  tcp_zerocopy_send_ctx_->Shutdown();+  while (!tcp_zerocopy_send_ctx_->AllSendRecordsEmpty()) {+    ProcessErrors();+  }+}++// Reads \a cmsg to process zerocopy control messages.+void PosixEndpointImpl::ProcessZerocopy(struct cmsghdr* cmsg) {+  GPR_DEBUG_ASSERT(cmsg);+  auto serr = reinterpret_cast<struct sock_extended_err*>(CMSG_DATA(cmsg));+  GPR_DEBUG_ASSERT(serr->ee_errno == 0);+  GPR_DEBUG_ASSERT(serr->ee_origin == SO_EE_ORIGIN_ZEROCOPY);+  const uint32_t lo = serr->ee_info;+  const uint32_t hi = serr->ee_data;+  for (uint32_t seq = lo; seq <= hi; ++seq) {+    // TODO(arjunroy): It's likely that lo and hi refer to zerocopy sequence+    // numbers that are generated by a single call to grpc_endpoint_write; ie.+    // we can batch the unref operation. So, check if record is the same for+    // both; if so, batch the unref/put.+    TcpZerocopySendRecord* record =+        tcp_zerocopy_send_ctx_->ReleaseSendRecord(seq);+    GPR_DEBUG_ASSERT(record);+    UnrefMaybePutZerocopySendRecord(record);+  }+  if (tcp_zerocopy_send_ctx_->UpdateZeroCopyOptMemStateAfterFree()) {+    handle_->SetWritable();+  }+}++// Reads \a cmsg to derive timestamps from the control messages. If a valid+// timestamp is found, the traced buffer list is updated with this timestamp.+// The caller of this function should be looping on the control messages found+// in \a msg. \a cmsg should point to the control message that the caller wants+// processed. On return, a pointer to a control message is returned. On the next+// iteration, CMSG_NXTHDR(msg, ret_val) should be passed as \a cmsg.+struct cmsghdr* PosixEndpointImpl::ProcessTimestamp(msghdr* msg,+                                                    struct cmsghdr* cmsg) {+  auto next_cmsg = CMSG_NXTHDR(msg, cmsg);+  cmsghdr* opt_stats = nullptr;+  if (next_cmsg == nullptr) {+    return cmsg;+  }++  // Check if next_cmsg is an OPT_STATS msg.+  if (next_cmsg->cmsg_level == SOL_SOCKET &&+      next_cmsg->cmsg_type == SCM_TIMESTAMPING_OPT_STATS) {+    opt_stats = next_cmsg;+    next_cmsg = CMSG_NXTHDR(msg, opt_stats);+    if (next_cmsg == nullptr) {+      return opt_stats;+    }+  }++  if (!(next_cmsg->cmsg_level == SOL_IP || next_cmsg->cmsg_level == SOL_IPV6) ||+      !(next_cmsg->cmsg_type == IP_RECVERR ||+        next_cmsg->cmsg_type == IPV6_RECVERR)) {+    return cmsg;+  }++  auto tss = reinterpret_cast<scm_timestamping*>(CMSG_DATA(cmsg));+  auto serr = reinterpret_cast<struct sock_extended_err*>(CMSG_DATA(next_cmsg));+  if (serr->ee_errno != ENOMSG ||+      serr->ee_origin != SO_EE_ORIGIN_TIMESTAMPING) {+    gpr_log(GPR_ERROR, ""Unexpected control message"");+    return cmsg;+  }+  // The error handling can potentially be done on another thread so we need to+  // protect the traced buffer list. A lock free list might be better. Using a+  // simple mutex for now.+  {+    absl::MutexLock lock(&traced_buffer_mu_);+    traced_buffers_.ProcessTimestamp(serr, opt_stats, tss);+  }+  return next_cmsg;+}++void PosixEndpointImpl::HandleError(absl::Status status) {+  if (!status.ok() ||+      stop_error_notification_.load(std::memory_order_relaxed)) {+    // We aren't going to register to hear on error anymore, so it is safe to+    // unref.+    Unref();+    return;+  }+  // We are still interested in collecting timestamps, so let's try reading+  // them.+  if (!ProcessErrors()) {+    // This might not a timestamps error. Set the read and write closures to be+    // ready.+    handle_->SetReadable();+    handle_->SetWritable();+  }+  handle_->NotifyOnError(on_error_);+}++bool PosixEndpointImpl::WriteWithTimestamps(struct msghdr* msg,+                                            size_t sending_length,+                                            ssize_t* sent_length,+                                            int* saved_errno,+                                            int additional_flags) {+  if (!socket_ts_enabled_) {+    uint32_t opt = kTimestampingSocketOptions;+    if (setsockopt(fd_, SOL_SOCKET, SO_TIMESTAMPING, static_cast<void*>(&opt),+                   sizeof(opt)) != 0) {+      return false;+    }+    bytes_counter_ = -1;+    socket_ts_enabled_ = true;+  }+  // Set control message to indicate that you want timestamps.+  union {+    char cmsg_buf[CMSG_SPACE(sizeof(uint32_t))];+    struct cmsghdr align;+  } u;+  cmsghdr* cmsg = reinterpret_cast<cmsghdr*>(u.cmsg_buf);+  cmsg->cmsg_level = SOL_SOCKET;+  cmsg->cmsg_type = SO_TIMESTAMPING;+  cmsg->cmsg_len = CMSG_LEN(sizeof(uint32_t));+  *reinterpret_cast<int*>(CMSG_DATA(cmsg)) = kTimestampingRecordingOptions;+  msg->msg_control = u.cmsg_buf;+  msg->msg_controllen = CMSG_SPACE(sizeof(uint32_t));++  // If there was an error on sendmsg the logic in tcp_flush will handle it.+  ssize_t length = TcpSend(fd_, msg, saved_errno, additional_flags);+  *sent_length = length;+  // Only save timestamps if all the bytes were taken by sendmsg.+  if (sending_length == static_cast<size_t>(length)) {+    traced_buffer_mu_.Lock();+    traced_buffers_.AddNewEntry(static_cast<uint32_t>(bytes_counter_ + length),+                                fd_, outgoing_buffer_arg_);+    traced_buffer_mu_.Unlock();+    outgoing_buffer_arg_ = nullptr;+  }+  return true;+}++#else+TcpZerocopySendRecord* PosixEndpointImpl::TcpGetSendZerocopyRecord(+    SliceBuffer& /*buf*/) {+  return nullptr;+}++void PosixEndpointImpl::HandleError(absl::Status /*status*/) {+  GPR_ASSERT(false && ""Error handling not supported on this platform"");+}++void PosixEndpointImpl::ZerocopyDisableAndWaitForRemaining() {}++bool PosixEndpointImpl::WriteWithTimestamps(struct msghdr* /*msg*/,+                                            size_t /*sending_length*/,+                                            ssize_t* /*sent_length*/,+                                            int* /*saved_errno*/,+                                            int /*additional_flags*/) {+  GPR_ASSERT(false && ""Write with timestamps not supported for this platform"");+}+#endif /* GRPC_LINUX_ERRQUEUE */++void PosixEndpointImpl::UnrefMaybePutZerocopySendRecord(+    TcpZerocopySendRecord* record) {+  if (record->Unref()) {+    tcp_zerocopy_send_ctx_->PutSendRecord(record);+  }+}++// If outgoing_buffer_arg is filled, shuts down the list early, so that any+// release operations needed can be performed on the arg.+void PosixEndpointImpl::TcpShutdownTracedBufferList() {+  if (outgoing_buffer_arg_ != nullptr) {+    traced_buffer_mu_.Lock();+    traced_buffers_.Shutdown(outgoing_buffer_arg_,+                             absl::InternalError(""TracedBuffer list shutdown""));+    traced_buffer_mu_.Unlock();+    outgoing_buffer_arg_ = nullptr;+  }+}++// returns true if done, false if pending; if returning true, *error is set+bool PosixEndpointImpl::DoFlushZerocopy(TcpZerocopySendRecord* record,+                                        absl::Status& status) {+  msg_iovlen_type iov_size;+  ssize_t sent_length = 0;+  size_t sending_length;+  size_t unwind_slice_idx;+  size_t unwind_byte_idx;+  bool tried_sending_message;+  int saved_errno;+  msghdr msg;+  status = absl::OkStatus();+  // iov consumes a large space. Keep it as the last item on the stack to+  // improve locality. After all, we expect only the first elements of it+  // being populated in most cases.+  iovec iov[MAX_WRITE_IOVEC];+  while (true) {+    sending_length = 0;+    iov_size = record->PopulateIovs(&unwind_slice_idx, &unwind_byte_idx,+                                    &sending_length, iov);+    msg.msg_name = nullptr;+    msg.msg_namelen = 0;+    msg.msg_iov = iov;+    msg.msg_iovlen = iov_size;+    msg.msg_flags = 0;+    tried_sending_message = false;+    // Before calling sendmsg (with or without timestamps): we+    // take a single ref on the zerocopy send record.+    tcp_zerocopy_send_ctx_->NoteSend(record);+    saved_errno = 0;+    if (outgoing_buffer_arg_ != nullptr) {+      if (!ts_capable_ ||+          !WriteWithTimestamps(&msg, sending_length, &sent_length, &saved_errno,+                               MSG_ZEROCOPY)) {+        // We could not set socket options to collect Fathom timestamps.+        // Fallback on writing without timestamps.+        ts_capable_ = false;+        TcpShutdownTracedBufferList();+      } else {+        tried_sending_message = true;+      }+    }+    if (!tried_sending_message) {+      msg.msg_control = nullptr;+      msg.msg_controllen = 0;+      sent_length = TcpSend(fd_, &msg, &saved_errno, MSG_ZEROCOPY);+    }+    if (tcp_zerocopy_send_ctx_->UpdateZeroCopyOptMemStateAfterSend(+            saved_errno == ENOBUFS)) {+      handle_->SetWritable();+    }+    if (sent_length < 0) {+      // If this particular send failed, drop ref taken earlier in this method.+      tcp_zerocopy_send_ctx_->UndoSend();+      if (saved_errno == EAGAIN || saved_errno == ENOBUFS) {+        record->UnwindIfThrottled(unwind_slice_idx, unwind_byte_idx);+        return false;+      } else {+        status = absl::InternalError(+            absl::StrCat(""sendmsg"", std::strerror(saved_errno)));+        TcpShutdownTracedBufferList();+        return true;+      }+    }+    bytes_counter_ += sent_length;+    record->UpdateOffsetForBytesSent(sending_length,+                                     static_cast<size_t>(sent_length));+    if (record->AllSlicesSent()) {+      return true;+    }+  }+}++bool PosixEndpointImpl::TcpFlushZerocopy(TcpZerocopySendRecord* record,+                                         absl::Status& status) {+  bool done = DoFlushZerocopy(record, status);+  if (done) {+    // Either we encountered an error, or we successfully sent all the bytes.+    // In either case, we're done with this record.+    UnrefMaybePutZerocopySendRecord(record);+  }+  return done;+}++bool PosixEndpointImpl::TcpFlush(absl::Status& status) {+  struct msghdr msg;+  struct iovec iov[MAX_WRITE_IOVEC];+  msg_iovlen_type iov_size;+  ssize_t sent_length = 0;+  size_t sending_length;+  size_t trailing;+  size_t unwind_slice_idx;+  size_t unwind_byte_idx;+  int saved_errno;+  status = absl::OkStatus();++  // We always start at zero, because we eagerly unref and trim the slice+  // buffer as we write+  size_t outgoing_slice_idx = 0;++  while (true) {+    sending_length = 0;+    unwind_slice_idx = outgoing_slice_idx;+    unwind_byte_idx = outgoing_byte_idx_;+    for (iov_size = 0; outgoing_slice_idx != outgoing_buffer_->Count() &&+                       iov_size != MAX_WRITE_IOVEC;+         iov_size++) {+      auto slice = outgoing_buffer_->RefSlice(outgoing_slice_idx);+      iov[iov_size].iov_base =+          const_cast<uint8_t*>(slice.begin()) + outgoing_byte_idx_;+      iov[iov_size].iov_len = slice.length() - outgoing_byte_idx_;+      sending_length += iov[iov_size].iov_len;+      outgoing_slice_idx++;+      outgoing_byte_idx_ = 0;+    }+    GPR_ASSERT(iov_size > 0);++    msg.msg_name = nullptr;+    msg.msg_namelen = 0;+    msg.msg_iov = iov;+    msg.msg_iovlen = iov_size;+    msg.msg_flags = 0;+    bool tried_sending_message = false;+    saved_errno = 0;+    if (outgoing_buffer_arg_ != nullptr) {+      if (!ts_capable_ || !WriteWithTimestamps(&msg, sending_length,+                                               &sent_length, &saved_errno, 0)) {+        // We could not set socket options to collect Fathom timestamps.+        // Fallback on writing without timestamps.+        ts_capable_ = false;+        TcpShutdownTracedBufferList();+      } else {+        tried_sending_message = true;+      }+    }+    if (!tried_sending_message) {+      msg.msg_control = nullptr;+      msg.msg_controllen = 0;+      sent_length = TcpSend(fd_, &msg, &saved_errno);+    }++    if (sent_length < 0) {+      if (saved_errno == EAGAIN || saved_errno == ENOBUFS) {+        outgoing_byte_idx_ = unwind_byte_idx;+        // unref all and forget about all slices that have been written to this+        // point+        for (size_t idx = 0; idx < unwind_slice_idx; ++idx) {+          outgoing_buffer_->TakeFirst();+        }+        return false;+      } else {+        status = absl::InternalError(+            absl::StrCat(""sendmsg"", std::strerror(saved_errno)));+        outgoing_buffer_->Clear();+        TcpShutdownTracedBufferList();+        return true;+      }+    }++    GPR_ASSERT(outgoing_byte_idx_ == 0);+    bytes_counter_ += sent_length;+    trailing = sending_length - static_cast<size_t>(sent_length);+    while (trailing > 0) {+      size_t slice_length;+      outgoing_slice_idx--;+      slice_length = outgoing_buffer_->RefSlice(outgoing_slice_idx).length();+      if (slice_length > trailing) {+        outgoing_byte_idx_ = slice_length - trailing;+        break;+      } else {+        trailing -= slice_length;+      }+    }+    if (outgoing_slice_idx == outgoing_buffer_->Count()) {+      outgoing_buffer_->Clear();+      return true;+    }+  }+}++void PosixEndpointImpl::HandleWrite(absl::Status status) {+  if (!status.ok()) {+    absl::AnyInvocable<void(absl::Status)> cb_ = std::move(write_cb_);+    write_cb_ = nullptr;+    if (current_zerocopy_send_ != nullptr) {+      UnrefMaybePutZerocopySendRecord(current_zerocopy_send_);+      current_zerocopy_send_ = nullptr;+    }+    cb_(status);+    Unref();+    return;+  }+  bool flush_result = current_zerocopy_send_ != nullptr+                          ? TcpFlushZerocopy(current_zerocopy_send_, status)+                          : TcpFlush(status);+  if (!flush_result) {+    GPR_DEBUG_ASSERT(status.ok());+    handle_->NotifyOnWrite(on_write_);+  } else {+    absl::AnyInvocable<void(absl::Status)> cb_ = std::move(write_cb_);+    write_cb_ = nullptr;+    current_zerocopy_send_ = nullptr;+    cb_(status);+    Unref();+  }+}++void PosixEndpointImpl::Write(+    absl::AnyInvocable<void(absl::Status)> on_writable, SliceBuffer* data,+    const EventEngine::Endpoint::WriteArgs* args) {+  absl::Status status = absl::OkStatus();+  TcpZerocopySendRecord* zerocopy_send_record = nullptr;++  GPR_ASSERT(write_cb_ == nullptr);+  GPR_DEBUG_ASSERT(current_zerocopy_send_ == nullptr);+  GPR_DEBUG_ASSERT(data != nullptr);++  if (data->Length() == 0) {+    on_writable(handle_->IsHandleShutdown() ? absl::InternalError(""EOF"")+                                            : status);+    TcpShutdownTracedBufferList();+    return;+  }++  zerocopy_send_record = TcpGetSendZerocopyRecord(*data);+  if (zerocopy_send_record == nullptr) {+    // Either not enough bytes, or couldn't allocate a zerocopy context.+    outgoing_buffer_ = data;+    outgoing_byte_idx_ = 0;+  }+  if (args != nullptr) {+    outgoing_buffer_arg_ = args->google_specific;+  }+  if (outgoing_buffer_arg_) {+    GPR_ASSERT(poller_->CanTrackErrors());+  }++  bool flush_result = zerocopy_send_record != nullptr+                          ? TcpFlushZerocopy(zerocopy_send_record, status)+                          : TcpFlush(status);+  if (!flush_result) {+    Ref();+    write_cb_ = std::move(on_writable);+    current_zerocopy_send_ = zerocopy_send_record;+    handle_->NotifyOnWrite(on_write_);+  } else {+    on_writable(status);+  }+}++void PosixEndpointImpl::MaybeShutdown(absl::Status why) {+  if (poller_->CanTrackErrors()) {+    ZerocopyDisableAndWaitForRemaining();+    stop_error_notification_.store(true, std::memory_order_release);+    handle_->SetHasError();+  }+  handle_->ShutdownHandle(why);+  Unref();+}++PosixEndpointImpl ::~PosixEndpointImpl() {+  handle_->OrphanHandle(on_done_, nullptr, """");+  delete on_read_;+  delete on_write_;+  delete on_error_;+}++PosixEndpointImpl::PosixEndpointImpl(EventHandle* handle,+                                     PosixEngineClosure* on_done,+                                     std::shared_ptr<EventEngine> engine,+                                     const PosixTcpOptions& options)+    : sock_(PosixSocketWrapper(handle->WrappedFd())),+      on_done_(on_done),+      traced_buffers_(),+      handle_(handle),+      poller_(handle->Poller()),+      engine_(engine) {+  PosixSocketWrapper sock(handle->WrappedFd());+  fd_ = handle_->WrappedFd();+  GPR_ASSERT(options.resource_quota != nullptr);+  memory_owner_ = options.resource_quota->memory_quota()->CreateMemoryOwner(+      *sock.PeerAddressString());+  self_reservation_ = memory_owner_.MakeReservation(sizeof(PosixEndpointImpl));+  local_address_ = *sock.LocalAddress();+  peer_address_ = *sock.PeerAddress();+  target_length_ = static_cast<double>(options.tcp_read_chunk_size);+  bytes_read_this_round_ = 0;+  min_read_chunk_size_ = options.tcp_min_read_chunk_size;+  max_read_chunk_size_ = options.tcp_max_read_chunk_size;+  tcp_zerocopy_send_ctx_ = absl::make_unique<TcpZerocopySendCtx>(+      options.tcp_tx_zerocopy_max_simultaneous_sends,+      options.tcp_tx_zerocopy_send_bytes_threshold);+  frame_size_tuning_enabled_ = grpc_core::IsTcpFrameSizeTuningEnabled();+  if (options.tcp_tx_zero_copy_enabled &&+      !tcp_zerocopy_send_ctx_->MemoryLimited() && poller_->CanTrackErrors()) {+#ifdef GRPC_LINUX_ERRQUEUE+    const int enable = 1;+    auto err =+        setsockopt(fd_, SOL_SOCKET, SO_ZEROCOPY, &enable, sizeof(enable));+    if (err == 0) {+      tcp_zerocopy_send_ctx_->SetEnabled(true);+    } else {+      gpr_log(GPR_ERROR, ""Failed to set zerocopy options on the socket."");+    }+#endif+  }++#ifdef GRPC_HAVE_TCP_INQ+  int one = 1;+  if (setsockopt(fd_, SOL_TCP, TCP_INQ, &one, sizeof(one)) == 0) {+    inq_capable_ = true;+  } else {+    gpr_log(GPR_DEBUG, ""cannot set inq fd=%d errno=%d"", fd_, errno);+    inq_capable_ = false;+  }+#else+  inq_capable_ = false;+#endif /* GRPC_HAVE_TCP_INQ */++  on_read_ = PosixEngineClosure::ToPermanentClosure(+      [this](absl::Status status) { HandleRead(std::move(status)); });+  on_write_ = PosixEngineClosure::ToPermanentClosure(+      [this](absl::Status status) { HandleWrite(std::move(status)); });+  on_error_ = PosixEngineClosure::ToPermanentClosure(+      [this](absl::Status status) { HandleError(std::move(status)); });++  // Start being notified on errors if poller can track errors.+  if (poller_->CanTrackErrors()) {+    Ref();+    handle_->NotifyOnError(on_error_);+  }+}++std::unique_ptr<PosixEndpoint> CreatePosixEndpoint(+    EventHandle* handle, PosixEngineClosure* on_shutdown,+    std::shared_ptr<EventEngine> engine, const EndpointConfig& config) {+  GPR_ASSERT(handle != nullptr);",Consider making `handle` a reference type parameter. No nullptr check would be required. Is handle ownership being transferred here? I'm not entirely sure what the lifetime of the handle pointer needs to be.,
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/30559,978087860,2022-09-22T21:09:59Z,src/core/lib/event_engine/posix_engine/posix_endpoint.cc,"@@ -0,0 +1,1135 @@+// Copyright 2022 gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+#include <grpc/support/port_platform.h>++#include ""src/core/lib/event_engine/posix_engine/posix_endpoint.h""++#include <memory>++#include ""absl/functional/any_invocable.h""+#include ""absl/status/status.h""+#include ""absl/synchronization/mutex.h""++#include <grpc/event_engine/endpoint_config.h>+#include <grpc/event_engine/slice.h>+#include <grpc/event_engine/slice_buffer.h>+#include <grpc/support/alloc.h>+#include <grpc/support/log.h>++#include ""src/core/lib/event_engine/posix_engine/event_poller.h""+#include ""src/core/lib/event_engine/posix_engine/internal_errqueue.h""+#include ""src/core/lib/event_engine/posix_engine/tcp_socket_utils.h""+#include ""src/core/lib/experiments/experiments.h""+#include ""src/core/lib/gprpp/global_config_generic.h""++#ifdef GRPC_POSIX_SOCKET_TCP+#ifdef GRPC_LINUX_ERRQUEUE+#include <linux/netlink.h>  // IWYU pragma: keep+#endif++#ifndef SOL_TCP+#define SOL_TCP IPPROTO_TCP+#endif++#ifndef TCP_INQ+#define TCP_INQ 36+#define TCP_CM_INQ TCP_INQ+#endif++#ifdef GRPC_HAVE_MSG_NOSIGNAL+#define SENDMSG_FLAGS MSG_NOSIGNAL+#else+#define SENDMSG_FLAGS 0+#endif++// TCP zero copy sendmsg flag.+// NB: We define this here as a fallback in case we're using an older set of+// library headers that has not defined MSG_ZEROCOPY. Since this constant is+// part of the kernel, we are guaranteed it will never change/disagree so+// defining it here is safe.+#ifndef MSG_ZEROCOPY+#define MSG_ZEROCOPY 0x4000000+#endif++#define MAX_READ_IOVEC 64++namespace grpc_event_engine {+namespace posix_engine {++namespace {++using ::grpc_event_engine::experimental::EndpointConfig;+using ::grpc_event_engine::experimental::EventEngine;+using ::grpc_event_engine::experimental::Slice;+using ::grpc_event_engine::experimental::SliceBuffer;++// A wrapper around sendmsg. It sends \a msg over \a fd and returns the number+// of bytes sent.+ssize_t TcpSend(int fd, const struct msghdr* msg, int* saved_errno,+                int additional_flags = 0) {+  ssize_t sent_length;+  do {+    sent_length = sendmsg(fd, msg, SENDMSG_FLAGS | additional_flags);+  } while (sent_length < 0 && (*saved_errno = errno) == EINTR);+  return sent_length;+}++#ifdef GRPC_LINUX_ERRQUEUE+// Whether the cmsg received from error queue is of the IPv4 or IPv6 levels.+bool CmsgIsIpLevel(const cmsghdr& cmsg) {+  return (cmsg.cmsg_level == SOL_IPV6 && cmsg.cmsg_type == IPV6_RECVERR) ||+         (cmsg.cmsg_level == SOL_IP && cmsg.cmsg_type == IP_RECVERR);+}++bool CmsgIsZeroCopy(const cmsghdr& cmsg) {+  if (!CmsgIsIpLevel(cmsg)) {+    return false;+  }+  auto serr = reinterpret_cast<const sock_extended_err*> CMSG_DATA(&cmsg);+  return serr->ee_errno == 0 && serr->ee_origin == SO_EE_ORIGIN_ZEROCOPY;+}+#endif  // GRPC_LINUX_ERRQUEUE++}  // namespace++#if defined(IOV_MAX) && IOV_MAX < 260+#define MAX_WRITE_IOVEC IOV_MAX+#else+#define MAX_WRITE_IOVEC 260+#endif+msg_iovlen_type TcpZerocopySendRecord::PopulateIovs(size_t* unwind_slice_idx,+                                                    size_t* unwind_byte_idx,+                                                    size_t* sending_length,+                                                    iovec* iov) {+  msg_iovlen_type iov_size;+  *unwind_slice_idx = out_offset_.slice_idx;+  *unwind_byte_idx = out_offset_.byte_idx;+  for (iov_size = 0;+       out_offset_.slice_idx != buf_.Count() && iov_size != MAX_WRITE_IOVEC;+       iov_size++) {+    auto slice = buf_.RefSlice(out_offset_.slice_idx);+    iov[iov_size].iov_base =+        const_cast<uint8_t*>(slice.begin()) + out_offset_.byte_idx;+    iov[iov_size].iov_len = slice.length() - out_offset_.byte_idx;+    *sending_length += iov[iov_size].iov_len;+    ++(out_offset_.slice_idx);+    out_offset_.byte_idx = 0;+  }+  GPR_DEBUG_ASSERT(iov_size > 0);+  return iov_size;+}++void TcpZerocopySendRecord::UpdateOffsetForBytesSent(size_t sending_length,+                                                     size_t actually_sent) {+  size_t trailing = sending_length - actually_sent;+  while (trailing > 0) {+    size_t slice_length;+    out_offset_.slice_idx--;+    slice_length = buf_.RefSlice(out_offset_.slice_idx).length();+    if (slice_length > trailing) {+      out_offset_.byte_idx = slice_length - trailing;+      break;+    } else {+      trailing -= slice_length;+    }+  }+}++void PosixEndpointImpl::AddToEstimate(size_t bytes) {+  bytes_read_this_round_ += static_cast<double>(bytes);+}++void PosixEndpointImpl::FinishEstimate() {+  // If we read >80% of the target buffer in one read loop, increase the size of+  // the target buffer to either the amount read, or twice its previous value.+  if (bytes_read_this_round_ > target_length_ * 0.8) {+    target_length_ = std::max(2 * target_length_, bytes_read_this_round_);+  } else {+    target_length_ = 0.99 * target_length_ + 0.01 * bytes_read_this_round_;+  }+  bytes_read_this_round_ = 0;+}++// Returns true if data available to read or error other than EAGAIN.+bool PosixEndpointImpl::TcpDoRead(absl::Status& status) {+  struct msghdr msg;+  struct iovec iov[MAX_READ_IOVEC];+  ssize_t read_bytes;+  size_t total_read_bytes = 0;+  size_t iov_len = std::min<size_t>(MAX_READ_IOVEC, incoming_buffer_->Count());+#ifdef GRPC_LINUX_ERRQUEUE+  constexpr size_t cmsg_alloc_space =+      CMSG_SPACE(sizeof(scm_timestamping)) + CMSG_SPACE(sizeof(int));+#else+  constexpr size_t cmsg_alloc_space = 24 /* CMSG_SPACE(sizeof(int)) */;+#endif /* GRPC_LINUX_ERRQUEUE */+  char cmsgbuf[cmsg_alloc_space];+  for (size_t i = 0; i < iov_len; i++) {+    Slice slice = incoming_buffer_->RefSlice(i);+    iov[i].iov_base = const_cast<uint8_t*>(slice.begin());+    iov[i].iov_len = slice.length();+  }++  GPR_ASSERT(incoming_buffer_->Length() != 0);+  GPR_DEBUG_ASSERT(min_progress_size_ > 0);++  do {+    // Assume there is something on the queue. If we receive TCP_INQ from+    // kernel, we will update this value, otherwise, we have to assume there is+    // always something to read until we get EAGAIN.+    inq_ = 1;++    msg.msg_name = nullptr;+    msg.msg_namelen = 0;+    msg.msg_iov = iov;+    msg.msg_iovlen = static_cast<msg_iovlen_type>(iov_len);+    if (inq_capable_) {+      msg.msg_control = cmsgbuf;+      msg.msg_controllen = sizeof(cmsgbuf);+    } else {+      msg.msg_control = nullptr;+      msg.msg_controllen = 0;+    }+    msg.msg_flags = 0;++    do {+      read_bytes = recvmsg(fd_, &msg, 0);+    } while (read_bytes < 0 && errno == EINTR);++    // We have read something in previous reads. We need to deliver those bytes+    // to the upper layer.+    if (read_bytes <= 0 &&+        total_read_bytes >= static_cast<size_t>(min_progress_size_)) {+      inq_ = 1;+      break;+    }++    if (read_bytes < 0) {+      // NB: After calling call_read_cb a parallel call of the read handler may+      // be running.+      if (errno == EAGAIN) {+        if (total_read_bytes > 0) {+          break;+        }+        FinishEstimate();+        inq_ = 0;+        return false;+      } else {+        incoming_buffer_->Clear();+        status =+            absl::InternalError(absl::StrCat(""recvmsg:"", std::strerror(errno)));+        return true;+      }+    }+    if (read_bytes == 0) {+      // 0 read size ==> end of stream+      //+      // We may have read something, i.e., total_read_bytes > 0, but since the+      // connection is closed we will drop the data here, because we can't call+      // the callback multiple times.+      incoming_buffer_->Clear();+      status = absl::InternalError(""Socket closed"");+      return true;+    }++    AddToEstimate(static_cast<size_t>(read_bytes));+    GPR_DEBUG_ASSERT((size_t)read_bytes <=+                     incoming_buffer_->Length() - total_read_bytes);++#ifdef GRPC_HAVE_TCP_INQ+    if (inq_capable_) {+      GPR_DEBUG_ASSERT(!(msg.msg_flags & MSG_CTRUNC));+      struct cmsghdr* cmsg = CMSG_FIRSTHDR(&msg);+      for (; cmsg != nullptr; cmsg = CMSG_NXTHDR(&msg, cmsg)) {+        if (cmsg->cmsg_level == SOL_TCP && cmsg->cmsg_type == TCP_CM_INQ &&+            cmsg->cmsg_len == CMSG_LEN(sizeof(int))) {+          inq_ = *reinterpret_cast<int*>(CMSG_DATA(cmsg));+          break;+        }+      }+    }+#endif  // GRPC_HAVE_TCP_INQ++    total_read_bytes += read_bytes;+    if (inq_ == 0 || total_read_bytes == incoming_buffer_->Length()) {+      break;+    }++    // We had a partial read, and still have space to read more data. So, adjust+    // IOVs and try to read more.+    size_t remaining = read_bytes;+    size_t j = 0;+    for (size_t i = 0; i < iov_len; i++) {+      if (remaining >= iov[i].iov_len) {+        remaining -= iov[i].iov_len;+        continue;+      }+      if (remaining > 0) {+        iov[j].iov_base = static_cast<char*>(iov[i].iov_base) + remaining;+        iov[j].iov_len = iov[i].iov_len - remaining;+        remaining = 0;+      } else {+        iov[j].iov_base = iov[i].iov_base;+        iov[j].iov_len = iov[i].iov_len;+      }+      ++j;+    }+    iov_len = j;+  } while (true);++  if (inq_ == 0) {+    FinishEstimate();+  }++  GPR_DEBUG_ASSERT(total_read_bytes > 0);+  status = absl::OkStatus();+  if (frame_size_tuning_enabled_) {+    // Update min progress size based on the total number of bytes read in+    // this round.+    min_progress_size_ -= total_read_bytes;+    if (min_progress_size_ > 0) {+      // There is still some bytes left to be read before we can signal+      // the read as complete. Append the bytes read so far into+      // last_read_buffer which serves as a staging buffer. Return false+      // to indicate tcp_handle_read needs to be scheduled again.+      incoming_buffer_->MoveFirstNBytesIntoSliceBuffer(total_read_bytes,+                                                       last_read_buffer_);+      return false;+    } else {+      // The required number of bytes have been read. Append the bytes+      // read in this round into last_read_buffer. Then swap last_read_buffer+      // and incoming_buffer. Now incoming buffer contains all the bytes+      // read since the start of the last tcp_read operation. last_read_buffer+      // would contain any spare space left in the incoming buffer. This+      // space will be used in the next tcp_read operation.+      min_progress_size_ = 1;+      incoming_buffer_->MoveFirstNBytesIntoSliceBuffer(total_read_bytes,+                                                       last_read_buffer_);+      incoming_buffer_->Swap(last_read_buffer_);+      return true;+    }+  }+  if (total_read_bytes < incoming_buffer_->Length()) {+    incoming_buffer_->RemoveLastNBytesIntoSliceBuffer(+        incoming_buffer_->Length() - total_read_bytes, last_read_buffer_);+    // last_read_buffer_.Clear();+  }+  return true;+}++void PosixEndpointImpl::PerformReclamation() {+  read_mu_.Lock();+  if (incoming_buffer_ != nullptr) {+    incoming_buffer_->Clear();+  }+  has_posted_reclaimer_ = false;+  read_mu_.Unlock();+}++void PosixEndpointImpl::MaybePostReclaimer() {+  if (!has_posted_reclaimer_) {+    has_posted_reclaimer_ = true;+    memory_owner_.PostReclaimer(+        grpc_core::ReclamationPass::kBenign,+        [this](absl::optional<grpc_core::ReclamationSweep> sweep) {+          if (!sweep.has_value()) return;+          PerformReclamation();+        });+  }+}++void PosixEndpointImpl::UpdateRcvLowat() {+  if (!grpc_core::IsTcpRcvLowatEnabled()) return;++  // TODO(ctiller): Check if supported by OS.+  // TODO(ctiller): Allow some adjustments instead of hardcoding things.++  static constexpr int kRcvLowatMax = 16 * 1024 * 1024;+  static constexpr int kRcvLowatThreshold = 16 * 1024;++  int remaining = std::min(static_cast<int>(incoming_buffer_->Length()),+                           min_progress_size_);+  remaining = std::min(remaining, kRcvLowatMax);","I believe we can use the initializer list overload here: `std::min({1,2,3,4})`",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/30953,978100767,2022-09-22T21:30:22Z,src/core/lib/slice/slice.h,"@@ -249,7 +248,11 @@ class MutableSlice : public slice_detail::BaseSlice,       : slice_detail::BaseSlice(slice) {     GPR_DEBUG_ASSERT(slice.refcount == nullptr || slice.refcount->IsUnique());   }-  ~MutableSlice() { grpc_slice_unref_internal(c_slice()); }+  ~MutableSlice() {+    if (reinterpret_cast<uintptr_t>(c_slice().refcount) > 1) {","Any reason the code in this file duplicates the code from `grpc_slice_ref()` and `grpc_slice_unref()` instead of just calling those functions?  Is this for performance reasons, and if so, do we have any benchmarks proving that this optimization is worth the duplication?",X
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/30559,978111356,2022-09-22T21:41:04Z,test/core/event_engine/test_suite/event_engine_test_utils.cc,"@@ -44,6 +45,45 @@ using Listener = ::grpc_event_engine::experimental::EventEngine::Listener; namespace grpc_event_engine { namespace experimental { +namespace {++constexpr int kMinMessageSize = 1024;+constexpr int kMaxMessageSize = 4096;++}  // namespace++// Returns a random message with bounded length.+std::string GetNextSendMessage() {+  static const char alphanum[] =+      ""0123456789""+      ""ABCDEFGHIJKLMNOPQRSTUVWXYZ""+      ""abcdefghijklmnopqrstuvwxyz"";+  static std::random_device rd;+  static std::seed_seq seed{rd()};+  static std::mt19937 gen(seed);+  static std::uniform_real_distribution<> dis(kMinMessageSize, kMaxMessageSize);+  static grpc_core::Mutex g_mu;+  std::string tmp_s;+  int len;+  {+    grpc_core::MutexLock lock(&g_mu);+    len = dis(gen);+  }+  tmp_s.reserve(len);+  for (int i = 0; i < len; ++i) {+    tmp_s += alphanum[rand() % (sizeof(alphanum) - 1)];+  }+  return tmp_s;+}++// Waits until the use_count of the event engine shared_ptr has reached 1+// and returns.+void WaitForPendingTasks(std::shared_ptr<EventEngine>&& engine) {","This presumes that all tasks own a shared_ptr to this EventEngine, which even in this PR is not the case. I'd suggest a rename to `WaitForSingleOwner` or some such, with the caveat that some callbacks _may still be running_ when this reaches its condition.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/30994,978766003,2022-09-23T14:56:04Z,src/core/lib/promise/pipe.h,"@@ -30,9 +33,47 @@  namespace grpc_core { +namespace pipe_detail {+template <typename T>+class Center;+}+ template <typename T> struct Pipe; +template <typename T>+class NextResult final {",Please document what this class represents and how it is used.,
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/30688,978795813,2022-09-23T15:19:22Z,src/core/lib/resolver/address_parser_registry.h,"@@ -49,32 +43,29 @@ class AddressParserRegistry {     AddressParserRegistry Build();     private:-    std::vector<Parser> parsers_;+    std::map<absl::string_view, AddressParser> parsers_;   };    AddressParserRegistry(AddressParserRegistry&&) = default;   AddressParserRegistry& operator=(AddressParserRegistry&&) = default;    // Parse URI using an appropriate parser, return a list of resolved addresses.","""a list of resolved addresses"" -> ""a resolved address""",
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/30559,978820796,2022-09-23T15:46:28Z,src/core/lib/event_engine/posix_engine/posix_endpoint.h,"@@ -0,0 +1,637 @@+// Copyright 2022 gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++#ifndef GRPC_CORE_LIB_EVENT_ENGINE_POSIX_ENGINE_POSIX_ENDPOINT_H+#define GRPC_CORE_LIB_EVENT_ENGINE_POSIX_ENGINE_POSIX_ENDPOINT_H++#include <grpc/support/port_platform.h>++#include <atomic>+#include <memory>+#include <unordered_map>++#include <grpc/event_engine/endpoint_config.h>+#include <grpc/event_engine/event_engine.h>+#include <grpc/event_engine/slice_buffer.h>+#include <grpc/support/alloc.h>+#include <grpc/support/log.h>++#include ""src/core/lib/event_engine/posix_engine/event_poller.h""+#include ""src/core/lib/event_engine/posix_engine/posix_engine_closure.h""+#include ""src/core/lib/event_engine/posix_engine/tcp_socket_utils.h""+#include ""src/core/lib/event_engine/posix_engine/traced_buffer_list.h""+#include ""src/core/lib/iomgr/port.h""++namespace grpc_event_engine {+namespace posix_engine {++#ifdef GRPC_POSIX_SOCKET_TCP++#ifdef GRPC_MSG_IOVLEN_TYPE+typedef GRPC_MSG_IOVLEN_TYPE msg_iovlen_type;+#else+typedef size_t msg_iovlen_type;+#endif++class TcpZerocopySendRecord {+ public:+  TcpZerocopySendRecord() { buf_.Clear(); };++  ~TcpZerocopySendRecord() { AssertEmpty(); }++  // Given the slices that we wish to send, and the current offset into the+  //   slice buffer (indicating which have already been sent), populate an iovec+  //   array that will be used for a zerocopy enabled sendmsg().+  msg_iovlen_type PopulateIovs(size_t* unwind_slice_idx,+                               size_t* unwind_byte_idx, size_t* sending_length,+                               iovec* iov);++  // A sendmsg() may not be able to send the bytes that we requested at this+  // time, returning EAGAIN (possibly due to backpressure). In this case,+  // unwind the offset into the slice buffer so we retry sending these bytes.+  void UnwindIfThrottled(size_t unwind_slice_idx, size_t unwind_byte_idx) {+    out_offset_.byte_idx = unwind_byte_idx;+    out_offset_.slice_idx = unwind_slice_idx;+  }++  // Update the offset into the slice buffer based on how much we wanted to sent+  // vs. what sendmsg() actually sent (which may be lower, possibly due to+  // backpressure).+  void UpdateOffsetForBytesSent(size_t sending_length, size_t actually_sent);++  // Indicates whether all underlying data has been sent or not.+  bool AllSlicesSent() { return out_offset_.slice_idx == buf_.Count(); }++  // Reset this structure for a new tcp_write() with zerocopy.+  void PrepareForSends(+      grpc_event_engine::experimental::SliceBuffer& slices_to_send) {+    AssertEmpty();+    out_offset_.slice_idx = 0;+    out_offset_.byte_idx = 0;+    buf_.Swap(slices_to_send);+    Ref();+  }++  // References: 1 reference per sendmsg(), and 1 for the tcp_write().+  void Ref() { ref_.fetch_add(1, std::memory_order_relaxed); }++  // Unref: called when we get an error queue notification for a sendmsg(), if a+  //  sendmsg() failed or when tcp_write() is done.+  bool Unref() {+    const intptr_t prior = ref_.fetch_sub(1, std::memory_order_acq_rel);+    GPR_DEBUG_ASSERT(prior > 0);+    if (prior == 1) {+      AllSendsComplete();+      return true;+    }+    return false;+  }++ private:+  struct OutgoingOffset {+    size_t slice_idx = 0;+    size_t byte_idx = 0;+  };++  void AssertEmpty() {+    GPR_DEBUG_ASSERT(buf_.Count() == 0);+    GPR_DEBUG_ASSERT(buf_.Length() == 0);+    GPR_DEBUG_ASSERT(ref_.load(std::memory_order_relaxed) == 0);+  }++  // When all sendmsg() calls associated with this tcp_write() have been+  // completed (ie. we have received the notifications for each sequence number+  // for each sendmsg()) and all reference counts have been dropped, drop our+  // reference to the underlying data since we no longer need it.+  void AllSendsComplete() {+    GPR_DEBUG_ASSERT(ref_.load(std::memory_order_relaxed) == 0);+    buf_.Clear();+  }++  grpc_event_engine::experimental::SliceBuffer buf_;+  std::atomic<intptr_t> ref_{0};+  OutgoingOffset out_offset_;+};++class TcpZerocopySendCtx {+ public:+  static constexpr int kDefaultMaxSends = 4;+  static constexpr size_t kDefaultSendBytesThreshold = 16 * 1024;  // 16KB++  explicit TcpZerocopySendCtx(+      int max_sends = kDefaultMaxSends,+      size_t send_bytes_threshold = kDefaultSendBytesThreshold)+      : max_sends_(max_sends),+        free_send_records_size_(max_sends),+        threshold_bytes_(send_bytes_threshold) {+    send_records_ = static_cast<TcpZerocopySendRecord*>(+        gpr_malloc(max_sends * sizeof(*send_records_)));+    free_send_records_ = static_cast<TcpZerocopySendRecord**>(+        gpr_malloc(max_sends * sizeof(*free_send_records_)));+    if (send_records_ == nullptr || free_send_records_ == nullptr) {+      gpr_free(send_records_);+      gpr_free(free_send_records_);+      gpr_log(GPR_INFO, ""Disabling TCP TX zerocopy due to memory pressure.\n"");+      memory_limited_ = true;+    } else {+      for (int idx = 0; idx < max_sends_; ++idx) {+        new (send_records_ + idx) TcpZerocopySendRecord();+        free_send_records_[idx] = send_records_ + idx;+      }+    }+  }++  ~TcpZerocopySendCtx() {+    if (send_records_ != nullptr) {+      for (int idx = 0; idx < max_sends_; ++idx) {+        send_records_[idx].~TcpZerocopySendRecord();+      }+    }+    gpr_free(send_records_);+    gpr_free(free_send_records_);+  }++  // True if we were unable to allocate the various bookkeeping structures at+  // transport initialization time. If memory limited, we do not zerocopy.+  bool MemoryLimited() const { return memory_limited_; }++  // TCP send zerocopy maintains an implicit sequence number for every+  // successful sendmsg() with zerocopy enabled; the kernel later gives us an+  // error queue notification with this sequence number indicating that the+  // underlying data buffers that we sent can now be released. Once that+  // notification is received, we can release the buffers associated with this+  // zerocopy send record. Here, we associate the sequence number with the data+  // buffers that were sent with the corresponding call to sendmsg().+  void NoteSend(TcpZerocopySendRecord* record) {+    record->Ref();+    {+      absl::MutexLock guard(&lock_);+      is_in_write_ = true;+      AssociateSeqWithSendRecordLocked(last_send_, record);+    }+    ++last_send_;+  }++  // If sendmsg() actually failed, though, we need to revert the sequence number+  // that we speculatively bumped before calling sendmsg(). Note that we bump+  // this sequence number and perform relevant bookkeeping (see: NoteSend())+  // *before* calling sendmsg() since, if we called it *after* sendmsg(), then+  // there is a possible race with the release notification which could occur on+  // another thread before we do the necessary bookkeeping. Hence, calling+  // NoteSend() *before* sendmsg() and implementing an undo function is needed.+  void UndoSend() {+    --last_send_;+    if (ReleaseSendRecord(last_send_)->Unref()) {+      // We should still be holding the ref taken by tcp_write().+      GPR_DEBUG_ASSERT(0);+    }+  }++  // Simply associate this send record (and the underlying sent data buffers)+  // with the implicit sequence number for this zerocopy sendmsg().+  void AssociateSeqWithSendRecordLocked(uint32_t seq,+                                        TcpZerocopySendRecord* record) {+    ctx_lookup_.emplace(seq, record);+  }++  // Get a send record for a send that we wish to do with zerocopy.+  TcpZerocopySendRecord* GetSendRecord() {+    absl::MutexLock guard(&lock_);+    return TryGetSendRecordLocked();+  }++  // A given send record corresponds to a single tcp_write() with zerocopy+  // enabled. This can result in several sendmsg() calls to flush all of the+  // data to wire. Each sendmsg() takes a reference on the+  // TcpZerocopySendRecord, and corresponds to a single sequence number.+  // ReleaseSendRecord releases a reference on TcpZerocopySendRecord for a+  // single sequence number. This is called either when we receive the relevant+  // error queue notification (saying that we can discard the underlying+  // buffers for this sendmsg()) is received from the kernel - or, in case+  // sendmsg() was unsuccessful to begin with.+  TcpZerocopySendRecord* ReleaseSendRecord(uint32_t seq) {+    absl::MutexLock guard(&lock_);+    return ReleaseSendRecordLocked(seq);+  }++  // After all the references to a TcpZerocopySendRecord are released, we can+  // add it back to the pool (of size max_sends_). Note that we can only have+  // max_sends_ tcp_write() instances with zerocopy enabled in flight at the+  // same time.+  void PutSendRecord(TcpZerocopySendRecord* record) {+    GPR_DEBUG_ASSERT(record >= send_records_ &&+                     record < send_records_ + max_sends_);+    absl::MutexLock guard(&lock_);+    PutSendRecordLocked(record);+  }++  // Indicate that we are disposing of this zerocopy context. This indicator+  // will prevent new zerocopy writes from being issued.+  void Shutdown() { shutdown_.store(true, std::memory_order_release); }++  // Indicates that there are no inflight tcp_write() instances with zerocopy+  // enabled.+  bool AllSendRecordsEmpty() {+    absl::MutexLock guard(&lock_);+    return free_send_records_size_ == max_sends_;+  }++  bool Enabled() const { return enabled_; }++  void SetEnabled(bool enabled) {+    GPR_DEBUG_ASSERT(!enabled || !MemoryLimited());+    enabled_ = enabled;","I see, that's fine then. You could improve the type's encapsulation by making this field's initialization part of the `TcpZerocopySendCtx` constructor (along with the setsockopt logic that controls it). Just a suggestion.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/30688,978870954,2022-09-23T16:47:00Z,src/core/lib/resolver/resolver_factory.h,"@@ -54,9 +54,8 @@ class ResolverFactory {  public:   virtual ~ResolverFactory() {} -  /// Returns the URI scheme that this factory implements.-  /// Caller does NOT take ownership of result.-  virtual absl::string_view scheme() const = 0;+  /// Returns true if the factory implements \a scheme, false otherwise.+  virtual bool ImplementsScheme(absl::string_view scheme) const = 0;","I assume you mean just for the sockaddr resolver, which needs to know which address resolvers are registered in order to know which schemes it should register itself under.  I think you're right that we don't want to tie together the registration of name resolvers and address resolvers.How about this: Instead of trying to have the sockaddr resolver register itself under names that correspond to the address resolver names, we could just special-case the sockaddr resolver in the `ClientChannel` code.  The `ClientChannel` code can check to see if the name resolver scheme is supported, and if not, it can fall back to using the sockaddr resolver.  The sockaddr resolver would not register itself in the name resolver registry at all.I think this approach would have the added benefit that it would define a clear precedence between the two namespaces: if there is a scheme registered as both a name resolver and an address resolver, the client channel code will always prefer the name resolver.Another alternative (which I don't like as much as the option above) would be to have the sockaddr resolver factory always register itself under the same fixed list of known address schemes that it uses today, regardless of whether the underlying address resolver type is registered, and then have its `IsValidUri()` method return false if the address type turns out to be unsupported.  Note that from the perspective of [the `ClientChannel` code](https://github.com/grpc/grpc/blob/f15ba1ffc73c5d0b63754df72fc47c567b9c7252/src/core/ext/filters/client_channel/client_channel.cc#L1032), this would look exactly the same as if the name resolver scheme was not registered, since [`ResolverRegistry::IsValidTarget()`](https://github.com/grpc/grpc/blob/f15ba1ffc73c5d0b63754df72fc47c567b9c7252/src/core/lib/resolver/resolver_registry.cc#L64) returns false in either case.  The down-side here is that we wouldn't automatically get support for new address types in `ClientChannel` without explicitly adding the schemes to the sockaddr resolver factory, which I suspect is not what we want here.Ultimately, I'm just really uncomfortable with allowing multiple name resolvers to be registered for the same scheme, because I think that would lead to bugs and confusion.  This actually came up in an internal discussion just recently in the context of the migration of our internal resolver, where I had to tell someone not to try registering two resolvers under the same name as a migration strategy, so it's not just a theoretical concern.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/31093,978914023,2022-09-23T17:34:42Z,src/cpp/ext/filters/census/client_filter.cc,"@@ -222,15 +238,26 @@ void OpenCensusCallTracer::OpenCensusCallAttemptTracer::RecordEnd(   } } +CensusContext OpenCensusCallTracer::OpenCensusCallAttemptTracer::+    CreateCensusContextForCallAttempt(OpenCensusCallTracer* call_tracer) {","Why make this a method on `OpenCensusCallAttemptTracer` when it's actually only accessing data on `OpenCensusCallTracer`?  Seems like it could just be a method on `OpenCensusCallTracer`, and the `OpenCensusCallAttemptTracer` could just change `CreateCensusContextForCallAttempt(parent_)` to `parent_->CreateCensusContextForCallAttempt()`.",X
5564114,Vignesh2208,https://api.github.com/repos/grpc/grpc/pulls/30559,978950733,2022-09-23T18:10:39Z,src/core/lib/event_engine/posix_engine/posix_endpoint.h,"@@ -0,0 +1,637 @@+// Copyright 2022 gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++#ifndef GRPC_CORE_LIB_EVENT_ENGINE_POSIX_ENGINE_POSIX_ENDPOINT_H+#define GRPC_CORE_LIB_EVENT_ENGINE_POSIX_ENGINE_POSIX_ENDPOINT_H++#include <grpc/support/port_platform.h>++#include <atomic>+#include <memory>+#include <unordered_map>++#include <grpc/event_engine/endpoint_config.h>+#include <grpc/event_engine/event_engine.h>+#include <grpc/event_engine/slice_buffer.h>+#include <grpc/support/alloc.h>+#include <grpc/support/log.h>++#include ""src/core/lib/event_engine/posix_engine/event_poller.h""+#include ""src/core/lib/event_engine/posix_engine/posix_engine_closure.h""+#include ""src/core/lib/event_engine/posix_engine/tcp_socket_utils.h""+#include ""src/core/lib/event_engine/posix_engine/traced_buffer_list.h""+#include ""src/core/lib/iomgr/port.h""++namespace grpc_event_engine {+namespace posix_engine {++#ifdef GRPC_POSIX_SOCKET_TCP++#ifdef GRPC_MSG_IOVLEN_TYPE+typedef GRPC_MSG_IOVLEN_TYPE msg_iovlen_type;+#else+typedef size_t msg_iovlen_type;+#endif++class TcpZerocopySendRecord {+ public:+  TcpZerocopySendRecord() { buf_.Clear(); };++  ~TcpZerocopySendRecord() { AssertEmpty(); }++  // Given the slices that we wish to send, and the current offset into the+  //   slice buffer (indicating which have already been sent), populate an iovec+  //   array that will be used for a zerocopy enabled sendmsg().+  msg_iovlen_type PopulateIovs(size_t* unwind_slice_idx,+                               size_t* unwind_byte_idx, size_t* sending_length,+                               iovec* iov);++  // A sendmsg() may not be able to send the bytes that we requested at this+  // time, returning EAGAIN (possibly due to backpressure). In this case,+  // unwind the offset into the slice buffer so we retry sending these bytes.+  void UnwindIfThrottled(size_t unwind_slice_idx, size_t unwind_byte_idx) {+    out_offset_.byte_idx = unwind_byte_idx;+    out_offset_.slice_idx = unwind_slice_idx;+  }++  // Update the offset into the slice buffer based on how much we wanted to sent+  // vs. what sendmsg() actually sent (which may be lower, possibly due to+  // backpressure).+  void UpdateOffsetForBytesSent(size_t sending_length, size_t actually_sent);++  // Indicates whether all underlying data has been sent or not.+  bool AllSlicesSent() { return out_offset_.slice_idx == buf_.Count(); }++  // Reset this structure for a new tcp_write() with zerocopy.+  void PrepareForSends(+      grpc_event_engine::experimental::SliceBuffer& slices_to_send) {+    AssertEmpty();+    out_offset_.slice_idx = 0;+    out_offset_.byte_idx = 0;+    buf_.Swap(slices_to_send);+    Ref();+  }++  // References: 1 reference per sendmsg(), and 1 for the tcp_write().+  void Ref() { ref_.fetch_add(1, std::memory_order_relaxed); }","Actually for this particular object, we cant use the RefCounted types because the Unref operation doesn't delete the object. Rather it adds the object to a free_list maintained by TcpSendZeroCopyCtx object: https://github.com/grpc/grpc/pull/30559/files#diff-480c81a437473d5161dac9218be290d75ce42b686c1405a88e756c9fa8084a0aR756",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/30953,979154280,2022-09-24T04:39:19Z,src/core/lib/slice/slice.h,"@@ -249,7 +248,11 @@ class MutableSlice : public slice_detail::BaseSlice,       : slice_detail::BaseSlice(slice) {     GPR_DEBUG_ASSERT(slice.refcount == nullptr || slice.refcount->IsUnique());   }-  ~MutableSlice() { grpc_slice_unref_internal(c_slice()); }+  ~MutableSlice() {+    if (reinterpret_cast<uintptr_t>(c_slice().refcount) > 1) {",Mostly the copying in of the slice to the ref/unref functions contribute a fairly high number of instructions versus what happens in the ref/unref.If `grpc_slice_ref` took a `grpc_slice*` we'd have a different story... but that's in the realms of a rather large change.,
963826,stanhu,https://api.github.com/repos/grpc/grpc/pulls/31119,980342139,2022-09-26T17:52:49Z,src/core/ext/filters/client_channel/http_proxy.cc,"@@ -53,6 +55,33 @@ namespace grpc_core { namespace { +static bool serverInCIDRRange(std::string server_host, absl::string_view no_proxy_entry) {+  auto server_address = StringToSockaddr(server_host, 0);+  if (!server_address.ok()) {+    return false;+  }++  std::vector<absl::string_view> cidr = absl::StrSplit(no_proxy_entry, '/', absl::SkipEmpty());+  if (cidr.size() == 0 || cidr.size() > 2) {+    return false;+  }++  auto proxy_address = StringToSockaddr(cidr[0], 0);","We may want to parse port numbers for exact IP matches, but this should be done outside of the CIDR comparison. Golang does this: https://github.com/golang/go/blob/f771edd7f92a47c276d65fbd9619e16a786c6746/src/vendor/golang.org/x/net/http/httpproxy/proxy.go#L38-L50",
4181124,yashykt,https://api.github.com/repos/grpc/grpc/pulls/31093,980532172,2022-09-26T21:48:36Z,test/cpp/ext/filters/census/stats_plugin_end2end_test.cc,"@@ -730,6 +731,55 @@ TEST_F(StatsPluginEnd2EndTest, TestAllSpansAreExported) {             recv_span_data->parent_span_id()); } +// Test the working of GRPC_ARG_DISABLE_OBSERVABILITY.+TEST_F(StatsPluginEnd2EndTest, TestObservabilityDisabledChannelArg) {+  {+    // Client spans are ended when the ClientContext's destructor is invoked.+    ChannelArguments args;+    args.SetInt(GRPC_ARG_ENABLE_OBSERVABILITY, 0);+    auto channel = CreateCustomChannel(server_address_,+                                       InsecureChannelCredentials(), args);+    ResetStub(channel);+    EchoRequest request;+    request.set_message(""foo"");+    EchoResponse response;++    grpc::ClientContext context;+    ::opencensus::trace::AlwaysSampler always_sampler;+    ::opencensus::trace::StartSpanOptions options;+    options.sampler = &always_sampler;+    auto sampling_span =+        ::opencensus::trace::Span::StartSpan(""sampling"", nullptr, options);+    grpc::CensusContext app_census_context(""root"", &sampling_span,+                                           ::opencensus::tags::TagMap{});+    context.set_census_context(+        reinterpret_cast<census_context*>(&app_census_context));+    traces_recorder_->StartRecording();+    grpc::Status status = stub_->Echo(&context, request, &response);+    EXPECT_TRUE(status.ok());+  }+  absl::SleepFor(absl::Milliseconds(500 * grpc_test_slowdown_factor()));","We've been using this 500ms sleep in this test for quite some time and I don't think this test has come up as flaky. That being said, I do want to remove the sleep from these tests. One way to do this would be to simply loop with a deadline till we get what we want, but if I'm doing this I'd like to do it for all the tests, and I would prefer not doing it in this PR",
933495,dennycd,https://api.github.com/repos/grpc/grpc/pulls/30439,981674034,2022-09-27T20:18:45Z,src/objective-c/BUILD,"@@ -239,6 +239,18 @@ grpc_objc_library(     ], ) +grpc_objc_library(+    name = ""grpc_objc_client_core_cronet_testing"",+    srcs = glob([""GRPCClient/private/GRPCCore/GRPCCoreCronet/*.m""]),","sg, let's do that in a follow up PR . The equivalent Pod test target is https://github.com/grpc/grpc/blob/ac585b8f7e78ea9d698bcc6c0019a336332b57e7/src/objective-c/tests/Podfile#L44 ",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/30952,981929848,2022-09-28T04:26:38Z,BUILD,"@@ -2915,17 +2915,22 @@ grpc_cc_library(         ""src/core/lib/event_engine/slice_buffer.cc"",     ],     hdrs = [+        ""include/grpc/event_engine/slice.h"",+        ""include/grpc/event_engine/slice_buffer.h"",","hdrs specifies that this target exports these headers (and in this case provides an implementation) - event_engine_base_hdrs (and the equivalent only-headers targets) largely should be removed, I just haven't got there yet.",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/30952,981930254,2022-09-28T04:27:33Z,test/core/avl/avl_test.cc,"@@ -14,7 +14,7 @@  #include ""src/core/lib/avl/avl.h"" -#include <gtest/gtest.h>+#include ""gtest/gtest.h""","the tooling wants to use """", they're semantically equivalent here, and we used to arbitrarily use <> for gtest - since there's no real reason to fight the tool let's use """"",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/30952,982638535,2022-09-28T16:47:27Z,BUILD,"@@ -2915,17 +2915,22 @@ grpc_cc_library(         ""src/core/lib/event_engine/slice_buffer.cc"",     ],     hdrs = [+        ""include/grpc/event_engine/slice.h"",+        ""include/grpc/event_engine/slice_buffer.h"",","Right... we should at some point in the future figure out why magic is required and make it not required.In the meantime - the implementation of Slice, SliceBuffer that's advertised from these includes is supplied by this library, so this library should export those headers.",
11522026,ralphchung,https://api.github.com/repos/grpc/grpc/pulls/30952,982696175,2022-09-28T17:42:51Z,BUILD,"@@ -2915,17 +2915,22 @@ grpc_cc_library(         ""src/core/lib/event_engine/slice_buffer.cc"",     ],     hdrs = [+        ""include/grpc/event_engine/slice.h"",+        ""include/grpc/event_engine/slice_buffer.h"",",">Right... we should at some point in the future figure out why magic is required and make it not required.It would be a huge refactoring I imagine.> In the meantime - the implementation of Slice, SliceBuffer that's advertised from these includes is supplied by this library, so this library should export those headers.It sounds reasonable, but I am not sure if this style is consistent with other targets and even not sure if this is important.",X
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/30952,982927488,2022-09-28T23:01:42Z,BUILD,"@@ -2915,17 +2915,22 @@ grpc_cc_library(         ""src/core/lib/event_engine/slice_buffer.cc"",     ],     hdrs = [+        ""include/grpc/event_engine/slice.h"",+        ""include/grpc/event_engine/slice_buffer.h"",","It's important - for the dependency analysis to work we need to be able to tie the headers and the implementations into bazel targets. The public headers without the backing implementation pattern we have is an anti-pattern and it eventually needs to go - the only ""header only"" targets we should have are the ones which have no backing cc files. Our destination state should be: if the build system allows me to include a header file I should be able to call all functions declared within that file. That is not true now, and sometimes in surprising ways.In the meantime, the following targets adopt this (correct) pattern: `grpc++_binder`, `grpc++_xds_server`, `grpc++_error_details`, `grpc++_alts`, `census`, `gpr_atm`, `gpr_platform`, `event_engine_memory_allocator`, `slice_refcount`, `slice`, `slice_buffer`, `grpcpp_server_load_reporting`, `grpc++_authorization_provider`, `grpc++_reflection`, `grpcpp_call_metric_recorder`, `grpcpp_orca_service`, `grpcpp_channelz`, `grpcpp_admin`, `grpc++_test`, `grpc_opencensus_plugin`.",
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/30622,983766428,2022-09-29T16:32:27Z,src/core/lib/promise/sleep.cc,"@@ -54,12 +54,9 @@ Poll<absl::Status> Sleep::operator()() { }  Sleep::ActiveClosure::ActiveClosure(Timestamp deadline)-    : waker_(Activity::current()->MakeOwningWaker()) {-  auto engine = GetContext<EventEngine>();-  GPR_ASSERT(engine != nullptr &&","I know the code looks nicer without the check, but the anonymous crash is harder to debug. IIRC, it is very easy to forget to add a Context in the right place, and challenging to figure out where that context needed to be after a crash due to a missing context. Maybe that's changed, but if you're removing this check and the helpful error output along with it, it might be worth deleting an engine context in a few places and seeing what the errors look like, if they'll be easier or harder to debug (for anyone on the team).",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/30971,983874114,2022-09-29T18:04:57Z,src/core/lib/transport/handshaker_factory.h,"@@ -35,11 +35,37 @@ namespace grpc_core {  class HandshakeManager; +// Enum representing the priority of the handshakers.+// The order of the handshakers is decided by the priority.+// For example kPreTCPConnect handshakers are called before kTCPConnect and so+// on.+enum class HandshakerPriority : int {",Suggest moving this inside of the `HandshakerFactory` class.,X
5564114,Vignesh2208,https://api.github.com/repos/grpc/grpc/pulls/31150,983891614,2022-09-29T18:23:32Z,src/core/lib/event_engine/posix_engine/posix_endpoint.cc,"@@ -122,39 +123,55 @@ ssize_t TcpSend(int fd, const struct msghdr* msg, int* saved_errno,  #define CAP_IS_SUPPORTED(cap) (prctl(PR_CAPBSET_READ, (cap), 0) > 0) +uint64_t ParseUlimitMemLockFromFile(std::string file_name) {+  std::ifstream limits_file(file_name);","Done. I created two separate files src/core/lib/gprpp/load_file{.h,.cc} to handle loading data from files. It returns a grpc_core::Slice type.",X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/29598,983995967,2022-09-29T20:28:37Z,src/core/lib/surface/call_trace.cc,"@@ -0,0 +1,114 @@+// Copyright 2022 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++#include <grpc/support/port_platform.h>++#include ""src/core/lib/surface/call_trace.h""++#include <functional>+#include <memory>+#include <string>+#include <utility>++#include ""absl/container/flat_hash_map.h""+#include ""absl/memory/memory.h""+#include ""absl/meta/type_traits.h""+#include ""absl/status/status.h""+#include ""absl/types/variant.h""++#include <grpc/support/log.h>++#include ""src/core/lib/channel/channel_stack.h""+#include ""src/core/lib/gprpp/no_destruct.h""+#include ""src/core/lib/gprpp/sync.h""+#include ""src/core/lib/iomgr/closure.h""+#include ""src/core/lib/promise/activity.h""+#include ""src/core/lib/promise/arena_promise.h""+#include ""src/core/lib/transport/call_fragments.h""+#include ""src/core/lib/transport/metadata_batch.h""+#include ""src/core/lib/transport/transport.h""++namespace grpc_core {++const grpc_channel_filter* PromiseTracingFilterFor(+    const grpc_channel_filter* filter) {+  struct DerivedFilter : public grpc_channel_filter {+    explicit DerivedFilter(const grpc_channel_filter* filter)+        : grpc_channel_filter{+              /* start_transport_stream_op_batch: */ grpc_call_next_op,+              /* make_call_promise: */+              [](grpc_channel_element* elem, CallArgs call_args,+                 NextPromiseFactory next_promise_factory)+                  -> ArenaPromise<ServerMetadataHandle> {+                auto* source_filter =+                    static_cast<const DerivedFilter*>(elem->filter)->filter;+                gpr_log(+                    GPR_DEBUG,+                    ""%sCreateCallPromise[%s]: client_initial_metadata=%s"",+                    Activity::current()->DebugTag().c_str(),+                    source_filter->name,+                    call_args.client_initial_metadata->DebugString().c_str());+                return [source_filter, child = next_promise_factory(+                                           std::move(call_args))]() mutable {+                  gpr_log(GPR_DEBUG, ""%sPollCallPromise[%s]: begin"",+                          Activity::current()->DebugTag().c_str(),+                          source_filter->name);+                  auto r = child();+                  if (auto* p = absl::get_if<ServerMetadataHandle>(&r)) {+                    gpr_log(GPR_DEBUG, ""%sPollCallPromise[%s]: done: %s"",+                            Activity::current()->DebugTag().c_str(),+                            source_filter->name, (*p)->DebugString().c_str());+                  } else {+                    gpr_log(GPR_DEBUG, ""%sPollCallPromise[%s]: <<pending>"",+                            Activity::current()->DebugTag().c_str(),+                            source_filter->name);+                  }+                  return r;+                };+              },+              grpc_channel_next_op, /* sizeof_call_data: */ 0,+              /* init_call_elem: */+              [](grpc_call_element*, const grpc_call_element_args*) {+                return absl::OkStatus();+              },+              grpc_call_stack_ignore_set_pollset_or_pollset_set,+              /* destroy_call_elem: */+              [](grpc_call_element*, const grpc_call_final_info*,+                 grpc_closure*) {},+              /* sizeof_channel_data: */ 0, /* init_channel_elem: */+              [](grpc_channel_element*, grpc_channel_element_args*) {+                return absl::OkStatus();+              },+              /* post_init_channel_elem: */+              [](grpc_channel_stack*, grpc_channel_element*) {},+              /* destroy_channel_elem: */ [](grpc_channel_element*) {},+              grpc_channel_next_get_info, filter->name},+          filter(filter) {}+    const grpc_channel_filter* const filter;+  };+  struct Globals {+    Mutex mu;+    absl::flat_hash_map<const grpc_channel_filter*,","Please add a lock annotation for this data member, just to be safe.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/29598,983999516,2022-09-29T20:33:35Z,test/core/end2end/tests/cancel_before_invoke.cc,"@@ -160,7 +160,7 @@ static void test_cancel_before_invoke(grpc_end2end_test_config config,   error = grpc_call_start_batch(c, ops, test_ops, tag(1), nullptr);   GPR_ASSERT(GRPC_CALL_OK == error); -  cqv.Expect(tag(1), true);+  cqv.Expect(tag(1), grpc_core::CqVerifier::AnyStatus());","Instead of just accepting either response, is there an easy way we can check which stack we're using and check for the right result for that stack?  Probably not a big deal, but in principle, it seems better to be specific about what we're expecting here, so that we don't wind up with any bugs whereby the behavior of either stack becomes non-deterministic.  Also, we may not remember to update this code when we finish switching over to the promise-based stack.",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/29598,984032056,2022-09-29T21:20:18Z,test/core/end2end/tests/cancel_before_invoke.cc,"@@ -160,7 +160,7 @@ static void test_cancel_before_invoke(grpc_end2end_test_config config,   error = grpc_call_start_batch(c, ops, test_ops, tag(1), nullptr);   GPR_ASSERT(GRPC_CALL_OK == error); -  cqv.Expect(tag(1), true);+  cqv.Expect(tag(1), grpc_core::CqVerifier::AnyStatus());","There's not... i actually tried for a while to add one, but it ends up needing an api added to grpc_call which I'm reticent to do. I've added a long-ish comment though, and we'll be coming through this code by mid next year to do the determinism pass, so I'm not too worried that we'd end up in a bad state forever.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/29598,984040152,2022-09-29T21:33:32Z,test/core/end2end/tests/cancel_before_invoke.cc,"@@ -160,7 +160,7 @@ static void test_cancel_before_invoke(grpc_end2end_test_config config,   error = grpc_call_start_batch(c, ops, test_ops, tag(1), nullptr);   GPR_ASSERT(GRPC_CALL_OK == error); -  cqv.Expect(tag(1), true);+  cqv.Expect(tag(1), grpc_core::CqVerifier::AnyStatus());","Okay, as long as we have a plan to deal with this, I'm happy.  Thanks!",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/31166,984083195,2022-09-29T23:00:23Z,src/core/lib/event_engine/default_event_engine.cc,"@@ -78,5 +81,18 @@ void ResetDefaultEventEngine() {   g_event_engine->reset(); } +namespace {+grpc_core::ChannelArgs EnsureEventEngineInChannelArgs(+    grpc_core::ChannelArgs args) {+  if (args.ContainsObject<EventEngine>()) return args;+  return args.SetObject<EventEngine>(GetDefaultEventEngine());+}+}  // namespace++void RegisterEventEngine(grpc_core::CoreConfiguration::Builder* builder) {","Suggest calling this `RegisterEventEngineChannelArgPreconditioning()`, to make it clear what it's actually registering.",X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/31166,984724913,2022-09-30T15:43:30Z,src/core/ext/filters/client_channel/lb_policy/weighted_target/weighted_target.cc,"@@ -175,6 +175,10 @@ class WeightedTargetLb : public LoadBalancingPolicy {       return picker_wrapper_;     } +    WeightedTargetLb* weighted_target_policy() {",This method is not necessary.  `DelayedRemovalTimer` is nested inside of `WeightedChild` and can therefore access its private data members directly.,X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/31166,984727543,2022-09-30T15:46:44Z,src/core/ext/filters/client_channel/lb_policy/xds/xds_cluster_manager.cc,"@@ -466,7 +462,9 @@ void XdsClusterManagerLb::ClusterChild::Orphan() {   // the child.   picker_wrapper_.reset();   if (delayed_removal_timer_handle_.has_value()) {-    engine_->Cancel(*delayed_removal_timer_handle_);+    xds_cluster_manager_policy_->channel_args()","This LB policy should use the same pattern as the grpclb and weighted_target LB policies: The LB policy should be given a `std::shared_ptr<EventEngine>` data member that will be set in its ctor using `GetObjectRef<>()`, and the nested classes can access that data member directly instead of fishing it out of channel args themselves.",
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/31187,984802219,2022-09-30T17:21:32Z,test/core/event_engine/test_suite/client_test.cc,"@@ -195,7 +209,10 @@ TEST_F(EventEngineClientTest, MultipleIPv6ConnectionsToOneOracleListenerTest) {     // Create a test EventEngine client endpoint and connect to a one of the     // addresses bound to the oracle listener. Verify that the connection     // succeeds.-    ChannelArgsEndpointConfig config;+    grpc_core::ChannelArgs args;",consider renaming these variables so it's clear you didn't intend to use the same-named variables in the outer scope.,X
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/31187,984909805,2022-09-30T19:57:33Z,test/core/event_engine/test_suite/client_test.cc,"@@ -135,7 +144,8 @@ TEST_F(EventEngineClientTest, ConnectExchangeBidiDataTransferTest) {   EXPECT_TRUE(client_endpoint != nullptr);","I'm not sure how this slipped in previously, but let's clean this up now. Comparing unique_ptr directly with a nullptr is wonky ... it works, but relies on some hidden casting to bool, and it appears to be deprecated in c++20. See https://en.cppreference.com/w/cpp/memory/unique_ptr/operator_cmp. Also, doing direct comparisons like this in googletest, you want to use the family of `EXPECT_NE(a, b)` tests rather than `EXPECT_TRUE(a != b)` because errors like ""expected: nullptr, actual: 0x12345"" can be more useful than ""expected: true, actual: false"".Consider instead `EXPECT_NE(client_endpoint.get(), nullptr)`.",
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/31187,984910335,2022-09-30T19:58:35Z,test/core/event_engine/test_suite/client_test.cc,"@@ -195,7 +211,10 @@ TEST_F(EventEngineClientTest, MultipleIPv6ConnectionsToOneOracleListenerTest) {     // Create a test EventEngine client endpoint and connect to a one of the     // addresses bound to the oracle listener. Verify that the connection     // succeeds.-    ChannelArgsEndpointConfig config;+    grpc_core::ChannelArgs client_args;+    auto quota = grpc_core::ResourceQuota::Default();","Please rename this as well, it hides a variable in the outer scope.",X
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/30622,985159201,2022-10-02T00:10:25Z,src/core/lib/promise/sleep.cc,"@@ -54,12 +54,9 @@ Poll<absl::Status> Sleep::operator()() { }  Sleep::ActiveClosure::ActiveClosure(Timestamp deadline)-    : waker_(Activity::current()->MakeOwningWaker()) {-  auto engine = GetContext<EventEngine>();-  GPR_ASSERT(engine != nullptr &&","This was originally an integration error... but I'm not happy with sacrificing readability here either - and over time we're going to end up with a very large mess of checks and not checks done differently throughout the codebase. So let's do #31205 instead, and keep this as is.",X
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/31229,987196069,2022-10-04T18:14:24Z,src/core/lib/transport/transport.cc,"@@ -22,22 +22,23 @@  #include <string.h> +#include <memory> #include <new>  #include ""absl/status/status.h"" +#include <grpc/event_engine/event_engine.h>++#include ""src/core/lib/event_engine/default_event_engine.h"" #include ""src/core/lib/gpr/alloc.h"" #include ""src/core/lib/iomgr/exec_ctx.h""-#include ""src/core/lib/iomgr/executor.h""-#include ""src/core/lib/iomgr/iomgr.h"" #include ""src/core/lib/transport/transport_impl.h""  grpc_core::DebugOnlyTraceFlag grpc_trace_stream_refcount(false,                                                          ""stream_refcount"");  void grpc_stream_destroy(grpc_stream_refcount* refcount) {-  if (!grpc_iomgr_is_any_background_poller_thread() &&","it's an optimization that I think is hard to replicate generally going forward, and one that is so limited in scope (the execctx condition is very rarely triggered) that i think we're safe to lose it",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/27669,987345164,2022-10-04T21:27:20Z,src/core/lib/security/authorization/rbac_translator.cc,"@@ -251,61 +267,73 @@ absl::StatusOr<Rbac::Permission> ParseRequest(const Json& json) {   return Rbac::Permission::MakeAndPermission(std::move(request)); } -absl::StatusOr<Rbac::Policy> ParseRules(const Json& json) {-  Rbac::Principal principals;-  auto it = json.object_value().find(""source"");-  if (it != json.object_value().end()) {-    if (it->second.type() != Json::Type::OBJECT) {-      return absl::InvalidArgumentError(""\""source\"" is not an object."");+absl::StatusOr<Rbac::Policy> ParseRule(const Json& json,+                                       std::string* policy_name) {+  std::unique_ptr<Rbac::Principal> principals;","If the goal is to check whether the fields are set, then how about using `absl::optional<>` instead?  That way you get the same semantics, but you don't need any dymamic allocation.",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/31228,987402585,2022-10-04T23:13:10Z,src/core/lib/iomgr/exec_ctx.h,"@@ -97,7 +97,7 @@ class ExecCtx {  public:   /** Default Constructor */ -  ExecCtx() : flags_(GRPC_EXEC_CTX_FLAG_IS_FINISHED) {",Glad you asked... I think we actually want a conditional here - added a big block of text in a comment to explain.,
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/31237,988205724,2022-10-05T18:08:32Z,tools/run_tests/run_tests.py,"@@ -278,7 +278,8 @@ def configure(self, config, args):             self._cmake_architecture_windows = 'x64' if self.args.arch == 'x64' else 'Win32'             # when builing with Ninja, the VS common tools need to be activated first             self._activate_vs_tools_windows = activate_vs_tools-            self._vs_tools_architecture_windows = 'x64' if self.args.arch == 'x64' else 'x86'+            # always use x64 toolset to overcome the memory limit of 32bit linker+            self._vs_tools_architecture_windows = 'x64'",wouldn't this make 32bit build on windows silently become 64bit? https://github.com/grpc/grpc/blob/0afcc375890eef6de23c8e0a29b6953b3f07b8e0/tools/run_tests/helper_scripts/build_cxx.bat#L31Let's doublecheck that before proceeding with this PR.,
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/31025,988215332,2022-10-05T18:20:47Z,src/core/ext/xds/xds_common_types.cc,"@@ -45,6 +46,25 @@  namespace grpc_core { +//+// ParseDuration()+//++Duration ParseDuration(const google_protobuf_Duration* proto_duration,+                       ValidationErrors* errors) {+  int64_t seconds = google_protobuf_Duration_seconds(proto_duration);+  if (seconds < 0 || seconds > 315576000000) {","We're using them in exactly two places, here and in the JSON parsing code.  I don't really see a convenient common dependency where we could put the constant, and I don't think the duplication is going to cause enough of a problem to warrant the overhead of creating a new module just for this constant.",X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/30516,988281760,2022-10-05T19:42:08Z,src/core/lib/security/context/security_context.h,"@@ -41,6 +41,16 @@  extern grpc_core::DebugOnlyTraceFlag grpc_trace_auth_context_refcount; +/* --- grpc_security_context_extension ---++   Extension to the security context that may be set in a filter and accessed+   later by a higher level method on a grpc_call object. */++struct grpc_security_context_extension {","This C type is actually for a different purpose, and I don't think we should use it here.  You can move this back down to its original location, below `grpc_auth_context`.For this PR, let's instead introduce an idiomatic C++ type, like this:```struct grpc_auth_context    : public grpc_core::RefCounted<grpc_auth_context,                                   grpc_core::NonPolymorphicRefCount> { public:  // A base class for extensions to inherit from.  class Extension {   public:    virtual ~Extension() = default;  };  void set_extension(std::unique_ptr<Extension> extension) {    extension_ = std::move(extension);  }  // ... private:  // ...  std::unique_ptr<Extension> extension_;};```Then you can define a subclass of `grpc_auth_context::Extension` that contains whatever you need it to.",
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/31237,989079595,2022-10-06T13:52:59Z,tools/run_tests/run_tests.py,"@@ -278,7 +278,8 @@ def configure(self, config, args):             self._cmake_architecture_windows = 'x64' if self.args.arch == 'x64' else 'Win32'             # when builing with Ninja, the VS common tools need to be activated first             self._activate_vs_tools_windows = activate_vs_tools-            self._vs_tools_architecture_windows = 'x64' if self.args.arch == 'x64' else 'x86'+            # always use x64 toolset to overcome the memory limit of 32bit linker+            self._vs_tools_architecture_windows = 'x64'","I don't think your assumptions are correct. There are actually 2 ways of building (see the if then else in the script)1. build with Ninja, which doesn't set architecture through cmake, but instead relies on the default architecture for the vs tools you selected (and I think this is the case that will get broken by your change)https://github.com/grpc/grpc/blob/0afcc375890eef6de23c8e0a29b6953b3f07b8e0/tools/run_tests/helper_scripts/build_cxx.bat#L412. build with cmake's visual studio generator, which lets you pass `-A` architecture flag to cmakehttps://github.com/grpc/grpc/blob/0afcc375890eef6de23c8e0a29b6953b3f07b8e0/tools/run_tests/helper_scripts/build_cxx.bat#L48",
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/30930,989143416,2022-10-06T14:44:44Z,tools/buildgen/extract_metadata_from_bazel_xml.py,"@@ -462,6 +468,12 @@ def update_test_metadata_with_transitive_metadata(             lib_dict['language'] = 'c++'  +def _get_actual_rule(bazel_rules, rule):+    while rule != None and rule['actual'] != None:",`!= None` is bad python afaik. `is not None` is better.Actually `while rule and rule['actual']:` should be sufficient.,
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/31271,989537883,2022-10-06T22:46:21Z,src/core/ext/filters/channel_idle/channel_idle_filter.cc,"@@ -277,9 +278,10 @@ void ChannelIdleFilter::StartIdleTimer() {  void ChannelIdleFilter::CloseChannel() {   auto* op = grpc_make_transport_op(nullptr);-  op->disconnect_with_error = grpc_error_set_int(-      GRPC_ERROR_CREATE(""enter idle""),-      StatusIntProperty::ChannelConnectivityState, GRPC_CHANNEL_IDLE);+  op->disconnect_with_error =+      GRPC_ERROR_BUILDER(kUnknown, ""enter idle"")+          .Set(StatusIntProperty::ChannelConnectivityState, GRPC_CHANNEL_IDLE)","Since the list of properties is known, I'd suggest:`.WithChannelConnectivityState(GRPC_CHANNEL_IDLE)`",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/31294,990809586,2022-10-09T16:28:54Z,src/core/BUILD,"@@ -0,0 +1,43 @@+# Copyright 2022 gRPC authors.+#+# Licensed under the Apache License, Version 2.0 (the ""License"");+# you may not use this file except in compliance with the License.+# You may obtain a copy of the License at+#+#     http://www.apache.org/licenses/LICENSE-2.0+#+# Unless required by applicable law or agreed to in writing, software+# distributed under the License is distributed on an ""AS IS"" BASIS,+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+# See the License for the specific language governing permissions and+# limitations under the License.++load(+    ""//bazel:grpc_build_system.bzl"",+    ""grpc_cc_library"",+    ""grpc_generate_one_off_targets"",+    ""grpc_upb_proto_library"",+    ""grpc_upb_proto_reflection_library"",+    ""python_config_settings"",+)+load(""@bazel_skylib//lib:selects.bzl"", ""selects"")++exports_files(glob([""**""]))++licenses([""reciprocal""])++package(+    default_visibility = [""//visibility:public""],+    features = [+        ""layering_check"",+        ""-parse_headers"",+    ],+)++grpc_cc_library(",Can we do `event_engine_common` before getting too much further... it's got a dependency on `include/` that I think is going to inform the rest of the decisions we might make on this.,
2793282,veblush,https://api.github.com/repos/grpc/grpc/pulls/31237,991453324,2022-10-10T16:11:53Z,tools/run_tests/helper_scripts/build_cxx.bat,"@@ -45,7 +45,7 @@ If ""%GRPC_CMAKE_GENERATOR%"" == ""Ninja"" ( ) else (   @rem Use one of the Visual Studio generators. -  cmake -G ""%GRPC_CMAKE_GENERATOR%"" -A ""%GRPC_CMAKE_ARCHITECTURE%"" -DgRPC_BUILD_TESTS=ON -DgRPC_BUILD_MSVC_MP_COUNT=%GRPC_RUN_TESTS_JOBS% %* ../.. || goto :error+  cmake -G ""%GRPC_CMAKE_GENERATOR%"" -A ""%GRPC_CMAKE_ARCHITECTURE%"" -DCMAKE_VS_PLATFORM_TOOLSET_HOST_ARCHITECTURE=x64 -DgRPC_BUILD_TESTS=ON -DgRPC_BUILD_MSVC_MP_COUNT=%GRPC_RUN_TESTS_JOBS% %* ../.. || goto :error","If the ninja build uses vc tools, it should be affected as well. Then I'm going to make the same change for that.OSS policy requires at least 3.10 of cmake ([ref](https://github.com/google/oss-policies-info/blob/main/foundational-cxx-support-matrix.md)) so we also can bump the version as well. But this change can be in a new PR.",
1644595,gnossen,https://api.github.com/repos/grpc/grpc/pulls/31288,991498276,2022-10-10T17:08:23Z,src/python/grpcio/grpc/__init__.py,"@@ -45,7 +44,7 @@ class FutureCancelledError(Exception):     """"""Indicates that the computation underlying a Future was cancelled.""""""  -class Future(six.with_metaclass(abc.ABCMeta)):","For posterity, since I had to do some research to convince myself that this was a backward compatible change:- The Cython implementation of [`with_metaclass`](https://github.com/benjaminp/six/blob/3b7efbcca41857da03fb01f004ccc425ab82dfbf/six.py#L856)- The implementation of [`abc.ABC`](https://github.com/python/cpython/blob/553d3c10172254b190078c50eb9f8e60522c8f41/Lib/abc.py#L184)I _think_ this should work, but we've heard complaints in the past when making changes to these base classes / metaclasses. Can you please do a little more research and post the results on the PR? What do the old objects look like and what do the new ones look like. Ideally, you should recursively call `dir()` on an instance of the old and an instance of the new and make sure that everything looks the same.",
24593237,XuanWang-Amos,https://api.github.com/repos/grpc/grpc/pulls/31288,991622781,2022-10-10T20:35:02Z,src/python/grpcio/grpc/__init__.py,"@@ -45,7 +44,7 @@ class FutureCancelledError(Exception):     """"""Indicates that the computation underlying a Future was cancelled.""""""  -class Future(six.with_metaclass(abc.ABCMeta)):","Sure, I checked `type` and `dir` for one of the base object `Channel`, here is the result:#### Context- [Channel](https://github.com/grpc/grpc/blob/master/src/python/grpcio/grpc/_channel.py#L1462) is a class of `grpc.Channel`(internally `grpc._channel.Channel`) which in turn is a [subclass of `abc.ABCMeta`](https://github.com/grpc/grpc/blob/master/src/python/grpcio/grpc/__init__.py#L942).#### When Using `class Channel(six.with_metaclass(abc.ABCMeta))`:* Type of `channel`: `<class 'grpc._channel.Channel'>`* `dir` of `channel`:```['__abstractmethods__', '__class__', '__del__', '__delattr__', '__dict__', '__dir__', '__doc__', '__enter__', '__eq__', '__exit__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', '_abc_impl', '_call_state', '_channel', '_close', '_close_on_fork', '_connectivity_state', '_process_python_options', '_single_threaded_unary_stream', '_unsubscribe_all', 'close', 'stream_stream', 'stream_unary', 'subscribe', 'unary_stream', 'unary_unary', 'unsubscribe']```* Type of `grpc._channel.Channel`: `<class 'abc.ABCMeta'>`* `dir` of `grpc._channel.Channel`:```['__abstractmethods__', '__class__', '__del__', '__delattr__', '__dict__', '__dir__', '__doc__', '__enter__', '__eq__', '__exit__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', '_abc_impl', '_close', '_close_on_fork', '_process_python_options', '_unsubscribe_all', 'close', 'stream_stream', 'stream_unary', 'subscribe', 'unary_stream', 'unary_unary', 'unsubscribe']```#### When Using `class Channel(abc.ABC)`:* Type of `channel`: `<class 'grpc._channel.Channel'>`* `dir` of `channel`:```['__abstractmethods__', '__class__', '__del__', '__delattr__', '__dict__', '__dir__', '__doc__', '__enter__', '__eq__', '__exit__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__slots__', '__str__', '__subclasshook__', '__weakref__', '_abc_impl', '_call_state', '_channel', '_close', '_close_on_fork', '_connectivity_state', '_process_python_options', '_single_threaded_unary_stream', '_unsubscribe_all', 'close', 'stream_stream', 'stream_unary', 'subscribe', 'unary_stream', 'unary_unary', 'unsubscribe']```* Type of `grpc._channel.Channel`:`<class 'abc.ABCMeta'>`* `dir` of `grpc._channel.Channel`:```['__abstractmethods__', '__class__', '__del__', '__delattr__', '__dict__', '__dir__', '__doc__', '__enter__', '__eq__', '__exit__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__slots__', '__str__', '__subclasshook__', '__weakref__', '_abc_impl', '_close', '_close_on_fork', '_process_python_options', '_unsubscribe_all', 'close', 'stream_stream', 'stream_unary', 'subscribe', 'unary_stream', 'unary_unary', 'unsubscribe']```#### Difference- The only difference between `six.with_metaclass(abc.ABCMeta)` and `abc.ABC` is that both `Channel` and `grpc._channel.Channel` are missing `__slots__` for classes created by Six, that's expected since we can see that the implementation of [abc.ABC](https://github.com/python/cpython/blob/553d3c10172254b190078c50eb9f8e60522c8f41/Lib/abc.py#L184) is adding `__slots__` to `abc.ABCMeta`, I also verified that the `dir()` is the same if we use `metaclass=abc.ABCMeta` instead of `abc.ABC`.Since use `abc.ABC` is listed as an alternative of `metaclass=abc.ABCMeta` which can help avoid confusing metaclass usage in [official docs](https://docs.python.org/3/library/abc.html#abc.ABC), I think it should be fine to keep it.Please let me know if you think it's better to use `metaclass=abc.ABCMeta`.",
5564114,Vignesh2208,https://api.github.com/repos/grpc/grpc/pulls/31128,994978141,2022-10-13T18:18:36Z,src/core/lib/event_engine/posix_engine/posix_engine.cc,"@@ -15,23 +15,89 @@  #include ""src/core/lib/event_engine/posix_engine/posix_engine.h"" +#include <atomic>+#include <chrono> #include <string> #include <utility>  #include ""absl/container/flat_hash_set.h"" #include ""absl/functional/any_invocable.h""+#include ""absl/status/status.h""  #include <grpc/event_engine/event_engine.h>+#include <grpc/event_engine/memory_allocator.h> #include <grpc/support/log.h>  #include ""src/core/lib/debug/trace.h""+#include ""src/core/lib/event_engine/poller.h"" #include ""src/core/lib/event_engine/posix_engine/timer.h"" #include ""src/core/lib/event_engine/trace.h"" #include ""src/core/lib/event_engine/utils.h""+#include ""src/core/lib/gprpp/sync.h""++#ifdef GRPC_POSIX_SOCKET_TCP+#include ""src/core/lib/event_engine/posix_engine/event_poller_posix_default.h""+#endif  // GRPC_POSIX_SOCKET_TCP++using namespace std::chrono_literals;  namespace grpc_event_engine { namespace experimental { +#ifdef GRPC_POSIX_SOCKET_TCP+using grpc_event_engine::posix_engine::PosixEventPoller;++PosixEventEngine::PosixEventEngine(PosixEventPoller* poller)+    : poller_(poller), poller_state_(PollerState::kExternal) {+  GPR_ASSERT(poller_ != nullptr);+}++PosixEventEngine::PosixEventEngine()+    : poller_(grpc_event_engine::posix_engine::GetDefaultPoller(this)) {+  ++shutdown_ref_;+  if (poller_ != nullptr) {+    executor_.Run([this]() { PollerWorkInternal(); });+  }+}++void PosixEventEngine::PollerWorkInternal() {+  // TODO(vigneshbabu): The timeout specified here is arbitrary. For instance,+  // this can be improved by setting the timeout to the next expiring timer.+  auto result = poller_->Work(24h, [this]() {+    ++shutdown_ref_;+    executor_.Run([this]() { PollerWorkInternal(); });+  });+  if (result == Poller::WorkResult::kDeadlineExceeded) {+    // The event engine is not shutting down but the next asynchronous+    // PollerWorkInternal did not get scheduled. Schedule it now.+    ++shutdown_ref_;","Removed the implementation. Now we dont need a shutdown_ref. Instead the poller state is managed by a PosixEnginePollerManager class which is held as a shared_ptr by the event engine. In the event engine destructor, we no simple trigger shutdown on this class.",X
933495,dennycd,https://api.github.com/repos/grpc/grpc/pulls/31046,995338544,2022-10-14T04:50:39Z,src/objective-c/tests/BUILD,"@@ -263,6 +264,20 @@ tvos_unit_test(     ], ) +# TvTests is not runnable with bazel, so the best we can do is to test+# that the testsuite builds correctly. This is achieved by having+# a dummy sh_test depend on :TvTests.+grpc_sh_test(",reason why we don't just use [tvos_build_test](https://github.com/bazelbuild/rules_apple/blob/master/doc/rules-tvos.md#tvos_build_test) for this ?,
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/31299,995717947,2022-10-14T12:42:45Z,src/compiler/csharp_generator.cc,"@@ -110,6 +110,13 @@ bool GenerateDocCommentBody(grpc::protobuf::io::Printer* printer,   return GenerateDocCommentBodyImpl(printer, location); } +void GenerateObsoleteAttributeIfObsolete(grpc::protobuf::io::Printer* printer,+                                         const MethodDescriptor* method) {+  if (method->options().deprecated()) {+    printer->Print(""[global::System.Obsolete]\n"");","I remember there was a problem with the .NET Obsolete attribute that it will break existing users' builds unless it is silenced, so adding the Obsolete attribute to the generated code is as a matter of fact a breaking change (and we try to avoid breaking API changes as much as possible)So while adding [Obsolete] atrribute for ""deprecated"" elements may seem to make sense, I not clear to me whether this is actually the right thing to do.",
521666,chuchu,https://api.github.com/repos/grpc/grpc/pulls/31299,996033702,2022-10-14T18:33:40Z,src/compiler/csharp_generator.cc,"@@ -110,6 +110,13 @@ bool GenerateDocCommentBody(grpc::protobuf::io::Printer* printer,   return GenerateDocCommentBodyImpl(printer, location); } +void GenerateObsoleteAttributeIfObsolete(grpc::protobuf::io::Printer* printer,+                                         const MethodDescriptor* method) {+  if (method->options().deprecated()) {+    printer->Print(""[global::System.Obsolete]\n"");","Hi Jan,thanks for you comment! When a method, which is annotated with the obsolete attribute is referenced, a compiler warning is generated. That is why I have disabled the warning in the generated code. We should should not generate warnings without an actual usage. When the project is configured to treat warnings as errors the build fails. So you are right. This is a breaking change. On the other hand, when the server removes the deprecated method eventually the build is broken as well.What do you think about an top level option in the proto file to generate the C# obsolete attribute? Or some other option which could be used on the command line. This could give a bit more control.BTW are there any tests which verify that a given proto produces a given C# file?Here is an example. Given this proto snippet:```protobufrpc SayHelloOld (HelloRequest) returns (HelloReply) {  option deprecated = true;}```Will produce this C# snippets:```csharp[global::System.CodeDom.Compiler.GeneratedCode(""grpc_csharp_plugin"", null)][global::System.Obsolete]public virtual global::System.Threading.Tasks.Task<global::Helloworld.HelloReply> SayHelloOld(global::Helloworld.HelloRequest request, grpc::ServerCallContext context){  throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, """"));}``````csharp[global::System.CodeDom.Compiler.GeneratedCode(""grpc_csharp_plugin"", null)]public static grpc::ServerServiceDefinition BindService(GreeterBase serviceImpl){  return grpc::ServerServiceDefinition.CreateBuilder()    #pragma warning disable CS0612    .AddMethod(__Method_SayHelloOld, serviceImpl.SayHelloOld)    #pragma warning restore CS0612    .AddMethod(__Method_SayHelloNew, serviceImpl.SayHelloNew).Build();}```The complete example is here.[sample.tar.gz](https://github.com/grpc/grpc/files/9789132/sample.tar.gz)Best regards,Chris",
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/31392,1000046221,2022-10-20T00:51:46Z,src/core/lib/event_engine/posix_engine/timer_manager.cc,"@@ -155,54 +72,32 @@ void TimerManager::MainLoop() {     grpc_core::Timestamp next = grpc_core::Timestamp::InfFuture();     absl::optional<std::vector<experimental::EventEngine::Closure*>>         check_result = timer_list_->TimerCheck(&next);-    if (check_result.has_value()) {-      if (!check_result->empty()) {-        RunSomeTimers(std::move(*check_result));-        continue;-      }-    } else {-      /* This case only happens under contention, meaning more than one timer-         manager thread checked timers concurrently.--         If that happens, we're guaranteed that some other thread has just-         checked timers, and this will avalanche into some other thread seeing-         empty timers and doing a timed sleep.--         Consequently, we can just sleep forever here and be happy at some-         saved wakeup cycles. */-      next = grpc_core::Timestamp::InfFuture();+    GPR_ASSERT(check_result.has_value() &&+               ""ERROR: More than one MainLoop is running."");+    if (!check_result->empty()) {+      RunSomeTimers(std::move(*check_result));+      continue;     }-    if (!WaitUntil(next)) return;-  }-}--void TimerManager::RunThread(void* arg) {-  g_timer_thread = true;-  std::unique_ptr<RunThreadArgs> thread(static_cast<RunThreadArgs*>(arg));-  if (grpc_event_engine_timer_trace.enabled()) {-    gpr_log(GPR_DEBUG, ""TimerManager::%p starting thread::%p"", thread->self,-            &thread->thread);-  }-  thread->self->Run();-  if (grpc_event_engine_timer_trace.enabled()) {-    gpr_log(GPR_DEBUG, ""TimerManager::%p thread::%p finished"", thread->self,-            &thread->thread);+    if (!WaitUntil(next)) break;   }-}--void TimerManager::Run() {-  MainLoop();-  grpc_core::MutexLock lock(&mu_);-  thread_count_--;-  if (thread_count_ == 0) cv_threadcount_.Signal();+  main_loop_exit_signal_.Notify(); }  bool TimerManager::IsTimerManagerThread() { return g_timer_thread; } -TimerManager::TimerManager() : host_(this) {+TimerManager::TimerManager(+    std::shared_ptr<grpc_event_engine::experimental::ThreadPool> thread_pool)+    : host_(this), thread_pool_(std::move(thread_pool)) {   timer_list_ = std::make_unique<TimerList>(&host_);-  grpc_core::MutexLock lock(&mu_);-  StartThread();+  main_thread_ = grpc_core::Thread(","It is intentionally not on the thread pool. There is now just one persistent TimerManager main loop. In the current incarnation, we do not want it executing closures, timer or otherwise, when work stealing is landed (presuming that happens before the timer manager's polling is integrated with the I/O polling thread, which I will do as soon as Vignesh's work on the poller https://github.com/grpc/grpc/pull/31128 is merged and stable).Alternative solutions could exist here that let a TimerManager with multiple MainLoops run on the thread pool, with a fair amount of added complexity. This PR is an intermediate step that allows work stealing to influence timer callbacks. I don't necessarily think it's worth managing a pool within a pool to allow callbacks to execute in the same thread, especially when that code is going away very quickly.",
5564114,Vignesh2208,https://api.github.com/repos/grpc/grpc/pulls/31298,1000111418,2022-10-20T03:37:03Z,src/core/lib/channel/connected_channel.cc,"@@ -381,7 +380,7 @@ class ClientStream : public Orphanable {           nullptr;       batch_payload_.recv_initial_metadata.peer_string = nullptr;       server_trailing_metadata_ =-          GetContext<FragmentAllocator>()->MakeClientMetadata();+          GetContext<Arena>()->MakePooled<ServerMetadata>(GetContext<Arena>());",Should this be MakePooled\<ClientMetadata\> ?,
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/31298,1000115035,2022-10-20T03:47:00Z,src/core/lib/channel/connected_channel.cc,"@@ -381,7 +380,7 @@ class ClientStream : public Orphanable {           nullptr;       batch_payload_.recv_initial_metadata.peer_string = nullptr;       server_trailing_metadata_ =-          GetContext<FragmentAllocator>()->MakeClientMetadata();+          GetContext<Arena>()->MakePooled<ServerMetadata>(GetContext<Arena>());","no... this is the server trailing metadata, so metadata from the server (which is what the type indicates)... the previous code was wrong!(that said, totally the same underlying type right now which is why it wasn't caught)",
5564114,Vignesh2208,https://api.github.com/repos/grpc/grpc/pulls/31392,1000192330,2022-10-20T06:29:12Z,src/core/lib/event_engine/posix_engine/timer_manager.h,"@@ -44,30 +44,23 @@ namespace posix_engine { // all times, and thus effectively preventing the thundering herd problem. // TODO(ctiller): consider unifying this thread pool and the one in // thread_pool.{h,cc}.-class TimerManager final : public grpc_event_engine::experimental::Forkable {+class TimerManager final {",Could you elaborate on why this is no longer a Forkable ?,
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/31376,1000332056,2022-10-20T08:52:37Z,src/csharp/Grpc.Core.Tests/ChannelTest.cs,"@@ -123,5 +123,16 @@ public async Task ChannelBaseShutdownAsyncInvokesShutdownAsync()             // check that Channel.ShutdownAsync has run             Assert.AreEqual(ChannelState.Shutdown, channel.State);         }++        [Test]+        public void CompositeCredentialsWithInsecureThrow()+        {+            var compositeCredentials = ChannelCredentials.Create(+                ChannelCredentials.Insecure,+                CallCredentials.FromInterceptor((context, metadata) => Task.CompletedTask));","`/var/local/git/grpc/src/csharp/Grpc.Core.Tests/ChannelTest.cs(132,77): error CS0117: 'Task' does not contain a definition for 'CompletedTask' [/var/local/git/grpc/src/csharp/Grpc.Core.Tests/Grpc.Core.Tests.csproj]`. This is due to the .NET45 target.You can use https://github.com/grpc/grpc/blob/fc302e37f2c1ec1db112bafd26427d65301ad9dd/src/csharp/Grpc.Core/Utils/TaskUtils.cs#L32 instead.",
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/31392,1000774837,2022-10-20T15:15:32Z,src/core/lib/event_engine/posix_engine/timer_manager.h,"@@ -44,30 +44,23 @@ namespace posix_engine { // all times, and thus effectively preventing the thundering herd problem. // TODO(ctiller): consider unifying this thread pool and the one in // thread_pool.{h,cc}.-class TimerManager final : public grpc_event_engine::experimental::Forkable {+class TimerManager final {","This class no longer needs to do anything special on fork, which is to say that it is trivially forkable.",X
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/31298,1000797732,2022-10-20T15:32:54Z,src/core/lib/resource_quota/arena.h,"@@ -88,6 +131,37 @@ class Arena {     return &p->t;   } +  class PooledDeleter {+   public:+    explicit PooledDeleter(Arena* arena) : arena_(arena) {}+    PooledDeleter() = default;+    template <typename T>+    void operator()(T* p) {+      // TODO(ctiller): promise based filter hijacks ownership of some pointers+      // to make them appear as PoolPtr without really transferring ownership,+      // by setting the arena to nullptr.+      // This is a transitional hack and should be removed once promise based+      // filter is removed.+      if (arena_ != nullptr) arena_->DeletePooled(p);+    }++   private:+    Arena* arena_;+  };++  template <typename T>+  using PoolPtr = std::unique_ptr<T, PooledDeleter>;++  template <typename T, typename... Args>+  PoolPtr<T> MakePooled(Args&&... args) {+    return PoolPtr<T>(+        new (AllocPooled(+            arena_detail::AllocationSizeFromObjectSize<sizeof(T)>(PoolSizes()),+            &pools_[arena_detail::PoolFromObjectSize<sizeof(T)>(PoolSizes())]))",(reason is that `PoolIndexForSize` contains no index for the empty list -- line 70 -- and hence if we need to access that we'll not compile),
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/31074,1001013332,2022-10-20T19:03:36Z,test/core/event_engine/posix/BUILD,"@@ -191,3 +194,26 @@ grpc_cc_test(         ""//test/core/util:grpc_test_util"",     ], )++grpc_cc_test(+    name = ""posix_event_engine_connect_test"",+    srcs = [""posix_event_engine_connect_test.cc""],+    external_deps = [""gtest""],+    language = ""C++"",+    tags = [+        ""no_windows"",+    ],+    uses_event_engine = True,+    uses_polling = True,",Does this test need to be replicated for every poller using the `@poller=X` test duplication mechanism?,
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/31074,1001013810,2022-10-20T19:04:11Z,test/core/event_engine/test_suite/BUILD,"@@ -80,8 +80,11 @@ grpc_cc_test(     tags = [         ""no_windows"",     ],-    uses_polling = False,+    uses_event_engine = True,+    uses_polling = True,",same question regarding poller duplication.,
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/31074,1001029262,2022-10-20T19:22:45Z,test/core/event_engine/posix/posix_event_engine_connect_test.cc,"@@ -0,0 +1,240 @@+// Copyright 2022 gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+#include <errno.h>+#include <fcntl.h>+#include <poll.h>+#include <stdlib.h>+#include <sys/socket.h>+#include <unistd.h>++#include <algorithm>+#include <chrono>+#include <cstring>+#include <memory>+#include <string>+#include <utility>+#include <vector>++#include ""absl/memory/memory.h""+#include ""absl/status/status.h""+#include ""absl/status/statusor.h""+#include ""absl/strings/str_cat.h""+#include ""gtest/gtest.h""++#include <grpc/event_engine/event_engine.h>+#include <grpc/grpc.h>+#include <grpc/support/log.h>++#include ""src/core/lib/channel/channel_args.h""+#include ""src/core/lib/event_engine/channel_args_endpoint_config.h""+#include ""src/core/lib/event_engine/posix_engine/posix_engine.h""+#include ""src/core/lib/event_engine/posix_engine/tcp_socket_utils.h""+#include ""src/core/lib/experiments/experiments.h""+#include ""src/core/lib/gprpp/notification.h""+#include ""src/core/lib/resource_quota/memory_quota.h""+#include ""src/core/lib/resource_quota/resource_quota.h""+#include ""test/core/event_engine/test_suite/event_engine_test_utils.h""+#include ""test/core/util/port.h""+#include ""test/core/util/test_config.h""++namespace grpc_event_engine {+namespace posix_engine {++using ::grpc_event_engine::experimental::ChannelArgsEndpointConfig;+using ::grpc_event_engine::experimental::EventEngine;+using ::grpc_event_engine::experimental::PosixEventEngine;+using ::grpc_event_engine::experimental::URIToResolvedAddress;+using ::grpc_event_engine::experimental::WaitForSingleOwner;+using namespace std::chrono_literals;++namespace {++// Creates a server socket listening for one connection on a specific port. It+// then creates another client socket connected to the server socket. This fills+// up the kernel listen queue on the server socket. Any subsequent attempts to+// connect to the server socket will be pending indefinitely. This can be used+// to test Connection timeouts and cancellation attempts.+absl::StatusOr<std::vector<int>> CreateConnectedSockets(+    EventEngine::ResolvedAddress resolved_addr) {+  int server_socket;+  int opt = -1;+  int client_socket;+  int one = 1;+  int flags;+  std::vector<int> ret_sockets;+  // Creating a new socket file descriptor.+  if ((server_socket = socket(AF_INET6, SOCK_STREAM, 0)) <= 0) {+    return absl::UnknownError(+        absl::StrCat(""Error creating socket: "", std::strerror(errno)));+  }+  // MacOS biulds fail if SO_REUSEADDR and SO_REUSEPORT are set in the same+  // setsockopt syscall. So they are set separately one after the other.+  if (setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt))) {+    return absl::UnknownError(+        absl::StrCat(""Error setsockopt(SO_REUSEADDR): "", std::strerror(errno)));+  }+  if (setsockopt(server_socket, SOL_SOCKET, SO_REUSEPORT, &opt, sizeof(opt))) {+    return absl::UnknownError(+        absl::StrCat(""Error setsockopt(SO_REUSEPORT): "", std::strerror(errno)));+  }++  // Forcefully bind the new socket.+  if (bind(server_socket, resolved_addr.address(), resolved_addr.size()) < 0) {+    return absl::UnknownError(+        absl::StrCat(""Error bind: "", std::strerror(errno)));+  }+  // Set the new socket to listen for one active connection at a time.+  // accept() is intentionally not called on the socket. This allows the+  // connection queue to build up.+  if (listen(server_socket, 1) < 0) {+    return absl::UnknownError(+        absl::StrCat(""Error listen: "", std::strerror(errno)));+  }+  ret_sockets.push_back(server_socket);+  // Create and connect client sockets until the connection attempt times out.+  // Even if the backlog specified to listen is 1, the kernel continues to+  // accept a certain number of SYN packets before dropping them. This loop+  // attempts to identify the number of new connection attempts that will+  // be allowed by the kernel before any subsequent connection attempts+  // become pending indefinitely.+  while (true) {+    client_socket = socket(AF_INET6, SOCK_STREAM, 0);+    setsockopt(client_socket, SOL_SOCKET, SO_REUSEADDR, &one, sizeof(one));+    // Make fd non-blocking.+    flags = fcntl(client_socket, F_GETFL, 0);+    EXPECT_EQ(fcntl(client_socket, F_SETFL, flags | O_NONBLOCK), 0);++    if (connect(client_socket,+                const_cast<struct sockaddr*>(resolved_addr.address()),+                resolved_addr.size()) == -1) {+      if (errno == EINPROGRESS) {+        struct pollfd pfd;+        pfd.fd = client_socket;+        pfd.events = POLLOUT;+        pfd.revents = 0;+        int ret = poll(&pfd, 1, 1000);+        if (ret == -1) {+          gpr_log(GPR_ERROR, ""poll() failed during connect; errno=%d"", errno);+          abort();+        } else if (ret == 0) {+          // current connection attempt timed out. It indicates that the+          // kernel will cause any subsequent connection attempts to+          // become pending indefinitely.+          ret_sockets.push_back(client_socket);+          return ret_sockets;+        }+      } else {+        gpr_log(GPR_ERROR, ""Failed to connect to the server (errno=%d)"", errno);+        abort();+      }+    }+    ret_sockets.push_back(client_socket);+  }+  return ret_sockets;+}++}  // namespace++TEST(PosixEventEngineTest, IndefiniteConnectTimeoutOrRstTest) {+  std::string target_addr = absl::StrCat(+      ""ipv6:[::1]:"", std::to_string(grpc_pick_unused_port_or_die()));+  auto resolved_addr = URIToResolvedAddress(target_addr);+  std::shared_ptr<EventEngine> posix_ee = std::make_shared<PosixEventEngine>();+  std::string resolved_addr_str =+      SockaddrToString(&resolved_addr, true).value();+  auto sockets = CreateConnectedSockets(resolved_addr);+  grpc_core::Notification signal;+  ASSERT_TRUE(sockets.ok());+  grpc_core::ChannelArgs args;+  auto quota = grpc_core::ResourceQuota::Default();+  args = args.Set(GRPC_ARG_RESOURCE_QUOTA, quota);+  ChannelArgsEndpointConfig config(args);+  auto memory_quota = absl::make_unique<grpc_core::MemoryQuota>(""bar"");+  posix_ee->Connect(+      [&signal, &resolved_addr_str](+          absl::StatusOr<std::unique_ptr<EventEngine::Endpoint>> status) {+        ASSERT_FALSE(status.ok());+        absl::Status deadline_exceeded_expected_status =+            absl::CancelledError(absl::StrCat(","nit: Checking error strings can be error-prone and brittle, as they are not part of the contract. Consider if you added some data to that error string in the EventEngine implementation ... should this test be considered broken if the strings don't match exactly? How many tests should need to change if the error strings change? It's a subtle thing, but can be annoying when you test internal details rather than the API contract itself.You could instead just assert the error _type_, which should be an invariant in the API contract. ",
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/31074,1001033392,2022-10-20T19:27:59Z,test/core/event_engine/posix/posix_event_engine_connect_test.cc,"@@ -0,0 +1,240 @@+// Copyright 2022 gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+#include <errno.h>+#include <fcntl.h>+#include <poll.h>+#include <stdlib.h>+#include <sys/socket.h>+#include <unistd.h>++#include <algorithm>+#include <chrono>+#include <cstring>+#include <memory>+#include <string>+#include <utility>+#include <vector>++#include ""absl/memory/memory.h""+#include ""absl/status/status.h""+#include ""absl/status/statusor.h""+#include ""absl/strings/str_cat.h""+#include ""gtest/gtest.h""++#include <grpc/event_engine/event_engine.h>+#include <grpc/grpc.h>+#include <grpc/support/log.h>++#include ""src/core/lib/channel/channel_args.h""+#include ""src/core/lib/event_engine/channel_args_endpoint_config.h""+#include ""src/core/lib/event_engine/posix_engine/posix_engine.h""+#include ""src/core/lib/event_engine/posix_engine/tcp_socket_utils.h""+#include ""src/core/lib/experiments/experiments.h""+#include ""src/core/lib/gprpp/notification.h""+#include ""src/core/lib/resource_quota/memory_quota.h""+#include ""src/core/lib/resource_quota/resource_quota.h""+#include ""test/core/event_engine/test_suite/event_engine_test_utils.h""+#include ""test/core/util/port.h""+#include ""test/core/util/test_config.h""++namespace grpc_event_engine {+namespace posix_engine {++using ::grpc_event_engine::experimental::ChannelArgsEndpointConfig;+using ::grpc_event_engine::experimental::EventEngine;+using ::grpc_event_engine::experimental::PosixEventEngine;+using ::grpc_event_engine::experimental::URIToResolvedAddress;+using ::grpc_event_engine::experimental::WaitForSingleOwner;+using namespace std::chrono_literals;++namespace {++// Creates a server socket listening for one connection on a specific port. It+// then creates another client socket connected to the server socket. This fills+// up the kernel listen queue on the server socket. Any subsequent attempts to+// connect to the server socket will be pending indefinitely. This can be used+// to test Connection timeouts and cancellation attempts.+absl::StatusOr<std::vector<int>> CreateConnectedSockets(+    EventEngine::ResolvedAddress resolved_addr) {+  int server_socket;+  int opt = -1;+  int client_socket;+  int one = 1;+  int flags;+  std::vector<int> ret_sockets;+  // Creating a new socket file descriptor.+  if ((server_socket = socket(AF_INET6, SOCK_STREAM, 0)) <= 0) {+    return absl::UnknownError(+        absl::StrCat(""Error creating socket: "", std::strerror(errno)));+  }+  // MacOS biulds fail if SO_REUSEADDR and SO_REUSEPORT are set in the same+  // setsockopt syscall. So they are set separately one after the other.+  if (setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt))) {+    return absl::UnknownError(+        absl::StrCat(""Error setsockopt(SO_REUSEADDR): "", std::strerror(errno)));+  }+  if (setsockopt(server_socket, SOL_SOCKET, SO_REUSEPORT, &opt, sizeof(opt))) {+    return absl::UnknownError(+        absl::StrCat(""Error setsockopt(SO_REUSEPORT): "", std::strerror(errno)));+  }++  // Forcefully bind the new socket.+  if (bind(server_socket, resolved_addr.address(), resolved_addr.size()) < 0) {+    return absl::UnknownError(+        absl::StrCat(""Error bind: "", std::strerror(errno)));+  }+  // Set the new socket to listen for one active connection at a time.+  // accept() is intentionally not called on the socket. This allows the+  // connection queue to build up.+  if (listen(server_socket, 1) < 0) {+    return absl::UnknownError(+        absl::StrCat(""Error listen: "", std::strerror(errno)));+  }+  ret_sockets.push_back(server_socket);+  // Create and connect client sockets until the connection attempt times out.+  // Even if the backlog specified to listen is 1, the kernel continues to+  // accept a certain number of SYN packets before dropping them. This loop+  // attempts to identify the number of new connection attempts that will+  // be allowed by the kernel before any subsequent connection attempts+  // become pending indefinitely.+  while (true) {+    client_socket = socket(AF_INET6, SOCK_STREAM, 0);+    setsockopt(client_socket, SOL_SOCKET, SO_REUSEADDR, &one, sizeof(one));+    // Make fd non-blocking.+    flags = fcntl(client_socket, F_GETFL, 0);+    EXPECT_EQ(fcntl(client_socket, F_SETFL, flags | O_NONBLOCK), 0);++    if (connect(client_socket,+                const_cast<struct sockaddr*>(resolved_addr.address()),+                resolved_addr.size()) == -1) {+      if (errno == EINPROGRESS) {+        struct pollfd pfd;+        pfd.fd = client_socket;+        pfd.events = POLLOUT;+        pfd.revents = 0;+        int ret = poll(&pfd, 1, 1000);+        if (ret == -1) {+          gpr_log(GPR_ERROR, ""poll() failed during connect; errno=%d"", errno);+          abort();+        } else if (ret == 0) {+          // current connection attempt timed out. It indicates that the+          // kernel will cause any subsequent connection attempts to+          // become pending indefinitely.+          ret_sockets.push_back(client_socket);+          return ret_sockets;+        }+      } else {+        gpr_log(GPR_ERROR, ""Failed to connect to the server (errno=%d)"", errno);+        abort();+      }+    }+    ret_sockets.push_back(client_socket);+  }+  return ret_sockets;+}++}  // namespace++TEST(PosixEventEngineTest, IndefiniteConnectTimeoutOrRstTest) {+  std::string target_addr = absl::StrCat(+      ""ipv6:[::1]:"", std::to_string(grpc_pick_unused_port_or_die()));+  auto resolved_addr = URIToResolvedAddress(target_addr);+  std::shared_ptr<EventEngine> posix_ee = std::make_shared<PosixEventEngine>();+  std::string resolved_addr_str =+      SockaddrToString(&resolved_addr, true).value();+  auto sockets = CreateConnectedSockets(resolved_addr);+  grpc_core::Notification signal;+  ASSERT_TRUE(sockets.ok());+  grpc_core::ChannelArgs args;+  auto quota = grpc_core::ResourceQuota::Default();+  args = args.Set(GRPC_ARG_RESOURCE_QUOTA, quota);+  ChannelArgsEndpointConfig config(args);+  auto memory_quota = absl::make_unique<grpc_core::MemoryQuota>(""bar"");+  posix_ee->Connect(+      [&signal, &resolved_addr_str](+          absl::StatusOr<std::unique_ptr<EventEngine::Endpoint>> status) {+        ASSERT_FALSE(status.ok());+        absl::Status deadline_exceeded_expected_status =+            absl::CancelledError(absl::StrCat(+                ""Failed to connect to remote host: "", resolved_addr_str,+                "" with error: "",+                absl::DeadlineExceededError(""connect() timed out"").ToString()));+        absl::Status conn_reset_expected_status =+            absl::CancelledError(absl::StrCat(+                ""Failed to connect to remote host: "", resolved_addr_str,+                "" with error: "",+                absl::InternalError(absl::StrCat(""getsockopt(SO_ERROR): "",","InternalError usually implies an implementation problem, which ... I don't think this is. https://github.com/abseil/abseil-cpp/blob/85cc4947dbec515868e47a7e4e2b604b21e333cb/absl/status/status.h#L231-L236. That distinction may become important, so we should probably fix the implementation to ensure it returns something more appropriate, maybe FailedPrecondition.",
5564114,Vignesh2208,https://api.github.com/repos/grpc/grpc/pulls/31074,1002134520,2022-10-21T19:45:17Z,test/core/event_engine/posix/BUILD,"@@ -191,3 +194,26 @@ grpc_cc_test(         ""//test/core/util:grpc_test_util"",     ], )++grpc_cc_test(+    name = ""posix_event_engine_connect_test"",+    srcs = [""posix_event_engine_connect_test.cc""],+    external_deps = [""gtest""],+    language = ""C++"",+    tags = [+        ""no_windows"",+    ],+    uses_event_engine = True,+    uses_polling = True,",Yes the event engine can instantiate both types of pollers. So I think its good to test connection cancellation/timeouts with both pollers,
5564114,Vignesh2208,https://api.github.com/repos/grpc/grpc/pulls/31074,1002178747,2022-10-21T20:52:13Z,test/core/event_engine/posix/posix_event_engine_connect_test.cc,"@@ -0,0 +1,240 @@+// Copyright 2022 gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+#include <errno.h>+#include <fcntl.h>+#include <poll.h>+#include <stdlib.h>+#include <sys/socket.h>+#include <unistd.h>++#include <algorithm>+#include <chrono>+#include <cstring>+#include <memory>+#include <string>+#include <utility>+#include <vector>++#include ""absl/memory/memory.h""+#include ""absl/status/status.h""+#include ""absl/status/statusor.h""+#include ""absl/strings/str_cat.h""+#include ""gtest/gtest.h""++#include <grpc/event_engine/event_engine.h>+#include <grpc/grpc.h>+#include <grpc/support/log.h>++#include ""src/core/lib/channel/channel_args.h""+#include ""src/core/lib/event_engine/channel_args_endpoint_config.h""+#include ""src/core/lib/event_engine/posix_engine/posix_engine.h""+#include ""src/core/lib/event_engine/posix_engine/tcp_socket_utils.h""+#include ""src/core/lib/experiments/experiments.h""+#include ""src/core/lib/gprpp/notification.h""+#include ""src/core/lib/resource_quota/memory_quota.h""+#include ""src/core/lib/resource_quota/resource_quota.h""+#include ""test/core/event_engine/test_suite/event_engine_test_utils.h""+#include ""test/core/util/port.h""+#include ""test/core/util/test_config.h""++namespace grpc_event_engine {+namespace posix_engine {++using ::grpc_event_engine::experimental::ChannelArgsEndpointConfig;+using ::grpc_event_engine::experimental::EventEngine;+using ::grpc_event_engine::experimental::PosixEventEngine;+using ::grpc_event_engine::experimental::URIToResolvedAddress;+using ::grpc_event_engine::experimental::WaitForSingleOwner;+using namespace std::chrono_literals;++namespace {++// Creates a server socket listening for one connection on a specific port. It+// then creates another client socket connected to the server socket. This fills+// up the kernel listen queue on the server socket. Any subsequent attempts to+// connect to the server socket will be pending indefinitely. This can be used+// to test Connection timeouts and cancellation attempts.+absl::StatusOr<std::vector<int>> CreateConnectedSockets(+    EventEngine::ResolvedAddress resolved_addr) {+  int server_socket;+  int opt = -1;+  int client_socket;+  int one = 1;+  int flags;+  std::vector<int> ret_sockets;+  // Creating a new socket file descriptor.+  if ((server_socket = socket(AF_INET6, SOCK_STREAM, 0)) <= 0) {+    return absl::UnknownError(+        absl::StrCat(""Error creating socket: "", std::strerror(errno)));+  }+  // MacOS biulds fail if SO_REUSEADDR and SO_REUSEPORT are set in the same+  // setsockopt syscall. So they are set separately one after the other.+  if (setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt))) {+    return absl::UnknownError(+        absl::StrCat(""Error setsockopt(SO_REUSEADDR): "", std::strerror(errno)));+  }+  if (setsockopt(server_socket, SOL_SOCKET, SO_REUSEPORT, &opt, sizeof(opt))) {+    return absl::UnknownError(+        absl::StrCat(""Error setsockopt(SO_REUSEPORT): "", std::strerror(errno)));+  }++  // Forcefully bind the new socket.+  if (bind(server_socket, resolved_addr.address(), resolved_addr.size()) < 0) {+    return absl::UnknownError(+        absl::StrCat(""Error bind: "", std::strerror(errno)));+  }+  // Set the new socket to listen for one active connection at a time.+  // accept() is intentionally not called on the socket. This allows the+  // connection queue to build up.+  if (listen(server_socket, 1) < 0) {+    return absl::UnknownError(+        absl::StrCat(""Error listen: "", std::strerror(errno)));+  }+  ret_sockets.push_back(server_socket);+  // Create and connect client sockets until the connection attempt times out.+  // Even if the backlog specified to listen is 1, the kernel continues to+  // accept a certain number of SYN packets before dropping them. This loop+  // attempts to identify the number of new connection attempts that will+  // be allowed by the kernel before any subsequent connection attempts+  // become pending indefinitely.+  while (true) {+    client_socket = socket(AF_INET6, SOCK_STREAM, 0);+    setsockopt(client_socket, SOL_SOCKET, SO_REUSEADDR, &one, sizeof(one));+    // Make fd non-blocking.+    flags = fcntl(client_socket, F_GETFL, 0);+    EXPECT_EQ(fcntl(client_socket, F_SETFL, flags | O_NONBLOCK), 0);++    if (connect(client_socket,+                const_cast<struct sockaddr*>(resolved_addr.address()),+                resolved_addr.size()) == -1) {+      if (errno == EINPROGRESS) {+        struct pollfd pfd;+        pfd.fd = client_socket;+        pfd.events = POLLOUT;+        pfd.revents = 0;+        int ret = poll(&pfd, 1, 1000);+        if (ret == -1) {+          gpr_log(GPR_ERROR, ""poll() failed during connect; errno=%d"", errno);+          abort();+        } else if (ret == 0) {+          // current connection attempt timed out. It indicates that the+          // kernel will cause any subsequent connection attempts to+          // become pending indefinitely.+          ret_sockets.push_back(client_socket);+          return ret_sockets;+        }+      } else {+        gpr_log(GPR_ERROR, ""Failed to connect to the server (errno=%d)"", errno);+        abort();+      }+    }+    ret_sockets.push_back(client_socket);+  }+  return ret_sockets;+}++}  // namespace++TEST(PosixEventEngineTest, IndefiniteConnectTimeoutOrRstTest) {+  std::string target_addr = absl::StrCat(+      ""ipv6:[::1]:"", std::to_string(grpc_pick_unused_port_or_die()));+  auto resolved_addr = URIToResolvedAddress(target_addr);+  std::shared_ptr<EventEngine> posix_ee = std::make_shared<PosixEventEngine>();+  std::string resolved_addr_str =+      SockaddrToString(&resolved_addr, true).value();+  auto sockets = CreateConnectedSockets(resolved_addr);+  grpc_core::Notification signal;+  ASSERT_TRUE(sockets.ok());+  grpc_core::ChannelArgs args;+  auto quota = grpc_core::ResourceQuota::Default();+  args = args.Set(GRPC_ARG_RESOURCE_QUOTA, quota);+  ChannelArgsEndpointConfig config(args);+  auto memory_quota = absl::make_unique<grpc_core::MemoryQuota>(""bar"");+  posix_ee->Connect(+      [&signal, &resolved_addr_str](+          absl::StatusOr<std::unique_ptr<EventEngine::Endpoint>> status) {+        ASSERT_FALSE(status.ok());+        absl::Status deadline_exceeded_expected_status =+            absl::CancelledError(absl::StrCat(+                ""Failed to connect to remote host: "", resolved_addr_str,+                "" with error: "",+                absl::DeadlineExceededError(""connect() timed out"").ToString()));+        absl::Status conn_reset_expected_status =+            absl::CancelledError(absl::StrCat(+                ""Failed to connect to remote host: "", resolved_addr_str,+                "" with error: "",+                absl::InternalError(absl::StrCat(""getsockopt(SO_ERROR): "",",Replaced it with FailedPreconditionError,
303201,JamesNK,https://api.github.com/repos/grpc/grpc/pulls/31376,1003130291,2022-10-24T10:07:27Z,src/csharp/Grpc.Core/Channel.cs,"@@ -69,20 +69,28 @@ public Channel(string target, ChannelCredentials credentials, IEnumerable<Channe             EnsureUserAgentChannelOption(this.options);             this.environment = GrpcEnvironment.AddRef(); -            this.completionQueue = this.environment.PickCompletionQueue();-            using (var nativeChannelArgs = ChannelOptions.CreateChannelArgs(this.options.Values))+            try             {-                var nativeCredentials = credentials.ToNativeCredentials();-                if (nativeCredentials != null)-                {-                    this.handle = ChannelSafeHandle.CreateSecure(nativeCredentials, target, nativeChannelArgs);-                }-                else+                this.completionQueue = this.environment.PickCompletionQueue();+                using (var nativeChannelArgs = ChannelOptions.CreateChannelArgs(this.options.Values))                 {-                    this.handle = ChannelSafeHandle.CreateInsecure(target, nativeChannelArgs);+                    var nativeCredentials = credentials.ToNativeCredentials();+                    if (nativeCredentials != null)+                    {+                        this.handle = ChannelSafeHandle.CreateSecure(nativeCredentials, target, nativeChannelArgs);+                    }+                    else+                    {+                        this.handle = ChannelSafeHandle.CreateInsecure(target, nativeChannelArgs);+                    }                 }+                GrpcEnvironment.RegisterChannel(this);+            }+            catch (Exception e)+            {+                Task.Run(async () => await GrpcEnvironment.ReleaseAsync().ConfigureAwait(false));+                throw e;",`throw e` loses the stacktrace of the exception.```suggestion            catch (Exception)            {                Task.Run(async () => await GrpcEnvironment.ReleaseAsync().ConfigureAwait(false));                throw;```,
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/31376,1003139042,2022-10-24T10:17:37Z,src/csharp/Grpc.Core/Channel.cs,"@@ -69,20 +69,28 @@ public Channel(string target, ChannelCredentials credentials, IEnumerable<Channe             EnsureUserAgentChannelOption(this.options);             this.environment = GrpcEnvironment.AddRef(); -            this.completionQueue = this.environment.PickCompletionQueue();-            using (var nativeChannelArgs = ChannelOptions.CreateChannelArgs(this.options.Values))+            try             {-                var nativeCredentials = credentials.ToNativeCredentials();-                if (nativeCredentials != null)-                {-                    this.handle = ChannelSafeHandle.CreateSecure(nativeCredentials, target, nativeChannelArgs);-                }-                else+                this.completionQueue = this.environment.PickCompletionQueue();+                using (var nativeChannelArgs = ChannelOptions.CreateChannelArgs(this.options.Values))                 {-                    this.handle = ChannelSafeHandle.CreateInsecure(target, nativeChannelArgs);+                    var nativeCredentials = credentials.ToNativeCredentials();+                    if (nativeCredentials != null)+                    {+                        this.handle = ChannelSafeHandle.CreateSecure(nativeCredentials, target, nativeChannelArgs);+                    }+                    else+                    {+                        this.handle = ChannelSafeHandle.CreateInsecure(target, nativeChannelArgs);+                    }                 }+                GrpcEnvironment.RegisterChannel(this);+            }+            catch (Exception e)+            {+                Task.Run(async () => await GrpcEnvironment.ReleaseAsync().ConfigureAwait(false));+                throw e;","of course, my bad. thanks for the fix!",
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/31376,1003139854,2022-10-24T10:18:37Z,src/csharp/Grpc.Core/Channel.cs,"@@ -69,20 +69,28 @@ public Channel(string target, ChannelCredentials credentials, IEnumerable<Channe             EnsureUserAgentChannelOption(this.options);             this.environment = GrpcEnvironment.AddRef(); -            this.completionQueue = this.environment.PickCompletionQueue();-            using (var nativeChannelArgs = ChannelOptions.CreateChannelArgs(this.options.Values))+            try             {-                var nativeCredentials = credentials.ToNativeCredentials();-                if (nativeCredentials != null)-                {-                    this.handle = ChannelSafeHandle.CreateSecure(nativeCredentials, target, nativeChannelArgs);-                }-                else+                this.completionQueue = this.environment.PickCompletionQueue();+                using (var nativeChannelArgs = ChannelOptions.CreateChannelArgs(this.options.Values))                 {-                    this.handle = ChannelSafeHandle.CreateInsecure(target, nativeChannelArgs);+                    var nativeCredentials = credentials.ToNativeCredentials();+                    if (nativeCredentials != null)+                    {+                        this.handle = ChannelSafeHandle.CreateSecure(nativeCredentials, target, nativeChannelArgs);+                    }+                    else+                    {+                        this.handle = ChannelSafeHandle.CreateInsecure(target, nativeChannelArgs);+                    }                 }+                GrpcEnvironment.RegisterChannel(this);+            }+            catch (Exception e)+            {+                Task.Run(async () => await GrpcEnvironment.ReleaseAsync().ConfigureAwait(false));","yes, basically. GrpcEnvironment is a singleton with global state of grpc native (and e.g. owns the threadpool).",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/31166,1003664963,2022-10-24T19:17:37Z,src/core/lib/channel/channel_stack.cc,"@@ -117,8 +119,12 @@ grpc_error_handle grpc_channel_stack_init(     }   } +  auto conditioned_channel_args = grpc_core::CoreConfiguration::Get()","I don't think this should be needed.  `grpc_channel_stack_init()` is not a public C-core API, so it should never be called from outside of C-core, except in tests.  That means the caller should already have preconditioned the channel args before `grpc_channel_stack_init()` is called.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/31166,1003665919,2022-10-24T19:18:46Z,test/core/channel/channel_stack_test.cc,"@@ -32,10 +33,14 @@  static grpc_error_handle channel_init_func(grpc_channel_element* elem,                                            grpc_channel_element_args* args) {-  EXPECT_EQ(args->channel_args->num_args, 1);-  EXPECT_EQ(args->channel_args->args[0].type, GRPC_ARG_INTEGER);-  EXPECT_STREQ(args->channel_args->args[0].key, ""test_key"");-  EXPECT_EQ(args->channel_args->args[0].value.integer, 42);+  int test_value = grpc_channel_args_find_integer(args->channel_args,+                                                  ""test_key"", {-1, 0, INT_MAX});+  EXPECT_EQ(test_value, 42);+  // TODO(hork): replace the string with a macro. See TODO in channel_args.h","If we need to use this in tests, I'd be fine with adding such a macro, as long as it's in a file in src instead of in include.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/31166,1003672074,2022-10-24T19:26:44Z,test/core/filters/filter_fuzzer.cc,"@@ -247,7 +248,10 @@ RefCountedPtr<AuthorizationEngine> LoadAuthorizationEngine( template <typename FuzzerChannelArgs> ChannelArgs LoadChannelArgs(const FuzzerChannelArgs& fuzz_args,                             GlobalObjects* globals) {-  ChannelArgs args = ChannelArgs().SetObject(ResourceQuota::Default());+  ChannelArgs args =","Should we just precondition the channel args here?  If these args are going to be passed to a filter, the filter will assume that they've already been preconditioned.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/31166,1003672971,2022-10-24T19:27:42Z,BUILD,"@@ -1759,6 +1759,7 @@ grpc_cc_library(         ""iomgr_timer"",         ""ref_counted_ptr"",         ""//src/core:arena"",+        ""//src/core:channel_args_preconditioning"",","This dependency should not be needed.  Preconditioning should be done inside of C-core, not at the C++ layer.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/31166,1003676062,2022-10-24T19:31:56Z,src/core/lib/channel/channel_args_preconditioning.h,"@@ -53,6 +53,9 @@ class ChannelArgsPreconditioning {   // Returns a new channel args object that is owned by the caller.   ChannelArgs PreconditionChannelArgs(const grpc_channel_args* args) const; +  // Take channel args and precondition them.+  ChannelArgs PreconditionChannelArgs(const ChannelArgs& args) const;","I don't think we should need this override.  The only places where we should be preconditioning channel args are at the C-core API boundary, where the caller passes in C-style args and we return `grpc_core::ChannelArgs`.",
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/31166,1003750778,2022-10-24T20:45:10Z,src/core/lib/channel/channel_stack.cc,"@@ -117,8 +119,12 @@ grpc_error_handle grpc_channel_stack_init(     }   } +  auto conditioned_channel_args = grpc_core::CoreConfiguration::Get()","There are also cases where re create ChannelArgs internally, which need to be preconditioned. Take the ChannelStackBuilder for example - if no ChannelArgs are explicitly set via `SetChannelArgs`, the defaults must be preconditioned before being used in channel_stack_init. It was simpler to do centrally here, where it's required. Otherwise, the call sites for preconditioning get peppered around a lot further (both at the surface and internally where we create channel_args), and we risk A) missing some essential preconditioning, or B) redundant conditioning. Preconditioning at this call site risks (B) as well, but preconditioning is currently fairly inexpensive.",
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/31166,1003753446,2022-10-24T20:47:47Z,src/core/lib/channel/channel_args_preconditioning.h,"@@ -53,6 +53,9 @@ class ChannelArgsPreconditioning {   // Returns a new channel args object that is owned by the caller.   ChannelArgs PreconditionChannelArgs(const grpc_channel_args* args) const; +  // Take channel args and precondition them.+  ChannelArgs PreconditionChannelArgs(const ChannelArgs& args) const;","See my comment above regarding wherever we create ChannelArgs internally. There are exceptions where it's necessary, and I didn't think it would be right to backtrack to using the C-type just for this. ~This gave me an idea, however: We could instead ensure that all ChannelArgs are preconditioned in the constructor.~ This is not going to work, there are too many situations wherein we want non-preconditioned ChannelArgs",
4181124,yashykt,https://api.github.com/repos/grpc/grpc/pulls/31351,1003758953,2022-10-24T20:54:47Z,test/core/xds/xds_listener_resource_type_test.cc,"@@ -0,0 +1,1962 @@+//+// Copyright 2022 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+//++#include <map>+#include <memory>+#include <string>+#include <utility>+#include <vector>++#include <google/protobuf/any.pb.h>+#include <google/protobuf/duration.pb.h>+#include <google/protobuf/wrappers.pb.h>++#include ""absl/status/status.h""+#include ""absl/status/statusor.h""+#include ""absl/strings/str_cat.h""+#include ""absl/strings/string_view.h""+#include ""absl/types/optional.h""+#include ""absl/types/variant.h""+#include ""gmock/gmock.h""+#include ""gtest/gtest.h""+#include ""upb/def.hpp""+#include ""upb/upb.hpp""++#include <grpc/grpc.h>+#include <grpc/support/log.h>++#include ""src/core/ext/xds/xds_bootstrap.h""+#include ""src/core/ext/xds/xds_bootstrap_grpc.h""+#include ""src/core/ext/xds/xds_client.h""+#include ""src/core/ext/xds/xds_common_types.h""+#include ""src/core/ext/xds/xds_http_filters.h""+#include ""src/core/ext/xds/xds_listener.h""+#include ""src/core/ext/xds/xds_resource_type.h""+#include ""src/core/lib/address_utils/sockaddr_utils.h""+#include ""src/core/lib/debug/trace.h""+#include ""src/core/lib/gprpp/ref_counted_ptr.h""+#include ""src/core/lib/gprpp/time.h""+#include ""src/core/lib/iomgr/error.h""+#include ""src/core/lib/json/json.h""+#include ""src/proto/grpc/testing/xds/v3/address.pb.h""+#include ""src/proto/grpc/testing/xds/v3/base.pb.h""+#include ""src/proto/grpc/testing/xds/v3/config_source.pb.h""+#include ""src/proto/grpc/testing/xds/v3/fault.pb.h""+#include ""src/proto/grpc/testing/xds/v3/http_connection_manager.pb.h""+#include ""src/proto/grpc/testing/xds/v3/http_filter_rbac.pb.h""+#include ""src/proto/grpc/testing/xds/v3/listener.pb.h""+#include ""src/proto/grpc/testing/xds/v3/protocol.pb.h""+#include ""src/proto/grpc/testing/xds/v3/router.pb.h""+#include ""src/proto/grpc/testing/xds/v3/string.pb.h""+#include ""src/proto/grpc/testing/xds/v3/tls.pb.h""+#include ""src/proto/grpc/testing/xds/v3/typed_struct.pb.h""+#include ""test/core/util/test_config.h""++using envoy::config::listener::v3::Listener;+using envoy::extensions::filters::http::fault::v3::HTTPFault;+using envoy::extensions::filters::http::rbac::v3::RBAC;+using envoy::extensions::filters::http::router::v3::Router;+using envoy::extensions::filters::network::http_connection_manager::v3::+    HttpConnectionManager;+using envoy::extensions::transport_sockets::tls::v3::DownstreamTlsContext;++namespace grpc_core {+namespace testing {+namespace {++TraceFlag xds_listener_resource_type_test_trace(+    true, ""xds_listener_resource_type_test"");++class XdsListenerTest : public ::testing::Test {+ protected:+  XdsListenerTest()+      : xds_client_(MakeXdsClient()),+        decode_context_{xds_client_.get(), xds_client_->bootstrap().server(),+                        &xds_listener_resource_type_test_trace,+                        upb_def_pool_.ptr(), upb_arena_.ptr()} {}++  static RefCountedPtr<XdsClient> MakeXdsClient() {+    grpc_error_handle error;+    auto bootstrap = GrpcXdsBootstrap::Create(+        ""{\n""+        ""  \""xds_servers\"": [\n""+        ""    {\n""+        ""      \""server_uri\"": \""xds.example.com\"",\n""+        ""      \""channel_creds\"": [\n""+        ""        {\""type\"": \""google_default\""}\n""+        ""      ]\n""+        ""    }\n""+        ""  ],\n""+        ""  \""certificate_providers\"": {\n""+        ""    \""provider1\"": {\n""+        ""      \""plugin_name\"": \""file_watcher\"",\n""+        ""      \""config\"": {\n""+        ""        \""certificate_file\"": \""/path/to/cert\"",\n""+        ""        \""private_key_file\"": \""/path/to/key\""\n""+        ""      }\n""+        ""    }\n""+        ""  }\n""+        ""}"");+    if (!bootstrap.ok()) {+      gpr_log(GPR_ERROR, ""Error parsing bootstrap: %s"",+              bootstrap.status().ToString().c_str());+      GPR_ASSERT(false);+    }+    return MakeRefCounted<XdsClient>(std::move(*bootstrap),+                                     /*transport_factory=*/nullptr);+  }++  RefCountedPtr<XdsClient> xds_client_;+  upb::DefPool upb_def_pool_;+  upb::Arena upb_arena_;+  XdsResourceType::DecodeContext decode_context_;+};++TEST_F(XdsListenerTest, Definition) {+  auto* resource_type = XdsListenerResourceType::Get();+  ASSERT_NE(resource_type, nullptr);+  EXPECT_EQ(resource_type->type_url(), ""envoy.config.listener.v3.Listener"");+  EXPECT_TRUE(resource_type->AllResourcesRequiredInSotW());+}++TEST_F(XdsListenerTest, UnparseableProto) {+  std::string serialized_resource(""\0"", 1);+  auto* resource_type = XdsListenerResourceType::Get();+  auto decode_result =+      resource_type->Decode(decode_context_, serialized_resource);+  EXPECT_EQ(decode_result.resource.status().code(),+            absl::StatusCode::kInvalidArgument);+  EXPECT_EQ(decode_result.resource.status().message(),+            ""Can't parse Listener resource."")+      << decode_result.resource.status();+}++TEST_F(XdsListenerTest, NeitherAddressNotApiListener) {+  Listener listener;+  listener.set_name(""foo"");+  std::string serialized_resource;+  ASSERT_TRUE(listener.SerializeToString(&serialized_resource));+  auto* resource_type = XdsListenerResourceType::Get();+  auto decode_result =+      resource_type->Decode(decode_context_, serialized_resource);+  EXPECT_EQ(decode_result.resource.status().code(),+            absl::StatusCode::kInvalidArgument);+  EXPECT_EQ(decode_result.resource.status().message(),+            ""Listener has neither address nor ApiListener"")+      << decode_result.resource.status();+}++// TODO(roth): Re-enable the following test once+// github.com/istio/istio/issues/38914 is resolved.+TEST_F(XdsListenerTest, DISABLED_BothAddressAndApiListener) {+  Listener listener;+  listener.set_name(""foo"");+  listener.mutable_api_listener();+  listener.mutable_address();+  std::string serialized_resource;+  ASSERT_TRUE(listener.SerializeToString(&serialized_resource));+  auto* resource_type = XdsListenerResourceType::Get();+  auto decode_result =+      resource_type->Decode(decode_context_, serialized_resource);+  EXPECT_EQ(decode_result.resource.status().code(),+            absl::StatusCode::kInvalidArgument);+  EXPECT_EQ(decode_result.resource.status().message(),+            ""Listener has both address and ApiListener"")+      << decode_result.resource.status();+}++//+// HttpConnectionManager tests+//++// These tests cover common behavior for both API listeners and TCP+// listeners, so we run them in both contexts.+class HttpConnectionManagerTest : public XdsListenerTest,+                                  public ::testing::WithParamInterface<bool> {",nit: It might be better to have a class/struct instead of a raw bool,X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/31166,1003791382,2022-10-24T21:36:45Z,src/core/lib/channel/channel_stack.cc,"@@ -117,8 +119,12 @@ grpc_error_handle grpc_channel_stack_init(     }   } +  auto conditioned_channel_args = grpc_core::CoreConfiguration::Get()","In principal, I think this preconditioning should be done where the channel args are created, not where they are used.  How many places do we create new channel args within C-core?We should also consider why we are creating channel args within C-core in the first place.  In principal, there should be very few places where this happens -- it should generally be necessary only when constructing a control-plane channel within C-core, such as the xDS channel, the grpclb channel, or the ALTS channel, and those places should get preconditioning automatically via `grpc_channel_create()`.  If there are other places where we're doing this, I think we should look at each one and decide whether it's actually necessary.For example, do we actually have any cases where we use `ChannelStackBuilder` without calling `SetChannelArgs()`?  If not, maybe we should just change the `ChannelStackBuilder` API to require passing in channel args to its ctor, so that this case goes away.I don't think we want the preconditioning to happen whenever we instantiate a `ChannelArgs` object, because those objects get copied all the time within C-core.",
23140989,ZhenLian,https://api.github.com/repos/grpc/grpc/pulls/31368,1003857513,2022-10-24T23:24:35Z,test/core/end2end/fixtures/h2_tls_common.h,"@@ -238,8 +238,8 @@ inline grpc_channel_credentials* create_tls_channel_credentials( inline grpc_server_credentials* create_tls_server_credentials(     fullstack_secure_fixture_data* ffd) {   grpc_tls_credentials_options* options = grpc_tls_credentials_options_create();-  options->set_min_tls_version(ffd->tls_version);-  options->set_max_tls_version(ffd->tls_version);","The current h2 ssl/tls tests contain a lot of tests with similar code. Taking `h2_ssl_tls12.cc` and `h2_ssl_tls13.cc` for example, most of the code is same, except maybe just one line setting the TLS version.Would you mind updating them so that they can be better structured?You can do this in a separate PR, or combining that in this PR. Thank you!",X
23140989,ZhenLian,https://api.github.com/repos/grpc/grpc/pulls/31368,1003862537,2022-10-24T23:35:44Z,test/cpp/end2end/tls_key_export_test.cc,"@@ -163,6 +163,8 @@ class TlsKeyLoggingEnd2EndTest : public ::testing::TestWithParam<TestScenario> {           GRPC_SSL_REQUEST_AND_REQUIRE_CLIENT_CERTIFICATE_AND_VERIFY);       server_creds_options.watch_identity_key_cert_pairs();       server_creds_options.watch_root_certs();+      server_creds_options.set_min_tls_version(grpc_tls_version::TLS1_2);","This can be a good example of e2e test, but it is testing some other functionality(TLS key exporting).Could you please write another test similar to this one but testing the TLS version setting behavior? You can also move any shared code into a common place, similar to `h2_tls_common.h`",
9566254,apolcyn,https://api.github.com/repos/grpc/grpc/pulls/31443,1003873003,2022-10-24T23:58:10Z,test/cpp/naming/resolver_component_test.cc,"@@ -192,9 +192,9 @@ gpr_timespec TestDeadline(void) {  struct ArgsStruct {   gpr_event ev;-  gpr_atm done_atm;   gpr_mu* mu;","I'd like to do that, but we can't because this `gpr_mu` actually belongs to the pollset, so we'd need to migrate pollset to `grpc_core::Mutex` first.",
9566254,apolcyn,https://api.github.com/repos/grpc/grpc/pulls/31443,1003877531,2022-10-25T00:08:51Z,test/cpp/naming/resolver_component_test.cc,"@@ -656,12 +655,22 @@ TEST(ResolverComponentTest, TestResolvesRelevantRecordsWithConcurrentFdStress) {   std::thread socket_stress_thread(OpenAndCloseSocketsStressLoop, phony_port,                                    &done_ev);   // Run the resolver test-  RunResolvesRelevantRecordsTest(ResultHandler::Create);+  RunResolvesRelevantRecordsTest(ResultHandler::Create,+                                 grpc_core::ChannelArgs());   // Shutdown and join stress thread   gpr_event_set(&done_ev, reinterpret_cast<void*>(1));   socket_stress_thread.join(); } +TEST(ResolverComponentTest, TestDoesntCrashOrHangWith1MsTimeout) {+  // Queries in this test could either complete successfully or time out","Yeah, I think we'd actually need some kind of mocked endpoint to do that. While it would be nice to have a test like that, it's not obvious to me how we could structure something like that, given the way that the c-ares library interacts directly with file descriptors.While the current test doesn't take a deterministic code path, it at least won't flake in a way that yields a false positive. And it's been useful so far (since it quickly surfaced this bug while I was trying to repro the separate issue of https://github.com/grpc/grpc/pull/31426, I think it's giving some previously-missing but important coverage).",
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/31166,1003928864,2022-10-25T02:12:08Z,src/core/lib/channel/channel_stack.cc,"@@ -117,8 +119,12 @@ grpc_error_handle grpc_channel_stack_init(     }   } +  auto conditioned_channel_args = grpc_core::CoreConfiguration::Get()","> How many places do we create new channel args within C-core?To begin with, I count around 30 default-constructed ChannelArgs class members within src/core. I haven't gone through to see how many get overwritten, or could otherwise be accessed before being overwritten - LB policies and client channel resolvers make up about a third of the set. I'll take a deeper look here.I did the experiment you suggested with ChannelStackBuilder, indeed we can add a ChannelArgs argument to the constructor, and all PR tests pass. So we may be safe with that change alone.> I don't think we want the preconditioning to happen whenever we instantiate a ChannelArgs object, because those objects get copied all the time within C-core.... and we'd be adding a dependency cycle between core config and channel args, as well as making making channel args fragments more expensive (as used in resolvers). It was a thought, but wouldn't pan out right now.",
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/31166,1003930634,2022-10-25T02:15:44Z,src/core/lib/channel/channel_args_preconditioning.h,"@@ -53,6 +53,9 @@ class ChannelArgsPreconditioning {   // Returns a new channel args object that is owned by the caller.   ChannelArgs PreconditionChannelArgs(const grpc_channel_args* args) const; +  // Take channel args and precondition them.+  ChannelArgs PreconditionChannelArgs(const ChannelArgs& args) const;","I removed this overload. I have a hunch we may still need it, but I was able to remove the need for it in this PR. Barring discovery that any internally-created ChannelArgs need preconditioning, I think it can stay gone.",
9566254,apolcyn,https://api.github.com/repos/grpc/grpc/pulls/31443,1004805719,2022-10-25T17:53:15Z,test/cpp/naming/resolver_component_test.cc,"@@ -656,12 +655,22 @@ TEST(ResolverComponentTest, TestResolvesRelevantRecordsWithConcurrentFdStress) {   std::thread socket_stress_thread(OpenAndCloseSocketsStressLoop, phony_port,                                    &done_ev);   // Run the resolver test-  RunResolvesRelevantRecordsTest(ResultHandler::Create);+  RunResolvesRelevantRecordsTest(ResultHandler::Create,+                                 grpc_core::ChannelArgs());   // Shutdown and join stress thread   gpr_event_set(&done_ev, reinterpret_cast<void*>(1));   socket_stress_thread.join(); } +TEST(ResolverComponentTest, TestDoesntCrashOrHangWith1MsTimeout) {+  // Queries in this test could either complete successfully or time out","> Maybe what we need is a fake c-ares implementation. We could implement an interface that wraps around c-ares and have the DNS resolver code use c-ares via that interface.Perhaps. But IMO this code pretty tightly coupled to the behavior of the c-ares library, and I think most of the meat of this code is about properly handling the behavior of the c-ares library. So I'd be weary of mocking at the c-ares API layer for the risk that we'd just end up testing our mock.While I'm not really sure how to do it at the moment, I'd still be a lot more excited about something that mocked out only the ""untrusted"" parts of the code, e.g. timing and the bytes received off the wire.",
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/31166,1004806659,2022-10-25T17:54:19Z,src/core/lib/channel/channel_stack_builder.h,"@@ -63,6 +64,7 @@ class ChannelStackBuilder {   grpc_transport* transport() const { return transport_; }    // Set channel args.+  // args *must be* preconditioned already.   ChannelStackBuilder& SetChannelArgs(const ChannelArgs& args);","It was used in one place, but I was able to refactor that usage away without much extra spaghettification.",X
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/30467,1004823198,2022-10-25T18:13:29Z,src/core/ext/filters/rbac/rbac_service_config_parser.cc,"@@ -18,587 +18,657 @@  #include ""src/core/ext/filters/rbac/rbac_service_config_parser.h"" -#include <stdint.h>-+#include <cstdint> #include <map> #include <string>  #include ""absl/status/status.h"" #include ""absl/status/statusor.h""-#include ""absl/strings/str_cat.h""-#include ""absl/strings/str_format.h"" #include ""absl/types/optional.h""  #include ""src/core/lib/channel/channel_args.h""-#include ""src/core/lib/gprpp/status_helper.h""-#include ""src/core/lib/iomgr/error.h""-#include ""src/core/lib/json/json_util.h""+#include ""src/core/lib/json/json_args.h""+#include ""src/core/lib/json/json_object_loader.h"" #include ""src/core/lib/matchers/matchers.h""-#include ""src/core/lib/transport/error_utils.h""  namespace grpc_core {  namespace { -std::string ParseRegexMatcher(const Json::Object& regex_matcher_json,-                              std::vector<grpc_error_handle>* error_list) {-  std::string regex;-  ParseJsonObjectField(regex_matcher_json, ""regex"", &regex, error_list);-  return regex;-}+struct RbacConfig {+  struct RbacPolicy {+    struct Rules {+      struct Policy {+        struct CidrRange {","The deep nesting of these structs makes it hard to reason about this code without tooling (to answer the 'where the heck am I' question)Suggest either:1. flattening the structure (pulling the inner structs up to the top level namespace and giving them longer names)or2. moving all methods out-of-line below the structure definitions, so that the overall structure can be grokked on ~1 page of code, and the methods carry location information (in the form of `RbacConfig::RbacPolicy::Rules::Policy::CidrRange::JsonLoader()` for instance)",
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/31409,1004885012,2022-10-25T19:27:29Z,BUILDING.md,"@@ -160,17 +189,25 @@ installed to be able to compile the C/C++ sources. > cmake --build . ``` -Using gRPC C++ as a DLL is not recommended, but you can still enable it by running `cmake` with `-DBUILD_SHARED_LIBS=ON`.+### Windows Build Notes  -### Windows: A note on building shared libs (DLLs)+**Building shared libs (DLLs)** -Windows DLL build is supported at a ""best effort"" basis and we don't recommend using gRPC C++ as a DLL as there are some known drawbacks around how C++ DLLs work on Windows. For example, there is no stable C++ ABI and you can't safely allocate memory in one DLL, and free it in another etc.+> **Warning**+> Using gRPC C++ as a DLL is not recommended, but you can still enable it by running `cmake` with `-DBUILD_SHARED_LIBS=ON`. ++Windows DLL build is supported on a ""best effort"" basis and we don't recommend using gRPC C++ as a DLL as there are some known drawbacks around how C++ DLLs work on Windows. For example, there is no stable C++ ABI and you can't safely allocate memory in one DLL, and free it in another etc.  That said, we don't actively prohibit building DLLs on windows (it can be enabled in cmake with `-DBUILD_SHARED_LIBS=ON`), and are free to use the DLL builds at your own risk. - you've been warned that there are some important drawbacks and some things might not work at all or will be broken in interesting ways. - we don't have extensive testing for DLL builds in place (to avoid maintenance costs, increased test duration etc.) so regressions / build breakages might occur ++**Debug/Release Installs**++There are both Debug and Release builds and their respective installs differ slightly (e.g. debug/release verions of libs). If you want a 'complete' install that includes both Debug and Release artefacts, then you'll need to perform two builds to separate install target-locations and then merge the differences. ",Isn't this general Visual Studio usage? I'm not sure this belongs here.,
5564114,Vignesh2208,https://api.github.com/repos/grpc/grpc/pulls/31404,1005168826,2022-10-26T03:09:29Z,src/core/ext/transport/chttp2/transport/chttp2_transport.cc,"@@ -341,51 +345,67 @@ static void read_channel_args(grpc_chttp2_transport* t,     int min;     int max;     bool availability[2] /* server, client */;-  } settings_map[] = {{GRPC_ARG_MAX_CONCURRENT_STREAMS,-                       GRPC_CHTTP2_SETTINGS_MAX_CONCURRENT_STREAMS,-                       -1,-                       0,-                       INT32_MAX,-                       {true, false}},-                      {GRPC_ARG_HTTP2_HPACK_TABLE_SIZE_DECODER,-                       GRPC_CHTTP2_SETTINGS_HEADER_TABLE_SIZE,-                       -1,-                       0,-                       INT32_MAX,-                       {true, true}},-                      {GRPC_ARG_MAX_METADATA_SIZE,-                       GRPC_CHTTP2_SETTINGS_MAX_HEADER_LIST_SIZE,-                       -1,-                       0,-                       INT32_MAX,-                       {true, true}},-                      {GRPC_ARG_HTTP2_MAX_FRAME_SIZE,-                       GRPC_CHTTP2_SETTINGS_MAX_FRAME_SIZE,-                       -1,-                       16384,-                       16777215,-                       {true, true}},-                      {GRPC_ARG_HTTP2_ENABLE_TRUE_BINARY,-                       GRPC_CHTTP2_SETTINGS_GRPC_ALLOW_TRUE_BINARY_METADATA,-                       1,-                       0,-                       1,-                       {true, true}},-                      {GRPC_ARG_HTTP2_STREAM_LOOKAHEAD_BYTES,-                       GRPC_CHTTP2_SETTINGS_INITIAL_WINDOW_SIZE,-                       -1,-                       5,-                       INT32_MAX,-                       {true, true}}};+  } settings_map[] = {+      {GRPC_ARG_MAX_CONCURRENT_STREAMS,+       GRPC_CHTTP2_SETTINGS_MAX_CONCURRENT_STREAMS,+       -1,+       0,+       INT32_MAX,+       {true, false}},+      {GRPC_ARG_HTTP2_HPACK_TABLE_SIZE_DECODER,+       GRPC_CHTTP2_SETTINGS_HEADER_TABLE_SIZE,+       -1,+       0,+       INT32_MAX,+       {true, true}},+      {GRPC_ARG_MAX_METADATA_SIZE,+       GRPC_CHTTP2_SETTINGS_MAX_HEADER_LIST_SIZE,+       -1,+       0,+       INT32_MAX,+       {true, true}},+      {GRPC_ARG_HTTP2_MAX_FRAME_SIZE,+       GRPC_CHTTP2_SETTINGS_MAX_FRAME_SIZE,+       -1,+       16384,+       16777215,+       {true, true}},+      {GRPC_ARG_HTTP2_ENABLE_TRUE_BINARY,+       GRPC_CHTTP2_SETTINGS_GRPC_ALLOW_TRUE_BINARY_METADATA,+       1,+       0,+       1,+       {true, true}},+      {GRPC_ARG_HTTP2_STREAM_LOOKAHEAD_BYTES,+       GRPC_CHTTP2_SETTINGS_INITIAL_WINDOW_SIZE,+       -1,+       5,+       INT32_MAX,+       {true, true}},+      {GRPC_ARG_EXPERIMENTAL_HTTP2_PREFERRED_CRYPTO_FRAME_SIZE,","I made some updates:* converted channel arg GRPC_ARG_EXPERIMENTAL_HTTP2_PREFERRED_CRYPTO_FRAME_SIZE to bool. If set to true, it sends a preferred crypto frame size value of INT_MAX at connection startup.* I think the peer_state_based_framing experiment is no longer required so I removed its uses in the chttp2_transport.cc file. I didn't remove the experiment itself but I think that can be done in the next PR. I updated the comments in the code so hopefully that would explain why I think this experiment is no longer needed.",
2521520,donnachaforde,https://api.github.com/repos/grpc/grpc/pulls/31409,1005504514,2022-10-26T10:26:19Z,BUILDING.md,"@@ -253,14 +292,21 @@ can be made about any sort of ABI stability across the same SONAME version.  ## Building with make on UNIX systems (deprecated) -NOTE: `make` used to be gRPC's default build system, but we're no longer recommending it. You should use `bazel` or `cmake` instead. The `Makefile` is only intended for internal usage and is not meant for public consumption.+> **Warning**+> Building gRPC using `make` is no longer recommended. ","Okay. I will revert the text but will ensure the 'Note' format is kept consistent. FWIW, I figured the note was really trying to make both points. Perhaps that section should be looked at again as it's marked as 'deprecated'. ",
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/31409,1005585722,2022-10-26T12:00:24Z,BUILDING.md,"@@ -160,17 +189,25 @@ installed to be able to compile the C/C++ sources. > cmake --build . ``` -Using gRPC C++ as a DLL is not recommended, but you can still enable it by running `cmake` with `-DBUILD_SHARED_LIBS=ON`.+### Windows Build Notes  -### Windows: A note on building shared libs (DLLs)+**Building shared libs (DLLs)** -Windows DLL build is supported at a ""best effort"" basis and we don't recommend using gRPC C++ as a DLL as there are some known drawbacks around how C++ DLLs work on Windows. For example, there is no stable C++ ABI and you can't safely allocate memory in one DLL, and free it in another etc.+> **Warning**+> Using gRPC C++ as a DLL is not recommended, but you can still enable it by running `cmake` with `-DBUILD_SHARED_LIBS=ON`. ++Windows DLL build is supported on a ""best effort"" basis and we don't recommend using gRPC C++ as a DLL as there are some known drawbacks around how C++ DLLs work on Windows. For example, there is no stable C++ ABI and you can't safely allocate memory in one DLL, and free it in another etc.  That said, we don't actively prohibit building DLLs on windows (it can be enabled in cmake with `-DBUILD_SHARED_LIBS=ON`), and are free to use the DLL builds at your own risk. - you've been warned that there are some important drawbacks and some things might not work at all or will be broken in interesting ways. - we don't have extensive testing for DLL builds in place (to avoid maintenance costs, increased test duration etc.) so regressions / build breakages might occur ++**Debug/Release Installs**++There are both Debug and Release builds and their respective installs differ slightly (e.g. debug/release verions of libs). If you want a 'complete' install that includes both Debug and Release artefacts, then you'll need to perform two builds to separate install target-locations and then merge the differences. ","I also don't see the usefulness of this section. Generally, we are trying to keep the docs as short as possible which containing the most important information (that's good for both maintainability and readability). TBH, I don't see why I would ever install both debug and opt version of the library and I even don't see how to build both at the same time.",
7221003,rockspore,https://api.github.com/repos/grpc/grpc/pulls/31368,1005852085,2022-10-26T15:38:53Z,test/cpp/end2end/tls_key_export_test.cc,"@@ -163,6 +163,8 @@ class TlsKeyLoggingEnd2EndTest : public ::testing::TestWithParam<TestScenario> {           GRPC_SSL_REQUEST_AND_REQUIRE_CLIENT_CERTIFICATE_AND_VERIFY);       server_creds_options.watch_identity_key_cert_pairs();       server_creds_options.watch_root_certs();+      server_creds_options.set_min_tls_version(grpc_tls_version::TLS1_2);","I looked at several tests in this directory, it seems all tests construct their fixture classes independently. I followed the `grpc_auth_...` test and created a new `tls_creds_options_test.cc`. More tests could be added but for the purpose of this PR I put the tls version tests only. Let me know what you think.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/31431,1005897381,2022-10-26T16:20:18Z,src/core/lib/channel/promise_based_filter.h,"@@ -263,6 +269,92 @@ class BaseCallData : public Activity, private Wakeable {     return p.release();   } +  class SendMessage {","Please add a comment explaining what these two classes are, in particular the fact that the reason they are split into their own classes is so that we don't need to allocate their state for filters that are not intercepting send or recv messages.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/31431,1005899126,2022-10-26T16:21:45Z,src/core/lib/channel/promise_based_filter.h,"@@ -263,6 +269,92 @@ class BaseCallData : public Activity, private Wakeable {     return p.release();   } +  class SendMessage {+   public:+    explicit SendMessage(BaseCallData* base)+        : base_(base), pipe_(base->arena()) {}+    PipeReceiver<MessageHandle>* outgoing_pipe() { return &pipe_.receiver; }++    void StartOp(CapturedBatch batch);+    void GotPipe(PipeReceiver<MessageHandle>* receiver);+    void WakeInsideCombiner(Flusher* flusher);+    void Done(const ServerMetadata& metadata);+    bool HaveCapturedBatch() const { return batch_.is_captured(); }+    bool IsIdle() const;++   private:+    enum class State : uint8_t {+      kInitial,+      kIdle,+      kGotBatchNoPipe,+      kGotBatch,+      kPushedToPipe,+      kForwardedBatch,+      kBatchCompleted,+      kCancelled,+    };+    static const char* StateString(State);++    void OnComplete(absl::Status status);++    BaseCallData* const base_;+    State state_ = State::kInitial;+    Pipe<MessageHandle> pipe_;+    PipeReceiver<MessageHandle>* receiver_ = nullptr;+    absl::optional<PipeSender<MessageHandle>::PushType> push_;+    absl::optional<PipeReceiver<MessageHandle>::NextType> next_;+    absl::optional<NextResult<MessageHandle>> next_result_;+    CapturedBatch batch_;+    grpc_closure* intercepted_on_complete_;+    grpc_closure on_complete_ =+        MakeMemberClosure<SendMessage, &SendMessage::OnComplete>(this);+    absl::Status completed_status_;+  };++  class ReceiveMessage {",Same comments here as for the `SendMessage` class above.,
7221003,rockspore,https://api.github.com/repos/grpc/grpc/pulls/31368,1006138602,2022-10-26T20:08:25Z,test/core/end2end/fixtures/h2_tls_common.h,"@@ -238,8 +238,8 @@ inline grpc_channel_credentials* create_tls_channel_credentials( inline grpc_server_credentials* create_tls_server_credentials(     fullstack_secure_fixture_data* ffd) {   grpc_tls_credentials_options* options = grpc_tls_credentials_options_create();-  options->set_min_tls_version(ffd->tls_version);-  options->set_max_tls_version(ffd->tls_version);","By taking a closer look at all the fixtures, it seems to me that they fall into different categories, and code is largely duplicated within each of them. For example, the `h2_sockpair...` is one of them. My guess is they are intentionally broken into different test binaries so that they can be executed in parallel. This makes me wonder if a merge of tls12 and tls13 is needed. Let me know what you think. Thanks.",X
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/31435,1006299470,2022-10-27T00:40:15Z,src/core/lib/event_engine/posix_engine/posix_engine_listener_utils.cc,"@@ -0,0 +1,384 @@+// Copyright 2022 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++#include <grpc/support/port_platform.h>++#include ""src/core/lib/event_engine/posix_engine/posix_engine_listener_utils.h""++#include <limits.h>+#include <stdio.h>+#include <stdlib.h>+#include <unistd.h>++#include <cstring>+#include <string>++#include ""absl/cleanup/cleanup.h""+#include ""absl/status/status.h""++#include <grpc/support/log.h>++#include ""src/core/lib/event_engine/posix_engine/tcp_socket_utils.h""+#include ""src/core/lib/gprpp/status_helper.h""+#include ""src/core/lib/iomgr/port.h""+#include ""src/core/lib/iomgr/socket_mutator.h""++#define MIN_SAFE_ACCEPT_QUEUE_SIZE 100++#ifdef GRPC_POSIX_SOCKET_UTILS_COMMON+#include <errno.h>       // IWYU pragma: keep+#include <ifaddrs.h>     // IWYU pragma: keep+#include <netinet/in.h>  // IWYU pragma: keep+#include <sys/socket.h>  // IWYU pragma: keep++#include ""absl/strings/str_cat.h""+#endif++namespace grpc_event_engine {+namespace posix_engine {++#ifdef GRPC_POSIX_SOCKET_UTILS_COMMON++namespace {++using ResolvedAddress =+    grpc_event_engine::experimental::EventEngine::ResolvedAddress;+using ListenerSocket = ListenerSocketsContainer::ListenerSocket;++#ifdef GRPC_HAVE_IFADDRS++// Bind to ""::"" to get a port number not used by any address.+absl::StatusOr<int> GetUnusedPort() {+  ResolvedAddress wild = SockaddrMakeWild6(0);+  PosixSocketWrapper::DSMode dsmode;+  auto sock = PosixSocketWrapper::CreateDualStackSocket(nullptr, wild,+                                                        SOCK_STREAM, 0, dsmode);+  if (!sock.ok()) {+    return sock.status();+  }+  if (dsmode == PosixSocketWrapper::DSMode::DSMODE_IPV4) {+    wild = SockaddrMakeWild4(0);+  }+  if (bind(sock->Fd(), wild.address(), wild.size()) != 0) {+    close(sock->Fd());+    return absl::InternalError(",Is `InternalError` right here? Failure to bind may be better indicated by `FailedPrecondition` or even `Aborted`. What do the other implementations do here?,
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/31435,1006303175,2022-10-27T00:44:47Z,src/core/lib/event_engine/posix_engine/posix_engine_listener_utils.cc,"@@ -0,0 +1,384 @@+// Copyright 2022 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++#include <grpc/support/port_platform.h>++#include ""src/core/lib/event_engine/posix_engine/posix_engine_listener_utils.h""++#include <limits.h>+#include <stdio.h>+#include <stdlib.h>+#include <unistd.h>++#include <cstring>+#include <string>++#include ""absl/cleanup/cleanup.h""+#include ""absl/status/status.h""++#include <grpc/support/log.h>++#include ""src/core/lib/event_engine/posix_engine/tcp_socket_utils.h""+#include ""src/core/lib/gprpp/status_helper.h""+#include ""src/core/lib/iomgr/port.h""+#include ""src/core/lib/iomgr/socket_mutator.h""++#define MIN_SAFE_ACCEPT_QUEUE_SIZE 100++#ifdef GRPC_POSIX_SOCKET_UTILS_COMMON+#include <errno.h>       // IWYU pragma: keep+#include <ifaddrs.h>     // IWYU pragma: keep+#include <netinet/in.h>  // IWYU pragma: keep+#include <sys/socket.h>  // IWYU pragma: keep++#include ""absl/strings/str_cat.h""+#endif++namespace grpc_event_engine {+namespace posix_engine {++#ifdef GRPC_POSIX_SOCKET_UTILS_COMMON++namespace {++using ResolvedAddress =+    grpc_event_engine::experimental::EventEngine::ResolvedAddress;+using ListenerSocket = ListenerSocketsContainer::ListenerSocket;++#ifdef GRPC_HAVE_IFADDRS++// Bind to ""::"" to get a port number not used by any address.+absl::StatusOr<int> GetUnusedPort() {+  ResolvedAddress wild = SockaddrMakeWild6(0);+  PosixSocketWrapper::DSMode dsmode;+  auto sock = PosixSocketWrapper::CreateDualStackSocket(nullptr, wild,+                                                        SOCK_STREAM, 0, dsmode);+  if (!sock.ok()) {+    return sock.status();+  }+  if (dsmode == PosixSocketWrapper::DSMode::DSMODE_IPV4) {+    wild = SockaddrMakeWild4(0);+  }+  if (bind(sock->Fd(), wild.address(), wild.size()) != 0) {+    close(sock->Fd());+    return absl::InternalError(+        absl::StrCat(""bind(GetUnusedPort): "", std::strerror(errno)));+  }+  socklen_t len = wild.size();+  if (getsockname(sock->Fd(), const_cast<sockaddr*>(wild.address()), &len) !=+      0) {+    close(sock->Fd());+    return absl::InternalError(+        absl::StrCat(""getsockname(GetUnusedPort): "", std::strerror(errno)));+  }+  close(sock->Fd());+  int port = SockaddrGetPort(wild);+  if (port <= 0) {+    return absl::InternalError(""Bad port"");+  }+  return port;+}++bool SystemHasIfAddrs() { return true; }++#else  // GRPC_HAVE_IFADDRS++bool SystemHasIfAddrs() { return false; }++#endif  // GRPC_HAVE_IFADDRS++// get max listen queue size on linux+int InitMaxAcceptQueueSize() {+  int n = SOMAXCONN;+  char buf[64];+  FILE* fp = fopen(""/proc/sys/net/core/somaxconn"", ""r"");+  int max_accept_queue_size;+  if (fp == nullptr) {+    // 2.4 kernel.+    return SOMAXCONN;+  }+  if (fgets(buf, sizeof buf, fp)) {+    char* end;+    long i = strtol(buf, &end, 10);+    if (i > 0 && i <= INT_MAX && end && *end == '\n') {+      n = static_cast<int>(i);+    }+  }+  fclose(fp);+  max_accept_queue_size = n;++  if (max_accept_queue_size < MIN_SAFE_ACCEPT_QUEUE_SIZE) {+    gpr_log(GPR_INFO,+            ""Suspiciously small accept queue (%d) will probably lead to ""+            ""connection drops"",+            max_accept_queue_size);+  }+  return max_accept_queue_size;+}++int GetMaxAcceptQueueSize() {+  static const int kMaxAcceptQueueSize = InitMaxAcceptQueueSize();+  return kMaxAcceptQueueSize;+}++// Prepare a recently-created socket for listening.+absl::Status PrepareSocket(const PosixTcpOptions& options,+                           ListenerSocket& socket) {+  ResolvedAddress sockname_temp;+  absl::Status error;+  int fd = socket.sock.Fd();+  GPR_ASSERT(fd >= 0);+  bool close_fd = true;+  socket.zero_copy_enabled = false;+  socket.port = 0;+  auto sock_cleanup = absl::MakeCleanup([&close_fd, fd]() -> void {+    if (close_fd && fd >= 0) {+      close(fd);+    }+  });+  if (PosixSocketWrapper::IsSocketReusePortSupported() &&+      options.allow_reuse_port && socket.addr.address()->sa_family != AF_UNIX) {+    GRPC_RETURN_IF_ERROR(socket.sock.SetSocketReusePort(1));+  }++#ifdef GRPC_LINUX_ERRQUEUE+  if (!socket.sock.SetSocketZeroCopy().ok()) {+    // it's not fatal, so just log it.+    gpr_log(GPR_DEBUG, ""Node does not support SO_ZEROCOPY, continuing."");+  } else {+    socket.zero_copy_enabled = true;+  }+#endif++  GRPC_RETURN_IF_ERROR(socket.sock.SetSocketNonBlocking(1));+  GRPC_RETURN_IF_ERROR(socket.sock.SetSocketCloexec(1));++  if (socket.addr.address()->sa_family != AF_UNIX) {+    GRPC_RETURN_IF_ERROR(socket.sock.SetSocketLowLatency(1));+    GRPC_RETURN_IF_ERROR(socket.sock.SetSocketReuseAddr(1));+    socket.sock.TrySetSocketTcpUserTimeout(options, false);+  }+  GRPC_RETURN_IF_ERROR(socket.sock.SetSocketNoSigpipeIfPossible());+  GRPC_RETURN_IF_ERROR(socket.sock.ApplySocketMutatorInOptions(+      GRPC_FD_SERVER_LISTENER_USAGE, options));++  if (bind(fd, socket.addr.address(), socket.addr.size()) < 0) {+    return absl::InternalError(",same thought regarding InternalError for a bind failure. I'll not comment on them further. The error type descriptions are outlined here: https://github.com/abseil/abseil-cpp/blob/bc097314fe5ba91e7f358159f84d7b9477502f75/absl/status/status.h#L231,
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/31435,1006307662,2022-10-27T00:56:58Z,src/core/lib/event_engine/posix_engine/tcp_socket_utils.cc,"@@ -354,6 +356,121 @@ absl::StatusOr<std::string> SockaddrToString(   return out; } +EventEngine::ResolvedAddress SockaddrMakeWild6(int port) {+  EventEngine::ResolvedAddress resolved_wild_out;+  sockaddr_in6* wild_out = reinterpret_cast<sockaddr_in6*>(+      const_cast<sockaddr*>(resolved_wild_out.address()));+  GPR_ASSERT(port >= 0 && port < 65536);+  memset(wild_out, 0, sizeof(sockaddr_in6));+  wild_out->sin6_family = AF_INET6;+  wild_out->sin6_port = htons(static_cast<uint16_t>(port));+  return EventEngine::ResolvedAddress(+      reinterpret_cast<sockaddr*>(wild_out),+      static_cast<socklen_t>(sizeof(sockaddr_in6)));+}++EventEngine::ResolvedAddress SockaddrMakeWild4(int port) {+  EventEngine::ResolvedAddress resolved_wild_out;+  sockaddr_in* wild_out = reinterpret_cast<sockaddr_in*>(+      const_cast<sockaddr*>(resolved_wild_out.address()));+  GPR_ASSERT(port >= 0 && port < 65536);+  memset(wild_out, 0, sizeof(sockaddr_in));+  wild_out->sin_family = AF_INET;+  wild_out->sin_port = htons(static_cast<uint16_t>(port));+  return EventEngine::ResolvedAddress(+      reinterpret_cast<sockaddr*>(wild_out),+      static_cast<socklen_t>(sizeof(sockaddr_in)));+}++int SockaddrGetPort(const EventEngine::ResolvedAddress& resolved_addr) {+  const sockaddr* addr = resolved_addr.address();+  switch (addr->sa_family) {+    case AF_INET:+      return ntohs((reinterpret_cast<const sockaddr_in*>(addr))->sin_port);+    case AF_INET6:+      return ntohs((reinterpret_cast<const sockaddr_in6*>(addr))->sin6_port);+#ifdef GRPC_HAVE_UNIX_SOCKET+    case AF_UNIX:+      return 1;+#endif+    default:+      gpr_log(GPR_ERROR, ""Unknown socket family %d in SockaddrGetPort"",+              addr->sa_family);+      return 0;+  }+}++bool SockaddrSetPort(EventEngine::ResolvedAddress& resolved_addr, int port) {+  sockaddr* addr = const_cast<sockaddr*>(resolved_addr.address());+  switch (addr->sa_family) {+    case AF_INET:+      GPR_ASSERT(port >= 0 && port < 65536);+      (reinterpret_cast<sockaddr_in*>(addr))->sin_port =+          htons(static_cast<uint16_t>(port));+      return true;+    case AF_INET6:+      GPR_ASSERT(port >= 0 && port < 65536);+      (reinterpret_cast<sockaddr_in6*>(addr))->sin6_port =+          htons(static_cast<uint16_t>(port));+      return true;+    default:+      gpr_log(GPR_ERROR, ""Unknown socket family %d in grpc_sockaddr_set_port"",+              addr->sa_family);+      return false;+  }+}++void UnlinkIfUnixDomainSocket(+    const EventEngine::ResolvedAddress& resolved_addr) {","Seems that if `GRPC_HAVE_UNIX_SOCKET` is undefined, the `resolved_addr` argument will be unused, which will fail the build. Suggest:```#else(void)resolved_address;#endif```But I'd also be curious to see when (if ever) this file is compiled with `GRPC_HAVE_UNIX_SOCKET` undefined.",
2521520,donnachaforde,https://api.github.com/repos/grpc/grpc/pulls/31409,1007958962,2022-10-28T11:25:28Z,BUILDING.md,"@@ -129,22 +130,50 @@ $ make  If you want to build shared libraries (`.so` files), run `cmake` with `-DBUILD_SHARED_LIBS=ON`. -### Windows, Using Visual Studio 2015 or 2017++### Windows, Using CMake  When using the ""Visual Studio"" generator, cmake will generate a solution (`grpc.sln`) that contains a VS project for-every target defined in `CMakeLists.txt` (+ a few extra convenience projects+every target defined in `CMakeLists.txt` (plus a few extra convenience projects added automatically by cmake). After opening the solution with Visual Studio you will be able to browse and build the code.++> **Note**+> A Visual C++ compiler is needed when building using CMake directly, which you specify as a [cmake-generator](https://cmake.org/cmake/help/latest/manual/cmake-generators.7.html#manual:cmake-generators(7)) option.+ ``` > @rem Run from grpc directory after cloning the repo with --recursive or updating submodules. > md .build > cd .build > cmake .. -G ""Visual Studio 14 2015"" > cmake --build . --config Release ```+> **Note** If you need to figure our our Visual Studio version, Wikipedia details the [mapping between Visual Studio product name and version number](https://en.wikipedia.org/wiki/Microsoft_Visual_Studio) in the 'History' section (e.g. Visual Studio 2022 == Version 17.0).++### Windows, Using Visual Studio","Yeah, the code block describing the steps at the cmd-line are quite similar so that can be shorted to just highlight the difference. I copied the code block for consistency but happy to modify.The reasons why I put it in its own section are:- The **Windows, Using CMake** section is really for command-line enthusiasts and many VC++ developers will have a natural preference to build inside Visual Studio. - I figured there really should be instructions for a Windows build that cross-referenced the [gRPC Quick start](https://grpc.io/docs/languages/cpp/quickstart) page. VC++ developers are going to find their way to this page because it doesn't include instructions for Windows.- It was more in keeping with the existing layout with there being a separate section covering  **Windows, Using Ninja**.Ultimately, it seems you can build on Windows using CMake, Visual Studio or using Ninja. All three use CMake. ",
5564114,Vignesh2208,https://api.github.com/repos/grpc/grpc/pulls/31435,1008445470,2022-10-28T20:28:23Z,src/core/lib/event_engine/posix_engine/posix_engine_listener_utils.cc,"@@ -0,0 +1,384 @@+// Copyright 2022 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++#include <grpc/support/port_platform.h>++#include ""src/core/lib/event_engine/posix_engine/posix_engine_listener_utils.h""++#include <limits.h>+#include <stdio.h>+#include <stdlib.h>+#include <unistd.h>++#include <cstring>+#include <string>++#include ""absl/cleanup/cleanup.h""+#include ""absl/status/status.h""++#include <grpc/support/log.h>++#include ""src/core/lib/event_engine/posix_engine/tcp_socket_utils.h""+#include ""src/core/lib/gprpp/status_helper.h""+#include ""src/core/lib/iomgr/port.h""+#include ""src/core/lib/iomgr/socket_mutator.h""++#define MIN_SAFE_ACCEPT_QUEUE_SIZE 100++#ifdef GRPC_POSIX_SOCKET_UTILS_COMMON+#include <errno.h>       // IWYU pragma: keep+#include <ifaddrs.h>     // IWYU pragma: keep+#include <netinet/in.h>  // IWYU pragma: keep+#include <sys/socket.h>  // IWYU pragma: keep++#include ""absl/strings/str_cat.h""+#endif++namespace grpc_event_engine {+namespace posix_engine {++#ifdef GRPC_POSIX_SOCKET_UTILS_COMMON++namespace {++using ResolvedAddress =+    grpc_event_engine::experimental::EventEngine::ResolvedAddress;+using ListenerSocket = ListenerSocketsContainer::ListenerSocket;++#ifdef GRPC_HAVE_IFADDRS++// Bind to ""::"" to get a port number not used by any address.+absl::StatusOr<int> GetUnusedPort() {+  ResolvedAddress wild = SockaddrMakeWild6(0);+  PosixSocketWrapper::DSMode dsmode;+  auto sock = PosixSocketWrapper::CreateDualStackSocket(nullptr, wild,+                                                        SOCK_STREAM, 0, dsmode);+  if (!sock.ok()) {+    return sock.status();+  }+  if (dsmode == PosixSocketWrapper::DSMode::DSMODE_IPV4) {+    wild = SockaddrMakeWild4(0);+  }+  if (bind(sock->Fd(), wild.address(), wild.size()) != 0) {+    close(sock->Fd());+    return absl::InternalError(",Replaced all InternalErrors with absl::FailedPreconditionError,
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/31368,1010555740,2022-11-01T15:18:32Z,test/core/end2end/fixtures/h2_tls_common.h,"@@ -238,8 +238,8 @@ inline grpc_channel_credentials* create_tls_channel_credentials( inline grpc_server_credentials* create_tls_server_credentials(     fullstack_secure_fixture_data* ffd) {   grpc_tls_credentials_options* options = grpc_tls_credentials_options_create();-  options->set_min_tls_version(ffd->tls_version);-  options->set_max_tls_version(ffd->tls_version);+  grpc_tls_credentials_options_set_min_tls_version(options, ffd->tls_version);+  grpc_tls_credentials_options_set_max_tls_version(options, ffd->tls_version);","I am assuming that we're using the default `pick_first` LB policy and that there is only one address returned by the resolver, since I think that should be the case in all of the core e2e tests.If there is a handshake failure, then the connection attempt will fail, and `pick_first` will put the channel in `TRANSIENT_FAILURE`.  Any RPC sent on the channel will then fail by default.  However, if the RPC is using `wait_for_ready`, then it will remain queued until either (a) a subsequent connection attempt succeeds, or (b) the RPC's deadline expires.  The individual test can control whether it is using `wait_for_ready`, and it can expect the RPC to fail as appropriate.Retries should not be an issue here.  If the test is not explicitly configuring retries, then there should not be any retries in this case.",
1644595,gnossen,https://api.github.com/repos/grpc/grpc/pulls/31514,1010890310,2022-11-01T20:53:23Z,src/python/grpcio/grpc/_auth.py,"@@ -14,11 +14,13 @@ """"""GRPCAuthMetadataPlugins for standard authentication.""""""  import inspect+from typing import Optional  import grpc  -def _sign_request(callback, token, error):+def _sign_request(callback: grpc.AuthMetadataPluginCallback, token: str,","[`token` can be `None`](https://github.com/grpc/grpc/blob/1e0b50a3176fc085ef029b7c822205c2cd57a17f/src/python/grpcio/grpc/_auth.py#L49), so this should be `Optional[str]`",
1644595,gnossen,https://api.github.com/repos/grpc/grpc/pulls/31514,1010891262,2022-11-01T20:54:35Z,src/python/grpcio/grpc/_auth.py,"@@ -33,7 +35,8 @@ def __init__(self, credentials):         self._is_jwt = 'additional_claims' in inspect.getfullargspec(             credentials.get_access_token).args -    def __call__(self, context, callback):",You probably want to add type annotations to the members of this class as well.,
1644595,gnossen,https://api.github.com/repos/grpc/grpc/pulls/31514,1010909356,2022-11-01T21:16:14Z,src/python/grpcio/grpc/_compression.py,"@@ -12,7 +12,13 @@ # See the License for the specific language governing permissions and # limitations under the License. +from __future__ import annotations","Why is this necessary? Taking a look at [PEP563](https://peps.python.org/pep-0563/), it looks like this feature postpones evaluation of annotations. Is there some sort of dependency cycle here? It is possible to break that cycle without using this?",X
1644595,gnossen,https://api.github.com/repos/grpc/grpc/pulls/31514,1010910098,2022-11-01T21:17:20Z,src/python/grpcio/grpc/_interceptor.py,"@@ -15,31 +15,44 @@  import collections import sys+import types+from typing import Any, Callable, Optional, Sequence, Tuple, Union  import grpc +from ._typing import DeserializingFunction+from ._typing import DoneCallbackType+from ._typing import MetadataType+from ._typing import RequestIterableType+from ._typing import RequestType+from ._typing import ResponseType+from ._typing import SerializingFunction+  class _ServicePipeline(object): -    def __init__(self, interceptors):+    def __init__(self, interceptors: Sequence[grpc.ServerInterceptor]):",Please add member type annotations to modified classes here and throughout.,
1644595,gnossen,https://api.github.com/repos/grpc/grpc/pulls/31514,1010984253,2022-11-01T23:09:53Z,src/python/grpcio/grpc/_interceptor.py,"@@ -547,7 +587,8 @@ def close(self):         self._channel.close()  -def intercept_channel(channel, *interceptors):+def intercept_channel(channel: grpc.Channel,+                      *interceptors: Optional[Sequence[Any]]) -> grpc.Channel:","I think the type of `*interceptors` should be `Union[UnaryUnaryClientInterceptor, ..., StreamStreamClientInterceptor]`. [Splat arguments should be annotated as if they were a single argument](https://peps.python.org/pep-0484/#arbitrary-argument-lists-and-default-argument-values).",
1644595,gnossen,https://api.github.com/repos/grpc/grpc/pulls/31514,1010985489,2022-11-01T23:12:31Z,src/python/grpcio/grpc/_runtime_protos.py,"@@ -60,7 +64,7 @@ def _call_with_lazy_import(fn_name, protobuf_path):             raise NotImplementedError(_UNINSTALLED_TEMPLATE.format(fn_name))  -def protos(protobuf_path):  # pylint: disable=unused-argument+def protos(protobuf_path: str) -> types.ModuleType:  # pylint: disable=unused-argument","`protos`, `services`, and `protos_and_services` are [public API](https://github.com/grpc/grpc/blob/37c66629196b9547bee1c630bd79c400ae423f0c/src/python/grpcio/grpc/__init__.py#L24). Let's leave them out of this PR.",
24593237,XuanWang-Amos,https://api.github.com/repos/grpc/grpc/pulls/31514,1011008250,2022-11-01T23:51:29Z,src/python/grpcio/grpc/_auth.py,"@@ -33,7 +35,8 @@ def __init__(self, credentials):         self._is_jwt = 'additional_claims' in inspect.getfullargspec(             credentials.get_access_token).args -    def __call__(self, context, callback):","I'm having trouble find type for `credentials`, comment says it's from oauth2client library, do we need annotate this too?",
24593237,XuanWang-Amos,https://api.github.com/repos/grpc/grpc/pulls/31514,1011026726,2022-11-02T00:34:13Z,src/python/grpcio/grpc/_compression.py,"@@ -12,7 +12,13 @@ # See the License for the specific language governing permissions and # limitations under the License. +from __future__ import annotations","`grpc.Compression` used here is not defined when we [include this file in `__init__.py`](https://github.com/XuanWang-Amos/grpc/blob/master/src/python/grpcio/grpc/__init__.py#L22), we'll have following error without this line:```partially initialized module 'grpc' has no attribute 'Compression' (most likely due to a circular import)```I think we might need move `Compression` here if we want to get rid of this line.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/29728,1011999902,2022-11-02T16:09:33Z,src/core/tsi/ssl_transport_security_utils.h,"@@ -0,0 +1,147 @@+/*+ *+ * Copyright 2022 gRPC authors.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ *     http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ *+ */++#ifndef GRPC_CORE_TSI_SSL_TRANSPORT_SECURITY_UTILS_H+#define GRPC_CORE_TSI_SSL_TRANSPORT_SECURITY_UTILS_H++#include <grpc/support/port_platform.h>++#include <openssl/x509.h>++#include ""absl/strings/string_view.h""++#include <grpc/grpc_security_constants.h>++#include ""src/core/tsi/ssl/key_logging/ssl_key_logging.h""+#include ""src/core/tsi/transport_security_interface.h""++namespace grpc_core {++// Converts an SSL error status code to a readable string.+//+// error: the SSL error status code.+//+// return: the corresponding status string.+const char* SslErrorString(int error);++// Logs the SSL error stack.+void LogSslErrorStack(void);++// Performs an SSL_write and handle errors.+//+// ssl: the SSL object to write to.+// unprotected_bytes: the buffer containing the bytes for writing to |ssl|.+// unprotected_bytes_size: the size of the buffer |unprotected_bytes|.+//+// return: TSI_OK if the write operation succeeds or corresponding TSI errors.+tsi_result DoSslWrite(SSL* ssl, unsigned char* unprotected_bytes,","In the long run, I think we will want to eliminate `tsi_result` in favor of `absl::Status`.  Since this PR is converting these functions to idiomatic C++, would it make sense to do that here?  Or would it make more sense to keep using `tsi_result` for now, and then in a future PR convert all uses for `tsi_result` to `absl::Status` all at once?",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/29728,1012011396,2022-11-02T16:18:09Z,src/core/tsi/ssl_transport_security_utils.h,"@@ -0,0 +1,147 @@+/*+ *+ * Copyright 2022 gRPC authors.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ *     http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ *+ */++#ifndef GRPC_CORE_TSI_SSL_TRANSPORT_SECURITY_UTILS_H+#define GRPC_CORE_TSI_SSL_TRANSPORT_SECURITY_UTILS_H++#include <grpc/support/port_platform.h>++#include <openssl/x509.h>++#include ""absl/strings/string_view.h""++#include <grpc/grpc_security_constants.h>++#include ""src/core/tsi/ssl/key_logging/ssl_key_logging.h""+#include ""src/core/tsi/transport_security_interface.h""++namespace grpc_core {++// Converts an SSL error status code to a readable string.+//+// error: the SSL error status code.+//+// return: the corresponding status string.+const char* SslErrorString(int error);++// Logs the SSL error stack.+void LogSslErrorStack(void);++// Performs an SSL_write and handle errors.+//+// ssl: the SSL object to write to.+// unprotected_bytes: the buffer containing the bytes for writing to |ssl|.+// unprotected_bytes_size: the size of the buffer |unprotected_bytes|.+//+// return: TSI_OK if the write operation succeeds or corresponding TSI errors.+tsi_result DoSslWrite(SSL* ssl, unsigned char* unprotected_bytes,+                      size_t unprotected_bytes_size);++// Performs an SSL_read and handle errors.+//+// ssl: the SSL object to read from.+// unprotected_bytes: the buffer to which this function will populate the read+//                    result from |ssl|.+// unprotected_bytes_size: the maximum size of the buffer |unprotected_bytes|.+//                         This will be populated with the size of the bytes+//                         read from |ssl| if this function returns TSI_OK.+//+// return: TSI_OK if the write operation succeeds or corresponding TSI errors.+tsi_result DoSslRead(SSL* ssl, unsigned char* unprotected_bytes,","Would it make sense to change this to use some idiomatic C++ type for the buffers?  It would be nice, for example, to have some type that encodes both the buffer space and the size in a single object, similarly to how `std::string` works.  But I don't know if it makes sense to do that in this PR, given that the surrounding code is presumably still using C-style buffers.",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/31528,1012125120,2022-11-02T17:59:52Z,tools/distrib/gen_experiments_and_format.sh,"@@ -15,7 +15,7 @@  set -e cd $(dirname $0)/../..-tools/codegen/core/gen_experiments.py $@+tools/codegen/core/gen_experiments.py --check $@","> https://github.com/grpc/grpc/blob/master/tools/codegen/core/gen_experiments.py#L38> > In this line, the if condition should be something like `if ""--check"" in sys.argv:` or `if sys.argv[1] == ""--check"":`Why?",
5564114,Vignesh2208,https://api.github.com/repos/grpc/grpc/pulls/31435,1012135896,2022-11-02T18:10:05Z,test/core/event_engine/posix/posix_engine_listener_utils_test.cc,"@@ -0,0 +1,162 @@+// Copyright 2022 gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++#include <string.h>+#include <sys/socket.h>+#include <unistd.h>++#include <list>+#include <string>++#include ""absl/status/status.h""+#include ""absl/status/statusor.h""+#include ""absl/strings/str_cat.h""+#include ""gtest/gtest.h""++#include <grpc/event_engine/event_engine.h>++#include ""src/core/lib/iomgr/port.h""++// This test won't work except with posix sockets enabled+#ifdef GRPC_POSIX_SOCKET_UTILS_COMMON++#include <ifaddrs.h>++#include <gtest/gtest.h>++#include <grpc/support/log.h>++#include ""src/core/lib/event_engine/channel_args_endpoint_config.h""+#include ""src/core/lib/event_engine/posix_engine/posix_engine_listener_utils.h""+#include ""src/core/lib/event_engine/posix_engine/tcp_socket_utils.h""+#include ""test/core/util/port.h""++namespace grpc_event_engine {+namespace posix_engine {++namespace {++using ::grpc_event_engine::experimental::ChannelArgsEndpointConfig;++class TestListenerSocketsContainer : public ListenerSocketsContainer {+ public:+  void Append(ListenerSocket socket) override { sockets_.push_back(socket); }++  absl::StatusOr<ListenerSocket> Find(+      const grpc_event_engine::experimental::EventEngine::ResolvedAddress& addr)+      override {+    for (auto socket = sockets_.begin(); socket != sockets_.end(); ++socket) {+      if (socket->addr.size() == addr.size() &&+          memcmp(socket->addr.address(), addr.address(), addr.size()) == 0) {+        return *socket;+      }+    }+    return absl::NotFoundError(""Socket not found!"");+  }++  int Size() { return static_cast<int>(sockets_.size()); }++  std::list<ListenerSocket>::const_iterator begin() { return sockets_.begin(); }+  std::list<ListenerSocket>::const_iterator end() { return sockets_.end(); }++ private:+  std::list<ListenerSocket> sockets_;+};++}  // namespace++TEST(PosixEngineListenerUtils, ListenerContainerAddWildcardAddressesTest) {+  TestListenerSocketsContainer listener_sockets;+  int port = grpc_pick_unused_port_or_die();+  ChannelArgsEndpointConfig config;+  auto result = ListenerContainerAddWildcardAddresses(+      listener_sockets, TcpOptionsFromEndpointConfig(config), port);+  EXPECT_TRUE(result.ok());+  EXPECT_GT(*result, 0);+  port = *result;+  EXPECT_GE(listener_sockets.Size(), 1);+  EXPECT_LE(listener_sockets.Size(), 2);+  for (auto socket = listener_sockets.begin(); socket != listener_sockets.end();+       ++socket) {+    ASSERT_TRUE((*socket).addr.address()->sa_family == AF_INET6 ||+                (*socket).addr.address()->sa_family == AF_INET);+    if ((*socket).addr.address()->sa_family == AF_INET6) {+      EXPECT_EQ(SockaddrToString(&(*socket).addr, true).value(),+                absl::StrCat(""[::]:"", std::to_string(port)));+    } else if ((*socket).addr.address()->sa_family == AF_INET) {+      EXPECT_EQ(SockaddrToString(&(*socket).addr, true).value(),+                absl::StrCat(""0.0.0.0:"", std::to_string(port)));+    }+    close(socket->sock.Fd());+  }+}++#ifdef GRPC_HAVE_IFADDRS+TEST(PosixEngineListenerUtils, ListenerContainerAddAllLocalAddressesTest) {+  TestListenerSocketsContainer listener_sockets;+  int port = grpc_pick_unused_port_or_die();+  ChannelArgsEndpointConfig config;+  struct ifaddrs* ifa = nullptr;+  struct ifaddrs* ifa_it;+  if (getifaddrs(&ifa) != 0 || ifa == nullptr) {+    // No ifaddresses available.+    gpr_log(GPR_INFO,+            ""Skipping ListenerAddAllLocalAddressesTest because the machine """,If the test runs on a machine with no interfaces I think this condition could get triggered. Looks like it could also get triggered if there is no memory,
24593237,XuanWang-Amos,https://api.github.com/repos/grpc/grpc/pulls/31514,1013154351,2022-11-03T16:39:48Z,src/python/grpcio/grpc/_typing.py,"@@ -0,0 +1,29 @@+# Copyright 2022 gRPC authors.+#+# Licensed under the Apache License, Version 2.0 (the ""License"");+# you may not use this file except in compliance with the License.+# You may obtain a copy of the License at+#+#     http://www.apache.org/licenses/LICENSE-2.0+#+# Unless required by applicable law or agreed to in writing, software+# distributed under the License is distributed on an ""AS IS"" BASIS,+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+# See the License for the specific language governing permissions and+# limitations under the License.+""""""Common types for gRPC Sync API""""""++from typing import Any, Callable, Iterable, Sequence, Tuple, TypeVar, Union++from grpc._cython.cygrpc import EOF++RequestType = TypeVar('RequestType')+ResponseType = TypeVar('ResponseType')+SerializingFunction = Callable[[Any], bytes]","Tried change the type of SerializingFunction from `Callable[[Any], bytes]` to `Callable[[RequestType], bytes]`, but looks like it's not necessary.For example, in [_Channel.unary_unary](https://github.com/grpc/grpc/blob/89de6312cd949fdd2aeaeaccc313fb74ac0a3853/src/python/grpcio/grpc/_interceptor.py#L492-L501) the annotation only appears in the signature thus not enforce anything, and pytype also complains with error: `Invalid type annotation 'RequestType'  [invalid-annotation] Appears only once in the signature`.I think the best way is just keep it as `Any` since it's also what we have in [aio stack](https://github.com/grpc/grpc/blob/89de6312cd949fdd2aeaeaccc313fb74ac0a3853/src/python/grpcio/grpc/aio/_typing.py#L27,L28).",
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/31540,1013202881,2022-11-03T17:19:21Z,test/core/event_engine/test_suite/server_test.cc,"@@ -12,12 +12,263 @@ // See the License for the specific language governing permissions and // limitations under the License. -#include <gtest/gtest.h>+#include <algorithm>+#include <chrono>+#include <memory>+#include <string>+#include <thread>+#include <tuple>+#include <utility>+#include <vector> +#include ""absl/status/status.h""+#include ""absl/status/statusor.h""+#include ""absl/strings/str_cat.h""+#include ""absl/time/clock.h""+#include ""absl/time/time.h""+#include ""gtest/gtest.h""++#include <grpc/event_engine/event_engine.h>+#include <grpc/event_engine/memory_allocator.h>+#include <grpc/grpc.h>+#include <grpc/support/log.h>++#include ""src/core/lib/channel/channel_args.h""+#include ""src/core/lib/event_engine/channel_args_endpoint_config.h""+#include ""src/core/lib/gprpp/notification.h"" #include ""src/core/lib/iomgr/exec_ctx.h""+#include ""src/core/lib/resource_quota/memory_quota.h""+#include ""src/core/lib/resource_quota/resource_quota.h"" #include ""test/core/event_engine/test_suite/event_engine_test.h""+#include ""test/core/event_engine/test_suite/event_engine_test_utils.h""+#include ""test/core/util/port.h""  class EventEngineServerTest : public EventEngineTest {}; -// TODO(hork): establish meaningful tests-TEST_F(EventEngineServerTest, TODO) { grpc_core::ExecCtx exec_ctx; }+using namespace std::chrono_literals;++namespace {++using ::grpc_event_engine::experimental::ChannelArgsEndpointConfig;+using ::grpc_event_engine::experimental::EventEngine;+using ::grpc_event_engine::experimental::URIToResolvedAddress;+using Endpoint = ::grpc_event_engine::experimental::EventEngine::Endpoint;+using Listener = ::grpc_event_engine::experimental::EventEngine::Listener;+using ::grpc_event_engine::experimental::GetNextSendMessage;+using ::grpc_event_engine::experimental::WaitForSingleOwner;++constexpr int kNumExchangedMessages = 100;++}  // namespace++// Create a connection using the oracle EventEngine to a listener created+// by the Test EventEngine and exchange bi-di data over the connection.+// For each data transfer, verify that data written at one end of the stream+// equals data read at the other end of the stream.+TEST_F(EventEngineServerTest, ServerConnectExchangeBidiDataTransferTest) {","This test might flake on infrastructure network issues, which we have seen. We can watch it for a bit and see the flake rate. It might be nice to improve the test so that infrastructure flakes do not show up as test flakes/failures (e.g., add retries on identified poor network conditions), but we can consider that later. Just noting that this may flake through no fault of the code.",
7221003,rockspore,https://api.github.com/repos/grpc/grpc/pulls/31368,1013444420,2022-11-03T22:15:19Z,test/core/end2end/fixtures/h2_tls_common.h,"@@ -238,8 +238,8 @@ inline grpc_channel_credentials* create_tls_channel_credentials( inline grpc_server_credentials* create_tls_server_credentials(     fullstack_secure_fixture_data* ffd) {   grpc_tls_credentials_options* options = grpc_tls_credentials_options_create();-  options->set_min_tls_version(ffd->tls_version);-  options->set_max_tls_version(ffd->tls_version);+  grpc_tls_credentials_options_set_min_tls_version(options, ffd->tls_version);+  grpc_tls_credentials_options_set_max_tls_version(options, ffd->tls_version);","I added fixtures and test for the bad tls versions. For some reason, the corresponding test couldn't end itself till the 10 seconds timeout specified by at [test_config.cc](https://github.com/grpc/grpc/blob/7c5e3267981b5cdef015438040ad6d5e62ff4044/test/core/util/test_config.cc#L163). I have confirmed that `grpc_shutdown()` in the main function in `h2_tls_wrong_versions.cc` actually returned. To reproduce this, one can run:```bazel test //test/core/end2end:h2_tls_wrong_versions_test@status_unavailable --test_output=streamed```when this branch is checked out.@ZhenLian PTAL when you get a chance. Thanks.",
394885,soheilhy,https://api.github.com/repos/grpc/grpc/pulls/31565,1014891187,2022-11-06T20:56:01Z,src/core/lib/iomgr/buffer_list.h,"@@ -100,54 +100,63 @@ struct Timestamps { #endif           /* GRPC_LINUX_ERRQUEUE */ }; -/** TracedBuffer is a class to keep track of timestamps for a specific buffer in- * the TCP layer. We are only tracking timestamps for Linux kernels and hence- * this class would only be used by Linux platforms. For all other platforms,- * TracedBuffer would be an empty class.- *- * The timestamps collected are according to Timestamps declared- * above.- *- * A TracedBuffer list is kept track of using the head element of the list. If- * the head element of the list is nullptr, then the list is empty.- */+// TracedBuffer is a class to keep track of timestamps for a specific buffer in+// the TCP layer. We are only tracking timestamps for Linux kernels and hence+// this class would only be used by Linux platforms. For all other platforms,+// TracedBuffer would be an empty class.+// The timestamps collected are according to Timestamps declared above A+// TracedBuffer list is kept track of using the head element of the list. If+// *the head element of the list is nullptr, then the list is empty. #ifdef GRPC_LINUX_ERRQUEUE-class TracedBuffer {++class TracedBufferList {  public:-  /** Use AddNewEntry function instead of using this directly. */-  TracedBuffer(uint32_t seq_no, void* arg)-      : seq_no_(seq_no), arg_(arg), next_(nullptr) {}--  /** Add a new entry in the TracedBuffer list pointed to by head. Also saves-   * sendmsg_time with the current timestamp. */-  static void AddNewEntry(TracedBuffer** head, uint32_t seq_no, int fd,-                          void* arg);--  /** Processes a received timestamp based on sock_extended_err and-   * scm_timestamping structures. It will invoke the timestamps callback if the-   * timestamp type is SCM_TSTAMP_ACK. */-  static void ProcessTimestamp(TracedBuffer** head,-                               struct sock_extended_err* serr,-                               struct cmsghdr* opt_stats,-                               struct scm_timestamping* tss);--  /** Cleans the list by calling the callback for each traced buffer in the list-   * with timestamps that it has. */-  static void Shutdown(TracedBuffer** head, void* remaining,-                       grpc_error_handle shutdown_err);+  // Add a new entry in the TracedBuffer list pointed to by head. Also saves+  // sendmsg_time with the current timestamp.+  void AddNewEntry(int32_t seq_no, int fd, void* arg);+  // Processes a received timestamp based on sock_extended_err and+  // scm_timestamping structures. It will invoke the timestamps callback if the+  // timestamp type is SCM_TSTAMP_ACK.+  void ProcessTimestamp(struct sock_extended_err* serr,+                        struct cmsghdr* opt_stats,+                        struct scm_timestamping* tss);+  int Size() {+    MutexLock lock(&mu_);+    return buffer_list_.size();+  }+  // Cleans the list by calling the callback for each traced buffer in the list+  // with timestamps that it has.+  void Shutdown(void* /*remaining*/, absl::Status /*shutdown_err*/);   private:-  uint32_t seq_no_;    /* The sequence number for the last byte in the buffer */-  void* arg_;          /* The arg to pass to timestamps_callback */-  Timestamps ts_;      /* The timestamps corresponding to this buffer */-  TracedBuffer* next_; /* The next TracedBuffer in the list */+  class TracedBuffer {+   public:+    TracedBuffer(uint32_t seq_no, void* arg) : seq_no_(seq_no), arg_(arg) {}++   private:+    friend class TracedBufferList;+    uint32_t seq_no_; /* The sequence number for the last byte in the buffer */+    void* arg_;       /* The arg to pass to timestamps_callback */+    Timestamps ts_;   /* The timestamps corresponding to this buffer */+  };+  Mutex mu_;+  // TracedBuffers are ordered by sequence number and would need to be processed+  // in a FIFO order starting with the smallest sequence number. To enable this,+  // they are stored in a std::list which allows easy appends and forward+  // iteration operations.+  std::list<TracedBuffer> buffer_list_;","List is doubly-linked list and is gonna have more overheads compared to intrusive. If we use intrusive list, we can avoid the expensive copy of tcp info (see my comment above).",
394885,soheilhy,https://api.github.com/repos/grpc/grpc/pulls/31565,1014891597,2022-11-06T20:59:54Z,src/core/lib/event_engine/posix_engine/traced_buffer_list.cc,"@@ -198,23 +199,27 @@ void ExtractOptStatsFromCmsg(ConnectionMetrics* metrics, }  // namespace.  void TracedBufferList::AddNewEntry(int32_t seq_no, int fd, void* arg) {-  buffer_list_.emplace_back(seq_no, arg);-  TracedBuffer& new_elem = buffer_list_.back();+  TracedBuffer new_elem(seq_no, arg);   // Store the current time as the sendmsg time.   new_elem.ts_.sendmsg_time.time = gpr_now(GPR_CLOCK_REALTIME);   new_elem.ts_.scheduled_time.time = gpr_inf_past(GPR_CLOCK_REALTIME);   new_elem.ts_.sent_time.time = gpr_inf_past(GPR_CLOCK_REALTIME);   new_elem.ts_.acked_time.time = gpr_inf_past(GPR_CLOCK_REALTIME);-   if (GetSocketTcpInfo(&new_elem.ts_.info, fd) == 0) {     ExtractOptStatsFromTcpInfo(&new_elem.ts_.sendmsg_time.metrics,                                &new_elem.ts_.info);   }+  grpc_core::MutexLock lock(&mu_);+  buffer_list_.push_back(new_elem);","`new_elem.ts_.info` is a a very large structure and is not trivially copy-able.  Can we make return `next_` to `TraceBuffer`, allocate it on the heap and make TracedBufferList use an intrusive list approach to avoid this copy?",
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/31366,1015611263,2022-11-07T16:08:19Z,test/distrib/bazel/test_single_bazel_version.sh,"@@ -51,12 +51,14 @@ FAILED_TESTS="""" export OVERRIDE_BAZEL_VERSION=""$VERSION"" # when running under bazel docker image, the workspace is read only. export OVERRIDE_BAZEL_WRAPPER_DOWNLOAD_DIR=/tmp+ bazel build -- //... ""${EXCLUDED_TARGETS[@]}"" || FAILED_TESTS=""${FAILED_TESTS}Build ""  for TEST_DIRECTORY in ""${TEST_DIRECTORIES[@]}""; do   pushd ""test/distrib/bazel/$TEST_DIRECTORY/"" -  bazel test --test_output=all //:all || FAILED_TESTS=""${FAILED_TESTS}${TEST_DIRECTORY} Distribtest""+  tools/bazel version | grep ""$VERSION"" || { echo ""Detected bazel version did not match expected value of $VERSION"" >/dev/stderr; exit 1; }+  tools/bazel test --test_output=all //:all || FAILED_TESTS=""${FAILED_TESTS}${TEST_DIRECTORY} Distribtest""","That's very strange. If I run ""bazel"" from the grpc repo root it really does run the wrapper for me. I just tried on my usual workspace and on a fresh clone.```~/github/experiment_grpc$ bazel versionINFO: Running bazel wrapper (see //tools/bazel for details), bazel version 5.3.0 will be used instead of system-wide bazel installation.Build label: 5.3.0```Are you sure you don't have DISABLE_BAZEL_WRAPPER variable set by accident?",
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/31527,1015622772,2022-11-07T16:18:04Z,src/csharp/Grpc.Tools/build/_protobuf/Google.Protobuf.Tools.targets,"@@ -190,17 +194,24 @@     <ItemGroup>       <_Protobuf_CodeCompile Include=""@(Protobuf_ExpectedOutputs->Distinct())""          Condition="" '%(Source)' != '' and '@(Protobuf_Compile->WithMetadataValue('CompileOutputs', 'true'))' != '' "" />-      <Compile Include=""@(_Protobuf_CodeCompile)"" />+      <!-- Adding Distinct() is just a precaution as the CSC compiler complains if there are +           duplicate source files+      -->+      <Compile Include=""@(_Protobuf_CodeCompile->Distinct())"" />","qq: if there are duplicates, wouldn't it be fair to report that as a problem? Did this actually happen to you during testing?",
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/31540,1015717463,2022-11-07T17:38:52Z,test/core/event_engine/test_suite/client_test.cc,"@@ -114,46 +114,40 @@ TEST_F(EventEngineClientTest, ConnectExchangeBidiDataTransferTest) {   auto quota = grpc_core::ResourceQuota::Default();   args = args.Set(GRPC_ARG_RESOURCE_QUOTA, quota);   ChannelArgsEndpointConfig config(args);-  auto status = oracle_ee->CreateListener(+  auto listener = oracle_ee->CreateListener(       std::move(accept_cb),       [](absl::Status status) { GPR_ASSERT(status.ok()); }, config,       std::make_unique<grpc_core::MemoryQuota>(""foo""));-  EXPECT_TRUE(status.ok());+  ASSERT_TRUE(listener.ok()); -  std::unique_ptr<Listener> listener = std::move(*status);-  EXPECT_TRUE(listener->Bind(URIToResolvedAddress(target_addr)).ok());-  EXPECT_TRUE(listener->Start().ok());+  ASSERT_TRUE((*listener)->Bind(URIToResolvedAddress(target_addr)).ok());","This can be `ASSERT_TRUE(listener->Bind(...).ok())`, no need for `(*listener)->`. Part of the reason it's recommend to name StatusOr variables as the value types themselves is because the StatusOr class overrides `operator->`, allowing the variable to act as the type.This pattern happens again below.",
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/31540,1015720448,2022-11-07T17:41:57Z,test/core/event_engine/test_suite/client_test.cc,"@@ -114,46 +114,40 @@ TEST_F(EventEngineClientTest, ConnectExchangeBidiDataTransferTest) {   auto quota = grpc_core::ResourceQuota::Default();   args = args.Set(GRPC_ARG_RESOURCE_QUOTA, quota);   ChannelArgsEndpointConfig config(args);-  auto status = oracle_ee->CreateListener(+  auto listener = oracle_ee->CreateListener(       std::move(accept_cb),       [](absl::Status status) { GPR_ASSERT(status.ok()); }, config,       std::make_unique<grpc_core::MemoryQuota>(""foo""));-  EXPECT_TRUE(status.ok());+  ASSERT_TRUE(listener.ok()); -  std::unique_ptr<Listener> listener = std::move(*status);-  EXPECT_TRUE(listener->Bind(URIToResolvedAddress(target_addr)).ok());-  EXPECT_TRUE(listener->Start().ok());+  ASSERT_TRUE((*listener)->Bind(URIToResolvedAddress(target_addr)).ok());+  ASSERT_TRUE((*listener)->Start().ok());    test_ee->Connect(       [&client_endpoint,        &client_signal](absl::StatusOr<std::unique_ptr<Endpoint>> status) {","nit: As recommend elsewhere, StatusOr variable names should match underlying type. Would suggest naming this parameter `endpoint` or some such.This pattern happens again below",
5564114,Vignesh2208,https://api.github.com/repos/grpc/grpc/pulls/31565,1015872378,2022-11-07T20:33:56Z,src/core/lib/iomgr/buffer_list.h,"@@ -100,54 +100,63 @@ struct Timestamps { #endif           /* GRPC_LINUX_ERRQUEUE */ }; -/** TracedBuffer is a class to keep track of timestamps for a specific buffer in- * the TCP layer. We are only tracking timestamps for Linux kernels and hence- * this class would only be used by Linux platforms. For all other platforms,- * TracedBuffer would be an empty class.- *- * The timestamps collected are according to Timestamps declared- * above.- *- * A TracedBuffer list is kept track of using the head element of the list. If- * the head element of the list is nullptr, then the list is empty.- */+// TracedBuffer is a class to keep track of timestamps for a specific buffer in+// the TCP layer. We are only tracking timestamps for Linux kernels and hence+// this class would only be used by Linux platforms. For all other platforms,+// TracedBuffer would be an empty class.+// The timestamps collected are according to Timestamps declared above A+// TracedBuffer list is kept track of using the head element of the list. If+// *the head element of the list is nullptr, then the list is empty. #ifdef GRPC_LINUX_ERRQUEUE-class TracedBuffer {++class TracedBufferList {  public:-  /** Use AddNewEntry function instead of using this directly. */-  TracedBuffer(uint32_t seq_no, void* arg)-      : seq_no_(seq_no), arg_(arg), next_(nullptr) {}--  /** Add a new entry in the TracedBuffer list pointed to by head. Also saves-   * sendmsg_time with the current timestamp. */-  static void AddNewEntry(TracedBuffer** head, uint32_t seq_no, int fd,-                          void* arg);--  /** Processes a received timestamp based on sock_extended_err and-   * scm_timestamping structures. It will invoke the timestamps callback if the-   * timestamp type is SCM_TSTAMP_ACK. */-  static void ProcessTimestamp(TracedBuffer** head,-                               struct sock_extended_err* serr,-                               struct cmsghdr* opt_stats,-                               struct scm_timestamping* tss);--  /** Cleans the list by calling the callback for each traced buffer in the list-   * with timestamps that it has. */-  static void Shutdown(TracedBuffer** head, void* remaining,-                       grpc_error_handle shutdown_err);+  // Add a new entry in the TracedBuffer list pointed to by head. Also saves+  // sendmsg_time with the current timestamp.+  void AddNewEntry(int32_t seq_no, int fd, void* arg);+  // Processes a received timestamp based on sock_extended_err and+  // scm_timestamping structures. It will invoke the timestamps callback if the+  // timestamp type is SCM_TSTAMP_ACK.+  void ProcessTimestamp(struct sock_extended_err* serr,+                        struct cmsghdr* opt_stats,+                        struct scm_timestamping* tss);+  int Size() {+    MutexLock lock(&mu_);+    return buffer_list_.size();+  }+  // Cleans the list by calling the callback for each traced buffer in the list+  // with timestamps that it has.+  void Shutdown(void* /*remaining*/, absl::Status /*shutdown_err*/);   private:-  uint32_t seq_no_;    /* The sequence number for the last byte in the buffer */-  void* arg_;          /* The arg to pass to timestamps_callback */-  Timestamps ts_;      /* The timestamps corresponding to this buffer */-  TracedBuffer* next_; /* The next TracedBuffer in the list */+  class TracedBuffer {+   public:+    TracedBuffer(uint32_t seq_no, void* arg) : seq_no_(seq_no), arg_(arg) {}++   private:+    friend class TracedBufferList;+    uint32_t seq_no_; /* The sequence number for the last byte in the buffer */+    void* arg_;       /* The arg to pass to timestamps_callback */+    Timestamps ts_;   /* The timestamps corresponding to this buffer */+  };+  Mutex mu_;+  // TracedBuffers are ordered by sequence number and would need to be processed+  // in a FIFO order starting with the smallest sequence number. To enable this,+  // they are stored in a std::list which allows easy appends and forward+  // iteration operations.+  std::list<TracedBuffer> buffer_list_;",Thanks. Updated it to use a singly linked list containing a head and tail ptr for quick append and iteration.,
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/31544,1016053766,2022-11-08T01:24:11Z,test/core/client_channel/lb_policy/lb_policy_test_lib.h,"@@ -433,11 +446,12 @@ class LoadBalancingPolicyTest : public ::testing::Test {         << location.file() << "":"" << location.line();   } -  // Requests a pick on picker and expects a Complete result whose-  // subchannel has the specified address.-  void ExpectPickComplete(LoadBalancingPolicy::SubchannelPicker* picker,-                          absl::string_view address_uri,-                          SourceLocation location = SourceLocation()) {+  // Requests a pick on picker and return the address from a Complete result.+  // Has to be void and use output argument so the assertions still work+  void GetPickedAddress(LoadBalancingPolicy::SubchannelPicker* picker,+                        absl::optional<std::string>& out_picked_uri,","For output parameters, please use pointers instead of references.(This is no longer relevant if you take my suggestion above about changing this to return the address directly.)",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/31544,1016061142,2022-11-08T01:37:28Z,test/core/client_channel/lb_policy/round_robin_test.cc,"@@ -0,0 +1,251 @@+//+// Copyright 2022 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+//++#include <stddef.h>++#include <algorithm>+#include <map>+#include <memory>+#include <utility>+#include <vector>++#include ""absl/status/status.h""+#include ""absl/status/statusor.h""+#include ""absl/strings/string_view.h""+#include ""gtest/gtest.h""++#include <grpc/grpc.h>++#include ""src/core/ext/filters/client_channel/subchannel_pool_interface.h""+#include ""src/core/lib/channel/channel_args.h""+#include ""src/core/lib/gprpp/orphanable.h""+#include ""src/core/lib/iomgr/resolved_address.h""+#include ""src/core/lib/load_balancing/lb_policy.h""+#include ""src/core/lib/resolver/server_address.h""+#include ""test/core/client_channel/lb_policy/lb_policy_test_lib.h""+#include ""test/core/util/test_config.h""++namespace grpc_core {+namespace testing {+namespace {++class RoundRobinTest : public LoadBalancingPolicyTest {+ public:+  OrphanablePtr<LoadBalancingPolicy> RoundRobinPolicy(","I think we should decouple creating the LB policy from sending it an update, since we will also want to test cases where we send the same policy instance multiple updates, each of which may have a different number of addresses.  I also don't think we should hard-code checking that the LB policy reports CONNECTING once for each subchannel in the list, because there are many cases where it won't actually do that on a subsequent update.For example, consider a test that covers this sequence of events:1. LB policy gets an update with address list [A].2. LB policy creates subchannel for A and reports CONNECTING.3. Subchannel for address A reports CONNECTING, LB policy reports CONNECTING.4. Subchannel for address A reports READY, LB policy reports READY.5. LB policy gets an update with address list [A, B].6. LB policy creates subchannels for A and B (the one for A is a duplicate object, sharing the same connection as the original one).  The LB policy does *not* report any state change, since it is continuing to use the old subchannel list for now.7. The new subchannel for address A reports READY, since it is already connected.  The LB policy reports READY.8. The subchannel for address B reports READY, and the LB policy reports READY again.I think we want those individual steps to be explicitly spelled out in the individual tests, so that it's easy to see what the test is actually doing.I suggest storing the LB policy in a data member that is initialized in the `RoundRobinTest` ctor, just like we do in the pick_first unit test.  Then we can just add a method like the following to `LoadBalancingPolicyTest`:```LoadBalancingPolicy::UpdateArgs BuildUpdate(const std::vector<std::string>& addresses) {  LoadBalancingPolicy::UpdateArgs update_args;  update_args.addresses.emplace();  for (const auto& address : addresses) {    update_args.addresses->emplace_back(MakeAddress(address), ChannelArgs());  }  return update_args;}```Then an individual test can just do this:```ApplyUpdate(BuildUpdate(addresses), lb_policy);```",X
5663878,yijiem,https://api.github.com/repos/grpc/grpc/pulls/31564,1016073309,2022-11-08T02:04:33Z,src/core/lib/transport/handshaker.cc,"@@ -16,32 +16,32 @@  *  */ -#include <grpc/support/port_platform.h>- #include ""src/core/lib/transport/handshaker.h"" +#include <grpc/support/port_platform.h> #include <inttypes.h>--#include <string>-#include <utility>--#include ""absl/status/status.h""-#include ""absl/strings/str_format.h""-+#include <grpc/event_engine/event_engine.h> #include <grpc/impl/codegen/grpc_types.h> #include <grpc/slice_buffer.h> #include <grpc/support/alloc.h> #include <grpc/support/log.h>+#include <string>+#include <utility> +#include ""absl/status/status.h""+#include ""absl/strings/str_format.h""+#include ""handshaker.h""","ah, my bad, not sure how it went in there... good catch!",
57042389,tonydnewell,https://api.github.com/repos/grpc/grpc/pulls/31527,1016363240,2022-11-08T09:39:37Z,src/csharp/Grpc.Tools/build/_protobuf/Google.Protobuf.Tools.targets,"@@ -190,17 +194,24 @@     <ItemGroup>       <_Protobuf_CodeCompile Include=""@(Protobuf_ExpectedOutputs->Distinct())""          Condition="" '%(Source)' != '' and '@(Protobuf_Compile->WithMetadataValue('CompileOutputs', 'true'))' != '' "" />-      <Compile Include=""@(_Protobuf_CodeCompile)"" />+      <!-- Adding Distinct() is just a precaution as the CSC compiler complains if there are +           duplicate source files+      -->+      <Compile Include=""@(_Protobuf_CodeCompile->Distinct())"" />",The Distinct() is just a precaution. No duplicates seen in testing with the new Unescape() fix (duplicates were seen with the old qualified Source fix).,
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/31544,1016889736,2022-11-08T16:54:43Z,test/core/client_channel/lb_policy/round_robin_test.cc,"@@ -0,0 +1,251 @@+//+// Copyright 2022 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+//++#include <stddef.h>++#include <algorithm>+#include <map>+#include <memory>+#include <utility>+#include <vector>++#include ""absl/status/status.h""+#include ""absl/status/statusor.h""+#include ""absl/strings/string_view.h""+#include ""gtest/gtest.h""++#include <grpc/grpc.h>++#include ""src/core/ext/filters/client_channel/subchannel_pool_interface.h""+#include ""src/core/lib/channel/channel_args.h""+#include ""src/core/lib/gprpp/orphanable.h""+#include ""src/core/lib/iomgr/resolved_address.h""+#include ""src/core/lib/load_balancing/lb_policy.h""+#include ""src/core/lib/resolver/server_address.h""+#include ""test/core/client_channel/lb_policy/lb_policy_test_lib.h""+#include ""test/core/util/test_config.h""++namespace grpc_core {+namespace testing {+namespace {++class RoundRobinTest : public LoadBalancingPolicyTest {+ public:+  OrphanablePtr<LoadBalancingPolicy> RoundRobinPolicy(+      size_t channelsCount = 3) {+    LoadBalancingPolicy::UpdateArgs update_args;+    update_args.addresses.emplace();+    for (size_t i = 0; i < channelsCount; ++i) {+      update_args.addresses->emplace_back(MakeAddress(UriForSubchannel(i)),+                                          ChannelArgs());+    }+    auto policy = MakeLbPolicy(""round_robin"");+    absl::Status status = ApplyUpdate(std::move(update_args), policy.get());+    EXPECT_TRUE(status.ok()) << status;+    EXPECT_EQ(channelsCount, subchannel_pool_.size());+    for (size_t i = 0; i < subchannel_pool_.size(); ++i) {+      ExpectState(GRPC_CHANNEL_CONNECTING);+    }+    return policy;+  }++  void SetSubchannelConnectivityState(+      size_t subchannel, grpc_connectivity_state new_state,+      absl::Status status = absl::OkStatus(),+      SourceLocation location = SourceLocation()) {+    auto it = subchannel_pool_.find(+        {MakeAddress(UriForSubchannel(subchannel)), ChannelArgs()});+    ASSERT_NE(it, subchannel_pool_.end())+        << location.file() << "":"" << location.line();+    it->second.SetConnectivityState(new_state, status);+  }++  bool ConnectionRequested(size_t subchannel) {+    auto it = subchannel_pool_.find(+        {MakeAddress(UriForSubchannel(subchannel)), ChannelArgs()});+    return it->second.ConnectionRequested();+  }++  std::string UriForSubchannel(size_t index) {+    std::stringstream out;+    out << ""ipv4:127.0.0.1:44"" << (index + 1);+    return out.str();+  }+};++TEST_F(RoundRobinTest, SingleChannel) {+  auto policy = RoundRobinPolicy(1);+  // LB policy should have reported CONNECTING state.+  auto picker = ExpectState(GRPC_CHANNEL_CONNECTING);+  ExpectPickQueued(picker.get());+  // LB policy should have requested a connection on this subchannel.+  EXPECT_TRUE(ConnectionRequested(0));++  SetSubchannelConnectivityState(0, GRPC_CHANNEL_CONNECTING);+  picker = ExpectState(GRPC_CHANNEL_CONNECTING);+  ExpectPickQueued(picker.get());++  // Channel is ready+  SetSubchannelConnectivityState(0, GRPC_CHANNEL_READY);+  picker = ExpectState(GRPC_CHANNEL_READY);+  // Picker should return the same subchannel repeatedly.+  for (size_t i = 0; i < 3; ++i) {+    ExpectPickComplete(picker.get(), UriForSubchannel(0));+  }+  ExpectNoStateChange();++  // There's a failure+  SetSubchannelConnectivityState(0, GRPC_CHANNEL_TRANSIENT_FAILURE);","A subchannel won't actually transition from READY directly to TRANSIENT_FAILURE; it will instead go from READY to IDLE if the connection fails.  Also, it will never transition from TRANSIENT_FAILURE directly back to READY.The subchannel connectivity state machine looks like this:- IDLE: This is the initial state.  It means that the subchannel is not connected but can start connecting whenever it is requested to do so.  When the LB policy requests a connection attempt, the subchannel transitions from IDLE to CONNECTING.- CONNECTING: This means that a connection attempt is in progress.  If the connection attempt succeeds, the subchannel will transition to READY; if the connection attempt fails, the subchannel will transition to TRANSIENT_FAILURE.- READY: This means that the subchannel is currently connected.  When the connection fails, the subchannel will transition to state IDLE.- TRANSIENT_FAILURE: This means that a connection attempt failed and the subchannel is now in backoff delay.  When the backoff period is over, the subchannel will transition back to IDLE.Note that the connectivity state reported by the LB policy is an aggregation of the connectivity states of the underlying subchannels.  In round_robin, we use the following rules to compute the aggregated connectivity state:https://github.com/grpc/grpc/blob/d3d2b64d234337ed67564ca7b0eb1a15871b939b/src/core/ext/filters/client_channel/lb_policy/round_robin/round_robin.cc#L379Note that round_robin never reports IDLE as the aggregated connectivity state, because when a subchannel is IDLE, we always immediately tell it to start reconnecting, so we treat IDLE as CONNECTING for aggregation purposes:https://github.com/grpc/grpc/blob/d3d2b64d234337ed67564ca7b0eb1a15871b939b/src/core/ext/filters/client_channel/lb_policy/round_robin/round_robin.cc#L475",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/31544,1016935350,2022-11-08T17:37:56Z,test/core/client_channel/lb_policy/lb_policy_test_lib.h,"@@ -451,7 +465,31 @@ class LoadBalancingPolicyTest : public ::testing::Test {     auto uri = grpc_sockaddr_to_uri(&subchannel->address());     ASSERT_TRUE(uri.ok()) << uri.status() << "" at "" << location.file() << "":""                           << location.line();-    EXPECT_EQ(*uri, address_uri) << location.file() << "":"" << location.line();+    out_picked_uri = *uri;+  }++  // Requests a pick on picker and expects a Complete result whose+  // subchannel has the specified address.+  void ExpectPickComplete(LoadBalancingPolicy::SubchannelPicker* picker,+                          absl::string_view address_uri,+                          SourceLocation location = SourceLocation()) {+    absl::optional<std::string> picked_uri;+    GetPickedAddress(picker, picked_uri, location);+    EXPECT_EQ(*picked_uri, address_uri)+        << location.file() << "":"" << location.line();+  }++  // Requests a pick on picker and expects a Fail result.+  void ExpectPickFail(LoadBalancingPolicy::SubchannelPicker* picker,","This method should check the status with which the LB policy fails the pick, since that status will wind up being used as the failure status of the data plane RPC, and we want to make sure that such statuses are properly helpful for our users.I suggest adding a required parameter of type `std::function<void(absl::Status)>` that we will pass the failure status to.  The caller can pass in a lambda that checks the status code and value.",
1644595,gnossen,https://api.github.com/repos/grpc/grpc/pulls/31514,1017008840,2022-11-08T18:58:22Z,src/python/grpcio/grpc/_interceptor.py,"@@ -547,7 +587,8 @@ def close(self):         self._channel.close()  -def intercept_channel(channel, *interceptors):+def intercept_channel(channel: grpc.Channel,+                      *interceptors: Optional[Sequence[Any]]) -> grpc.Channel:","[You mean this check?](https://github.com/grpc/grpc/blob/d3d2b64d234337ed67564ca7b0eb1a15871b939b/src/python/grpcio/grpc/_interceptor.py#L551) Not everyone uses type annotations. Technically speaking this would be a regression, so I'm leaning away from that.",
672669,sergiitk,https://api.github.com/repos/grpc/grpc/pulls/31569,1017209261,2022-11-08T23:09:33Z,tools/internal_ci/linux/grpc_xds_k8s_xlang.sh,"@@ -44,13 +49,14 @@ readonly VERSION_TAG=""master v1.50.x"" run_test() {   # Test driver usage:   # https://github.com/grpc/grpc/tree/master/tools/run_tests/xds_k8s_test_driver#basic-usage-  local tag=""${1:?Usage: run_test tag server_lang client_lang}""-  local slang=""${2:?Usage: run_test tag server_lang client_lang}""-  local clang=""${3:?Usage: run_test tag server_lang client_lang}""-  local server_image_name=""${IMAGE_REPO}/${slang}-server:${tag}""-  local client_image_name=""${IMAGE_REPO}/${clang}-client:${tag}""+  local stag=""${1:?Usage: run_test server_tag client_tag server_lang client_lang}""","1) Can we reorder the args to group server lang with server tag, and client lang and client tag? This will read more natural2) Tag is ambiguous here. In other scripts it make sense, because it's SHA of the commit, and refers to the docker tag. Here it's not as clear - I was thinking initially we're talking about git tags. Let's call it branch? It'll align with ""cross-branch"" even more.`Usage: run_test client_lang client_branch server_lang server_branch`",
14166415,sanjaypujare,https://api.github.com/repos/grpc/grpc/pulls/31569,1017264950,2022-11-09T00:35:33Z,tools/internal_ci/linux/grpc_xds_k8s_xlang.sh,"@@ -128,6 +139,34 @@ main() {     echo ""Failed test suites: ${failed_tests}""     done   done+  # Run cross branch tests per language: master x latest and master x oldest+  for LANG in ${CLIENT_LANG}",No particular reason - they both happen to be the same list so it doesn't really matter but I have to choose *one* list (since this is cross branch for one language at a time),
2793282,veblush,https://api.github.com/repos/grpc/grpc/pulls/31571,1018323997,2022-11-09T19:16:03Z,test/cpp/ext/gcp/observability_logging_sink_test.cc,"@@ -0,0 +1,306 @@+//+// Copyright 2022 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+//++#include ""src/cpp/ext/gcp/observability_logging_sink.h""++#include ""gmock/gmock.h""+#include ""gtest/gtest.h""++#include ""test/core/util/test_config.h""++namespace grpc {+namespace internal {++namespace {++TEST(GcpObservabilityLoggingSinkTest, LoggingConfigEmpty) {+  const char* json_str = R""json({+      ""cloud_logging"": {+      }+    })json"";+  auto json = grpc_core::Json::Parse(json_str);+  ASSERT_TRUE(json.ok()) << json.status();+  grpc_core::ValidationErrors errors;+  auto config = grpc_core::LoadFromJson<GcpObservabilityConfig>(+      *json, grpc_core::JsonArgs(), &errors);+  ASSERT_TRUE(errors.ok()) << errors.status(""unexpected errors"");+  ObservabilityLoggingSink sink(config.cloud_logging.value());+  // client test+  EXPECT_EQ(sink.FindMatch(true, ""foo/bar""), LoggingSink::Config(0, 0));+  // server test+  EXPECT_EQ(sink.FindMatch(false, ""foo/bar""), LoggingSink::Config(0, 0));+}++TEST(GcpObservabilityLoggingSinkTest, LoggingConfigClientWildCardEntries) {+  const char* json_str = R""json({+      ""cloud_logging"": {+        ""client_rpc_events"": [+          {+            ""methods"": [""*""],+            ""max_metadata_bytes"": 4096,+            ""max_message_bytes"": 4096","nit: how about having different values for max_metadata_bytes and max_message_bytes like 1024 and 4096 respectively so that LoggingSink::Config(1024, 4096) looks easy to understand what's for what.",
4181124,yashykt,https://api.github.com/repos/grpc/grpc/pulls/31571,1018387425,2022-11-09T20:32:47Z,src/cpp/ext/filters/logging/logging_sink.h,"@@ -0,0 +1,61 @@+//+//+// Copyright 2022 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+//+//++#ifndef GRPC_INTERNAL_CPP_EXT_FILTERS_LOGGING_LOGGING_SINK_H+#define GRPC_INTERNAL_CPP_EXT_FILTERS_LOGGING_LOGGING_SINK_H++#include <grpc/support/port_platform.h>++#include ""absl/strings/string_view.h""++namespace grpc {+namespace internal {++// Interface for a logging sink that will be used by the logging filter.+class LoggingSink {+ public:+  class Config {+   public:+    Config(uint32_t max_metadata_bytes, uint32_t max_message_bytes)+        : max_metadata_bytes_(max_metadata_bytes),+          max_message_bytes_(max_message_bytes) {}+    bool MetadataLoggingEnabled() { return max_metadata_bytes_ != 0; }+    bool MessageLoggingEnabled() { return max_message_bytes_ != 0; }+    bool ShouldLog() {+      return MetadataLoggingEnabled() || MessageLoggingEnabled();+    }++    bool operator==(const Config& other) const {+      return max_metadata_bytes_ == other.max_metadata_bytes_ &&+             max_message_bytes_ == other.max_message_bytes_;+    }++   private:+    uint32_t max_metadata_bytes_;+    uint32_t max_message_bytes_;+  };++  virtual ~LoggingSink() = default;++  virtual Config FindMatch(bool is_client, absl::string_view path) = 0;","There are two fields - metadata and message which can have different logging configurations, and as per go/totw/123#when-not-to-use-stdoptional, we shouldn't be using optional if we already have a distinguished value for such cases. In this case, 0 already means - do not log, so adding an optional, just unnecessarily adds a bool",
17583509,zeromath,https://api.github.com/repos/grpc/grpc/pulls/29728,1018456924,2022-11-09T22:03:04Z,src/core/tsi/ssl_transport_security_utils.h,"@@ -0,0 +1,147 @@+/*+ *+ * Copyright 2022 gRPC authors.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ *     http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ *+ */++#ifndef GRPC_CORE_TSI_SSL_TRANSPORT_SECURITY_UTILS_H+#define GRPC_CORE_TSI_SSL_TRANSPORT_SECURITY_UTILS_H++#include <grpc/support/port_platform.h>++#include <openssl/x509.h>++#include ""absl/strings/string_view.h""++#include <grpc/grpc_security_constants.h>++#include ""src/core/tsi/ssl/key_logging/ssl_key_logging.h""+#include ""src/core/tsi/transport_security_interface.h""++namespace grpc_core {++// Converts an SSL error status code to a readable string.+//+// error: the SSL error status code.+//+// return: the corresponding status string.+const char* SslErrorString(int error);++// Logs the SSL error stack.+void LogSslErrorStack(void);++// Performs an SSL_write and handle errors.+//+// ssl: the SSL object to write to.+// unprotected_bytes: the buffer containing the bytes for writing to |ssl|.+// unprotected_bytes_size: the size of the buffer |unprotected_bytes|.+//+// return: TSI_OK if the write operation succeeds or corresponding TSI errors.+tsi_result DoSslWrite(SSL* ssl, unsigned char* unprotected_bytes,",I prefer to make those changes in a separate PR. I looked up the list of `tsi_result` values and `absl::Status` and I didn't see a perfect match between these two lists. I think more work is needed to do this conversion so it is better to leave them to future PRs.,
1644595,gnossen,https://api.github.com/repos/grpc/grpc/pulls/31601,1018585701,2022-11-10T02:13:40Z,src/python/grpcio/grpc/_cython/_cygrpc/event.pxd.pxi,"@@ -12,15 +12,17 @@ # See the License for the specific language governing permissions and # limitations under the License. +cdef class BaseEvent:","Now that this exists, you can make the [return type of `_Tag.event`](https://github.com/grpc/grpc/blob/54dd7563c2d563bff74e4b558f2e985db4a01f2d/src/python/grpcio/grpc/_cython/_cygrpc/tag.pxd.pxi#L18) more specific than `object`.",
5663878,yijiem,https://api.github.com/repos/grpc/grpc/pulls/31564,1018697894,2022-11-10T06:29:41Z,src/core/lib/transport/handshaker.cc,"@@ -201,10 +197,15 @@ void HandshakeManager::DoHandshake(grpc_endpoint* endpoint,     GRPC_CLOSURE_INIT(&on_handshake_done_, on_handshake_done, &args_,                       grpc_schedule_on_exec_ctx);     // Start deadline timer, which owns a ref.-    Ref().release();-    GRPC_CLOSURE_INIT(&on_timeout_, &HandshakeManager::OnTimeoutFn, this,-                      grpc_schedule_on_exec_ctx);-    grpc_timer_init(&deadline_timer_, deadline, &on_timeout_);+    const Duration time_to_deadline = deadline - Timestamp::Now();+    deadline_timer_handle_ =+        event_engine_->RunAfter(time_to_deadline, [self = Ref()]() mutable {+          ApplicationCallbackExecCtx callback_exec_ctx;+          ExecCtx exec_ctx;+          self->Shutdown(GRPC_ERROR_CREATE(""Handshake timed out""));+          // HandshakeManager deletion might require an active ExecCtx.","This is mostly based on the code here: https://github.com/grpc/grpc/blob/05ab5c08a468a1555b07fd9a70cb9edc5bb849d7/src/core/ext/filters/client_channel/subchannel.cc#L928The closure holds a ref to the HandshakeManager and when it is destructed it triggers a series of destruction steps on the event_engine thread which may need an ExecCtx to be live on the thread. Thus, self.reset() triggers this process before the previous ExecCtx is destructed. Otherwise we may see this crash in one of the tests: https://paste.googleplex.com/4627665280565248",
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/31591,1019408907,2022-11-10T17:11:35Z,tools/dockerfile/push_testing_images.sh,"@@ -57,12 +69,70 @@ do     DOCKER_IMAGE_TAG=$(sha1sum $DOCKERFILE_DIR/Dockerfile | cut -f1 -d\ )   fi -  # skip the image if it already exists in the repo -  curl --silent -f -lSL https://registry.hub.docker.com/v2/repositories/${DOCKERHUB_ORGANIZATION}/${DOCKER_IMAGE_NAME}/tags/${DOCKER_IMAGE_TAG} > /dev/null \-      && continue+  echo ""Visiting ${DOCKERFILE_DIR}""++  # SKIP_REMOTE controls whether artifact registry are going to be queried at all.+  if [ ""${SKIP_REMOTE}"" == """" ]+  then+    DOCKER_IMAGE_DIGEST_REMOTE=$(gcloud artifacts docker images describe ""${ARTIFACT_REGISTRY_PREFIX}/${DOCKER_IMAGE_NAME}:${DOCKER_IMAGE_TAG}"" --format=json | jq -r '.image_summary.digest')++    if [ ""${DOCKER_IMAGE_DIGEST_REMOTE}"" != """" ]+    then+      # skip building the image if it already exists in the destination registry+      echo ""Docker image ${DOCKER_IMAGE_NAME} already exists in artifact registry at the right version (tag ${DOCKER_IMAGE_TAG}).""++      # TODO: (sanity check) if remote check requested, check that the remote digest matches what's currently in the .current_version file.++      # update info on what we consider to be the current version of the docker image (which will be used to run tests)+      # we consider the sha256 image digest info from the artifact registry to be the canonical one+      echo -n ""${ARTIFACT_REGISTRY_PREFIX}/${DOCKER_IMAGE_NAME}:${DOCKER_IMAGE_TAG}@${DOCKER_IMAGE_DIGEST_REMOTE}"" >${DOCKERFILE_DIR}.current_version -  docker build -t ${DOCKERHUB_ORGANIZATION}/${DOCKER_IMAGE_NAME}:${DOCKER_IMAGE_TAG} ${DOCKERFILE_DIR}+      continue+    fi -  # ""docker login"" needs to be run in advance-  docker push ${DOCKERHUB_ORGANIZATION}/${DOCKER_IMAGE_NAME}:${DOCKER_IMAGE_TAG}+    # TODO: (sanity check) if remote check requested, fail here since not all images have been uploaded to artifact registry+  fi++  # if the .current_version file doesn't exist or it doesn't contain the right SHA checksum,+  # it is out of date and we will need to rebuild the docker image locally.+  LOCAL_BUILD_REQUIRED=""""+  grep ""^${ARTIFACT_REGISTRY_PREFIX}/${DOCKER_IMAGE_NAME}:${DOCKER_IMAGE_TAG}@sha256:.*"" ${DOCKERFILE_DIR}.current_version >/dev/null && LOCAL_BUILD_REQUIRED=true","Shouldn't it be the opposite condition? If `.current_version` contains the right Dockerfile checksum, then LOCAL_BUILD_REQUIRED should be false. If you're trying to leverage short-circuit evaluation, I think you'd want an `||` here instead of an `&&`.",
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/31591,1019412605,2022-11-10T17:14:59Z,tools/dockerfile/push_testing_images.sh,"@@ -57,12 +69,70 @@ do     DOCKER_IMAGE_TAG=$(sha1sum $DOCKERFILE_DIR/Dockerfile | cut -f1 -d\ )   fi -  # skip the image if it already exists in the repo -  curl --silent -f -lSL https://registry.hub.docker.com/v2/repositories/${DOCKERHUB_ORGANIZATION}/${DOCKER_IMAGE_NAME}/tags/${DOCKER_IMAGE_TAG} > /dev/null \-      && continue+  echo ""Visiting ${DOCKERFILE_DIR}""++  # SKIP_REMOTE controls whether artifact registry are going to be queried at all.+  if [ ""${SKIP_REMOTE}"" == """" ]+  then+    DOCKER_IMAGE_DIGEST_REMOTE=$(gcloud artifacts docker images describe ""${ARTIFACT_REGISTRY_PREFIX}/${DOCKER_IMAGE_NAME}:${DOCKER_IMAGE_TAG}"" --format=json | jq -r '.image_summary.digest')++    if [ ""${DOCKER_IMAGE_DIGEST_REMOTE}"" != """" ]+    then+      # skip building the image if it already exists in the destination registry+      echo ""Docker image ${DOCKER_IMAGE_NAME} already exists in artifact registry at the right version (tag ${DOCKER_IMAGE_TAG}).""++      # TODO: (sanity check) if remote check requested, check that the remote digest matches what's currently in the .current_version file.++      # update info on what we consider to be the current version of the docker image (which will be used to run tests)+      # we consider the sha256 image digest info from the artifact registry to be the canonical one+      echo -n ""${ARTIFACT_REGISTRY_PREFIX}/${DOCKER_IMAGE_NAME}:${DOCKER_IMAGE_TAG}@${DOCKER_IMAGE_DIGEST_REMOTE}"" >${DOCKERFILE_DIR}.current_version -  docker build -t ${DOCKERHUB_ORGANIZATION}/${DOCKER_IMAGE_NAME}:${DOCKER_IMAGE_TAG} ${DOCKERFILE_DIR}+      continue+    fi -  # ""docker login"" needs to be run in advance-  docker push ${DOCKERHUB_ORGANIZATION}/${DOCKER_IMAGE_NAME}:${DOCKER_IMAGE_TAG}+    # TODO: (sanity check) if remote check requested, fail here since not all images have been uploaded to artifact registry+  fi++  # if the .current_version file doesn't exist or it doesn't contain the right SHA checksum,+  # it is out of date and we will need to rebuild the docker image locally.+  LOCAL_BUILD_REQUIRED=""""+  grep ""^${ARTIFACT_REGISTRY_PREFIX}/${DOCKER_IMAGE_NAME}:${DOCKER_IMAGE_TAG}@sha256:.*"" ${DOCKERFILE_DIR}.current_version >/dev/null && LOCAL_BUILD_REQUIRED=true++  if [ ""${LOCAL_BUILD_REQUIRED}"" != """" ]+  then+    echo ""Dockerfile for ${DOCKER_IMAGE_NAME} hasn't changed. Will skip 'docker build'.""+    continue+  fi++  # TODO: (sanity check) if in check mode, fail here since the .current_version file is either missing or out of date++  if [ ""${TRANSFER_FROM_DOCKERHUB}"" == """" ]+  then+    echo ""Running 'docker build' for ${DOCKER_IMAGE_NAME}""+    echo ""==========""+    docker build -t ${ARTIFACT_REGISTRY_PREFIX}/${DOCKER_IMAGE_NAME}:${DOCKER_IMAGE_TAG} ${DOCKERFILE_DIR}+    echo ""==========""+  else+    # TRANSFER_FROM_DOCKERHUB is a temporary feature that pulls the corresponding image from dockerhub instead","The user would have to set this env var, right? Do you have plans for how to use it? If so, it might be worth putting an expiration date here so we know when we should remove this temporary thing.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/31607,1019476703,2022-11-10T18:24:26Z,src/core/ext/filters/client_channel/lb_policy/subchannel_list.h,"@@ -324,8 +324,8 @@ void SubchannelData<SubchannelListType,   pending_watcher_ =       new Watcher(this, subchannel_list()->WeakRef(DEBUG_LOCATION, ""Watcher""));   subchannel_->WatchConnectivityState(-      std::unique_ptr<SubchannelInterface::ConnectivityStateWatcherInterface>(-          pending_watcher_));+      std::unique_ptr<SubchannelInterface::ConnectivityStateWatcherInterface>{","Why is this change necessary?  `std::unique_ptr<SubchannelInterface::ConnectivityStateWatcherInterface>` is a class type, so parens should be fine here.  This is not a cast, it's constructing a new object.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/31607,1019485788,2022-11-10T18:34:16Z,test/core/transport/binder/binder_transport_test.cc,"@@ -192,8 +192,8 @@ class MetadataEncoder {   template <typename Which>   void Encode(Which, const typename Which::ValueType& value) {     metadata_.emplace_back(-        std::string(Which::key()),-        std::string(grpc_core::Slice(Which::Encode(value)).as_string_view()));+        std::string{Which::key()},","`std::string` is a class, so this should not require braces.  It's constructing a new object, not doing a cast.",
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/31564,1019633194,2022-11-10T21:34:37Z,src/core/lib/transport/handshaker.h,"@@ -97,16 +100,18 @@ class Handshaker : public RefCounted<Handshaker> {  class HandshakeManager : public RefCounted<HandshakeManager> {  public:-  HandshakeManager();+  explicit HandshakeManager(+      std::shared_ptr<grpc_event_engine::experimental::EventEngine>","That could work, the args should still be the same when cancellation needs to occur later. And it would mean not having to do a cherrypick. FYI Yijie, if `args_.args` are reset as on line 117, then it won't contain the EventEngine, only preconditioned ChannelArgs are guaranteed to have them.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/31564,1019636854,2022-11-10T21:39:53Z,src/core/lib/transport/handshaker.h,"@@ -97,16 +100,18 @@ class Handshaker : public RefCounted<Handshaker> {  class HandshakeManager : public RefCounted<HandshakeManager> {  public:-  HandshakeManager();+  explicit HandshakeManager(+      std::shared_ptr<grpc_event_engine::experimental::EventEngine>","We can still save the shared_ptr as a data member of `HandshakeManager`.  That way, we don't have to worry about channel args being manipulated by one of the handshakers and potentially pointing to a different EE instance later when we want to cancel the timer.All I'm really arguing here is that instead of passing the EE instance to the ctor, we can just set it from channel args in `DoHandshake()`.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/31607,1019656499,2022-11-10T22:08:58Z,test/core/transport/binder/binder_transport_test.cc,"@@ -192,8 +192,8 @@ class MetadataEncoder {   template <typename Which>   void Encode(Which, const typename Which::ValueType& value) {     metadata_.emplace_back(-        std::string(Which::key()),-        std::string(grpc_core::Slice(Which::Encode(value)).as_string_view()));+        std::string{Which::key()},","I believe that calls the initializer_list ctor, not the single-argument ctor.  But there's no reason we should need to do that here.  The braces are ugly and confusing, and they really don't provide any benefit in this case.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/31564,1019711690,2022-11-10T23:51:22Z,src/core/lib/transport/handshaker.h,"@@ -122,37 +125,39 @@ class HandshakeManager : public RefCounted<HandshakeManager> {   /// the arguments.   void DoHandshake(grpc_endpoint* endpoint, const ChannelArgs& channel_args,                    Timestamp deadline, grpc_tcp_server_acceptor* acceptor,-                   grpc_iomgr_cb_func on_handshake_done, void* user_data);+                   grpc_iomgr_cb_func on_handshake_done, void* user_data)+      ABSL_LOCKS_EXCLUDED(mu_);   private:-  bool CallNextHandshakerLocked(grpc_error_handle error);+  bool CallNextHandshakerLocked(grpc_error_handle error)+      ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu_);    // A function used as the handshaker-done callback when chaining   // handshakers together.-  static void CallNextHandshakerFn(void* arg, grpc_error_handle error);--  // Callback invoked when deadline is exceeded.-  static void OnTimeoutFn(void* arg, grpc_error_handle error);+  static void CallNextHandshakerFn(void* arg, grpc_error_handle error)+      ABSL_LOCKS_EXCLUDED(mu_);    static const size_t HANDSHAKERS_INIT_SIZE = 2;    Mutex mu_;-  bool is_shutdown_ = false;+  bool is_shutdown_ ABSL_GUARDED_BY(mu_) = false;   // An array of handshakers added via grpc_handshake_manager_add().   absl::InlinedVector<RefCountedPtr<Handshaker>, HANDSHAKERS_INIT_SIZE>-      handshakers_;+      handshakers_ ABSL_GUARDED_BY(mu_);   // The index of the handshaker to invoke next and closure to invoke it.-  size_t index_ = 0;-  grpc_closure call_next_handshaker_;+  size_t index_ ABSL_GUARDED_BY(mu_) = 0;+  grpc_closure call_next_handshaker_ ABSL_GUARDED_BY(mu_);   // The acceptor to call the handshakers with.-  grpc_tcp_server_acceptor* acceptor_;+  grpc_tcp_server_acceptor* acceptor_ ABSL_GUARDED_BY(mu_);   // Deadline timer across all handshakers.","Suggest moving these 3 lines down to line 159, so it's right next to the EE data member.",
2793282,veblush,https://api.github.com/repos/grpc/grpc/pulls/31607,1019717768,2022-11-11T00:04:51Z,test/core/transport/binder/binder_transport_test.cc,"@@ -192,8 +192,8 @@ class MetadataEncoder {   template <typename Which>   void Encode(Which, const typename Which::ValueType& value) {     metadata_.emplace_back(-        std::string(Which::key()),-        std::string(grpc_core::Slice(Which::Encode(value)).as_string_view()));+        std::string{Which::key()},",This could be actually both a regular ctor and initializer_list ctor. Yay another C++ thing! But I'm adding NOLINT comment here.,
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/31544,1019719244,2022-11-11T00:08:24Z,test/core/client_channel/lb_policy/round_robin_test.cc,"@@ -0,0 +1,251 @@+//+// Copyright 2022 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+//++#include <stddef.h>++#include <algorithm>+#include <map>+#include <memory>+#include <utility>+#include <vector>++#include ""absl/status/status.h""+#include ""absl/status/statusor.h""+#include ""absl/strings/string_view.h""+#include ""gtest/gtest.h""++#include <grpc/grpc.h>++#include ""src/core/ext/filters/client_channel/subchannel_pool_interface.h""+#include ""src/core/lib/channel/channel_args.h""+#include ""src/core/lib/gprpp/orphanable.h""+#include ""src/core/lib/iomgr/resolved_address.h""+#include ""src/core/lib/load_balancing/lb_policy.h""+#include ""src/core/lib/resolver/server_address.h""+#include ""test/core/client_channel/lb_policy/lb_policy_test_lib.h""+#include ""test/core/util/test_config.h""++namespace grpc_core {+namespace testing {+namespace {++class RoundRobinTest : public LoadBalancingPolicyTest {+ public:+  OrphanablePtr<LoadBalancingPolicy> RoundRobinPolicy(+      size_t channelsCount = 3) {+    LoadBalancingPolicy::UpdateArgs update_args;+    update_args.addresses.emplace();+    for (size_t i = 0; i < channelsCount; ++i) {+      update_args.addresses->emplace_back(MakeAddress(UriForSubchannel(i)),+                                          ChannelArgs());+    }+    auto policy = MakeLbPolicy(""round_robin"");+    absl::Status status = ApplyUpdate(std::move(update_args), policy.get());+    EXPECT_TRUE(status.ok()) << status;+    EXPECT_EQ(channelsCount, subchannel_pool_.size());+    for (size_t i = 0; i < subchannel_pool_.size(); ++i) {+      ExpectState(GRPC_CHANNEL_CONNECTING);+    }+    return policy;+  }++  void SetSubchannelConnectivityState(+      size_t subchannel, grpc_connectivity_state new_state,+      absl::Status status = absl::OkStatus(),+      SourceLocation location = SourceLocation()) {+    auto it = subchannel_pool_.find(+        {MakeAddress(UriForSubchannel(subchannel)), ChannelArgs()});+    ASSERT_NE(it, subchannel_pool_.end())+        << location.file() << "":"" << location.line();+    it->second.SetConnectivityState(new_state, status);+  }++  bool ConnectionRequested(size_t subchannel) {+    auto it = subchannel_pool_.find(+        {MakeAddress(UriForSubchannel(subchannel)), ChannelArgs()});+    return it->second.ConnectionRequested();+  }++  std::string UriForSubchannel(size_t index) {+    std::stringstream out;+    out << ""ipv4:127.0.0.1:44"" << (index + 1);+    return out.str();+  }+};++TEST_F(RoundRobinTest, SingleChannel) {+  auto policy = RoundRobinPolicy(1);+  // LB policy should have reported CONNECTING state.+  auto picker = ExpectState(GRPC_CHANNEL_CONNECTING);+  ExpectPickQueued(picker.get());+  // LB policy should have requested a connection on this subchannel.+  EXPECT_TRUE(ConnectionRequested(0));++  SetSubchannelConnectivityState(0, GRPC_CHANNEL_CONNECTING);+  picker = ExpectState(GRPC_CHANNEL_CONNECTING);+  ExpectPickQueued(picker.get());++  // Channel is ready+  SetSubchannelConnectivityState(0, GRPC_CHANNEL_READY);+  picker = ExpectState(GRPC_CHANNEL_READY);+  // Picker should return the same subchannel repeatedly.+  for (size_t i = 0; i < 3; ++i) {+    ExpectPickComplete(picker.get(), UriForSubchannel(0));+  }+  ExpectNoStateChange();++  // There's a failure+  SetSubchannelConnectivityState(0, GRPC_CHANNEL_TRANSIENT_FAILURE);+  ExpectReresolutionRequest();+  picker = ExpectState(GRPC_CHANNEL_TRANSIENT_FAILURE);+  ExpectPickFail(picker.get());++  // ... and a recovery!+  SetSubchannelConnectivityState(0, GRPC_CHANNEL_READY);+  picker = ExpectState(GRPC_CHANNEL_READY);+  ExpectPickComplete(picker.get(), UriForSubchannel(0));++  ExpectNoStateChange();+}++TEST_F(RoundRobinTest, ThreeSubchannels) {+  auto policy = RoundRobinPolicy(3);+  // LB policy should have reported CONNECTING state.+  auto picker = ExpectState(GRPC_CHANNEL_CONNECTING);+  ExpectPickQueued(picker.get());+  // LB policy should have requested a connection on this subchannel.+  EXPECT_TRUE(ConnectionRequested(0));++  for (size_t i = 0; i < 3; ++i) {+    SetSubchannelConnectivityState(i, GRPC_CHANNEL_CONNECTING);+    picker = ExpectState(GRPC_CHANNEL_CONNECTING);+  }+  ExpectPickQueued(picker.get());++  // Only one channel is ready+  SetSubchannelConnectivityState(0, GRPC_CHANNEL_READY);+  picker = ExpectState(GRPC_CHANNEL_READY);+  // Picker should return the same subchannel repeatedly.+  for (size_t i = 0; i < 3; ++i) {+    ExpectPickComplete(picker.get(), UriForSubchannel(0));+  }+  ExpectNoStateChange();++  // All channels ready+  SetSubchannelConnectivityState(1, GRPC_CHANNEL_READY);+  SetSubchannelConnectivityState(2, GRPC_CHANNEL_READY);+  ExpectState(GRPC_CHANNEL_READY);+  picker = ExpectState(GRPC_CHANNEL_READY);++  std::unordered_set<std::string> reportedUris;+  // Picker should return each address once, we do not care about the order.+  for (size_t i = 0; i < 20; ++i) {","We do actually want to check that the subchannels are returned in the right order.  If we send 30 RPCs and the LB policy sends the first 10 to the first subchannel, the next 10 to the next subchannel, and the last 10 to the last subchannel, that's not round robin.The fact that we restart at a random point in the list when we create a new picker is a bit of a wart, and it's done that way mainly to avoid the complexity of trying to share state between the picker and the LB policy.  But we don't create new pickers that often, so the vast majority of the time, users see even distribution, and we need to make sure that that more common behavior is correct.",
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/31591,1019970866,2022-11-11T08:04:11Z,tools/dockerfile/push_testing_images.sh,"@@ -57,12 +69,70 @@ do     DOCKER_IMAGE_TAG=$(sha1sum $DOCKERFILE_DIR/Dockerfile | cut -f1 -d\ )   fi -  # skip the image if it already exists in the repo -  curl --silent -f -lSL https://registry.hub.docker.com/v2/repositories/${DOCKERHUB_ORGANIZATION}/${DOCKER_IMAGE_NAME}/tags/${DOCKER_IMAGE_TAG} > /dev/null \-      && continue+  echo ""Visiting ${DOCKERFILE_DIR}""++  # SKIP_REMOTE controls whether artifact registry are going to be queried at all.+  if [ ""${SKIP_REMOTE}"" == """" ]+  then+    DOCKER_IMAGE_DIGEST_REMOTE=$(gcloud artifacts docker images describe ""${ARTIFACT_REGISTRY_PREFIX}/${DOCKER_IMAGE_NAME}:${DOCKER_IMAGE_TAG}"" --format=json | jq -r '.image_summary.digest')++    if [ ""${DOCKER_IMAGE_DIGEST_REMOTE}"" != """" ]+    then+      # skip building the image if it already exists in the destination registry+      echo ""Docker image ${DOCKER_IMAGE_NAME} already exists in artifact registry at the right version (tag ${DOCKER_IMAGE_TAG}).""++      # TODO: (sanity check) if remote check requested, check that the remote digest matches what's currently in the .current_version file.++      # update info on what we consider to be the current version of the docker image (which will be used to run tests)+      # we consider the sha256 image digest info from the artifact registry to be the canonical one+      echo -n ""${ARTIFACT_REGISTRY_PREFIX}/${DOCKER_IMAGE_NAME}:${DOCKER_IMAGE_TAG}@${DOCKER_IMAGE_DIGEST_REMOTE}"" >${DOCKERFILE_DIR}.current_version -  docker build -t ${DOCKERHUB_ORGANIZATION}/${DOCKER_IMAGE_NAME}:${DOCKER_IMAGE_TAG} ${DOCKERFILE_DIR}+      continue+    fi -  # ""docker login"" needs to be run in advance-  docker push ${DOCKERHUB_ORGANIZATION}/${DOCKER_IMAGE_NAME}:${DOCKER_IMAGE_TAG}+    # TODO: (sanity check) if remote check requested, fail here since not all images have been uploaded to artifact registry+  fi++  # if the .current_version file doesn't exist or it doesn't contain the right SHA checksum,+  # it is out of date and we will need to rebuild the docker image locally.+  LOCAL_BUILD_REQUIRED=""""+  grep ""^${ARTIFACT_REGISTRY_PREFIX}/${DOCKER_IMAGE_NAME}:${DOCKER_IMAGE_TAG}@sha256:.*"" ${DOCKERFILE_DIR}.current_version >/dev/null && LOCAL_BUILD_REQUIRED=true","you're right, that's what I had originally, but it didn't work but now I'm realizing that the condition below `""${LOCAL_BUILD_REQUIRED}"" != """"` is also reversed. That's why `||` didn't work when I tried it.Thanks for catching this.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/31626,1020420052,2022-11-11T17:23:07Z,src/core/lib/security/credentials/external/aws_external_account_credentials.cc,"@@ -73,6 +77,18 @@ std::string UrlEncode(const absl::string_view& s) {   return result; } +bool ValidateAwsUrl(const std::string& urlString) {+  absl::StatusOr<grpc_core::URI> url = grpc_core::URI::Parse(urlString);+  if (!url.ok()) return false;+  absl::string_view host;+  absl::string_view port;+  grpc_core::SplitHostPort(url->authority(), &host, &port);+  if (host == awsEc2MetadataIpv4Address || host == awsEc2MetadataIpv6Address) {",This can just say:```return host == awsEc2MetadataIpv4Address || host == awsEc2MetadataIpv6Address;```,
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/31544,1020633331,2022-11-12T01:32:09Z,test/core/client_channel/lb_policy/lb_policy_test_lib.h,"@@ -433,63 +433,66 @@ class LoadBalancingPolicyTest : public ::testing::Test {     return final_picker;   } -  // Requests a pick on picker and expects a Queue result.-  void ExpectPickQueued(LoadBalancingPolicy::SubchannelPicker* picker,-                        SourceLocation location = SourceLocation()) {+  LoadBalancingPolicy::PickResult PerformPick(+      LoadBalancingPolicy::SubchannelPicker* picker) {     ExecCtx exec_ctx;     FakeMetadata metadata({});     FakeCallState call_state;-    auto pick_result =-        picker->Pick({""/service/method"", &metadata, &call_state});+    return picker->Pick({""/service/method"", &metadata, &call_state});+  }++  // Requests a pick on picker and expects a Queue result.+  void ExpectPickQueued(LoadBalancingPolicy::SubchannelPicker* picker,+                        SourceLocation location = SourceLocation()) {+    auto pick_result = PerformPick(picker);     ASSERT_TRUE(absl::holds_alternative<LoadBalancingPolicy::PickResult::Queue>(         pick_result.result))         << location.file() << "":"" << location.line();   }    // Requests a pick on picker and return the address from a Complete result.   // Has to be void and use output argument so the assertions still work-  void GetPickedAddress(LoadBalancingPolicy::SubchannelPicker* picker,-                        absl::optional<std::string>& out_picked_uri,-                        SourceLocation location = SourceLocation()) {-    out_picked_uri.reset();-    ExecCtx exec_ctx;-    FakeMetadata metadata({});-    FakeCallState call_state;-    auto pick_result =-        picker->Pick({""/service/method"", &metadata, &call_state});+  absl::optional<std::string> ExpectPickAddress(","In #31632, I've changed `ExpectPickComplete()` to return the resulting address, so there's no longer any need for a duplicate method that does basically the same thing.",X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/31544,1020636748,2022-11-12T01:51:26Z,test/core/client_channel/lb_policy/round_robin_test.cc,"@@ -44,186 +44,256 @@ namespace {  class RoundRobinTest : public LoadBalancingPolicyTest {  public:-  OrphanablePtr<LoadBalancingPolicy> RoundRobinPolicy(-      size_t channelsCount = 3) {+  LoadBalancingPolicy::UpdateArgs BuildUpdateArgs(+      absl::Span<const std::string> subchannel_addresses) {     LoadBalancingPolicy::UpdateArgs update_args;     update_args.addresses.emplace();-    for (size_t i = 0; i < channelsCount; ++i) {-      update_args.addresses->emplace_back(MakeAddress(UriForSubchannel(i)),-                                          ChannelArgs());+    for (const auto& addr : subchannel_addresses) {+      update_args.addresses->emplace_back(MakeAddress(addr), ChannelArgs());     }-    auto policy = MakeLbPolicy(""round_robin"");-    absl::Status status = ApplyUpdate(std::move(update_args), policy.get());-    EXPECT_TRUE(status.ok()) << status;-    EXPECT_EQ(channelsCount, subchannel_pool_.size());+    return update_args;+  }++  void ExpectAllChannelsConnecting() {","I think this method is not needed.I don't think we should expect any particular number of CONNECTING notifications, for two reasons.  First, it doesn't really make sense to assume that the number of CONNECTING notifications will be the number of subchannels in the pool, because there will be many cases where that won't be true.  But second, and more importantly, the fact that we currently return one CONNECTING notification for each subchannel is basically an implementation detail that we shouldn't rely on in the test.Instead, I think the pattern we should use here should be the following:- When we first send the address list to the policy, we should expect a single CONNECTING notification.  We can do this by calling `ExpectConnectingUpdate()`.- Then we can do all of the subchannel interactions (making sure the LB policy has requested a connection, then having the subchannel report CONNECTING followed by READY).- Then we want to just drain the queue of state updates, and we shouldn't care how many CONNECTING updates we see before we get a READY update.  We can do that by calling `WaitForConnected()`.Also, note that we should systemically ensure that any time we get a CONNECTING update, the resulting picker will queue picks.  The aforementioned `ExpectConnectingUpdate()` and `WaitForConnected()` methods take care of this for us, so we don't need to worry about this in individual tests.You can look at the pick_first test in #31632 for an example of the right pattern to use in individual tests.",X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/31544,1020637065,2022-11-12T01:54:04Z,test/core/client_channel/lb_policy/round_robin_test.cc,"@@ -44,186 +44,256 @@ namespace {  class RoundRobinTest : public LoadBalancingPolicyTest {","Let's add an `OrphanablePtr<LoadBalancingPolicy> lb_policy_` data member to this class, and have the ctor set it, so that we don't need to call `MakeLbPolicy()` in each individual test.  This is also consistent with how we do things in the existing pick_first and outlier_detection tests.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/31544,1020638677,2022-11-12T02:09:04Z,test/core/client_channel/lb_policy/round_robin_test.cc,"@@ -44,186 +44,256 @@ namespace {  class RoundRobinTest : public LoadBalancingPolicyTest {  public:-  OrphanablePtr<LoadBalancingPolicy> RoundRobinPolicy(-      size_t channelsCount = 3) {+  LoadBalancingPolicy::UpdateArgs BuildUpdateArgs(+      absl::Span<const std::string> subchannel_addresses) {     LoadBalancingPolicy::UpdateArgs update_args;     update_args.addresses.emplace();-    for (size_t i = 0; i < channelsCount; ++i) {-      update_args.addresses->emplace_back(MakeAddress(UriForSubchannel(i)),-                                          ChannelArgs());+    for (const auto& addr : subchannel_addresses) {+      update_args.addresses->emplace_back(MakeAddress(addr), ChannelArgs());     }-    auto policy = MakeLbPolicy(""round_robin"");-    absl::Status status = ApplyUpdate(std::move(update_args), policy.get());-    EXPECT_TRUE(status.ok()) << status;-    EXPECT_EQ(channelsCount, subchannel_pool_.size());+    return update_args;+  }++  void ExpectAllChannelsConnecting() {     for (size_t i = 0; i < subchannel_pool_.size(); ++i) {       ExpectState(GRPC_CHANNEL_CONNECTING);     }-    return policy;   } -  void SetSubchannelConnectivityState(-      size_t subchannel, grpc_connectivity_state new_state,-      absl::Status status = absl::OkStatus(),-      SourceLocation location = SourceLocation()) {-    auto it = subchannel_pool_.find(-        {MakeAddress(UriForSubchannel(subchannel)), ChannelArgs()});-    ASSERT_NE(it, subchannel_pool_.end())+  // Picker should return each address in any order.+  void ExpectPickAddresses(LoadBalancingPolicy::SubchannelPicker* picker,+                           absl::Span<const std::string> uris,+                           size_t iterations_per_uri = 3,+                           SourceLocation location = SourceLocation()) {+    std::unordered_map<std::string, int> reported_uris;+    for (size_t i = 0; i < iterations_per_uri * uris.size(); ++i) {+      auto address = ExpectPickAddress(picker);+      ASSERT_TRUE(address.has_value())+          << location.file() << "":"" << location.line();+      reported_uris[*address]++;+    }+    EXPECT_EQ(reported_uris.size(), uris.size())         << location.file() << "":"" << location.line();-    it->second.SetConnectivityState(new_state, status);-  }--  bool ConnectionRequested(size_t subchannel) {-    auto it = subchannel_pool_.find(-        {MakeAddress(UriForSubchannel(subchannel)), ChannelArgs()});-    return it->second.ConnectionRequested();-  }--  std::string UriForSubchannel(size_t index) {-    std::stringstream out;-    out << ""ipv4:127.0.0.1:44"" << (index + 1);-    return out.str();+    for (const std::string& uri : uris) {+      EXPECT_EQ(reported_uris[uri], iterations_per_uri)+          << ""Subchannel "" << uri << location.file() << "":"" << location.line();+    }   } };  TEST_F(RoundRobinTest, SingleChannel) {-  auto policy = RoundRobinPolicy(1);+  std::string uri = ""ipv4:127.0.0.1:441"";","Suggest using `absl::string_view` and making this a constant, with appropriate naming:```const absl::string_view kAddress = ""ipv4:127.0.0.1:441"";```",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/31544,1020794009,2022-11-12T18:55:26Z,test/core/client_channel/lb_policy/round_robin_test.cc,"@@ -0,0 +1,373 @@+//+// Copyright 2022 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+//++#include <stddef.h>++#include <algorithm>+#include <map>+#include <memory>+#include <utility>+#include <vector>++#include ""absl/status/status.h""+#include ""absl/status/statusor.h""+#include ""absl/strings/string_view.h""+#include ""gtest/gtest.h""++#include <grpc/grpc.h>++#include ""src/core/ext/filters/client_channel/subchannel_pool_interface.h""+#include ""src/core/lib/channel/channel_args.h""+#include ""src/core/lib/gprpp/orphanable.h""+#include ""src/core/lib/iomgr/resolved_address.h""+#include ""src/core/lib/load_balancing/lb_policy.h""+#include ""src/core/lib/resolver/server_address.h""+#include ""test/core/client_channel/lb_policy/lb_policy_test_lib.h""+#include ""test/core/util/test_config.h""++namespace grpc_core {+namespace testing {+namespace {++class RoundRobinTest : public LoadBalancingPolicyTest {+ public:+  LoadBalancingPolicy::UpdateArgs BuildUpdateArgs(+      absl::Span<const std::string> subchannel_addresses) {+    LoadBalancingPolicy::UpdateArgs update_args;+    update_args.addresses.emplace();+    for (const auto& addr : subchannel_addresses) {+      update_args.addresses->emplace_back(MakeAddress(addr), ChannelArgs());+    }+    return update_args;+  }++  void ExpectAllChannelsConnecting() {+    for (size_t i = 0; i < subchannel_pool_.size(); ++i) {+      ExpectState(GRPC_CHANNEL_CONNECTING);+    }+  }++  // Picker should return each address in any order.+  void ExpectPickAddresses(LoadBalancingPolicy::SubchannelPicker* picker,+                           absl::Span<const std::string> uris,+                           size_t iterations_per_uri = 3,+                           SourceLocation location = SourceLocation()) {+    std::unordered_map<std::string, int> reported_uris;+    for (size_t i = 0; i < iterations_per_uri * uris.size(); ++i) {+      auto address = ExpectPickAddress(picker);+      ASSERT_TRUE(address.has_value())+          << location.file() << "":"" << location.line();+      reported_uris[*address]++;+    }+    EXPECT_EQ(reported_uris.size(), uris.size())+        << location.file() << "":"" << location.line();+    for (const std::string& uri : uris) {+      EXPECT_EQ(reported_uris[uri], iterations_per_uri)+          << ""Subchannel "" << uri << location.file() << "":"" << location.line();+    }+  }+};++TEST_F(RoundRobinTest, SingleChannel) {+  std::string uri = ""ipv4:127.0.0.1:441"";+  auto policy = MakeLbPolicy(""round_robin"");+  auto status = ApplyUpdate(BuildUpdateArgs({uri}), policy.get());++  ASSERT_TRUE(status.ok()) << status;+  EXPECT_EQ(subchannel_pool_.size(), 1);++  ExpectState(GRPC_CHANNEL_CONNECTING);++  // LB policy should have reported CONNECTING state.+  auto picker = ExpectState(GRPC_CHANNEL_CONNECTING);+  ExpectPickQueued(picker.get());+  auto subchannel = FindSubchannel(uri);+  ASSERT_NE(subchannel, nullptr);+  // LB policy should have requested a connection on this subchannel.+  EXPECT_TRUE(subchannel->ConnectionRequested());+  subchannel->SetConnectivityState(GRPC_CHANNEL_CONNECTING, absl::OkStatus());+  picker = ExpectState(GRPC_CHANNEL_CONNECTING);+  ExpectPickQueued(picker.get());++  // Subchannel is ready+  subchannel->SetConnectivityState(GRPC_CHANNEL_READY, absl::OkStatus());+  picker = ExpectState(GRPC_CHANNEL_READY);+  // Picker should return the same subchannel repeatedly.+  for (size_t i = 0; i < 3; ++i) {+    ExpectPickComplete(picker.get(), uri);+  }+  ExpectNoStateChange();++  subchannel->SetConnectivityState(GRPC_CHANNEL_IDLE, absl::OkStatus());+  ExpectReresolutionRequest();+  ExpectState(GRPC_CHANNEL_CONNECTING);+  ExpectNoStateChange();++  // There's a failure+  subchannel->SetConnectivityState(GRPC_CHANNEL_TRANSIENT_FAILURE,+                                   absl::UnavailableError(""a test""));+  ExpectReresolutionRequest();+  absl::Status expected_status = absl::UnavailableError(+      ""connections to all backends failing; last error: UNAVAILABLE: a test"");+  picker = ExpectState(GRPC_CHANNEL_TRANSIENT_FAILURE, expected_status);++  auto pick_result = PerformPick(picker.get());+  ASSERT_TRUE(absl::holds_alternative<LoadBalancingPolicy::PickResult::Fail>(+      pick_result.result));++  status = absl::get<LoadBalancingPolicy::PickResult::Fail>(pick_result.result)+               .status;+  EXPECT_EQ(status, expected_status);++  // ... and a recovery!+  subchannel->SetConnectivityState(GRPC_CHANNEL_READY, absl::OkStatus());+  picker = ExpectState(GRPC_CHANNEL_READY);+  ExpectPickComplete(picker.get(), uri);++  ExpectNoStateChange();+}++TEST_F(RoundRobinTest, ThreeSubchannels) {+  std::array<std::string, 3> uris = {+      ""ipv4:127.0.0.1:441"",+      ""ipv4:127.0.0.1:442"",+      ""ipv4:127.0.0.1:443"",+  };+  auto policy = MakeLbPolicy(""round_robin"");+  auto status = ApplyUpdate(BuildUpdateArgs(uris), policy.get());++  ASSERT_TRUE(status.ok()) << status;+  EXPECT_EQ(subchannel_pool_.size(), 3);+  for (int i = 0; i < 3; i++) {+    ExpectState(GRPC_CHANNEL_CONNECTING);+  }++  // LB policy should have reported CONNECTING state.+  auto picker = ExpectState(GRPC_CHANNEL_CONNECTING);+  ExpectPickQueued(picker.get());+  // LB policy should have requested a connection on this subchannel.+  EXPECT_TRUE(FindSubchannel(uris[0])->ConnectionRequested());++  for (const std::string& uri : uris) {+    auto subchannel = FindSubchannel(uri);+    ASSERT_NE(subchannel, nullptr);+    subchannel->SetConnectivityState(GRPC_CHANNEL_CONNECTING, absl::OkStatus());+    picker = ExpectState(GRPC_CHANNEL_CONNECTING);+  }+  ExpectPickQueued(picker.get());++  // Only one subchannel is ready+  FindSubchannel(uris[0])->SetConnectivityState(GRPC_CHANNEL_READY,+                                                absl::OkStatus());+  picker = ExpectState(GRPC_CHANNEL_READY);+  // Picker should return the same subchannel repeatedly.+  for (size_t i = 0; i < 3; ++i) {+    ExpectPickComplete(picker.get(), uris[0]);+  }+  ExpectNoStateChange();++  auto second_subchannel = FindSubchannel(uris[1]);+  // All subchannels ready+  second_subchannel->SetConnectivityState(GRPC_CHANNEL_READY, absl::OkStatus());+  picker = ExpectState(GRPC_CHANNEL_READY);+  ExpectPickAddresses(picker.get(), {uris[0], uris[1]});+  ExpectNoStateChange();++  FindSubchannel(uris[2])->SetConnectivityState(GRPC_CHANNEL_READY,+                                                absl::OkStatus());+  picker = ExpectState(GRPC_CHANNEL_READY);++  ExpectPickAddresses(picker.get(), uris);++  ExpectNoStateChange();++  second_subchannel->SetConnectivityState(GRPC_CHANNEL_IDLE, absl::OkStatus());+  ExpectReresolutionRequest();+  ExpectState(GRPC_CHANNEL_READY);+  ExpectNoStateChange();+  second_subchannel->SetConnectivityState(GRPC_CHANNEL_TRANSIENT_FAILURE,+                                          absl::OkStatus());+  ExpectReresolutionRequest();+  picker = ExpectState(GRPC_CHANNEL_READY);+  ExpectPickAddresses(picker.get(), {uris[0], uris[2]});++  ExpectNoStateChange();+}++TEST_F(RoundRobinTest, OneChannelReady) {+  auto policy = MakeLbPolicy(""round_robin"");+  auto status = ApplyUpdate(BuildUpdateArgs({+                                ""ipv4:127.0.0.1:441"",+                                ""ipv4:127.0.0.1:442"",+                                ""ipv4:127.0.0.1:443"",+                            }),+                            policy.get());+  ASSERT_TRUE(status.ok()) << status;+  for (int i = 0; i < 3; i++) {+    ExpectState(GRPC_CHANNEL_CONNECTING);+  }+  ExpectState(GRPC_CHANNEL_CONNECTING);++  auto subchannel = FindSubchannel(""ipv4:127.0.0.1:441"");+  ASSERT_NE(subchannel, nullptr);+  subchannel->SetConnectivityState(GRPC_CHANNEL_READY, absl::OkStatus());++  auto picker = ExpectState(GRPC_CHANNEL_READY);+  ExpectPickComplete(picker.get(), ""ipv4:127.0.0.1:441"");+  ExpectNoStateChange();+}++TEST_F(RoundRobinTest, ConnectingFromStart) {+  auto policy = MakeLbPolicy(""round_robin"");+  auto status = ApplyUpdate(BuildUpdateArgs({+                                ""ipv4:127.0.0.1:441"",+                                ""ipv4:127.0.0.1:442"",+                                ""ipv4:127.0.0.1:443"",+                            }),+                            policy.get());+  ASSERT_TRUE(status.ok()) << status;+  for (int i = 0; i < 3; i++) {+    ExpectState(GRPC_CHANNEL_CONNECTING);+  }+  auto picker = ExpectState(GRPC_CHANNEL_CONNECTING);+  ExpectPickQueued(picker.get());+  EXPECT_EQ(3, subchannel_pool_.size());+  ExpectNoStateChange();+}++TEST_F(RoundRobinTest, OneChannelReadyToIdle) {",I think this is already covered in the `SingleAddress` test case above.  No need to duplicate it here.,X
10496191,sifmelcara,https://api.github.com/repos/grpc/grpc/pulls/31654,1022284822,2022-11-15T03:38:45Z,src/core/ext/transport/binder/wire_format/wire_reader_impl.cc,"@@ -212,6 +214,7 @@ absl::Status WireReaderImpl::ProcessTransaction(transaction_code_t code,       int64_t num_bytes = -1;       GRPC_RETURN_IF_ERROR(parcel->ReadInt64(&num_bytes));       gpr_log(GPR_DEBUG, ""received acknowledge bytes = %"" PRId64, num_bytes);+      wire_writer_set_notification_.WaitForNotification();",1. Add comment to explain why we need this and in what potential scenario it will deadlock2. Use `WaitForNotificationWithTimeout` instead. Log an error and return proper `absl::Status` when timeout happens,
10496191,sifmelcara,https://api.github.com/repos/grpc/grpc/pulls/31654,1022286363,2022-11-15T03:42:53Z,src/core/ext/transport/binder/wire_format/wire_reader_impl.cc,"@@ -212,6 +214,7 @@ absl::Status WireReaderImpl::ProcessTransaction(transaction_code_t code,       int64_t num_bytes = -1;       GRPC_RETURN_IF_ERROR(parcel->ReadInt64(&num_bytes));       gpr_log(GPR_DEBUG, ""received acknowledge bytes = %"" PRId64, num_bytes);+      wire_writer_set_notification_.WaitForNotification();",(Also should add a TODO to emphasize that this is a temporary workaround),
832059,LittleCVR,https://api.github.com/repos/grpc/grpc/pulls/31654,1022562023,2022-11-15T09:42:20Z,src/core/ext/transport/binder/wire_format/wire_reader_impl.h,"@@ -130,6 +130,7 @@ class WireReaderImpl : public WireReader {    // Used to send ACK.   std::shared_ptr<WireWriter> wire_writer_;+  grpc_core::Notification wire_writer_set_notification_;",I prefer long name like `wire_writer_ready_notification_` :D,
4181124,yashykt,https://api.github.com/repos/grpc/grpc/pulls/31668,1023437326,2022-11-16T02:17:10Z,src/core/ext/filters/client_channel/resolver/xds/xds_resolver.cc,"@@ -883,26 +883,44 @@ void XdsResolver::OnListenerUpdate(XdsListenerResource listener) {       &current_listener_.route_config,       // RDS resource name       [&](std::string* rds_name) {-        if (route_config_watcher_ != nullptr) {-          XdsRouteConfigResourceType::CancelWatch(-              xds_client_.get(), route_config_name_, route_config_watcher_,-              /*delay_unsubscription=*/!rds_name->empty());-          route_config_watcher_ = nullptr;-        }-        route_config_name_ = std::move(*rds_name);-        if (!route_config_name_.empty()) {-          current_virtual_host_.routes.clear();+        // If the RDS name changed, update the RDS watcher.+        // Note that this will be true on the initial update, because+        // route_config_name_ will be empty.+        if (route_config_name_ != *rds_name) {+          // If we already had a watch (i.e., if the previous config had+          // a different RDS name), stop the previous watch.+          // There will be no previous watch if either (a) this is the+          // initial resource update or (b) the previous Listener had an+          // inlined RouteConfig.+          if (route_config_watcher_ != nullptr) {+            XdsRouteConfigResourceType::CancelWatch(+                xds_client_.get(), route_config_name_, route_config_watcher_,+                /*delay_unsubscription=*/true);+            route_config_watcher_ = nullptr;+          }+          // Start watch for the new RDS resource name.+          route_config_name_ = std::move(*rds_name);           auto watcher = MakeRefCounted<RouteConfigWatcher>(Ref());           route_config_watcher_ = watcher.get();           XdsRouteConfigResourceType::StartWatch(               xds_client_.get(), route_config_name_, std::move(watcher));+        } else {+          // RDS resource name has not changed, so no watch needs to be","why is this in the else part? Even if the rds name has not changed, the list of filters could still have changed right?",
7221003,rockspore,https://api.github.com/repos/grpc/grpc/pulls/31368,1024138888,2022-11-16T15:13:33Z,test/core/end2end/fixtures/h2_tls_wrong_versions.cc,"@@ -0,0 +1,170 @@+/*+ *+ * Copyright 2018 gRPC authors.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ *     http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ *+ */++#include <string.h>++#include <string>++#include <grpc/grpc.h>++#include ""src/core/lib/gprpp/global_config_generic.h""+#include ""src/core/lib/gprpp/host_port.h""+#include ""src/core/lib/security/security_connector/ssl_utils_config.h""+#include ""test/core/end2end/end2end_tests.h""+#include ""test/core/end2end/fixtures/h2_tls_common.h""+#include ""test/core/util/port.h""+#include ""test/core/util/test_config.h""++static grpc_end2end_test_fixture chttp2_create_fixture_simple_fullstack_1(+    const grpc_channel_args*, const grpc_channel_args*) {+  grpc_end2end_test_fixture f;+  int port = grpc_pick_unused_port_or_die();+  fullstack_secure_fixture_data* ffd = new fullstack_secure_fixture_data();+  memset(&f, 0, sizeof(f));+  ffd->localaddr = grpc_core::JoinHostPort(""localhost"", port);+  SetChannelTlsVersion(ffd, SecurityPrimitives::TlsVersion::V_12,+                       SecurityPrimitives::TlsVersion::V_12);+  SetServerTlsVersion(ffd, SecurityPrimitives::TlsVersion::V_13,+                      SecurityPrimitives::TlsVersion::V_13);+  SetCertificateProvider(ffd,+                         SecurityPrimitives::ProviderType::STATIC_PROVIDER);+  SetCertificateVerifier(+      ffd, SecurityPrimitives::VerifierType::EXTERNAL_SYNC_VERIFIER);+  f.fixture_data = ffd;+  f.cq = grpc_completion_queue_create_for_next(nullptr);+  return f;+}++static grpc_end2end_test_fixture chttp2_create_fixture_simple_fullstack_2(+    const grpc_channel_args*, const grpc_channel_args*) {+  grpc_end2end_test_fixture f;+  int port = grpc_pick_unused_port_or_die();+  fullstack_secure_fixture_data* ffd = new fullstack_secure_fixture_data();+  memset(&f, 0, sizeof(f));+  ffd->localaddr = grpc_core::JoinHostPort(""localhost"", port);+  SetChannelTlsVersion(ffd, SecurityPrimitives::TlsVersion::V_13,+                       SecurityPrimitives::TlsVersion::V_13);+  SetServerTlsVersion(ffd, SecurityPrimitives::TlsVersion::V_12,+                      SecurityPrimitives::TlsVersion::V_12);+  SetCertificateProvider(ffd,+                         SecurityPrimitives::ProviderType::STATIC_PROVIDER);+  SetCertificateVerifier(+      ffd, SecurityPrimitives::VerifierType::EXTERNAL_SYNC_VERIFIER);+  f.fixture_data = ffd;+  f.cq = grpc_completion_queue_create_for_next(nullptr);+  return f;+}++static grpc_end2end_test_fixture chttp2_create_fixture_simple_fullstack_3(+    const grpc_channel_args*, const grpc_channel_args*) {+  grpc_end2end_test_fixture f;+  int port = grpc_pick_unused_port_or_die();+  fullstack_secure_fixture_data* ffd = new fullstack_secure_fixture_data();+  memset(&f, 0, sizeof(f));+  ffd->localaddr = grpc_core::JoinHostPort(""localhost"", port);+  SetChannelTlsVersion(ffd, SecurityPrimitives::TlsVersion::V_13,","This is a good point but I don't think it should be the setter's job to check the versions. IIUC, tls_credentials_options is not immutable once created and can be consumed multiple times if needed. Consider the following use case:```options->set_min_tls_version(1.2);options->set_max_tls_version(1.2);// some work using the options without losing the ownership of the pointer.// set tls versions differently for some other use.options->set_min_tls_version(1.3); // now this would error if we check it here.options->set_max_tls_version(1.3);```This admittedly is not a standard use pattern, since passing the options to the tls_credentials normally transfers the ownership of the options, but rejecting it seems weird to me.In fact, tls_credentials_options has no functions like verify or validate. It would be better for the consumer to perform such a check, i.e., a check can be done when the options are passed into tls_credentials, either channel or server. In this case, I think it's better to be added in a separate PR.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/31668,1024235173,2022-11-16T16:30:10Z,src/core/ext/filters/client_channel/resolver/xds/xds_resolver.cc,"@@ -883,26 +883,44 @@ void XdsResolver::OnListenerUpdate(XdsListenerResource listener) {       &current_listener_.route_config,       // RDS resource name       [&](std::string* rds_name) {-        if (route_config_watcher_ != nullptr) {-          XdsRouteConfigResourceType::CancelWatch(-              xds_client_.get(), route_config_name_, route_config_watcher_,-              /*delay_unsubscription=*/!rds_name->empty());-          route_config_watcher_ = nullptr;-        }-        route_config_name_ = std::move(*rds_name);-        if (!route_config_name_.empty()) {-          current_virtual_host_.routes.clear();+        // If the RDS name changed, update the RDS watcher.+        // Note that this will be true on the initial update, because+        // route_config_name_ will be empty.+        if (route_config_name_ != *rds_name) {+          // If we already had a watch (i.e., if the previous config had+          // a different RDS name), stop the previous watch.+          // There will be no previous watch if either (a) this is the+          // initial resource update or (b) the previous Listener had an+          // inlined RouteConfig.+          if (route_config_watcher_ != nullptr) {+            XdsRouteConfigResourceType::CancelWatch(+                xds_client_.get(), route_config_name_, route_config_watcher_,+                /*delay_unsubscription=*/true);+            route_config_watcher_ = nullptr;+          }+          // Start watch for the new RDS resource name.+          route_config_name_ = std::move(*rds_name);           auto watcher = MakeRefCounted<RouteConfigWatcher>(Ref());           route_config_watcher_ = watcher.get();           XdsRouteConfigResourceType::StartWatch(               xds_client_.get(), route_config_name_, std::move(watcher));+        } else {+          // RDS resource name has not changed, so no watch needs to be","Right, but if we get an LDS update that changes both the list of filters and the RDS resource name, then we don't want to start using the new filter list until we get the first update from the new RDS watch, because we have no guarantee that the new filter list and the old route config form a correct configuration.For an example of where this is important, see the `LdsUpdateChangesHcmConfigAndRdsResourceName` test.",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/31614,1024299541,2022-11-16T17:27:15Z,src/core/lib/resource_quota/memory_quota.cc,"@@ -450,6 +501,82 @@ void BasicMemoryQuota::Return(size_t amount) {   free_bytes_.fetch_add(amount, std::memory_order_relaxed); } +uint64_t BasicMemoryQuota::AddNewAllocator(GrpcMemoryAllocatorImpl* allocator) {+  uint64_t curr_id = curr_allocator_id_.fetch_add(1, std::memory_order_seq_cst);++  AllocatorBucket::Shard& shard = allocators_[0].SelectShard(allocator);++  shard.shard_mu.Lock();+  shard.allocator_map.insert({curr_id, allocator});+  shard.shard_mu.Unlock();++  return curr_id;+}++void BasicMemoryQuota::RemoveAllocator(uint64_t id,+                                       GrpcMemoryAllocatorImpl* allocator) {+  if (GRPC_TRACE_FLAG_ENABLED(grpc_resource_quota_trace)) {+    gpr_log(GPR_INFO, ""Removing allocator %"" PRIu64 "", %p"",+            allocator->allocator_id_, allocator);+  }++  AllocatorBucket::Shard& small_shard = allocators_[0].SelectShard(allocator);+  {+    absl::MutexLock l(&small_shard.shard_mu);+    if (small_shard.allocator_map.erase(id) == 1) {+      return;+    }+  }++  AllocatorBucket::Shard& big_shard = allocators_[1].SelectShard(allocator);++  big_shard.shard_mu.Lock();+  big_shard.allocator_map.erase(id);+  big_shard.shard_mu.Unlock();+}++void BasicMemoryQuota::MoveAllocatorBigToSmall(",Suggest renaming to `MaybeMoveAllocatorBigToSmall` -- since there's a conditionality here that would be useful to call out at call sites,X
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/31614,1024301334,2022-11-16T17:29:06Z,src/core/lib/resource_quota/memory_quota.h,"@@ -327,9 +355,14 @@ class BasicMemoryQuota final   std::atomic<intptr_t> free_bytes_{kInitialSize};   // The total number of bytes in this quota.   std::atomic<size_t> quota_size_{kInitialSize};+  // Assign a unique ID to each allocator.+  std::atomic<uint64_t> curr_allocator_id_{0};    // Reclaimer queues.   ReclaimerQueue reclaimers_[kNumReclamationPasses];+  // List of all allocators sorted into 2 buckets, small (<100 KB free bytes)+  // and large (>500 KB free bytes).+  std::array<AllocatorBucket, 2> allocators_;","I don't think we're getting benefit from an array here, let's just go with `AllocatorBucket big_allocator_; AllocatorBucket small_allocator_;`?",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/31614,1024316323,2022-11-16T17:43:45Z,src/core/lib/resource_quota/memory_quota.h,"@@ -372,10 +405,47 @@ class GrpcMemoryAllocatorImpl final : public EventEngineMemoryAllocatorImpl {       // Try to immediately return some free'ed memory back to the total quota.       MaybeDonateBack();     }+    if (is_big_.load(std::memory_order_relaxed)) {","I haven't proved it yet, but this pattern of having an atomic guarding the state of a second thing that has a lock worries me: it seems likely that we end up with cases where is_big is true and we're in the small list, or the opposite - especially in the situation where we've got multiple concurrent allocations & deallocations happening.Instead, I'd propose eliminating `is_big_` entirely, and adding a method `ResolveBigSmallList(uint64_t old_free_bytes, uint64_t new_free_bytes)` (I'm sure you'll choose a better name!)The logic for this new method:```void ResolveBigSmallList(uint64_t old_free_bytes, uint64_t new_free_bytes) {  while (true) {    if (new_free_bytes < kSmallAllocatorThreshold) {      if (old_free_bytes < kSmallAllocatorThreshold) return; // no change in status      MaybeMoveAllocatorBigToSmall();    } else if (new_free_bytes > kBigAllocatorThreshold) {      if (old_free_bytes > kBigAllocatorThreshold) return; // no change in status      MaybeMoveAllocatorSmallToBig();    } else {      // no change necessary: in the in-between space we don't care which list we're on      return;    }    // We made some modifications: loop and make sure we ultimately land in the right place    old_free_bytes = new_free_bytes;    new_free_bytes = free_bytes_.load(std::memory_order_relaxed);  }}```now whatever fluctuations happen we can assuredly get back to a consistent state, and we don't need to have that tracking variable.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/31668,1024350962,2022-11-16T18:16:00Z,test/cpp/end2end/xds/xds_routing_end2end_test.cc,"@@ -96,11 +97,13 @@ TEST_P(LdsDeletionTest, ListenerDeletionIgnored) {   EXPECT_EQ(response_state->state, AdsServiceImpl::ResponseState::ACKED);   // Unset LDS resource and wait for client to ACK the update.   balancer_->ads_service()->UnsetResource(kLdsTypeUrl, kServerName);-  const auto deadline = absl::Now() + absl::Seconds(30);+  const auto deadline =+      absl::Now() + (absl::Seconds(30) * grpc_test_slowdown_factor());   while (true) {     ASSERT_LT(absl::Now(), deadline) << ""timed out waiting for LDS ACK"";     response_state = balancer_->ads_service()->lds_response_state();     if (response_state.has_value()) break;+    absl::SleepFor(absl::Seconds(1) * grpc_test_slowdown_factor());","The sleep just avoids wasting CPU time.  Without it, this is just a busy loop, constantly checking the same thing over and over again.  With the sleep, we pause to actually give the system time to change state before we check again.Note that the sleep does not affect the overall 30-second deadline for getting the ACK.",
14166415,sanjaypujare,https://api.github.com/repos/grpc/grpc/pulls/31569,1024506798,2022-11-16T21:05:46Z,tools/internal_ci/linux/grpc_xds_k8s_run_test.sh,"@@ -0,0 +1,101 @@+#!/usr/bin/env bash",Code shared between `grpc_xds_k8s_xlang.sh` and `grpc_xds_k8s_xbranch.sh` . Didn't want code duplication.,X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/31544,1025589202,2022-11-17T19:05:00Z,test/core/client_channel/lb_policy/round_robin_test.cc,"@@ -44,318 +44,236 @@ namespace {  class RoundRobinTest : public LoadBalancingPolicyTest {  public:-  LoadBalancingPolicy::UpdateArgs BuildUpdateArgs(-      absl::Span<const std::string> subchannel_addresses) {-    LoadBalancingPolicy::UpdateArgs update_args;-    update_args.addresses.emplace();-    for (const auto& addr : subchannel_addresses) {-      update_args.addresses->emplace_back(MakeAddress(addr), ChannelArgs());-    }-    return update_args;-  }--  void ExpectAllChannelsConnecting() {-    for (size_t i = 0; i < subchannel_pool_.size(); ++i) {-      ExpectState(GRPC_CHANNEL_CONNECTING);-    }-  }+  RoundRobinTest() : policy(MakeLbPolicy(""round_robin"")) {}    // Picker should return each address in any order.-  void ExpectPickAddresses(LoadBalancingPolicy::SubchannelPicker* picker,-                           absl::Span<const std::string> uris,-                           size_t iterations_per_uri = 3,-                           SourceLocation location = SourceLocation()) {-    std::unordered_map<std::string, int> reported_uris;+  void ExpectRoundRobinPicks(LoadBalancingPolicy::SubchannelPicker* picker,+                             absl::Span<const absl::string_view> uris,+                             size_t iterations_per_uri = 3,+                             SourceLocation location = SourceLocation()) {+    int expected = -1;     for (size_t i = 0; i < iterations_per_uri * uris.size(); ++i) {-      auto address = ExpectPickAddress(picker);+      auto address = ExpectPickComplete(picker);       ASSERT_TRUE(address.has_value())           << location.file() << "":"" << location.line();-      reported_uris[*address]++;-    }-    EXPECT_EQ(reported_uris.size(), uris.size())-        << location.file() << "":"" << location.line();-    for (const std::string& uri : uris) {-      EXPECT_EQ(reported_uris[uri], iterations_per_uri)-          << ""Subchannel "" << uri << location.file() << "":"" << location.line();+      int ind = std::find(uris.begin(), uris.end(), *address) - uris.begin();+      ASSERT_LT(ind, uris.size()) << ""Missing "" << *address << ""\n""+                                  << location.file() << "":"" << location.line();+      if (expected >= 0) {+        EXPECT_EQ(ind, expected)+            << ""Got "" << *address << "", expected "" << uris[ind] << ""\n""+            << location.file() << "":"" << location.line();+      }+      expected = (ind + 1) % uris.size();     }   }++  OrphanablePtr<LoadBalancingPolicy> policy;","Names of class data members should have a trailing underscore (i.e., this should be called `policy_`), as per https://google.github.io/styleguide/cppguide.html#Variable_Names.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/31544,1025625507,2022-11-17T19:37:20Z,test/core/client_channel/lb_policy/round_robin_test.cc,"@@ -44,318 +44,236 @@ namespace {  class RoundRobinTest : public LoadBalancingPolicyTest {  public:-  LoadBalancingPolicy::UpdateArgs BuildUpdateArgs(-      absl::Span<const std::string> subchannel_addresses) {-    LoadBalancingPolicy::UpdateArgs update_args;-    update_args.addresses.emplace();-    for (const auto& addr : subchannel_addresses) {-      update_args.addresses->emplace_back(MakeAddress(addr), ChannelArgs());-    }-    return update_args;-  }--  void ExpectAllChannelsConnecting() {-    for (size_t i = 0; i < subchannel_pool_.size(); ++i) {-      ExpectState(GRPC_CHANNEL_CONNECTING);-    }-  }+  RoundRobinTest() : policy(MakeLbPolicy(""round_robin"")) {}    // Picker should return each address in any order.-  void ExpectPickAddresses(LoadBalancingPolicy::SubchannelPicker* picker,-                           absl::Span<const std::string> uris,-                           size_t iterations_per_uri = 3,-                           SourceLocation location = SourceLocation()) {-    std::unordered_map<std::string, int> reported_uris;+  void ExpectRoundRobinPicks(LoadBalancingPolicy::SubchannelPicker* picker,+                             absl::Span<const absl::string_view> uris,+                             size_t iterations_per_uri = 3,+                             SourceLocation location = SourceLocation()) {+    int expected = -1;     for (size_t i = 0; i < iterations_per_uri * uris.size(); ++i) {-      auto address = ExpectPickAddress(picker);+      auto address = ExpectPickComplete(picker);       ASSERT_TRUE(address.has_value())           << location.file() << "":"" << location.line();-      reported_uris[*address]++;-    }-    EXPECT_EQ(reported_uris.size(), uris.size())-        << location.file() << "":"" << location.line();-    for (const std::string& uri : uris) {-      EXPECT_EQ(reported_uris[uri], iterations_per_uri)-          << ""Subchannel "" << uri << location.file() << "":"" << location.line();+      int ind = std::find(uris.begin(), uris.end(), *address) - uris.begin();+      ASSERT_LT(ind, uris.size()) << ""Missing "" << *address << ""\n""+                                  << location.file() << "":"" << location.line();+      if (expected >= 0) {+        EXPECT_EQ(ind, expected)+            << ""Got "" << *address << "", expected "" << uris[ind] << ""\n""+            << location.file() << "":"" << location.line();+      }+      expected = (ind + 1) % uris.size();     }   }++  OrphanablePtr<LoadBalancingPolicy> policy; }; -TEST_F(RoundRobinTest, SingleChannel) {-  std::string uri = ""ipv4:127.0.0.1:441"";-  auto policy = MakeLbPolicy(""round_robin"");-  auto status = ApplyUpdate(BuildUpdateArgs({uri}), policy.get());+const absl::string_view kFirstAddress = ""ipv4:127.0.0.1:441"";+const absl::string_view kSecondAddress = ""ipv4:127.0.0.1:442"";+const absl::string_view kThirdAddress = ""ipv4:127.0.0.1:443""; +TEST_F(RoundRobinTest, SingleAddress) {+  auto status = ApplyUpdate(BuildUpdate({kFirstAddress}), policy.get());   ASSERT_TRUE(status.ok()) << status;-  EXPECT_EQ(subchannel_pool_.size(), 1);--  ExpectState(GRPC_CHANNEL_CONNECTING);-   // LB policy should have reported CONNECTING state.-  auto picker = ExpectState(GRPC_CHANNEL_CONNECTING);-  ExpectPickQueued(picker.get());-  auto subchannel = FindSubchannel(uri);+  ExpectConnectingUpdate();+  auto subchannel = FindSubchannel(kFirstAddress);   ASSERT_NE(subchannel, nullptr);   // LB policy should have requested a connection on this subchannel.   EXPECT_TRUE(subchannel->ConnectionRequested());-  subchannel->SetConnectivityState(GRPC_CHANNEL_CONNECTING, absl::OkStatus());-  picker = ExpectState(GRPC_CHANNEL_CONNECTING);-  ExpectPickQueued(picker.get());-+  subchannel->SetConnectivityState(GRPC_CHANNEL_CONNECTING);+  ExpectConnectingUpdate();","I don't think we should call this here.Note that the current implementation will actually report CONNECTING *three* times (not just twice) before reporting READY:1. When the LB policy first gets the address list.2. When the newly created subchannel reports its initial IDLE state.  (Note that there's nothing in the test to explicitly trigger that state update; the subchannel automatically reports this as soon as it's created.)3. When the subchannel reports CONNECTING.However, when the LB policy reports CONNECTING and the previous update was also CONNECTING, that does not actually change the state of the channel, so it's basically a no-op.  The fact that the current implementation does this 3 times in this test is just an implementation detail.  If we changed the implementation to report CONNECTING only once, or to report it 4 or more times, we'd still want the test to pass, because the LB policy would still be exhibiting the correct behavior.I think what we actually care about here is the following:- The LB policy reports CONNECTING immediately upon getting the address list.  (This is verified via the call to `ExpectConnectingUpdate()` on line 82 above.)- The LB policy does not report anything *other* than CONNECTING until it reports READY.  (This is verified by the call to `WaitForConnected()` on line 91 below.)So I don't think we want the second call to `ExpectConnectingUpdate()` here.  Let's remove it.More generally, I think we should structure all of these tests such that we don't care about state updates that don't actually change the behavior of the channel.  This includes:- Duplicate CONNECTING updates.- Duplicate TRANSIENT_FAILURE updates, as long as the associated status does not change.- Duplicate READY updates, as long as the picker behavior does not change (i.e., the list of READY subchannels does not change).I think the general pattern here should be that we only check for updates when the LB policy is required to actually change the state.  At that point, we should allow any number of duplicate updates for the previous state before we see the expected state change, but we should still always check the picker behavior after every single update.  This means:- When we send the initial address list to the LB policy, we call `ExpectConnectingUpdate()`.  This checks for a single CONNECTING update, and verifies the picker behavior.- When the policy should transition from CONNECTING to READY, call `WaitForConnected()`.  This allows zero or more CONNECTING updates (and verifies the picker behavior for each one) followed by a single READY update.  Note that it is the caller's responsibility to verify the picker behavior for the final READY update, so we should always call `ExpectRoundRobinPicks()` after `WaitForConnected()`.  (The test framework can't generally verify picker behavior in READY state, since that behavior is specific to each LB policy.)- When the policy should change the set of addresses that the picker is using (i.e., the previous state was READY and the new state is READY, but the picker behavior should change), we should call `ExpectState(GRPC_CHANNEL_READY)` instead of calling `WaitForConnected()`, because we don't want to allow a CONNECTING state in between the two READY states.  Just like `WaitForConnected()`, it is the caller's responsibility to verify the picker behavior for the final READY update, so we should always call `ExpectRoundRobinPicks()` after `ExpectState(GRPC_CHANNEL_READY)`.- When the policy should transition from CONNECTING to TRANSIENT_FAILURE, call `WaitForConnectionFailed()`.  This will allow zero or more CONNECTING updates (and verifies the picker behavior for each one) followed by a single TF update, and it verifies the associated status and associated picker behavior.If we need to check some other transition, the general case is to use `WaitForStateUpdate()` with a lambda that allows duplicate updates for the previous state, checking the picker behavior after each one, and then expects the new state.  If we find that there are particular patterns that we're repeatedly using `WaitForStateUpdate()` for, we can add new helper functions for them to keep the tests concise.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/31544,1025627435,2022-11-17T19:39:19Z,test/core/client_channel/lb_policy/round_robin_test.cc,"@@ -44,318 +44,236 @@ namespace {  class RoundRobinTest : public LoadBalancingPolicyTest {  public:-  LoadBalancingPolicy::UpdateArgs BuildUpdateArgs(-      absl::Span<const std::string> subchannel_addresses) {-    LoadBalancingPolicy::UpdateArgs update_args;-    update_args.addresses.emplace();-    for (const auto& addr : subchannel_addresses) {-      update_args.addresses->emplace_back(MakeAddress(addr), ChannelArgs());-    }-    return update_args;-  }--  void ExpectAllChannelsConnecting() {-    for (size_t i = 0; i < subchannel_pool_.size(); ++i) {-      ExpectState(GRPC_CHANNEL_CONNECTING);-    }-  }+  RoundRobinTest() : policy(MakeLbPolicy(""round_robin"")) {}    // Picker should return each address in any order.-  void ExpectPickAddresses(LoadBalancingPolicy::SubchannelPicker* picker,-                           absl::Span<const std::string> uris,-                           size_t iterations_per_uri = 3,-                           SourceLocation location = SourceLocation()) {-    std::unordered_map<std::string, int> reported_uris;+  void ExpectRoundRobinPicks(LoadBalancingPolicy::SubchannelPicker* picker,+                             absl::Span<const absl::string_view> uris,+                             size_t iterations_per_uri = 3,+                             SourceLocation location = SourceLocation()) {+    int expected = -1;     for (size_t i = 0; i < iterations_per_uri * uris.size(); ++i) {-      auto address = ExpectPickAddress(picker);+      auto address = ExpectPickComplete(picker);       ASSERT_TRUE(address.has_value())           << location.file() << "":"" << location.line();-      reported_uris[*address]++;-    }-    EXPECT_EQ(reported_uris.size(), uris.size())-        << location.file() << "":"" << location.line();-    for (const std::string& uri : uris) {-      EXPECT_EQ(reported_uris[uri], iterations_per_uri)-          << ""Subchannel "" << uri << location.file() << "":"" << location.line();+      int ind = std::find(uris.begin(), uris.end(), *address) - uris.begin();+      ASSERT_LT(ind, uris.size()) << ""Missing "" << *address << ""\n""+                                  << location.file() << "":"" << location.line();+      if (expected >= 0) {+        EXPECT_EQ(ind, expected)+            << ""Got "" << *address << "", expected "" << uris[ind] << ""\n""+            << location.file() << "":"" << location.line();+      }+      expected = (ind + 1) % uris.size();     }   }++  OrphanablePtr<LoadBalancingPolicy> policy; }; -TEST_F(RoundRobinTest, SingleChannel) {-  std::string uri = ""ipv4:127.0.0.1:441"";-  auto policy = MakeLbPolicy(""round_robin"");-  auto status = ApplyUpdate(BuildUpdateArgs({uri}), policy.get());+const absl::string_view kFirstAddress = ""ipv4:127.0.0.1:441"";+const absl::string_view kSecondAddress = ""ipv4:127.0.0.1:442"";+const absl::string_view kThirdAddress = ""ipv4:127.0.0.1:443""; +TEST_F(RoundRobinTest, SingleAddress) {+  auto status = ApplyUpdate(BuildUpdate({kFirstAddress}), policy.get());   ASSERT_TRUE(status.ok()) << status;-  EXPECT_EQ(subchannel_pool_.size(), 1);--  ExpectState(GRPC_CHANNEL_CONNECTING);-   // LB policy should have reported CONNECTING state.-  auto picker = ExpectState(GRPC_CHANNEL_CONNECTING);-  ExpectPickQueued(picker.get());-  auto subchannel = FindSubchannel(uri);+  ExpectConnectingUpdate();+  auto subchannel = FindSubchannel(kFirstAddress);   ASSERT_NE(subchannel, nullptr);   // LB policy should have requested a connection on this subchannel.   EXPECT_TRUE(subchannel->ConnectionRequested());-  subchannel->SetConnectivityState(GRPC_CHANNEL_CONNECTING, absl::OkStatus());-  picker = ExpectState(GRPC_CHANNEL_CONNECTING);-  ExpectPickQueued(picker.get());-+  subchannel->SetConnectivityState(GRPC_CHANNEL_CONNECTING);+  ExpectConnectingUpdate();   // Subchannel is ready-  subchannel->SetConnectivityState(GRPC_CHANNEL_READY, absl::OkStatus());-  picker = ExpectState(GRPC_CHANNEL_READY);+  subchannel->SetConnectivityState(GRPC_CHANNEL_READY);+  auto picker = WaitForConnected();   // Picker should return the same subchannel repeatedly.   for (size_t i = 0; i < 3; ++i) {","I think that for all of these tests, whenever we are verifying the behavior of the round_robin picker, we should use `ExpectRoundRobinPicks()`, even if there happens to be just one address in the list.  That way, all of the tests are consistent (and more concise).",
1644595,gnossen,https://api.github.com/repos/grpc/grpc/pulls/31677,1025869321,2022-11-18T00:24:21Z,src/python/grpcio/grpc/_channel.py,"@@ -188,9 +217,12 @@ def handle_event(event):   #pylint: disable=too-many-statements-def _consume_request_iterator(request_iterator, state, call, request_serializer,-                              event_handler):-    """"""Consume a request iterator supplied by the user.""""""+def _consume_request_iterator(request_iterator: Iterator, state: _RPCState,+                              call: Union[cygrpc.IntegratedCall,","I think there's an opportunity to pull out a base call class so that this can just be `cygrpc.ManagedCall`. These two classes have the `operate` and `cancel` methods in common, so it makes some sense.",
1644595,gnossen,https://api.github.com/repos/grpc/grpc/pulls/31677,1025878354,2022-11-18T00:40:39Z,src/python/grpcio/grpc/_channel.py,"@@ -550,15 +598,15 @@ def traceback(self, timeout=None):                 except grpc.RpcError:                     return sys.exc_info()[2] -    def add_done_callback(self, fn):+    def add_done_callback(self, fn: DoneCallbackType) -> None:","The name is similar, but `DoneCallbackType` is `Callable[[Any], None]` and the callback here is supposed to be `Callable[[grpc.Future], None]`. From [the docs](https://grpc.github.io/grpc/python/grpc.html?highlight=add_callback): ""The callback will be passed this Future object describing the outcome of the computation. Callbacks will be invoked after the future is terminated, whether successfully or not.""",
1644595,gnossen,https://api.github.com/repos/grpc/grpc/pulls/31677,1025885393,2022-11-18T00:56:34Z,src/python/grpcio/grpc/_channel.py,"@@ -838,18 +892,23 @@ def _start_unary_request(request, timeout, request_serializer):         return deadline, serialized_request, None  -def _end_unary_response_blocking(state, call, with_call, deadline):+def _end_unary_response_blocking(+    state: _RPCState, call: grpc.Call, with_call: bool,+    deadline: Optional[float]+) -> Union[ResponseType, Tuple[ResponseType, grpc.Call]]:","Oh wow, this is gnarly. This is an example of [control coupling](https://en.wikipedia.org/wiki/Coupling_(computer_programming)) where the return type differs significantly based on one of the parameters. It's not within the scope of this PR, but we probably really want to split this into two different functions entirely.",X
287917,eugeneo,https://api.github.com/repos/grpc/grpc/pulls/31544,1025921147,2022-11-18T02:14:56Z,test/core/client_channel/lb_policy/round_robin_test.cc,"@@ -44,318 +44,236 @@ namespace {  class RoundRobinTest : public LoadBalancingPolicyTest {  public:-  LoadBalancingPolicy::UpdateArgs BuildUpdateArgs(-      absl::Span<const std::string> subchannel_addresses) {-    LoadBalancingPolicy::UpdateArgs update_args;-    update_args.addresses.emplace();-    for (const auto& addr : subchannel_addresses) {-      update_args.addresses->emplace_back(MakeAddress(addr), ChannelArgs());-    }-    return update_args;-  }--  void ExpectAllChannelsConnecting() {-    for (size_t i = 0; i < subchannel_pool_.size(); ++i) {-      ExpectState(GRPC_CHANNEL_CONNECTING);-    }-  }+  RoundRobinTest() : policy(MakeLbPolicy(""round_robin"")) {}    // Picker should return each address in any order.-  void ExpectPickAddresses(LoadBalancingPolicy::SubchannelPicker* picker,-                           absl::Span<const std::string> uris,-                           size_t iterations_per_uri = 3,-                           SourceLocation location = SourceLocation()) {-    std::unordered_map<std::string, int> reported_uris;+  void ExpectRoundRobinPicks(LoadBalancingPolicy::SubchannelPicker* picker,+                             absl::Span<const absl::string_view> uris,+                             size_t iterations_per_uri = 3,+                             SourceLocation location = SourceLocation()) {+    int expected = -1;     for (size_t i = 0; i < iterations_per_uri * uris.size(); ++i) {-      auto address = ExpectPickAddress(picker);+      auto address = ExpectPickComplete(picker);       ASSERT_TRUE(address.has_value())           << location.file() << "":"" << location.line();-      reported_uris[*address]++;-    }-    EXPECT_EQ(reported_uris.size(), uris.size())-        << location.file() << "":"" << location.line();-    for (const std::string& uri : uris) {-      EXPECT_EQ(reported_uris[uri], iterations_per_uri)-          << ""Subchannel "" << uri << location.file() << "":"" << location.line();+      int ind = std::find(uris.begin(), uris.end(), *address) - uris.begin();+      ASSERT_LT(ind, uris.size()) << ""Missing "" << *address << ""\n""+                                  << location.file() << "":"" << location.line();+      if (expected >= 0) {+        EXPECT_EQ(ind, expected)+            << ""Got "" << *address << "", expected "" << uris[ind] << ""\n""+            << location.file() << "":"" << location.line();+      }+      expected = (ind + 1) % uris.size();     }   }++  OrphanablePtr<LoadBalancingPolicy> policy; }; -TEST_F(RoundRobinTest, SingleChannel) {-  std::string uri = ""ipv4:127.0.0.1:441"";-  auto policy = MakeLbPolicy(""round_robin"");-  auto status = ApplyUpdate(BuildUpdateArgs({uri}), policy.get());+const absl::string_view kFirstAddress = ""ipv4:127.0.0.1:441"";+const absl::string_view kSecondAddress = ""ipv4:127.0.0.1:442"";+const absl::string_view kThirdAddress = ""ipv4:127.0.0.1:443""; +TEST_F(RoundRobinTest, SingleAddress) {+  auto status = ApplyUpdate(BuildUpdate({kFirstAddress}), policy.get());   ASSERT_TRUE(status.ok()) << status;-  EXPECT_EQ(subchannel_pool_.size(), 1);--  ExpectState(GRPC_CHANNEL_CONNECTING);-   // LB policy should have reported CONNECTING state.-  auto picker = ExpectState(GRPC_CHANNEL_CONNECTING);-  ExpectPickQueued(picker.get());-  auto subchannel = FindSubchannel(uri);+  ExpectConnectingUpdate();+  auto subchannel = FindSubchannel(kFirstAddress);   ASSERT_NE(subchannel, nullptr);   // LB policy should have requested a connection on this subchannel.   EXPECT_TRUE(subchannel->ConnectionRequested());-  subchannel->SetConnectivityState(GRPC_CHANNEL_CONNECTING, absl::OkStatus());-  picker = ExpectState(GRPC_CHANNEL_CONNECTING);-  ExpectPickQueued(picker.get());-+  subchannel->SetConnectivityState(GRPC_CHANNEL_CONNECTING);+  ExpectConnectingUpdate();","I understand that we should ignore repeated notifications when the state does not change. But how should cases like `OneChannelReady` be handled (should be around line 173) - when 3 GPC_CHANNEL_READY events are fired? There needs a way to purge duplicate events or the assertion that the queue is empty on test completion fails. Should I introduce a utility that will ignore the number of events, as long as the state does not change? I was considering something like `ExpectSameState` that will reach and of queue ensuring that only same state events are there.Same thing happens, e.g. with TRANSIENT_ERROR states in `SingleAddress` (around line 110)",
1644595,gnossen,https://api.github.com/repos/grpc/grpc/pulls/31677,1025927823,2022-11-18T02:30:49Z,src/python/grpcio/grpc/_channel.py,"@@ -1312,8 +1447,16 @@ def create(flags, method, host, deadline, metadata, credentials,   class _ChannelConnectivityState(object):--    def __init__(self, channel):+    lock: threading.RLock+    channel: grpc.Channel+    polling: bool+    connectivity: grpc.ChannelConnectivity+    try_to_connect: bool+    callbacks_and_connectivities: Sequence[Sequence[Union[","I think the outer container should be `List` here. The inner container is more difficult. It looks like it's currently a list of fixed size 2 where the zeroth element is of type `Callable[[grpc.ChannelConnectivity], None]` and first element is of type `Optional[grpc.ChannelConnectivity]`. Can we just change the sites that mutate this member to use tuples so that this type can become `List[Tuple[Callable[[grpc.ChannelConnectivity], None], Optional[grpc.ChannelConnectivity]]]`?",
11404172,Schramp,https://api.github.com/repos/grpc/grpc/pulls/28432,1026200789,2022-11-18T09:22:58Z,src/core/lib/iomgr/tcp_windows.cc,"@@ -391,27 +391,49 @@ static void win_write(grpc_endpoint* ep, grpc_slice_buffer* slices,   /* First, let's try a synchronous, non-blocking write. */   status = WSASend(socket->socket, buffers, (DWORD)tcp->write_slices->count,                    &bytes_sent, 0, NULL, NULL);-  info->wsa_error = status == 0 ? 0 : WSAGetLastError(); -  /* We would kind of expect to get a WSAEWOULDBLOCK here, especially on a busy-     connection that has its send queue filled up. But if we don't, then we can-     avoid doing an async write operation at all. */-  if (info->wsa_error != WSAEWOULDBLOCK) {-    grpc_error_handle error = status == 0-                                  ? absl::OkStatus()-                                  : GRPC_WSA_ERROR(info->wsa_error, ""WSASend"");-    grpc_core::ExecCtx::Run(DEBUG_LOCATION, cb, error);-    if (allocated) gpr_free(allocated);-    return;+  if (status == 0) {+    if (bytes_sent == tcp->write_slices->length) {+      info->wsa_error = 0;+      grpc_error_handle error = absl::OkStatus();+      grpc_core::ExecCtx::Run(DEBUG_LOCATION, cb, error);+      if (allocated) gpr_free(allocated);+      return;+    }++    /* The data was not completely delivered, we should send the rest of+       them by doing an async write operation. */+    for (i = 0; i < tcp->write_slices->count; i++) {+      if (buffers[i].len > bytes_sent) {+        buffers[i].buf += bytes_sent;+        buffers[i].len -= bytes_sent;+        break;+      }+      bytes_sent -= buffers[i].len;+      async_buffers_offset++;+    }+  } else {+    info->wsa_error = WSAGetLastError();++    /* We would kind of expect to get a WSAEWOULDBLOCK here, especially on a+       busy connection that has its send queue filled up. But if we don't, then+       we can avoid doing an async write operation at all. */+    if (info->wsa_error != WSAEWOULDBLOCK) {+      grpc_error_handle error = GRPC_WSA_ERROR(info->wsa_error, ""WSASend"");+      grpc_core::ExecCtx::Run(DEBUG_LOCATION, cb, error);+      if (allocated) gpr_free(allocated);+      return;+    }   }    TCP_REF(tcp, ""write"");    /* If we got a WSAEWOULDBLOCK earlier, then we need to re-do the same      operation, this time asynchronously. */   memset(&socket->write_info.overlapped, 0, sizeof(OVERLAPPED));-  status = WSASend(socket->socket, buffers, (DWORD)tcp->write_slices->count,-                   &bytes_sent, 0, &socket->write_info.overlapped, NULL);+  status = WSASend(socket->socket, buffers + async_buffers_offset,+                   (DWORD)(tcp->write_slices->count - async_buffers_offset),+                   NULL, 0, &socket->write_info.overlapped, NULL);   if (allocated) gpr_free(allocated);","Please note that the blocking behaviour of the first WSASend function on Windows hides the use-after free of the variable ""allocated"" (or the stack allocated version ""local_buffers"" that gets out of scope) of the non blocking second WSASend. In Windows this code is never reached.This is however another issue that is out of scope of this PR.",
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/28432,1026716925,2022-11-18T17:44:30Z,src/core/lib/iomgr/tcp_windows.cc,"@@ -391,27 +391,49 @@ static void win_write(grpc_endpoint* ep, grpc_slice_buffer* slices,   /* First, let's try a synchronous, non-blocking write. */   status = WSASend(socket->socket, buffers, (DWORD)tcp->write_slices->count,                    &bytes_sent, 0, NULL, NULL);-  info->wsa_error = status == 0 ? 0 : WSAGetLastError(); -  /* We would kind of expect to get a WSAEWOULDBLOCK here, especially on a busy-     connection that has its send queue filled up. But if we don't, then we can-     avoid doing an async write operation at all. */-  if (info->wsa_error != WSAEWOULDBLOCK) {-    grpc_error_handle error = status == 0-                                  ? absl::OkStatus()-                                  : GRPC_WSA_ERROR(info->wsa_error, ""WSASend"");-    grpc_core::ExecCtx::Run(DEBUG_LOCATION, cb, error);-    if (allocated) gpr_free(allocated);-    return;+  if (status == 0) {+    if (bytes_sent == tcp->write_slices->length) {+      info->wsa_error = 0;+      grpc_error_handle error = absl::OkStatus();+      grpc_core::ExecCtx::Run(DEBUG_LOCATION, cb, error);+      if (allocated) gpr_free(allocated);+      return;+    }++    /* The data was not completely delivered, we should send the rest of+       them by doing an async write operation. */+    for (i = 0; i < tcp->write_slices->count; i++) {+      if (buffers[i].len > bytes_sent) {+        buffers[i].buf += bytes_sent;+        buffers[i].len -= bytes_sent;+        break;+      }+      bytes_sent -= buffers[i].len;+      async_buffers_offset++;+    }+  } else {+    info->wsa_error = WSAGetLastError();++    /* We would kind of expect to get a WSAEWOULDBLOCK here, especially on a+       busy connection that has its send queue filled up. But if we don't, then+       we can avoid doing an async write operation at all. */+    if (info->wsa_error != WSAEWOULDBLOCK) {+      grpc_error_handle error = GRPC_WSA_ERROR(info->wsa_error, ""WSASend"");+      grpc_core::ExecCtx::Run(DEBUG_LOCATION, cb, error);+      if (allocated) gpr_free(allocated);+      return;+    }   }    TCP_REF(tcp, ""write"");    /* If we got a WSAEWOULDBLOCK earlier, then we need to re-do the same      operation, this time asynchronously. */   memset(&socket->write_info.overlapped, 0, sizeof(OVERLAPPED));-  status = WSASend(socket->socket, buffers, (DWORD)tcp->write_slices->count,-                   &bytes_sent, 0, &socket->write_info.overlapped, NULL);+  status = WSASend(socket->socket, buffers + async_buffers_offset,+                   (DWORD)(tcp->write_slices->count - async_buffers_offset),+                   NULL, 0, &socket->write_info.overlapped, NULL);   if (allocated) gpr_free(allocated);","I'm not sure that's right. Per the [WSASend docs](https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-wsasend):> If this function is completed in an overlapped manner, it is the Winsock service provider's responsibility to capture the [WSABUF](https://learn.microsoft.com/en-us/windows/desktop/api/ws2def/ns-ws2def-wsabuf) structures before returning from this call. This enables applications to build stack-based WSABUF arrays pointed to by the lpBuffers parameter.Deallocating the heap (and local) variables before returning shouldn't be an issue for the subsequent overlapped WSASend call. Do I maybe misunderstand your concern here?",
24593237,XuanWang-Amos,https://api.github.com/repos/grpc/grpc/pulls/31677,1026785859,2022-11-18T19:03:47Z,src/python/grpcio/grpc/_channel.py,"@@ -1439,15 +1588,19 @@ def _unsubscribe(state, callback):                 break  -def _augment_options(base_options, compression):+def _augment_options(+        base_options: Optional[ChannelArgumentType],","On second thought, we don't need `Optional` here, will remove it. (this comes from the 2nd return value of `_separate_channel_options`, it can be an empty list but not `None`)",
28025951,HannahShiSFB,https://api.github.com/repos/grpc/grpc/pulls/31555,1026790019,2022-11-18T19:08:53Z,src/objective-c/tests/CFStreamTests/CFStreamClientTests.mm,"@@ -0,0 +1,208 @@+/*+ *+ * Copyright 2018 gRPC authors.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ *     http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ *+ */++#import <XCTest/XCTest.h>",Its not possible to reference files in other directories in bazel.This copy is temporary until bazel apple rules 2.0 release which added sanitizer support. https://github.com/bazelbuild/rules_apple/releases,
24593237,XuanWang-Amos,https://api.github.com/repos/grpc/grpc/pulls/31677,1026791462,2022-11-18T19:10:51Z,src/python/grpcio/grpc/_channel.py,"@@ -1484,30 +1643,37 @@ def __init__(self, target, options, credentials, compression):         if cygrpc.g_gevent_activated:             cygrpc.gevent_increment_channel_count() -    def _process_python_options(self, python_options):+    def _process_python_options(+            self, python_options: Optional[ChannelArgumentType]) -> None:","Same as `core_options`, it can be an empty list but not `None`, will remove `Optional` here.",
1644595,gnossen,https://api.github.com/repos/grpc/grpc/pulls/31677,1026961193,2022-11-18T23:01:14Z,src/python/grpcio/grpc/_server.py,"@@ -321,36 +371,40 @@ def abort(self, code, details):             self._state.aborted = True             raise Exception() -    def abort_with_status(self, status):+    def abort_with_status(self, status: grpc.Status) -> None:         self._state.trailing_metadata = status.trailing_metadata         self.abort(status.code, status.details) -    def set_code(self, code):+    def set_code(self, code: grpc.StatusCode) -> None:         with self._state.condition:             self._state.code = code -    def code(self):+    def code(self) -> grpc.StatusCode:         return self._state.code -    def set_details(self, details):+    def set_details(self, details: str) -> None:         with self._state.condition:             self._state.details = _common.encode(details) -    def details(self):+    def details(self) -> bytes:","Uh-oh. This looks like an existing bug. From [the docs](https://grpc.github.io/grpc/python/grpc.html#grpc.ServicerContext.details): ""Accesses the value to be used as detail _string_ upon RPC completion."" I'm a bit torn on what to do here. This is technically an experimental method, so we have the ability to change it, but it's been here for a _while_.The downside here is that anyone using the existing API will have to encode the bytes to get back the string they set with `set_details`. We'll think about this as part of our ongoing API graduation process. I've noted it down.",
1644595,gnossen,https://api.github.com/repos/grpc/grpc/pulls/31677,1026976542,2022-11-18T23:40:20Z,src/python/grpcio/grpc/_server.py,"@@ -174,7 +207,10 @@ def _abort(state, call, code, details):         state.due.add(token)  -def _receive_close_on_server(state):+def _receive_close_on_server(+    state: _RPCState+) -> Callable[[cygrpc.BaseEvent], Tuple[Optional[_RPCState],","Can we pull out a common type for the return value of `_receive_close_on_server`, `_send_message`, `_receive_message`, `_send_initial_metadata`, `_send_status_from_server`? Maybe call it `ServerCallbackTag`? What they all have in common is that they are actually invoked [here](https://github.com/grpc/grpc/blob/c20455e8363836aae4750d4325704496a5a3c278/src/python/grpcio/grpc/_server.py#L985).",
1644595,gnossen,https://api.github.com/repos/grpc/grpc/pulls/31677,1026985435,2022-11-19T00:04:38Z,src/python/grpcio/grpc/_server.py,"@@ -233,60 +279,64 @@ def send_message(unused_send_message_event):   class _Context(grpc.ServicerContext):+    _rpc_event: cygrpc.BaseEvent+    _state: _RPCState+    request_deserializer: Optional[DeserializingFunction] -    def __init__(self, rpc_event, state, request_deserializer):+    def __init__(self, rpc_event: cygrpc.BaseEvent, state: _RPCState,+                 request_deserializer: Optional[DeserializingFunction]):         self._rpc_event = rpc_event         self._state = state         self._request_deserializer = request_deserializer -    def is_active(self):+    def is_active(self) -> bool:         with self._state.condition:             return _is_rpc_state_active(self._state) -    def time_remaining(self):+    def time_remaining(self) -> float:         return max(self._rpc_event.call_details.deadline - time.time(), 0) -    def cancel(self):+    def cancel(self) -> bool:         self._rpc_event.call.cancel() -    def add_callback(self, callback):+    def add_callback(self, callback: CallbackType) -> bool:         with self._state.condition:             if self._state.callbacks is None:                 return False             else:                 self._state.callbacks.append(callback)                 return True -    def disable_next_message_compression(self):+    def disable_next_message_compression(self) -> None:         with self._state.condition:             self._state.disable_next_compression = True -    def invocation_metadata(self):+    def invocation_metadata(self) -> Optional[MetadataType]:         return self._rpc_event.invocation_metadata -    def peer(self):+    def peer(self) -> str:         return _common.decode(self._rpc_event.call.peer()) -    def peer_identities(self):+    def peer_identities(self) -> Optional[Iterable[bytes]]:","I know that the docs call this out as an `Iterable`, but I think we can do better than that. In the Cython layer, it's actually [a list](https://github.com/grpc/grpc/blob/c20455e8363836aae4750d4325704496a5a3c278/src/python/grpcio/grpc/_cython/_cygrpc/security.pyx.pxi#L45). Can we be a bit more specific here and make this a sequence? If we don't, I think the first thing people will have to do after calling this method is iterate through it and put it _into_ a container:```pythonidentities = list(ctx.peer_identities)```when in reality, all that's happening here is copying a list to another list. We'll need to update the documentation too when we get around to doing the public portion of the types.",
1644595,gnossen,https://api.github.com/repos/grpc/grpc/pulls/31677,1027002794,2022-11-19T01:11:37Z,src/python/grpcio/grpc/_server.py,"@@ -945,49 +1069,60 @@ def _validate_generic_rpc_handlers(generic_rpc_handlers):                 'not have ""service"" method!'.format(generic_rpc_handler))  -def _augment_options(base_options, compression):+def _augment_options(+    base_options: Optional[Sequence[ChannelArgumentType]],",`base_options` cannot be `None` [at this layer](https://github.com/grpc/grpc/blob/c20455e8363836aae4750d4325704496a5a3c278/src/python/grpcio/grpc/__init__.py#L2070).,
24593237,XuanWang-Amos,https://api.github.com/repos/grpc/grpc/pulls/31677,1028489482,2022-11-21T20:30:22Z,src/python/grpcio/grpc/_server.py,"@@ -769,10 +869,28 @@ class _ServerStage(enum.Enum):   class _ServerState(object):+    lock: threading.RLock+    completion_queue: cygrpc.CompletionQueue+    server: cygrpc.Server+    generic_handlers: Optional[List[grpc.GenericRpcHandler]]+    interceptor_pipeline: Optional[_interceptor._ServicePipeline]+    thread_pool: futures.ThreadPoolExecutor+    stage: _ServerStage+    termination_event: threading.Event+    shutdown_events: Sequence","Is it possible to add other `Event` to this list? (Looks like we won't based on `_server.py`, but better to confirm).",
24593237,XuanWang-Amos,https://api.github.com/repos/grpc/grpc/pulls/31677,1028499675,2022-11-21T20:45:07Z,src/python/grpcio/grpc/_server.py,"@@ -793,30 +911,33 @@ def __init__(self, completion_queue, server, generic_handlers,         self.server_deallocated = False  -def _add_generic_handlers(state, generic_handlers):+def _add_generic_handlers(+        state: _ServerState,+        generic_handlers: Iterable[grpc.GenericRpcHandler]) -> None:","[add_generic_rpc_handlers](https://github.com/grpc/grpc/blob/master/src/python/grpcio/grpc/__init__.py#L1407) says it's expecting an iterable in public documentation, since not all `Iterable` are `Sequence`, change it to sequence might break some integration?",
1644595,gnossen,https://api.github.com/repos/grpc/grpc/pulls/31677,1028514314,2022-11-21T21:05:22Z,src/python/grpcio/grpc/_server.py,"@@ -793,30 +911,33 @@ def __init__(self, completion_queue, server, generic_handlers,         self.server_deallocated = False  -def _add_generic_handlers(state, generic_handlers):+def _add_generic_handlers(+        state: _ServerState,+        generic_handlers: Iterable[grpc.GenericRpcHandler]) -> None:","That's true. We _could_ convert to a sequence by doing `list(user_input)` somewhere near the top, but this is fine for now.",
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/31742,1029741257,2022-11-22T19:26:41Z,test/core/event_engine/windows/iocp_test.cc,"@@ -75,7 +81,10 @@ TEST_F(IOCPTest, ClientReceivesNotificationOfServerSend) {     // Expecting error 997, WSA_IO_PENDING     EXPECT_EQ(status, -1);     int last_error = WSAGetLastError();-    ASSERT_EQ(last_error, WSA_IO_PENDING);+    EXPECT_EQ(last_error, WSA_IO_PENDING);","Changing the public interface in `<grpc/support/log_windows.h>` is far out of scope, so this may be a bit awkward. We could wrap the method with something like:```std::unique_ptr<char*> GetWrappedFormattedMessage(int last_error, absl::string_view context) {   /* mechanics to get formatted message and wrap with w/ custom deleter */}ASSERT_EQ(last_error, WSA_IO_PENDING) << GetWrappedFormattedMessage(last_error, ""WSARecv"").get();```But I'm not sure it's worth the added complexity. We could also maybe tolerate the memory leak in these tests and ignore the need to free the `char*`, but I'd rather not risk it. Or we could tolerate a copy to std::string to avoid the need to free a `char*`.In future work, I'll be introducing canonical absl::Status conversions for Windows errors, which will make this cleaner. I'd suggest leaving it as is for now.",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/31735,1029909073,2022-11-22T23:27:20Z,src/core/lib/event_engine/windows/resolved_address.cc,"@@ -0,0 +1,97 @@+// Copyright 2022 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+#include <grpc/support/port_platform.h>++#ifdef GPR_WINDOWS++#include <errno.h>+#include <inttypes.h>+#include <winsock2.h>++#include ""absl/strings/str_format.h""++#include ""src/core/lib/event_engine/windows/resolved_address.h""+#include ""src/core/lib/gprpp/host_port.h""+#include ""src/core/lib/gprpp/status_helper.h""+#include ""src/core/lib/uri/uri_parser.h""++namespace grpc_event_engine {+namespace experimental {++namespace {+absl::StatusOr<std::string> GetScheme(+    const EventEngine::ResolvedAddress& resolved_address) {+  if (resolved_address.address()->sa_family == AF_INET) return ""ipv4"";+  if (resolved_address.address()->sa_family == AF_INET6) return ""ipv6"";+  return absl::InvalidArgumentError(absl::StrFormat(+      ""Unknown scheme: %d"", resolved_address.address()->sa_family));+}+}  // namespace++absl::StatusOr<std::string> ResolvedAddressToURI(+    const EventEngine::ResolvedAddress& resolved_address) {+  if (resolved_address.size() == 0) {+    return absl::InvalidArgumentError(""Empty address"");+  }+  auto scheme = GetScheme(resolved_address);+  GRPC_RETURN_IF_ERROR(scheme.status());+  auto path = ResolvedAddressToString(resolved_address);+  GRPC_RETURN_IF_ERROR(path.status());+  absl::StatusOr<grpc_core::URI> uri =+      grpc_core::URI::Create(*scheme, /*authority=*/"""", std::move(path.value()),+                             /*query_parameter_pairs=*/{}, /*fragment=*/"""");+  if (!uri.ok()) return uri.status();+  return uri->ToString();+}++// TODO(hork): implement normalization+absl::StatusOr<std::string> ResolvedAddressToString(","I count two implementations of this in the code base now, making this a third.Given this is relatively complex and bug-prone code to write & maintain, I'd like us to have a plan to get down to one. I'd strongly prefer that we never exceed two -- can this implementation be merged with another to achieve that?",X
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/31735,1029914096,2022-11-22T23:38:27Z,src/core/lib/event_engine/windows/windows_endpoint.cc,"@@ -0,0 +1,333 @@+// Copyright 2022 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+#include <grpc/support/port_platform.h>++#ifdef GPR_WINDOWS++#include ""absl/cleanup/cleanup.h""+#include ""absl/functional/any_invocable.h""+#include ""absl/status/status.h""+#include ""absl/strings/str_format.h""++#include <grpc/event_engine/memory_allocator.h>+#include <grpc/support/log_windows.h>++#include ""src/core/lib/event_engine/trace.h""+#include ""src/core/lib/event_engine/windows/resolved_address.h""+#include ""src/core/lib/event_engine/windows/windows_endpoint.h""+#include ""src/core/lib/gprpp/debug_location.h""+#include ""src/core/lib/gprpp/status_helper.h""++namespace grpc_event_engine {+namespace experimental {++// DO NOT SUBMIT(hork): we should be careful about the changes to the error+// return types, they were previously all Unavailable.+// TODO(hork): The previous implementation required internal ref counting. Add+// this when it becomes necessary.+// TODO(hork): The previous implementation required a 2-phase shutdown. Add this+// when it becomes necessary.++namespace {+constexpr int kDefaultTargetReadSize = 8192;+constexpr int kMaxWSABUFCount = 16;++void AbortOnEvent(absl::Status) {+  GPR_ASSERT(false &&+             ""INTERNAL ERROR: Asked to handle read/write event with an invalid ""+             ""callback"");+}++absl::Status WSAErrorToStatusWithMessage(+    int wsa_error, absl::string_view custom_message,+    const grpc_core::DebugLocation& location) {+  // See+  // https://learn.microsoft.com/en-us/windows/win32/api/Winsock2/nf-winsock2-wsasend+  // https://learn.microsoft.com/en-us/windows/win32/api/Winsock2/nf-winsock2-wsarecv+  char* wsa_message = gpr_format_message(wsa_error);+  std::string message;+  if (!custom_message.empty()) {+    std::string message = absl::StrCat(wsa_message, "": "", custom_message);+  } else {+    std::string message = wsa_message;+  }+  gpr_free(wsa_message);+  switch (wsa_error) {+    case 0:+      return absl::OkStatus();+    case WSAECONNRESET:+    case WSAECONNABORTED:+    case WSA_OPERATION_ABORTED:+      return StatusCreate(absl::StatusCode::kAborted, message, location, {});+    case WSAETIMEDOUT:+      return StatusCreate(absl::StatusCode::kDeadlineExceeded, message,+                          location, {});+    case WSAEFAULT:+    case WSAEINVAL:+      return StatusCreate(absl::StatusCode::kInvalidArgument, message, location,+                          {});+    case WSAENETDOWN:+    case WSAENOTCONN:+    case WSAESHUTDOWN:+      return StatusCreate(absl::StatusCode::kUnavailable, message, location,+                          {});+    default:+      return StatusCreate(absl::StatusCode::kUnknown, message, location, {});+  }+}++absl::Status WSAErrorToStatus(int wsa_error,+                              const grpc_core::DebugLocation& location) {+  return WSAErrorToStatusWithMessage(wsa_error, """", location);+}++}  // namespace++WindowsEndpoint::WindowsEndpoint(+    const EventEngine::ResolvedAddress& peer_address,+    std::unique_ptr<WinSocket> socket, MemoryAllocator&& allocator,+    const EndpointConfig& /* config */, Executor* executor)+    : peer_address_(peer_address),+      socket_(std::move(socket)),+      allocator_(std::move(allocator)),+      handle_read_event_(this),+      handle_write_event_(this),+      executor_(executor) {+  sockaddr addr;+  int addr_len = sizeof(addr);+  if (getsockname(socket_->socket(), &addr, &addr_len) < 0) {+    GPR_ASSERT(false &&+               ""Unrecoverable error: Failed to get local socket name."");+  }+  local_address_ = EventEngine::ResolvedAddress(&addr, addr_len);+  local_address_string_ = *ResolvedAddressToURI(local_address_);+  peer_address_string_ = *ResolvedAddressToURI(peer_address_);+}++WindowsEndpoint::~WindowsEndpoint() {+  socket_->MaybeShutdown(absl::OkStatus());+}++void WindowsEndpoint::Read(absl::AnyInvocable<void(absl::Status)> on_read,+                           SliceBuffer* buffer, const ReadArgs* /* args */) {+  // TODO(hork): last_read_buffer from iomgr: Is it only garbage, or optimized?+  GRPC_EVENT_ENGINE_TRACE(""WindowsEndpoint::%p reading"", this);+  // Prepare the WSABUF struct+  WSABUF wsa_buffers[kMaxWSABUFCount];+  // TODO(hork): use read hint instead of the default?+  if (buffer->Length() < kDefaultTargetReadSize &&+      buffer->Count() < kMaxWSABUFCount) {+    buffer->AppendIndexed(Slice(allocator_.MakeSlice(kDefaultTargetReadSize)));+  }+  GPR_ASSERT(buffer->Count() <= kMaxWSABUFCount);+  for (int i = 0; i < buffer->Count(); i++) {+    Slice tmp = buffer->RefSlice(i);+    wsa_buffers[i].buf = (char*)tmp.begin();+    wsa_buffers[i].len = tmp.size();+  }+  DWORD bytes_read = 0;+  DWORD flags = 0;+  // First let's try a synchronous, non-blocking read.+  int status = WSARecv(socket_->socket(), wsa_buffers, (DWORD)buffer->Count(),+                       &bytes_read, &flags, nullptr, nullptr);+  int wsa_error = status == 0 ? 0 : WSAGetLastError();+  // Did we get data immediately ? Yay.+  if (wsa_error != WSAEWOULDBLOCK) {+    // prune slicebuffer+    if (bytes_read != buffer->Length()) {+      buffer->RemoveLastNBytes(buffer->Length() - bytes_read);+    }+    executor_->Run([on_read = std::move(on_read)]() mutable {+      on_read(absl::OkStatus());+    });+    return;+  }+  // Otherwise, let's retry, by queuing a read.+  memset(socket_->read_info()->overlapped(), 0, sizeof(OVERLAPPED));+  status =+      WSARecv(socket_->socket(), wsa_buffers, (DWORD)buffer->Count(),+              &bytes_read, &flags, socket_->read_info()->overlapped(), nullptr);+  wsa_error = status == 0 ? 0 : WSAGetLastError();+  if (wsa_error != 0 && wsa_error != WSA_IO_PENDING) {+    // Async read returned immediately with an error+    executor_->Run([this, on_read = std::move(on_read), wsa_error]() mutable {+      on_read(WSAErrorToStatusWithMessage(+          wsa_error, absl::StrFormat(""WindowsEndpont::%p Read failed"", this),+          DEBUG_LOCATION));+    });+    return;+  }++  handle_read_event_.SetCallback(std::move(on_read));+  handle_read_event_.SetSliceBuffer(buffer);+  socket_->NotifyOnRead(&handle_read_event_);+}++void WindowsEndpoint::Write(absl::AnyInvocable<void(absl::Status)> on_writable,+                            SliceBuffer* data, const WriteArgs* /* args */) {+  if (grpc_event_engine_trace.enabled()) {+    for (int i = 0; i < data->Count(); i++) {+      auto str = data->RefSlice(i).as_string_view();+      gpr_log(GPR_INFO, ""WindowsEndpoint::%p WRITE (peer=%s): %.*s"", this,+              peer_address_string_.c_str(), str.length(), str.data());+    }+  }+  GPR_ASSERT(data->Count() <= UINT_MAX);+  WSABUF local_buffers[kMaxWSABUFCount];","suggest `absl::InlinedVector<WSABUF, kMaxWSABUFCount>` here and eschewing the complex hand allocation/deallocation",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/31735,1029915119,2022-11-22T23:40:47Z,src/core/lib/event_engine/windows/windows_endpoint.cc,"@@ -0,0 +1,333 @@+// Copyright 2022 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+#include <grpc/support/port_platform.h>++#ifdef GPR_WINDOWS++#include ""absl/cleanup/cleanup.h""+#include ""absl/functional/any_invocable.h""+#include ""absl/status/status.h""+#include ""absl/strings/str_format.h""++#include <grpc/event_engine/memory_allocator.h>+#include <grpc/support/log_windows.h>++#include ""src/core/lib/event_engine/trace.h""+#include ""src/core/lib/event_engine/windows/resolved_address.h""+#include ""src/core/lib/event_engine/windows/windows_endpoint.h""+#include ""src/core/lib/gprpp/debug_location.h""+#include ""src/core/lib/gprpp/status_helper.h""++namespace grpc_event_engine {+namespace experimental {++// DO NOT SUBMIT(hork): we should be careful about the changes to the error+// return types, they were previously all Unavailable.+// TODO(hork): The previous implementation required internal ref counting. Add+// this when it becomes necessary.+// TODO(hork): The previous implementation required a 2-phase shutdown. Add this+// when it becomes necessary.++namespace {+constexpr int kDefaultTargetReadSize = 8192;+constexpr int kMaxWSABUFCount = 16;++void AbortOnEvent(absl::Status) {+  GPR_ASSERT(false &&+             ""INTERNAL ERROR: Asked to handle read/write event with an invalid ""+             ""callback"");+}++absl::Status WSAErrorToStatusWithMessage(+    int wsa_error, absl::string_view custom_message,+    const grpc_core::DebugLocation& location) {+  // See+  // https://learn.microsoft.com/en-us/windows/win32/api/Winsock2/nf-winsock2-wsasend+  // https://learn.microsoft.com/en-us/windows/win32/api/Winsock2/nf-winsock2-wsarecv+  char* wsa_message = gpr_format_message(wsa_error);+  std::string message;+  if (!custom_message.empty()) {+    std::string message = absl::StrCat(wsa_message, "": "", custom_message);+  } else {+    std::string message = wsa_message;+  }+  gpr_free(wsa_message);+  switch (wsa_error) {+    case 0:+      return absl::OkStatus();+    case WSAECONNRESET:+    case WSAECONNABORTED:+    case WSA_OPERATION_ABORTED:+      return StatusCreate(absl::StatusCode::kAborted, message, location, {});+    case WSAETIMEDOUT:+      return StatusCreate(absl::StatusCode::kDeadlineExceeded, message,+                          location, {});+    case WSAEFAULT:+    case WSAEINVAL:+      return StatusCreate(absl::StatusCode::kInvalidArgument, message, location,+                          {});+    case WSAENETDOWN:+    case WSAENOTCONN:+    case WSAESHUTDOWN:+      return StatusCreate(absl::StatusCode::kUnavailable, message, location,+                          {});+    default:+      return StatusCreate(absl::StatusCode::kUnknown, message, location, {});+  }+}++absl::Status WSAErrorToStatus(int wsa_error,+                              const grpc_core::DebugLocation& location) {+  return WSAErrorToStatusWithMessage(wsa_error, """", location);+}++}  // namespace++WindowsEndpoint::WindowsEndpoint(+    const EventEngine::ResolvedAddress& peer_address,+    std::unique_ptr<WinSocket> socket, MemoryAllocator&& allocator,+    const EndpointConfig& /* config */, Executor* executor)+    : peer_address_(peer_address),+      socket_(std::move(socket)),+      allocator_(std::move(allocator)),+      handle_read_event_(this),+      handle_write_event_(this),+      executor_(executor) {+  sockaddr addr;+  int addr_len = sizeof(addr);+  if (getsockname(socket_->socket(), &addr, &addr_len) < 0) {+    GPR_ASSERT(false &&+               ""Unrecoverable error: Failed to get local socket name."");+  }+  local_address_ = EventEngine::ResolvedAddress(&addr, addr_len);+  local_address_string_ = *ResolvedAddressToURI(local_address_);+  peer_address_string_ = *ResolvedAddressToURI(peer_address_);+}++WindowsEndpoint::~WindowsEndpoint() {+  socket_->MaybeShutdown(absl::OkStatus());+}++void WindowsEndpoint::Read(absl::AnyInvocable<void(absl::Status)> on_read,+                           SliceBuffer* buffer, const ReadArgs* /* args */) {+  // TODO(hork): last_read_buffer from iomgr: Is it only garbage, or optimized?+  GRPC_EVENT_ENGINE_TRACE(""WindowsEndpoint::%p reading"", this);+  // Prepare the WSABUF struct+  WSABUF wsa_buffers[kMaxWSABUFCount];+  // TODO(hork): use read hint instead of the default?+  if (buffer->Length() < kDefaultTargetReadSize &&+      buffer->Count() < kMaxWSABUFCount) {+    buffer->AppendIndexed(Slice(allocator_.MakeSlice(kDefaultTargetReadSize)));+  }+  GPR_ASSERT(buffer->Count() <= kMaxWSABUFCount);+  for (int i = 0; i < buffer->Count(); i++) {+    Slice tmp = buffer->RefSlice(i);+    wsa_buffers[i].buf = (char*)tmp.begin();+    wsa_buffers[i].len = tmp.size();+  }+  DWORD bytes_read = 0;+  DWORD flags = 0;+  // First let's try a synchronous, non-blocking read.+  int status = WSARecv(socket_->socket(), wsa_buffers, (DWORD)buffer->Count(),+                       &bytes_read, &flags, nullptr, nullptr);+  int wsa_error = status == 0 ? 0 : WSAGetLastError();+  // Did we get data immediately ? Yay.+  if (wsa_error != WSAEWOULDBLOCK) {+    // prune slicebuffer+    if (bytes_read != buffer->Length()) {+      buffer->RemoveLastNBytes(buffer->Length() - bytes_read);+    }+    executor_->Run([on_read = std::move(on_read)]() mutable {+      on_read(absl::OkStatus());+    });+    return;+  }+  // Otherwise, let's retry, by queuing a read.+  memset(socket_->read_info()->overlapped(), 0, sizeof(OVERLAPPED));+  status =+      WSARecv(socket_->socket(), wsa_buffers, (DWORD)buffer->Count(),+              &bytes_read, &flags, socket_->read_info()->overlapped(), nullptr);+  wsa_error = status == 0 ? 0 : WSAGetLastError();+  if (wsa_error != 0 && wsa_error != WSA_IO_PENDING) {+    // Async read returned immediately with an error+    executor_->Run([this, on_read = std::move(on_read), wsa_error]() mutable {+      on_read(WSAErrorToStatusWithMessage(+          wsa_error, absl::StrFormat(""WindowsEndpont::%p Read failed"", this),+          DEBUG_LOCATION));+    });+    return;+  }++  handle_read_event_.SetCallback(std::move(on_read));+  handle_read_event_.SetSliceBuffer(buffer);+  socket_->NotifyOnRead(&handle_read_event_);+}++void WindowsEndpoint::Write(absl::AnyInvocable<void(absl::Status)> on_writable,+                            SliceBuffer* data, const WriteArgs* /* args */) {+  if (grpc_event_engine_trace.enabled()) {+    for (int i = 0; i < data->Count(); i++) {+      auto str = data->RefSlice(i).as_string_view();+      gpr_log(GPR_INFO, ""WindowsEndpoint::%p WRITE (peer=%s): %.*s"", this,+              peer_address_string_.c_str(), str.length(), str.data());+    }+  }+  GPR_ASSERT(data->Count() <= UINT_MAX);+  WSABUF local_buffers[kMaxWSABUFCount];+  LPWSABUF buffers = local_buffers;+  LPWSABUF allocated = nullptr;+  MemoryAllocator::Reservation memory_reservation;+  if (data->Count() > kMaxWSABUFCount) {+    size_t bytes_to_allocate = sizeof(WSABUF) * data->Count();+    memory_reservation = allocator_.MakeReservation(bytes_to_allocate);+    allocated = (WSABUF*)gpr_malloc(bytes_to_allocate);+    buffers = allocated;+  }+  for (int i = 0; i < data->Count(); i++) {+    auto slice = data->RefSlice(i);",meta: we need a way of getting this data out without referencing the contained slice - doing so is incredibly inefficient,
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/31735,1029925264,2022-11-23T00:05:45Z,src/core/lib/event_engine/windows/windows_endpoint.cc,"@@ -0,0 +1,333 @@+// Copyright 2022 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+#include <grpc/support/port_platform.h>++#ifdef GPR_WINDOWS++#include ""absl/cleanup/cleanup.h""+#include ""absl/functional/any_invocable.h""+#include ""absl/status/status.h""+#include ""absl/strings/str_format.h""++#include <grpc/event_engine/memory_allocator.h>+#include <grpc/support/log_windows.h>++#include ""src/core/lib/event_engine/trace.h""+#include ""src/core/lib/event_engine/windows/resolved_address.h""+#include ""src/core/lib/event_engine/windows/windows_endpoint.h""+#include ""src/core/lib/gprpp/debug_location.h""+#include ""src/core/lib/gprpp/status_helper.h""++namespace grpc_event_engine {+namespace experimental {++// DO NOT SUBMIT(hork): we should be careful about the changes to the error+// return types, they were previously all Unavailable.+// TODO(hork): The previous implementation required internal ref counting. Add+// this when it becomes necessary.+// TODO(hork): The previous implementation required a 2-phase shutdown. Add this+// when it becomes necessary.++namespace {+constexpr int kDefaultTargetReadSize = 8192;+constexpr int kMaxWSABUFCount = 16;++void AbortOnEvent(absl::Status) {+  GPR_ASSERT(false &&+             ""INTERNAL ERROR: Asked to handle read/write event with an invalid ""+             ""callback"");+}++absl::Status WSAErrorToStatusWithMessage(+    int wsa_error, absl::string_view custom_message,+    const grpc_core::DebugLocation& location) {+  // See+  // https://learn.microsoft.com/en-us/windows/win32/api/Winsock2/nf-winsock2-wsasend+  // https://learn.microsoft.com/en-us/windows/win32/api/Winsock2/nf-winsock2-wsarecv+  char* wsa_message = gpr_format_message(wsa_error);+  std::string message;+  if (!custom_message.empty()) {+    std::string message = absl::StrCat(wsa_message, "": "", custom_message);+  } else {+    std::string message = wsa_message;+  }+  gpr_free(wsa_message);+  switch (wsa_error) {+    case 0:+      return absl::OkStatus();+    case WSAECONNRESET:+    case WSAECONNABORTED:+    case WSA_OPERATION_ABORTED:+      return StatusCreate(absl::StatusCode::kAborted, message, location, {});+    case WSAETIMEDOUT:+      return StatusCreate(absl::StatusCode::kDeadlineExceeded, message,+                          location, {});+    case WSAEFAULT:+    case WSAEINVAL:+      return StatusCreate(absl::StatusCode::kInvalidArgument, message, location,+                          {});+    case WSAENETDOWN:+    case WSAENOTCONN:+    case WSAESHUTDOWN:+      return StatusCreate(absl::StatusCode::kUnavailable, message, location,+                          {});+    default:+      return StatusCreate(absl::StatusCode::kUnknown, message, location, {});+  }+}++absl::Status WSAErrorToStatus(int wsa_error,+                              const grpc_core::DebugLocation& location) {+  return WSAErrorToStatusWithMessage(wsa_error, """", location);+}++}  // namespace++WindowsEndpoint::WindowsEndpoint(+    const EventEngine::ResolvedAddress& peer_address,+    std::unique_ptr<WinSocket> socket, MemoryAllocator&& allocator,+    const EndpointConfig& /* config */, Executor* executor)+    : peer_address_(peer_address),+      socket_(std::move(socket)),+      allocator_(std::move(allocator)),+      handle_read_event_(this),+      handle_write_event_(this),+      executor_(executor) {+  sockaddr addr;+  int addr_len = sizeof(addr);+  if (getsockname(socket_->socket(), &addr, &addr_len) < 0) {+    GPR_ASSERT(false &&+               ""Unrecoverable error: Failed to get local socket name."");+  }+  local_address_ = EventEngine::ResolvedAddress(&addr, addr_len);+  local_address_string_ = *ResolvedAddressToURI(local_address_);+  peer_address_string_ = *ResolvedAddressToURI(peer_address_);+}++WindowsEndpoint::~WindowsEndpoint() {+  socket_->MaybeShutdown(absl::OkStatus());+}++void WindowsEndpoint::Read(absl::AnyInvocable<void(absl::Status)> on_read,+                           SliceBuffer* buffer, const ReadArgs* /* args */) {+  // TODO(hork): last_read_buffer from iomgr: Is it only garbage, or optimized?+  GRPC_EVENT_ENGINE_TRACE(""WindowsEndpoint::%p reading"", this);+  // Prepare the WSABUF struct+  WSABUF wsa_buffers[kMaxWSABUFCount];+  // TODO(hork): use read hint instead of the default?+  if (buffer->Length() < kDefaultTargetReadSize &&+      buffer->Count() < kMaxWSABUFCount) {+    buffer->AppendIndexed(Slice(allocator_.MakeSlice(kDefaultTargetReadSize)));+  }+  GPR_ASSERT(buffer->Count() <= kMaxWSABUFCount);+  for (int i = 0; i < buffer->Count(); i++) {+    Slice tmp = buffer->RefSlice(i);+    wsa_buffers[i].buf = (char*)tmp.begin();+    wsa_buffers[i].len = tmp.size();+  }+  DWORD bytes_read = 0;+  DWORD flags = 0;+  // First let's try a synchronous, non-blocking read.+  int status = WSARecv(socket_->socket(), wsa_buffers, (DWORD)buffer->Count(),+                       &bytes_read, &flags, nullptr, nullptr);+  int wsa_error = status == 0 ? 0 : WSAGetLastError();+  // Did we get data immediately ? Yay.+  if (wsa_error != WSAEWOULDBLOCK) {+    // prune slicebuffer+    if (bytes_read != buffer->Length()) {+      buffer->RemoveLastNBytes(buffer->Length() - bytes_read);+    }+    executor_->Run([on_read = std::move(on_read)]() mutable {+      on_read(absl::OkStatus());+    });+    return;+  }+  // Otherwise, let's retry, by queuing a read.+  memset(socket_->read_info()->overlapped(), 0, sizeof(OVERLAPPED));+  status =+      WSARecv(socket_->socket(), wsa_buffers, (DWORD)buffer->Count(),+              &bytes_read, &flags, socket_->read_info()->overlapped(), nullptr);+  wsa_error = status == 0 ? 0 : WSAGetLastError();+  if (wsa_error != 0 && wsa_error != WSA_IO_PENDING) {+    // Async read returned immediately with an error+    executor_->Run([this, on_read = std::move(on_read), wsa_error]() mutable {+      on_read(WSAErrorToStatusWithMessage(+          wsa_error, absl::StrFormat(""WindowsEndpont::%p Read failed"", this),+          DEBUG_LOCATION));+    });+    return;+  }++  handle_read_event_.SetCallback(std::move(on_read));+  handle_read_event_.SetSliceBuffer(buffer);+  socket_->NotifyOnRead(&handle_read_event_);+}++void WindowsEndpoint::Write(absl::AnyInvocable<void(absl::Status)> on_writable,+                            SliceBuffer* data, const WriteArgs* /* args */) {+  if (grpc_event_engine_trace.enabled()) {+    for (int i = 0; i < data->Count(); i++) {+      auto str = data->RefSlice(i).as_string_view();+      gpr_log(GPR_INFO, ""WindowsEndpoint::%p WRITE (peer=%s): %.*s"", this,+              peer_address_string_.c_str(), str.length(), str.data());+    }+  }+  GPR_ASSERT(data->Count() <= UINT_MAX);+  WSABUF local_buffers[kMaxWSABUFCount];+  LPWSABUF buffers = local_buffers;+  LPWSABUF allocated = nullptr;+  MemoryAllocator::Reservation memory_reservation;+  if (data->Count() > kMaxWSABUFCount) {+    size_t bytes_to_allocate = sizeof(WSABUF) * data->Count();+    memory_reservation = allocator_.MakeReservation(bytes_to_allocate);+    allocated = (WSABUF*)gpr_malloc(bytes_to_allocate);+    buffers = allocated;+  }+  for (int i = 0; i < data->Count(); i++) {+    auto slice = data->RefSlice(i);","I deleted a comment here along the lines of `// DO NOT SUBMIT: implement PeekSlice`, but did not want to complicate this PR with a public API change. I can do the public SliceBuffer change now in a separate PR. There are also ways we could add the functionality internally as a non-member helper function around the c slice buffer, but I think it's probably best in the public API.",
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/31735,1029925314,2022-11-23T00:05:50Z,src/core/lib/event_engine/windows/windows_endpoint.cc,"@@ -0,0 +1,333 @@+// Copyright 2022 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+#include <grpc/support/port_platform.h>++#ifdef GPR_WINDOWS++#include ""absl/cleanup/cleanup.h""+#include ""absl/functional/any_invocable.h""+#include ""absl/status/status.h""+#include ""absl/strings/str_format.h""++#include <grpc/event_engine/memory_allocator.h>+#include <grpc/support/log_windows.h>++#include ""src/core/lib/event_engine/trace.h""+#include ""src/core/lib/event_engine/windows/resolved_address.h""+#include ""src/core/lib/event_engine/windows/windows_endpoint.h""+#include ""src/core/lib/gprpp/debug_location.h""+#include ""src/core/lib/gprpp/status_helper.h""++namespace grpc_event_engine {+namespace experimental {++// DO NOT SUBMIT(hork): we should be careful about the changes to the error+// return types, they were previously all Unavailable.+// TODO(hork): The previous implementation required internal ref counting. Add+// this when it becomes necessary.+// TODO(hork): The previous implementation required a 2-phase shutdown. Add this+// when it becomes necessary.++namespace {+constexpr int kDefaultTargetReadSize = 8192;+constexpr int kMaxWSABUFCount = 16;++void AbortOnEvent(absl::Status) {+  GPR_ASSERT(false &&+             ""INTERNAL ERROR: Asked to handle read/write event with an invalid ""+             ""callback"");+}++absl::Status WSAErrorToStatusWithMessage(+    int wsa_error, absl::string_view custom_message,+    const grpc_core::DebugLocation& location) {+  // See+  // https://learn.microsoft.com/en-us/windows/win32/api/Winsock2/nf-winsock2-wsasend+  // https://learn.microsoft.com/en-us/windows/win32/api/Winsock2/nf-winsock2-wsarecv+  char* wsa_message = gpr_format_message(wsa_error);+  std::string message;+  if (!custom_message.empty()) {+    std::string message = absl::StrCat(wsa_message, "": "", custom_message);+  } else {+    std::string message = wsa_message;+  }+  gpr_free(wsa_message);+  switch (wsa_error) {+    case 0:+      return absl::OkStatus();+    case WSAECONNRESET:+    case WSAECONNABORTED:+    case WSA_OPERATION_ABORTED:+      return StatusCreate(absl::StatusCode::kAborted, message, location, {});+    case WSAETIMEDOUT:+      return StatusCreate(absl::StatusCode::kDeadlineExceeded, message,+                          location, {});+    case WSAEFAULT:+    case WSAEINVAL:+      return StatusCreate(absl::StatusCode::kInvalidArgument, message, location,+                          {});+    case WSAENETDOWN:+    case WSAENOTCONN:+    case WSAESHUTDOWN:+      return StatusCreate(absl::StatusCode::kUnavailable, message, location,+                          {});+    default:+      return StatusCreate(absl::StatusCode::kUnknown, message, location, {});+  }+}++absl::Status WSAErrorToStatus(int wsa_error,+                              const grpc_core::DebugLocation& location) {+  return WSAErrorToStatusWithMessage(wsa_error, """", location);+}++}  // namespace++WindowsEndpoint::WindowsEndpoint(+    const EventEngine::ResolvedAddress& peer_address,+    std::unique_ptr<WinSocket> socket, MemoryAllocator&& allocator,+    const EndpointConfig& /* config */, Executor* executor)+    : peer_address_(peer_address),+      socket_(std::move(socket)),+      allocator_(std::move(allocator)),+      handle_read_event_(this),+      handle_write_event_(this),+      executor_(executor) {+  sockaddr addr;+  int addr_len = sizeof(addr);+  if (getsockname(socket_->socket(), &addr, &addr_len) < 0) {+    GPR_ASSERT(false &&","Done. There are 84 other uses of `GPR_ASSERT(false && ""Reason"")` in the codebase at the moment, it's a pattern/smell that can be cleaned up if you feel so inclined.",X
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/31735,1029945875,2022-11-23T01:02:36Z,src/core/lib/event_engine/windows/windows_endpoint.cc,"@@ -0,0 +1,333 @@+// Copyright 2022 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+#include <grpc/support/port_platform.h>++#ifdef GPR_WINDOWS++#include ""absl/cleanup/cleanup.h""+#include ""absl/functional/any_invocable.h""+#include ""absl/status/status.h""+#include ""absl/strings/str_format.h""++#include <grpc/event_engine/memory_allocator.h>+#include <grpc/support/log_windows.h>++#include ""src/core/lib/event_engine/trace.h""+#include ""src/core/lib/event_engine/windows/resolved_address.h""+#include ""src/core/lib/event_engine/windows/windows_endpoint.h""+#include ""src/core/lib/gprpp/debug_location.h""+#include ""src/core/lib/gprpp/status_helper.h""++namespace grpc_event_engine {+namespace experimental {++// DO NOT SUBMIT(hork): we should be careful about the changes to the error+// return types, they were previously all Unavailable.+// TODO(hork): The previous implementation required internal ref counting. Add+// this when it becomes necessary.+// TODO(hork): The previous implementation required a 2-phase shutdown. Add this+// when it becomes necessary.++namespace {+constexpr int kDefaultTargetReadSize = 8192;+constexpr int kMaxWSABUFCount = 16;++void AbortOnEvent(absl::Status) {+  GPR_ASSERT(false &&+             ""INTERNAL ERROR: Asked to handle read/write event with an invalid ""+             ""callback"");+}++absl::Status WSAErrorToStatusWithMessage(+    int wsa_error, absl::string_view custom_message,+    const grpc_core::DebugLocation& location) {+  // See+  // https://learn.microsoft.com/en-us/windows/win32/api/Winsock2/nf-winsock2-wsasend+  // https://learn.microsoft.com/en-us/windows/win32/api/Winsock2/nf-winsock2-wsarecv+  char* wsa_message = gpr_format_message(wsa_error);+  std::string message;+  if (!custom_message.empty()) {+    std::string message = absl::StrCat(wsa_message, "": "", custom_message);+  } else {+    std::string message = wsa_message;+  }+  gpr_free(wsa_message);+  switch (wsa_error) {+    case 0:+      return absl::OkStatus();+    case WSAECONNRESET:+    case WSAECONNABORTED:+    case WSA_OPERATION_ABORTED:+      return StatusCreate(absl::StatusCode::kAborted, message, location, {});+    case WSAETIMEDOUT:+      return StatusCreate(absl::StatusCode::kDeadlineExceeded, message,+                          location, {});+    case WSAEFAULT:+    case WSAEINVAL:+      return StatusCreate(absl::StatusCode::kInvalidArgument, message, location,+                          {});+    case WSAENETDOWN:+    case WSAENOTCONN:+    case WSAESHUTDOWN:+      return StatusCreate(absl::StatusCode::kUnavailable, message, location,+                          {});+    default:+      return StatusCreate(absl::StatusCode::kUnknown, message, location, {});+  }+}++absl::Status WSAErrorToStatus(int wsa_error,+                              const grpc_core::DebugLocation& location) {+  return WSAErrorToStatusWithMessage(wsa_error, """", location);+}++}  // namespace++WindowsEndpoint::WindowsEndpoint(+    const EventEngine::ResolvedAddress& peer_address,+    std::unique_ptr<WinSocket> socket, MemoryAllocator&& allocator,+    const EndpointConfig& /* config */, Executor* executor)+    : peer_address_(peer_address),+      socket_(std::move(socket)),+      allocator_(std::move(allocator)),+      handle_read_event_(this),+      handle_write_event_(this),+      executor_(executor) {+  sockaddr addr;+  int addr_len = sizeof(addr);+  if (getsockname(socket_->socket(), &addr, &addr_len) < 0) {+    GPR_ASSERT(false &&+               ""Unrecoverable error: Failed to get local socket name."");+  }+  local_address_ = EventEngine::ResolvedAddress(&addr, addr_len);+  local_address_string_ = *ResolvedAddressToURI(local_address_);+  peer_address_string_ = *ResolvedAddressToURI(peer_address_);+}++WindowsEndpoint::~WindowsEndpoint() {+  socket_->MaybeShutdown(absl::OkStatus());+}++void WindowsEndpoint::Read(absl::AnyInvocable<void(absl::Status)> on_read,+                           SliceBuffer* buffer, const ReadArgs* /* args */) {+  // TODO(hork): last_read_buffer from iomgr: Is it only garbage, or optimized?+  GRPC_EVENT_ENGINE_TRACE(""WindowsEndpoint::%p reading"", this);+  // Prepare the WSABUF struct+  WSABUF wsa_buffers[kMaxWSABUFCount];+  // TODO(hork): use read hint instead of the default?","Agreed. `min_progress_size` is currently unused in the Windows iomgr implementation, but we can improve upon that here. I've added the override.",
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/31717,1030701734,2022-11-23T17:09:50Z,src/core/ext/filters/client_channel/resolver/polling_resolver.cc,"@@ -200,9 +200,18 @@ void PollingResolver::GetResultStatus(absl::Status status) {         gpr_log(GPR_INFO, ""[polling resolver %p] retrying immediately"", this);       }     }-    Ref(DEBUG_LOCATION, ""next_resolution_timer"").release();-    GRPC_CLOSURE_INIT(&on_next_resolution_, OnNextResolution, this, nullptr);-    grpc_timer_init(&next_resolution_timer_, next_try, &on_next_resolution_);+    next_resolution_timer_handle_ =","Now that this code is sizable and duplicated, it might be worth wrapping is inside a method like `ScheduleNextResolutionTimer(timeout)`, to be used here and on line 246.",X
5663878,yijiem,https://api.github.com/repos/grpc/grpc/pulls/31717,1030765922,2022-11-23T18:26:43Z,src/core/ext/filters/client_channel/resolver/polling_resolver.cc,"@@ -200,9 +200,18 @@ void PollingResolver::GetResultStatus(absl::Status status) {         gpr_log(GPR_INFO, ""[polling resolver %p] retrying immediately"", this);       }     }-    Ref(DEBUG_LOCATION, ""next_resolution_timer"").release();-    GRPC_CLOSURE_INIT(&on_next_resolution_, OnNextResolution, this, nullptr);-    grpc_timer_init(&next_resolution_timer_, next_try, &on_next_resolution_);+    next_resolution_timer_handle_ =+        event_engine_->RunAfter(timeout, [self = Ref()]() mutable {+          ApplicationCallbackExecCtx callback_exec_ctx;+          ExecCtx exec_ctx;+          auto* self_ptr = static_cast<PollingResolver*>(self.get());+          self_ptr->work_serializer_->Run(+              [self = std::move(self)]() {+                auto* self_ptr = static_cast<PollingResolver*>(self.get());","The Ref() call here returns a `RefCountedPtr<Resolver>`, `Resolver` is the parent class of `PollingResolver` and it does not have a (virtual) `OnNextResolutionLocked` member function, thus the downcast here.",
4181124,yashykt,https://api.github.com/repos/grpc/grpc/pulls/31634,1032873953,2022-11-27T06:21:49Z,src/core/ext/filters/client_channel/subchannel.cc,"@@ -777,12 +766,16 @@ void Subchannel::Orphan() {     subchannel_pool_->UnregisterSubchannel(key_, this);     subchannel_pool_.reset();   }-  MutexLock lock(&mu_);-  GPR_ASSERT(!shutdown_);-  shutdown_ = true;-  connector_.reset();-  connected_subchannel_.reset();-  health_watcher_map_.ShutdownLocked();+  {+    MutexLock lock(&mu_);+    GPR_ASSERT(!shutdown_);+    shutdown_ = true;+    connector_.reset();+    connected_subchannel_.reset();+    health_watcher_map_.ShutdownLocked();+  }+  // Drain any connectivity state notifications after releasing the mutex.+  work_serializer_.DrainQueue();","On line 784 and line 790 we lock the mutex but we don't drain the work serializer. What is the chance that `get_or_add` will in the future do a WorkSerializer schedule and cause things to get stuck, similar for line 790",
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/31638,1033250913,2022-11-28T08:34:28Z,src/csharp/Grpc.Tools.Tests/MsBuildIntegrationTest.cs,"@@ -0,0 +1,382 @@+#region Copyright notice and license++// Copyright 2022 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++#endregion++using System;+using System.IO;+using NUnit.Framework;+using System.Diagnostics;+using System.Reflection;+using System.Collections.Specialized;+using System.Collections;+using System.Collections.Generic;+using Newtonsoft.Json;++namespace Grpc.Tools.Tests+{+    /// <summary>+    /// Tests for Grpc.Tools MSBuild .target and .props files.+    /// </summary>+    /// <remarks>+    /// The Grpc.Tools NuGet package is not tested directly, but instead the+    /// same .target and .props files are included in a MSBuild project and+    /// that project is built using ""dotnet build"" with the SDK installed on+    /// the test machine.+    /// <para>+    /// The real protoc compiler is not called. Instead a fake protoc script is+    /// called that does the minimum work needed for the build to succeed+    /// (generating cs files and writing dependencies file) and also writes out+    /// the arguments it was called with in a JSON file. The output is checked+    /// with expected results.+    /// </para>+    /// </remarks>+    public class MsBuildIntegrationTest+    {+        private const string TASKS_ASSEMBLY_PROPERTY = ""_Protobuf_MsBuildAssembly"";+        private const string TASKS_ASSEMBLY_DLL = ""Protobuf.MSBuild.dll"";+        private const string PROTBUF_FULLPATH_PROPERTY = ""Protobuf_ProtocFullPath"";+        private const string PLUGIN_FULLPATH_PROPERTY = ""gRPC_PluginFullPath"";+        private const string TOOLS_BUILD_DIR_PROPERTY = ""GrpcToolsBuildDir"";++        private static bool isMono = Type.GetType(""Mono.Runtime"") != null;++        private void SkipIfMonoOrNet45()+        {+            // We only want to run these tests once. This test class is just a driver+            // for calling the ""dotnet build"" processes, so it doesn't matter what+            // the runtime of this class actually is.+            //+            // If we were to allow the tests to be run on both .NET Framework (or Mono) and+            // .NET Core then we could get into a situation where both are running in+            // parallel which would cause the tests to fail as both would be writing to+            // the same files.++            if (isMono)+            {+                Assert.Ignore(""Skipping test when mono runtime"");+            }+#if NET45+            Assert.Ignore(""Skipping test when NET45"");+#endif+        }++        [Test]+        public void TestSingleProto()+        {+            SkipIfMonoOrNet45();+            string testId = Guid.NewGuid().ToString();++            TryRunMsBuild(""TestSingleProto"",+                ""file.proto:File.cs;FileGrpc.cs"",+                testId+                );+        }++        [Test]+        public void TestMultipleProtos()+        {+            SkipIfMonoOrNet45();+            string testId = Guid.NewGuid().ToString();++            TryRunMsBuild(""TestMultipleProtos"",+                ""file.proto:File.cs;FileGrpc.cs"" ++                ""|protos/another.proto:Another.cs;AnotherGrpc.cs"" ++                ""|second.proto:Second.cs;SecondGrpc.cs"",+                testId+                );+        }++        [Test]+        public void TestAtInPath()+        {+            SkipIfMonoOrNet45();+            string testId = Guid.NewGuid().ToString();++            TryRunMsBuild(""TestAtInPath"",+                ""@protos/file.proto:File.cs;FileGrpc.cs"",+                testId+                );+        }++        [Test]+        public void TestProtoOutsideProject()+        {+            SkipIfMonoOrNet45();+            string testId = Guid.NewGuid().ToString();++            TryRunMsBuild(""TestProtoOutsideProject/project"",+                ""../api/greet.proto:Greet.cs;GreetGrpc.cs"",+                testId+                );+        }++        /// <summary>+        /// Run ""dotnet build"" on the test's project file.+        /// </summary>+        /// <param name=""testName"">Name of test and name of directory containing the test</param>+        /// <param name=""filesToGenerate"">Tell the fake protoc script which files to generate</param>+        /// <param name=""testId"">A unique ID for the test run - used to create results file</param>+        private void TryRunMsBuild(string testName, string filesToGenerate, string testId)","filesToGenerate string clearly has some internal structure. Should we pass a list/dictionary/list of lists to the function and have it construct the ""FAKEPROTOC_GENERATE_EXPECTED"" content automatically? There is not need for the callers to construct a long string with `;` and `|` dividers themselves. ",
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/31638,1033288776,2022-11-28T09:13:30Z,src/csharp/Grpc.Tools.Tests/scripts/fakeprotoc.py,"@@ -0,0 +1,327 @@+#!/usr/bin/env python3+# Copyright 2022 gRPC authors.+#+# Licensed under the Apache License, Version 2.0 (the ""License"");+# you may not use this file except in compliance with the License.+# You may obtain a copy of the License at+#+#     http://www.apache.org/licenses/LICENSE-2.0+#+# Unless required by applicable law or agreed to in writing, software+# distributed under the License is distributed on an ""AS IS"" BASIS,+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+# See the License for the specific language governing permissions and+# limitations under the License.++# Fake protobuf compiler for use in the Grpc.Tools MSBuild integration+# unit tests.  Its purpose is to be called from the Grpc.Tools +# Google.Protobuf.Tools.targets MSBuild file instead of the actual protoc+# compiler. This script:+# - parses the command line arguments+# - generates expected dependencies file+# - generates dummy .cs files that are expected by the tests+# - writes a JSON results file containing the arguments passed in++# Configuration is done via environment variables as it is not possible+# to pass additional argument when called from the MSBuild scripts under test.+#+# Environment variables:+# FAKEPROTOC_PROJECTDIR - output directory for generated files and output file+# FAKEPROTOC_GENERATE_EXPECTED - list of expected generated files in format:+#         file1.proto:csfile1.cs;csfile2.cs|file2.proto:csfile3.cs;csfile4.cs|...+# FAKEPROTOC_TESTID - unique id for the test used as name for JSON results file++import datetime+import hashlib+import json+import os+import sys++# Set to True to write out debug messages from this script+dbg = True+dbgfile = None++# Env variable: output directory for generated files and output file+FAKEPROTOC_PROJECTDIR = None+# Env variable: list of expected generated files+FAKEPROTOC_GENERATE_EXPECTED = None+# Env variable: unique id for the test used as name for JSON results file+FAKEPROTOC_TESTID = None++protoc_args = []+protoc_args_dict = {}+results_json = {}++dependencyfile = None+grpcout = None+protofile = None+proto_to_generated = {}++def create_debug(filename):+    """""" Create debug file for this script """"""+    global dbg+    global dbgfile+    if dbg:+        # append mode since this script may be called multiple times+        # during one build/test+        dbgfile = open(filename, ""a"")++def close_debug():+    """""" Close the debug file """"""+    global dbgfile+    if not dbgfile is None:+        dbgfile.close()++def write_debug(msg):+    """""" Write to the debug file if debug is enabled """"""+    global dbg+    global dbgfile+    if dbg and not dbgfile is None:+        print(msg, file=dbgfile, flush=True)++def read_protoc_arguments():+    """"""+    Read the protoc argument from the command line and+    any response files specified on the command line.++    Arguments are added to protoc_args for later parsing.+    """"""+    write_debug(""\nread_protoc_arguments"")+    global protoc_args+    for i in range(1, len(sys.argv), 1):+        arg = sys.argv[i]+        write_debug(""  arg: ""+arg)+        if arg.startswith(""@""):+            protoc_args.append(""# RSP file: ""+arg)+            read_rsp_file(arg[1:])+        else:+            protoc_args(arg)++def read_rsp_file(rspfile):+    """"""+    Read arguments from a response file.++    Arguments are added to protoc_args for later parsing.+    """"""+    write_debug(""\nread_rsp_file: ""+rspfile)+    global protoc_args+    with open(rspfile, ""r"") as rsp:+        for line in rsp:+            line = line.strip()+            write_debug(""    line: ""+line)+            protoc_args.append(line)++def parse_protoc_arguments():+    """"""+    Parse the protoc arguments that are in protoc_args+    """"""+    global protoc_args+    global dependencyfile+    global grpcout+    global protofile++    write_debug(""\nparse_protoc_arguments"")+    for arg in protoc_args:+        if dbg:+            write_debug(""Parsing: ""+arg)++        # All arguments containing file or directory paths are+        # normalised by converting to relative paths to the+        # project directory, and all '\' and changed to '/'+        if arg.startswith(""--""):+            (name, value) = arg.split(""="",1)++            if name == ""--dependency_out"":+                value = relative_to_project(value)+                dependencyfile = value+            elif name == ""--grpc_out"":+                value = relative_to_project(value)+                grpcout = value+            elif name in [ ""--grpc_out"", ""--proto_path"", ""--csharp_out"" ]:+                value = relative_to_project(value)++            add_protoc_arg_to_dict(name, value)++        elif arg.startswith(""#""):+            pass # ignore+        else:+            # proto file name+            protofile = relative_to_project(arg)+            add_protoc_arg_to_dict(""protofile"", protofile)++def add_protoc_arg_to_dict(name, value):+    """"""+    Add the arguments with name/value to protoc_args_dict++    protoc_args_dict is later used from writing out the JSON+    results file+    """"""+    global protoc_args_dict+    if name in protoc_args_dict:+        values = protoc_args_dict[name]+        values.append(value)+    else:+        protoc_args_dict[name] = [ value ]++def relative_to_project(file):+    """""" Convert a file path to one relative to the project directory """"""+    return normalise_slashes(os.path.relpath(os.path.abspath(file), FAKEPROTOC_PROJECTDIR))++def normalise_slashes(path):+    """""" Change all backslashes to forward slashes """"""+    return path.replace(""\\"",""/"")++def write_results_json(pf):+    """""" Write out the results JSON file """"""+    global protoc_args_dict+    global results_json+    global FAKEPROTOC_PROJECTDIR++    # Read existing json.+    # Since protoc may be called more than once each build/test if there is+    # more than one protoc file, we read the existing data to add to it.+    fname = os.path.abspath(FAKEPROTOC_PROJECTDIR+""/log/""+FAKEPROTOC_TESTID+"".json"")+    if os.path.isfile(fname):+        results_json = json.load(open(fname,""r""))+        protoc_files_dict = results_json.get(""Files"")+    else:+        results_json = {}+        protoc_files_dict = {}+        results_json[""Files""] = protoc_files_dict+    +    protofiles = protoc_args_dict.get(""protofile"")+    if protofiles is None:+        key = ""NONE""+    else:+        key = protofiles[0]+    results_json[""Metadata""] = { ""timestamp"": str(datetime.datetime.now()) }","what is the use of ""Metadata"" here?",
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/31638,1033296814,2022-11-28T09:21:03Z,src/csharp/Grpc.Tools.Tests/MsBuildIntegrationTest.cs,"@@ -0,0 +1,382 @@+#region Copyright notice and license++// Copyright 2022 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++#endregion++using System;+using System.IO;+using NUnit.Framework;+using System.Diagnostics;+using System.Reflection;+using System.Collections.Specialized;+using System.Collections;+using System.Collections.Generic;+using Newtonsoft.Json;++namespace Grpc.Tools.Tests+{+    /// <summary>+    /// Tests for Grpc.Tools MSBuild .target and .props files.+    /// </summary>+    /// <remarks>+    /// The Grpc.Tools NuGet package is not tested directly, but instead the+    /// same .target and .props files are included in a MSBuild project and+    /// that project is built using ""dotnet build"" with the SDK installed on+    /// the test machine.+    /// <para>+    /// The real protoc compiler is not called. Instead a fake protoc script is+    /// called that does the minimum work needed for the build to succeed+    /// (generating cs files and writing dependencies file) and also writes out+    /// the arguments it was called with in a JSON file. The output is checked+    /// with expected results.+    /// </para>+    /// </remarks>+    public class MsBuildIntegrationTest+    {+        private const string TASKS_ASSEMBLY_PROPERTY = ""_Protobuf_MsBuildAssembly"";+        private const string TASKS_ASSEMBLY_DLL = ""Protobuf.MSBuild.dll"";+        private const string PROTBUF_FULLPATH_PROPERTY = ""Protobuf_ProtocFullPath"";+        private const string PLUGIN_FULLPATH_PROPERTY = ""gRPC_PluginFullPath"";+        private const string TOOLS_BUILD_DIR_PROPERTY = ""GrpcToolsBuildDir"";++        private static bool isMono = Type.GetType(""Mono.Runtime"") != null;++        private void SkipIfMonoOrNet45()+        {+            // We only want to run these tests once. This test class is just a driver+            // for calling the ""dotnet build"" processes, so it doesn't matter what+            // the runtime of this class actually is.+            //+            // If we were to allow the tests to be run on both .NET Framework (or Mono) and+            // .NET Core then we could get into a situation where both are running in+            // parallel which would cause the tests to fail as both would be writing to+            // the same files.++            if (isMono)+            {+                Assert.Ignore(""Skipping test when mono runtime"");+            }+#if NET45+            Assert.Ignore(""Skipping test when NET45"");+#endif+        }++        [Test]+        public void TestSingleProto()+        {+            SkipIfMonoOrNet45();+            string testId = Guid.NewGuid().ToString();++            TryRunMsBuild(""TestSingleProto"",+                ""file.proto:File.cs;FileGrpc.cs"",+                testId+                );+        }++        [Test]+        public void TestMultipleProtos()+        {+            SkipIfMonoOrNet45();+            string testId = Guid.NewGuid().ToString();++            TryRunMsBuild(""TestMultipleProtos"",+                ""file.proto:File.cs;FileGrpc.cs"" ++                ""|protos/another.proto:Another.cs;AnotherGrpc.cs"" ++                ""|second.proto:Second.cs;SecondGrpc.cs"",+                testId+                );+        }++        [Test]+        public void TestAtInPath()+        {+            SkipIfMonoOrNet45();+            string testId = Guid.NewGuid().ToString();++            TryRunMsBuild(""TestAtInPath"",+                ""@protos/file.proto:File.cs;FileGrpc.cs"",+                testId+                );+        }++        [Test]+        public void TestProtoOutsideProject()+        {+            SkipIfMonoOrNet45();+            string testId = Guid.NewGuid().ToString();++            TryRunMsBuild(""TestProtoOutsideProject/project"",+                ""../api/greet.proto:Greet.cs;GreetGrpc.cs"",+                testId+                );+        }++        /// <summary>+        /// Run ""dotnet build"" on the test's project file.+        /// </summary>+        /// <param name=""testName"">Name of test and name of directory containing the test</param>+        /// <param name=""filesToGenerate"">Tell the fake protoc script which files to generate</param>+        /// <param name=""testId"">A unique ID for the test run - used to create results file</param>+        private void TryRunMsBuild(string testName, string filesToGenerate, string testId)+        {+            var assemblyDir = Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location);+            var parentDir = System.IO.Directory.GetParent(assemblyDir).FullName;++            // Path for fake proto+            var fakeProtocScript = Platform.IsWindows ? ""fakeprotoc.bat"" : ""fakeprotoc.py"";+            var fakeProtoc = Path.GetFullPath($""{parentDir}/../../scripts/{fakeProtocScript}"");++            // Paths for Grpc.Tools files+            var grpcToolsDir = Path.GetFullPath($""{parentDir}/../../../Grpc.Tools"");+            var grpcToolsBuildDir = Path.GetFullPath($""{grpcToolsDir}/build"");+            // Task assembly is needed to run the extension tasks+            var tasksAssembly = Path.GetFullPath($""{grpcToolsDir}/bin/Debug/netstandard1.3/{TASKS_ASSEMBLY_DLL}"");++            // Paths for test data+            var testdataDir = Path.GetFullPath(parentDir+ ""/../../Integration.Tests/"");+            var testDir = Path.GetFullPath(testdataDir + testName);++            Console.WriteLine($""testDir = {testDir}"");++            // Clean up test output dirs: bin obj log+            if (Directory.Exists(testDir+""/bin""))","alternatively, you could get rid of the DeleteDirectoryWithRetry and issues with parallel runs by simply generating a ""invocation_UUID"" directory for each run and putting bin/ obj/ and log/ directories under it. That way each run of the test will be completely independent and you won't have the inconsistently of having a UUID.json file with testId in the name, but msbuild.log and fakeprotoc-dbg.txt without it.",
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/31299,1033730207,2022-11-28T16:01:59Z,src/compiler/csharp_generator.cc,"@@ -110,6 +110,13 @@ bool GenerateDocCommentBody(grpc::protobuf::io::Printer* printer,   return GenerateDocCommentBodyImpl(printer, location); } +void GenerateObsoleteAttributeIfObsolete(grpc::protobuf::io::Printer* printer,+                                         const MethodDescriptor* method) {+  if (method->options().deprecated()) {+    printer->Print(""[global::System.Obsolete]\n"");","Generally, we only introduce a protoc option if it's absolutely necessary - the proliferation of protoc options makes it difficult to maintain and test our code and it also creates an exponential explosion of different variants of the generated code the user can have (and that we have to count on / test for). So we really don't want to add a new commandline option.I'm actually not convinced that marking service methods as deprecated in the .proto file is a practice worth recommending. IMHO that's an approach that doesn't follow the best practices for the lifecycle of protobuf-based gRPC services.  If you want to build backward-compatible services with gRPC + protobuf, you must not remove a method you once introduced anyway - otherwise clients will be broken. Once a method is added, it can only be removed when a new major version of the API is introduced (and the package name in the .proto file will change. e.g. google.testing.someapi.V1 package will be replaced by google.testing.someapi.V2).I'd be willing to consider the feature you're proposing if you can demonstrate that what you're proposing is consistent with protoc behavior in other languages (java, python, c++ etc.) and that there's a clear pattern we can follow.",X
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/31409,1033736293,2022-11-28T16:07:25Z,BUILDING.md,"@@ -83,8 +83,9 @@ to clone the gRPC repository at the [latest stable release tag](https://github.c > git submodule update --init ``` -NOTE: The `bazel` build tool uses a different model for dependencies. You only need to worry about downloading submodules if you're building-with something else than `bazel` (e.g. `cmake`).+> **Note**","Feel free to propose formatting changes / style improvements in a separate PR (where you ONLY make formatting/style/typo fixes), and I'm sure the review of that will be much easier and also much faster to accept/reject.With a big PR that changes the content AND makes style fixes at the same time it's going to be very difficult to move forward.",
5663878,yijiem,https://api.github.com/repos/grpc/grpc/pulls/31717,1034075708,2022-11-28T21:36:07Z,src/core/ext/filters/client_channel/resolver/polling_resolver.cc,"@@ -99,30 +104,41 @@ void PollingResolver::ShutdownLocked() {     gpr_log(GPR_INFO, ""[polling resolver %p] shutting down"", this);   }   shutdown_ = true;-  if (have_next_resolution_timer_) {-    grpc_timer_cancel(&next_resolution_timer_);+  if (next_resolution_timer_handle_.has_value()) {+    if (GPR_UNLIKELY(tracer_ != nullptr && tracer_->enabled())) {+      gpr_log(GPR_INFO, ""[polling resolver %p] cancel re-resolution timer"",+              this);+    }+    event_engine_->Cancel(*next_resolution_timer_handle_);   }   request_.reset(); } -void PollingResolver::OnNextResolution(void* arg, grpc_error_handle error) {-  auto* self = static_cast<PollingResolver*>(arg);-  self->work_serializer_->Run(-      [self, error]() { self->OnNextResolutionLocked(error); }, DEBUG_LOCATION);+void PollingResolver::ScheduleNextResolutionTimer(const Duration& timeout) {+  next_resolution_timer_handle_ =+      event_engine_->RunAfter(timeout, [self = Ref()]() mutable {+        ApplicationCallbackExecCtx callback_exec_ctx;+        ExecCtx exec_ctx;+        auto* self_ptr = static_cast<PollingResolver*>(self.get());+        self_ptr->work_serializer_->Run(+            [self = std::move(self)]() {+              auto* self_ptr = static_cast<PollingResolver*>(self.get());","The Ref() call returns a `RefCountedPtr<Resolver>`, `Resolver` is the parent class of `PollingResolver` and it does not have a (virtual) `OnNextResolutionLocked` member function, thus the downcast here.We could lift the `OnNextResolutionLocked` member function to `Resolver`, but I'm not sure if it would be relevant to other pull-based resolvers other than `PollingResolver`.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/31717,1034174184,2022-11-29T00:09:18Z,src/core/ext/filters/client_channel/resolver/polling_resolver.cc,"@@ -99,30 +104,41 @@ void PollingResolver::ShutdownLocked() {     gpr_log(GPR_INFO, ""[polling resolver %p] shutting down"", this);   }   shutdown_ = true;-  if (have_next_resolution_timer_) {-    grpc_timer_cancel(&next_resolution_timer_);+  if (next_resolution_timer_handle_.has_value()) {+    if (GPR_UNLIKELY(tracer_ != nullptr && tracer_->enabled())) {+      gpr_log(GPR_INFO, ""[polling resolver %p] cancel re-resolution timer"",+              this);+    }+    event_engine_->Cancel(*next_resolution_timer_handle_);   }   request_.reset(); } -void PollingResolver::OnNextResolution(void* arg, grpc_error_handle error) {-  auto* self = static_cast<PollingResolver*>(arg);-  self->work_serializer_->Run(-      [self, error]() { self->OnNextResolutionLocked(error); }, DEBUG_LOCATION);+void PollingResolver::ScheduleNextResolutionTimer(const Duration& timeout) {+  next_resolution_timer_handle_ =+      event_engine_->RunAfter(timeout, [self = Ref()]() mutable {+        ApplicationCallbackExecCtx callback_exec_ctx;+        ExecCtx exec_ctx;+        auto* self_ptr = static_cast<PollingResolver*>(self.get());+        self_ptr->work_serializer_->Run(+            [self = std::move(self)]() {+              auto* self_ptr = static_cast<PollingResolver*>(self.get());","This problem comes up a lot.  The fact that `Ref()` on a subclass of `Resolver` returns a pointer to the base class type instead of a pointer to the subclass is a problem, but I haven't had time to figure out a good solution.Fortunately, there's another bug in `RefCountedPtr<>` that offsets the above bug to some degree, which is that it allows down-casting without an explicit cast, which it really shouldn't.  But the fact that it does allow this means that you can do something like this:```RefCountedPtr<PollingResolver> self = Ref();channel_args_.GetObject<EventEngine>()->RunAfter(    timeout, [self = std::move(self)]() mutable { ... });```Now, inside the lambda, `self` is the subclass type, not the base class type.It would be good to find a way to fix both of those bugs.  The second bug should be fairly easy to fix, although I don't want to fix it until we also fix the first one. :)",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/31730,1035031786,2022-11-29T17:07:15Z,BUILD,"@@ -740,6 +740,7 @@ grpc_cc_library(         ""//src/core:grpc_lb_policy_ring_hash"",         ""//src/core:grpc_lb_policy_round_robin"",         ""//src/core:grpc_lb_policy_weighted_target"",+        ""//src/core:grpc_lb_policy_xds_override_host"",","This needs to be added to the `GRPC_XDS_TARGETS` list instead of being a direct dependency here, so that we don't include this when gRPC is built without xDS support.  You can test this by using the `--define=grpc_no_xds=true` flag with bazel.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/31730,1035038173,2022-11-29T17:13:03Z,test/core/client_channel/lb_policy/xds_override_host_disabled_test.cc,"@@ -0,0 +1,59 @@+//+// Copyright 2022 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+//++#include <stddef.h>++#include ""src/core/lib/gprpp/env.h""+#include ""test/core/client_channel/lb_policy/lb_policy_test_lib.h""+#include ""test/core/util/test_config.h""++namespace grpc_core {+namespace testing {+namespace {++class XdsOverrideHostDisabledTest : public LoadBalancingPolicyTest {+ protected:+  XdsOverrideHostDisabledTest()+      : policy_(MakeLbPolicy(""xds_override_host_experimental"")) {}++  OrphanablePtr<LoadBalancingPolicy> policy_;+};++TEST_F(XdsOverrideHostDisabledTest, NoPolicyAvailable) {","This doesn't need to be in its own file.  Let's move it to xds_override_host_test.cc.Note that instead of setting the env var and calling `grpc_init()` in main, you can do that in the `SetUpTestSuite()` and `TearDownTestSuite()` methods in the test class, so that you can set it differently for different tests in the same file (see [example](https://github.com/grpc/grpc/blob/024a0f738898c5440dc4fa0102f72e6712cbb748/test/cpp/end2end/rls_end2end_test.cc#L160)).",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/31730,1035039409,2022-11-29T17:14:14Z,test/core/client_channel/lb_policy/xds_override_host_disabled_test.cc,"@@ -0,0 +1,59 @@+//+// Copyright 2022 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+//++#include <stddef.h>++#include ""src/core/lib/gprpp/env.h""+#include ""test/core/client_channel/lb_policy/lb_policy_test_lib.h""+#include ""test/core/util/test_config.h""++namespace grpc_core {+namespace testing {+namespace {++class XdsOverrideHostDisabledTest : public LoadBalancingPolicyTest {+ protected:+  XdsOverrideHostDisabledTest()+      : policy_(MakeLbPolicy(""xds_override_host_experimental"")) {}++  OrphanablePtr<LoadBalancingPolicy> policy_;","I don't think we need this data member.  The test can just directly call `MakeLbPolicy()` and check the result.```using XdsOverrideHostDisabledTest = LoadBalancingPolicyTest;TEST_F(XdsOverrideHostDisabledTest, NoPolicyAvailable) {  EXPECT_EQ(MakeLbPolicy(""xds_override_host_experimental""), nullptr);}```",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/31730,1035049203,2022-11-29T17:23:29Z,src/core/ext/filters/client_channel/lb_policy/xds_override_host/xds_override_host.cc,"@@ -0,0 +1,404 @@+//+// Copyright 2022 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+//++#include <grpc/support/port_platform.h>++#include <inttypes.h>+#include <string.h>++#include <algorithm>+#include <memory>+#include <string>+#include <utility>+#include <vector>++#include ""absl/status/status.h""+#include ""absl/status/statusor.h""+#include ""absl/strings/str_cat.h""+#include ""absl/strings/string_view.h""+#include ""absl/types/optional.h""++#include <grpc/impl/codegen/connectivity_state.h>+#include <grpc/impl/codegen/grpc_types.h>+#include <grpc/support/log.h>++#include ""src/core/ext/filters/client_channel/lb_policy/child_policy_handler.h""+#include ""src/core/ext/filters/client_channel/lb_policy/subchannel_list.h""+#include ""src/core/lib/channel/channel_args.h""+#include ""src/core/lib/config/core_configuration.h""+#include ""src/core/lib/debug/trace.h""+#include ""src/core/lib/gprpp/debug_location.h""+#include ""src/core/lib/gprpp/env.h""+#include ""src/core/lib/gprpp/orphanable.h""+#include ""src/core/lib/gprpp/ref_counted_ptr.h""+#include ""src/core/lib/iomgr/pollset_set.h""+#include ""src/core/lib/json/json.h""+#include ""src/core/lib/load_balancing/lb_policy.h""+#include ""src/core/lib/load_balancing/lb_policy_factory.h""+#include ""src/core/lib/load_balancing/subchannel_interface.h""+#include ""src/core/lib/resolver/server_address.h""+#include ""src/core/lib/transport/connectivity_state.h""++namespace grpc_core {++TraceFlag grpc_lb_xds_override_host_trace(false, ""xds_override_host"");++namespace {++//+// xds_override_host LB policy+//++constexpr absl::string_view kXdsOverrideHost = ""xds_override_host_experimental"";++// Config for stateful session LB policy.+class XdsOverrideHostLbConfig : public LoadBalancingPolicy::Config {+ public:+  XdsOverrideHostLbConfig(+      RefCountedPtr<LoadBalancingPolicy::Config> child_policy)+      : child_policy_(std::move(child_policy)) {}++  absl::string_view name() const override { return kXdsOverrideHost; }++  RefCountedPtr<LoadBalancingPolicy::Config> child_policy() const {+    return child_policy_;+  }++ private:+  RefCountedPtr<LoadBalancingPolicy::Config> child_policy_;+};++// xDS Cluster Impl LB policy.+class XdsOverrideHostLb : public LoadBalancingPolicy {+ public:+  explicit XdsOverrideHostLb(Args args);++  absl::string_view name() const override { return kXdsOverrideHost; }++  absl::Status UpdateLocked(UpdateArgs args) override;+  void ExitIdleLocked() override;+  void ResetBackoffLocked() override;++ private:+  // A picker that wraps the picker from the child for cases when cookie is+  // present.+  class Picker : public SubchannelPicker {+   public:+    Picker(XdsOverrideHostLb* xds_override_host_lb,+           RefCountedPtr<SubchannelPicker> picker);++    PickResult Pick(PickArgs args) override;++   private:+    class SubchannelCallTracker;+    RefCountedPtr<SubchannelPicker> picker_;+  };++  class Helper : public ChannelControlHelper {+   public:+    explicit Helper(RefCountedPtr<XdsOverrideHostLb> xds_override_host_policy)+        : xds_override_host_policy_(std::move(xds_override_host_policy)) {}++    ~Helper() override {+      xds_override_host_policy_.reset(DEBUG_LOCATION, ""Helper"");+    }++    RefCountedPtr<SubchannelInterface> CreateSubchannel(+        ServerAddress address, const ChannelArgs& args) override;+    void UpdateState(grpc_connectivity_state state, const absl::Status& status,+                     RefCountedPtr<SubchannelPicker> picker) override;+    void RequestReresolution() override;+    absl::string_view GetAuthority() override;+    grpc_event_engine::experimental::EventEngine* GetEventEngine() override;+    void AddTraceEvent(TraceSeverity severity,+                       absl::string_view message) override;++   private:+    RefCountedPtr<XdsOverrideHostLb> xds_override_host_policy_;+  };++  ~XdsOverrideHostLb() override;++  static std::string MakeKeyForAddress(const ServerAddress& address);++  void ShutdownLocked() override;++  OrphanablePtr<LoadBalancingPolicy> CreateChildPolicyLocked(+      const ChannelArgs& args);++  void MaybeUpdatePickerLocked();++  // Current config from the resolver.+  RefCountedPtr<XdsOverrideHostLbConfig> config_;++  // Internal state.+  bool shutting_down_ = false;++  OrphanablePtr<LoadBalancingPolicy> child_policy_;++  // Latest state and picker reported by the child policy.+  grpc_connectivity_state state_ = GRPC_CHANNEL_IDLE;+  absl::Status status_;+  RefCountedPtr<SubchannelPicker> picker_;+};++//+// XdsOverrideHostLb::Picker+//++XdsOverrideHostLb::Picker::Picker(XdsOverrideHostLb* xds_override_host_lb,+                                  RefCountedPtr<SubchannelPicker> picker)+    : picker_(std::move(picker)) {+  if (GRPC_TRACE_FLAG_ENABLED(grpc_lb_xds_override_host_trace)) {+    gpr_log(GPR_INFO, ""[xds_override_host_lb %p] constructed new picker %p"",+            xds_override_host_lb, this);+  }+}++LoadBalancingPolicy::PickResult XdsOverrideHostLb::Picker::Pick(+    LoadBalancingPolicy::PickArgs args) {+  if (picker_ == nullptr) {  // Should never happen.+    return PickResult::Fail(absl::InternalError(+        ""xds_override_host picker not given any child picker""));+  }+  // Delegate to child picker+  return picker_->Pick(args);+}++//+// XdsOverrideHostLb+//++XdsOverrideHostLb::XdsOverrideHostLb(Args args)+    : LoadBalancingPolicy(std::move(args)) {+  if (GRPC_TRACE_FLAG_ENABLED(grpc_lb_xds_override_host_trace)) {+    gpr_log(GPR_INFO, ""[xds_override_host_lb %p] created"", this);+  }+}++XdsOverrideHostLb::~XdsOverrideHostLb() {+  if (GRPC_TRACE_FLAG_ENABLED(grpc_lb_xds_override_host_trace)) {+    gpr_log(GPR_INFO,+            ""[xds_override_host_lb %p] destroying xds_override_host LB policy"",+            this);+  }+}++void XdsOverrideHostLb::ShutdownLocked() {+  if (GRPC_TRACE_FLAG_ENABLED(grpc_lb_xds_override_host_trace)) {+    gpr_log(GPR_INFO, ""[xds_override_host_lb %p] shutting down"", this);+  }+  shutting_down_ = true;+  // Remove the child policy's interested_parties pollset_set from the+  // xDS policy.+  if (child_policy_ != nullptr) {+    // grpc_pollset_set_del_pollset_set(child_policy_->interested_parties(),+    //                                  interested_parties());+    child_policy_.reset();+  }+  // Drop our ref to the child's picker, in case it's holding a ref to+  // the child.+  picker_.reset();+}++void XdsOverrideHostLb::ExitIdleLocked() {+  if (child_policy_ != nullptr) child_policy_->ExitIdleLocked();+}++void XdsOverrideHostLb::ResetBackoffLocked() {+  if (child_policy_ != nullptr) child_policy_->ResetBackoffLocked();+}++absl::Status XdsOverrideHostLb::UpdateLocked(UpdateArgs args) {+  if (GRPC_TRACE_FLAG_ENABLED(grpc_lb_xds_override_host_trace)) {+    gpr_log(GPR_INFO, ""[xds_override_host_lb %p] Received update"", this);+  }+  auto old_config = std::move(config_);+  // Update config.+  config_ = std::move(args.config);+  if (config_ == nullptr) {+    return absl::InvalidArgumentError(""Missing policy config"");+  }+  // Create child policy if needed.+  if (child_policy_ == nullptr) {+    child_policy_ = CreateChildPolicyLocked(args.args);+  }+  // Update child policy.+  UpdateArgs update_args;+  update_args.addresses = std::move(args.addresses);+  update_args.resolution_note = std::move(args.resolution_note);+  update_args.config = config_->child_policy();+  // Update the policy.+  update_args.args = std::move(args.args);+  if (GRPC_TRACE_FLAG_ENABLED(grpc_lb_xds_override_host_trace)) {+    gpr_log(GPR_INFO,+            ""[xds_override_host_lb %p] Updating child policy handler %p"", this,+            child_policy_.get());+  }+  return child_policy_->UpdateLocked(std::move(update_args));+}++void XdsOverrideHostLb::MaybeUpdatePickerLocked() {+  if (picker_ != nullptr) {+    auto xds_override_host_picker = MakeRefCounted<Picker>(this, picker_);+    if (GRPC_TRACE_FLAG_ENABLED(grpc_lb_xds_override_host_trace)) {+      gpr_log(GPR_INFO,+              ""[xds_override_host_lb %p] updating connectivity: state=%s ""+              ""status=(%s) picker=%p"",+              this, ConnectivityStateName(state_), status_.ToString().c_str(),+              xds_override_host_picker.get());+    }+    channel_control_helper()->UpdateState(state_, status_,+                                          std::move(xds_override_host_picker));+  }+}++OrphanablePtr<LoadBalancingPolicy> XdsOverrideHostLb::CreateChildPolicyLocked(+    const ChannelArgs& args) {+  LoadBalancingPolicy::Args lb_policy_args;+  lb_policy_args.work_serializer = work_serializer();+  lb_policy_args.args = args;+  lb_policy_args.channel_control_helper =+      std::make_unique<Helper>(Ref(DEBUG_LOCATION, ""Helper""));+  OrphanablePtr<LoadBalancingPolicy> lb_policy =+      MakeOrphanable<ChildPolicyHandler>(std::move(lb_policy_args),+                                         &grpc_lb_xds_override_host_trace);+  if (GRPC_TRACE_FLAG_ENABLED(grpc_lb_xds_override_host_trace)) {+    gpr_log(GPR_INFO,+            ""[xds_override_host_lb %p] Created new child policy handler %p"",+            this, lb_policy.get());+  }+  // Add our interested_parties pollset_set to that of the newly created+  // child policy. This will make the child policy progress upon activity on+  // this policy, which in turn is tied to the application's call.+  grpc_pollset_set_add_pollset_set(lb_policy->interested_parties(),+                                   interested_parties());+  return lb_policy;+}++//+// XdsOverrideHostLb::Helper+//++RefCountedPtr<SubchannelInterface> XdsOverrideHostLb::Helper::CreateSubchannel(+    ServerAddress address, const ChannelArgs& args) {+  return xds_override_host_policy_->channel_control_helper()->CreateSubchannel(+      address, args);+}++void XdsOverrideHostLb::Helper::UpdateState(+    grpc_connectivity_state state, const absl::Status& status,+    RefCountedPtr<SubchannelPicker> picker) {+  if (xds_override_host_policy_->shutting_down_) return;+  if (GRPC_TRACE_FLAG_ENABLED(grpc_lb_xds_override_host_trace)) {+    gpr_log(GPR_INFO,+            ""[xds_override_host_lb %p] child connectivity state update: ""+            ""state=%s (%s) picker=%p"",+            xds_override_host_policy_.get(), ConnectivityStateName(state),+            status.ToString().c_str(), picker.get());+  }+  // Save the state and picker.+  xds_override_host_policy_->state_ = state;+  xds_override_host_policy_->status_ = status;+  xds_override_host_policy_->picker_ = std::move(picker);+  // Wrap the picker and return it to the channel.+  xds_override_host_policy_->MaybeUpdatePickerLocked();+}++void XdsOverrideHostLb::Helper::RequestReresolution() {+  if (xds_override_host_policy_->shutting_down_) return;+  xds_override_host_policy_->channel_control_helper()->RequestReresolution();+}++absl::string_view XdsOverrideHostLb::Helper::GetAuthority() {+  return xds_override_host_policy_->channel_control_helper()->GetAuthority();+}++grpc_event_engine::experimental::EventEngine*+XdsOverrideHostLb::Helper::GetEventEngine() {+  return xds_override_host_policy_->channel_control_helper()->GetEventEngine();+}++void XdsOverrideHostLb::Helper::AddTraceEvent(TraceSeverity severity,+                                              absl::string_view message) {+  if (xds_override_host_policy_->shutting_down_) return;+  xds_override_host_policy_->channel_control_helper()->AddTraceEvent(severity,+                                                                     message);+}++//+// factory+//+class XdsOverrideHostLbFactory : public LoadBalancingPolicyFactory {+ public:+  OrphanablePtr<LoadBalancingPolicy> CreateLoadBalancingPolicy(+      LoadBalancingPolicy::Args args) const override {+    return MakeOrphanable<XdsOverrideHostLb>(std::move(args));+  }++  absl::string_view name() const override { return kXdsOverrideHost; }++  absl::StatusOr<RefCountedPtr<LoadBalancingPolicy::Config>>+  ParseLoadBalancingConfig(const Json& json) const override {+    if (json.type() == Json::Type::JSON_NULL) {+      // This policy was configured in the deprecated loadBalancingPolicy+      // field or in the client API.+      return absl::InvalidArgumentError(+          ""field:loadBalancingPolicy error:xds_override_host policy requires ""+          ""configuration. Please use loadBalancingConfig field of service ""+          ""config instead."");+    }+    ValidationErrors errors;+    RefCountedPtr<LoadBalancingPolicy::Config> child_policy;+    {+      // Parse childPolicy manually.+      {+        ValidationErrors::ScopedField field(&errors, "".childPolicy"");+        auto it = json.object_value().find(""childPolicy"");+        if (it == json.object_value().end()) {+          errors.AddError(""field not present"");+        } else {+          auto child_policy_config = CoreConfiguration::Get()+                                         .lb_policy_registry()+                                         .ParseLoadBalancingConfig(it->second);+          if (!child_policy_config.ok()) {+            errors.AddError(child_policy_config.status().message());+          } else {+            child_policy = std::move(*child_policy_config);+          }+        }+      }+    }+    if (!errors.ok()) {+      return errors.status(+          ""errors validating xds_override_host LB policy config"");+    }+    return MakeRefCounted<XdsOverrideHostLbConfig>(std::move(child_policy));+  }+};++}  // namespace++void RegisterXdsOverrideHostLbPolicy(CoreConfiguration::Builder* builder) {+  auto enabled = absl::AsciiStrToLower(","Please use the same logic that we use elsewhere for parsing the experimental env var:https://github.com/grpc/grpc/blob/024a0f738898c5440dc4fa0102f72e6712cbb748/src/core/ext/xds/xds_cluster.cc#L70Note that the existing logic accepts values other than just ""true"".",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/31730,1035055417,2022-11-29T17:29:16Z,src/core/ext/filters/client_channel/lb_policy/xds_override_host/xds_override_host.cc,"@@ -0,0 +1,404 @@+//+// Copyright 2022 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+//++#include <grpc/support/port_platform.h>++#include <inttypes.h>+#include <string.h>++#include <algorithm>+#include <memory>+#include <string>+#include <utility>+#include <vector>++#include ""absl/status/status.h""+#include ""absl/status/statusor.h""+#include ""absl/strings/str_cat.h""+#include ""absl/strings/string_view.h""+#include ""absl/types/optional.h""++#include <grpc/impl/codegen/connectivity_state.h>+#include <grpc/impl/codegen/grpc_types.h>+#include <grpc/support/log.h>++#include ""src/core/ext/filters/client_channel/lb_policy/child_policy_handler.h""+#include ""src/core/ext/filters/client_channel/lb_policy/subchannel_list.h""+#include ""src/core/lib/channel/channel_args.h""+#include ""src/core/lib/config/core_configuration.h""+#include ""src/core/lib/debug/trace.h""+#include ""src/core/lib/gprpp/debug_location.h""+#include ""src/core/lib/gprpp/env.h""+#include ""src/core/lib/gprpp/orphanable.h""+#include ""src/core/lib/gprpp/ref_counted_ptr.h""+#include ""src/core/lib/iomgr/pollset_set.h""+#include ""src/core/lib/json/json.h""+#include ""src/core/lib/load_balancing/lb_policy.h""+#include ""src/core/lib/load_balancing/lb_policy_factory.h""+#include ""src/core/lib/load_balancing/subchannel_interface.h""+#include ""src/core/lib/resolver/server_address.h""+#include ""src/core/lib/transport/connectivity_state.h""++namespace grpc_core {++TraceFlag grpc_lb_xds_override_host_trace(false, ""xds_override_host"");++namespace {++//+// xds_override_host LB policy+//++constexpr absl::string_view kXdsOverrideHost = ""xds_override_host_experimental"";++// Config for stateful session LB policy.+class XdsOverrideHostLbConfig : public LoadBalancingPolicy::Config {+ public:+  XdsOverrideHostLbConfig(+      RefCountedPtr<LoadBalancingPolicy::Config> child_policy)+      : child_policy_(std::move(child_policy)) {}++  absl::string_view name() const override { return kXdsOverrideHost; }++  RefCountedPtr<LoadBalancingPolicy::Config> child_policy() const {+    return child_policy_;+  }++ private:+  RefCountedPtr<LoadBalancingPolicy::Config> child_policy_;+};++// xDS Cluster Impl LB policy.+class XdsOverrideHostLb : public LoadBalancingPolicy {+ public:+  explicit XdsOverrideHostLb(Args args);++  absl::string_view name() const override { return kXdsOverrideHost; }++  absl::Status UpdateLocked(UpdateArgs args) override;+  void ExitIdleLocked() override;+  void ResetBackoffLocked() override;++ private:+  // A picker that wraps the picker from the child for cases when cookie is+  // present.+  class Picker : public SubchannelPicker {+   public:+    Picker(XdsOverrideHostLb* xds_override_host_lb,+           RefCountedPtr<SubchannelPicker> picker);++    PickResult Pick(PickArgs args) override;++   private:+    class SubchannelCallTracker;+    RefCountedPtr<SubchannelPicker> picker_;+  };++  class Helper : public ChannelControlHelper {+   public:+    explicit Helper(RefCountedPtr<XdsOverrideHostLb> xds_override_host_policy)+        : xds_override_host_policy_(std::move(xds_override_host_policy)) {}++    ~Helper() override {+      xds_override_host_policy_.reset(DEBUG_LOCATION, ""Helper"");+    }++    RefCountedPtr<SubchannelInterface> CreateSubchannel(+        ServerAddress address, const ChannelArgs& args) override;+    void UpdateState(grpc_connectivity_state state, const absl::Status& status,+                     RefCountedPtr<SubchannelPicker> picker) override;+    void RequestReresolution() override;+    absl::string_view GetAuthority() override;+    grpc_event_engine::experimental::EventEngine* GetEventEngine() override;+    void AddTraceEvent(TraceSeverity severity,+                       absl::string_view message) override;++   private:+    RefCountedPtr<XdsOverrideHostLb> xds_override_host_policy_;+  };++  ~XdsOverrideHostLb() override;++  static std::string MakeKeyForAddress(const ServerAddress& address);++  void ShutdownLocked() override;++  OrphanablePtr<LoadBalancingPolicy> CreateChildPolicyLocked(+      const ChannelArgs& args);++  void MaybeUpdatePickerLocked();++  // Current config from the resolver.+  RefCountedPtr<XdsOverrideHostLbConfig> config_;++  // Internal state.+  bool shutting_down_ = false;++  OrphanablePtr<LoadBalancingPolicy> child_policy_;++  // Latest state and picker reported by the child policy.+  grpc_connectivity_state state_ = GRPC_CHANNEL_IDLE;+  absl::Status status_;+  RefCountedPtr<SubchannelPicker> picker_;+};++//+// XdsOverrideHostLb::Picker+//++XdsOverrideHostLb::Picker::Picker(XdsOverrideHostLb* xds_override_host_lb,+                                  RefCountedPtr<SubchannelPicker> picker)+    : picker_(std::move(picker)) {+  if (GRPC_TRACE_FLAG_ENABLED(grpc_lb_xds_override_host_trace)) {+    gpr_log(GPR_INFO, ""[xds_override_host_lb %p] constructed new picker %p"",+            xds_override_host_lb, this);+  }+}++LoadBalancingPolicy::PickResult XdsOverrideHostLb::Picker::Pick(+    LoadBalancingPolicy::PickArgs args) {+  if (picker_ == nullptr) {  // Should never happen.+    return PickResult::Fail(absl::InternalError(+        ""xds_override_host picker not given any child picker""));+  }+  // Delegate to child picker+  return picker_->Pick(args);+}++//+// XdsOverrideHostLb+//++XdsOverrideHostLb::XdsOverrideHostLb(Args args)+    : LoadBalancingPolicy(std::move(args)) {+  if (GRPC_TRACE_FLAG_ENABLED(grpc_lb_xds_override_host_trace)) {+    gpr_log(GPR_INFO, ""[xds_override_host_lb %p] created"", this);+  }+}++XdsOverrideHostLb::~XdsOverrideHostLb() {+  if (GRPC_TRACE_FLAG_ENABLED(grpc_lb_xds_override_host_trace)) {+    gpr_log(GPR_INFO,+            ""[xds_override_host_lb %p] destroying xds_override_host LB policy"",+            this);+  }+}++void XdsOverrideHostLb::ShutdownLocked() {+  if (GRPC_TRACE_FLAG_ENABLED(grpc_lb_xds_override_host_trace)) {+    gpr_log(GPR_INFO, ""[xds_override_host_lb %p] shutting down"", this);+  }+  shutting_down_ = true;+  // Remove the child policy's interested_parties pollset_set from the+  // xDS policy.+  if (child_policy_ != nullptr) {+    // grpc_pollset_set_del_pollset_set(child_policy_->interested_parties(),+    //                                  interested_parties());+    child_policy_.reset();+  }+  // Drop our ref to the child's picker, in case it's holding a ref to+  // the child.+  picker_.reset();+}++void XdsOverrideHostLb::ExitIdleLocked() {+  if (child_policy_ != nullptr) child_policy_->ExitIdleLocked();+}++void XdsOverrideHostLb::ResetBackoffLocked() {+  if (child_policy_ != nullptr) child_policy_->ResetBackoffLocked();+}++absl::Status XdsOverrideHostLb::UpdateLocked(UpdateArgs args) {+  if (GRPC_TRACE_FLAG_ENABLED(grpc_lb_xds_override_host_trace)) {+    gpr_log(GPR_INFO, ""[xds_override_host_lb %p] Received update"", this);+  }+  auto old_config = std::move(config_);+  // Update config.+  config_ = std::move(args.config);+  if (config_ == nullptr) {+    return absl::InvalidArgumentError(""Missing policy config"");+  }+  // Create child policy if needed.+  if (child_policy_ == nullptr) {+    child_policy_ = CreateChildPolicyLocked(args.args);+  }+  // Update child policy.+  UpdateArgs update_args;+  update_args.addresses = std::move(args.addresses);+  update_args.resolution_note = std::move(args.resolution_note);+  update_args.config = config_->child_policy();+  // Update the policy.+  update_args.args = std::move(args.args);+  if (GRPC_TRACE_FLAG_ENABLED(grpc_lb_xds_override_host_trace)) {+    gpr_log(GPR_INFO,+            ""[xds_override_host_lb %p] Updating child policy handler %p"", this,+            child_policy_.get());+  }+  return child_policy_->UpdateLocked(std::move(update_args));+}++void XdsOverrideHostLb::MaybeUpdatePickerLocked() {+  if (picker_ != nullptr) {+    auto xds_override_host_picker = MakeRefCounted<Picker>(this, picker_);+    if (GRPC_TRACE_FLAG_ENABLED(grpc_lb_xds_override_host_trace)) {+      gpr_log(GPR_INFO,+              ""[xds_override_host_lb %p] updating connectivity: state=%s ""+              ""status=(%s) picker=%p"",+              this, ConnectivityStateName(state_), status_.ToString().c_str(),+              xds_override_host_picker.get());+    }+    channel_control_helper()->UpdateState(state_, status_,+                                          std::move(xds_override_host_picker));+  }+}++OrphanablePtr<LoadBalancingPolicy> XdsOverrideHostLb::CreateChildPolicyLocked(+    const ChannelArgs& args) {+  LoadBalancingPolicy::Args lb_policy_args;+  lb_policy_args.work_serializer = work_serializer();+  lb_policy_args.args = args;+  lb_policy_args.channel_control_helper =+      std::make_unique<Helper>(Ref(DEBUG_LOCATION, ""Helper""));+  OrphanablePtr<LoadBalancingPolicy> lb_policy =+      MakeOrphanable<ChildPolicyHandler>(std::move(lb_policy_args),+                                         &grpc_lb_xds_override_host_trace);+  if (GRPC_TRACE_FLAG_ENABLED(grpc_lb_xds_override_host_trace)) {+    gpr_log(GPR_INFO,+            ""[xds_override_host_lb %p] Created new child policy handler %p"",+            this, lb_policy.get());+  }+  // Add our interested_parties pollset_set to that of the newly created+  // child policy. This will make the child policy progress upon activity on+  // this policy, which in turn is tied to the application's call.+  grpc_pollset_set_add_pollset_set(lb_policy->interested_parties(),+                                   interested_parties());+  return lb_policy;+}++//+// XdsOverrideHostLb::Helper+//++RefCountedPtr<SubchannelInterface> XdsOverrideHostLb::Helper::CreateSubchannel(+    ServerAddress address, const ChannelArgs& args) {+  return xds_override_host_policy_->channel_control_helper()->CreateSubchannel(+      address, args);+}++void XdsOverrideHostLb::Helper::UpdateState(+    grpc_connectivity_state state, const absl::Status& status,+    RefCountedPtr<SubchannelPicker> picker) {+  if (xds_override_host_policy_->shutting_down_) return;+  if (GRPC_TRACE_FLAG_ENABLED(grpc_lb_xds_override_host_trace)) {+    gpr_log(GPR_INFO,+            ""[xds_override_host_lb %p] child connectivity state update: ""+            ""state=%s (%s) picker=%p"",+            xds_override_host_policy_.get(), ConnectivityStateName(state),+            status.ToString().c_str(), picker.get());+  }+  // Save the state and picker.+  xds_override_host_policy_->state_ = state;+  xds_override_host_policy_->status_ = status;+  xds_override_host_policy_->picker_ = std::move(picker);+  // Wrap the picker and return it to the channel.+  xds_override_host_policy_->MaybeUpdatePickerLocked();+}++void XdsOverrideHostLb::Helper::RequestReresolution() {+  if (xds_override_host_policy_->shutting_down_) return;+  xds_override_host_policy_->channel_control_helper()->RequestReresolution();+}++absl::string_view XdsOverrideHostLb::Helper::GetAuthority() {+  return xds_override_host_policy_->channel_control_helper()->GetAuthority();+}++grpc_event_engine::experimental::EventEngine*+XdsOverrideHostLb::Helper::GetEventEngine() {+  return xds_override_host_policy_->channel_control_helper()->GetEventEngine();+}++void XdsOverrideHostLb::Helper::AddTraceEvent(TraceSeverity severity,+                                              absl::string_view message) {+  if (xds_override_host_policy_->shutting_down_) return;+  xds_override_host_policy_->channel_control_helper()->AddTraceEvent(severity,+                                                                     message);+}++//+// factory+//+class XdsOverrideHostLbFactory : public LoadBalancingPolicyFactory {+ public:+  OrphanablePtr<LoadBalancingPolicy> CreateLoadBalancingPolicy(+      LoadBalancingPolicy::Args args) const override {+    return MakeOrphanable<XdsOverrideHostLb>(std::move(args));+  }++  absl::string_view name() const override { return kXdsOverrideHost; }++  absl::StatusOr<RefCountedPtr<LoadBalancingPolicy::Config>>+  ParseLoadBalancingConfig(const Json& json) const override {+    if (json.type() == Json::Type::JSON_NULL) {+      // This policy was configured in the deprecated loadBalancingPolicy+      // field or in the client API.+      return absl::InvalidArgumentError(+          ""field:loadBalancingPolicy error:xds_override_host policy requires ""+          ""configuration. Please use loadBalancingConfig field of service ""+          ""config instead."");+    }+    ValidationErrors errors;+    RefCountedPtr<LoadBalancingPolicy::Config> child_policy;+    {+      // Parse childPolicy manually.","Instead of doing this JSON parsing here, please change `XdsOverrideHostLbConfig` to implement the interface expected by the [json_object_loader library](https://github.com/grpc/grpc/blob/024a0f738898c5440dc4fa0102f72e6712cbb748/src/core/lib/json/json_object_loader.h#L45).For an example, see the [`priority` LB policy](https://github.com/grpc/grpc/blob/024a0f738898c5440dc4fa0102f72e6712cbb748/src/core/ext/filters/client_channel/lb_policy/priority/priority.cc#L110).  Note that the code here in `ParseLoadBalancingConfig()` should just be a call to [`LoadRefCountedFromJson<>()`](https://github.com/grpc/grpc/blob/024a0f738898c5440dc4fa0102f72e6712cbb748/src/core/ext/filters/client_channel/lb_policy/priority/priority.cc#L920).",X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/31730,1035062618,2022-11-29T17:36:37Z,src/core/ext/filters/client_channel/lb_policy/xds_override_host/xds_override_host.cc,"@@ -0,0 +1,404 @@+//+// Copyright 2022 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+//++#include <grpc/support/port_platform.h>++#include <inttypes.h>+#include <string.h>++#include <algorithm>+#include <memory>+#include <string>+#include <utility>+#include <vector>++#include ""absl/status/status.h""+#include ""absl/status/statusor.h""+#include ""absl/strings/str_cat.h""+#include ""absl/strings/string_view.h""+#include ""absl/types/optional.h""++#include <grpc/impl/codegen/connectivity_state.h>+#include <grpc/impl/codegen/grpc_types.h>+#include <grpc/support/log.h>++#include ""src/core/ext/filters/client_channel/lb_policy/child_policy_handler.h""+#include ""src/core/ext/filters/client_channel/lb_policy/subchannel_list.h""+#include ""src/core/lib/channel/channel_args.h""+#include ""src/core/lib/config/core_configuration.h""+#include ""src/core/lib/debug/trace.h""+#include ""src/core/lib/gprpp/debug_location.h""+#include ""src/core/lib/gprpp/env.h""+#include ""src/core/lib/gprpp/orphanable.h""+#include ""src/core/lib/gprpp/ref_counted_ptr.h""+#include ""src/core/lib/iomgr/pollset_set.h""+#include ""src/core/lib/json/json.h""+#include ""src/core/lib/load_balancing/lb_policy.h""+#include ""src/core/lib/load_balancing/lb_policy_factory.h""+#include ""src/core/lib/load_balancing/subchannel_interface.h""+#include ""src/core/lib/resolver/server_address.h""+#include ""src/core/lib/transport/connectivity_state.h""++namespace grpc_core {++TraceFlag grpc_lb_xds_override_host_trace(false, ""xds_override_host"");++namespace {++//+// xds_override_host LB policy+//++constexpr absl::string_view kXdsOverrideHost = ""xds_override_host_experimental"";++// Config for stateful session LB policy.+class XdsOverrideHostLbConfig : public LoadBalancingPolicy::Config {+ public:+  XdsOverrideHostLbConfig(+      RefCountedPtr<LoadBalancingPolicy::Config> child_policy)+      : child_policy_(std::move(child_policy)) {}++  absl::string_view name() const override { return kXdsOverrideHost; }++  RefCountedPtr<LoadBalancingPolicy::Config> child_policy() const {+    return child_policy_;+  }++ private:+  RefCountedPtr<LoadBalancingPolicy::Config> child_policy_;+};++// xDS Cluster Impl LB policy.+class XdsOverrideHostLb : public LoadBalancingPolicy {+ public:+  explicit XdsOverrideHostLb(Args args);++  absl::string_view name() const override { return kXdsOverrideHost; }++  absl::Status UpdateLocked(UpdateArgs args) override;+  void ExitIdleLocked() override;+  void ResetBackoffLocked() override;++ private:+  // A picker that wraps the picker from the child for cases when cookie is+  // present.+  class Picker : public SubchannelPicker {+   public:+    Picker(XdsOverrideHostLb* xds_override_host_lb,+           RefCountedPtr<SubchannelPicker> picker);++    PickResult Pick(PickArgs args) override;++   private:+    class SubchannelCallTracker;+    RefCountedPtr<SubchannelPicker> picker_;+  };++  class Helper : public ChannelControlHelper {+   public:+    explicit Helper(RefCountedPtr<XdsOverrideHostLb> xds_override_host_policy)+        : xds_override_host_policy_(std::move(xds_override_host_policy)) {}++    ~Helper() override {+      xds_override_host_policy_.reset(DEBUG_LOCATION, ""Helper"");+    }++    RefCountedPtr<SubchannelInterface> CreateSubchannel(+        ServerAddress address, const ChannelArgs& args) override;+    void UpdateState(grpc_connectivity_state state, const absl::Status& status,+                     RefCountedPtr<SubchannelPicker> picker) override;+    void RequestReresolution() override;+    absl::string_view GetAuthority() override;+    grpc_event_engine::experimental::EventEngine* GetEventEngine() override;+    void AddTraceEvent(TraceSeverity severity,+                       absl::string_view message) override;++   private:+    RefCountedPtr<XdsOverrideHostLb> xds_override_host_policy_;+  };++  ~XdsOverrideHostLb() override;++  static std::string MakeKeyForAddress(const ServerAddress& address);++  void ShutdownLocked() override;++  OrphanablePtr<LoadBalancingPolicy> CreateChildPolicyLocked(+      const ChannelArgs& args);++  void MaybeUpdatePickerLocked();++  // Current config from the resolver.+  RefCountedPtr<XdsOverrideHostLbConfig> config_;++  // Internal state.+  bool shutting_down_ = false;++  OrphanablePtr<LoadBalancingPolicy> child_policy_;++  // Latest state and picker reported by the child policy.+  grpc_connectivity_state state_ = GRPC_CHANNEL_IDLE;+  absl::Status status_;+  RefCountedPtr<SubchannelPicker> picker_;+};++//+// XdsOverrideHostLb::Picker+//++XdsOverrideHostLb::Picker::Picker(XdsOverrideHostLb* xds_override_host_lb,+                                  RefCountedPtr<SubchannelPicker> picker)+    : picker_(std::move(picker)) {+  if (GRPC_TRACE_FLAG_ENABLED(grpc_lb_xds_override_host_trace)) {+    gpr_log(GPR_INFO, ""[xds_override_host_lb %p] constructed new picker %p"",+            xds_override_host_lb, this);+  }+}++LoadBalancingPolicy::PickResult XdsOverrideHostLb::Picker::Pick(+    LoadBalancingPolicy::PickArgs args) {+  if (picker_ == nullptr) {  // Should never happen.+    return PickResult::Fail(absl::InternalError(+        ""xds_override_host picker not given any child picker""));+  }+  // Delegate to child picker+  return picker_->Pick(args);+}++//+// XdsOverrideHostLb+//++XdsOverrideHostLb::XdsOverrideHostLb(Args args)+    : LoadBalancingPolicy(std::move(args)) {+  if (GRPC_TRACE_FLAG_ENABLED(grpc_lb_xds_override_host_trace)) {+    gpr_log(GPR_INFO, ""[xds_override_host_lb %p] created"", this);+  }+}++XdsOverrideHostLb::~XdsOverrideHostLb() {+  if (GRPC_TRACE_FLAG_ENABLED(grpc_lb_xds_override_host_trace)) {+    gpr_log(GPR_INFO,+            ""[xds_override_host_lb %p] destroying xds_override_host LB policy"",+            this);+  }+}++void XdsOverrideHostLb::ShutdownLocked() {+  if (GRPC_TRACE_FLAG_ENABLED(grpc_lb_xds_override_host_trace)) {+    gpr_log(GPR_INFO, ""[xds_override_host_lb %p] shutting down"", this);+  }+  shutting_down_ = true;+  // Remove the child policy's interested_parties pollset_set from the+  // xDS policy.+  if (child_policy_ != nullptr) {+    // grpc_pollset_set_del_pollset_set(child_policy_->interested_parties(),+    //                                  interested_parties());+    child_policy_.reset();+  }+  // Drop our ref to the child's picker, in case it's holding a ref to+  // the child.+  picker_.reset();+}++void XdsOverrideHostLb::ExitIdleLocked() {+  if (child_policy_ != nullptr) child_policy_->ExitIdleLocked();+}++void XdsOverrideHostLb::ResetBackoffLocked() {+  if (child_policy_ != nullptr) child_policy_->ResetBackoffLocked();+}++absl::Status XdsOverrideHostLb::UpdateLocked(UpdateArgs args) {+  if (GRPC_TRACE_FLAG_ENABLED(grpc_lb_xds_override_host_trace)) {+    gpr_log(GPR_INFO, ""[xds_override_host_lb %p] Received update"", this);+  }+  auto old_config = std::move(config_);+  // Update config.+  config_ = std::move(args.config);+  if (config_ == nullptr) {+    return absl::InvalidArgumentError(""Missing policy config"");+  }+  // Create child policy if needed.+  if (child_policy_ == nullptr) {+    child_policy_ = CreateChildPolicyLocked(args.args);+  }+  // Update child policy.+  UpdateArgs update_args;+  update_args.addresses = std::move(args.addresses);+  update_args.resolution_note = std::move(args.resolution_note);+  update_args.config = config_->child_policy();+  // Update the policy.",This comment doesn't seem useful -- it duplicates the existing comment on line 239 above.,X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/31730,1035081704,2022-11-29T17:54:06Z,test/core/client_channel/lb_policy/xds_override_host_test.cc,"@@ -0,0 +1,129 @@+//+// Copyright 2022 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+//++#include ""gmock/gmock.h""++#include ""src/core/lib/gprpp/env.h""+#include ""test/core/client_channel/lb_policy/lb_policy_test_lib.h""+#include ""test/core/util/test_config.h""++namespace grpc_core {+namespace testing {+namespace {++class XdsOverrideHostTest : public LoadBalancingPolicyTest {+ protected:+  XdsOverrideHostTest()+      : policy_(MakeLbPolicy(""xds_override_host_experimental"")) {}++  RefCountedPtr<LoadBalancingPolicy::Config> MakeXdsOverrideHostConfig(+      std::string child_policy = ""pick_first"") {+    Json::Object child_policy_config = {{child_policy, Json::Object()}};++    return MakeConfig(Json::Array{Json::Object{+        {""xds_override_host_experimental"",+         Json::Object{{""childPolicy"", Json::Array{{child_policy_config}}}}}}});+  }++  OrphanablePtr<LoadBalancingPolicy> policy_;+};++TEST_F(XdsOverrideHostTest, DelegatesToChild) {+  ASSERT_NE(policy_, nullptr);+  std::array<absl::string_view, 2> addresses = {""ipv4:127.0.0.1:441"",+                                                ""ipv4:127.0.0.1:442""};+  EXPECT_EQ(policy_->name(), ""xds_override_host_experimental"");+  // 1. We use pick_first as a child+  EXPECT_EQ(ApplyUpdate(BuildUpdate(addresses, MakeXdsOverrideHostConfig()),+                        policy_.get()),+            absl::OkStatus());+  ExpectConnectingUpdate();+  for (absl::string_view address : addresses) {+    auto subchannel = FindSubchannel(+        {address}, ChannelArgs().Set(GRPC_ARG_INHIBIT_HEALTH_CHECKING, true));+    ASSERT_TRUE(subchannel);+    subchannel->ConnectionRequested();","You need to actually check the result of this, or there's no point in calling it.  And when you do check the result, I think you'll find that this will fail for the second subchannel.  This is because pick_first, unlike round_robin, does not automatically connect to all subchannels in parallel.  Instead, it will try to connect to one subchannel at a time, which means that it won't attempt to connect to the second subchannel until the first subchannel reports TRANSIENT_FAILURE, which in this case never happens.I think you can basically ignore the second subchannel here and instead do these steps only for the first subchannel.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/31717,1035106843,2022-11-29T18:15:43Z,src/core/lib/gprpp/ref_counted_ptr.h,"@@ -49,6 +49,8 @@ class RefCountedPtr {   template <typename Y>   // NOLINTNEXTLINE(google-explicit-constructor)   RefCountedPtr(RefCountedPtr<Y>&& other) noexcept {+    static_assert(std::has_virtual_destructor<T>::value,","This could potentially break things, because [`RefCounted<>` supports objects with non-virtual dtors](https://github.com/grpc/grpc/blob/024a0f738898c5440dc4fa0102f72e6712cbb748/src/core/lib/gprpp/ref_counted.h#L259).What's the benefit that we would get from this?  It's not clear to me that it actually buys us anything, and given the problem I just mentioned, I think it would be better to just remove it.",
5663878,yijiem,https://api.github.com/repos/grpc/grpc/pulls/31717,1035186645,2022-11-29T19:20:32Z,src/core/lib/gprpp/ref_counted_ptr.h,"@@ -49,6 +49,8 @@ class RefCountedPtr {   template <typename Y>   // NOLINTNEXTLINE(google-explicit-constructor)   RefCountedPtr(RefCountedPtr<Y>&& other) noexcept {+    static_assert(std::has_virtual_destructor<T>::value,","OK, sounds good. I thought in the NonPolymorphic case one shouldn't be doing things like```static_assert(std::is_same<decltype(Ref()), RefCountedPtr<Parent>>::value);RefCountedPtr<Child> c = Ref();```Since the Parent class needs to be a concrete leaf class. But I guess adding it doesn't give us much benefit + it's actually a bug...",
24593237,XuanWang-Amos,https://api.github.com/repos/grpc/grpc/pulls/31769,1035260900,2022-11-29T20:37:52Z,src/python/grpcio/grpc/__init__.py,"@@ -1506,13 +1559,15 @@ def wait_for_termination(self, timeout=None): #################################  Functions    ################################  -def unary_unary_rpc_method_handler(behavior,-                                   request_deserializer=None,-                                   response_serializer=None):+def unary_unary_rpc_method_handler(+    behavior: Callable[[Any, Any], Any],","Not entirely sure here since doc string says it `accepts one request`, but based on [example](https://github.com/grpc/grpc/blob/master/src/python/grpcio_tests/tests/qps/benchmark_server.py#L39), all `behavior` should take two arguments, one for request and one for context.",
24593237,XuanWang-Amos,https://api.github.com/repos/grpc/grpc/pulls/31769,1035266295,2022-11-29T20:43:30Z,src/python/grpcio/grpc/__init__.py,"@@ -1705,13 +1777,14 @@ def composite_channel_credentials(channel_credentials, *call_credentials):             channel_credentials._credentials))  -def ssl_server_credentials(private_key_certificate_chain_pairs,-                           root_certificates=None,-                           require_client_auth=False):+def ssl_server_credentials(+        private_key_certificate_chain_pairs: Sequence[Sequence],+        root_certificates: Optional[bytes] = None,+        require_client_auth: Optional[bool] = False) -> ServerCredentials:     """"""Creates a ServerCredentials for use with an SSL-enabled Server.      Args:-      private_key_certificate_chain_pairs: A list of pairs of the form+      private_key_certificate_chain_pairs: A sequence of pairs of the form",Changed it to `Sequence` since some users are using [sequence](https://github.com/gaia-pipeline/pythonsdk/blob/c4d25740f038ed6e9cffcf68d5dde9ddc2a4f804/gaiasdk/sdk.py#L142).,
24593237,XuanWang-Amos,https://api.github.com/repos/grpc/grpc/pulls/31769,1035267676,2022-11-29T20:45:15Z,src/python/grpcio/grpc/__init__.py,"@@ -1398,19 +1449,20 @@ class Server(abc.ABC):     """"""Services RPCs.""""""      @abc.abstractmethod-    def add_generic_rpc_handlers(self, generic_rpc_handlers):+    def add_generic_rpc_handlers(+            self, generic_rpc_handlers: Sequence[GenericRpcHandler]) -> None:         """"""Registers GenericRpcHandlers with this Server.          This method is only safe to call before the server is started.          Args:-          generic_rpc_handlers: An iterable of GenericRpcHandlers that will be+          generic_rpc_handlers: A sequence of GenericRpcHandlers that will be","We're using [`Sequence` in aio](https://github.com/grpc/grpc/blob/2d4f3c56001cd1e1f85734b2f7c5ce5f2797c38a/src/python/grpcio/grpc/aio/_server.py#L67), since all iterables are sequence, changed here to `Sequence` too.",
5564114,Vignesh2208,https://api.github.com/repos/grpc/grpc/pulls/31592,1036046172,2022-11-30T14:33:47Z,src/core/lib/transport/promise_endpoint.cc,"@@ -0,0 +1,61 @@+/*+ * Copyright 2022 gRPC authors.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ *     http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++#include <grpc/support/port_platform.h>++#include ""src/core/lib/transport/promise_endpoint.h""++#include <utility>++#include <grpc/support/log.h>++namespace grpc {++namespace internal {++PromiseEndpoint::PromiseEndpoint(+    std::unique_ptr<grpc_event_engine::experimental::EventEngine::Endpoint>+        endpoint,+    grpc_core::SliceBuffer already_received)",Whats the purpose of this already_received SliceBuffer parameter ?,
5564114,Vignesh2208,https://api.github.com/repos/grpc/grpc/pulls/31592,1036051200,2022-11-30T14:37:54Z,src/core/lib/transport/promise_endpoint.h,"@@ -0,0 +1,315 @@+/*+ * Copyright 2022 gRPC authors.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ *     http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++#ifndef GRPC_CORE_LIB_TRANSPORT_PROMISE_ENDPOINT_H+#define GRPC_CORE_LIB_TRANSPORT_PROMISE_ENDPOINT_H++#include <grpc/support/port_platform.h>++#include <stddef.h>+#include <stdint.h>++#include <functional>+#include <memory>+#include <utility>++#include ""absl/base/thread_annotations.h""+#include ""absl/status/status.h""+#include ""absl/status/statusor.h""+#include ""absl/types/optional.h""++#include <grpc/event_engine/event_engine.h>+#include <grpc/event_engine/slice.h>+#include <grpc/event_engine/slice_buffer.h>+#include <grpc/slice_buffer.h>+#include <grpc/support/log.h>++#include ""src/core/lib/gprpp/sync.h""+#include ""src/core/lib/promise/activity.h""+#include ""src/core/lib/promise/poll.h""+#include ""src/core/lib/slice/slice.h""+#include ""src/core/lib/slice/slice_buffer.h""++namespace grpc {++namespace internal {++class PromiseEndpoint {+ public:+  PromiseEndpoint(+      std::unique_ptr<grpc_event_engine::experimental::EventEngine::Endpoint>+          endpoint,+      grpc_core::SliceBuffer already_received);+  ~PromiseEndpoint();++  auto Write(grpc_core::SliceBuffer data) {+    grpc_core::MutexLock lock(&write_mutex_);++    /// Previous write result has not been polled.+    GPR_ASSERT(!write_result_.has_value());++    /// TODO: Is there a better way to convert?+    grpc_slice_buffer_swap(data.c_slice_buffer(),",grpc_event_engine::experimental::SliceBuffer class already has a Swap method defined. You can use that instead of swapping the grpc_slice_buffer c types,
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/31634,1036351238,2022-11-30T19:11:23Z,src/core/ext/filters/client_channel/subchannel.cc,"@@ -777,12 +766,16 @@ void Subchannel::Orphan() {     subchannel_pool_->UnregisterSubchannel(key_, this);     subchannel_pool_.reset();   }-  MutexLock lock(&mu_);-  GPR_ASSERT(!shutdown_);-  shutdown_ = true;-  connector_.reset();-  connected_subchannel_.reset();-  health_watcher_map_.ShutdownLocked();+  {+    MutexLock lock(&mu_);+    GPR_ASSERT(!shutdown_);+    shutdown_ = true;+    connector_.reset();+    connected_subchannel_.reset();+    health_watcher_map_.ShutdownLocked();+  }+  // Drain any connectivity state notifications after releasing the mutex.+  work_serializer_.DrainQueue();","It's not possible for `get_or_add()` to do schedule anything on the `WorkSerializer`, because we (intentionally) don't expose any methods on `Subchannel` that do that without acquiring the lock first, and since the lock is already held while calling `get_or_add()`, that would cause a deadlock.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/31730,1036530111,2022-11-30T22:58:14Z,src/core/ext/filters/client_channel/lb_policy/xds/xds_override_host.cc,"@@ -342,6 +358,40 @@ void XdsOverrideHostLb::Helper::AddTraceEvent(TraceSeverity severity, // // factory //+const JsonLoaderInterface* XdsOverrideHostLbConfig::JsonLoader(+    const JsonArgs&) {+  return JsonObjectLoader<XdsOverrideHostLbConfig>()+      // Child policy config is parsed in JsonPostLoad+      .Finish();+}++void XdsOverrideHostLbConfig::JsonPostLoad(const Json& json, const JsonArgs&,+                                           ValidationErrors* errors) {+  ValidationErrors::ScopedField field(errors, "".childPolicy"");+  auto it = json.object_value().find(""childPolicy"");+  if (it == json.object_value().end()) {+    errors->AddError(""field not present"");+    return;","Note that in a subsequent PR, you will need to also add support for the ""overrideHostStatus"" field, and we will need to validate that field even if there are errors in this field, so we won't want to return early at that point.  (It's better UX for users to return all errors at once rather than stopping at the first error we find.)This is fine for now, as long as you remember to change this when you add the second field.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/31730,1036534582,2022-11-30T23:06:00Z,test/core/client_channel/lb_policy/xds_override_host_test.cc,"@@ -37,6 +34,28 @@ class XdsOverrideHostTest : public LoadBalancingPolicyTest {          Json::Object{{""childPolicy"", Json::Array{{child_policy_config}}}}}}});   } +  void SetUp() override {+    grpc_core::SetEnv(""GRPC_EXPERIMENTAL_XDS_ENABLE_HOST_OVERRIDE"", ""TRUE"");+    grpc_init();+    policy_ = MakeLbPolicy(""xds_override_host_experimental"");+  }++  void TearDown() override {+    // Note: Can't safely trigger this from inside the FakeHelper dtor,","Instead of duplicating this code from the parent class, just call the method from the parent class directly:```LoadBalancingPolicyTest::TearDown();```That way, if we add anything else to the parent class `TearDown()` in the future, we won't need to duplicate it here.",X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/31730,1036539306,2022-11-30T23:13:10Z,test/core/client_channel/lb_policy/xds_override_host_test.cc,"@@ -122,7 +144,7 @@ TEST_F(XdsOverrideHostTest, NoConfigReportsError) {       absl::InvalidArgumentError(""Missing policy config"")); } -TEST_F(XdsOverrideHostTest, ConfigRequiresChildPolicy) {+TEST_F(XdsOverrideHostTest, ValidateChildPolicyConfig) {","Suggest moving the config tests to their own file, since they don't require any of the other infrastructure being set up in this test.  For an example of an LB policy config test, see https://github.com/grpc/grpc/blob/master/test/core/client_channel/outlier_detection_lb_config_parser_test.cc.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/31730,1036542424,2022-11-30T23:15:33Z,test/core/client_channel/lb_policy/xds_override_host_test.cc,"@@ -131,6 +153,59 @@ TEST_F(XdsOverrideHostTest, ConfigRequiresChildPolicy) {             absl::InvalidArgumentError(                 ""errors validating xds_override_host LB policy config: ""                 ""[field:childPolicy error:field not present]""));++  result =+      CoreConfiguration::Get().lb_policy_registry().ParseLoadBalancingConfig(+          Json::Array{Json::Object{+              {""xds_override_host_experimental"",+               Json::Object{+                   {""childPolicy"",+                    Json::Array{+                        {Json::Object{{""pick_first"", Json::Object{}}}},+                        {Json::Object{{""round_robin"", Json::Object{}}}}}}}++              }}});+  EXPECT_EQ(result.status(),+            absl::InvalidArgumentError(+                ""errors validating xds_override_host LB policy config: ""+                ""[field:childPolicy error:exactly one child config should be ""+                ""specified]""));++  result =+      CoreConfiguration::Get().lb_policy_registry().ParseLoadBalancingConfig(+          Json::Array{+              Json::Object{{""xds_override_host_experimental"",+                            Json::Object{{+                                ""childPolicy"",+                                {Json::Object{{""pick_first"", Json::Object{}}}},+                            }}}++              }});+  EXPECT_EQ(result.status(),+            absl::InvalidArgumentError(+                ""errors validating xds_override_host LB policy config: ""+                ""[field:childPolicy error:type should be array]""));++  result =+      CoreConfiguration::Get().lb_policy_registry().ParseLoadBalancingConfig(+          Json::Array{Json::Object{{""xds_override_host_experimental"",+                                    Json::Object{{""childPolicy"", Json::Array{}}}++          }}});+  EXPECT_EQ(result.status(),+            absl::InvalidArgumentError(+                ""errors validating xds_override_host LB policy config: ""+                ""[field:childPolicy error:No known policies in list: ]""));+}++TEST_F(XdsOverrideHostTest, XdsOverrideHostLbPolicyDisabled) {+  policy_.reset();","I suggest moving this to a separate test class, so that you don't need all of this boilerplate:```using XdsOverrideHostDisabledTest = LoadBalancingPolicyTest;TEST_F(XdsOverrideHostDisabledTest, PolicyDoesNotExist) {  EXPECT_EQ(MakeLbPolicy(""xds_override_host_experimental""), nullptr);}```(Note that this depends on my suggestion above to move `grpc_init()` and `grpc_shutdown()` back to `main()`.)",X
11522026,ralphchung,https://api.github.com/repos/grpc/grpc/pulls/31785,1037314408,2022-12-01T16:17:47Z,include/grpc/event_engine/slice_buffer.h,"@@ -118,12 +125,26 @@ class SliceBuffer {   /// associated slice.   Slice RefSlice(size_t index); +  /// Returns pointer to the buffer contained in the slice at the specified+  /// index. The returned buffer is mutable.+  std::tuple<uint8_t*, size_t> MutableData(size_t index) {+    return std::make_tuple<uint8_t*, size_t>(+        GPR_SLICE_START_PTR(slice_buffer_.slices[index]),",Please use `GPRC_SLICE_*` since `GPR_SLICE_*` are being deprecated. https://github.com/grpc/grpc/pull/31774,
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/31785,1037442586,2022-12-01T18:30:43Z,include/grpc/event_engine/slice_buffer.h,"@@ -118,12 +125,26 @@ class SliceBuffer {   /// associated slice.   Slice RefSlice(size_t index); +  /// Returns pointer to the buffer contained in the slice at the specified+  /// index. The returned buffer is mutable.+  std::tuple<uint8_t*, size_t> MutableData(size_t index) {","Craig and I discussed alternatives in the context of my WindowsEventEngine work as well, we should discuss it next week. This is a public API change, and needs to be carefully thought through. I'm not sure adding raw slice data accessor methods to the SliceBuffer is the right choice here, if anything they belong on the Slice type, but RefSlice might not get us the Slice we need (I implemented `PeekSlice` for this reason, but it's not ideal either).Is my hypothesis correct that the bugs you're seeing are with uses of inlined slices in the Write API?",
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/31785,1037444878,2022-12-01T18:33:31Z,include/grpc/event_engine/slice_buffer.h,"@@ -118,12 +125,26 @@ class SliceBuffer {   /// associated slice.   Slice RefSlice(size_t index); +  /// Returns pointer to the buffer contained in the slice at the specified+  /// index. The returned buffer is mutable.+  std::tuple<uint8_t*, size_t> MutableData(size_t index) {+    return std::make_tuple<uint8_t*, size_t>(+        GPR_SLICE_START_PTR(slice_buffer_.slices[index]),+        GPR_SLICE_LENGTH(slice_buffer_.slices[index]));+  }+   /// The total number of bytes held by the SliceBuffer   size_t Length() { return slice_buffer_.length; }    /// Return a pointer to the back raw grpc_slice_buffer   grpc_slice_buffer* c_slice_buffer() { return &slice_buffer_; } +  // Returns a SliceBuffer that transfers slices into this new SliceBuffer,+  // leaving the input parameter empty.+  static SliceBuffer TakeCSliceBuffer(grpc_slice_buffer& slice_buffer) {",This appears to be unused.,X
1644595,gnossen,https://api.github.com/repos/grpc/grpc/pulls/31769,1037498824,2022-12-01T19:42:33Z,src/python/grpcio/grpc/__init__.py,"@@ -185,7 +205,7 @@ def traceback(self, timeout=None):         raise NotImplementedError()      @abc.abstractmethod-    def add_done_callback(self, fn):+    def add_done_callback(self, fn: DoneCallbackType) -> None:","This is not the right type. It should be `Callable[[grpc.Future], None]` as in [`_InactiveRpcError.add_done_callback`](https://github.com/grpc/grpc/blob/5933b52e1117e0aca1cd3635ef0370577bbff865/src/python/grpcio/grpc/_channel.py#L395).",
1644595,gnossen,https://api.github.com/repos/grpc/grpc/pulls/31769,1037666146,2022-12-01T23:52:30Z,src/python/grpcio/grpc/__init__.py,"@@ -330,15 +350,15 @@ def time_remaining(self):         raise NotImplementedError()      @abc.abstractmethod-    def cancel(self):+    def cancel(self) -> None:","This does not match the signature of [`_InactiveRpcError.cancel`](https://github.com/grpc/grpc/blob/5933b52e1117e0aca1cd3635ef0370577bbff865/src/python/grpcio/grpc/_channel.py#L444). We should change the return type to `bool` and add a ""Returns"" section to the docstring. Something like ""Returns False if the RPC is already completed, otherwise True.""",
1644595,gnossen,https://api.github.com/repos/grpc/grpc/pulls/31769,1037667320,2022-12-01T23:55:00Z,src/python/grpcio/grpc/__init__.py,"@@ -359,7 +379,7 @@ class Call(RpcContext, metaclass=abc.ABCMeta):     """"""Invocation-side utility object for an RPC.""""""      @abc.abstractmethod-    def initial_metadata(self):+    def initial_metadata(self) -> Optional[MetadataType]:","The docstring doesn't currently indicate that this value can be `None`. Let's add ""or None if no initial metadata has been received.""",
1644595,gnossen,https://api.github.com/repos/grpc/grpc/pulls/31769,1037667648,2022-12-01T23:55:36Z,src/python/grpcio/grpc/__init__.py,"@@ -370,7 +390,7 @@ def initial_metadata(self):         raise NotImplementedError()      @abc.abstractmethod-    def trailing_metadata(self):+    def trailing_metadata(self) -> Optional[MetadataType]:","LIkewise, the docstring here does not document that the return value can be `None`. Let's add ""or None if no trailing metadata has been received.""",
1644595,gnossen,https://api.github.com/repos/grpc/grpc/pulls/31769,1037670474,2022-12-02T00:01:30Z,src/python/grpcio/grpc/__init__.py,"@@ -392,7 +412,7 @@ def code(self):         raise NotImplementedError()      @abc.abstractmethod-    def details(self):+    def details(self) -> Optional[str]:","Hm. So this can return `None` when `_InactiveRpcError._state.details` is `None`, which is the case when the RPC has not completed. But I think this means that the current signature for [_common.decode](https://github.com/grpc/grpc/blob/5933b52e1117e0aca1cd3635ef0370577bbff865/src/python/grpcio/grpc/_common.py#L77) is wrong since it can both take and return a `None`. How did this sneak past the type checker?",
1644595,gnossen,https://api.github.com/repos/grpc/grpc/pulls/31769,1037672809,2022-12-02T00:06:33Z,src/python/grpcio/grpc/__init__.py,"@@ -460,8 +483,10 @@ class UnaryStreamClientInterceptor(abc.ABC):     """"""Affords intercepting unary-stream invocations.""""""      @abc.abstractmethod-    def intercept_unary_stream(self, continuation, client_call_details,-                               request):+    def intercept_unary_stream(self, continuation: Callable[",This has made me realize that there are still [a few types missing](https://github.com/grpc/grpc/blob/5933b52e1117e0aca1cd3635ef0370577bbff865/src/python/grpcio/grpc/_interceptor.py#L268) from the interceptor implementation.,
1644595,gnossen,https://api.github.com/repos/grpc/grpc/pulls/31769,1037676160,2022-12-02T00:13:51Z,src/python/grpcio/grpc/__init__.py,"@@ -426,7 +446,10 @@ class UnaryUnaryClientInterceptor(abc.ABC):     """"""Affords intercepting unary-unary invocations.""""""      @abc.abstractmethod-    def intercept_unary_unary(self, continuation, client_call_details, request):+    def intercept_unary_unary(self, continuation: Callable[+        [ClientCallDetails, RequestType], Any],","The story for backward compatibility here is a little complicated. Generally speaking, moving from a more general type to a less general type (i.e. Any to `Intersection[Call, Future]`) is not backward compatible.But that's somewhat mitigated by the fact that this has been required by the docstrings for as long as interceptors have been supported. I think we could make the story even stronger by adding a runtime check in the interceptor implementation that ensures that both of these interfaces are satisfied. That would ensure that no one comes to depend on this being `Any` rather than a more specific type.",
1644595,gnossen,https://api.github.com/repos/grpc/grpc/pulls/31769,1037683680,2022-12-02T00:31:18Z,src/python/grpcio/grpc/__init__.py,"@@ -603,7 +632,8 @@ class AuthMetadataContext(abc.ABC): class AuthMetadataPluginCallback(abc.ABC):     """"""Callback object received by a metadata plugin."""""" -    def __call__(self, metadata, error):+    def __call__(self, metadata: MetadataType,+                 error: Optional[Type[BaseException]]) -> Any:","I like the use of `BaseException` here rather than just `Exception`. But why `Type`? This seems wrong to me, we pass in [actual exceptions here](https://github.com/grpc/grpc/blob/5933b52e1117e0aca1cd3635ef0370577bbff865/src/python/grpcio/grpc/_auth.py#L25), not exception classes.",
1644595,gnossen,https://api.github.com/repos/grpc/grpc/pulls/31769,1037684234,2022-12-02T00:32:37Z,src/python/grpcio/grpc/__init__.py,"@@ -616,7 +646,8 @@ def __call__(self, metadata, error): class AuthMetadataPlugin(abc.ABC):     """"""A specification for custom authentication."""""" -    def __call__(self, context, callback):+    def __call__(self, contex: AuthMetadataContext,",Looks like you accidentally deleted the `t` from `context` here. It's super worrying to me that this didn't cause a CI failure. We need to look into this.,
1644595,gnossen,https://api.github.com/repos/grpc/grpc/pulls/31769,1037695837,2022-12-02T00:58:57Z,src/python/grpcio/grpc/__init__.py,"@@ -766,12 +798,12 @@ class UnaryStreamMultiCallable(abc.ABC):      @abc.abstractmethod     def __call__(self,-                 request,-                 timeout=None,-                 metadata=None,-                 credentials=None,-                 wait_for_ready=None,-                 compression=None):+                 request: Any,",I just noticed that the return type is missing on [the implementation of this](https://github.com/grpc/grpc/blob/5933b52e1117e0aca1cd3635ef0370577bbff865/src/python/grpcio/grpc/_interceptor.py#L356).,
287917,eugeneo,https://api.github.com/repos/grpc/grpc/pulls/31730,1038404314,2022-12-02T18:17:31Z,test/core/client_channel/lb_policy/xds_override_host_test.cc,"@@ -123,15 +112,16 @@ TEST_F(XdsOverrideHostTest, SwapChildPolicy) {     ASSERT_TRUE(subchannel->ConnectionRequested());     subchannel->SetConnectivityState(GRPC_CHANNEL_CONNECTING);     subchannel->SetConnectivityState(GRPC_CHANNEL_READY);-    EXPECT_NE(ExpectState(GRPC_CHANNEL_READY), nullptr);+    picker = ExpectState(GRPC_CHANNEL_READY);+    EXPECT_NE(picker, nullptr);+    ExpectPickComplete(picker.get());",This would basically be testing `round_robin`. I believe it is inefficient to duplicate those tests.Note that there's a check all addresses are picked a few lines below.,X
5564114,Vignesh2208,https://api.github.com/repos/grpc/grpc/pulls/31785,1038405573,2022-12-02T18:19:13Z,src/core/lib/event_engine/posix_engine/lockfree_event.cc,"@@ -86,7 +86,7 @@ void LockfreeEvent::DestroyEvent() {     // with post-deletion (see the note in the constructor) we want the bit     // pattern to prevent error retention in a deleted object   } while (!state_.compare_exchange_strong(curr, kShutdownBit,-                                           std::memory_order_relaxed,+                                           std::memory_order_acq_rel,","Its safer to use acq_rel because there is a load of state_ and store back into state_. Using relaxed for both these load and store operations may not be safe because other threads may also load and store from the state_ variable. We should typically use relaxed only when we know there wont be any contention on the atomic variable while the operation is being performed. I think under the hood, acquire and release trigger some cache synchronizations which are not done with relaxed semantics.",
5564114,Vignesh2208,https://api.github.com/repos/grpc/grpc/pulls/31785,1038407651,2022-12-02T18:21:24Z,src/core/lib/event_engine/posix_engine/posix_endpoint.cc,"@@ -1132,7 +1165,12 @@ void PosixEndpointImpl::Write(     current_zerocopy_send_ = zerocopy_send_record;     handle_->NotifyOnWrite(on_write_);   } else {-    on_writable(status);+    // TODO(vigneshbabu): Consider eventually running this callback inline to+    // avoid a thread hop. At the time of submission, it causes deadlocks which+    // should be reolved after ExecCtx removal.+    engine_->Run([on_writable = std::move(on_writable), status]() mutable {+      on_writable(status);","I think rather than taking a dependency on ExecCtx here, we can enforce inside core that the on_write callback should contain an ExecCtx and an ApplicationExecCtx within the callback body. This would be similar to how were are migrating the RunAfter timers.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/31730,1038423472,2022-12-02T18:37:01Z,src/core/ext/filters/client_channel/lb_policy/xds/xds_override_host.cc,"@@ -355,14 +345,17 @@ void XdsOverrideHostLb::Helper::AddTraceEvent(TraceSeverity severity,                                                                      message); } +static const auto kJsonLoader =","Please put this inside of the `XdsOverrideHostLbConfig::JsonLoader()` method.  It does not need to be accessed outside of that method, so there's no reason to put it outside.Let's stick with the same approach that we use everywhere else.  For example:https://github.com/grpc/grpc/blob/5933b52e1117e0aca1cd3635ef0370577bbff865/src/core/ext/filters/client_channel/lb_policy/outlier_detection/outlier_detection.cc#L1055",X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/31730,1038426495,2022-12-02T18:41:12Z,test/core/client_channel/xds_override_host_lb_config_parser_test.cc,"@@ -33,19 +33,7 @@ namespace grpc_core { namespace testing { namespace { -class XdsOverrideHostConfigParsingTest : public ::testing::Test {- public:-  static void SetUpTestSuite() {-    grpc_core::SetEnv(""GRPC_EXPERIMENTAL_XDS_ENABLE_HOST_OVERRIDE"", ""TRUE"");-    grpc_init();-  }--  static void TearDownTestSuite() {-    grpc_shutdown_blocking();-    grpc_core::UnsetEnv(""GRPC_EXPERIMENTAL_XDS_ENABLE_HOST_OVERRIDE"");-    grpc_core::CoreConfiguration::Reset();-  }-};+class XdsOverrideHostConfigParsingTest : public ::testing::Test {};","Since we no longer need to do anything in this test suite, we can remove it completely and change all of the `TEST_F()` invocations below to be `TEST()` instead.",X
11522026,ralphchung,https://api.github.com/repos/grpc/grpc/pulls/31804,1039707279,2022-12-05T14:59:04Z,test/core/iomgr/tcp_client_posix_test.cc,"@@ -207,27 +211,79 @@ void test_fails(void) {  void test_connect_cancellation_succeeds(void) {   gpr_log(GPR_ERROR, ""---- starting test_connect_cancellation_succeeds() ----"");+  auto target_ipv6_addr_uri = *grpc_core::URI::Parse(absl::StrCat(+      ""ipv6:[::1]:"", std::to_string(grpc_pick_unused_port_or_die())));+  auto target_ipv4_addr_uri = *grpc_core::URI::Parse(absl::StrCat(+      ""ipv4:127.0.0.1:"", std::to_string(grpc_pick_unused_port_or_die())));   grpc_resolved_address resolved_addr;-  struct sockaddr_in* addr =-      reinterpret_cast<struct sockaddr_in*>(resolved_addr.addr);+  ASSERT_TRUE(grpc_parse_uri(target_ipv6_addr_uri, &resolved_addr));   int svr_fd;   grpc_closure done;   grpc_core::ExecCtx exec_ctx;--  memset(&resolved_addr, 0, sizeof(resolved_addr));-  resolved_addr.len = static_cast<socklen_t>(sizeof(struct sockaddr_in));-  addr->sin_family = AF_INET;-+  int one = 1;+  bool tried_ipv4 = false;   /* create a phony server */-  svr_fd = socket(AF_INET, SOCK_STREAM, 0);-  ASSERT_GE(svr_fd, 0);-  ASSERT_EQ(bind(svr_fd, (struct sockaddr*)addr, (socklen_t)resolved_addr.len),-            0);+  svr_fd = socket(AF_INET6, SOCK_STREAM, 0);+  while (svr_fd < 0 ||+         bind(svr_fd, reinterpret_cast<sockaddr*>(resolved_addr.addr),+              resolved_addr.len) != 0) {+    if (tried_ipv4) {+      gpr_log(GPR_ERROR,+              ""Skipping test. Failed to create a phony server bound to ipv6 or ""+              ""ipv4 address"");+      return;",Should we `ASSERT_TRUE(false)` or something similar?,
11522026,ralphchung,https://api.github.com/repos/grpc/grpc/pulls/31785,1039746149,2022-12-05T15:29:40Z,include/grpc/event_engine/slice_buffer.h,"@@ -118,12 +125,26 @@ class SliceBuffer {   /// associated slice.   Slice RefSlice(size_t index); +  /// Returns pointer to the buffer contained in the slice at the specified+  /// index. The returned buffer is mutable.+  std::tuple<uint8_t*, size_t> MutableData(size_t index) {",What I heard about this class `SliceBuffer` is that the interface for this class should be stable. I am not sure if adding new API needs more discussion.,
11522026,ralphchung,https://api.github.com/repos/grpc/grpc/pulls/31785,1039752443,2022-12-05T15:34:53Z,src/core/lib/event_engine/posix_engine/lockfree_event.cc,"@@ -86,7 +86,7 @@ void LockfreeEvent::DestroyEvent() {     // with post-deletion (see the note in the constructor) we want the bit     // pattern to prevent error retention in a deleted object   } while (!state_.compare_exchange_strong(curr, kShutdownBit,-                                           std::memory_order_relaxed,+                                           std::memory_order_acq_rel,","Has `std::memory_order_relaxed` caused any problems? I think your reasoning is somehow different from what I understand. First, since `state_` is an atomic variable, there should not have race condition on the variable itself, which is not a valid reason to replace `memory_order_relaxed` with `memory_order_acq_rel`. Second, I think `std::memory_order_relaxed` is about we don't care about the order of operations to the variable `state_`.",
287917,eugeneo,https://api.github.com/repos/grpc/grpc/pulls/31793,1039873847,2022-12-05T17:18:31Z,src/core/ext/filters/stateful_session_affinity/stateful_session_affinity_filter.cc,"@@ -0,0 +1,231 @@+//+// Copyright 2022 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+//++#include <grpc/support/port_platform.h>++#include ""src/core/ext/filters/stateful_session_affinity/stateful_session_affinity_filter.h""++#include <string.h>++#include <algorithm>+#include <functional>+#include <memory>+#include <string>+#include <utility>+#include <vector>++#include ""absl/status/status.h""+#include ""absl/strings/escaping.h""+#include ""absl/strings/match.h""+#include ""absl/strings/str_cat.h""+#include ""absl/strings/str_join.h""+#include ""absl/strings/str_split.h""+#include ""absl/strings/string_view.h""+#include ""absl/types/optional.h""++#include <grpc/impl/codegen/gpr_types.h>+#include <grpc/support/log.h>++#include ""src/core/ext/filters/stateful_session_affinity/stateful_session_affinity_service_config_parser.h""+#include ""src/core/lib/channel/channel_stack.h""+#include ""src/core/lib/channel/context.h""+#include ""src/core/lib/config/core_configuration.h""+#include ""src/core/lib/debug/trace.h""+#include ""src/core/lib/gprpp/time.h""+#include ""src/core/lib/promise/context.h""+#include ""src/core/lib/promise/detail/basic_seq.h""+#include ""src/core/lib/promise/latch.h""+#include ""src/core/lib/promise/seq.h""+#include ""src/core/lib/promise/try_concurrently.h""+#include ""src/core/lib/resource_quota/arena.h""+#include ""src/core/lib/service_config/service_config_call_data.h""+#include ""src/core/lib/slice/slice.h""+#include ""src/core/lib/transport/metadata_batch.h""+#include ""src/core/lib/transport/transport.h""++namespace grpc_core {++TraceFlag grpc_stateful_session_affinity_filter_trace(+    false, ""stateful_session_affinity_filter"");++UniqueTypeName XdsHostOverrideTypeName() {+  static UniqueTypeName::Factory kFactory(""xds_host_override"");","I am open to renaming the policy, but its name is ""xds_override_host"" - different word order.",X
287917,eugeneo,https://api.github.com/repos/grpc/grpc/pulls/31793,1039877481,2022-12-05T17:22:10Z,src/core/ext/filters/stateful_session_affinity/stateful_session_affinity_filter.cc,"@@ -0,0 +1,231 @@+//+// Copyright 2022 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+//++#include <grpc/support/port_platform.h>++#include ""src/core/ext/filters/stateful_session_affinity/stateful_session_affinity_filter.h""++#include <string.h>++#include <algorithm>+#include <functional>+#include <memory>+#include <string>+#include <utility>+#include <vector>++#include ""absl/status/status.h""+#include ""absl/strings/escaping.h""+#include ""absl/strings/match.h""+#include ""absl/strings/str_cat.h""+#include ""absl/strings/str_join.h""+#include ""absl/strings/str_split.h""+#include ""absl/strings/string_view.h""+#include ""absl/types/optional.h""++#include <grpc/impl/codegen/gpr_types.h>+#include <grpc/support/log.h>++#include ""src/core/ext/filters/stateful_session_affinity/stateful_session_affinity_service_config_parser.h""+#include ""src/core/lib/channel/channel_stack.h""+#include ""src/core/lib/channel/context.h""+#include ""src/core/lib/config/core_configuration.h""+#include ""src/core/lib/debug/trace.h""+#include ""src/core/lib/gprpp/time.h""+#include ""src/core/lib/promise/context.h""+#include ""src/core/lib/promise/detail/basic_seq.h""+#include ""src/core/lib/promise/latch.h""+#include ""src/core/lib/promise/seq.h""+#include ""src/core/lib/promise/try_concurrently.h""+#include ""src/core/lib/resource_quota/arena.h""+#include ""src/core/lib/service_config/service_config_call_data.h""+#include ""src/core/lib/slice/slice.h""+#include ""src/core/lib/transport/metadata_batch.h""+#include ""src/core/lib/transport/transport.h""++namespace grpc_core {++TraceFlag grpc_stateful_session_affinity_filter_trace(+    false, ""stateful_session_affinity_filter"");++UniqueTypeName XdsHostOverrideTypeName() {+  static UniqueTypeName::Factory kFactory(""xds_host_override"");+  return kFactory.Create();+}++const grpc_channel_filter StatefulSessionAffinityFilter::kFilter =+    MakePromiseBasedFilter<StatefulSessionAffinityFilter,+                           FilterEndpoint::kClient>(+        ""stateful_session_affinity_filter"");++absl::StatusOr<StatefulSessionAffinityFilter>+StatefulSessionAffinityFilter::Create(const ChannelArgs&,+                                      ChannelFilter::Args filter_args) {+  return StatefulSessionAffinityFilter(filter_args);+}++StatefulSessionAffinityFilter::StatefulSessionAffinityFilter(+    ChannelFilter::Args filter_args)+    : index_(grpc_channel_stack_filter_instance_number(+          filter_args.channel_stack(),+          filter_args.uninitialized_channel_element())),+      service_config_parser_index_(+          StatefulSessionAffinityServiceConfigParser::ParserIndex()) {}++namespace {++// Adds the set-cookie header to the server initial metadata if needed.+void MaybeUpdateServerInitialMetadata(+    const StatefulSessionAffinityMethodParsedConfig::CookieConfig*+        cookie_config,+    absl::optional<absl::string_view> cookie_value,+    ServerMetadata* server_initial_metadata) {+  // Get peer string.+  auto peer_string = server_initial_metadata->get(PeerString());+  if (!peer_string.has_value()) return;  // Nothing we can do.+  // If there was no cookie or if the address changed, set the cookie.+  if (!cookie_value.has_value() || *peer_string != *cookie_value) {+    std::vector<std::string> parts = {+        absl::StrCat(*cookie_config->name, ""="",+                     absl::Base64Escape(*peer_string), ""; HttpOnly"")};+    if (cookie_config->path.has_value()) {+      parts.emplace_back(absl::StrCat(""Path="", *cookie_config->path));+    }+    if (cookie_config->ttl > Duration::Zero()) {+      parts.emplace_back(+          absl::StrCat(""Max-Age="", cookie_config->ttl.as_timespec().tv_sec));+    }+    server_initial_metadata->Append(+        ""set-cookie"", Slice::FromCopiedString(absl::StrJoin(parts, ""; "")),+        [](absl::string_view error, const Slice&) {+          gpr_log(GPR_ERROR, ""ERROR ADDING set-cookie METADATA: %s"",+                  std::string(error).c_str());+          GPR_ASSERT(false);+        });+  }+}++}  // namespace++// Construct a promise for one call.+ArenaPromise<ServerMetadataHandle>+StatefulSessionAffinityFilter::MakeCallPromise(+    CallArgs call_args, NextPromiseFactory next_promise_factory) {+  // Get config.+  auto* service_config_call_data = static_cast<ServiceConfigCallData*>(+      GetContext<+          grpc_call_context_element>()[GRPC_CONTEXT_SERVICE_CONFIG_CALL_DATA]+          .value);+  GPR_ASSERT(service_config_call_data != nullptr);+  auto* method_params = static_cast<StatefulSessionAffinityMethodParsedConfig*>(+      service_config_call_data->GetMethodParsedConfig(+          service_config_parser_index_));+  GPR_ASSERT(method_params != nullptr);+  auto* cookie_config = method_params->GetConfig(index_);+  GPR_ASSERT(cookie_config != nullptr);+  if (!cookie_config->name.has_value()) {+    return next_promise_factory(std::move(call_args));+  }+  // We have a config.+  // If the config has a path, check to see if it matches the request path.+  if (cookie_config->path.has_value()) {+    Slice* path_slice =+        call_args.client_initial_metadata->get_pointer(HttpPathMetadata());+    GPR_ASSERT(path_slice != nullptr);+    absl::string_view path = path_slice->as_string_view();+    // Matching criteria from+    // https://www.rfc-editor.org/rfc/rfc6265#section-5.1.4.+    if (!absl::StartsWith(path, *cookie_config->path) ||+        (path.size() != cookie_config->path->size() &&+         cookie_config->path->back() != '/' &&+         path[cookie_config->path->size() + 1] != '/')) {+      return next_promise_factory(std::move(call_args));+    }+  }+  // Check to see if we have a host override cookie.+  auto cookie_value = GetHostOverrideFromCookie(+      call_args.client_initial_metadata, *cookie_config->name);+  if (cookie_value.has_value()) {+    if (GRPC_TRACE_FLAG_ENABLED(grpc_stateful_session_affinity_filter_trace)) {+      gpr_log(GPR_INFO,+              ""chand=%p: stateful session affinity found cookie %s value %s"",+              this, cookie_config->name->c_str(),+              std::string(*cookie_value).c_str());+    }+    // We have a valid cookie, so add the call attribute to be used by the+    // xds_override_host LB policy.+    service_config_call_data->SetCallAttribute(XdsHostOverrideTypeName(),+                                               *cookie_value);+  }+  // Intercept server initial metadata.+  auto* read_latch = GetContext<Arena>()->New<Latch<ServerMetadata*>>();+  auto* write_latch =+      std::exchange(call_args.server_initial_metadata, read_latch);+  return TryConcurrently(+             Seq(next_promise_factory(std::move(call_args)),+                 [cookie_config, cookie_value](ServerMetadataHandle md) {+                   MaybeUpdateServerInitialMetadata(cookie_config, cookie_value,+                                                    md.get());+                   return md;+                 }))+      .NecessaryPull(Seq(read_latch->Wait(),+                         [write_latch, cookie_config,+                          cookie_value](ServerMetadata** md) -> absl::Status {+                           if (*md != nullptr) {+                             MaybeUpdateServerInitialMetadata(+                                 cookie_config, cookie_value, *md);+                           }+                           write_latch->Set(*md);+                           return absl::OkStatus();+                         }));+}++absl::optional<absl::string_view>","I am always curious about returning string_view from a method. Seems unsafe, especially in the long run as implementation can change unpredictably.",
287917,eugeneo,https://api.github.com/repos/grpc/grpc/pulls/31788,1039946374,2022-12-05T18:35:27Z,src/core/ext/filters/stateful_session_affinity/stateful_session_affinity_filter.cc,"@@ -0,0 +1,231 @@+//+// Copyright 2022 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+//++#include <grpc/support/port_platform.h>++#include ""src/core/ext/filters/stateful_session_affinity/stateful_session_affinity_filter.h""++#include <string.h>++#include <algorithm>+#include <functional>+#include <memory>+#include <string>+#include <utility>+#include <vector>++#include ""absl/status/status.h""+#include ""absl/strings/escaping.h""+#include ""absl/strings/match.h""+#include ""absl/strings/str_cat.h""+#include ""absl/strings/str_join.h""+#include ""absl/strings/str_split.h""+#include ""absl/strings/string_view.h""+#include ""absl/types/optional.h""++#include <grpc/impl/codegen/gpr_types.h>+#include <grpc/support/log.h>++#include ""src/core/ext/filters/stateful_session_affinity/stateful_session_affinity_service_config_parser.h""+#include ""src/core/lib/channel/channel_stack.h""+#include ""src/core/lib/channel/context.h""+#include ""src/core/lib/config/core_configuration.h""+#include ""src/core/lib/debug/trace.h""+#include ""src/core/lib/gprpp/time.h""+#include ""src/core/lib/promise/context.h""+#include ""src/core/lib/promise/detail/basic_seq.h""+#include ""src/core/lib/promise/latch.h""+#include ""src/core/lib/promise/seq.h""+#include ""src/core/lib/promise/try_concurrently.h""+#include ""src/core/lib/resource_quota/arena.h""+#include ""src/core/lib/service_config/service_config_call_data.h""+#include ""src/core/lib/slice/slice.h""+#include ""src/core/lib/transport/metadata_batch.h""+#include ""src/core/lib/transport/transport.h""++namespace grpc_core {++TraceFlag grpc_stateful_session_affinity_filter_trace(+    false, ""stateful_session_affinity_filter"");++UniqueTypeName XdsHostOverrideTypeName() {+  static UniqueTypeName::Factory kFactory(""xds_host_override"");","I would like to make sure we use consistent naming so we don't unnecessarily confuse the users. LB policy is ""xds_override_host"" (different word order). Which one would you prefer? I can rename the LB policy.",X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/31812,1040249135,2022-12-06T00:13:18Z,src/core/ext/xds/xds_client.cc,"@@ -1471,7 +1472,8 @@ XdsClient::XdsClient(       transport_factory_(std::move(transport_factory)),       request_timeout_(resource_request_timeout),       xds_federation_enabled_(XdsFederationEnabled()),-      api_(this, &grpc_xds_client_trace, bootstrap_->node(), &symtab_),+      api_(this, &grpc_xds_client_trace, bootstrap_->node(), &symtab_,+           user_agent_name, user_agent_version),",Please use `std::move()` for these two parameters to avoid unnecessary string copies.,
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/31809,1040298796,2022-12-06T01:23:56Z,src/core/ext/transport/chttp2/transport/hpack_parser.cc,"@@ -1189,17 +1189,49 @@ class HPackParser::Parser {         std::move(result));   } +  class MetadataSizeLimitExceededEncoder {+   public:+    explicit MetadataSizeLimitExceededEncoder(std::string& summary)+        : summary_(summary) {}++    void Encode(const Slice& key, const Slice& value) {+      absl::StrAppend(&summary_, "" "", key.as_string_view(), "":"",+                      hpack_constants::SizeForEntry(key.size(), value.size()),+                      ""B"");+    }++    template <typename Key, typename Value>+    void Encode(Key key, const Value& value) {+      absl::StrAppend(&summary_, "" "", Key::key(), "":"",+                      hpack_constants::SizeForEntry(Key::key().size(),+                                                    Key::Encode(value).size()),+                      ""B"");+    }++   private:+    std::string& summary_;+  };+   GPR_ATTRIBUTE_NOINLINE-  bool HandleMetadataSizeLimitExceeded(const HPackTable::Memento&) {+  bool HandleMetadataSizeLimitExceeded(const HPackTable::Memento& md) {+    // Collect a summary of sizes so far for debugging+    // Do not collect contents, for fear of exposing PII.+    std::string summary;+    if (metadata_buffer_ != nullptr) {+      MetadataSizeLimitExceededEncoder encoder(summary);+      metadata_buffer_->Encode(&encoder);","```for each metadata_element in metadata_buffer:  encoder->Encode(metadata_element.key, metadata_element.value);```",
84629581,krishnacx,https://api.github.com/repos/grpc/grpc/pulls/31813,1040464771,2022-12-06T04:54:37Z,src/core/ext/transport/chttp2/transport/chttp2_transport.cc,"@@ -2379,18 +2379,16 @@ static void read_action_locked(void* tp, grpc_error_handle error) {   }   std::swap(err, error);   if (t->closed_with_error.ok()) {-    size_t i = 0;     grpc_error_handle errors[3] = {error, absl::OkStatus(), absl::OkStatus()};-    for (; i < t->read_buffer.count && errors[1] == absl::OkStatus(); i++) {++    for (size_t i = 0; i < t->read_buffer.count && errors[1] == absl::OkStatus(); i++) {",do..while loop can be better here. Since the first iteration condition would be true anyways.,
84629581,krishnacx,https://api.github.com/repos/grpc/grpc/pulls/31816,1040573903,2022-12-06T07:04:06Z,include/grpc/event_engine/posix.h,"@@ -0,0 +1,130 @@+// Copyright 2022 gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+#ifndef GRPC_EVENT_ENGINE_POSIX_H+#define GRPC_EVENT_ENGINE_POSIX_H++#include <grpc/support/port_platform.h>++#include <functional>+#include <vector>++#include ""absl/functional/any_invocable.h""+#include ""absl/status/status.h""++#include <grpc/event_engine/endpoint_config.h>+#include <grpc/event_engine/event_engine.h>+#include <grpc/event_engine/memory_allocator.h>+#include <grpc/event_engine/port.h>+#include <grpc/event_engine/slice_buffer.h>++#ifdef GRPC_EVENT_ENGINE_POSIX++namespace grpc_event_engine {+namespace experimental {++/// This defines an EventEngine interface that all posix specific event engines+/// must implement.+class PosixEventEngine : public EventEngine {+  class PosixEventEngineEndpoint : public EventEngine::Endpoint {+   public:+    /// Returns the file descriptor associated with the posix endpoint.+    virtual int GetWrappedFd() = 0;+    /// Shutdown the endpoint. After this function call its illegal to invoke+    /// any other methods on the endpoint.+    /// \a release_fd - a pointer to hold the file descriptor associated with+    /// the posix endpoint. If it is not nullptr, then the file descriptor is+    /// not closed while the endpoint is shutdown. The pointer will be updated+    /// to hold the endpoint's assocaited file descriptor.+    /// \a on_release_cb - a callback to be invoked when the endpoint is+    /// shutdown and the file descriptor is released. It should only be invoked+    /// if release_fd is not nullptr.+    virtual void Shutdown(+        int* release_fd,+        absl::AnyInvocable<void(absl::Status)> on_release_cb) = 0;+  };+  /// Creates a PosixEventEngineEndpoint from an fd which is already assumed to+  /// be connected to a remote peer.+  /// \a fd - The connected socket file descriptor.+  /// \a peer_addr - The address of the peer to which the provided fd has been+  /// connected.+  /// \a config - Additional configuration to apply to the endpoint.+  /// \a memory_allocator - The endpoint may use the provided memory allocator+  /// to track memory allocations.+  virtual std::unique_ptr<PosixEventEngineEndpoint> CreateEndpointFromFd(+      int fd, const ResolvedAddress& peer_addr, const EndpointConfig& config,+      MemoryAllocator memory_allocator) = 0;++  /// Listens for incoming connection requests from gRPC clients and initiates+  /// request processing once connections are established.+  class PosixEventEngineListener : public EventEngine::Listener {+   public:+    /// Called when the posix listener has accepted a new client connection.+    /// \a listener_fd - The listening socket fd that accepted the new client+    /// connection.+    /// \a endpoint - The EventEngine endpoint to handle data exchange over the+    /// new client connection.+    /// \a memory_allocation - The callback may use the provided memory+    /// allocator to handle memory allocation operations.+    using PosixAcceptCallback = absl::AnyInvocable<void(+        int listener_fd, std::unique_ptr<Endpoint> endpoint,+        MemoryAllocator memory_allocator)>;+    /// Called when a posix listener bind operation completes. A single bind+    /// operation may trigger creation of multiple listener fds. This callback+    /// should be invoked once on each newly created and bound fd. If the+    /// corresponding bind operation fails for a particular fd, this callback+    /// must be invoked with a absl::FailedPreConditionError status.+    ///+    /// \a listener_fd - The listening socket fd that was bound to the specified+    /// address.+    using OnPosixBindNewFdCallback =+        absl::AnyInvocable<void(absl::StatusOr<int> listener_fd)>;+    /// Bind an address/port to this Listener.+    ///+    /// It is expected that multiple addresses/ports can be bound to this+    /// Listener before Listener::Start has been called. Returns either the+    /// bound port or an appropriate error status. The on_bind_new_fd callback+    /// is invoked once for each newly bound listener fd that may be created by+    /// this Bind operation.",Is description about function parameters no required ?,
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/31816,1041184637,2022-12-06T16:21:00Z,include/grpc/event_engine/posix.h,"@@ -0,0 +1,158 @@+// Copyright 2022 gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+#ifndef GRPC_EVENT_ENGINE_POSIX_H+#define GRPC_EVENT_ENGINE_POSIX_H++#include <grpc/support/port_platform.h>++#include <functional>+#include <vector>++#include ""absl/functional/any_invocable.h""+#include ""absl/status/status.h""++#include <grpc/event_engine/endpoint_config.h>+#include <grpc/event_engine/event_engine.h>+#include <grpc/event_engine/memory_allocator.h>+#include <grpc/event_engine/port.h>+#include <grpc/event_engine/slice_buffer.h>++namespace grpc_event_engine {+namespace experimental {++#ifdef GRPC_EVENT_ENGINE_POSIX++/// This defines an EventEngine interface that all posix specific event engines+/// must implement.+class PosixEventEngine : public EventEngine {+  class PosixEventEngineEndpoint : public EventEngine::Endpoint {+   public:+    /// Returns the file descriptor associated with the posix endpoint.+    virtual int GetWrappedFd() = 0;++    /// Shutdown the endpoint. After this function call its illegal to invoke+    /// any other methods on the endpoint.+    /// \a release_fd - a pointer to hold the file descriptor associated with+    /// the posix endpoint. If it is not nullptr, then the file descriptor is+    /// not closed while the endpoint is shutdown. The pointer will be updated+    /// to hold the endpoint's associated file descriptor.+    /// \a on_release_cb - a callback to be invoked when the endpoint is+    /// shutdown and the file descriptor is released. It should be invoked only+    /// if release_fd is not nullptr.+    virtual void Shutdown(+        int* release_fd,+        absl::AnyInvocable<void(absl::Status)> on_release_cb) = 0;+  };++  /// Creates a PosixEventEngineEndpoint from an fd which is already assumed to+  /// be connected to a remote peer.+  /// \a fd - The connected socket file descriptor.+  /// \a peer_addr - The address of the peer to which the provided fd has been+  /// connected.+  /// \a config - Additional configuration to applied to the endpoint.+  /// \a memory_allocator - The endpoint may use the provided memory allocator+  /// to track memory allocations.+  virtual std::unique_ptr<PosixEventEngineEndpoint> CreateEndpointFromFd(+      int fd, const ResolvedAddress& peer_addr, const EndpointConfig& config,+      MemoryAllocator memory_allocator) = 0;++  /// Listens for incoming connection requests from gRPC clients and initiates+  /// request processing once connections are established.+  class PosixEventEngineListener : public EventEngine::Listener {+   public:+    /// Called when the posix listener has accepted a new client connection.+    /// \a listener_fd - The listening socket fd that accepted the new client+    /// connection.+    /// \a endpoint - The EventEngine endpoint to handle data exchange over the+    /// new client connection.+    /// \a is_external - A boolean indicating whether the new client connection+    /// is accepted by an external listener_fd or by a listener_fd that is+    /// managed by the event engine listener.+    /// \a memory_allocation - The callback may use the provided memory+    /// allocator to handle memory allocation operations.+    /// \a pending_data - If specified, it holds any pending data that may have+    /// already been read over the new client connection. Otherwise, it is+    /// assumed that no data has been read over the new client connection.+    using PosixAcceptCallback = absl::AnyInvocable<void(+        int listener_fd, std::unique_ptr<Endpoint> endpoint, bool is_external,+        MemoryAllocator memory_allocator, SliceBuffer* pending_data)>;++    /// Called when a posix listener bind operation completes. A single bind+    /// operation may trigger creation of multiple listener fds. This callback+    /// should be invoked once on each newly created and bound fd. If the+    /// corresponding bind operation fails for a particular fd, this callback+    /// must be invoked with a absl::FailedPreConditionError status.+    ///+    /// \a listener_fd - The listening socket fd that was bound to the specified+    /// address.+    using OnPosixBindNewFdCallback =+        absl::AnyInvocable<void(absl::StatusOr<int> listener_fd)>;++    /// Bind an address/port to this Listener.+    ///+    /// It is expected that multiple addresses/ports can be bound to this+    /// Listener before Listener::Start has been called. Returns either the+    /// bound port or an appropriate error status.+    /// \a addr - The address to listen for incoming connections.+    /// \a on_bind_new_fd The callback is invoked once for each newly bound+    /// listener fd that may be created by this Bind operation.+    virtual absl::StatusOr<int> Bind(","What is the use-case for this?  Do we actually have cases where we need to use the EE impl to create a listen socket and then take the fd for that socket?  If so, why do we need the EE impl for this -- can't the caller just do the listen directly?",
5564114,Vignesh2208,https://api.github.com/repos/grpc/grpc/pulls/31816,1041261421,2022-12-06T17:28:55Z,include/grpc/event_engine/posix.h,"@@ -0,0 +1,158 @@+// Copyright 2022 gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+#ifndef GRPC_EVENT_ENGINE_POSIX_H+#define GRPC_EVENT_ENGINE_POSIX_H++#include <grpc/support/port_platform.h>++#include <functional>+#include <vector>++#include ""absl/functional/any_invocable.h""+#include ""absl/status/status.h""++#include <grpc/event_engine/endpoint_config.h>+#include <grpc/event_engine/event_engine.h>+#include <grpc/event_engine/memory_allocator.h>+#include <grpc/event_engine/port.h>+#include <grpc/event_engine/slice_buffer.h>++namespace grpc_event_engine {+namespace experimental {++#ifdef GRPC_EVENT_ENGINE_POSIX++/// This defines an EventEngine interface that all posix specific event engines+/// must implement.+class PosixEventEngine : public EventEngine {+  class PosixEventEngineEndpoint : public EventEngine::Endpoint {+   public:+    /// Returns the file descriptor associated with the posix endpoint.+    virtual int GetWrappedFd() = 0;++    /// Shutdown the endpoint. After this function call its illegal to invoke+    /// any other methods on the endpoint.+    /// \a release_fd - a pointer to hold the file descriptor associated with+    /// the posix endpoint. If it is not nullptr, then the file descriptor is+    /// not closed while the endpoint is shutdown. The pointer will be updated+    /// to hold the endpoint's associated file descriptor.+    /// \a on_release_cb - a callback to be invoked when the endpoint is+    /// shutdown and the file descriptor is released. It should be invoked only+    /// if release_fd is not nullptr.+    virtual void Shutdown(+        int* release_fd,+        absl::AnyInvocable<void(absl::Status)> on_release_cb) = 0;+  };++  /// Creates a PosixEventEngineEndpoint from an fd which is already assumed to+  /// be connected to a remote peer.+  /// \a fd - The connected socket file descriptor.+  /// \a peer_addr - The address of the peer to which the provided fd has been+  /// connected.+  /// \a config - Additional configuration to applied to the endpoint.+  /// \a memory_allocator - The endpoint may use the provided memory allocator+  /// to track memory allocations.+  virtual std::unique_ptr<PosixEventEngineEndpoint> CreateEndpointFromFd(+      int fd, const ResolvedAddress& peer_addr, const EndpointConfig& config,+      MemoryAllocator memory_allocator) = 0;++  /// Listens for incoming connection requests from gRPC clients and initiates+  /// request processing once connections are established.+  class PosixEventEngineListener : public EventEngine::Listener {+   public:+    /// Called when the posix listener has accepted a new client connection.+    /// \a listener_fd - The listening socket fd that accepted the new client+    /// connection.+    /// \a endpoint - The EventEngine endpoint to handle data exchange over the+    /// new client connection.+    /// \a is_external - A boolean indicating whether the new client connection+    /// is accepted by an external listener_fd or by a listener_fd that is+    /// managed by the event engine listener.+    /// \a memory_allocation - The callback may use the provided memory+    /// allocator to handle memory allocation operations.+    /// \a pending_data - If specified, it holds any pending data that may have+    /// already been read over the new client connection. Otherwise, it is+    /// assumed that no data has been read over the new client connection.+    using PosixAcceptCallback = absl::AnyInvocable<void(+        int listener_fd, std::unique_ptr<Endpoint> endpoint, bool is_external,+        MemoryAllocator memory_allocator, SliceBuffer* pending_data)>;++    /// Called when a posix listener bind operation completes. A single bind+    /// operation may trigger creation of multiple listener fds. This callback+    /// should be invoked once on each newly created and bound fd. If the+    /// corresponding bind operation fails for a particular fd, this callback+    /// must be invoked with a absl::FailedPreConditionError status.+    ///+    /// \a listener_fd - The listening socket fd that was bound to the specified+    /// address.+    using OnPosixBindNewFdCallback =+        absl::AnyInvocable<void(absl::StatusOr<int> listener_fd)>;++    /// Bind an address/port to this Listener.+    ///+    /// It is expected that multiple addresses/ports can be bound to this+    /// Listener before Listener::Start has been called. Returns either the+    /// bound port or an appropriate error status.+    /// \a addr - The address to listen for incoming connections.+    /// \a on_bind_new_fd The callback is invoked once for each newly bound+    /// listener fd that may be created by this Bind operation.+    virtual absl::StatusOr<int> Bind(","We have some internal use-cases. For each port, there may be a set of listening fds. By providing a callback to be invoked on each listening fd created for that port, we could maintain a map of all listening fds for each port which  later lets us retrieve a listening fd at a specific index.Currently, the grpc_tcp_server_port_fd and grpc_tcp_server_port_fd_count API methods exist to retrieve specific listening fds.",
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/30041,1041453169,2022-12-06T20:58:55Z,src/core/ext/filters/client_channel/lb_policy/rls/rls.cc,"@@ -1116,40 +1116,45 @@ LoadBalancingPolicy::PickResult RlsLb::Picker::Pick(PickArgs args) { RlsLb::Cache::Entry::BackoffTimer::BackoffTimer(RefCountedPtr<Entry> entry,                                                 Timestamp backoff_time)     : entry_(std::move(entry)) {-  GRPC_CLOSURE_INIT(&backoff_timer_callback_, OnBackoffTimer, this, nullptr);-  Ref(DEBUG_LOCATION, ""BackoffTimer"").release();-  grpc_timer_init(&backoff_timer_, backoff_time, &backoff_timer_callback_);+  backoff_timer_task_handle_ =+      entry_->lb_policy_->channel_control_helper()->GetEventEngine()->RunAfter(+          backoff_time - Timestamp::Now(),+          [self = Ref(DEBUG_LOCATION, ""BackoffTimer"")] {+            self->OnBackoffTimer();+          }); }  void RlsLb::Cache::Entry::BackoffTimer::Orphan() {-  if (armed_) {-    armed_ = false;-    grpc_timer_cancel(&backoff_timer_);+  if (backoff_timer_task_handle_.has_value()) {+    if (entry_->lb_policy_->channel_control_helper()->GetEventEngine()->Cancel(+            *backoff_timer_task_handle_)) {+      if (GRPC_TRACE_FLAG_ENABLED(grpc_lb_rls_trace)) {+        gpr_log(+            GPR_INFO, ""[rlslb %p] cache entry=%p %s, backoff timer canceled"",+            entry_->lb_policy_.get(), entry_.get(),+            entry_->is_shutdown_ ? ""(shut down)""+                                 : entry_->lru_iterator_->ToString().c_str());+      }+    }+    backoff_timer_task_handle_.reset();   }   Unref(DEBUG_LOCATION, ""Orphan""); } -void RlsLb::Cache::Entry::BackoffTimer::OnBackoffTimer(-    void* arg, grpc_error_handle /*error*/) {-  auto* self = static_cast<BackoffTimer*>(arg);-  self->entry_->lb_policy_->work_serializer()->Run(-      [self]() {-        RefCountedPtr<BackoffTimer> backoff_timer(self);+void RlsLb::Cache::Entry::BackoffTimer::OnBackoffTimer() {+  entry_->lb_policy_->work_serializer()->Run(+      [self = Ref(DEBUG_LOCATION, ""BackoffTimer-WorkSerializer"")]() {         {           MutexLock lock(&self->entry_->lb_policy_->mu_);+          self->backoff_timer_task_handle_.reset();           if (GRPC_TRACE_FLAG_ENABLED(grpc_lb_rls_trace)) {             gpr_log(GPR_INFO,-                    ""[rlslb %p] cache entry=%p %s, armed_=%d: ""-                    ""backoff timer fired"",+                    ""[rlslb %p] cache entry=%p %s, backoff timer fired"",                     self->entry_->lb_policy_.get(), self->entry_.get(),                     self->entry_->is_shutdown_                         ? ""(shut down)""-                        : self->entry_->lru_iterator_->ToString().c_str(),-                    self->armed_);+                        : self->entry_->lru_iterator_->ToString().c_str());           }-          bool cancelled = !self->armed_;-          self->armed_ = false;-          if (cancelled) return;","Good question. Previously `OnBackoffTimer` would be called whether the timer was cancelled or not, hence the need to check the condition inside the callback. Now, `OnBackoffTimer` is only called if the timer has _not_ been cancelled. The logic for what to do on cancellation was moved to line 1131. So I think it's correct as is.",
10496191,sifmelcara,https://api.github.com/repos/grpc/grpc/pulls/31814,1041501476,2022-12-06T21:56:38Z,src/core/ext/transport/binder/wire_format/transaction.h,"@@ -67,11 +68,11 @@ class Transaction {     GPR_ASSERT((flags_ & kFlagStatusDescription) == 0);     status_desc_ = status_desc;   }+  void SetOutOfBandClose() { flags_ |= kFlagOutOfBandClose; }   void SetStatus(int status) {-    GPR_ASSERT(!is_client_);-    GPR_ASSERT((flags_ >> 16) == 0);-    GPR_ASSERT(status < (1 << 16));-    flags_ |= (status << 16);+    GPR_ASSERT((flags_ >> kStatusCodeShift) == 0);+    GPR_ASSERT(status < (1 << kStatusCodeShift));",I think technically this should be `GPR_ASSERT(status < (1 << (32-kStatusCodeShift)));` since it is checking that `status` won't overflow a 32-bit integer after `<< 16`Maybe add some comments?,
10496191,sifmelcara,https://api.github.com/repos/grpc/grpc/pulls/31814,1041511913,2022-12-06T22:10:21Z,src/core/ext/transport/binder/wire_format/transaction.h,"@@ -67,11 +68,11 @@ class Transaction {     GPR_ASSERT((flags_ & kFlagStatusDescription) == 0);     status_desc_ = status_desc;   }+  void SetOutOfBandClose() { flags_ |= kFlagOutOfBandClose; }   void SetStatus(int status) {-    GPR_ASSERT(!is_client_);-    GPR_ASSERT((flags_ >> 16) == 0);-    GPR_ASSERT(status < (1 << 16));-    flags_ |= (status << 16);+    GPR_ASSERT((flags_ >> kStatusCodeShift) == 0);+    GPR_ASSERT(status < (1 << kStatusCodeShift));","Actually, left shift a integer to make it larger than `MAX_INT` is undefined behavior. So it should be `GPR_ASSERT(status < (1 << (31-kStatusCodeShift)));`",
5663878,yijiem,https://api.github.com/repos/grpc/grpc/pulls/30041,1041535342,2022-12-06T22:33:03Z,src/core/ext/filters/client_channel/lb_policy/rls/rls.cc,"@@ -1419,35 +1425,43 @@ void RlsLb::Cache::ResetAllBackoff() { void RlsLb::Cache::Shutdown() {   map_.clear();   lru_list_.clear();-  grpc_timer_cancel(&cleanup_timer_);+  if (cleanup_timer_handle_.has_value() &&+      lb_policy_->channel_control_helper()->GetEventEngine()->Cancel(+          *cleanup_timer_handle_)) {+    if (GRPC_TRACE_FLAG_ENABLED(grpc_lb_rls_trace)) {+      gpr_log(GPR_INFO, ""[rlslb %p] cache cleanup timer canceled"", lb_policy_);+    }+    cleanup_timer_handle_.reset();+    lb_policy_->Unref(DEBUG_LOCATION, ""Shutdown"");+  } } -void RlsLb::Cache::OnCleanupTimer(void* arg, grpc_error_handle error) {-  Cache* cache = static_cast<Cache*>(arg);-  cache->lb_policy_->work_serializer()->Run(-      [cache, error]() {-        RefCountedPtr<RlsLb> lb_policy(cache->lb_policy_);+void RlsLb::Cache::OnCleanupTimer() {+  {+    MutexLock lock(&lb_policy_->mu_);+    cleanup_timer_handle_.reset();+  }+  lb_policy_->work_serializer()->Run(+      [this]() {+        RefCountedPtr<RlsLb> lb_policy(lb_policy_);         if (GRPC_TRACE_FLAG_ENABLED(grpc_lb_rls_trace)) {-          gpr_log(GPR_INFO, ""[rlslb %p] cache cleanup timer fired (%s)"",-                  cache->lb_policy_, StatusToString(error).c_str());+          gpr_log(GPR_INFO, ""[rlslb %p] cache cleanup timer fired"", lb_policy_);         }-        if (error == absl::CancelledError()) return;","Is there a similar issue here, i.e. the logic of the timer being cancelled is conflated with shutdown?",
5663878,yijiem,https://api.github.com/repos/grpc/grpc/pulls/30041,1041565918,2022-12-06T23:11:07Z,src/core/ext/filters/client_channel/lb_policy/rls/rls.cc,"@@ -1419,35 +1425,41 @@ void RlsLb::Cache::ResetAllBackoff() { void RlsLb::Cache::Shutdown() {   map_.clear();   lru_list_.clear();-  grpc_timer_cancel(&cleanup_timer_);+  if (cleanup_timer_handle_.has_value() &&+      lb_policy_->channel_control_helper()->GetEventEngine()->Cancel(+          *cleanup_timer_handle_)) {+    if (GRPC_TRACE_FLAG_ENABLED(grpc_lb_rls_trace)) {+      gpr_log(GPR_INFO, ""[rlslb %p] cache cleanup timer canceled"", lb_policy_);+    }+    cleanup_timer_handle_.reset();",Maybe reset the handle regardless of whether `EventEngine::Cancel` returns true or false? I think technically we want to reset it when `EventEngine::Cancel` returns false.,
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/31819,1041609836,2022-12-07T00:15:24Z,src/core/ext/filters/client_channel/lb_policy/xds/xds_override_host.cc,"@@ -66,6 +68,12 @@ namespace {  constexpr absl::string_view kXdsOverrideHost = ""xds_override_host_experimental""; +std::string MakeKeyForAddress(const ServerAddress& address) {+  // Use only the address, not the attributes.+  auto addr_str = grpc_sockaddr_to_string(&address.address(), false);","We'll need to make sure that this generates the same string that the filter is using to populate the cookie value here:https://github.com/grpc/grpc/blob/0ca4bbfb9f27b6c95d59c086e0fcc2ed54ef79b8/src/core/ext/filters/stateful_session/stateful_session_filter.cc#L92I am not sure if these two will match exactly, since they're coming from slightly different places.  But we can figure this out when we write the e2e test.(I'm not suggesting any change here right now; I mention this just as something to be aware of when we write the e2e test.)",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/31819,1041614896,2022-12-07T00:22:24Z,src/core/ext/filters/client_channel/lb_policy/xds/xds_override_host.cc,"@@ -160,23 +180,37 @@ class XdsOverrideHostLb : public LoadBalancingPolicy {   grpc_connectivity_state state_ = GRPC_CHANNEL_IDLE;   absl::Status status_;   RefCountedPtr<SubchannelPicker> picker_;++  absl::Mutex subchannel_by_address_map_mu_;+  std::unordered_map<std::string, AddressMapEntry> subchannel_by_address_map_+      ABSL_GUARDED_BY(subchannel_by_address_map_mu_); };  // // XdsOverrideHostLb::Picker // -XdsOverrideHostLb::Picker::Picker(XdsOverrideHostLb* xds_override_host_lb,-                                  RefCountedPtr<SubchannelPicker> picker)-    : picker_(std::move(picker)) {+XdsOverrideHostLb::Picker::Picker(+    RefCountedPtr<XdsOverrideHostLb> xds_override_host_lb,+    RefCountedPtr<SubchannelPicker> picker)+    : policy_(xds_override_host_lb), picker_(std::move(picker)) {   if (GRPC_TRACE_FLAG_ENABLED(grpc_lb_xds_override_host_trace)) {     gpr_log(GPR_INFO, ""[xds_override_host_lb %p] constructed new picker %p"",-            xds_override_host_lb, this);+            xds_override_host_lb.get(), this);   } }  LoadBalancingPolicy::PickResult XdsOverrideHostLb::Picker::Pick(     LoadBalancingPolicy::PickArgs args) {+  std::string buffer;+  auto override_host =+      args.initial_metadata->Lookup(kOverrideHostHeaderName, &buffer);","We're not going to get the override host from a header, we're going to get it from a call attribute.  This should use the same mechanism as we're using to get the cluster name in the `xds_cluster_resolver` LB policy:https://github.com/grpc/grpc/blob/0ca4bbfb9f27b6c95d59c086e0fcc2ed54ef79b8/src/core/ext/filters/client_channel/lb_policy/xds/xds_cluster_manager.cc#L236In this case, the attribute you need to use is the one I defined in the HTTP filter:https://github.com/grpc/grpc/blob/0ca4bbfb9f27b6c95d59c086e0fcc2ed54ef79b8/src/core/ext/filters/stateful_session/stateful_session_filter.h#L37",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/31819,1041616806,2022-12-07T00:24:08Z,src/core/ext/filters/client_channel/lb_policy/xds/xds_override_host.cc,"@@ -243,6 +277,16 @@ absl::Status XdsOverrideHostLb::UpdateLocked(UpdateArgs args) {   if (child_policy_ == nullptr) {     child_policy_ = CreateChildPolicyLocked(args.args);   }+  if (args.addresses.ok()) {+    for (const auto& address : *args.addresses) {+      if (GRPC_TRACE_FLAG_ENABLED(grpc_lb_xds_override_host_trace)) {+        gpr_log(GPR_INFO, ""%s"", MakeKeyForAddress(address).c_str());","Instead of just logging every single address in the list, I think it would be useful to log when we are adding or removing an entry from the map.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/31819,1041621085,2022-12-07T00:30:27Z,src/core/ext/filters/client_channel/lb_policy/xds/xds_override_host.cc,"@@ -243,6 +277,16 @@ absl::Status XdsOverrideHostLb::UpdateLocked(UpdateArgs args) {   if (child_policy_ == nullptr) {     child_policy_ = CreateChildPolicyLocked(args.args);   }+  if (args.addresses.ok()) {","It doesn't look like we're actually updating the map here.  For any address in the new address list that does not already exist in the map, we need to add an entry to the map, and for any entry already in the map that is not present in the new address list, we need to delete it from the map.There's some pseudo-code for this in the gRFC (although it's a bit more complicated than what we really need here, because we don't currently support equivalent addresses):https://github.com/grpc/proposal/blob/de6a9d6db8feace15dfc7fd4b662605de520a7d2/A55-xds-stateful-session-affinity.md#lb-policy-for-stateful-session-affinityNote that this should be the only place that we change the set of entries in the map.  We will change the fields in the value of the map when subchannels are created or destroyed and when their connectivity states change, but the actual set of entries in the map should not change when those events occur.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/31819,1041650582,2022-12-07T01:19:03Z,src/core/ext/filters/client_channel/lb_policy/xds/xds_override_host.cc,"@@ -295,14 +342,52 @@ OrphanablePtr<LoadBalancingPolicy> XdsOverrideHostLb::CreateChildPolicyLocked(   return lb_policy; } +RefCountedPtr<SubchannelInterface> XdsOverrideHostLb::LookupSubchannelByAddress(+    absl::string_view address) {+  absl::MutexLock lock(&subchannel_by_address_map_mu_);+  std::string key{address};+  auto subchannel_record = subchannel_by_address_map_.find(key);+  if (subchannel_record == subchannel_by_address_map_.end()) {+    if (GRPC_TRACE_FLAG_ENABLED(grpc_lb_xds_override_host_trace)) {+      gpr_log(+          GPR_INFO,+          ""[xds_override_host_lb %p] Subchannel for address %s was not found"",+          this, key.c_str());+    }+    return nullptr;+  }+  if (GRPC_TRACE_FLAG_ENABLED(grpc_lb_xds_override_host_trace)) {+    gpr_log(GPR_INFO,+            ""[xds_override_host_lb %p] Subchannel for address %s was found"",+            this, key.c_str());+  }+  return subchannel_record->second.subchannel;+}++void XdsOverrideHostLb::RegisterSubchannel(+    const ServerAddress& address,+    RefCountedPtr<SubchannelInterface> subchannel) {+  absl::MutexLock lock(&subchannel_by_address_map_mu_);+  auto key = MakeKeyForAddress(address);+  if (GRPC_TRACE_FLAG_ENABLED(grpc_lb_xds_override_host_trace)) {+    gpr_log(GPR_INFO,+            ""[xds_override_host_lb %p] Added subchannel with address %s"", this,+            key.c_str());+  }+  subchannel_by_address_map_[key] = {subchannel};+}+ // // XdsOverrideHostLb::Helper //  RefCountedPtr<SubchannelInterface> XdsOverrideHostLb::Helper::CreateSubchannel(     ServerAddress address, const ChannelArgs& args) {-  return xds_override_host_policy_->channel_control_helper()->CreateSubchannel(-      address, args);+  auto subchannel =+      xds_override_host_policy_->channel_control_helper()->CreateSubchannel(+          address, args);+  xds_override_host_policy_->RegisterSubchannel(address, subchannel);","This handles adding a subchannel to the map, but it doesn't look like we're handling *removing* a subchannel from the map anywhere.  If the child policy unrefs a subchannel, we should not continue to hold a ref to it in the map, because that could potentially hold open a connection that is not actually needed.I don't think we can do this if we hold a ref to the subchannel in our map, because then we have no way to know when the child policy has unreffed the subchannel, since its ref-count will never go to zero.  Instead, I think we need a structure here similar to that of the `outlier_detection` policy:- The `AddressMapEntry` struct should become a ref-counted class.  (This is analogous to the `SubchannelState` class in the `outlier_detection` policy.)- When a subchannel is created, we wrap it in our own subchannel object, which will hold a ref to the relevant `AddressMapEntry`.- The `AddressMapEntry::subchannel` field should should be a raw pointer instead of a `RefCountedPtr<>` -- it should not hold ownership of the subchannel, since that will prevent the subchannel from being destroyed by the child policy.  Instead, when the subchannel wrapper is unreffed by the child policy, its dtor can check whether `AddressMapEntry::subchannel` is set to point to `this`, and if so, it will reset it to null.I think this approach also points to the right way to track the subchannel connectivity state: the subchannel wrapper can intercept the watcher started by the child policy, and it can update the state in the `AddressMapEntry` before passing it on to the child policy.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/31826,1042473350,2022-12-07T17:10:47Z,src/core/ext/filters/client_channel/resolver/polling_resolver.cc,"@@ -121,10 +121,11 @@ void PollingResolver::OnNextResolutionLocked() {             ""[polling resolver %p] re-resolution timer fired: shutdown_=%d"",             this, shutdown_);   }-  next_resolution_timer_handle_.reset();-  if (!shutdown_) {+  // If we haven't been cancelled nor shutdown, then start resolving.","The semantics of the iomgr timer API are that the callback is always invoked, even on a successful cancellation, so the callback had to check `error.ok()` to see if it was cancelled.  In the new EE API, the callback is not invoked on a successful cancellation, so there's no need for that check.Again, the important thing here is that when `ResetBackoffLocked()` is called, we cancel the timer, but we *do* want to start resolving immediately.  However, looking at the code more closely, it looks like this wasn't working correctly even before #31717.We need to consider the following cases for `ResetBackoffLocked()`:- Case 1: The timer is not running.  In this case, we do *not* want to call `StartResolvingLocked()`.- Case 2: The timer is running.  In this case, we want to cancel the timer, and we want to call `StartResolvingLocked()` immediately.  In this case, there are two sub-cases:    - Case 2a: Cancellation succeeds (i.e., the callback will never be invoked).  In this case, we need to invoke `StartResolvingLocked()` directly in `ResetBackoffLocked()`.    - Case 2b: Cancellation fails (i.e., the callback has already been scheduled).  In this case, we can either let the callback invoke `StartResolvingLocked()`, or we can ensure that the callback will not invoke `StartResolvingLocked()` and we can do it ourselves in `ResetBackoffLocked()`.  Given that we need to invoke `StartResolvingLocked()` inside of `ResetBackoffLocked()` for case 2a, it's probably easiest to do the same thing for case 2b.Given that, I suggest the following:- Keep the change here in `OnNextResolutionLocked()` so that it does not invoke `StartResolvingLocked()` if the timer was cancelled before the callback was invoked (case 2b).- Revert the change to `MaybeCancelNextResolutionTimer()`.  It should unconditionally reset `next_resolution_timer_handle_`, regardless of whether cancellation succeeded.- Change `ResetBackoffLocked()` to do this:```backoff_.Reset();if (next_resolution_timer_handle_.has_value()) {  MaybeCancelNextResolutionTimer();  StartResolvingLocked();}```",
287917,eugeneo,https://api.github.com/repos/grpc/grpc/pulls/31819,1042480656,2022-12-07T17:17:51Z,test/core/client_channel/lb_policy/xds_override_host_test.cc,"@@ -74,6 +80,76 @@ TEST_F(XdsOverrideHostTest, NoConfigReportsError) {       absl::InvalidArgumentError(""Missing policy config"")); } +TEST_F(XdsOverrideHostTest, OverrideHost) {+  const std::array<absl::string_view, 2> kAddresses = {""ipv4:127.0.0.1:441"",+                                                       ""ipv4:127.0.0.1:442""};+  EXPECT_EQ(policy_->name(), ""xds_override_host_experimental"");+  // 1. We use pick_first as a child+  EXPECT_EQ(ApplyUpdate(BuildUpdate(kAddresses,+                                    MakeXdsOverrideHostConfig(""round_robin"")),+                        policy_.get()),+            absl::OkStatus());+  ExpectConnectingUpdate();+  EXPECT_NE(ExpectState(GRPC_CHANNEL_CONNECTING), nullptr);",I believe I fixed all occurrences... A lot of copy-pasting in these test cases.I am trying to limit overlap between the test cases as that tends to increase the burden of maintaining the tests long-term. I am not sure if checking the picker beyond comparing to `nullptr` is needed.,X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/30041,1042815109,2022-12-08T00:45:49Z,src/core/ext/filters/client_channel/lb_policy/rls/rls.cc,"@@ -1116,40 +1116,47 @@ LoadBalancingPolicy::PickResult RlsLb::Picker::Pick(PickArgs args) { RlsLb::Cache::Entry::BackoffTimer::BackoffTimer(RefCountedPtr<Entry> entry,                                                 Timestamp backoff_time)     : entry_(std::move(entry)) {-  GRPC_CLOSURE_INIT(&backoff_timer_callback_, OnBackoffTimer, this, nullptr);-  Ref(DEBUG_LOCATION, ""BackoffTimer"").release();-  grpc_timer_init(&backoff_timer_, backoff_time, &backoff_timer_callback_);+  backoff_timer_task_handle_ =+      entry_->lb_policy_->channel_control_helper()->GetEventEngine()->RunAfter(+          backoff_time - Timestamp::Now(),",Need to instantiate an `ExecCtx` and `ApplicationCallbackExecCtx` here.,
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/31784,1043036386,2022-12-08T07:59:31Z,src/csharp/GRPC-TOOLS-MSBUILD.md,"@@ -0,0 +1,215 @@+# Grpc.Tools MSBuild integration overview",let's move this file under src/csharp/Grpc.Tools/ and call it e.g. `implementation_notes.md`?the .md file with capitals is more of an exception than a rule in our github repository.,
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/31450,1043160651,2022-12-08T10:04:17Z,src/csharp/Grpc.Core/Internal/BatchContextSafeHandle.cs,"@@ -86,6 +86,23 @@ public Metadata GetReceivedInitialMetadata()             return MetadataArraySafeHandle.ReadMetadataFromPtrUnsafe(metadataArrayPtr);         } +        // Gets data of recv_initial_metadata completion without throwing an+        // exception if the data is corrupt. This is to stop UnaryCall from hanging+        // if there is some internal problem.+        // See https://github.com/grpc/grpc/issues/29854+        public Metadata TryGetReceivedInitialMetadata()",I went through the thread of #29854 and didn't see any mention of failing to parse the InitalMetadata. The only issue that's reported is an error being thrown when GetReceivedStatusOnClient tries to convert the statusDetails to string. So it seems that proactively trying to modify GetReceivedInitialMetadata is unnecessary?The location of the problem:https://github.com/grpc/grpc/blob/90b0ea387e988b8615882e152a5152ed0801ec06/src/csharp/Grpc.Core/Internal/BatchContextSafeHandle.cs#L94,
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/31450,1043163389,2022-12-08T10:06:39Z,src/csharp/Grpc.Core/Internal/AsyncCall.cs,"@@ -116,7 +116,8 @@ public TResponse UnaryCall(TRequest msg)                             {                                 using (profiler.NewScope(""AsyncCall.UnaryCall.HandleBatch""))                                 {-                                    HandleUnaryResponse(success, ctx.GetReceivedStatusOnClient(), ctx.GetReceivedMessageReader(), ctx.GetReceivedInitialMetadata());+                                    HandleUnaryResponse(success, ctx.TryGetReceivedStatusOnClient(),","Changing the way the data gets read from context here would make the behavior for unary calls and for streaming calls inconsistent and I don't think we want that. I think instead, we should make a small modification to the original GetReceivedStatusOnClient() method and revert the changes here.",
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/31450,1043174355,2022-12-08T10:14:07Z,src/csharp/Grpc.Core/Internal/BatchContextSafeHandle.cs,"@@ -101,6 +118,24 @@ public ClientSideStatus GetReceivedStatusOnClient()             return new ClientSideStatus(status, metadata);         } +        // Gets data of recv_status_on_client completion without throwing an+        // exception if the data is corrupt. This is to stop UnaryCall from hanging+        // if there is some internal problem.+        // See https://github.com/grpc/grpc/issues/29854+        public ClientSideStatus TryGetReceivedStatusOnClient()","Instead of introducing a new method, we should modify the original GetReceivedStatusOnClient().AFAIK The only problem experienced in #29854 was the inability to convert the detailsPtr to details string (via MarshalUtils.PtrToStringUTF8)I think we should simply have a  try - catch around `MarshalUtils.PtrToStringUTF8(detailsPtr, (int)detailsLength.ToUInt32());` (and possibly also around `string debugErrorString = Marshal.PtrToStringAnsi(...)`) and log an error if the conversion fails (which should never happen under normal circumstances).https://github.com/grpc/grpc/blob/90b0ea387e988b8615882e152a5152ed0801ec06/src/csharp/Grpc.Core/Internal/BatchContextSafeHandle.cs#L94",X
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/31450,1043182312,2022-12-08T10:19:34Z,src/csharp/Grpc.Core/Internal/BatchContextSafeHandle.cs,"@@ -101,6 +118,24 @@ public ClientSideStatus GetReceivedStatusOnClient()             return new ClientSideStatus(status, metadata);         } +        // Gets data of recv_status_on_client completion without throwing an+        // exception if the data is corrupt. This is to stop UnaryCall from hanging+        // if there is some internal problem.+        // See https://github.com/grpc/grpc/issues/29854+        public ClientSideStatus TryGetReceivedStatusOnClient()",One way you could do this is to wrap the MarshalUtils.PtrToStringUTF8 into a new private method (e.g. `PtrToStringUTF8WithSafeFallback` and call it instead of MarshalUtils.PtrToStringUTF8 here.https://github.com/grpc/grpc/blob/90b0ea387e988b8615882e152a5152ed0801ec06/src/csharp/Grpc.Core/Internal/MarshalUtils.cs#L37,X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/30041,1043709882,2022-12-08T18:51:01Z,src/core/ext/filters/client_channel/lb_policy/rls/rls.cc,"@@ -1419,35 +1425,40 @@ void RlsLb::Cache::ResetAllBackoff() { void RlsLb::Cache::Shutdown() {   map_.clear();   lru_list_.clear();-  grpc_timer_cancel(&cleanup_timer_);+  if (cleanup_timer_handle_.has_value() &&+      lb_policy_->channel_control_helper()->GetEventEngine()->Cancel(+          *cleanup_timer_handle_)) {+    if (GRPC_TRACE_FLAG_ENABLED(grpc_lb_rls_trace)) {+      gpr_log(GPR_INFO, ""[rlslb %p] cache cleanup timer canceled"", lb_policy_);+    }+    lb_policy_->Unref(DEBUG_LOCATION, ""Shutdown"");+  }+  cleanup_timer_handle_.reset(); } -void RlsLb::Cache::OnCleanupTimer(void* arg, grpc_error_handle error) {-  Cache* cache = static_cast<Cache*>(arg);-  cache->lb_policy_->work_serializer()->Run(-      [cache, error]() {-        RefCountedPtr<RlsLb> lb_policy(cache->lb_policy_);+void RlsLb::Cache::OnCleanupTimer() {+  lb_policy_->work_serializer()->Run(","I would prefer to use the same pattern we're using everywhere else of capturing the ref in the callback lambda, since that allows the compiler to enfore ref ownership.  I understand that it means that we'll take a new ref and then drop the previous one every time the timer fires, but this isn't performance-sensitive code, so that seems like a good trade-off.",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/31844,1043973993,2022-12-09T01:23:44Z,src/core/lib/gpr/time_posix.cc,"@@ -114,7 +114,9 @@ static gpr_timespec now_impl(gpr_clock_type clock) {       break;     case GPR_CLOCK_MONOTONIC:       now_dbl = ((double)(mach_absolute_time() - g_time_start)) * g_time_scale;-      now.tv_sec = (int64_t)(now_dbl * 1e-9);+      // Add 5 seconds arbitrarily: avoids weird conditions in gprpp/time.cc+      // when there's a small number of seconds returned.+      now.tv_sec = (int64_t)(now_dbl * 1e-9 + 5.0);","We've got some issues in gprpp/time.cc initialization about wanting values > 1 second for gpr_now(GPR_CLOCK_MONOTONIC)... and given it needs to be *relatively* fast path there, and the monotonic clock is a number of seconds from an *arbitrary* epoch, it seems just moving the epoch here to sidestep the issue during initialization is fair game.",
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/31785,1043995381,2022-12-09T02:06:02Z,src/core/lib/event_engine/posix_engine/posix_endpoint.cc,"@@ -1132,7 +1165,12 @@ void PosixEndpointImpl::Write(     current_zerocopy_send_ = zerocopy_send_record;     handle_->NotifyOnWrite(on_write_);   } else {-    on_writable(status);+    // TODO(vigneshbabu): Consider eventually running this callback inline to+    // avoid a thread hop. At the time of submission, it causes deadlocks which+    // should be reolved after ExecCtx removal.+    engine_->Run([on_writable = std::move(on_writable), status]() mutable {+      on_writable(status);",I think that could work. We can stipulate that any non-EventEngine-internal uses of the following within core will need to instantiate their own ExecCtx and ApplicationCallbackExecCtx within the callback:* `::Run`* `::RunAfter`* `::Connect`'s OnConnectCallback* `::CreateListener`'s AcceptCallback and the on_shutdown callback* `::DNSResolver::Lookup*` callbacks* `::Endpoint::Read` and `::Endpoint::Write` callbacks.,
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/31844,1044625461,2022-12-09T16:32:12Z,src/core/lib/gpr/time_posix.cc,"@@ -114,7 +114,9 @@ static gpr_timespec now_impl(gpr_clock_type clock) {       break;     case GPR_CLOCK_MONOTONIC:       now_dbl = ((double)(mach_absolute_time() - g_time_start)) * g_time_scale;-      now.tv_sec = (int64_t)(now_dbl * 1e-9);+      // Add 5 seconds arbitrarily: avoids weird conditions in gprpp/time.cc+      // when there's a small number of seconds returned.+      now.tv_sec = (int64_t)(now_dbl * 1e-9 + 5.0);","(this need goes away when we increase the precision of `TimeStamp`, but until then we need to take steps to ensure that we don't accidentally produce timestamps way out towards the edges of its range)",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/31854,1044695746,2022-12-09T18:03:43Z,src/core/ext/filters/client_channel/lb_policy/grpclb/client_load_reporting_filter.cc,"@@ -25,6 +25,7 @@ #include ""absl/meta/type_traits.h"" #include ""absl/status/status.h"" #include ""absl/types/optional.h""+#include ""client_load_reporting_filter.h""","This is the second time recently I've seen iwyu add a duplicate include of the self-header without a path.  Not sure what's causing this, but I don't think this include is needed -- the right one is on line 21.",X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/31854,1044702021,2022-12-09T18:08:34Z,src/core/ext/filters/client_channel/lb_policy/grpclb/client_load_reporting_filter.cc,"@@ -33,118 +34,48 @@ #include ""src/core/lib/gprpp/ref_counted_ptr.h"" #include ""src/core/lib/iomgr/closure.h"" #include ""src/core/lib/iomgr/error.h""+#include ""src/core/lib/promise/join.h""+#include ""src/core/lib/promise/promise.h""+#include ""src/core/lib/promise/seq.h""+#include ""src/core/lib/promise/try_concurrently.h"" #include ""src/core/lib/transport/metadata_batch.h"" #include ""src/core/lib/transport/transport.h"" -static grpc_error_handle clr_init_channel_elem(-    grpc_channel_element* /*elem*/, grpc_channel_element_args* /*args*/) {-  return absl::OkStatus();-}--static void clr_destroy_channel_elem(grpc_channel_element* /*elem*/) {}+namespace grpc_core {+const grpc_channel_filter ClientLoadReportingFilter::kFilter =+    MakePromiseBasedFilter<ClientLoadReportingFilter, FilterEndpoint::kClient>(+        ""client_load_reporting""); -namespace {+absl::StatusOr<ClientLoadReportingFilter> ClientLoadReportingFilter::Create(+    const ChannelArgs&, ChannelFilter::Args) {+  return ClientLoadReportingFilter();+} -struct call_data {+ArenaPromise<ServerMetadataHandle> ClientLoadReportingFilter::MakeCallPromise(+    CallArgs call_args, NextPromiseFactory next_promise_factory) {   // Stats object to update.   grpc_core::RefCountedPtr<grpc_core::GrpcLbClientStats> client_stats;-  // State for intercepting send_initial_metadata.-  grpc_closure on_complete_for_send;-  grpc_closure* original_on_complete_for_send;-  bool send_initial_metadata_succeeded = false;-  // State for intercepting recv_initial_metadata.-  grpc_closure recv_initial_metadata_ready;-  grpc_closure* original_recv_initial_metadata_ready;-  bool recv_initial_metadata_succeeded = false;-};--}  // namespace--static void on_complete_for_send(void* arg, grpc_error_handle error) {-  call_data* calld = static_cast<call_data*>(arg);-  if (error.ok()) {-    calld->send_initial_metadata_succeeded = true;-  }-  grpc_core::Closure::Run(DEBUG_LOCATION, calld->original_on_complete_for_send,-                          error);-}--static void recv_initial_metadata_ready(void* arg, grpc_error_handle error) {-  call_data* calld = static_cast<call_data*>(arg);-  if (error.ok()) {-    calld->recv_initial_metadata_succeeded = true;-  }-  grpc_core::Closure::Run(DEBUG_LOCATION,-                          calld->original_recv_initial_metadata_ready, error);-}--static grpc_error_handle clr_init_call_elem(-    grpc_call_element* elem, const grpc_call_element_args* args) {-  GPR_ASSERT(args->context != nullptr);-  new (elem->call_data) call_data();-  return absl::OkStatus();-} -static void clr_destroy_call_elem(grpc_call_element* elem,-                                  const grpc_call_final_info* /*final_info*/,-                                  grpc_closure* /*ignored*/) {-  call_data* calld = static_cast<call_data*>(elem->call_data);-  if (calld->client_stats != nullptr) {-    // Record call finished, optionally setting client_failed_to_send and-    // received.-    calld->client_stats->AddCallFinished(-        !calld->send_initial_metadata_succeeded /* client_failed_to_send */,-        calld->recv_initial_metadata_succeeded /* known_received */);+  // Handle client initial metadata.+  // Grab client stats object from metadata.+  auto client_stats_md = call_args.client_initial_metadata->Take(+      grpc_core::GrpcLbClientStatsMetadata());+  if (client_stats_md.has_value()) {+    client_stats.reset(*client_stats_md);   }-  calld->~call_data();-} -static void clr_start_transport_stream_op_batch(-    grpc_call_element* elem, grpc_transport_stream_op_batch* batch) {-  call_data* calld = static_cast<call_data*>(elem->call_data);-  // Handle send_initial_metadata.-  if (batch->send_initial_metadata) {-    // Grab client stats object from metadata.-    auto client_stats_md =-        batch->payload->send_initial_metadata.send_initial_metadata->Take(-            grpc_core::GrpcLbClientStatsMetadata());-    if (client_stats_md.has_value()) {-      grpc_core::GrpcLbClientStats* client_stats = *client_stats_md;-      if (client_stats != nullptr) {-        calld->client_stats.reset(client_stats);-        // Intercept completion.-        calld->original_on_complete_for_send = batch->on_complete;-        GRPC_CLOSURE_INIT(&calld->on_complete_for_send, on_complete_for_send,-                          calld, grpc_schedule_on_exec_ctx);-        batch->on_complete = &calld->on_complete_for_send;-      }-    }-  }-  // Intercept completion of recv_initial_metadata.-  if (batch->recv_initial_metadata) {-    calld->original_recv_initial_metadata_ready =-        batch->payload->recv_initial_metadata.recv_initial_metadata_ready;-    GRPC_CLOSURE_INIT(&calld->recv_initial_metadata_ready,-                      recv_initial_metadata_ready, calld,-                      grpc_schedule_on_exec_ctx);-    batch->payload->recv_initial_metadata.recv_initial_metadata_ready =-        &calld->recv_initial_metadata_ready;-  }-  // Chain to next filter.-  grpc_call_next_op(elem, batch);+  auto* server_initial_metadata = call_args.server_initial_metadata;++  return Seq(next_promise_factory(std::move(call_args)),+             [server_initial_metadata, client_stats = std::move(client_stats)](+                 ServerMetadataHandle trailing_metadata) {+               if (client_stats != nullptr) {+                 client_stats->AddCallFinished(+                     trailing_metadata->get(GrpcStreamNetworkState()) ==+                         GrpcStreamNetworkState::kNotSentOnWire,+                     NowOrNever(server_initial_metadata->Wait()).has_value());","Do we have a guarantee that `server_initial_metadata` will still exist at this point?Also, I assume there's no problem with two different callers calling `Wait()` on the same latch?",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/31854,1044703686,2022-12-09T18:11:01Z,src/core/ext/filters/client_channel/lb_policy/grpclb/client_load_reporting_filter.cc,"@@ -33,118 +34,48 @@ #include ""src/core/lib/gprpp/ref_counted_ptr.h"" #include ""src/core/lib/iomgr/closure.h"" #include ""src/core/lib/iomgr/error.h""+#include ""src/core/lib/promise/join.h""+#include ""src/core/lib/promise/promise.h""+#include ""src/core/lib/promise/seq.h""+#include ""src/core/lib/promise/try_concurrently.h"" #include ""src/core/lib/transport/metadata_batch.h"" #include ""src/core/lib/transport/transport.h"" -static grpc_error_handle clr_init_channel_elem(-    grpc_channel_element* /*elem*/, grpc_channel_element_args* /*args*/) {-  return absl::OkStatus();-}--static void clr_destroy_channel_elem(grpc_channel_element* /*elem*/) {}+namespace grpc_core {+const grpc_channel_filter ClientLoadReportingFilter::kFilter =+    MakePromiseBasedFilter<ClientLoadReportingFilter, FilterEndpoint::kClient>(+        ""client_load_reporting""); -namespace {+absl::StatusOr<ClientLoadReportingFilter> ClientLoadReportingFilter::Create(+    const ChannelArgs&, ChannelFilter::Args) {+  return ClientLoadReportingFilter();+} -struct call_data {+ArenaPromise<ServerMetadataHandle> ClientLoadReportingFilter::MakeCallPromise(+    CallArgs call_args, NextPromiseFactory next_promise_factory) {   // Stats object to update.   grpc_core::RefCountedPtr<grpc_core::GrpcLbClientStats> client_stats;-  // State for intercepting send_initial_metadata.-  grpc_closure on_complete_for_send;-  grpc_closure* original_on_complete_for_send;-  bool send_initial_metadata_succeeded = false;-  // State for intercepting recv_initial_metadata.-  grpc_closure recv_initial_metadata_ready;-  grpc_closure* original_recv_initial_metadata_ready;-  bool recv_initial_metadata_succeeded = false;-};--}  // namespace--static void on_complete_for_send(void* arg, grpc_error_handle error) {-  call_data* calld = static_cast<call_data*>(arg);-  if (error.ok()) {-    calld->send_initial_metadata_succeeded = true;-  }-  grpc_core::Closure::Run(DEBUG_LOCATION, calld->original_on_complete_for_send,-                          error);-}--static void recv_initial_metadata_ready(void* arg, grpc_error_handle error) {-  call_data* calld = static_cast<call_data*>(arg);-  if (error.ok()) {-    calld->recv_initial_metadata_succeeded = true;-  }-  grpc_core::Closure::Run(DEBUG_LOCATION,-                          calld->original_recv_initial_metadata_ready, error);-}--static grpc_error_handle clr_init_call_elem(-    grpc_call_element* elem, const grpc_call_element_args* args) {-  GPR_ASSERT(args->context != nullptr);-  new (elem->call_data) call_data();-  return absl::OkStatus();-} -static void clr_destroy_call_elem(grpc_call_element* elem,-                                  const grpc_call_final_info* /*final_info*/,-                                  grpc_closure* /*ignored*/) {-  call_data* calld = static_cast<call_data*>(elem->call_data);-  if (calld->client_stats != nullptr) {-    // Record call finished, optionally setting client_failed_to_send and-    // received.-    calld->client_stats->AddCallFinished(-        !calld->send_initial_metadata_succeeded /* client_failed_to_send */,-        calld->recv_initial_metadata_succeeded /* known_received */);+  // Handle client initial metadata.+  // Grab client stats object from metadata.+  auto client_stats_md = call_args.client_initial_metadata->Take(+      grpc_core::GrpcLbClientStatsMetadata());+  if (client_stats_md.has_value()) {+    client_stats.reset(*client_stats_md);   }-  calld->~call_data();-} -static void clr_start_transport_stream_op_batch(-    grpc_call_element* elem, grpc_transport_stream_op_batch* batch) {-  call_data* calld = static_cast<call_data*>(elem->call_data);-  // Handle send_initial_metadata.-  if (batch->send_initial_metadata) {-    // Grab client stats object from metadata.-    auto client_stats_md =-        batch->payload->send_initial_metadata.send_initial_metadata->Take(-            grpc_core::GrpcLbClientStatsMetadata());-    if (client_stats_md.has_value()) {-      grpc_core::GrpcLbClientStats* client_stats = *client_stats_md;-      if (client_stats != nullptr) {-        calld->client_stats.reset(client_stats);-        // Intercept completion.-        calld->original_on_complete_for_send = batch->on_complete;-        GRPC_CLOSURE_INIT(&calld->on_complete_for_send, on_complete_for_send,-                          calld, grpc_schedule_on_exec_ctx);-        batch->on_complete = &calld->on_complete_for_send;-      }-    }-  }-  // Intercept completion of recv_initial_metadata.-  if (batch->recv_initial_metadata) {-    calld->original_recv_initial_metadata_ready =-        batch->payload->recv_initial_metadata.recv_initial_metadata_ready;-    GRPC_CLOSURE_INIT(&calld->recv_initial_metadata_ready,-                      recv_initial_metadata_ready, calld,-                      grpc_schedule_on_exec_ctx);-    batch->payload->recv_initial_metadata.recv_initial_metadata_ready =-        &calld->recv_initial_metadata_ready;-  }-  // Chain to next filter.-  grpc_call_next_op(elem, batch);+  auto* server_initial_metadata = call_args.server_initial_metadata;++  return Seq(next_promise_factory(std::move(call_args)),+             [server_initial_metadata, client_stats = std::move(client_stats)](+                 ServerMetadataHandle trailing_metadata) {+               if (client_stats != nullptr) {+                 client_stats->AddCallFinished(+                     trailing_metadata->get(GrpcStreamNetworkState()) ==+                         GrpcStreamNetworkState::kNotSentOnWire,","Are we sure that there are no differences in behavior between this and what we were doing before?  Are there any cases where send_initial_metadata can fail that would not be reported as `kNotSentOnWire` -- for example, what if send_initial_metadata is failed by another filter below this one but above the transport?",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/31854,1044787671,2022-12-09T19:38:16Z,src/core/ext/filters/client_channel/lb_policy/grpclb/client_load_reporting_filter.cc,"@@ -33,118 +34,48 @@ #include ""src/core/lib/gprpp/ref_counted_ptr.h"" #include ""src/core/lib/iomgr/closure.h"" #include ""src/core/lib/iomgr/error.h""+#include ""src/core/lib/promise/join.h""+#include ""src/core/lib/promise/promise.h""+#include ""src/core/lib/promise/seq.h""+#include ""src/core/lib/promise/try_concurrently.h"" #include ""src/core/lib/transport/metadata_batch.h"" #include ""src/core/lib/transport/transport.h"" -static grpc_error_handle clr_init_channel_elem(-    grpc_channel_element* /*elem*/, grpc_channel_element_args* /*args*/) {-  return absl::OkStatus();-}--static void clr_destroy_channel_elem(grpc_channel_element* /*elem*/) {}+namespace grpc_core {+const grpc_channel_filter ClientLoadReportingFilter::kFilter =+    MakePromiseBasedFilter<ClientLoadReportingFilter, FilterEndpoint::kClient>(+        ""client_load_reporting""); -namespace {+absl::StatusOr<ClientLoadReportingFilter> ClientLoadReportingFilter::Create(+    const ChannelArgs&, ChannelFilter::Args) {+  return ClientLoadReportingFilter();+} -struct call_data {+ArenaPromise<ServerMetadataHandle> ClientLoadReportingFilter::MakeCallPromise(+    CallArgs call_args, NextPromiseFactory next_promise_factory) {   // Stats object to update.   grpc_core::RefCountedPtr<grpc_core::GrpcLbClientStats> client_stats;-  // State for intercepting send_initial_metadata.-  grpc_closure on_complete_for_send;-  grpc_closure* original_on_complete_for_send;-  bool send_initial_metadata_succeeded = false;-  // State for intercepting recv_initial_metadata.-  grpc_closure recv_initial_metadata_ready;-  grpc_closure* original_recv_initial_metadata_ready;-  bool recv_initial_metadata_succeeded = false;-};--}  // namespace--static void on_complete_for_send(void* arg, grpc_error_handle error) {-  call_data* calld = static_cast<call_data*>(arg);-  if (error.ok()) {-    calld->send_initial_metadata_succeeded = true;-  }-  grpc_core::Closure::Run(DEBUG_LOCATION, calld->original_on_complete_for_send,-                          error);-}--static void recv_initial_metadata_ready(void* arg, grpc_error_handle error) {-  call_data* calld = static_cast<call_data*>(arg);-  if (error.ok()) {-    calld->recv_initial_metadata_succeeded = true;-  }-  grpc_core::Closure::Run(DEBUG_LOCATION,-                          calld->original_recv_initial_metadata_ready, error);-}--static grpc_error_handle clr_init_call_elem(-    grpc_call_element* elem, const grpc_call_element_args* args) {-  GPR_ASSERT(args->context != nullptr);-  new (elem->call_data) call_data();-  return absl::OkStatus();-} -static void clr_destroy_call_elem(grpc_call_element* elem,-                                  const grpc_call_final_info* /*final_info*/,-                                  grpc_closure* /*ignored*/) {-  call_data* calld = static_cast<call_data*>(elem->call_data);-  if (calld->client_stats != nullptr) {-    // Record call finished, optionally setting client_failed_to_send and-    // received.-    calld->client_stats->AddCallFinished(-        !calld->send_initial_metadata_succeeded /* client_failed_to_send */,-        calld->recv_initial_metadata_succeeded /* known_received */);+  // Handle client initial metadata.+  // Grab client stats object from metadata.+  auto client_stats_md = call_args.client_initial_metadata->Take(+      grpc_core::GrpcLbClientStatsMetadata());+  if (client_stats_md.has_value()) {+    client_stats.reset(*client_stats_md);   }-  calld->~call_data();-} -static void clr_start_transport_stream_op_batch(-    grpc_call_element* elem, grpc_transport_stream_op_batch* batch) {-  call_data* calld = static_cast<call_data*>(elem->call_data);-  // Handle send_initial_metadata.-  if (batch->send_initial_metadata) {-    // Grab client stats object from metadata.-    auto client_stats_md =-        batch->payload->send_initial_metadata.send_initial_metadata->Take(-            grpc_core::GrpcLbClientStatsMetadata());-    if (client_stats_md.has_value()) {-      grpc_core::GrpcLbClientStats* client_stats = *client_stats_md;-      if (client_stats != nullptr) {-        calld->client_stats.reset(client_stats);-        // Intercept completion.-        calld->original_on_complete_for_send = batch->on_complete;-        GRPC_CLOSURE_INIT(&calld->on_complete_for_send, on_complete_for_send,-                          calld, grpc_schedule_on_exec_ctx);-        batch->on_complete = &calld->on_complete_for_send;-      }-    }-  }-  // Intercept completion of recv_initial_metadata.-  if (batch->recv_initial_metadata) {-    calld->original_recv_initial_metadata_ready =-        batch->payload->recv_initial_metadata.recv_initial_metadata_ready;-    GRPC_CLOSURE_INIT(&calld->recv_initial_metadata_ready,-                      recv_initial_metadata_ready, calld,-                      grpc_schedule_on_exec_ctx);-    batch->payload->recv_initial_metadata.recv_initial_metadata_ready =-        &calld->recv_initial_metadata_ready;-  }-  // Chain to next filter.-  grpc_call_next_op(elem, batch);+  auto* server_initial_metadata = call_args.server_initial_metadata;++  return Seq(next_promise_factory(std::move(call_args)),+             [server_initial_metadata, client_stats = std::move(client_stats)](+                 ServerMetadataHandle trailing_metadata) {+               if (client_stats != nullptr) {+                 client_stats->AddCallFinished(+                     trailing_metadata->get(GrpcStreamNetworkState()) ==+                         GrpcStreamNetworkState::kNotSentOnWire,","There's a risk. I'm not aware of any filters that do that at the moment, but probably there's going to be some.We don't have an on-complete edge for send-initial-metadata any longer though, and I suspect we don't want one either (too much chatter in the stack), so I think this approach is for the best.",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/31856,1044838926,2022-12-09T20:58:27Z,src/core/lib/experiments/experiments.h,"@@ -25,27 +25,61 @@  namespace grpc_core { -inline bool IsTcpFrameSizeTuningEnabled() { return IsExperimentEnabled(0); }-inline bool IsTcpReadChunksEnabled() { return IsExperimentEnabled(1); }-inline bool IsTcpRcvLowatEnabled() { return IsExperimentEnabled(2); }-inline bool IsPeerStateBasedFramingEnabled() { return IsExperimentEnabled(3); }-inline bool IsFlowControlFixesEnabled() { return IsExperimentEnabled(4); }+enum ExperimentNames {",enum class,
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/31854,1044866282,2022-12-09T21:49:39Z,src/core/ext/filters/client_channel/lb_policy/grpclb/client_load_reporting_filter.cc,"@@ -33,118 +34,48 @@ #include ""src/core/lib/gprpp/ref_counted_ptr.h"" #include ""src/core/lib/iomgr/closure.h"" #include ""src/core/lib/iomgr/error.h""+#include ""src/core/lib/promise/join.h""+#include ""src/core/lib/promise/promise.h""+#include ""src/core/lib/promise/seq.h""+#include ""src/core/lib/promise/try_concurrently.h"" #include ""src/core/lib/transport/metadata_batch.h"" #include ""src/core/lib/transport/transport.h"" -static grpc_error_handle clr_init_channel_elem(-    grpc_channel_element* /*elem*/, grpc_channel_element_args* /*args*/) {-  return absl::OkStatus();-}--static void clr_destroy_channel_elem(grpc_channel_element* /*elem*/) {}+namespace grpc_core {+const grpc_channel_filter ClientLoadReportingFilter::kFilter =+    MakePromiseBasedFilter<ClientLoadReportingFilter, FilterEndpoint::kClient>(+        ""client_load_reporting""); -namespace {+absl::StatusOr<ClientLoadReportingFilter> ClientLoadReportingFilter::Create(+    const ChannelArgs&, ChannelFilter::Args) {+  return ClientLoadReportingFilter();+} -struct call_data {+ArenaPromise<ServerMetadataHandle> ClientLoadReportingFilter::MakeCallPromise(+    CallArgs call_args, NextPromiseFactory next_promise_factory) {   // Stats object to update.   grpc_core::RefCountedPtr<grpc_core::GrpcLbClientStats> client_stats;-  // State for intercepting send_initial_metadata.-  grpc_closure on_complete_for_send;-  grpc_closure* original_on_complete_for_send;-  bool send_initial_metadata_succeeded = false;-  // State for intercepting recv_initial_metadata.-  grpc_closure recv_initial_metadata_ready;-  grpc_closure* original_recv_initial_metadata_ready;-  bool recv_initial_metadata_succeeded = false;-};--}  // namespace--static void on_complete_for_send(void* arg, grpc_error_handle error) {-  call_data* calld = static_cast<call_data*>(arg);-  if (error.ok()) {-    calld->send_initial_metadata_succeeded = true;-  }-  grpc_core::Closure::Run(DEBUG_LOCATION, calld->original_on_complete_for_send,-                          error);-}--static void recv_initial_metadata_ready(void* arg, grpc_error_handle error) {-  call_data* calld = static_cast<call_data*>(arg);-  if (error.ok()) {-    calld->recv_initial_metadata_succeeded = true;-  }-  grpc_core::Closure::Run(DEBUG_LOCATION,-                          calld->original_recv_initial_metadata_ready, error);-}--static grpc_error_handle clr_init_call_elem(-    grpc_call_element* elem, const grpc_call_element_args* args) {-  GPR_ASSERT(args->context != nullptr);-  new (elem->call_data) call_data();-  return absl::OkStatus();-} -static void clr_destroy_call_elem(grpc_call_element* elem,-                                  const grpc_call_final_info* /*final_info*/,-                                  grpc_closure* /*ignored*/) {-  call_data* calld = static_cast<call_data*>(elem->call_data);-  if (calld->client_stats != nullptr) {-    // Record call finished, optionally setting client_failed_to_send and-    // received.-    calld->client_stats->AddCallFinished(-        !calld->send_initial_metadata_succeeded /* client_failed_to_send */,-        calld->recv_initial_metadata_succeeded /* known_received */);+  // Handle client initial metadata.+  // Grab client stats object from metadata.+  auto client_stats_md = call_args.client_initial_metadata->Take(+      grpc_core::GrpcLbClientStatsMetadata());+  if (client_stats_md.has_value()) {+    client_stats.reset(*client_stats_md);   }-  calld->~call_data();-} -static void clr_start_transport_stream_op_batch(-    grpc_call_element* elem, grpc_transport_stream_op_batch* batch) {-  call_data* calld = static_cast<call_data*>(elem->call_data);-  // Handle send_initial_metadata.-  if (batch->send_initial_metadata) {-    // Grab client stats object from metadata.-    auto client_stats_md =-        batch->payload->send_initial_metadata.send_initial_metadata->Take(-            grpc_core::GrpcLbClientStatsMetadata());-    if (client_stats_md.has_value()) {-      grpc_core::GrpcLbClientStats* client_stats = *client_stats_md;-      if (client_stats != nullptr) {-        calld->client_stats.reset(client_stats);-        // Intercept completion.-        calld->original_on_complete_for_send = batch->on_complete;-        GRPC_CLOSURE_INIT(&calld->on_complete_for_send, on_complete_for_send,-                          calld, grpc_schedule_on_exec_ctx);-        batch->on_complete = &calld->on_complete_for_send;-      }-    }-  }-  // Intercept completion of recv_initial_metadata.-  if (batch->recv_initial_metadata) {-    calld->original_recv_initial_metadata_ready =-        batch->payload->recv_initial_metadata.recv_initial_metadata_ready;-    GRPC_CLOSURE_INIT(&calld->recv_initial_metadata_ready,-                      recv_initial_metadata_ready, calld,-                      grpc_schedule_on_exec_ctx);-    batch->payload->recv_initial_metadata.recv_initial_metadata_ready =-        &calld->recv_initial_metadata_ready;-  }-  // Chain to next filter.-  grpc_call_next_op(elem, batch);+  auto* server_initial_metadata = call_args.server_initial_metadata;++  return Seq(next_promise_factory(std::move(call_args)),+             [server_initial_metadata, client_stats = std::move(client_stats)](+                 ServerMetadataHandle trailing_metadata) {+               if (client_stats != nullptr) {+                 client_stats->AddCallFinished(+                     trailing_metadata->get(GrpcStreamNetworkState()) ==+                         GrpcStreamNetworkState::kNotSentOnWire,","Good point about not wanting an on-complete edge for send_initial_metadata anymore.I'm wondering if maybe it would be safer to reverse the semantics of the metadata attribute here.  Maybe we should change it to set an attribute when the transport *does* put the call on the wire, and then check here that the attribute is *not* set to that value?That having been said, this is probably fine for now, since we're trying to move away from grpclb anyway.",
57042389,tonydnewell,https://api.github.com/repos/grpc/grpc/pulls/31450,1045096620,2022-12-10T15:10:34Z,src/csharp/Grpc.Core/Internal/BatchContextSafeHandle.cs,"@@ -86,6 +86,23 @@ public Metadata GetReceivedInitialMetadata()             return MetadataArraySafeHandle.ReadMetadataFromPtrUnsafe(metadataArrayPtr);         } +        // Gets data of recv_initial_metadata completion without throwing an+        // exception if the data is corrupt. This is to stop UnaryCall from hanging+        // if there is some internal problem.+        // See https://github.com/grpc/grpc/issues/29854+        public Metadata TryGetReceivedInitialMetadata()",I was being thorough and handling all cases that could cause a hang if an exception was thrown,
57042389,tonydnewell,https://api.github.com/repos/grpc/grpc/pulls/31450,1045201501,2022-12-11T09:39:55Z,src/csharp/Grpc.Core/Internal/AsyncCall.cs,"@@ -116,7 +116,8 @@ public TResponse UnaryCall(TRequest msg)                             {                                 using (profiler.NewScope(""AsyncCall.UnaryCall.HandleBatch""))                                 {-                                    HandleUnaryResponse(success, ctx.GetReceivedStatusOnClient(), ctx.GetReceivedMessageReader(), ctx.GetReceivedInitialMetadata());+                                    HandleUnaryResponse(success, ctx.TryGetReceivedStatusOnClient(),",The change is to make sure no exceptions are thrown in `UnaryCall`  to avoid a hang (by wrapping _all_ methods that are being called before calling `HandleUnaryResponse`) and make sure that the consequences of any exception are cleaned up.In the original `HandleUnaryResponse` there was already a `TryDeserialize` - I am just applying the same pattern to the other methods `TryGetReceivedStatusOnClient` and `TryGetReceivedInitialMetadata`.,
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/31854,1045392132,2022-12-12T04:19:12Z,src/core/ext/filters/client_channel/lb_policy/grpclb/client_load_reporting_filter.cc,"@@ -33,118 +33,49 @@ #include ""src/core/lib/gprpp/ref_counted_ptr.h"" #include ""src/core/lib/iomgr/closure.h"" #include ""src/core/lib/iomgr/error.h""+#include ""src/core/lib/promise/join.h""+#include ""src/core/lib/promise/promise.h""+#include ""src/core/lib/promise/seq.h""+#include ""src/core/lib/promise/try_concurrently.h"" #include ""src/core/lib/transport/metadata_batch.h"" #include ""src/core/lib/transport/transport.h"" -static grpc_error_handle clr_init_channel_elem(-    grpc_channel_element* /*elem*/, grpc_channel_element_args* /*args*/) {-  return absl::OkStatus();-}--static void clr_destroy_channel_elem(grpc_channel_element* /*elem*/) {}--namespace {--struct call_data {-  // Stats object to update.-  grpc_core::RefCountedPtr<grpc_core::GrpcLbClientStats> client_stats;-  // State for intercepting send_initial_metadata.-  grpc_closure on_complete_for_send;-  grpc_closure* original_on_complete_for_send;-  bool send_initial_metadata_succeeded = false;-  // State for intercepting recv_initial_metadata.-  grpc_closure recv_initial_metadata_ready;-  grpc_closure* original_recv_initial_metadata_ready;-  bool recv_initial_metadata_succeeded = false;-};+namespace grpc_core {+const grpc_channel_filter ClientLoadReportingFilter::kFilter =+    MakePromiseBasedFilter<ClientLoadReportingFilter, FilterEndpoint::kClient,+                           kFilterExaminesServerInitialMetadata>(+        ""client_load_reporting""); -}  // namespace--static void on_complete_for_send(void* arg, grpc_error_handle error) {-  call_data* calld = static_cast<call_data*>(arg);-  if (error.ok()) {-    calld->send_initial_metadata_succeeded = true;-  }-  grpc_core::Closure::Run(DEBUG_LOCATION, calld->original_on_complete_for_send,-                          error);+absl::StatusOr<ClientLoadReportingFilter> ClientLoadReportingFilter::Create(+    const ChannelArgs&, ChannelFilter::Args) {+  return ClientLoadReportingFilter(); } -static void recv_initial_metadata_ready(void* arg, grpc_error_handle error) {-  call_data* calld = static_cast<call_data*>(arg);-  if (error.ok()) {-    calld->recv_initial_metadata_succeeded = true;-  }-  grpc_core::Closure::Run(DEBUG_LOCATION,-                          calld->original_recv_initial_metadata_ready, error);-}--static grpc_error_handle clr_init_call_elem(-    grpc_call_element* elem, const grpc_call_element_args* args) {-  GPR_ASSERT(args->context != nullptr);-  new (elem->call_data) call_data();-  return absl::OkStatus();-}--static void clr_destroy_call_elem(grpc_call_element* elem,-                                  const grpc_call_final_info* /*final_info*/,-                                  grpc_closure* /*ignored*/) {-  call_data* calld = static_cast<call_data*>(elem->call_data);-  if (calld->client_stats != nullptr) {-    // Record call finished, optionally setting client_failed_to_send and-    // received.-    calld->client_stats->AddCallFinished(-        !calld->send_initial_metadata_succeeded /* client_failed_to_send */,-        calld->recv_initial_metadata_succeeded /* known_received */);+ArenaPromise<ServerMetadataHandle> ClientLoadReportingFilter::MakeCallPromise(+    CallArgs call_args, NextPromiseFactory next_promise_factory) {+  // Stats object to update.+  RefCountedPtr<GrpcLbClientStats> client_stats;++  // Handle client initial metadata.+  // Grab client stats object from metadata.+  auto client_stats_md =+      call_args.client_initial_metadata->Take(GrpcLbClientStatsMetadata());+  if (client_stats_md.has_value()) {+    client_stats.reset(*client_stats_md);   }-  calld->~call_data();-} -static void clr_start_transport_stream_op_batch(-    grpc_call_element* elem, grpc_transport_stream_op_batch* batch) {-  call_data* calld = static_cast<call_data*>(elem->call_data);-  // Handle send_initial_metadata.-  if (batch->send_initial_metadata) {-    // Grab client stats object from metadata.-    auto client_stats_md =-        batch->payload->send_initial_metadata.send_initial_metadata->Take(-            grpc_core::GrpcLbClientStatsMetadata());-    if (client_stats_md.has_value()) {-      grpc_core::GrpcLbClientStats* client_stats = *client_stats_md;-      if (client_stats != nullptr) {-        calld->client_stats.reset(client_stats);-        // Intercept completion.-        calld->original_on_complete_for_send = batch->on_complete;-        GRPC_CLOSURE_INIT(&calld->on_complete_for_send, on_complete_for_send,-                          calld, grpc_schedule_on_exec_ctx);-        batch->on_complete = &calld->on_complete_for_send;-      }-    }-  }-  // Intercept completion of recv_initial_metadata.-  if (batch->recv_initial_metadata) {-    calld->original_recv_initial_metadata_ready =-        batch->payload->recv_initial_metadata.recv_initial_metadata_ready;-    GRPC_CLOSURE_INIT(&calld->recv_initial_metadata_ready,-                      recv_initial_metadata_ready, calld,-                      grpc_schedule_on_exec_ctx);-    batch->payload->recv_initial_metadata.recv_initial_metadata_ready =-        &calld->recv_initial_metadata_ready;-  }-  // Chain to next filter.-  grpc_call_next_op(elem, batch);+  auto* server_initial_metadata = call_args.server_initial_metadata;++  return Seq(next_promise_factory(std::move(call_args)),","They're a little different:- `start_transport_stream_op_batch` is called once per batch of operations, so we do our work on that batch and then we pass control to the next one with `grpc_call_next_op` -- in some other filters we might also delay that call for some batches until some async work completes.- `MakeCallPromise` is called once per call and constructs a promise that will do the rest of the work. Since there's no asynchronous work to do to complete initial metadata for this filter we can immediately call the constructor for the next filter's promise as part of this one, and combine it into the total structure we return.",
57042389,tonydnewell,https://api.github.com/repos/grpc/grpc/pulls/31638,1045677484,2022-12-12T10:55:10Z,src/csharp/Grpc.Tools.Tests/MsBuildIntegrationTest.cs,"@@ -0,0 +1,382 @@+#region Copyright notice and license++// Copyright 2022 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++#endregion++using System;+using System.IO;+using NUnit.Framework;+using System.Diagnostics;+using System.Reflection;+using System.Collections.Specialized;+using System.Collections;+using System.Collections.Generic;+using Newtonsoft.Json;++namespace Grpc.Tools.Tests+{+    /// <summary>+    /// Tests for Grpc.Tools MSBuild .target and .props files.+    /// </summary>+    /// <remarks>+    /// The Grpc.Tools NuGet package is not tested directly, but instead the+    /// same .target and .props files are included in a MSBuild project and+    /// that project is built using ""dotnet build"" with the SDK installed on+    /// the test machine.+    /// <para>+    /// The real protoc compiler is not called. Instead a fake protoc script is+    /// called that does the minimum work needed for the build to succeed+    /// (generating cs files and writing dependencies file) and also writes out+    /// the arguments it was called with in a JSON file. The output is checked+    /// with expected results.+    /// </para>+    /// </remarks>+    public class MsBuildIntegrationTest+    {+        private const string TASKS_ASSEMBLY_PROPERTY = ""_Protobuf_MsBuildAssembly"";+        private const string TASKS_ASSEMBLY_DLL = ""Protobuf.MSBuild.dll"";+        private const string PROTBUF_FULLPATH_PROPERTY = ""Protobuf_ProtocFullPath"";+        private const string PLUGIN_FULLPATH_PROPERTY = ""gRPC_PluginFullPath"";+        private const string TOOLS_BUILD_DIR_PROPERTY = ""GrpcToolsBuildDir"";++        private static bool isMono = Type.GetType(""Mono.Runtime"") != null;++        private void SkipIfMonoOrNet45()+        {+            // We only want to run these tests once. This test class is just a driver+            // for calling the ""dotnet build"" processes, so it doesn't matter what+            // the runtime of this class actually is.+            //+            // If we were to allow the tests to be run on both .NET Framework (or Mono) and+            // .NET Core then we could get into a situation where both are running in+            // parallel which would cause the tests to fail as both would be writing to+            // the same files.++            if (isMono)+            {+                Assert.Ignore(""Skipping test when mono runtime"");+            }+#if NET45+            Assert.Ignore(""Skipping test when NET45"");+#endif+        }++        [Test]+        public void TestSingleProto()+        {+            SkipIfMonoOrNet45();+            string testId = Guid.NewGuid().ToString();++            TryRunMsBuild(""TestSingleProto"",+                ""file.proto:File.cs;FileGrpc.cs"",+                testId+                );+        }++        [Test]+        public void TestMultipleProtos()+        {+            SkipIfMonoOrNet45();+            string testId = Guid.NewGuid().ToString();++            TryRunMsBuild(""TestMultipleProtos"",+                ""file.proto:File.cs;FileGrpc.cs"" ++                ""|protos/another.proto:Another.cs;AnotherGrpc.cs"" ++                ""|second.proto:Second.cs;SecondGrpc.cs"",+                testId+                );+        }++        [Test]+        public void TestAtInPath()+        {+            SkipIfMonoOrNet45();+            string testId = Guid.NewGuid().ToString();++            TryRunMsBuild(""TestAtInPath"",+                ""@protos/file.proto:File.cs;FileGrpc.cs"",+                testId+                );+        }++        [Test]+        public void TestProtoOutsideProject()+        {+            SkipIfMonoOrNet45();+            string testId = Guid.NewGuid().ToString();++            TryRunMsBuild(""TestProtoOutsideProject/project"",+                ""../api/greet.proto:Greet.cs;GreetGrpc.cs"",+                testId+                );+        }++        /// <summary>+        /// Run ""dotnet build"" on the test's project file.+        /// </summary>+        /// <param name=""testName"">Name of test and name of directory containing the test</param>+        /// <param name=""filesToGenerate"">Tell the fake protoc script which files to generate</param>+        /// <param name=""testId"">A unique ID for the test run - used to create results file</param>+        private void TryRunMsBuild(string testName, string filesToGenerate, string testId)+        {+            var assemblyDir = Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location);+            var parentDir = System.IO.Directory.GetParent(assemblyDir).FullName;++            // Path for fake proto+            var fakeProtocScript = Platform.IsWindows ? ""fakeprotoc.bat"" : ""fakeprotoc.py"";",On Windows we have to wrap the python script in a BAT script since we can only pass one executable name without parameters to the MSBuild,
57042389,tonydnewell,https://api.github.com/repos/grpc/grpc/pulls/31638,1045679903,2022-12-12T10:57:35Z,src/csharp/Grpc.Tools.Tests/scripts/fakeprotoc.bat,"@@ -0,0 +1,4 @@+@echo off",On Windows we have to wrap the python script in a BAT script since we can only pass one executable name without parameters to the MSBuild,
57042389,tonydnewell,https://api.github.com/repos/grpc/grpc/pulls/31638,1045682006,2022-12-12T10:59:47Z,src/csharp/Grpc.Tools.Tests/scripts/fakeprotoc.py,"@@ -0,0 +1,327 @@+#!/usr/bin/env python3+# Copyright 2022 gRPC authors.+#+# Licensed under the Apache License, Version 2.0 (the ""License"");+# you may not use this file except in compliance with the License.+# You may obtain a copy of the License at+#+#     http://www.apache.org/licenses/LICENSE-2.0+#+# Unless required by applicable law or agreed to in writing, software+# distributed under the License is distributed on an ""AS IS"" BASIS,+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+# See the License for the specific language governing permissions and+# limitations under the License.++# Fake protobuf compiler for use in the Grpc.Tools MSBuild integration+# unit tests.  Its purpose is to be called from the Grpc.Tools +# Google.Protobuf.Tools.targets MSBuild file instead of the actual protoc+# compiler. This script:+# - parses the command line arguments+# - generates expected dependencies file+# - generates dummy .cs files that are expected by the tests+# - writes a JSON results file containing the arguments passed in++# Configuration is done via environment variables as it is not possible+# to pass additional argument when called from the MSBuild scripts under test.+#+# Environment variables:+# FAKEPROTOC_PROJECTDIR - output directory for generated files and output file+# FAKEPROTOC_GENERATE_EXPECTED - list of expected generated files in format:+#         file1.proto:csfile1.cs;csfile2.cs|file2.proto:csfile3.cs;csfile4.cs|...+# FAKEPROTOC_TESTID - unique id for the test used as name for JSON results file++import datetime+import hashlib+import json+import os+import sys++# Set to True to write out debug messages from this script+dbg = True+dbgfile = None++# Env variable: output directory for generated files and output file+FAKEPROTOC_PROJECTDIR = None+# Env variable: list of expected generated files+FAKEPROTOC_GENERATE_EXPECTED = None+# Env variable: unique id for the test used as name for JSON results file+FAKEPROTOC_TESTID = None++protoc_args = []+protoc_args_dict = {}+results_json = {}++dependencyfile = None+grpcout = None+protofile = None+proto_to_generated = {}++def create_debug(filename):+    """""" Create debug file for this script """"""+    global dbg+    global dbgfile+    if dbg:+        # append mode since this script may be called multiple times+        # during one build/test+        dbgfile = open(filename, ""a"")++def close_debug():+    """""" Close the debug file """"""+    global dbgfile+    if not dbgfile is None:+        dbgfile.close()++def write_debug(msg):+    """""" Write to the debug file if debug is enabled """"""+    global dbg+    global dbgfile+    if dbg and not dbgfile is None:+        print(msg, file=dbgfile, flush=True)++def read_protoc_arguments():+    """"""+    Read the protoc argument from the command line and+    any response files specified on the command line.++    Arguments are added to protoc_args for later parsing.+    """"""+    write_debug(""\nread_protoc_arguments"")+    global protoc_args+    for i in range(1, len(sys.argv), 1):+        arg = sys.argv[i]+        write_debug(""  arg: ""+arg)+        if arg.startswith(""@""):+            protoc_args.append(""# RSP file: ""+arg)+            read_rsp_file(arg[1:])+        else:+            protoc_args(arg)++def read_rsp_file(rspfile):+    """"""+    Read arguments from a response file.++    Arguments are added to protoc_args for later parsing.+    """"""+    write_debug(""\nread_rsp_file: ""+rspfile)+    global protoc_args+    with open(rspfile, ""r"") as rsp:+        for line in rsp:+            line = line.strip()+            write_debug(""    line: ""+line)+            protoc_args.append(line)++def parse_protoc_arguments():+    """"""+    Parse the protoc arguments that are in protoc_args+    """"""+    global protoc_args+    global dependencyfile+    global grpcout+    global protofile++    write_debug(""\nparse_protoc_arguments"")+    for arg in protoc_args:+        if dbg:+            write_debug(""Parsing: ""+arg)++        # All arguments containing file or directory paths are+        # normalised by converting to relative paths to the+        # project directory, and all '\' and changed to '/'+        if arg.startswith(""--""):+            (name, value) = arg.split(""="",1)++            if name == ""--dependency_out"":+                value = relative_to_project(value)+                dependencyfile = value+            elif name == ""--grpc_out"":+                value = relative_to_project(value)+                grpcout = value+            elif name in [ ""--grpc_out"", ""--proto_path"", ""--csharp_out"" ]:+                value = relative_to_project(value)++            add_protoc_arg_to_dict(name, value)++        elif arg.startswith(""#""):+            pass # ignore+        else:+            # proto file name+            protofile = relative_to_project(arg)+            add_protoc_arg_to_dict(""protofile"", protofile)++def add_protoc_arg_to_dict(name, value):+    """"""+    Add the arguments with name/value to protoc_args_dict++    protoc_args_dict is later used from writing out the JSON+    results file+    """"""+    global protoc_args_dict+    if name in protoc_args_dict:+        values = protoc_args_dict[name]+        values.append(value)+    else:+        protoc_args_dict[name] = [ value ]++def relative_to_project(file):+    """""" Convert a file path to one relative to the project directory """"""+    return normalise_slashes(os.path.relpath(os.path.abspath(file), FAKEPROTOC_PROJECTDIR))++def normalise_slashes(path):+    """""" Change all backslashes to forward slashes """"""+    return path.replace(""\\"",""/"")++def write_results_json(pf):+    """""" Write out the results JSON file """"""+    global protoc_args_dict+    global results_json+    global FAKEPROTOC_PROJECTDIR++    # Read existing json.+    # Since protoc may be called more than once each build/test if there is+    # more than one protoc file, we read the existing data to add to it.+    fname = os.path.abspath(FAKEPROTOC_PROJECTDIR+""/log/""+FAKEPROTOC_TESTID+"".json"")+    if os.path.isfile(fname):+        results_json = json.load(open(fname,""r""))+        protoc_files_dict = results_json.get(""Files"")+    else:+        results_json = {}+        protoc_files_dict = {}+        results_json[""Files""] = protoc_files_dict+    +    protofiles = protoc_args_dict.get(""protofile"")+    if protofiles is None:+        key = ""NONE""+    else:+        key = protofiles[0]+    results_json[""Metadata""] = { ""timestamp"": str(datetime.datetime.now()) }",Metadata is just for test developers - e.g. adding a timestamp so that can see when data was generated.It may become useful later when testing incremental builds - e.g. checking timestamp to check that it didn't run twice,
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/31819,1046051896,2022-12-12T16:24:37Z,src/core/ext/filters/client_channel/client_channel.h,"@@ -398,7 +398,7 @@ class ClientChannel::LoadBalancedCall      // Internal API to allow first-party LB policies to access per-call     // attributes set by the ConfigSelector.-    absl::string_view GetCallAttribute(UniqueTypeName type);+    virtual absl::string_view GetCallAttribute(UniqueTypeName type);","Suggest moving this into an interface, so that the fake impl in the test can inherit from the interface instead of the real implementation.  In other words, I suggest something like this:```// In a new file lb_call_state_internal.h.class LbCallStateInternal : public LoadBalancingPolicy::CallState { public:  virtual absl::string_view GetCallAttribute(UniqueTypeName type) = 0;};```Then change both `ClientChannel::LoadBalancedCall::LbCallState` and `FakeCallState` to inherit from `LbCallStateInternal`.",X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/31819,1046055012,2022-12-12T16:26:43Z,src/core/ext/filters/client_channel/lb_policy/xds/xds_override_host.cc,"@@ -68,11 +68,109 @@ namespace {  constexpr absl::string_view kXdsOverrideHost = ""xds_override_host_experimental""; -std::string MakeKeyForAddress(const ServerAddress& address) {-  // Use only the address, not the attributes.-  auto addr_str = grpc_sockaddr_to_string(&address.address(), false);-  return addr_str.ok() ? addr_str.value() : addr_str.status().ToString();-}+class SubchannelWrapper;",Please nest all of this inside of the `XdsOverrideHostLb` class.,
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/31819,1046087038,2022-12-12T16:48:54Z,src/core/ext/filters/client_channel/lb_policy/xds/xds_override_host.cc,"@@ -193,30 +280,39 @@ class XdsOverrideHostLb : public LoadBalancingPolicy { XdsOverrideHostLb::Picker::Picker(     RefCountedPtr<XdsOverrideHostLb> xds_override_host_lb,     RefCountedPtr<SubchannelPicker> picker)-    : policy_(xds_override_host_lb), picker_(std::move(picker)) {+    : policy_(std::move(xds_override_host_lb)), picker_(std::move(picker)) {   if (GRPC_TRACE_FLAG_ENABLED(grpc_lb_xds_override_host_trace)) {     gpr_log(GPR_INFO, ""[xds_override_host_lb %p] constructed new picker %p"",-            xds_override_host_lb.get(), this);+            policy_.get(), this);   } }  LoadBalancingPolicy::PickResult XdsOverrideHostLb::Picker::Pick(     LoadBalancingPolicy::PickArgs args) {-  std::string buffer;-  auto override_host =-      args.initial_metadata->Lookup(kOverrideHostHeaderName, &buffer);-  if (override_host.has_value()) {-    auto subchannel = policy_->LookupSubchannelByAddress(*override_host);-    if (subchannel != nullptr) {-      return PickResult::Complete{subchannel};-    }-  }   if (picker_ == nullptr) {  // Should never happen.     return PickResult::Fail(absl::InternalError(         ""xds_override_host picker not given any child picker""));   }+  std::string buffer;",This variable is no longer needed.,X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/31819,1046097044,2022-12-12T16:55:28Z,src/core/ext/filters/client_channel/lb_policy/xds/xds_override_host.cc,"@@ -342,39 +426,18 @@ OrphanablePtr<LoadBalancingPolicy> XdsOverrideHostLb::CreateChildPolicyLocked(   return lb_policy; } -RefCountedPtr<SubchannelInterface> XdsOverrideHostLb::LookupSubchannelByAddress(-    absl::string_view address) {-  absl::MutexLock lock(&subchannel_by_address_map_mu_);-  std::string key{address};-  auto subchannel_record = subchannel_by_address_map_.find(key);-  if (subchannel_record == subchannel_by_address_map_.end()) {-    if (GRPC_TRACE_FLAG_ENABLED(grpc_lb_xds_override_host_trace)) {-      gpr_log(-          GPR_INFO,-          ""[xds_override_host_lb %p] Subchannel for address %s was not found"",-          this, key.c_str());+void XdsOverrideHostLb::UpdateSubchannelByAddressMap(+    const absl::StatusOr<ServerAddressList>& addresses) {+  std::unordered_set<std::string> keys(addresses->size());","I think constructing this set is unnecessarily cumbersome; it will add a lot of generated code bloat and require memory allocation at run time.  Instead, I suggest just passing the `ServerAddressList` directly to `subchannel_by_address_map_.PrepareAddressMap()` and constructing the key for each address inside that function as we iterate through the list.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/31819,1046168382,2022-12-12T17:47:32Z,src/core/ext/filters/client_channel/lb_policy/xds/xds_override_host.cc,"@@ -68,11 +68,109 @@ namespace {  constexpr absl::string_view kXdsOverrideHost = ""xds_override_host_experimental""; -std::string MakeKeyForAddress(const ServerAddress& address) {-  // Use only the address, not the attributes.-  auto addr_str = grpc_sockaddr_to_string(&address.address(), false);-  return addr_str.ok() ? addr_str.value() : addr_str.status().ToString();-}+class SubchannelWrapper;++class SubchannelEntry : public RefCounted<SubchannelEntry> {+ public:+  void SetSubchannel(SubchannelInterface* subchannel) {+    absl::MutexLock lock(&mu_);+    subchannel_ = subchannel;+  }++  void ResetSubchannel(SubchannelInterface* expected) {+    absl::MutexLock lock(&mu_);+    if (subchannel_ == expected) {+      subchannel_ = nullptr;+    }+  }++  RefCountedPtr<SubchannelInterface> GetSubchannel() {+    absl::MutexLock lock(&mu_);+    if (subchannel_ == nullptr) {+      return RefCountedPtr<SubchannelInterface>(nullptr);+    }+    return subchannel_->Ref();+  }++ private:+  absl::Mutex mu_;","I'm not sure there's actually any value in having a separate mutex for each individual map entry.  Given the access pattern we expect here, I think it would be both simpler and more performant to just have a single lock that covers both the map and the entries within the map.The map will be accessed in the following places:1. From the picker, where we look up one specific subchannel and take a ref to it.2. From the control plane, in any of the following cases:    - When we get an updated address list from our parent (i.e., in `UpdateLocked()`).    - From the control plane, when a subchannel is created (i.e., in `Helper::CreateSubchannel()`).    - From the control plane, when a subchannel is destroyed (i.e., when the child policy unrefs the subchannel wrapper).All of the control plane cases will be serialized via the `WorkSerializer`, so there's no need to worry about them happening concurrently with each other.  So the only synchronization issue here is that the picker case may happen concurrently with any of the control plane cases.The case for which we really care about performance is case 1, so we want to minimize lock contention there.  With the current approach of having two locks, it's possible that a given pick could wind up seeing lock contention on both locks.  For example, consider the following sequence of events:1. The control plane gets a request from the child policy to create one of the subchannels.  It acquires the map-level lock to find the right entry (line 139).2. In another thread, the picker tries to acquire the map-level lock to lookup the override host (line 104).  Since the control plane thread is holding the lock, **the picker thread needs to block**.3. The control plane thread finishes its lookup and releases the map-level lock (line 144).  It then creates a new `SubchannelWrapper` (line 145), which calls `SetSubchannel()` on the entry (line 161), which acquires the lock in the entry (line 76).4. The picker thread now acquires the map-level lock and proceeds to do the map lookup.  It then calls `GetSubchannel()` on the entry (line 115), which attempts to acquire the entry's lock (line 88).  Since the control plane thread is holding the lock, **the picker thread needs to block again**.6. The control plane thread finishes setting the subchannel in the entry and releases the entry's lock (line 78).7. The picker thread now acquires the entry's lock and is able to grab the ref to the subchannel (line 92).Having the picker block twice is bad for performance.  If we eliminate the entry-level lock and just use the map-level lock to guard the entries as well, then the picker would have to block only once:1. The control plane gets a request from the child policy to create one of the subchannels.  It acquires the map-level lock to find the right entry.2. In another thread, the picker tries to acquire the map-level lock to lookup the override host.  Since the control plane thread is holding the lock, **the picker thread needs to block (this is the only place)**.3. The control plane thread looks up the right entry and sets the subchannel in the entry, both while holding the map-level lock.  Only then does it release the map-level lock.4. The picker thread now acquires the map-level lock.  It proceeds to do the map lookup and take the ref to the subchannel in the entry, both while holding the map-level lock.  Only then does it release the map-level lock.It's worth noting that currently, the channel itself holds a lock while invoking the picker, so there can be only one pick happening at any one time.  We will probably remove that lock in the channel at some point, so we don't want a design that depends on the presence of that lock.  However, the fact that that lock does currently exist tells us that we're unlikely to see a performance problem with having just one top-level lock, because with the current lock in the channel code, there will not be any unnecessary contention on the map-level lock here (i.e., there will be a max of two threads accessing it at any one time, one in the picker and the other in the control plane).  And even if we remove the lock from the channel code, having a single map-level lock here would be no worse than what we're currently doing in the channel.  And if we find that to be a problem at some point, we can consider ways to optimize this at that point.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/31819,1046182917,2022-12-12T17:54:43Z,test/core/client_channel/lb_policy/lb_policy_test_lib.h,"@@ -356,14 +357,21 @@ class LoadBalancingPolicyTest : public ::testing::Test {   };    // A fake CallState implementation, for use in PickArgs.-  class FakeCallState : public LoadBalancingPolicy::CallState {+  class FakeCallState : public ClientChannel::LoadBalancedCall::LbCallState {    public:+    explicit FakeCallState(std::map<UniqueTypeName, std::string> attributes)+        : LbCallState(nullptr), attributes_(attributes) {}+     ~FakeCallState() override {       for (void* allocation : allocations_) {         gpr_free(allocation);       }     } +    absl::string_view GetCallAttribute(UniqueTypeName type) override {","Nit: This can be private, since no one will call it directly on this class; it will be called only through the parent class's vtable.",X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/31819,1046184703,2022-12-12T17:55:38Z,test/core/client_channel/lb_policy/lb_policy_test_lib.h,"@@ -584,9 +593,9 @@ class LoadBalancingPolicyTest : public ::testing::Test {   // the result was something other than Complete.   absl::optional<std::string> ExpectPickComplete(       LoadBalancingPolicy::SubchannelPicker* picker,-      const std::map<std::string, std::string>& metadata = {},+      const std::map<UniqueTypeName, std::string> call_state = {},","This parameter should be named `call_attributes`, not `call_state`.",X
7221003,rockspore,https://api.github.com/repos/grpc/grpc/pulls/31368,1046225448,2022-12-12T18:27:49Z,test/core/end2end/fixtures/h2_tls_wrong_versions.cc,"@@ -0,0 +1,170 @@+/*+ *+ * Copyright 2018 gRPC authors.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ *     http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ *+ */++#include <string.h>++#include <string>++#include <grpc/grpc.h>++#include ""src/core/lib/gprpp/global_config_generic.h""+#include ""src/core/lib/gprpp/host_port.h""+#include ""src/core/lib/security/security_connector/ssl_utils_config.h""+#include ""test/core/end2end/end2end_tests.h""+#include ""test/core/end2end/fixtures/h2_tls_common.h""+#include ""test/core/util/port.h""+#include ""test/core/util/test_config.h""++static grpc_end2end_test_fixture chttp2_create_fixture_simple_fullstack_1(+    const grpc_channel_args*, const grpc_channel_args*) {+  grpc_end2end_test_fixture f;+  int port = grpc_pick_unused_port_or_die();+  fullstack_secure_fixture_data* ffd = new fullstack_secure_fixture_data();+  memset(&f, 0, sizeof(f));+  ffd->localaddr = grpc_core::JoinHostPort(""localhost"", port);+  SetChannelTlsVersion(ffd, SecurityPrimitives::TlsVersion::V_12,+                       SecurityPrimitives::TlsVersion::V_12);+  SetServerTlsVersion(ffd, SecurityPrimitives::TlsVersion::V_13,+                      SecurityPrimitives::TlsVersion::V_13);+  SetCertificateProvider(ffd,+                         SecurityPrimitives::ProviderType::STATIC_PROVIDER);+  SetCertificateVerifier(+      ffd, SecurityPrimitives::VerifierType::EXTERNAL_SYNC_VERIFIER);+  f.fixture_data = ffd;+  f.cq = grpc_completion_queue_create_for_next(nullptr);+  return f;+}++static grpc_end2end_test_fixture chttp2_create_fixture_simple_fullstack_2(+    const grpc_channel_args*, const grpc_channel_args*) {+  grpc_end2end_test_fixture f;+  int port = grpc_pick_unused_port_or_die();+  fullstack_secure_fixture_data* ffd = new fullstack_secure_fixture_data();+  memset(&f, 0, sizeof(f));+  ffd->localaddr = grpc_core::JoinHostPort(""localhost"", port);+  SetChannelTlsVersion(ffd, SecurityPrimitives::TlsVersion::V_13,+                       SecurityPrimitives::TlsVersion::V_13);+  SetServerTlsVersion(ffd, SecurityPrimitives::TlsVersion::V_12,+                      SecurityPrimitives::TlsVersion::V_12);+  SetCertificateProvider(ffd,+                         SecurityPrimitives::ProviderType::STATIC_PROVIDER);+  SetCertificateVerifier(+      ffd, SecurityPrimitives::VerifierType::EXTERNAL_SYNC_VERIFIER);+  f.fixture_data = ffd;+  f.cq = grpc_completion_queue_create_for_next(nullptr);+  return f;+}++static grpc_end2end_test_fixture chttp2_create_fixture_simple_fullstack_3(+    const grpc_channel_args*, const grpc_channel_args*) {+  grpc_end2end_test_fixture f;+  int port = grpc_pick_unused_port_or_die();+  fullstack_secure_fixture_data* ffd = new fullstack_secure_fixture_data();+  memset(&f, 0, sizeof(f));+  ffd->localaddr = grpc_core::JoinHostPort(""localhost"", port);+  SetChannelTlsVersion(ffd, SecurityPrimitives::TlsVersion::V_13,","After some discussion with @erm-g, we all agree that a check is needed as early as possible. Instead of doing this at the setter, I found there already exists a [sanity check](https://github.com/grpc/grpc/blob/f76948b12d9e853cea19bbafaf098533f6907d93/src/core/lib/security/credentials/tls/tls_credentials.cc#L43) invoked right before the options are used to created the credentials. So I added a check there and some unit tests.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/31819,1046232822,2022-12-12T18:35:55Z,test/core/client_channel/lb_policy/xds_override_host_test.cc,"@@ -74,6 +80,76 @@ TEST_F(XdsOverrideHostTest, NoConfigReportsError) {       absl::InvalidArgumentError(""Missing policy config"")); } +TEST_F(XdsOverrideHostTest, OverrideHost) {+  const std::array<absl::string_view, 2> kAddresses = {""ipv4:127.0.0.1:441"",+                                                       ""ipv4:127.0.0.1:442""};+  EXPECT_EQ(policy_->name(), ""xds_override_host_experimental"");+  // 1. We use pick_first as a child+  EXPECT_EQ(ApplyUpdate(BuildUpdate(kAddresses,+                                    MakeXdsOverrideHostConfig(""round_robin"")),+                        policy_.get()),+            absl::OkStatus());+  ExpectConnectingUpdate();+  EXPECT_NE(ExpectState(GRPC_CHANNEL_CONNECTING), nullptr);","I think it's important to keep in mind that the whole goal of the LB policy is to return the right picks.  All of the subchannel connectivity management that we're testing here **exists only for the purpose of ensuring that the policy returns the right picks**.  Given that, I think it's very important to always verify exact picker behavior, because that's ultimately the thing we actually care about.  If that's wrong, then the test is useless, because it's not verifying that the LB policy is behaving correctly.As long as we're relying on the picking behavior of simple underlying policies like pick_first and round_robin, I don't think it's going to add any particular maintenance burden to the tests to check the pick results, because the picking behavior of those two policies is not going to change.  And if we're already going to assert that the picker returns complete picks, I don't think we gain anything by not actually checking that the resulting address is the one we expect.Please change all occurrances of `EXPECT_TRUE(ExpectPickComplete(picker.get()).has_value())` to instead do `EXPECT_EQ(ExpectPickComplete(picker.get()), ""ipv4:127.0.0.1:441"")` (or whatever address is appropriate).",
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/31865,1046553469,2022-12-13T00:43:15Z,test/cpp/end2end/connection_attempt_injector.cc,"@@ -191,17 +193,19 @@ ConnectionAttemptInjector::InjectedDelay::InjectedDelay(     grpc_pollset_set* interested_parties, const EndpointConfig& config,     const grpc_resolved_address* addr, grpc_core::Timestamp deadline)     : attempt_(closure, ep, interested_parties, config, addr, deadline) {-  GRPC_CLOSURE_INIT(&timer_callback_, TimerCallback, this, nullptr);   grpc_core::Timestamp now = grpc_core::Timestamp::Now();   duration = std::min(duration, deadline - now);-  grpc_timer_init(&timer_, now + duration, &timer_callback_);+  grpc_event_engine::experimental::GetDefaultEventEngine()->RunAfter(+      duration, [this] {+        grpc_core::ApplicationCallbackExecCtx callback_exec_ctx;","Just a comment, no fix required: This is an interesting case in that I think these contexts are necessary, but they may have been _technically_ required in the previous implementation as well - `grpc_timer_init` may use `ExecCtx::Run` directly in a few situations, which will crash if one is not on the stack.",
5564114,Vignesh2208,https://api.github.com/repos/grpc/grpc/pulls/31848,1046685667,2022-12-13T05:52:48Z,src/core/lib/event_engine/windows/windows_engine.cc,"@@ -140,15 +178,171 @@ bool WindowsEventEngine::IsWorkerThread() {   GPR_ASSERT(false && ""unimplemented""); } -bool WindowsEventEngine::CancelConnect(EventEngine::ConnectionHandle handle) {-  GPR_ASSERT(false && ""unimplemented"");+void WindowsEventEngine::OnConnectCompleted(+    std::shared_ptr<ConnectionState> state) {+  // Connection attempt complete!+  grpc_core::MutexLock lock(&state->mu);+  state->on_connected = nullptr;+  {+    grpc_core::MutexLock handle_lock(&connection_mu_);+    known_connection_handles_.erase(state->connection_handle);+  }+  // return early if we cannot cancel the connection timeout timer.+  if (!Cancel(state->timer_handle)) return;+  auto write_info = state->socket->write_info();+  if (write_info->wsa_error() != 0) {+    auto error = GRPC_WSA_ERROR(write_info->wsa_error(), ""ConnectEx"");+    state->socket->MaybeShutdown(error);+    state->on_connected_user_callback(error);+    return;+  }+  // This code should be running in an executor thread already, so the callback+  // can be run directly.+  ChannelArgsEndpointConfig cfg;+  state->on_connected_user_callback(std::make_unique<WindowsEndpoint>(+      state->address, std::move(state->socket), std::move(state->allocator),+      cfg, executor_.get())); }  EventEngine::ConnectionHandle WindowsEventEngine::Connect(     OnConnectCallback on_connect, const ResolvedAddress& addr,-    const EndpointConfig& args, MemoryAllocator memory_allocator,-    Duration deadline) {-  GPR_ASSERT(false && ""unimplemented"");+    const EndpointConfig& /* args */, MemoryAllocator memory_allocator,+    Duration timeout) {+  // TODO(hork): utilize the endpoint config+  absl::Status status;+  int istatus;+  auto uri = ResolvedAddressToURI(addr);+  if (!uri.ok()) {+    Run([on_connect = std::move(on_connect), status = uri.status()]() mutable {+      on_connect(status);+    });+    return invalid_connection_handle;+  }+  GRPC_EVENT_ENGINE_TRACE(""EventEngine::%p connecting to %s"", this,+                          uri->c_str());+  // Use dualstack sockets where available.+  ResolvedAddress address = addr;+  ResolvedAddress addr6_v4mapped;+  if (ResolvedAddressToV4Mapped(addr, &addr6_v4mapped)) {+    address = addr6_v4mapped;+  }+  SOCKET sock = WSASocket(AF_INET6, SOCK_STREAM, IPPROTO_TCP, nullptr, 0,+                          IOCP::GetDefaultSocketFlags());+  if (sock == INVALID_SOCKET) {+    Run([on_connect = std::move(on_connect),+         status = GRPC_WSA_ERROR(WSAGetLastError(), ""WSASocket"")]() mutable {+      on_connect(status);+    });+    return invalid_connection_handle;+  }+  status = PrepareSocket(sock);+  if (!status.ok()) {+    Run([on_connect = std::move(on_connect), status]() mutable {+      on_connect(status);+    });+    return invalid_connection_handle;+  }+  // Grab the function pointer for ConnectEx for that specific socket It may+  // change depending on the interface.+  LPFN_CONNECTEX ConnectEx;+  GUID guid = WSAID_CONNECTEX;+  DWORD ioctl_num_bytes;+  istatus = WSAIoctl(sock, SIO_GET_EXTENSION_FUNCTION_POINTER, &guid,+                     sizeof(guid), &ConnectEx, sizeof(ConnectEx),+                     &ioctl_num_bytes, nullptr, nullptr);+  if (istatus != 0) {+    Run([on_connect = std::move(on_connect),+         status = GRPC_WSA_ERROR(+             WSAGetLastError(),+             ""WSAIoctl(SIO_GET_EXTENSION_FUNCTION_POINTER)"")]() mutable {+      on_connect(status);+    });+    return invalid_connection_handle;+  }+  // bind the local address+  auto local_address = ResolvedAddressMakeWild6(0);+  istatus = bind(sock, local_address.address(), local_address.size());+  if (istatus != 0) {+    Run([on_connect = std::move(on_connect),+         status = GRPC_WSA_ERROR(WSAGetLastError(), ""bind"")]() mutable {+      on_connect(status);+    });+    return invalid_connection_handle;+  }+  // Connect+  auto watched_socket = iocp_.Watch(sock);+  auto* info = watched_socket->write_info();+  bool success =+      ConnectEx(watched_socket->socket(), address.address(), address.size(),+                nullptr, 0, nullptr, info->overlapped());+  // It wouldn't be unusual to get a success immediately. But we'll still get an+  // IOCP notification, so let's ignore it.+  if (!success) {+    int last_error = WSAGetLastError();+    if (last_error != ERROR_IO_PENDING) {+      auto status = GRPC_WSA_ERROR(WSAGetLastError(), ""ConnectEx"");+      Run([on_connect = std::move(on_connect), status]() mutable {+        on_connect(status);+      });+      watched_socket->MaybeShutdown(status);+      return invalid_connection_handle;+    }+  }+  GPR_ASSERT(watched_socket != nullptr);+  auto connection_state = std::make_shared<ConnectionState>();+  grpc_core::MutexLock lock(&connection_state->mu);+  connection_state->address = address;+  connection_state->socket = std::move(watched_socket);+  connection_state->on_connected_user_callback = std::move(on_connect);+  connection_state->allocator = std::move(memory_allocator);+  connection_state->on_connected =+      SelfDeletingClosure::Create([this, connection_state]() mutable {+        OnConnectCompleted(std::move(connection_state));+      });+  {+    grpc_core::MutexLock conn_lock(&connection_mu_);+    connection_state->connection_handle =+        ConnectionHandle{reinterpret_cast<intptr_t>(connection_state.get()),+                         aba_token_.fetch_add(1)};+    known_connection_handles_.insert(connection_state->connection_handle);+  }+  connection_state->timer_handle =+      RunAfter(timeout, [this, connection_state]() {+        if (CancelConnect(connection_state->connection_handle)) {+          // delete the other ref to the connection state+          delete connection_state->on_connected;+          connection_state->on_connected_user_callback(+              absl::DeadlineExceededError(""Connection timed out""));+        }+        // else: The connection attempt could not be canceled. We can assume the+        // connection callback will be called.+      });+  connection_state->socket->NotifyOnWrite(connection_state->on_connected);+  return connection_state->connection_handle;+}++bool WindowsEventEngine::CancelConnect(EventEngine::ConnectionHandle handle) {+  if (TaskHandleComparator<ConnectionHandle>::Eq()(handle,+                                                   invalid_connection_handle)) {+    GRPC_EVENT_ENGINE_TRACE(""%s"",+                            ""Attempted to cancel an invalid connection handle"");+    return false;+  }+  grpc_core::MutexLock lock(&connection_mu_);+  if (!known_connection_handles_.contains(handle)) {+    GRPC_EVENT_ENGINE_TRACE(+        ""Unknown connection handle: %s"",+        HandleToString<EventEngine::ConnectionHandle>(handle).c_str());+    return false;+  }+  auto* connection_state = reinterpret_cast<ConnectionState*>(handle.keys[0]);+  connection_state->socket->MaybeShutdown(+      absl::CancelledError(""CancelConnect""));+  known_connection_handles_.erase(handle);","I think if CancelConnect succeeds, the timer started in line 309 also needs to be cancelled. Otherwise the timer callback will execute after deadline expires and it may not delete connection_state->on_connected.",
5663878,yijiem,https://api.github.com/repos/grpc/grpc/pulls/31877,1046688450,2022-12-13T05:57:41Z,src/core/ext/transport/chttp2/client/chttp2_connector.cc,"@@ -171,13 +174,16 @@ void Chttp2Connector::OnHandshakeDone(void* arg, grpc_error_handle error) {       self->Ref().release();  // Ref held by OnReceiveSettings()       GRPC_CLOSURE_INIT(&self->on_receive_settings_, OnReceiveSettings, self,                         grpc_schedule_on_exec_ctx);-      self->Ref().release();  // Ref held by OnTimeout()       grpc_chttp2_transport_start_reading(self->result_->transport,                                           args->read_buffer,                                           &self->on_receive_settings_, nullptr);-      GRPC_CLOSURE_INIT(&self->on_timeout_, OnTimeout, self,-                        grpc_schedule_on_exec_ctx);-      grpc_timer_init(&self->timer_, self->args_.deadline, &self->on_timeout_);+      self->timer_handle_ =+          self->args_.channel_args.GetObject<EventEngine>()->RunAfter(+              self->args_.deadline - Timestamp::Now(), [self = self->Ref()] {+                ApplicationCallbackExecCtx callback_exec_ctx;+                ExecCtx exec_ctx;+                static_cast<Chttp2Connector*>(self.get())->OnTimeout();+              });","An alternative is to write something like:```// self->Ref() returns a RefCountedPtr<SubchannelConnector>, an// implicit downcast will be used here:RefCountedPtr<Chttp2Connector> cc = self->Ref();self->timer_handle_ =    self->args_.channel_args.GetObject<EventEngine>()->RunAfter(        self->args_.deadline - Timestamp::Now(), [self = std::move(cc)] {          ApplicationCallbackExecCtx callback_exec_ctx;          ExecCtx exec_ctx;          self->OnTimeout();        });```I'm not sure which one is more readable or better in other ways. So went with the one without creating an extra `cc` variable.",X
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/31848,1047439261,2022-12-13T16:53:48Z,src/core/lib/event_engine/windows/windows_engine.cc,"@@ -140,15 +178,171 @@ bool WindowsEventEngine::IsWorkerThread() {   GPR_ASSERT(false && ""unimplemented""); } -bool WindowsEventEngine::CancelConnect(EventEngine::ConnectionHandle handle) {-  GPR_ASSERT(false && ""unimplemented"");+void WindowsEventEngine::OnConnectCompleted(+    std::shared_ptr<ConnectionState> state) {+  // Connection attempt complete!+  grpc_core::MutexLock lock(&state->mu);+  state->on_connected = nullptr;+  {+    grpc_core::MutexLock handle_lock(&connection_mu_);+    known_connection_handles_.erase(state->connection_handle);+  }+  // return early if we cannot cancel the connection timeout timer.+  if (!Cancel(state->timer_handle)) return;+  auto write_info = state->socket->write_info();+  if (write_info->wsa_error() != 0) {+    auto error = GRPC_WSA_ERROR(write_info->wsa_error(), ""ConnectEx"");+    state->socket->MaybeShutdown(error);+    state->on_connected_user_callback(error);+    return;+  }+  // This code should be running in an executor thread already, so the callback+  // can be run directly.+  ChannelArgsEndpointConfig cfg;+  state->on_connected_user_callback(std::make_unique<WindowsEndpoint>(+      state->address, std::move(state->socket), std::move(state->allocator),+      cfg, executor_.get())); }  EventEngine::ConnectionHandle WindowsEventEngine::Connect(     OnConnectCallback on_connect, const ResolvedAddress& addr,-    const EndpointConfig& args, MemoryAllocator memory_allocator,-    Duration deadline) {-  GPR_ASSERT(false && ""unimplemented"");+    const EndpointConfig& /* args */, MemoryAllocator memory_allocator,+    Duration timeout) {+  // TODO(hork): utilize the endpoint config+  absl::Status status;+  int istatus;+  auto uri = ResolvedAddressToURI(addr);+  if (!uri.ok()) {+    Run([on_connect = std::move(on_connect), status = uri.status()]() mutable {+      on_connect(status);+    });+    return invalid_connection_handle;+  }+  GRPC_EVENT_ENGINE_TRACE(""EventEngine::%p connecting to %s"", this,+                          uri->c_str());+  // Use dualstack sockets where available.+  ResolvedAddress address = addr;+  ResolvedAddress addr6_v4mapped;+  if (ResolvedAddressToV4Mapped(addr, &addr6_v4mapped)) {+    address = addr6_v4mapped;+  }+  SOCKET sock = WSASocket(AF_INET6, SOCK_STREAM, IPPROTO_TCP, nullptr, 0,+                          IOCP::GetDefaultSocketFlags());+  if (sock == INVALID_SOCKET) {+    Run([on_connect = std::move(on_connect),+         status = GRPC_WSA_ERROR(WSAGetLastError(), ""WSASocket"")]() mutable {+      on_connect(status);+    });+    return invalid_connection_handle;+  }+  status = PrepareSocket(sock);+  if (!status.ok()) {+    Run([on_connect = std::move(on_connect), status]() mutable {+      on_connect(status);+    });+    return invalid_connection_handle;+  }+  // Grab the function pointer for ConnectEx for that specific socket It may+  // change depending on the interface.+  LPFN_CONNECTEX ConnectEx;+  GUID guid = WSAID_CONNECTEX;+  DWORD ioctl_num_bytes;+  istatus = WSAIoctl(sock, SIO_GET_EXTENSION_FUNCTION_POINTER, &guid,+                     sizeof(guid), &ConnectEx, sizeof(ConnectEx),+                     &ioctl_num_bytes, nullptr, nullptr);+  if (istatus != 0) {+    Run([on_connect = std::move(on_connect),+         status = GRPC_WSA_ERROR(+             WSAGetLastError(),+             ""WSAIoctl(SIO_GET_EXTENSION_FUNCTION_POINTER)"")]() mutable {+      on_connect(status);+    });+    return invalid_connection_handle;+  }+  // bind the local address+  auto local_address = ResolvedAddressMakeWild6(0);+  istatus = bind(sock, local_address.address(), local_address.size());+  if (istatus != 0) {+    Run([on_connect = std::move(on_connect),+         status = GRPC_WSA_ERROR(WSAGetLastError(), ""bind"")]() mutable {+      on_connect(status);+    });+    return invalid_connection_handle;+  }+  // Connect+  auto watched_socket = iocp_.Watch(sock);+  auto* info = watched_socket->write_info();+  bool success =+      ConnectEx(watched_socket->socket(), address.address(), address.size(),+                nullptr, 0, nullptr, info->overlapped());+  // It wouldn't be unusual to get a success immediately. But we'll still get an+  // IOCP notification, so let's ignore it.+  if (!success) {+    int last_error = WSAGetLastError();+    if (last_error != ERROR_IO_PENDING) {+      auto status = GRPC_WSA_ERROR(WSAGetLastError(), ""ConnectEx"");+      Run([on_connect = std::move(on_connect), status]() mutable {+        on_connect(status);+      });+      watched_socket->MaybeShutdown(status);+      return invalid_connection_handle;+    }+  }+  GPR_ASSERT(watched_socket != nullptr);+  auto connection_state = std::make_shared<ConnectionState>();+  grpc_core::MutexLock lock(&connection_state->mu);","`ConnectionState`'s thread guard annotations would be unhappy with that change. We could move some things around, create a constructor for the type instead (which would only partially construct the object), or reduce the set of members protected by the lock, but would it help anything? This lock only affects this one connection, which is going to take just as long whether we lock before or after setting those member variables.",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/31875,1047568060,2022-12-13T18:22:41Z,tools/distrib/fix_build_deps.py,"@@ -329,8 +329,6 @@ def grpc_cc_library(name,             m = re.search(r'^#include ""(.*)""', line)             if m:                 inc.add(m.group(1))-            if 'grpc::g_glip' in line or 'grpc::g_core_codegen_interface' in line:-                needs_codegen_base_src.add(name)",I think that means we can remove the `needs_codegen_base_src` list entirely (and any supporting logic),X
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/31848,1047612507,2022-12-13T19:00:07Z,src/core/lib/event_engine/utils.h,"@@ -25,12 +25,16 @@ namespace grpc_event_engine { namespace experimental { -std::string HandleToString(EventEngine::TaskHandle handle);+// Returns a string representation of the EventEngine::*Handle types+template <typename Handle>","Nit:This would generate less bloat and faster build times if rewritten to:```std::string HandleToStringInner(uintptr_t a, uintptr_t b);template <typename Handle>std::string HandleToString(const Handle& handle) { return HandleToStringInner(a, b); }```(note: now the absl::StrCat isn't duplicated per type, and can be moved into the implementation file so that we're not including complex headers from our headers).",X
287917,eugeneo,https://api.github.com/repos/grpc/grpc/pulls/31819,1047649534,2022-12-13T19:35:23Z,src/core/ext/filters/client_channel/lb_policy/xds/xds_override_host.cc,"@@ -68,11 +68,109 @@ namespace {  constexpr absl::string_view kXdsOverrideHost = ""xds_override_host_experimental""; -std::string MakeKeyForAddress(const ServerAddress& address) {-  // Use only the address, not the attributes.-  auto addr_str = grpc_sockaddr_to_string(&address.address(), false);-  return addr_str.ok() ? addr_str.value() : addr_str.status().ToString();-}+class SubchannelWrapper;++class SubchannelEntry : public RefCounted<SubchannelEntry> {+ public:+  void SetSubchannel(SubchannelInterface* subchannel) {+    absl::MutexLock lock(&mu_);+    subchannel_ = subchannel;+  }++  void ResetSubchannel(SubchannelInterface* expected) {+    absl::MutexLock lock(&mu_);+    if (subchannel_ == expected) {+      subchannel_ = nullptr;+    }+  }++  RefCountedPtr<SubchannelInterface> GetSubchannel() {+    absl::MutexLock lock(&mu_);+    if (subchannel_ == nullptr) {+      return RefCountedPtr<SubchannelInterface>(nullptr);+    }+    return subchannel_->Ref();+  }++ private:+  absl::Mutex mu_;","I rolled the standalone ""map"" class into the LB policy class and removed the extra mutex.",
287917,eugeneo,https://api.github.com/repos/grpc/grpc/pulls/31819,1047697240,2022-12-13T20:22:58Z,test/core/client_channel/lb_policy/lb_policy_test_lib.h,"@@ -356,14 +357,21 @@ class LoadBalancingPolicyTest : public ::testing::Test {   };    // A fake CallState implementation, for use in PickArgs.-  class FakeCallState : public LoadBalancingPolicy::CallState {+  class FakeCallState : public ClientChannel::LoadBalancedCall::LbCallState {    public:+    explicit FakeCallState(std::map<UniqueTypeName, std::string> attributes)+        : LbCallState(nullptr), attributes_(attributes) {}+     ~FakeCallState() override {       for (void* allocation : allocations_) {         gpr_free(allocation);       }     } +    absl::string_view GetCallAttribute(UniqueTypeName type) override {",This is also how CallState is inherited. Should I have public inheritance from CallState and private from LbCallState?,
521666,chuchu,https://api.github.com/repos/grpc/grpc/pulls/31299,1047750709,2022-12-13T21:07:00Z,src/compiler/csharp_generator.cc,"@@ -110,6 +110,13 @@ bool GenerateDocCommentBody(grpc::protobuf::io::Printer* printer,   return GenerateDocCommentBodyImpl(printer, location); } +void GenerateObsoleteAttributeIfObsolete(grpc::protobuf::io::Printer* printer,+                                         const MethodDescriptor* method) {+  if (method->options().deprecated()) {+    printer->Print(""[global::System.Obsolete]\n"");","Hi Jan.Thanks for your reply! It looks like the deprecation of rpc methods is in some grey area. The proto3 language guide contains only an option to deprecate field options. It recommends that languages should create compiler warnings when such a field is used. For the deprecation of messages I can only find some older [issues](https://github.com/protocolbuffers/protobuf/issues/1734) discussing it.I tested it a bit with different languages and the most languages do not support it. Java and Golang do. C++, C#, Ruby and Python do not.The documentation and implementation of the deprecation option is inadequate. This leads to confusion because Java devs use it and are wondering why C# devs ignore it.I like your approach of versioning APIs using namespaces. Maybe because of the existence of the deprecation option it is done in a different way.Whatever approach we choose it should be consistent. The deprecation option is not and it will be discussed again and again. Either we implement it from end to end or we get rid of it. But that would be not backward compatible.",
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/31848,1047815405,2022-12-13T22:27:28Z,src/core/lib/event_engine/windows/windows_engine.h,"@@ -104,16 +99,58 @@ class WindowsEventEngine : public EventEngine,   bool Cancel(TaskHandle handle) override;   private:-  struct Closure;+  // State of an active connection.+  // Managed by a shared_ptr, owned exclusively by the timeout callback and the+  // OnConnectCompleted callback herein.+  struct ConnectionState {+    // everything is guarded by mu;+    grpc_core::Mutex mu;+    EventEngine::ConnectionHandle connection_handle ABSL_GUARDED_BY(mu);+    EventEngine::TaskHandle timer_handle ABSL_GUARDED_BY(mu);+    EventEngine::OnConnectCallback on_connected_user_callback+        ABSL_GUARDED_BY(mu);+    EventEngine::Closure* on_connected ABSL_GUARDED_BY(mu);","In this current design, the closure keeps the state object alive, and executing (or deleting) the closure triggers the shared_ptr<ConnectionState> ref decrement. If we changed this to a unique_ptr, we'd have more complex memory management of the state object itself, having to do something like manually release a held ref at the end of the closure.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/31819,1047843580,2022-12-13T23:14:06Z,src/core/ext/filters/client_channel/lb_policy/xds/xds_override_host.cc,"@@ -437,7 +392,50 @@ void XdsOverrideHostLb::UpdateSubchannelByAddressMap(       }     }   }-  subchannel_by_address_map_.PrepareAddressMap(keys);+  absl::MutexLock lock(&subchannel_map_mu_);+  for (auto it = subchannel_map_.begin(); it != subchannel_map_.end();) {+    if (keys.find(it->first) == keys.end()) {+      it = subchannel_map_.erase(it);+    } else {+      ++it;+    }+  }+  for (const auto& it : keys) {+    if (subchannel_map_.find(it) == subchannel_map_.end()) {+      subchannel_map_.emplace(it, MakeRefCounted<SubchannelEntry>());+    }+  }+}++RefCountedPtr<XdsOverrideHostLb::SubchannelWrapper>+XdsOverrideHostLb::AdoptSubchannel(+    ServerAddress address, RefCountedPtr<SubchannelInterface> subchannel) {+  absl::optional<RefCountedPtr<SubchannelEntry>> maybe_entry;",This variable is no longer used.,X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/31819,1047908515,2022-12-14T01:13:06Z,src/core/ext/filters/client_channel/lb_policy/xds/xds_override_host.cc,"@@ -246,6 +142,46 @@ class XdsOverrideHostLb : public LoadBalancingPolicy {     RefCountedPtr<XdsOverrideHostLb> xds_override_host_policy_;   }; +  class SubchannelWrapper : public DelegatingSubchannel {+   public:+    SubchannelWrapper(RefCountedPtr<SubchannelInterface> subchannel,","It looks like you're no longer having the subchannel take a ref to the map entry, which means that every time the subchannel needs to modify values in the map (e.g., whenever its connectivity state changes), it will need to do a map lookup.  I'm not sure whether or not this is a good trade-off: it reduces the memory usage by not storing another pointer in each `SubchannelWrapper`, but it increases CPU usage by having to do the lookup each time.Given how expensive memory is right now, I guess this is probably a reasonable trade-off.  But in that case, I think `SubchannelEntry` no longer needs to be ref-counted, because its lifetime will now be controlled solely by the existence of the map entry.",
11522026,ralphchung,https://api.github.com/repos/grpc/grpc/pulls/31804,1048520785,2022-12-14T14:13:40Z,test/core/iomgr/tcp_client_posix_test.cc,"@@ -207,27 +211,80 @@ void test_fails(void) {  void test_connect_cancellation_succeeds(void) {   gpr_log(GPR_ERROR, ""---- starting test_connect_cancellation_succeeds() ----"");+  auto target_ipv6_addr_uri = *grpc_core::URI::Parse(absl::StrCat(+      ""ipv6:[::1]:"", std::to_string(grpc_pick_unused_port_or_die())));+  auto target_ipv4_addr_uri = *grpc_core::URI::Parse(absl::StrCat(+      ""ipv4:127.0.0.1:"", std::to_string(grpc_pick_unused_port_or_die())));   grpc_resolved_address resolved_addr;-  struct sockaddr_in* addr =-      reinterpret_cast<struct sockaddr_in*>(resolved_addr.addr);+  ASSERT_TRUE(grpc_parse_uri(target_ipv6_addr_uri, &resolved_addr));   int svr_fd;   grpc_closure done;   grpc_core::ExecCtx exec_ctx;--  memset(&resolved_addr, 0, sizeof(resolved_addr));-  resolved_addr.len = static_cast<socklen_t>(sizeof(struct sockaddr_in));-  addr->sin_family = AF_INET;-+  bool tried_ipv4 = false;   /* create a phony server */-  svr_fd = socket(AF_INET, SOCK_STREAM, 0);-  ASSERT_GE(svr_fd, 0);-  ASSERT_EQ(bind(svr_fd, (struct sockaddr*)addr, (socklen_t)resolved_addr.len),-            0);+  svr_fd = socket(AF_INET6, SOCK_STREAM, 0);","Just for the readability, I think having helper functions might help the entire flow more neat and clean.```c++/// returns socket file descriptor or error statusabsl::StatusOr<int> TryIpv6(absl::string_view address); /// or any better function nameabsl::StatusOr<int> TryIpv4(absl::string_view address);auto ret = TryIpv6(absl::StrCat(""ipv6:[::1]:"", std::to_string(grpc_pick_unused_port_or_die())));if (!ret.ok()) {  ret = TryIpv4(absl::StrCat(""ipv4:127.0.0.1:"", std::to_string(grpc_pick_unused_port_or_die()));}if (!ret.ok()) {  gpr_log(GPR_ERROR, ...);  return;}const int server_fd = *ret;...```",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/31819,1049052118,2022-12-14T22:56:19Z,test/core/client_channel/lb_policy/lb_policy_test_lib.h,"@@ -356,14 +357,21 @@ class LoadBalancingPolicyTest : public ::testing::Test {   };    // A fake CallState implementation, for use in PickArgs.-  class FakeCallState : public LoadBalancingPolicy::CallState {+  class FakeCallState : public ClientChannel::LoadBalancedCall::LbCallState {    public:+    explicit FakeCallState(std::map<UniqueTypeName, std::string> attributes)+        : LbCallState(nullptr), attributes_(attributes) {}+     ~FakeCallState() override {       for (void* allocation : allocations_) {         gpr_free(allocation);       }     } +    absl::string_view GetCallAttribute(UniqueTypeName type) override {","You don't need to change the inheritence at all, just move this method into the private section.Note that the existing `Alloc()` method is already done this way.  The `Alloc()` method in the `LoadBalancingPolicy::CallState` base class is public, but the implementation of that method in this class is private.  This works fine, because when a caller is holding a pointer to the base class, they can call the public `Alloc()` method, and it will invoke the override here via the vtable, and vtable accesses aren't restricted by the method being private.  The fact that the method is private here just means that someone who is holding a pointer to `FakeCallState` (the derived class) would not be able to directly call the `Alloc()` method.Making the method overrides private in the derived class is sometimes useful for preventing callers from invoking the method directly on the derived class.  But that's not very common, so it ultimately doesn't matter very much.I don't actually care that much whether we keep these overrides private or make them public, but we should be consistent.  So please either make `Alloc()` public or make `GetCallAttributes()` private.",X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/31891,1049132221,2022-12-15T01:42:11Z,test/core/client_channel/lb_policy/lb_policy_test_lib.h,"@@ -651,10 +738,6 @@ class LoadBalancingPolicyTest : public ::testing::Test {     return &it->second;   } -  void ExpectQueueEmpty(SourceLocation location = SourceLocation()) {","I didn't remove it; I just moved it up to line 453, next to the other similar methods.",X
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/31638,1049737863,2022-12-15T14:52:40Z,src/csharp/Grpc.Tools.Tests/MsBuildIntegrationTest.cs,"@@ -0,0 +1,558 @@+#region Copyright notice and license++// Copyright 2022 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++#endregion++using System;+using System.IO;+using NUnit.Framework;+using System.Diagnostics;+using System.Reflection;+using System.Collections.Specialized;+using System.Collections;+using System.Collections.Generic;+using System.Text.RegularExpressions;+using Newtonsoft.Json;++namespace Grpc.Tools.Tests+{+    /// <summary>+    /// Tests for Grpc.Tools MSBuild .target and .props files.+    /// </summary>+    /// <remarks>+    /// The Grpc.Tools NuGet package is not tested directly, but instead the+    /// same .target and .props files are included in a MSBuild project and+    /// that project is built using ""dotnet build"" with the SDK installed on+    /// the test machine.+    /// <para>+    /// The real protoc compiler is not called. Instead a fake protoc script is+    /// called that does the minimum work needed for the build to succeed+    /// (generating cs files and writing dependencies file) and also writes out+    /// the arguments it was called with in a JSON file. The output is checked+    /// with expected results.+    /// </para>+    /// </remarks>+    [TestFixture]+    public class MsBuildIntegrationTest+    {+        private const string TASKS_ASSEMBLY_PROPERTY = ""_Protobuf_MsBuildAssembly"";","nit: The naming convention for constants in c# is  e.g. ""TasksAssemblyProperty"".",
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/31816,1049910796,2022-12-15T16:57:04Z,src/core/lib/event_engine/posix.h,"@@ -0,0 +1,159 @@+// Copyright 2022 gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+#ifndef GRPC_CORE_LIB_EVENT_ENGINE_POSIX_H+#define GRPC_CORE_LIB_EVENT_ENGINE_POSIX_H++#include <grpc/support/port_platform.h>++#include <functional>+#include <vector>++#include ""absl/functional/any_invocable.h""+#include ""absl/status/status.h""++#include <grpc/event_engine/endpoint_config.h>+#include <grpc/event_engine/event_engine.h>+#include <grpc/event_engine/memory_allocator.h>+#include <grpc/event_engine/port.h>+#include <grpc/event_engine/slice_buffer.h>++namespace grpc_event_engine {+namespace experimental {++#ifdef GRPC_EVENT_ENGINE_POSIX++/// This defines an EventEngine interface that posix specific event engines+/// may implement to support additional functionality.+class PosixEngine : public EventEngine {+ public:+  class PosixEventEngineEndpoint : public EventEngine::Endpoint {","The names are going to be confusing, for instance:```class PosixEventEngine : public PosixEngine {  class Endpoint : public PosixEngine::PosixEventEngineEndpoint {    ...  }}```Using these with an interface like `void DoAThing(PosixEngine::PosixEventEngineEndpoint* endpoint) { ...  }`, you're probably going to have to look it up to determine if it the argument is taking the interface or the implementation (`PosixEventEngine::Endpoint` is the implementation).I'd like to suggest an attribute-based alternative for these interfaces, not extending the base types, including strictly the added functionality. For instance:```// an Endpoint interfaceclass EndpointFdSupport {  virtual int GetWrappedFd() = 0;  /* ... */};class ListenerFdSupport {  virtual absl::StatusOr<int> BindWithFd(      const ResolvedAddress& addr,      OnPosixBindNewFdCallback on_bind_new_fd) = 0;    /* ... */};class EventEngineFdSupport {  virtual std::unique_ptr<PosixEventEngineEndpoint> CreatePosixEndpointFromFd(      int fd, const EndpointConfig& config,      MemoryAllocator memory_allocator) = 0;    /* ... */}```What we'll have then is something like:```class PosixEventEngine : public EventEngine, public EventEngineFdSupport {  class Endpoint : public EndpointFdSupport {};};```And usage would look like `void DoAThing(EndpointFdSupport* endpoint) { ... }`",X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/31819,1051079506,2022-12-16T19:17:24Z,test/core/client_channel/lb_policy/xds_override_host_test.cc,"@@ -81,30 +122,13 @@ TEST_F(XdsOverrideHostTest, NoConfigReportsError) { }  TEST_F(XdsOverrideHostTest, OverrideHost) {-  const std::array<absl::string_view, 2> kAddresses = {""ipv4:127.0.0.1:441"",-                                                       ""ipv4:127.0.0.1:442""};-  EXPECT_EQ(ApplyUpdate(BuildUpdate(kAddresses,-                                    MakeXdsOverrideHostConfig(""round_robin"")),-                        policy_.get()),-            absl::OkStatus());-  ExpectConnectingUpdate();-  // Ready up both subchannels-  for (auto address : kAddresses) {-    auto subchannel = FindSubchannel({address});-    ASSERT_NE(subchannel, nullptr);-    ASSERT_TRUE(subchannel->ConnectionRequested());-    subchannel->SetConnectivityState(GRPC_CHANNEL_CONNECTING);-    subchannel->SetConnectivityState(GRPC_CHANNEL_READY);-  }-  WaitForConnected();-  ExpectState(GRPC_CHANNEL_READY);-  auto picker = ExpectState(GRPC_CHANNEL_READY);+  // Send address list to LB policy.+  const std::array<absl::string_view, 3> kAddresses = {+      ""ipv4:127.0.0.1:441"", ""ipv4:127.0.0.1:442"", ""ipv4:127.0.0.1:443""};+  auto maybe_picker = InitRoundRobin(kAddresses);+  ASSERT_TRUE(maybe_picker.has_value());+  auto picker = *maybe_picker;   ASSERT_NE(picker, nullptr);","This assertion should probably move into `WaitForRoundRobinListChange()`, because we're already calling the picker in that function, so if it's null, we'd crash there.I think we should add the following in lb_policy_test.h at line 575:```EXPECT_NE(update.picker, nullptr);if (update.picker == nullptr) return false;```Once we do that, we no longer need the assertion here, because `WaitForRoundRobinListChange()` will guarantee that if it returns non-nullopt, the picker will never be null.Same thing in all of these tests.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/31819,1051083905,2022-12-16T19:23:44Z,test/core/client_channel/lb_policy/xds_override_host_test.cc,"@@ -116,58 +140,30 @@ TEST_F(XdsOverrideHostTest, OverrideHost) { }  TEST_F(XdsOverrideHostTest, OverrideHostSubchannelNotFound) {-  const std::array<absl::string_view, 2> kAddresses = {""ipv4:127.0.0.1:441"",-                                                       ""ipv4:127.0.0.1:442""};-  EXPECT_EQ(ApplyUpdate(BuildUpdate(kAddresses,-                                    MakeXdsOverrideHostConfig(""round_robin"")),-                        policy_.get()),-            absl::OkStatus());-  ExpectConnectingUpdate();-  // Ready up both subchannels-  for (auto address : kAddresses) {-    auto subchannel = FindSubchannel({address});-    ASSERT_NE(subchannel, nullptr);-    ASSERT_TRUE(subchannel->ConnectionRequested());-    subchannel->SetConnectivityState(GRPC_CHANNEL_CONNECTING);-    subchannel->SetConnectivityState(GRPC_CHANNEL_READY);-  }-  WaitForConnected();-  ExpectState(GRPC_CHANNEL_READY);-  auto picker = ExpectState(GRPC_CHANNEL_READY);+  // Send address list to LB policy.+  const std::array<absl::string_view, 3> kAddresses = {+      ""ipv4:127.0.0.1:441"", ""ipv4:127.0.0.1:442"", ""ipv4:127.0.0.1:443""};+  auto maybe_picker = InitRoundRobin(kAddresses);+  ASSERT_TRUE(maybe_picker.has_value());+  auto picker = *maybe_picker;   ASSERT_NE(picker, nullptr);-  // Make sure child policy works-  EXPECT_NE(ExpectPickComplete(picker.get()), ExpectPickComplete(picker.get()));-  // Check that the host is overridden   std::map<UniqueTypeName, std::string> call_attributes{       {XdsHostOverrideTypeName(), ""no such host""}};-  std::unordered_set<absl::optional<std::string>> picks{-      ExpectPickComplete(picker.get(), call_attributes),-      ExpectPickComplete(picker.get(), call_attributes)};+  std::unordered_set<std::string> picks;","Instead of doing this by hand, I suggest adding a `call_attributes` parameter to `ExpectRoundRobinPicks()` and then just use that method here.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/31819,1051093347,2022-12-16T19:36:29Z,test/core/client_channel/lb_policy/xds_override_host_test.cc,"@@ -86,6 +121,97 @@ TEST_F(XdsOverrideHostTest, NoConfigReportsError) {       absl::InvalidArgumentError(""Missing policy config"")); } +TEST_F(XdsOverrideHostTest, OverrideHost) {+  // Send address list to LB policy.+  const std::array<absl::string_view, 3> kAddresses = {+      ""ipv4:127.0.0.1:441"", ""ipv4:127.0.0.1:442"", ""ipv4:127.0.0.1:443""};+  auto maybe_picker = InitRoundRobin(kAddresses);+  ASSERT_TRUE(maybe_picker.has_value());+  auto picker = *maybe_picker;+  ASSERT_NE(picker, nullptr);+  // Check that the host is overridden+  std::map<UniqueTypeName, std::string> call_attributes{+      {XdsHostOverrideTypeName(), ""127.0.0.1:442""}};+  EXPECT_EQ(ExpectPickComplete(picker.get(), call_attributes), kAddresses[1]);+  EXPECT_EQ(ExpectPickComplete(picker.get(), call_attributes), kAddresses[1]);+  call_attributes[XdsHostOverrideTypeName()] = std::string(""127.0.0.1:441"");+  EXPECT_EQ(ExpectPickComplete(picker.get(), call_attributes), kAddresses[0]);+  EXPECT_EQ(ExpectPickComplete(picker.get(), call_attributes), kAddresses[0]);+}++TEST_F(XdsOverrideHostTest, OverrideHostSubchannelNotFound) {+  // Send address list to LB policy.+  const std::array<absl::string_view, 3> kAddresses = {+      ""ipv4:127.0.0.1:441"", ""ipv4:127.0.0.1:442"", ""ipv4:127.0.0.1:443""};+  auto maybe_picker = InitRoundRobin(kAddresses);+  ASSERT_TRUE(maybe_picker.has_value());+  auto picker = *maybe_picker;+  ASSERT_NE(picker, nullptr);+  std::map<UniqueTypeName, std::string> call_attributes{+      {XdsHostOverrideTypeName(), ""no such host""}};+  std::unordered_set<std::string> picks;+  for (size_t i = 0; i < kAddresses.size(); ++i) {+    auto pick = ExpectPickComplete(picker.get(), call_attributes);+    ASSERT_TRUE(pick.has_value());+    picks.emplace(*pick);+  }+  ASSERT_THAT(picks, UnorderedElementsAreArray(kAddresses));+}++TEST_F(XdsOverrideHostTest, SubchannelsComeAndGo) {+  const std::array<absl::string_view, 3> kAddresses = {+      ""ipv4:127.0.0.1:441"", ""ipv4:127.0.0.1:442"", ""ipv4:127.0.0.1:443""};+  auto maybe_picker = InitRoundRobin(kAddresses);+  ASSERT_TRUE(maybe_picker.has_value());+  auto picker = *maybe_picker;+  ASSERT_NE(picker, nullptr);+  // Make sure child policy works+  EXPECT_NE(ExpectPickComplete(picker.get()), ExpectPickComplete(picker.get()));+  // Check that the host is overridden+  std::map<UniqueTypeName, std::string> call_attributes{+      {XdsHostOverrideTypeName(), ""127.0.0.1:442""}};+  EXPECT_EQ(ExpectPickComplete(picker.get(), call_attributes), kAddresses[1]);+  EXPECT_EQ(ExpectPickComplete(picker.get(), call_attributes), kAddresses[1]);+  // Some other address is gone+  EXPECT_EQ(+      ApplyUpdate(BuildUpdate({""ipv4:127.0.0.1:441"", ""ipv4:127.0.0.1:442""},+                              MakeXdsOverrideHostConfig(""round_robin"")),+                  policy_.get()),+      absl::OkStatus());+  ExpectState(GRPC_CHANNEL_READY);",This is still (a) checking for individual state changes instead of checking only when we actually expect a behavior change and (b) getting a state change and not checking the resulting picker behavior.I think we should instead use `WaitForRoundRobinListChange()` here to wait for the LB policy to switch to the new address list.,
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/31819,1051094004,2022-12-16T19:36:59Z,test/core/client_channel/lb_policy/xds_override_host_test.cc,"@@ -86,6 +121,97 @@ TEST_F(XdsOverrideHostTest, NoConfigReportsError) {       absl::InvalidArgumentError(""Missing policy config"")); } +TEST_F(XdsOverrideHostTest, OverrideHost) {+  // Send address list to LB policy.+  const std::array<absl::string_view, 3> kAddresses = {+      ""ipv4:127.0.0.1:441"", ""ipv4:127.0.0.1:442"", ""ipv4:127.0.0.1:443""};+  auto maybe_picker = InitRoundRobin(kAddresses);+  ASSERT_TRUE(maybe_picker.has_value());+  auto picker = *maybe_picker;+  ASSERT_NE(picker, nullptr);+  // Check that the host is overridden+  std::map<UniqueTypeName, std::string> call_attributes{+      {XdsHostOverrideTypeName(), ""127.0.0.1:442""}};+  EXPECT_EQ(ExpectPickComplete(picker.get(), call_attributes), kAddresses[1]);+  EXPECT_EQ(ExpectPickComplete(picker.get(), call_attributes), kAddresses[1]);+  call_attributes[XdsHostOverrideTypeName()] = std::string(""127.0.0.1:441"");+  EXPECT_EQ(ExpectPickComplete(picker.get(), call_attributes), kAddresses[0]);+  EXPECT_EQ(ExpectPickComplete(picker.get(), call_attributes), kAddresses[0]);+}++TEST_F(XdsOverrideHostTest, OverrideHostSubchannelNotFound) {+  // Send address list to LB policy.+  const std::array<absl::string_view, 3> kAddresses = {+      ""ipv4:127.0.0.1:441"", ""ipv4:127.0.0.1:442"", ""ipv4:127.0.0.1:443""};+  auto maybe_picker = InitRoundRobin(kAddresses);+  ASSERT_TRUE(maybe_picker.has_value());+  auto picker = *maybe_picker;+  ASSERT_NE(picker, nullptr);+  std::map<UniqueTypeName, std::string> call_attributes{+      {XdsHostOverrideTypeName(), ""no such host""}};+  std::unordered_set<std::string> picks;+  for (size_t i = 0; i < kAddresses.size(); ++i) {+    auto pick = ExpectPickComplete(picker.get(), call_attributes);+    ASSERT_TRUE(pick.has_value());+    picks.emplace(*pick);+  }+  ASSERT_THAT(picks, UnorderedElementsAreArray(kAddresses));+}++TEST_F(XdsOverrideHostTest, SubchannelsComeAndGo) {+  const std::array<absl::string_view, 3> kAddresses = {+      ""ipv4:127.0.0.1:441"", ""ipv4:127.0.0.1:442"", ""ipv4:127.0.0.1:443""};+  auto maybe_picker = InitRoundRobin(kAddresses);+  ASSERT_TRUE(maybe_picker.has_value());+  auto picker = *maybe_picker;+  ASSERT_NE(picker, nullptr);+  // Make sure child policy works+  EXPECT_NE(ExpectPickComplete(picker.get()), ExpectPickComplete(picker.get()));+  // Check that the host is overridden+  std::map<UniqueTypeName, std::string> call_attributes{+      {XdsHostOverrideTypeName(), ""127.0.0.1:442""}};+  EXPECT_EQ(ExpectPickComplete(picker.get(), call_attributes), kAddresses[1]);+  EXPECT_EQ(ExpectPickComplete(picker.get(), call_attributes), kAddresses[1]);+  // Some other address is gone+  EXPECT_EQ(+      ApplyUpdate(BuildUpdate({""ipv4:127.0.0.1:441"", ""ipv4:127.0.0.1:442""},+                              MakeXdsOverrideHostConfig(""round_robin"")),+                  policy_.get()),+      absl::OkStatus());+  ExpectState(GRPC_CHANNEL_READY);+  picker = ExpectState(GRPC_CHANNEL_READY);+  ASSERT_NE(picker, nullptr);+  EXPECT_EQ(ExpectPickComplete(picker.get(), call_attributes), kAddresses[1]);+  EXPECT_EQ(ExpectPickComplete(picker.get(), call_attributes), kAddresses[1]);+  // ""Our"" address is gone+  EXPECT_EQ(+      ApplyUpdate(BuildUpdate({""ipv4:127.0.0.1:441"", ""ipv4:127.0.0.1:443""},+                              MakeXdsOverrideHostConfig(""round_robin"")),+                  policy_.get()),+      absl::OkStatus());+  ExpectState(GRPC_CHANNEL_READY);",Same here: Please use `WaitForRoundRobinListChange()` to wait for the policy to switch to the new address list.,
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/31819,1051095894,2022-12-16T19:38:24Z,test/core/client_channel/lb_policy/xds_override_host_test.cc,"@@ -86,6 +121,97 @@ TEST_F(XdsOverrideHostTest, NoConfigReportsError) {       absl::InvalidArgumentError(""Missing policy config"")); } +TEST_F(XdsOverrideHostTest, OverrideHost) {+  // Send address list to LB policy.+  const std::array<absl::string_view, 3> kAddresses = {+      ""ipv4:127.0.0.1:441"", ""ipv4:127.0.0.1:442"", ""ipv4:127.0.0.1:443""};+  auto maybe_picker = InitRoundRobin(kAddresses);+  ASSERT_TRUE(maybe_picker.has_value());+  auto picker = *maybe_picker;+  ASSERT_NE(picker, nullptr);+  // Check that the host is overridden+  std::map<UniqueTypeName, std::string> call_attributes{+      {XdsHostOverrideTypeName(), ""127.0.0.1:442""}};+  EXPECT_EQ(ExpectPickComplete(picker.get(), call_attributes), kAddresses[1]);+  EXPECT_EQ(ExpectPickComplete(picker.get(), call_attributes), kAddresses[1]);+  call_attributes[XdsHostOverrideTypeName()] = std::string(""127.0.0.1:441"");+  EXPECT_EQ(ExpectPickComplete(picker.get(), call_attributes), kAddresses[0]);+  EXPECT_EQ(ExpectPickComplete(picker.get(), call_attributes), kAddresses[0]);+}++TEST_F(XdsOverrideHostTest, OverrideHostSubchannelNotFound) {+  // Send address list to LB policy.+  const std::array<absl::string_view, 3> kAddresses = {+      ""ipv4:127.0.0.1:441"", ""ipv4:127.0.0.1:442"", ""ipv4:127.0.0.1:443""};+  auto maybe_picker = InitRoundRobin(kAddresses);+  ASSERT_TRUE(maybe_picker.has_value());+  auto picker = *maybe_picker;+  ASSERT_NE(picker, nullptr);+  std::map<UniqueTypeName, std::string> call_attributes{+      {XdsHostOverrideTypeName(), ""no such host""}};+  std::unordered_set<std::string> picks;+  for (size_t i = 0; i < kAddresses.size(); ++i) {+    auto pick = ExpectPickComplete(picker.get(), call_attributes);+    ASSERT_TRUE(pick.has_value());+    picks.emplace(*pick);+  }+  ASSERT_THAT(picks, UnorderedElementsAreArray(kAddresses));+}++TEST_F(XdsOverrideHostTest, SubchannelsComeAndGo) {+  const std::array<absl::string_view, 3> kAddresses = {+      ""ipv4:127.0.0.1:441"", ""ipv4:127.0.0.1:442"", ""ipv4:127.0.0.1:443""};+  auto maybe_picker = InitRoundRobin(kAddresses);+  ASSERT_TRUE(maybe_picker.has_value());+  auto picker = *maybe_picker;+  ASSERT_NE(picker, nullptr);+  // Make sure child policy works+  EXPECT_NE(ExpectPickComplete(picker.get()), ExpectPickComplete(picker.get()));+  // Check that the host is overridden+  std::map<UniqueTypeName, std::string> call_attributes{+      {XdsHostOverrideTypeName(), ""127.0.0.1:442""}};+  EXPECT_EQ(ExpectPickComplete(picker.get(), call_attributes), kAddresses[1]);+  EXPECT_EQ(ExpectPickComplete(picker.get(), call_attributes), kAddresses[1]);+  // Some other address is gone+  EXPECT_EQ(+      ApplyUpdate(BuildUpdate({""ipv4:127.0.0.1:441"", ""ipv4:127.0.0.1:442""},+                              MakeXdsOverrideHostConfig(""round_robin"")),+                  policy_.get()),+      absl::OkStatus());+  ExpectState(GRPC_CHANNEL_READY);+  picker = ExpectState(GRPC_CHANNEL_READY);+  ASSERT_NE(picker, nullptr);+  EXPECT_EQ(ExpectPickComplete(picker.get(), call_attributes), kAddresses[1]);+  EXPECT_EQ(ExpectPickComplete(picker.get(), call_attributes), kAddresses[1]);+  // ""Our"" address is gone+  EXPECT_EQ(+      ApplyUpdate(BuildUpdate({""ipv4:127.0.0.1:441"", ""ipv4:127.0.0.1:443""},+                              MakeXdsOverrideHostConfig(""round_robin"")),+                  policy_.get()),+      absl::OkStatus());+  ExpectState(GRPC_CHANNEL_READY);+  picker = ExpectState(GRPC_CHANNEL_READY);+  ExpectQueueEmpty();+  ASSERT_NE(picker, nullptr);+  std::array<absl::optional<std::string>, 2> picks = {",Similar comment as on line 152 above: This should just call `ExpectRoundRobinPicks()` with a `call_attributes` parameter.,
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/31819,1051096677,2022-12-16T19:39:00Z,test/core/client_channel/lb_policy/xds_override_host_test.cc,"@@ -86,6 +121,97 @@ TEST_F(XdsOverrideHostTest, NoConfigReportsError) {       absl::InvalidArgumentError(""Missing policy config"")); } +TEST_F(XdsOverrideHostTest, OverrideHost) {+  // Send address list to LB policy.+  const std::array<absl::string_view, 3> kAddresses = {+      ""ipv4:127.0.0.1:441"", ""ipv4:127.0.0.1:442"", ""ipv4:127.0.0.1:443""};+  auto maybe_picker = InitRoundRobin(kAddresses);+  ASSERT_TRUE(maybe_picker.has_value());+  auto picker = *maybe_picker;+  ASSERT_NE(picker, nullptr);+  // Check that the host is overridden+  std::map<UniqueTypeName, std::string> call_attributes{+      {XdsHostOverrideTypeName(), ""127.0.0.1:442""}};+  EXPECT_EQ(ExpectPickComplete(picker.get(), call_attributes), kAddresses[1]);+  EXPECT_EQ(ExpectPickComplete(picker.get(), call_attributes), kAddresses[1]);+  call_attributes[XdsHostOverrideTypeName()] = std::string(""127.0.0.1:441"");+  EXPECT_EQ(ExpectPickComplete(picker.get(), call_attributes), kAddresses[0]);+  EXPECT_EQ(ExpectPickComplete(picker.get(), call_attributes), kAddresses[0]);+}++TEST_F(XdsOverrideHostTest, OverrideHostSubchannelNotFound) {+  // Send address list to LB policy.+  const std::array<absl::string_view, 3> kAddresses = {+      ""ipv4:127.0.0.1:441"", ""ipv4:127.0.0.1:442"", ""ipv4:127.0.0.1:443""};+  auto maybe_picker = InitRoundRobin(kAddresses);+  ASSERT_TRUE(maybe_picker.has_value());+  auto picker = *maybe_picker;+  ASSERT_NE(picker, nullptr);+  std::map<UniqueTypeName, std::string> call_attributes{+      {XdsHostOverrideTypeName(), ""no such host""}};+  std::unordered_set<std::string> picks;+  for (size_t i = 0; i < kAddresses.size(); ++i) {+    auto pick = ExpectPickComplete(picker.get(), call_attributes);+    ASSERT_TRUE(pick.has_value());+    picks.emplace(*pick);+  }+  ASSERT_THAT(picks, UnorderedElementsAreArray(kAddresses));+}++TEST_F(XdsOverrideHostTest, SubchannelsComeAndGo) {+  const std::array<absl::string_view, 3> kAddresses = {+      ""ipv4:127.0.0.1:441"", ""ipv4:127.0.0.1:442"", ""ipv4:127.0.0.1:443""};+  auto maybe_picker = InitRoundRobin(kAddresses);+  ASSERT_TRUE(maybe_picker.has_value());+  auto picker = *maybe_picker;+  ASSERT_NE(picker, nullptr);+  // Make sure child policy works+  EXPECT_NE(ExpectPickComplete(picker.get()), ExpectPickComplete(picker.get()));+  // Check that the host is overridden+  std::map<UniqueTypeName, std::string> call_attributes{+      {XdsHostOverrideTypeName(), ""127.0.0.1:442""}};+  EXPECT_EQ(ExpectPickComplete(picker.get(), call_attributes), kAddresses[1]);+  EXPECT_EQ(ExpectPickComplete(picker.get(), call_attributes), kAddresses[1]);+  // Some other address is gone+  EXPECT_EQ(+      ApplyUpdate(BuildUpdate({""ipv4:127.0.0.1:441"", ""ipv4:127.0.0.1:442""},+                              MakeXdsOverrideHostConfig(""round_robin"")),+                  policy_.get()),+      absl::OkStatus());+  ExpectState(GRPC_CHANNEL_READY);+  picker = ExpectState(GRPC_CHANNEL_READY);+  ASSERT_NE(picker, nullptr);+  EXPECT_EQ(ExpectPickComplete(picker.get(), call_attributes), kAddresses[1]);+  EXPECT_EQ(ExpectPickComplete(picker.get(), call_attributes), kAddresses[1]);+  // ""Our"" address is gone+  EXPECT_EQ(+      ApplyUpdate(BuildUpdate({""ipv4:127.0.0.1:441"", ""ipv4:127.0.0.1:443""},+                              MakeXdsOverrideHostConfig(""round_robin"")),+                  policy_.get()),+      absl::OkStatus());+  ExpectState(GRPC_CHANNEL_READY);+  picker = ExpectState(GRPC_CHANNEL_READY);+  ExpectQueueEmpty();+  ASSERT_NE(picker, nullptr);+  std::array<absl::optional<std::string>, 2> picks = {+      ExpectPickComplete(picker.get(), call_attributes),+      ExpectPickComplete(picker.get(), call_attributes)};+  EXPECT_THAT(picks, UnorderedElementsAreArray(+                         {""ipv4:127.0.0.1:441"", ""ipv4:127.0.0.1:443""}));+  // And now it is back+  EXPECT_EQ(+      ApplyUpdate(BuildUpdate({""ipv4:127.0.0.1:442"", ""ipv4:127.0.0.1:443""},+                              MakeXdsOverrideHostConfig(""round_robin"")),+                  policy_.get()),+      absl::OkStatus());+  ExpectState(GRPC_CHANNEL_READY);",Same as above: Please use `WaitForRoundRobinListChange()` to wait for the policy to switch to the new address list.,
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/31819,1051097093,2022-12-16T19:39:18Z,test/core/client_channel/lb_policy/xds_override_host_test.cc,"@@ -86,6 +121,97 @@ TEST_F(XdsOverrideHostTest, NoConfigReportsError) {       absl::InvalidArgumentError(""Missing policy config"")); } +TEST_F(XdsOverrideHostTest, OverrideHost) {+  // Send address list to LB policy.+  const std::array<absl::string_view, 3> kAddresses = {+      ""ipv4:127.0.0.1:441"", ""ipv4:127.0.0.1:442"", ""ipv4:127.0.0.1:443""};+  auto maybe_picker = InitRoundRobin(kAddresses);+  ASSERT_TRUE(maybe_picker.has_value());+  auto picker = *maybe_picker;+  ASSERT_NE(picker, nullptr);+  // Check that the host is overridden+  std::map<UniqueTypeName, std::string> call_attributes{+      {XdsHostOverrideTypeName(), ""127.0.0.1:442""}};+  EXPECT_EQ(ExpectPickComplete(picker.get(), call_attributes), kAddresses[1]);+  EXPECT_EQ(ExpectPickComplete(picker.get(), call_attributes), kAddresses[1]);+  call_attributes[XdsHostOverrideTypeName()] = std::string(""127.0.0.1:441"");+  EXPECT_EQ(ExpectPickComplete(picker.get(), call_attributes), kAddresses[0]);+  EXPECT_EQ(ExpectPickComplete(picker.get(), call_attributes), kAddresses[0]);+}++TEST_F(XdsOverrideHostTest, OverrideHostSubchannelNotFound) {+  // Send address list to LB policy.+  const std::array<absl::string_view, 3> kAddresses = {+      ""ipv4:127.0.0.1:441"", ""ipv4:127.0.0.1:442"", ""ipv4:127.0.0.1:443""};+  auto maybe_picker = InitRoundRobin(kAddresses);+  ASSERT_TRUE(maybe_picker.has_value());+  auto picker = *maybe_picker;+  ASSERT_NE(picker, nullptr);+  std::map<UniqueTypeName, std::string> call_attributes{+      {XdsHostOverrideTypeName(), ""no such host""}};+  std::unordered_set<std::string> picks;+  for (size_t i = 0; i < kAddresses.size(); ++i) {+    auto pick = ExpectPickComplete(picker.get(), call_attributes);+    ASSERT_TRUE(pick.has_value());+    picks.emplace(*pick);+  }+  ASSERT_THAT(picks, UnorderedElementsAreArray(kAddresses));+}++TEST_F(XdsOverrideHostTest, SubchannelsComeAndGo) {+  const std::array<absl::string_view, 3> kAddresses = {+      ""ipv4:127.0.0.1:441"", ""ipv4:127.0.0.1:442"", ""ipv4:127.0.0.1:443""};+  auto maybe_picker = InitRoundRobin(kAddresses);+  ASSERT_TRUE(maybe_picker.has_value());+  auto picker = *maybe_picker;+  ASSERT_NE(picker, nullptr);+  // Make sure child policy works+  EXPECT_NE(ExpectPickComplete(picker.get()), ExpectPickComplete(picker.get()));+  // Check that the host is overridden+  std::map<UniqueTypeName, std::string> call_attributes{+      {XdsHostOverrideTypeName(), ""127.0.0.1:442""}};+  EXPECT_EQ(ExpectPickComplete(picker.get(), call_attributes), kAddresses[1]);+  EXPECT_EQ(ExpectPickComplete(picker.get(), call_attributes), kAddresses[1]);+  // Some other address is gone+  EXPECT_EQ(+      ApplyUpdate(BuildUpdate({""ipv4:127.0.0.1:441"", ""ipv4:127.0.0.1:442""},+                              MakeXdsOverrideHostConfig(""round_robin"")),+                  policy_.get()),+      absl::OkStatus());+  ExpectState(GRPC_CHANNEL_READY);+  picker = ExpectState(GRPC_CHANNEL_READY);+  ASSERT_NE(picker, nullptr);+  EXPECT_EQ(ExpectPickComplete(picker.get(), call_attributes), kAddresses[1]);+  EXPECT_EQ(ExpectPickComplete(picker.get(), call_attributes), kAddresses[1]);+  // ""Our"" address is gone+  EXPECT_EQ(+      ApplyUpdate(BuildUpdate({""ipv4:127.0.0.1:441"", ""ipv4:127.0.0.1:443""},+                              MakeXdsOverrideHostConfig(""round_robin"")),+                  policy_.get()),+      absl::OkStatus());+  ExpectState(GRPC_CHANNEL_READY);+  picker = ExpectState(GRPC_CHANNEL_READY);+  ExpectQueueEmpty();+  ASSERT_NE(picker, nullptr);+  std::array<absl::optional<std::string>, 2> picks = {+      ExpectPickComplete(picker.get(), call_attributes),+      ExpectPickComplete(picker.get(), call_attributes)};+  EXPECT_THAT(picks, UnorderedElementsAreArray(+                         {""ipv4:127.0.0.1:441"", ""ipv4:127.0.0.1:443""}));+  // And now it is back+  EXPECT_EQ(+      ApplyUpdate(BuildUpdate({""ipv4:127.0.0.1:442"", ""ipv4:127.0.0.1:443""},+                              MakeXdsOverrideHostConfig(""round_robin"")),+                  policy_.get()),+      absl::OkStatus());+  ExpectState(GRPC_CHANNEL_READY);+  picker = ExpectState(GRPC_CHANNEL_READY);+  ASSERT_NE(picker, nullptr);+  picks = {ExpectPickComplete(picker.get(), call_attributes),",Same as above: Please call `ExpectRoundRobinPicks()` with a `call_attributes` parameter.,
2793282,veblush,https://api.github.com/repos/grpc/grpc/pulls/31909,1051191596,2022-12-16T21:53:51Z,test/cpp/codegen/compiler_test_mock_golden,"@@ -2,6 +2,9 @@ // If you make any local change, they will be lost. // source: src/proto/grpc/testing/compiler_test.proto +#ifndef GRPC_MOCK_src_2fproto_2fgrpc_2ftesting_2fcompiler_5ftest_2eproto__INCLUDED","This is how grpc codegen does; `_2f` = `/`, `_5f` = `_`, and so on by https://github.com/grpc/grpc/blob/9e7c8bff5518cf86ab61210589b0bfca8cbc64c7/src/compiler/cpp_generator.cc#L42-L56",
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/24785,1052369194,2022-12-19T15:53:13Z,src/csharp/Grpc.Core/Internal/AsyncCallBase.cs,"@@ -351,7 +354,7 @@ protected void HandleReadFinished(bool success, IBufferReader receivedMessageRea                     readingDone = true;                      // TODO(jtattermusch): it might be too late to set the status-                    CancelWithStatus(DeserializeResponseFailureStatus);+                    CancelWithStatus(CreateDeserializeResponseFailureStatus(deserializeException));",I think this won't work since CancelWithStatus invokes C-core's native `call_cancel_with_status` which doesn't take the debug details as a parameter. So the debugException added to the status here will get lost.https://github.com/grpc/grpc/blob/af855eb64eea02d2f7b68d49c3d4d7a263649104/src/csharp/Grpc.Core/Internal/CallSafeHandle.cs#L225https://github.com/grpc/grpc/blob/af855eb64eea02d2f7b68d49c3d4d7a263649104/src/csharp/Grpc.Core/Internal/AsyncCallBase.cs#L101,
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/31819,1052414229,2022-12-19T16:37:50Z,test/core/client_channel/lb_policy/lb_policy_test_lib.h,"@@ -658,11 +659,16 @@ class LoadBalancingPolicyTest : public ::testing::Test {   // Gets num_picks complete picks from picker and returns the resulting   // list of addresses, or nullopt if a non-complete pick was returned.   absl::optional<std::vector<std::string>> GetCompletePicks(-      LoadBalancingPolicy::SubchannelPicker* picker, size_t num_picks,-      SourceLocation location = SourceLocation()) {+      LoadBalancingPolicy::SubchannelPicker* picker,+      const std::map<UniqueTypeName, std::string> call_attributes = {},+      size_t num_picks = 3, SourceLocation location = SourceLocation()) {","I think `num_picks` should not have a default value here, because there isn't really a default number of picks that will be appropriate in most circumstances.  The caller should be required to pass this parameter.",
1644595,gnossen,https://api.github.com/repos/grpc/grpc/pulls/31769,1052517721,2022-12-19T18:40:00Z,src/python/grpcio/grpc/__init__.py,"@@ -1160,7 +1205,8 @@ def send_initial_metadata(self, initial_metadata):         raise NotImplementedError()      @abc.abstractmethod-    def set_trailing_metadata(self, trailing_metadata):+    def set_trailing_metadata(+            self, trailing_metadata: Optional[MetadataType]) -> None:","This signature disagrees with [the actual implementation](https://github.com/grpc/grpc/blob/a5f1ac8d6a1fa33cd25759f5dbfa6c5348dec3f7/src/python/grpcio/grpc/_server.py#L344). And I think the internal implementation is right. As far as I can tell, calling this method with `None` should correctly remove any queued trailing metadata. Some people may be using this, so we don't want to get rid of it. Please update the internal implementation to also be `Optional`.But there's another issue here: This should have been caught by the type checker. We need to either get this PR in its current state to fail or come up with an explanation for why pytype is incapable of surfacing this issue. Then, we would need to figure out a way to supplement the type checker.With an input like [this](https://gist.github.com/gnossen/0f6f8d73864215831d9caed19618cfbc), I would would expect an error like this:```  Base signature: 'def A.foo(self, bar: Optional[int]) -> int'.  Subclass signature: 'def B.foo(self, bar: int) -> int'.  Type mismatch for parameter 'bar'.```",
1644595,gnossen,https://api.github.com/repos/grpc/grpc/pulls/31769,1052575812,2022-12-19T19:42:50Z,src/python/grpcio/grpc/__init__.py,"@@ -1148,7 +1192,8 @@ def set_compression(self, compression):         raise NotImplementedError()      @abc.abstractmethod-    def send_initial_metadata(self, initial_metadata):+    def send_initial_metadata(self,+                              initial_metadata: Optional[MetadataType]) -> None:         """"""Sends the initial metadata value to the client.","We should add the following sentence to the end of the docstring: ""If `None`, sends HTTP/2 status code and headers with no gRPC initial metadata.""",
1644595,gnossen,https://api.github.com/repos/grpc/grpc/pulls/31769,1052576547,2022-12-19T19:43:52Z,src/python/grpcio/grpc/__init__.py,"@@ -1160,7 +1205,8 @@ def send_initial_metadata(self, initial_metadata):         raise NotImplementedError()      @abc.abstractmethod-    def set_trailing_metadata(self, trailing_metadata):+    def set_trailing_metadata(+            self, trailing_metadata: Optional[MetadataType]) -> None:","We should add the following to the the docstring for the `trailing_metadata` argument: ""If `None`, will send no trailing metadata.""",
1644595,gnossen,https://api.github.com/repos/grpc/grpc/pulls/31769,1052617542,2022-12-19T20:40:13Z,src/python/grpcio/grpc/__init__.py,"@@ -1889,7 +1971,8 @@ def local_server_credentials(local_connect_type=LocalConnectionType.LOCAL_TCP):         _cygrpc.server_credentials_local(local_connect_type.value))  -def alts_channel_credentials(service_accounts=None):+def alts_channel_credentials(+        service_accounts: Optional[Sequence] = None) -> ChannelCredentials:",`Optional[Sequence[str]]` based on [this](https://github.com/grpc/grpc/blob/a5f1ac8d6a1fa33cd25759f5dbfa6c5348dec3f7/src/python/grpcio/grpc/_cython/_cygrpc/credentials.pyx.pxi#L401).,
1644595,gnossen,https://api.github.com/repos/grpc/grpc/pulls/31769,1052620984,2022-12-19T20:45:19Z,src/python/grpcio/grpc/_typing.py,"@@ -56,3 +61,7 @@     Callable[[Iterator[RequestType], 'ServicerContext'],              ResponseType], Callable[[Iterator[RequestType], 'ServicerContext'],                                      Iterator[ResponseType]]]+InterceptorsType = Union['UnaryUnaryClientInterceptor',","Nit: `InterceptorsType` -> `InterceptorType`. In a compound noun, the first word is always in the singular with the exception of a couple of irregular words.",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/31902,1052672368,2022-12-19T21:58:17Z,src/core/lib/surface/call.cc,"@@ -2880,6 +2885,7 @@ void ClientPromiseBasedCall::PublishStatus(         gpr_strdup(MakeErrorString(trailing_metadata.get()).c_str());   }   PublishMetadataArray(op_args.trailing_metadata, trailing_metadata.get());+  recv_status_on_client_ = absl::monostate();","Oh bug fix that it showed up... we call into this function if we're in a state where there's an outstanding `RECV_STATUS_ON_CLIENT` op, but we should only complete it once... so if a secondary finish condition shows up later we want to ensure we're back in a different state before that happens.",
57042389,tonydnewell,https://api.github.com/repos/grpc/grpc/pulls/24785,1053150546,2022-12-20T10:20:16Z,src/csharp/Grpc.Core/Internal/AsyncCallBase.cs,"@@ -351,7 +354,7 @@ protected void HandleReadFinished(bool success, IBufferReader receivedMessageRea                     readingDone = true;                      // TODO(jtattermusch): it might be too late to set the status-                    CancelWithStatus(DeserializeResponseFailureStatus);+                    CancelWithStatus(CreateDeserializeResponseFailureStatus(deserializeException));","We could append to the status.Detail (which is ""Failed to deserialize response message."") a string representation of the original exception. But how much? Full stack trace or just the name and message?",
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/31140,1053685352,2022-12-20T19:44:04Z,src/core/lib/event_engine/cf_engine/cf_engine.cc,"@@ -0,0 +1,140 @@+// Copyright 2022 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++#include <grpc/support/port_platform.h>++#ifdef GPR_APPLE++#include ""src/core/lib/event_engine/cf_engine/cf_engine.h""+#include ""src/core/lib/event_engine/posix_engine/timer_manager.h""+#include ""src/core/lib/event_engine/trace.h""+#include ""src/core/lib/event_engine/utils.h""++namespace grpc_event_engine {+namespace experimental {++class CFEventEngine::Closure final : public EventEngine::Closure {","nit: per the C++ style guide, you should either make this a `struct`, or a class with private members and appropriate setters/getters. See https://google.github.io/styleguide/cppguide.html#Structs_vs._Classes. I'd suggest keeping it a class, given this excerpt from the style guide:> The struct must not have invariants that imply relationships between different fields, since direct user access to those fields may break those invariants. Something like this could work:```class CFEventEngineClosure final : public EventEngine::Closure { public:  CFEventEngineClosure(absl::AnyInvocable<void()> cb, EventEngine* engine)      : cb_(std::move(cb)), engine_(engine) {}  const EventEngine::TaskHandle& handle() const { return handle_; }  void SetHandle(EventEngine::TaskHandle handle) { handle_ = handle; }  void Run() override {    GRPC_EVENT_ENGINE_TRACE(""CFEventEngine:%p executing callback:%s"", engine_,                            HandleToString(handle_).c_str());    {      grpc_core::MutexLock lock(&engine_->mu_);      engine_->known_handles_.erase(handle_);    }    cb_();    delete this;  } private:  absl::AnyInvocable<void()> cb_;  CFEventEngine* engine_;  EventEngine::TaskHandle handle_;};```",
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/31912,1053696822,2022-12-20T19:58:16Z,src/core/lib/iomgr/tcp_server_windows.cc,"@@ -522,16 +523,11 @@ static grpc_error_handle tcp_server_add_port(grpc_tcp_server* s, }  static void tcp_server_start(grpc_tcp_server* s,-                             const std::vector<grpc_pollset*>* /*pollsets*/,-                             grpc_tcp_server_cb on_accept_cb,-                             void* on_accept_cb_arg) {+                             const std::vector<grpc_pollset*>* /*pollsets*/) {   grpc_tcp_listener* sp;-  GPR_ASSERT(on_accept_cb);   gpr_mu_lock(&s->mu);-  GPR_ASSERT(!s->on_accept_cb);+  GPR_ASSERT(s->on_accept_cb);","This is an invariant now, right? How might we end up failing this check? If it were to fail, I think that means either A) `s` is an invalid `grpc_tcp_server*` in which case the lock above should fail first, or B) someone mucked with the member data manually, which they should not be doing.",
672669,sergiitk,https://api.github.com/repos/grpc/grpc/pulls/31569,1053728909,2022-12-20T20:39:45Z,tools/internal_ci/linux/grpc_xds_k8s_run_test.sh,"@@ -0,0 +1,96 @@+#!/usr/bin/env bash+# Copyright 2022 gRPC authors.+#+# Licensed under the Apache License, Version 2.0 (the ""License"");+# you may not use this file except in compliance with the License.+# You may obtain a copy of the License at+#+#     http://www.apache.org/licenses/LICENSE-2.0+#+# Unless required by applicable law or agreed to in writing, software+# distributed under the License is distributed on an ""AS IS"" BASIS,+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+# See the License for the specific language governing permissions and+# limitations under the License.++## xDS test server/client Docker images+readonly IMAGE_REPO=""gcr.io/grpc-testing/xds-interop""++find_latest() {+  gcloud container images list-tags --filter=tags\~v1\.\\d\\d\.x ""${IMAGE_REPO}/${1}-${2}"" '--format=table[no-heading](tags)' | awk -F, '{print $2}' | sort | tail -n 1+}++if [ ""${LATEST_BRANCH}"" == """" ]; then+  cpp_server=$(find_latest cpp server)+  cpp_client=$(find_latest cpp client)+  go_server=$(find_latest go server)+  go_client=$(find_latest go client)+  java_server=$(find_latest java server)+  java_client=$(find_latest java client)+  LATEST_BRANCH=""$((echo $cpp_server; echo $cpp_client; echo $go_server; echo $go_client; echo $java_server; echo $java_client;) | sort -g | head -1)""","You can use `shellcheck` command for linting:```shIn grpc_xds_k8s_run_test.sh line 30:  LATEST_BRANCH=""$((echo $cpp_server; echo $cpp_client; echo $go_server; echo $go_client; echo $java_server; echo $java_client;) | sort -g | head -1)""                 ^-- SC1102 (error): Shells disambiguate $(( differently or not at all. For $(command substitution), add space after $( . For $((arithmetics)), fix parsing errors.                         ^---------^ SC2086 (info): Double quote to prevent globbing and word splitting.                                           ^---------^ SC2086 (info): Double quote to prevent globbing and word splitting.                                                             ^--------^ SC2086 (info): Double quote to prevent globbing and word splitting.                                                                              ^--------^ SC2086 (info): Double quote to prevent globbing and word splitting.                                                                                               ^----------^ SC2086 (info): Double quote to prevent globbing and word splitting.                                                                                                                  ^----------^ SC2086 (info): Double quote to prevent globbing and word splitting.Did you mean:  LATEST_BRANCH=""$((echo ""$cpp_server""; echo ""$cpp_client""; echo ""$go_server""; echo ""$go_client""; echo ""$java_server""; echo ""$java_client"";) | sort -g | head -1)""```",
672669,sergiitk,https://api.github.com/repos/grpc/grpc/pulls/31569,1053730348,2022-12-20T20:41:52Z,tools/internal_ci/linux/grpc_xds_k8s_run_test.sh,"@@ -0,0 +1,96 @@+#!/usr/bin/env bash+# Copyright 2022 gRPC authors.+#+# Licensed under the Apache License, Version 2.0 (the ""License"");+# you may not use this file except in compliance with the License.+# You may obtain a copy of the License at+#+#     http://www.apache.org/licenses/LICENSE-2.0+#+# Unless required by applicable law or agreed to in writing, software+# distributed under the License is distributed on an ""AS IS"" BASIS,+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+# See the License for the specific language governing permissions and+# limitations under the License.++## xDS test server/client Docker images+readonly IMAGE_REPO=""gcr.io/grpc-testing/xds-interop""++find_latest() {+  gcloud container images list-tags --filter=tags\~v1\.\\d\\d\.x ""${IMAGE_REPO}/${1}-${2}"" '--format=table[no-heading](tags)' | awk -F, '{print $2}' | sort | tail -n 1+}++if [ ""${LATEST_BRANCH}"" == """" ]; then+  cpp_server=$(find_latest cpp server)+  cpp_client=$(find_latest cpp client)+  go_server=$(find_latest go server)+  go_client=$(find_latest go client)+  java_server=$(find_latest java server)+  java_client=$(find_latest java client)+  LATEST_BRANCH=""$((echo $cpp_server; echo $cpp_client; echo $go_server; echo $go_client; echo $java_server; echo $java_client;) | sort -g | head -1)""+fi++if [ ""${OLDEST_BRANCH}"" == """" ]; then+  OLDEST_BRANCH=""v1.$(expr $(echo ${LATEST_BRANCH} | cut -f 2 -d.) - 9).x""","Shellcheck also complains about this:```shIn grpc_xds_k8s_run_test.sh line 34:  OLDEST_BRANCH=""v1.$(expr $(echo ${LATEST_BRANCH} | cut -f 2 -d.) - 9).x""                      ^--^ SC2003 (style): expr is antiquated. Consider rewriting this using $((..)), ${} or [[ ]].                           ^-- SC2046 (warning): Quote this to prevent word splitting.                                  ^--------------^ SC2086 (info): Double quote to prevent globbing and word splitting.Did you mean:  OLDEST_BRANCH=""v1.$(expr $(echo ""${LATEST_BRANCH}"" | cut -f 2 -d.) - 9).x""```",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/31819,1053805664,2022-12-20T22:23:00Z,test/core/client_channel/lb_policy/lb_policy_test_lib.h,"@@ -658,11 +659,16 @@ class LoadBalancingPolicyTest : public ::testing::Test {   // Gets num_picks complete picks from picker and returns the resulting   // list of addresses, or nullopt if a non-complete pick was returned.   absl::optional<std::vector<std::string>> GetCompletePicks(-      LoadBalancingPolicy::SubchannelPicker* picker, size_t num_picks,-      SourceLocation location = SourceLocation()) {+      LoadBalancingPolicy::SubchannelPicker* picker,+      const std::map<UniqueTypeName, std::string> call_attributes = {},+      size_t num_picks = 3, SourceLocation location = SourceLocation()) {","Instead of dropping the default for `call_attributes`, just reorder the parameters so that `num_picks` is before `call_attributes`.I've done this in https://github.com/eugeneo/grpc/pull/1.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/31819,1053807319,2022-12-20T22:26:07Z,test/core/client_channel/lb_policy/xds_override_host_test.cc,"@@ -86,6 +121,97 @@ TEST_F(XdsOverrideHostTest, NoConfigReportsError) {       absl::InvalidArgumentError(""Missing policy config"")); } +TEST_F(XdsOverrideHostTest, OverrideHost) {+  // Send address list to LB policy.+  const std::array<absl::string_view, 3> kAddresses = {+      ""ipv4:127.0.0.1:441"", ""ipv4:127.0.0.1:442"", ""ipv4:127.0.0.1:443""};+  auto maybe_picker = InitRoundRobin(kAddresses);+  ASSERT_TRUE(maybe_picker.has_value());+  auto picker = *maybe_picker;+  ASSERT_NE(picker, nullptr);+  // Check that the host is overridden+  std::map<UniqueTypeName, std::string> call_attributes{+      {XdsHostOverrideTypeName(), ""127.0.0.1:442""}};+  EXPECT_EQ(ExpectPickComplete(picker.get(), call_attributes), kAddresses[1]);+  EXPECT_EQ(ExpectPickComplete(picker.get(), call_attributes), kAddresses[1]);+  call_attributes[XdsHostOverrideTypeName()] = std::string(""127.0.0.1:441"");+  EXPECT_EQ(ExpectPickComplete(picker.get(), call_attributes), kAddresses[0]);+  EXPECT_EQ(ExpectPickComplete(picker.get(), call_attributes), kAddresses[0]);+}++TEST_F(XdsOverrideHostTest, OverrideHostSubchannelNotFound) {+  // Send address list to LB policy.+  const std::array<absl::string_view, 3> kAddresses = {+      ""ipv4:127.0.0.1:441"", ""ipv4:127.0.0.1:442"", ""ipv4:127.0.0.1:443""};+  auto maybe_picker = InitRoundRobin(kAddresses);+  ASSERT_TRUE(maybe_picker.has_value());+  auto picker = *maybe_picker;+  ASSERT_NE(picker, nullptr);+  std::map<UniqueTypeName, std::string> call_attributes{+      {XdsHostOverrideTypeName(), ""no such host""}};+  std::unordered_set<std::string> picks;+  for (size_t i = 0; i < kAddresses.size(); ++i) {+    auto pick = ExpectPickComplete(picker.get(), call_attributes);+    ASSERT_TRUE(pick.has_value());+    picks.emplace(*pick);+  }+  ASSERT_THAT(picks, UnorderedElementsAreArray(kAddresses));+}++TEST_F(XdsOverrideHostTest, SubchannelsComeAndGo) {+  const std::array<absl::string_view, 3> kAddresses = {+      ""ipv4:127.0.0.1:441"", ""ipv4:127.0.0.1:442"", ""ipv4:127.0.0.1:443""};+  auto maybe_picker = InitRoundRobin(kAddresses);+  ASSERT_TRUE(maybe_picker.has_value());+  auto picker = *maybe_picker;+  ASSERT_NE(picker, nullptr);+  // Make sure child policy works+  EXPECT_NE(ExpectPickComplete(picker.get()), ExpectPickComplete(picker.get()));+  // Check that the host is overridden+  std::map<UniqueTypeName, std::string> call_attributes{+      {XdsHostOverrideTypeName(), ""127.0.0.1:442""}};+  EXPECT_EQ(ExpectPickComplete(picker.get(), call_attributes), kAddresses[1]);+  EXPECT_EQ(ExpectPickComplete(picker.get(), call_attributes), kAddresses[1]);+  // Some other address is gone+  EXPECT_EQ(+      ApplyUpdate(BuildUpdate({""ipv4:127.0.0.1:441"", ""ipv4:127.0.0.1:442""},+                              MakeXdsOverrideHostConfig(""round_robin"")),+                  policy_.get()),+      absl::OkStatus());+  ExpectState(GRPC_CHANNEL_READY);","It looks like there were two problems here.1. There was a bug in RR causing it to generate spurious picker updates whenever it swapped out the subchannel list.  I've fixed this in #31939.2. The purpose of calling `WaitForRoundRobinListChange()` here is to ensure that the LB policy has actually swapped over to the new address list.  You can't check that by using the call attributes here, because then you're forcing the picker to return a specific address instead of checking that it's returning the new list of addresses that we're looking for.  Instead, you need to first call `WaitForRoundRobinListChange()` to check for the new list without the call attributes, and then use the call attributes to make sure they're working as expected.  I've made this change in https://github.com/eugeneo/grpc/pull/1.",
28025951,HannahShiSFB,https://api.github.com/repos/grpc/grpc/pulls/31140,1053845332,2022-12-20T23:35:23Z,src/core/lib/event_engine/cf_engine/cf_engine.cc,"@@ -0,0 +1,140 @@+// Copyright 2022 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++#include <grpc/support/port_platform.h>++#ifdef GPR_APPLE++#include ""src/core/lib/event_engine/cf_engine/cf_engine.h""+#include ""src/core/lib/event_engine/posix_engine/timer_manager.h""+#include ""src/core/lib/event_engine/trace.h""+#include ""src/core/lib/event_engine/utils.h""++namespace grpc_event_engine {+namespace experimental {++class CFEventEngine::Closure final : public EventEngine::Closure {",Will change it to struct as fields are used by EventEngine class. This is also how posix engine and windows engine do.,
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/31831,1053900217,2022-12-21T01:43:11Z,include/grpc/event_engine/internal/slice_cast.h,"@@ -0,0 +1,55 @@+// Copyright 2022 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++#ifndef GRPC_EVENT_ENGINE_INTERNAL_SLICE_CAST_H+#define GRPC_EVENT_ENGINE_INTERNAL_SLICE_CAST_H++namespace grpc_event_engine {+namespace experimental {+namespace internal {++// Opt-in trait class for slice conversions.+// Declare a specialization of this class for any types that are compatible+// with `SliceCast`. Both ways need to be declared (i.e. if+// ConstRefSliceCastable<A,B> exists, you should declare+// ConstRefSliceCastable<B,A> too).+// The type has no members, it's just the existance of the specialization that+// unlocks SliceCast usage for a type pair.+template <typename Result, typename T>+struct ConstRefSliceCastable;++// This is strictly too wide, but consider all types to be SliceCast-able to+// themselves.+// Unfortunately this allows `const int& x = SliceCast<int>(x);` which is kind+// of bogus.+template <typename A>+struct ConstRefSliceCastable<A, A> {};++// Cast to `const Result&` from `const T&` without any runtime checks.+// This is only valid if `sizeof(Result) == sizeof(T)`, and if `Result`, `T` are+// opted in as compatible via `ConstRefSliceCastable`.+template <typename Result, typename T>+const Result& SliceCast(const T& value, ConstRefSliceCastable<Result, T> = {}) {","Regarding constness, we _may_ need to cast it away for things like EventEngine::Read implementations, but more likely I think we'll have a const thing with mutable underlying data (so ... logically not const). I'm not sure if const is going to be meaningful in the cases I've worked with, but it may be the wisest default.",
5663878,yijiem,https://api.github.com/repos/grpc/grpc/pulls/31942,1053928781,2022-12-21T02:49:40Z,src/core/ext/transport/chttp2/server/chttp2_server.cc,"@@ -407,29 +410,33 @@ void Chttp2ServerListener::ActiveConnection::HandshakingState::Start(                              OnHandshakeDone, this); } -void Chttp2ServerListener::ActiveConnection::HandshakingState::OnTimeout(-    void* arg, grpc_error_handle error) {-  HandshakingState* self = static_cast<HandshakingState*>(arg);-  // Note that we may be called with absl::OkStatus() when the timer fires-  // or with an error indicating that the timer system is being shut down.-  if (error != absl::CancelledError()) {+void Chttp2ServerListener::ActiveConnection::HandshakingState::OnTimeout() {+  grpc_chttp2_transport* transport = nullptr;+  {+    MutexLock lock(&connection_->mu_);+    if (timer_handle_.has_value()) {+      transport = connection_->transport_;+      timer_handle_.reset();+    }+  }+  if (transport) {     grpc_transport_op* op = grpc_make_transport_op(nullptr);     op->disconnect_with_error = GRPC_ERROR_CREATE(         ""Did not receive HTTP/2 settings before handshake timeout"");-    grpc_chttp2_transport* transport = nullptr;-    {-      MutexLock lock(&self->connection_->mu_);-      transport = self->connection_->transport_;-    }     grpc_transport_perform_op(&transport->base, op);   }-  self->Unref(); }  void Chttp2ServerListener::ActiveConnection::HandshakingState::     OnReceiveSettings(void* arg, grpc_error_handle /* error */) {","In reality, it seems like `OnReceiveSettings` will be called when closing the transport (e.g. when read failed): https://github.com/grpc/grpc/blob/a5f1ac8d6a1fa33cd25759f5dbfa6c5348dec3f7/src/core/ext/transport/chttp2/transport/chttp2_transport.cc#L624So I may guess that in most cases this timer is cancelled before shutdown.",
11522026,ralphchung,https://api.github.com/repos/grpc/grpc/pulls/31959,1055090046,2022-12-22T04:48:21Z,include/grpc/event_engine/internal/slice_cast.h,"@@ -22,32 +22,44 @@ namespace internal { // Opt-in trait class for slice conversions. // Declare a specialization of this class for any types that are compatible // with `SliceCast`. Both ways need to be declared (i.e. if-// ConstRefSliceCastable<A,B> exists, you should declare-// ConstRefSliceCastable<B,A> too).+// SliceCastable<A,B> exists, you should declare+// SliceCastable<B,A> too). // The type has no members, it's just the existance of the specialization that // unlocks SliceCast usage for a type pair. template <typename Result, typename T>-struct ConstRefSliceCastable;+struct SliceCastable;  // This is strictly too wide, but consider all types to be SliceCast-able to // themselves. // Unfortunately this allows `const int& x = SliceCast<int>(x);` which is kind // of bogus. template <typename A>-struct ConstRefSliceCastable<A, A> {};+struct SliceCastable<A, A> {};  // Cast to `const Result&` from `const T&` without any runtime checks. // This is only valid if `sizeof(Result) == sizeof(T)`, and if `Result`, `T` are-// opted in as compatible via `ConstRefSliceCastable`.+// opted in as compatible via `SliceCastable`. template <typename Result, typename T>-const Result& SliceCast(const T& value, ConstRefSliceCastable<Result, T> = {}) {+const Result& SliceCast(const T& value, SliceCastable<Result, T> = {}) {","I have a interface question. Intuitively I would expect some similar usage as the C++ builtin casts. That makes it `SliceCast<Slice&>(a_grpc_slice)` or `SliceCast<const grpc_slice&>(a_Slice)`, which means the word between `<` and `>` is the return type name. Would that be possible in this case? And is there other purpose of designing this way?",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/31914,1055629287,2022-12-22T16:22:00Z,src/core/ext/filters/client_channel/lb_policy/xds/xds_override_host.cc,"@@ -229,15 +266,49 @@ XdsOverrideHostLb::Picker::Picker(   } } +/*+    // No READY subchannel found.  If we found an IDLE subchannel,+    // trigger a connection attempt and queue the pick until that attempt+    // completes.+    if idle_subchannel is not None:+      hop into control plane to trigger connection attempt for idle_subchannel+      return queue as pick result+*/++absl::optional<LoadBalancingPolicy::PickResult>+XdsOverrideHostLb::PickOverridenHost(absl::string_view address) {+  if (address.length() == 0) {+    return absl::nullopt;+  }+  MutexLock lock(&subchannel_map_mu_);+  auto it = subchannel_map_.find(address);+  if (it == subchannel_map_.end()) {+    return absl::nullopt;+  }+  auto subchannel = it->second.GetSubchannel();+  if (subchannel == nullptr) {+    return absl::nullopt;+  }+  auto connectivity_state = subchannel->connectivity_state();+  if (connectivity_state == GRPC_CHANNEL_READY) {+    return PickResult::Complete(subchannel->wrapped_subchannel());+  } else if (connectivity_state == GRPC_CHANNEL_CONNECTING) {+    return PickResult::Queue();+  } else if (connectivity_state == GRPC_CHANNEL_IDLE) {+    work_serializer()->Run([&]() { subchannel->RequestConnection(); },","When you call `WorkSerializer::Run()`, one of two things will happen:1. If some other thread is currently executing code in the `WorkSerializer`, it will add the callback to the queue to be executed by that other thread, and `Run()` will return without executing the callback.2. If no other thread is currently executing code in the `WorkSerializer`, it will run the callback inline before returning from `Run()`.  Note that if any other threads call `Run()` while this thread is running the callback, then this thread will wind up executing additional callbacks from those other threads before returning from `Run()`.This means that we need to be prepared to handle both cases here.In case 1, the callback we want to run here will be run asynchronously, which means that the callback needs to hold a ref to anything that it needs to access, to ensure that those objects are still alive when it actually runs.  In this case, that means we need to hold a ref to the subchannel.  It also means that using `&` in the lambda capture isn't a good idea, since it's likely that none of the local state will still be in scope when the callback runs.In case 2, we need to be prepared for the fact that we might wind up running callbacks from other threads before `Run()` returns.  However, this code is running in the picker, which means it's performance-sensitive, so we don't really want to run arbitrary control-plane code inline here, since that will increase RPC latency.  Also, the client channel code currently holds a data plane mutex while invoking the picker, and it's possible that one of the callbacks running in the `WorkSerializer` could cause the LB policy to return a new picker to the channel, which would require acquiring the data plane mutex -- and since we're already holding that mutex, that would cause a deadlock.  To address these problems, we need to first do an async hop via `ExecCtx::Run()` before we call `WorkSerializer::Run()`.  (Eventually, we will change this kind of code to use `EventEngine::Run()` instead of `ExecCtx::Run()`, but for now let's stick with the existing pattern.)To address all of the above, I think we need to use an approach similar to what the ring_hash policy does here:https://github.com/grpc/grpc/blob/531287b2ee0b71a2919c328a35a7ca06221b7697/src/core/ext/filters/client_channel/lb_policy/ring_hash/ring_hash.cc#L267This case will be slightly different than the ring_hash case in that we can take a ref to the individual subchannel instead of taking a ref to the subchannel list.  And we'll also need to take our own ref to the `WorkSerializer`.  But the overall approach is the same.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/31914,1055637323,2022-12-22T16:30:45Z,src/core/ext/filters/client_channel/lb_policy/xds/xds_override_host.cc,"@@ -229,15 +266,49 @@ XdsOverrideHostLb::Picker::Picker(   } } +/*+    // No READY subchannel found.  If we found an IDLE subchannel,+    // trigger a connection attempt and queue the pick until that attempt+    // completes.+    if idle_subchannel is not None:+      hop into control plane to trigger connection attempt for idle_subchannel+      return queue as pick result+*/++absl::optional<LoadBalancingPolicy::PickResult>+XdsOverrideHostLb::PickOverridenHost(absl::string_view address) {","I think this should be a method of the picker, not in the LB policy itself, since it's data plane code.",X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/31914,1055675427,2022-12-22T17:12:59Z,src/core/BUILD,"@@ -4460,6 +4460,7 @@ grpc_cc_library(     language = ""c++"",     deps = [         ""channel_args"",+        ""grpc_lb_subchannel_list"",",This dependency should not be needed.  Only leaf policies need to use the subchannel_list library.,
287917,eugeneo,https://api.github.com/repos/grpc/grpc/pulls/31914,1055758277,2022-12-22T18:47:00Z,test/core/client_channel/lb_policy/lb_policy_test_lib.h,"@@ -702,6 +709,7 @@ class LoadBalancingPolicyTest : public ::testing::Test {       absl::Span<const absl::string_view> addresses,       const std::map<UniqueTypeName, std::string> call_attributes = {},       size_t num_iterations = 3, SourceLocation location = SourceLocation()) {+    ASSERT_NE(picker, nullptr);",I think it is ok to have duplicate check. There are some tests that call `ExpectRoundRobinPicks` directly.,
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/31366,1055838764,2022-12-22T20:49:25Z,test/distrib/bazel/test_single_bazel_version.sh,"@@ -51,12 +51,16 @@ FAILED_TESTS="""" export OVERRIDE_BAZEL_VERSION=""$VERSION"" # when running under bazel docker image, the workspace is read only. export OVERRIDE_BAZEL_WRAPPER_DOWNLOAD_DIR=/tmp-bazel build -- //... ""${EXCLUDED_TARGETS[@]}"" || FAILED_TESTS=""${FAILED_TESTS}Build ""++ACTION_ENV_FLAG=""--action_env=bazel_cache_invalidate=version_${VERSION}""++tools/bazel build ""${ACTION_ENV_FLAG}"" -- //... ""${EXCLUDED_TARGETS[@]}"" || FAILED_TESTS=""${FAILED_TESTS}Build ""","qq: are the spaces in `FAILED_TESTS=""${FAILED_TESTS}Build ""`  and `FAILED_TESTS=""${FAILED_TESTS}${TEST_DIRECTORY} Distribtest""` (line 63) where we want them? Seems that the pattern is different so I just wanted to doublecheck.",
133680,sampajano,https://api.github.com/repos/grpc/grpc/pulls/31140,1055919606,2022-12-22T23:09:07Z,src/core/lib/event_engine/cf_engine/cf_engine.cc,"@@ -0,0 +1,139 @@+// Copyright 2022 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++#include <grpc/support/port_platform.h>++#ifdef GPR_APPLE++#include ""src/core/lib/event_engine/cf_engine/cf_engine.h""+#include ""src/core/lib/event_engine/posix_engine/timer_manager.h""+#include ""src/core/lib/event_engine/trace.h""+#include ""src/core/lib/event_engine/utils.h""++namespace grpc_event_engine {+namespace experimental {++struct CFEventEngine::Closure final : public EventEngine::Closure {+  absl::AnyInvocable<void()> cb;+  Timer timer;+  CFEventEngine* engine;+  EventEngine::TaskHandle handle;++  void Run() override {+    GRPC_EVENT_ENGINE_TRACE(""CFEventEngine:%p executing callback:%s"", engine,+                            HandleToString(handle).c_str());+    {+      grpc_core::MutexLock lock(&engine->mu_);+      engine->known_handles_.erase(handle);+    }+    cb();+    delete this;+  }+};++CFEventEngine::CFEventEngine()+    : executor_(std::make_shared<ThreadPool>()), timer_manager_(executor_) {}++CFEventEngine::~CFEventEngine() {+  {+    grpc_core::MutexLock lock(&mu_);+    if (GRPC_TRACE_FLAG_ENABLED(grpc_event_engine_trace)) {+      for (auto handle : known_handles_) {+        gpr_log(GPR_ERROR,+                ""WindowsEventEngine:%p uncleared TaskHandle at shutdown:%s"",+                this, HandleToString(handle).c_str());+      }+    }+    GPR_ASSERT(GPR_LIKELY(known_handles_.empty()));+    timer_manager_.Shutdown();+  }+  executor_->Quiesce();+}++absl::StatusOr<std::unique_ptr<EventEngine::Listener>>+CFEventEngine::CreateListener(+    Listener::AcceptCallback on_accept,+    absl::AnyInvocable<void(absl::Status)> on_shutdown,+    const EndpointConfig& config,+    std::unique_ptr<MemoryAllocatorFactory> memory_allocator_factory) {+  GPR_ASSERT(false && ""unimplemented"");","just curious -- since i saw you added a CF EE test, i wonder if those tests are supposed to pass when a lot of this class is not implemented?",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/31971,1055919964,2022-12-22T23:09:55Z,test/core/client_channel/lb_policy/lb_policy_test_lib.h,"@@ -160,10 +160,33 @@ class LoadBalancingPolicyTest : public ::testing::Test {      const std::string& address() const { return address_; } +    void AssertValidConnectivityStateTransition(+        grpc_connectivity_state to_state, grpc_connectivity_state from_state,","Suggest swapping the order of these two parameters, since that seems a little more intuitive (old state followed by new state).",X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/31971,1055921819,2022-12-22T23:14:26Z,test/core/client_channel/lb_policy/lb_policy_test_lib.h,"@@ -160,10 +160,33 @@ class LoadBalancingPolicyTest : public ::testing::Test {      const std::string& address() const { return address_; } +    void AssertValidConnectivityStateTransition(+        grpc_connectivity_state to_state, grpc_connectivity_state from_state,+        SourceLocation location = SourceLocation()) {+      const std::map<grpc_connectivity_state,","Suggest writing this more simply, without the need for complex data structures:```switch (from_state) {  case GRPC_CHANNEL_IDLE:    ASSERT_EQ(new_state, GRPC_CHANNEL_CONNECTING)        << location.file() << "":"" << location.line();    break;  case GRPC_CHANNEL_CONNECTING:    ASSERT_THAT(new_state, ::testing::Eq(::testing::AnyOf(        GRPC_CHANNEL_READY,        GRPC_CHANNEL_TRANSIENT_FAILURE)))        << location.file() << "":"" << location.line();    break;  case GRPC_CHANNEL_READY:    ASSERT_EQ(new_state, GRPC_CHANNEL_IDLE)        << location.file() << "":"" << location.line();    break;  case GRPC_CHANNEL_TRANSIENT_FAILURE:    ASSERT_EQ(new_state, GRPC_CHANNEL_IDLE)        << location.file() << "":"" << location.line();    break;  default:    break;}```",X
24593237,XuanWang-Amos,https://api.github.com/repos/grpc/grpc/pulls/31769,1058605325,2022-12-28T21:28:16Z,src/python/grpcio/grpc/__init__.py,"@@ -392,7 +412,7 @@ def code(self):         raise NotImplementedError()      @abc.abstractmethod-    def details(self):+    def details(self) -> Optional[str]:","For return it make sense, `decode` returns `str` is still valid for `Optional[str]`, but for the input, `Anystr` shouldn't allow `None`.I tested using the following code, looks like Pytype is not able to detect this issue:```def decode(b: AnyStr) -> Optional[str]:    if isinstance(b, bytes):        return b.decode('utf-8', 'replace')    return bclass _RPCState(object):    details: Optional[str]    def __init__(self, details: Optional[str]):        self.details = decode(details)state = _RPCState(None) # No complain heredecode(None) # Pytype complains```",
24593237,XuanWang-Amos,https://api.github.com/repos/grpc/grpc/pulls/31769,1058613432,2022-12-28T21:41:18Z,src/python/grpcio/grpc/__init__.py,"@@ -616,7 +646,8 @@ def __call__(self, metadata, error): class AuthMetadataPlugin(abc.ABC):     """"""A specification for custom authentication."""""" -    def __call__(self, context, callback):+    def __call__(self, contex: AuthMetadataContext,","Nice catch, I think this class was only used in `metadata_call_credentials` method and it only appears in examples and some interop tests, maybe they're not triggered in CI?",
24593237,XuanWang-Amos,https://api.github.com/repos/grpc/grpc/pulls/31769,1058620537,2022-12-28T21:51:56Z,src/python/grpcio/grpc/__init__.py,"@@ -664,12 +695,12 @@ class UnaryUnaryMultiCallable(abc.ABC): ",`certificate_configuration` is created by `server_certificate_config_ssl` and it's a core class `ServerCertificateConfig`:https://github.com/grpc/grpc/blob/2d4f3c56001cd1e1f85734b2f7c5ce5f2797c38a/src/python/grpcio/grpc/_cython/_cygrpc/credentials.pyx.pxi#L283Let me see if I can use that here...,
24593237,XuanWang-Amos,https://api.github.com/repos/grpc/grpc/pulls/31769,1058622470,2022-12-28T21:56:33Z,src/python/grpcio/grpc/__init__.py,"@@ -801,12 +833,12 @@ class StreamUnaryMultiCallable(abc.ABC):      @abc.abstractmethod     def __call__(self,-                 request_iterator,-                 timeout=None,-                 metadata=None,-                 credentials=None,-                 wait_for_ready=None,-                 compression=None):+                 request_iterator: Iterable,","oops I missed, will change here and all similar places to use `RequestIterable`.",
24593237,XuanWang-Amos,https://api.github.com/repos/grpc/grpc/pulls/31769,1058626809,2022-12-28T22:13:08Z,src/python/grpcio/grpc/__init__.py,"@@ -1160,7 +1205,8 @@ def send_initial_metadata(self, initial_metadata):         raise NotImplementedError()      @abc.abstractmethod-    def set_trailing_metadata(self, trailing_metadata):+    def set_trailing_metadata(+            self, trailing_metadata: Optional[MetadataType]) -> None:","Agree that type checker should caught this issue, but looks like the following code can pass both Pytype and Typeguard:```@typecheckedclass A(metaclass=abc.ABCMeta):    @abc.abstractmethod    def foo(self, bar: int) -> None:        raise NotImplementedError()@typecheckedclass B(A):    def foo(self, bar: Optional[int]) -> None:        returnb = B()print(b.foo(123))```My guess is both will just assumes the override method is correct, but the reason behind it needs investigate.",
24593237,XuanWang-Amos,https://api.github.com/repos/grpc/grpc/pulls/31769,1058632210,2022-12-28T22:34:45Z,src/python/grpcio/grpc/__init__.py,"@@ -1260,7 +1306,7 @@ def code(self):         """"""         raise NotImplementedError() -    def details(self):+    def details(self) -> str:","Did more testing use the following code:```@typecheckedclass A(metaclass=abc.ABCMeta):    def foo(self) -> str:        raise NotImplementedError()@typecheckedclass B(A):    def foo(self) -> bytes:        return b'bytes'@typecheckeddef bar(s: str) -> None:    returnb = B()bar(b.foo())```This time Typeguard complains input should be str instead of bytes, looks like it thinks the override method is correct.For some reason Pytype still passed ",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/31914,1060988830,2023-01-03T21:58:40Z,test/core/client_channel/lb_policy/lb_policy_test_lib.h,"@@ -702,6 +709,7 @@ class LoadBalancingPolicyTest : public ::testing::Test {       absl::Span<const absl::string_view> addresses,       const std::map<UniqueTypeName, std::string> call_attributes = {},       size_t num_iterations = 3, SourceLocation location = SourceLocation()) {+    ASSERT_NE(picker, nullptr);","We are calling `GetCompletePicks()` on the next line, and it will do exactly this check, so any code that calls `ExpectRoundRobinPicks()` will already get the right behavior.  I don't understand what benefit we get from this duplicate check.",
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/31785,1061048427,2023-01-04T00:11:56Z,src/core/lib/event_engine/tcp_socket_utils.cc,"@@ -111,36 +111,13 @@ absl::StatusOr<std::string> ResolvedAddrToUnixPathIfPossible(  absl::StatusOr<std::string> ResolvedAddrToUriUnixIfPossible(     const EventEngine::ResolvedAddress* resolved_addr) {-  const sockaddr* addr = resolved_addr->address();-  if (addr->sa_family != AF_UNIX) {-    return absl::InvalidArgumentError(-        absl::StrCat(""Socket family is not AF_UNIX: "", addr->sa_family));-  }-  const sockaddr_un* unix_addr = reinterpret_cast<const sockaddr_un*>(addr);-#ifdef GPR_APPLE-  int len = resolved_addr->size() - sizeof(unix_addr->sun_family) --            sizeof(unix_addr->sun_len) - 1;-#else-  int len = resolved_addr->size() - sizeof(unix_addr->sun_family) - 1;-#endif-  bool abstract = (len < 0 || unix_addr->sun_path[0] == '\0');-  std::string scheme;-  std::string path;-  if (abstract) {-    scheme = ""unix-abstract"";-    if (len >= 0) {-      path = std::string(unix_addr->sun_path + 1, len);-    }-  } else {-    scheme = ""unix"";-    size_t maxlen = sizeof(unix_addr->sun_path);-    if (strnlen(unix_addr->sun_path, maxlen) == maxlen) {-      return absl::InvalidArgumentError(""UDS path is not null-terminated"");-    }-    path = unix_addr->sun_path;-  }+  auto path = ResolvedAddrToUnixPathIfPossible(resolved_addr);+  GRPC_RETURN_IF_ERROR(path.status());+  std::string scheme = path->rfind('\0', 0) == 0 ? ""unix-abstract"" : ""unix"";","this can be simplified to `path->at(0) == '\0'`. See https://godbolt.org/z/9G5jGWTEz. Regarding bounds-checking, I think other bits of this function would fail if path were an empty string.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/31985,1061811367,2023-01-04T19:22:10Z,src/core/ext/filters/client_channel/lb_policy/xds/xds_override_host.cc,"@@ -153,9 +163,10 @@ class XdsOverrideHostLb : public LoadBalancingPolicy {      private:       std::unique_ptr<ConnectivityStateWatcherInterface> delegate_;       RefCountedPtr<SubchannelWrapper> subchannel_;+      XdsHealthStatus health_status_{XdsHealthStatus::kUnknown};","I don't think this data member is in the right object.  This `ConnectivityStateWatcher` class is for watching the subchannel's connectivity state, but from the perspective of this LB policy, the EDS health state is orthogonal to the subchannel's connectivity state.Also, note that we need to change `GetSubchannelByAddress()` to look at this field to decide whether the picker should use the override host.  If the override host's status is not present in the status mask from the config, then the picker needs to ignore the override host.I think this should be a field in the `SubchannelEntry` class instead.  The only place it will get set is from `UpdateLocked()`, where we are already updating the map, so we should just set this value at the same time.  And it needs to be accessible to the picker, which will be looking at the same map.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/31985,1061814823,2023-01-04T19:27:01Z,src/core/ext/filters/client_channel/lb_policy/xds/xds_override_host.cc,"@@ -460,30 +492,60 @@ OrphanablePtr<LoadBalancingPolicy> XdsOverrideHostLb::CreateChildPolicyLocked(   return lb_policy; } -void XdsOverrideHostLb::UpdateAddressMap(-    const absl::StatusOr<ServerAddressList>& addresses) {-  std::unordered_set<std::string> keys(addresses->size());+XdsHealthStatus XdsOverrideHostLb::AddressHealthStatus(","This does not actually need to be a method of `XdsOverrideHostLb`, since it doesn't access any of the data members.  It can just be a standalone function (which will be local to this file, since this code is already inside of an anonymous namespace).",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/31985,1061825074,2023-01-04T19:41:21Z,src/core/ext/filters/client_channel/lb_policy/xds/xds_override_host.cc,"@@ -621,18 +683,34 @@ const JsonLoaderInterface* XdsOverrideHostLbConfig::JsonLoader(  void XdsOverrideHostLbConfig::JsonPostLoad(const Json& json, const JsonArgs&,                                            ValidationErrors* errors) {-  ValidationErrors::ScopedField field(errors, "".childPolicy"");-  auto it = json.object_value().find(""childPolicy"");-  if (it == json.object_value().end()) {-    errors->AddError(""field not present"");-  } else {-    auto child_policy_config =-        CoreConfiguration::Get().lb_policy_registry().ParseLoadBalancingConfig(-            it->second);-    if (!child_policy_config.ok()) {-      errors->AddError(child_policy_config.status().message());+  {+    ValidationErrors::ScopedField field(errors, "".childPolicy"");+    auto it = json.object_value().find(""childPolicy"");+    if (it == json.object_value().end()) {+      errors->AddError(""field not present"");     } else {-      child_config_ = std::move(*child_policy_config);+      auto child_policy_config = CoreConfiguration::Get()+                                     .lb_policy_registry()+                                     .ParseLoadBalancingConfig(it->second);+      if (!child_policy_config.ok()) {+        errors->AddError(child_policy_config.status().message());+      } else {+        child_config_ = std::move(*child_policy_config);+      }+    }+  }+  {+    ValidationErrors::ScopedField field(errors, "".overrideHostStatus"");+    auto it = json.object_value().find(""overrideHostStatus"");","Instead of manually digging through the JSON fields, please use `LoadJsonObjectField()`, which will do a lot of the necessary validation for you (e.g., checking that the fields are the right JSON types):```auto host_status_list = LoadJsonObjectField<std::vector<std::string>>(    json.object_value(), args, ""overrideHostStatus"", errors,    /*required=*/false);if (host_status_list.has_value()) {  override_host_status_mask_ = 0;  for (size_t i = 0; i < host_status_list->size(); ++i) {    const std::string& host_status = (*host_status_list)[i];    auto status = XdsHealthStatus::FromString(value.string_value());    if (!status.has_value()) {      ValidationErrors::ScopedField field(          errors, absl::StrCat(""["", i, ""]""));      errors->AddError(""invalid host status"");    } else {      override_host_status_mask_ |= HealthStatusBitMask(*status);    }  }}```",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/31985,1061859007,2023-01-04T20:30:53Z,test/core/client_channel/lb_policy/xds_override_host_test.cc,"@@ -213,6 +253,92 @@ TEST_F(XdsOverrideHostTest, ConnectingSubchannelIsQueued) {   picker = ExpectState(GRPC_CHANNEL_READY);   ExpectPickQueued(picker.get(), pick_arg); }++TEST_F(XdsOverrideHostTest, DrainingState) {","This test looks really good!I think we also need a test similar to the `ConnectingSubchannelIsQueued` test above, but for DRAINING state.  We need to verify that we are still monitoring the subchannel's connectivity state even when the child has unreffed the subchannel and is not watching its connectivity state.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32019,1061998590,2023-01-05T00:40:11Z,test/core/util/test_lb_policies.cc,"@@ -746,6 +748,173 @@ class FailLbFactory : public LoadBalancingPolicyFactory {   std::atomic<int>* pick_counter_; }; +//+// QueueOnceLoadBalancingPolicy - a load balancing policy that provides a Queue+// PickResult atleast once, after which it delegates to PickFirst.+//++constexpr char kQueueOncePolicyName[] = ""queue_once"";++class QueueOnceLoadBalancingPolicy : public ForwardingLoadBalancingPolicy {+ public:+  QueueOnceLoadBalancingPolicy(Args args)+      : ForwardingLoadBalancingPolicy(+            std::make_unique<Helper>(+                RefCountedPtr<QueueOnceLoadBalancingPolicy>(this)),+            std::move(args), ""pick_first"",+            /*initial_refcount=*/2) {}++  ~QueueOnceLoadBalancingPolicy() override = default;++  absl::string_view name() const override { return kQueueOncePolicyName; }++ private:+  class Helper;++  // An always queueing picker+  class QueueingPicker : public SubchannelPicker {+   public:+    QueueingPicker(Helper* helper) : helper_(helper) {}","I don't think this is safe.  The helper's lifetime is basically tied to the LB policy's lifetime, but the picker could outlive the LB policy.In general, I don't think the helper is the right place to store the state that you need to access from this picker.  The only purpose of the helper is to provide a way for the child policy to interact with the parent policy, so these interactions between the parent and its own picker don't really belong in the helper.I think this state should instead be stored in the LB policy itself, and the picker should hold a ref to the LB policy.Note that one option here would be that instead of writing your own queue picker, you just use the standard one provided by the LB policy library:https://github.com/grpc/grpc/blob/06a9fbd3822e33e30fb62c5fc201f13886ede3f4/src/core/lib/load_balancing/lb_policy.h#L381When that picker sees the first pick, it will hop into the `WorkSerializer` and invoke the LB policy's `ExitIdleLocked()` method, so you could use that method to trigger the subsequent picker update.Alternatively, you can create your own queuing picker, but it should work analogously to the standard one: the hop into the `WorkSerializer` should be handled in the picker, and it should invoke a method on the LB policy.  It can hold a ref to the LB policy for this, which it will pass to the `WorkSerializer` callback.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32019,1062015188,2023-01-05T01:19:58Z,test/core/util/test_lb_policies.cc,"@@ -746,6 +748,173 @@ class FailLbFactory : public LoadBalancingPolicyFactory {   std::atomic<int>* pick_counter_; }; +//+// QueueOnceLoadBalancingPolicy - a load balancing policy that provides a Queue+// PickResult atleast once, after which it delegates to PickFirst.+//++constexpr char kQueueOncePolicyName[] = ""queue_once"";++class QueueOnceLoadBalancingPolicy : public ForwardingLoadBalancingPolicy {+ public:+  QueueOnceLoadBalancingPolicy(Args args)+      : ForwardingLoadBalancingPolicy(+            std::make_unique<Helper>(+                RefCountedPtr<QueueOnceLoadBalancingPolicy>(this)),+            std::move(args), ""pick_first"",+            /*initial_refcount=*/2) {}++  ~QueueOnceLoadBalancingPolicy() override = default;++  absl::string_view name() const override { return kQueueOncePolicyName; }++ private:+  class Helper;++  // An always queueing picker+  class QueueingPicker : public SubchannelPicker {+   public:+    QueueingPicker(Helper* helper) : helper_(helper) {}++    PickResult Pick(PickArgs /*args*/) override;++   private:+    Helper* helper_;+  };++  class DelegatingPicker : public SubchannelPicker {+   public:+    DelegatingPicker(RefCountedPtr<SubchannelPicker> delegate_picker)+        : delegate_picker_(std::move(delegate_picker)) {}++    PickResult Pick(PickArgs args) override {+      return delegate_picker_->Pick(args);+    }++   private:+    RefCountedPtr<SubchannelPicker> delegate_picker_;+  };++  class Helper : public ChannelControlHelper {+   public:+    Helper(RefCountedPtr<QueueOnceLoadBalancingPolicy> parent)+        : parent_(std::move(parent)) {}++    RefCountedPtr<SubchannelInterface> CreateSubchannel(+        ServerAddress address, const ChannelArgs& args) override {+      return parent_->channel_control_helper()->CreateSubchannel(+          std::move(address), args);+    }++    void UpdateState(grpc_connectivity_state state, const absl::Status& status,+                     RefCountedPtr<SubchannelPicker> picker) override {+      bool pick_queued;+      {+        MutexLock lock(&mu_);+        pick_queued = pick_queued_;+        // If a pick has not been queued yet, we need to save the update from+        // PickFirst to propagate later.+        if (!pick_queued) {+          state_to_update_ = {state, status, std::move(picker)};+        }+      }+      if (!pick_queued) {+        return parent_->channel_control_helper()->UpdateState(+            GRPC_CHANNEL_CONNECTING, absl::OkStatus(),+            MakeRefCounted<QueueingPicker>(this));+      }+      parent_->channel_control_helper()->UpdateState(+          state, status, MakeRefCounted<DelegatingPicker>(std::move(picker)));+    }++    void RequestReresolution() override {+      parent_->channel_control_helper()->RequestReresolution();+    }++    absl::string_view GetAuthority() override {+      return parent_->channel_control_helper()->GetAuthority();+    }++    grpc_event_engine::experimental::EventEngine* GetEventEngine() override {+      return parent_->channel_control_helper()->GetEventEngine();+    }++    void AddTraceEvent(TraceSeverity severity,+                       absl::string_view message) override {+      parent_->channel_control_helper()->AddTraceEvent(severity, message);+    }++    void SetPickQueued() {+      MutexLock lock(&mu_);+      pick_queued_ = true;+      if (state_to_update_.has_value()) {+        // Propagate the update from PickFirst but do not do it inline to avoid+        // deadlocks.+        parent_->work_serializer()->Schedule(+            [helper = parent_->channel_control_helper(),","This is a little unsafe, because you're not holding ownership of the helper here.  I think it probably works out okay in practice, because you're holding a ref to the LB policy (which owns the helper) in the `ExecCtx` callback below, but I'd prefer not to see this pattern in our code.As mentioned above, I think the picker should just hop into the `WorkSerializer` to invoke a method on the LB policy, and that callback should hold a ref to the LB policy, so it's explicitly safe.",
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/31813,1062833385,2023-01-05T19:43:01Z,src/core/ext/transport/chttp2/transport/chttp2_transport.cc,"@@ -2379,18 +2379,16 @@ static void read_action_locked(void* tp, grpc_error_handle error) {   }   std::swap(err, error);   if (t->closed_with_error.ok()) {-    size_t i = 0;     grpc_error_handle errors[3] = {error, absl::OkStatus(), absl::OkStatus()};-    for (; i < t->read_buffer.count && errors[1] == absl::OkStatus(); i++) {++    for (size_t i = 0; i < t->read_buffer.count && errors[1] == absl::OkStatus(); i++) {","It's possible to have an empty buffer. See test errors. Please revert this bit, and just remove the unused loop in this PR.",X
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/31140,1062861919,2023-01-05T20:19:20Z,test/core/event_engine/test_suite/cf_event_engine_test.cc,"@@ -0,0 +1,41 @@+// Copyright 2022 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+#include <grpc/grpc.h>++#include ""src/core/lib/event_engine/cf_engine/cf_engine.h""+#include ""test/core/event_engine/test_suite/event_engine_test.h""+#include ""test/core/util/test_config.h""++#ifdef GPR_APPLE++int main(int argc, char** argv) {+  testing::InitGoogleTest(&argc, argv);+  grpc::testing::TestEnvironment env(&argc, argv);+  auto factory = []() {+    return std::make_unique<grpc_event_engine::experimental::CFEventEngine>();+  };+  SetEventEngineFactories(factory, factory);","That should be documented better in test/core/event_engine/test_suite/README.md.The oracle is another EventEngine implementation used as a control for certain tests. For example, if you're implementing a custom engine on a system where the PosixEventEngine would also work, you can use the PosixEventEngine as an ""oracle"" to provide (for example) a stable listener implementation for client tests against your engine implementation. In your case, the oracle can be specified as the same implementation, it will effectively test your EventEngine implementation against itself.",
5564114,Vignesh2208,https://api.github.com/repos/grpc/grpc/pulls/31890,1063667353,2023-01-06T18:11:40Z,src/core/lib/event_engine/posix_engine/posix_endpoint.cc,"@@ -1168,20 +1168,29 @@ void PosixEndpointImpl::Write(   } } -void PosixEndpointImpl::MaybeShutdown(absl::Status why) {+void PosixEndpointImpl::MaybeShutdown(+    absl::Status why,+    absl::AnyInvocable<void(absl::StatusOr<int>)> on_release_fd) {",Which parameter are you referring to ? The on_release_fd callback is an any-invocable so it can only be moved. The absl::Status needs to be copied because it maybe provided to a callback executing on another thread and thus its easier to reason about its lifetime.  absl::Status is copied by value everywhere else in gRPC as well - primarily to easily reason about its lifetime I think.,
14166415,sanjaypujare,https://api.github.com/repos/grpc/grpc/pulls/31569,1063847140,2023-01-06T22:18:20Z,tools/internal_ci/linux/grpc_xds_k8s_run_test.sh,"@@ -0,0 +1,96 @@+#!/usr/bin/env bash+# Copyright 2022 gRPC authors.+#+# Licensed under the Apache License, Version 2.0 (the ""License"");+# you may not use this file except in compliance with the License.+# You may obtain a copy of the License at+#+#     http://www.apache.org/licenses/LICENSE-2.0+#+# Unless required by applicable law or agreed to in writing, software+# distributed under the License is distributed on an ""AS IS"" BASIS,+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+# See the License for the specific language governing permissions and+# limitations under the License.++## xDS test server/client Docker images+readonly IMAGE_REPO=""gcr.io/grpc-testing/xds-interop""++find_latest() {+  gcloud container images list-tags --filter=tags\~v1\.\\d\\d\.x ""${IMAGE_REPO}/${1}-${2}"" '--format=table[no-heading](tags)' | awk -F, '{print $2}' | sort | tail -n 1+}++if [ ""${LATEST_BRANCH}"" == """" ]; then+  cpp_server=$(find_latest cpp server)+  cpp_client=$(find_latest cpp client)+  go_server=$(find_latest go server)+  go_client=$(find_latest go client)+  java_server=$(find_latest java server)+  java_client=$(find_latest java client)+  LATEST_BRANCH=""$((echo $cpp_server; echo $cpp_client; echo $go_server; echo $go_client; echo $java_server; echo $java_client;) | sort -g | head -1)""","`echo ""${USER}\n${SHELL}""` is not guaranteed to work. But I think `echo -e ""${USER}\n${SHELL}""` would work. Some of these shell idiosyncrasies are weird and that's why I went with the most basic way that's not dependent on such quirks.",
133680,sampajano,https://api.github.com/repos/grpc/grpc/pulls/31140,1065142014,2023-01-09T21:54:22Z,src/core/lib/event_engine/cf_engine/cf_engine.cc,"@@ -0,0 +1,139 @@+// Copyright 2022 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++#include <grpc/support/port_platform.h>++#ifdef GPR_APPLE++#include ""src/core/lib/event_engine/cf_engine/cf_engine.h""+#include ""src/core/lib/event_engine/posix_engine/timer_manager.h""+#include ""src/core/lib/event_engine/trace.h""+#include ""src/core/lib/event_engine/utils.h""++namespace grpc_event_engine {+namespace experimental {++struct CFEventEngine::Closure final : public EventEngine::Closure {+  absl::AnyInvocable<void()> cb;+  Timer timer;+  CFEventEngine* engine;+  EventEngine::TaskHandle handle;++  void Run() override {+    GRPC_EVENT_ENGINE_TRACE(""CFEventEngine:%p executing callback:%s"", engine,+                            HandleToString(handle).c_str());+    {+      grpc_core::MutexLock lock(&engine->mu_);+      engine->known_handles_.erase(handle);+    }+    cb();+    delete this;+  }+};++CFEventEngine::CFEventEngine()+    : executor_(std::make_shared<ThreadPool>()), timer_manager_(executor_) {}++CFEventEngine::~CFEventEngine() {+  {+    grpc_core::MutexLock lock(&mu_);+    if (GRPC_TRACE_FLAG_ENABLED(grpc_event_engine_trace)) {+      for (auto handle : known_handles_) {+        gpr_log(GPR_ERROR,+                ""WindowsEventEngine:%p uncleared TaskHandle at shutdown:%s"",+                this, HandleToString(handle).c_str());+      }+    }+    GPR_ASSERT(GPR_LIKELY(known_handles_.empty()));+    timer_manager_.Shutdown();+  }+  executor_->Quiesce();+}++absl::StatusOr<std::unique_ptr<EventEngine::Listener>>+CFEventEngine::CreateListener(+    Listener::AcceptCallback on_accept,+    absl::AnyInvocable<void(absl::Status)> on_shutdown,+    const EndpointConfig& config,+    std::unique_ptr<MemoryAllocatorFactory> memory_allocator_factory) {+  GPR_ASSERT(false && ""unimplemented"");+}++CFEventEngine::ConnectionHandle CFEventEngine::Connect(+    OnConnectCallback on_connect, const ResolvedAddress& addr,+    const EndpointConfig& args, MemoryAllocator memory_allocator,+    Duration timeout) {+  GPR_ASSERT(false && ""unimplemented"");+}++bool CFEventEngine::CancelConnect(ConnectionHandle handle) {+  GPR_ASSERT(false && ""unimplemented"");+}++bool CFEventEngine::IsWorkerThread() { GPR_ASSERT(false && ""unimplemented""); }++std::unique_ptr<EventEngine::DNSResolver> CFEventEngine::GetDNSResolver(+    const DNSResolver::ResolverOptions& options) {+  GPR_ASSERT(false && ""unimplemented"");+}++void CFEventEngine::Run(EventEngine::Closure* closure) {+  GPR_ASSERT(false && ""unimplemented"");+}++void CFEventEngine::Run(absl::AnyInvocable<void()> closure) {+  GPR_ASSERT(false && ""unimplemented"");+}++EventEngine::TaskHandle CFEventEngine::RunAfter(Duration when,+                                                EventEngine::Closure* closure) {+  return RunAfterInternal(when, [closure]() { closure->Run(); });+}++EventEngine::TaskHandle CFEventEngine::RunAfter(+    Duration when, absl::AnyInvocable<void()> closure) {+  return RunAfterInternal(when, std::move(closure));+}++bool CFEventEngine::Cancel(TaskHandle handle) {+  grpc_core::MutexLock lock(&mu_);+  if (!known_handles_.contains(handle)) return false;+  auto* cd = reinterpret_cast<Closure*>(handle.keys[0]);+  bool r = timer_manager_.TimerCancel(&cd->timer);+  known_handles_.erase(handle);+  if (r) delete cd;+  return r;+}++EventEngine::TaskHandle CFEventEngine::RunAfterInternal(+    Duration when, absl::AnyInvocable<void()> cb) {+  auto when_ts = ToTimestamp(timer_manager_.Now(), when);+  auto* cd = new Closure;+  cd->cb = std::move(cb);+  cd->engine = this;+  EventEngine::TaskHandle handle{reinterpret_cast<intptr_t>(cd),+                                 aba_token_.fetch_add(1)};+  grpc_core::MutexLock lock(&mu_);+  known_handles_.insert(handle);+  cd->handle = handle;+  GRPC_EVENT_ENGINE_TRACE(""CFEventEngine:%p scheduling callback:%s"", this,+                          HandleToString(handle).c_str());+  timer_manager_.TimerInit(&cd->timer, when_ts, cd);+  return handle;+}","Ah ok. Could you maybe evaluate and offer your thoughts here?And if it's not worth to do it right now in this PR, we could submit as is. But keep it in mind as we add further code, and adopt code reuse if the amount of code warrants the additional complexity.Thanks!",
133680,sampajano,https://api.github.com/repos/grpc/grpc/pulls/31140,1065161624,2023-01-09T22:23:53Z,src/core/lib/event_engine/cf_engine/cf_engine.cc,"@@ -0,0 +1,139 @@+// Copyright 2022 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++#include <grpc/support/port_platform.h>++#ifdef GPR_APPLE++#include ""src/core/lib/event_engine/cf_engine/cf_engine.h""+#include ""src/core/lib/event_engine/posix_engine/timer_manager.h""+#include ""src/core/lib/event_engine/trace.h""+#include ""src/core/lib/event_engine/utils.h""++namespace grpc_event_engine {+namespace experimental {++struct CFEventEngine::Closure final : public EventEngine::Closure {+  absl::AnyInvocable<void()> cb;+  Timer timer;+  CFEventEngine* engine;+  EventEngine::TaskHandle handle;++  void Run() override {+    GRPC_EVENT_ENGINE_TRACE(""CFEventEngine:%p executing callback:%s"", engine,+                            HandleToString(handle).c_str());+    {+      grpc_core::MutexLock lock(&engine->mu_);+      engine->known_handles_.erase(handle);+    }+    cb();+    delete this;+  }+};++CFEventEngine::CFEventEngine()+    : executor_(std::make_shared<ThreadPool>()), timer_manager_(executor_) {}++CFEventEngine::~CFEventEngine() {+  {+    grpc_core::MutexLock lock(&mu_);+    if (GRPC_TRACE_FLAG_ENABLED(grpc_event_engine_trace)) {+      for (auto handle : known_handles_) {+        gpr_log(GPR_ERROR,+                ""WindowsEventEngine:%p uncleared TaskHandle at shutdown:%s"",+                this, HandleToString(handle).c_str());+      }+    }+    GPR_ASSERT(GPR_LIKELY(known_handles_.empty()));+    timer_manager_.Shutdown();+  }+  executor_->Quiesce();+}++absl::StatusOr<std::unique_ptr<EventEngine::Listener>>+CFEventEngine::CreateListener(+    Listener::AcceptCallback on_accept,+    absl::AnyInvocable<void(absl::Status)> on_shutdown,+    const EndpointConfig& config,+    std::unique_ptr<MemoryAllocatorFactory> memory_allocator_factory) {+  GPR_ASSERT(false && ""unimplemented"");+}++CFEventEngine::ConnectionHandle CFEventEngine::Connect(+    OnConnectCallback on_connect, const ResolvedAddress& addr,+    const EndpointConfig& args, MemoryAllocator memory_allocator,+    Duration timeout) {+  GPR_ASSERT(false && ""unimplemented"");+}++bool CFEventEngine::CancelConnect(ConnectionHandle handle) {+  GPR_ASSERT(false && ""unimplemented"");+}++bool CFEventEngine::IsWorkerThread() { GPR_ASSERT(false && ""unimplemented""); }++std::unique_ptr<EventEngine::DNSResolver> CFEventEngine::GetDNSResolver(+    const DNSResolver::ResolverOptions& options) {+  GPR_ASSERT(false && ""unimplemented"");+}++void CFEventEngine::Run(EventEngine::Closure* closure) {+  GPR_ASSERT(false && ""unimplemented"");+}++void CFEventEngine::Run(absl::AnyInvocable<void()> closure) {+  GPR_ASSERT(false && ""unimplemented"");+}++EventEngine::TaskHandle CFEventEngine::RunAfter(Duration when,+                                                EventEngine::Closure* closure) {+  return RunAfterInternal(when, [closure]() { closure->Run(); });+}++EventEngine::TaskHandle CFEventEngine::RunAfter(+    Duration when, absl::AnyInvocable<void()> closure) {+  return RunAfterInternal(when, std::move(closure));+}++bool CFEventEngine::Cancel(TaskHandle handle) {+  grpc_core::MutexLock lock(&mu_);+  if (!known_handles_.contains(handle)) return false;+  auto* cd = reinterpret_cast<Closure*>(handle.keys[0]);+  bool r = timer_manager_.TimerCancel(&cd->timer);+  known_handles_.erase(handle);+  if (r) delete cd;+  return r;+}++EventEngine::TaskHandle CFEventEngine::RunAfterInternal(+    Duration when, absl::AnyInvocable<void()> cb) {+  auto when_ts = ToTimestamp(timer_manager_.Now(), when);+  auto* cd = new Closure;+  cd->cb = std::move(cb);+  cd->engine = this;+  EventEngine::TaskHandle handle{reinterpret_cast<intptr_t>(cd),+                                 aba_token_.fetch_add(1)};+  grpc_core::MutexLock lock(&mu_);+  known_handles_.insert(handle);+  cd->handle = handle;+  GRPC_EVENT_ENGINE_TRACE(""CFEventEngine:%p scheduling callback:%s"", this,+                          HandleToString(handle).c_str());+  timer_manager_.TimerInit(&cd->timer, when_ts, cd);+  return handle;+}","Discussed offline. Timer is the only place where there's potential to reuse, but not the other components. So it's probably not worth the additional complexity.",
287917,eugeneo,https://api.github.com/repos/grpc/grpc/pulls/32069,1066454133,2023-01-10T23:55:19Z,src/core/ext/filters/client_channel/resolver/xds/xds_resolver.cc,"@@ -443,8 +443,8 @@ XdsResolver::XdsConfigSelector::XdsConfigSelector(   // weighted_cluster_state field points to the memory in the route field, so   // moving the entry in a reallocation will cause the string_view to point to   // invalid data.-  route_table_.reserve(resolver_->current_virtual_host_.routes.size());-  for (auto& route : resolver_->current_virtual_host_.routes) {+  route_table_.reserve(resolver_->current_virtual_host_->routes.size());",nit: I am slightly uncomfortable with the fact that current_virtual_host_ that may be unset to be unreferenced unconditionally.,
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32069,1066470053,2023-01-11T00:32:37Z,src/core/ext/filters/client_channel/resolver/xds/xds_resolver.cc,"@@ -443,8 +443,8 @@ XdsResolver::XdsConfigSelector::XdsConfigSelector(   // weighted_cluster_state field points to the memory in the route field, so   // moving the entry in a reallocation will cause the string_view to point to   // invalid data.-  route_table_.reserve(resolver_->current_virtual_host_.routes.size());-  for (auto& route : resolver_->current_virtual_host_.routes) {+  route_table_.reserve(resolver_->current_virtual_host_->routes.size());","Yeah, I agree.  In general, I prefer to handle this kind of thing by passing the value in by parameter, but the existing code here already has the `XdsConfigSelector` ctor reaching into a lot of the resolver's internal state, and some of those operations are writes, not just reads.  So in this particular case, there's already a bunch of shared logic between the two objects, so there's not much point in trying to pretend otherwise.",X
1644595,gnossen,https://api.github.com/repos/grpc/grpc/pulls/32030,1066479668,2023-01-11T00:54:30Z,src/python/grpcio/grpc/_server.py,"@@ -662,6 +666,8 @@ def send_response(response: Any) -> None:                 if proceed:                     _send_message_callback_to_blocking_iterator_adapter(                         rpc_event, state, send_response, response_iterator)+    except Exception:  # pylint: disable=broad-except+        traceback.print_exception(*sys.exc_info())",Maybe [`traceback.print_exc()`](https://docs.python.org/3/library/traceback.html#traceback.print_exc),
1644595,gnossen,https://api.github.com/repos/grpc/grpc/pulls/32059,1066488258,2023-01-11T01:15:09Z,src/python/grpcio/grpc/_cython/_cygrpc/aio/server.pyx.pxi,"@@ -716,14 +716,17 @@ async def _handle_exceptions(RPCState rpc_state, object rpc_coro, object loop):                 status_code = rpc_state.status_code              rpc_state.status_sent = True-            await _send_error_status_from_server(-                rpc_state,-                status_code,-                'Unexpected %s: %s' % (type(e), e),-                rpc_state.trailing_metadata,-                rpc_state.create_send_initial_metadata_op_if_not_sent(),-                loop-            )+            try:+                await _send_error_status_from_server(+                    rpc_state,+                    status_code,+                    'Unexpected %s: %s' % (type(e), e),+                    rpc_state.trailing_metadata,+                    rpc_state.create_send_initial_metadata_op_if_not_sent(),+                    loop+                )+            except ExecuteBatchError:+                _LOGGER.exception('Failed sending error status from server')","Please also log the contents of the exception, including the full stack trace.",
1644595,gnossen,https://api.github.com/repos/grpc/grpc/pulls/32059,1066493539,2023-01-11T01:27:59Z,src/python/grpcio/grpc/_cython/_cygrpc/aio/callback_common.pyx.pxi,"@@ -23,11 +24,19 @@ cdef class CallbackFailureHandler:         self._core_function_name = core_function_name         self._error_details = error_details         self._exception_type = exception_type+        self._core_error_string = NULL+        if isinstance(exception_type, enum.IntEnum):+            self._core_error_string = grpc_call_error_to_string(exception_type)      cdef handle(self, object future):-        future.set_exception(self._exception_type(-            'Failed ""%s"": %s' % (self._core_function_name, self._error_details)-        ))+        if self._core_error_string == NULL:","After some digging, it looks like this `CallbackFailureHandler` actually handles the case that `grpc_event.success` is 0, not the case that we have a bad `grpc_call_error`. We'll want to revert the changes to this class.",
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/31890,1067306222,2023-01-11T18:06:27Z,src/core/lib/event_engine/posix_engine/posix_endpoint.h,"@@ -622,18 +629,30 @@ class PosixEndpoint     return impl_->GetLocalAddress();   } +  int GetWrappedFd() override { return impl_->GetWrappedFd(); }++  void Shutdown(absl::AnyInvocable<void(absl::StatusOr<int> release_fd)>+                    on_release_fd) override {+    if (!shutdown_.exchange(true, std::memory_order_acq_rel)) {+      impl_->MaybeShutdown(absl::InternalError(""Endpoint closing""),","nit: InternalError is reserved for serious errors. Aborted may be a better choice here, though OkStatus would be best since this is a normal occurrence - though I believe we lose the message with OkStatus, so it may be off the table.Please read the status code definitions here: https://github.com/abseil/abseil-cpp/blob/master/absl/status/status.h#L67",
5564114,Vignesh2208,https://api.github.com/repos/grpc/grpc/pulls/31890,1067620148,2023-01-12T01:33:45Z,src/core/lib/event_engine/posix_engine/posix_endpoint.h,"@@ -622,18 +629,30 @@ class PosixEndpoint     return impl_->GetLocalAddress();   } +  int GetWrappedFd() override { return impl_->GetWrappedFd(); }++  void Shutdown(absl::AnyInvocable<void(absl::StatusOr<int> release_fd)>+                    on_release_fd) override {+    if (!shutdown_.exchange(true, std::memory_order_acq_rel)) {+      impl_->MaybeShutdown(absl::InternalError(""Endpoint closing""),",changed it to absl::FailedPreconditionError,
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/31985,1068333057,2023-01-12T16:23:05Z,src/core/ext/filters/client_channel/lb_policy/xds/xds_override_host.cc,"@@ -139,42 +119,35 @@ class XdsOverrideHostLb : public LoadBalancingPolicy {         ConnectivityStateWatcherInterface* watcher) override;      grpc_connectivity_state connectivity_state() {-      return connectivity_state_.load();+      return watcher_->connectivity_state_.load();     }      XdsOverrideHostLb* policy() { return policy_.get(); } -    void detach() { key_ = absl::nullopt; }+    void Detach() { key_.reset(); }     private:     class ConnectivityStateWatcher : public ConnectivityStateWatcherInterface {      public:-      ConnectivityStateWatcher(-          std::unique_ptr<ConnectivityStateWatcherInterface> delegate,-          RefCountedPtr<SubchannelWrapper> subchannel)-          : delegate_(std::move(delegate)), subchannel_(subchannel) {}+      ConnectivityStateWatcher() {}        void OnConnectivityStateChange(grpc_connectivity_state state,-                                     absl::Status status) override {-        delegate_->OnConnectivityStateChange(state, status);-        subchannel_->connectivity_state_ = state;-      }+                                     absl::Status status) override; -      grpc_pollset_set* interested_parties() override {-        return delegate_->interested_parties();-      }+      grpc_pollset_set* interested_parties() override;       private:-      std::unique_ptr<ConnectivityStateWatcherInterface> delegate_;-      RefCountedPtr<SubchannelWrapper> subchannel_;-      XdsHealthStatus health_status_{XdsHealthStatus::kUnknown};+      friend class SubchannelWrapper;++      grpc_pollset_set* interested_parties_ = nullptr;","I think these data members should be directly in `SubchannelWrapper`, not in `ConnectivityStateWatcher`.  That way, there will be no need for the `friend` statement on line 140.  Note that `ConnectivityStateWatcher` is nested inside of `SubchannelWrapper`, so it can directly access the surrounding class's data members.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/31985,1068350572,2023-01-12T16:38:44Z,src/core/ext/filters/client_channel/lb_policy/xds/xds_override_host.cc,"@@ -247,42 +220,45 @@ class XdsOverrideHostLb : public LoadBalancingPolicy {    class SubchannelEntry {    public:-    void SetSubchannel(SubchannelWrapper* subchannel) {-      if (subchannel_ != nullptr) {-        subchannel_->detach();+    using Handle =+        absl::variant<SubchannelWrapper*, RefCountedPtr<SubchannelWrapper>>;++    explicit SubchannelEntry(Handle subchannel) {+      SetSubchannel(std::move(subchannel));+    }++    void SetSubchannel(Handle subchannel) {+      auto current = GetSubchannel();+      auto next = absl::visit(GetPointer(), subchannel);","Suggest using our [`Match()`](https://github.com/grpc/grpc/blob/1e32218bb82f72df964c2fa860a65aa7907d5b59/src/core/lib/gprpp/match.h#L41) function instead of `absl::visit()`, since it makes the code a little easier to read:``` public:  SubchannelWrapper* GetSubchannel() {    return GetSubchannelFromHandle(subchannel_);  } private:  static SubchannelWrapper* GetSubchannelFromHandle(Handle handle) {    return Match(        handle,        [](SubchannelWrapper* subchannel) { return subchannel; },        [](const RefCountedPtr<SubchannelWrapper>& subchannel) { return subchannel.get(); });  }```Then this line can be:```SubchannelWrapper* next = GetSubchannelFromHandle(subchannel);```",X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/31985,1068355525,2023-01-12T16:43:12Z,src/core/ext/filters/client_channel/lb_policy/xds/xds_override_host.cc,"@@ -247,42 +220,45 @@ class XdsOverrideHostLb : public LoadBalancingPolicy {    class SubchannelEntry {    public:-    void SetSubchannel(SubchannelWrapper* subchannel) {-      if (subchannel_ != nullptr) {-        subchannel_->detach();+    using Handle =+        absl::variant<SubchannelWrapper*, RefCountedPtr<SubchannelWrapper>>;++    explicit SubchannelEntry(Handle subchannel) {+      SetSubchannel(std::move(subchannel));+    }++    void SetSubchannel(Handle subchannel) {+      auto current = GetSubchannel();","Please don't use `auto` unless it actually improves readability, as per the style guide:https://google.github.io/styleguide/cppguide.html#Type_deductionAs an example, `auto` makes sense for iterator types, where writing out the full type name actually hurts readability, especially since it's already clear from the context what the type is.  But in a case like this, `auto` actually makes the code less readable than writing out the full type, because the full type name (`SubchannelWrapper*`) isn't so long that it distracts from understanding the code, and seeing the actual type name helps the reader understand what the code is doing.Please fix throughout.",X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/31985,1068359567,2023-01-12T16:46:58Z,src/core/ext/filters/client_channel/lb_policy/xds/xds_override_host.cc,"@@ -247,42 +220,45 @@ class XdsOverrideHostLb : public LoadBalancingPolicy {    class SubchannelEntry {    public:-    void SetSubchannel(SubchannelWrapper* subchannel) {-      if (subchannel_ != nullptr) {-        subchannel_->detach();+    using Handle =+        absl::variant<SubchannelWrapper*, RefCountedPtr<SubchannelWrapper>>;++    explicit SubchannelEntry(Handle subchannel) {+      SetSubchannel(std::move(subchannel));",I think this can just initialize `subchannel_` in the initializer list.  We don't actually need any of the additional logic from `SetSubchannel()` when the object is first being constructed.,X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/31985,1068370471,2023-01-12T16:56:59Z,src/core/ext/filters/client_channel/lb_policy/xds/xds_override_host.cc,"@@ -496,58 +470,49 @@ OrphanablePtr<LoadBalancingPolicy> XdsOverrideHostLb::CreateChildPolicyLocked(   return lb_policy; } -XdsHealthStatus XdsOverrideHostLb::AddressHealthStatus(-    const ServerAddress& address) {-  auto attribute = address.GetAttribute(XdsEndpointHealthStatusAttribute::kKey);-  if (attribute == nullptr) {-    return XdsHealthStatus(XdsHealthStatus::HealthStatus::kUnknown);-  }-  return static_cast<const XdsEndpointHealthStatusAttribute*>(attribute)-      ->status();-}- absl::StatusOr<ServerAddressList> XdsOverrideHostLb::UpdateAddressMap(     absl::StatusOr<ServerAddressList> addresses,     int override_host_status_mask) {-  std::unordered_map<std::string, bool> keys_and_lock(addresses->size());+  // It will also retain subchannels until after update. Otherwise destroying+  // the subchannels will try to reacquire the locks in the ResetSubchannel...+  std::map<std::string, SubchannelEntry, std::less<>> new_map;   absl::StatusOr<ServerAddressList> child_addresses;-  if (addresses.ok()) {-    child_addresses.emplace();-    for (const auto& address : *addresses) {-      auto status = AddressHealthStatus(address);-      bool locked = false;-      if (status.status() == XdsHealthStatus::HealthStatus::kDraining) {-        if ((override_host_status_mask & HealthStatusBitMask(status)) == 0) {+  {+    MutexLock lock(&subchannel_map_mu_);+    if (addresses.ok()) {+      child_addresses.emplace();+      for (const auto& address : *addresses) {+        auto status = GetAddressHealthStatus(address);+        bool draining = false;+        if (status.status() != XdsHealthStatus::HealthStatus::kDraining) {+          child_addresses->push_back(address);+        } else if ((override_host_status_mask & HealthStatusBitMask(status)) ==+                   0) {           continue;+        } else {+          draining = true;+        }+        auto key = grpc_sockaddr_to_string(&address.address(), false);+        if (key.ok()) {+          auto it = subchannel_map_.find(*key);+          if (it == subchannel_map_.end()) {+            new_map.emplace(std::make_pair(*key, SubchannelEntry(nullptr)));","There's no need to explicitly use `std::make_pair()` when you're calling `std::map<>::emplace()`, because the parameters to `emplace()` will be passed to the `std::pair<>` ctor.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/31985,1068373489,2023-01-12T16:59:36Z,src/core/ext/filters/client_channel/lb_policy/xds/xds_override_host.cc,"@@ -496,58 +470,49 @@ OrphanablePtr<LoadBalancingPolicy> XdsOverrideHostLb::CreateChildPolicyLocked(   return lb_policy; } -XdsHealthStatus XdsOverrideHostLb::AddressHealthStatus(-    const ServerAddress& address) {-  auto attribute = address.GetAttribute(XdsEndpointHealthStatusAttribute::kKey);-  if (attribute == nullptr) {-    return XdsHealthStatus(XdsHealthStatus::HealthStatus::kUnknown);-  }-  return static_cast<const XdsEndpointHealthStatusAttribute*>(attribute)-      ->status();-}- absl::StatusOr<ServerAddressList> XdsOverrideHostLb::UpdateAddressMap(     absl::StatusOr<ServerAddressList> addresses,     int override_host_status_mask) {-  std::unordered_map<std::string, bool> keys_and_lock(addresses->size());+  // It will also retain subchannels until after update. Otherwise destroying+  // the subchannels will try to reacquire the locks in the ResetSubchannel...+  std::map<std::string, SubchannelEntry, std::less<>> new_map;   absl::StatusOr<ServerAddressList> child_addresses;-  if (addresses.ok()) {-    child_addresses.emplace();-    for (const auto& address : *addresses) {-      auto status = AddressHealthStatus(address);-      bool locked = false;-      if (status.status() == XdsHealthStatus::HealthStatus::kDraining) {-        if ((override_host_status_mask & HealthStatusBitMask(status)) == 0) {+  {+    MutexLock lock(&subchannel_map_mu_);","I think the way you had this before was better, because it avoided holding the lock for longer than it actually needed to, thus minimizing lock contention.  Most of the work we're doing in the loop here is just extracting data from the new address list, which we can do before we take the lock.  We can then acquire the lock and update the map with the resulting data, so that we're not holding the lock any longer than we actually need to.I think the code here should look something like this:```if (!addresses.ok()) return addresses;// Construct list of addresses for the child policy and for our map.ServerAddressList child_addresses;std::map<std::string, XdsHealthStatus> addresses_for_map;for (const auto& address : *addresses) {  XdsHealthStatus health_status = GetAddressHealthStatus(address);  if (health_status.status() != XdsHealthStatus::HealthStatus::kDraining) {    child_addresses.push_back(address);  } else if (override_host_status_mask & HealthStatusBitMask(health_status) == 0) {    continue;  // Skip draining hosts if not in the override status set.  }  auto key = grpc_sockaddr_to_string(&address.address(), false);  if (key.ok()) {    addresses_for_map.emplace(std::move(*key), health_status);  }}// Now grab the lock and update the map.{  MutexLock lock(&subchannel_map_mu_);  // For each address in the map that is not in the new list, remove it.  for (auto it = subchannel_map_.begin(); it != subchannel_map_.end(); ) {    if (addresses_for_map.find(it->first) == addresses_for_map.end()) {      // Detach here so that the SubchannelWrapper does not deadlock by trying to reacquire      // the lock to remove itself from the entry, which isn't necessary anyway, since we're      // about to remove the entire entry.      SubchannelWrapper* subchannel = it->second.GetSubchannel();      if (subchannel != nullptr) subchannel->Detach();      it = subchannel_map_.erase(it);    } else {      ++it;    }  }  // For each address in the new list, update the EDS health status in the corresponding map entry,  // adding the entry if needed.  for (const auto& p : addresses_for_map) {    const std::string& key = p.first;    const XdsHealthStatus& health_status = p.second;    const bool is_draining = health_status.status() == XdsHealthStatus::HealthStatus::kDraining;    auto it = subchannel_map_.find(key);    if (it == subchannel_map_.end()) {      it = subchannel_map_.emplace(key, SubchannelEntry()).first;    }    it->second.SetEdsHealthStatus(health_status);  }}return std::move(child_addresses);```",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/31985,1068411307,2023-01-12T17:34:23Z,src/core/ext/filters/client_channel/lb_policy/xds/xds_override_host.cc,"@@ -153,9 +163,10 @@ class XdsOverrideHostLb : public LoadBalancingPolicy {      private:       std::unique_ptr<ConnectivityStateWatcherInterface> delegate_;       RefCountedPtr<SubchannelWrapper> subchannel_;+      XdsHealthStatus health_status_{XdsHealthStatus::kUnknown};","I think we do need this data member.As an example, if the override host set in the config does *not* include `UNKNOWN`, then if the picker sees an override host whose health status is `UNKNOWN`, it needs to ignore that override host.  In order to do that, we need to store the health status in the `SubchannelEntry`, and the picker needs to look at it when checking the override host attribute.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/31985,1068414631,2023-01-12T17:36:59Z,src/core/ext/filters/client_channel/lb_policy/xds/xds_override_host.cc,"@@ -621,18 +683,34 @@ const JsonLoaderInterface* XdsOverrideHostLbConfig::JsonLoader(  void XdsOverrideHostLbConfig::JsonPostLoad(const Json& json, const JsonArgs&,                                            ValidationErrors* errors) {-  ValidationErrors::ScopedField field(errors, "".childPolicy"");-  auto it = json.object_value().find(""childPolicy"");-  if (it == json.object_value().end()) {-    errors->AddError(""field not present"");-  } else {-    auto child_policy_config =-        CoreConfiguration::Get().lb_policy_registry().ParseLoadBalancingConfig(-            it->second);-    if (!child_policy_config.ok()) {-      errors->AddError(child_policy_config.status().message());+  {+    ValidationErrors::ScopedField field(errors, "".childPolicy"");+    auto it = json.object_value().find(""childPolicy"");+    if (it == json.object_value().end()) {+      errors->AddError(""field not present"");     } else {-      child_config_ = std::move(*child_policy_config);+      auto child_policy_config = CoreConfiguration::Get()+                                     .lb_policy_registry()+                                     .ParseLoadBalancingConfig(it->second);+      if (!child_policy_config.ok()) {+        errors->AddError(child_policy_config.status().message());+      } else {+        child_config_ = std::move(*child_policy_config);+      }+    }+  }+  {+    ValidationErrors::ScopedField field(errors, "".overrideHostStatus"");+    auto it = json.object_value().find(""overrideHostStatus"");+    if (it != json.object_value().end()) {+      override_host_status_mask_ = 0;+      auto array = it->second.array_value();+      for (const auto& value : array) {+        auto status = XdsHealthStatus::FromString(value.string_value());+        if (status.has_value()) {","Yes, we don't support all of the EDS health states, but the `XdsClient` won't return any host that is in an unsupported state, so we'll never see any such hosts here:https://github.com/grpc/grpc/blob/fc54381aecf414c6ef35aaa19346bb1521168bfe/src/core/ext/xds/xds_endpoint.cc#L163",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/31985,1068471780,2023-01-12T18:23:06Z,src/core/ext/filters/client_channel/lb_policy/xds/xds_override_host.h,"@@ -49,12 +49,16 @@ class XdsOverrideHostLbConfig : public LoadBalancingPolicy::Config {     return child_config_;   } +  int override_host_status_mask() const { return override_host_status_mask_; }","Instead of exposing this as an integer, how about adding an interface to provide set semantics?  That would make the calling code (both in the LB policy and in the config tests) more readable.I'm thinking that we could add something like this in src/core/ext/xds/xds_health_status.h:```class XdsHealthStatusSet { public:  explicit XdsHealthStatusSet(const std::vector<XdsHealthStatus>& statuses) {    for (XdsHealthStatus status : statuses) {      Add(status);    }  }  bool operator==(const XdsHealthStatusSet& other) { return status_mask_ == other.status_mask_; }  void Clear() { status_mask_ = 0; }  void Add(XdsHealthStatus status) {    status_mask_ |= (0x1 << status.status());  }  bool Contains(XdsHealthStatus status) {    return status_mask_ & (0x1 << status.status());  } private:  int status_mask_ = 0;};```Then we could have this method return `XdsHealthStatusSet`, and the callers could check whether the set contains the expected statuses.",X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/31985,1068473350,2023-01-12T18:24:57Z,test/core/client_channel/lb_policy/xds_override_host_lb_config_parser_test.cc,"@@ -151,6 +218,51 @@ TEST(XdsOverrideHostConfigParsingTest, ReportsEmptyChildPolicyArray) {                 ""error:errors validating xds_override_host LB policy config: ""                 ""[field:childPolicy error:No known policies in list: ]]"")); }++TEST(XdsOverrideHostConfigParsingTest, ParsesOverrideHostStatusList) {",This test looks like a duplicate of the one above.  I don't think it's needed.,X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/31985,1068475671,2023-01-12T18:27:34Z,test/core/client_channel/lb_policy/xds_override_host_test.cc,"@@ -54,15 +54,9 @@ class XdsOverrideHostTest : public LoadBalancingPolicyTest {       : policy_(MakeLbPolicy(""xds_override_host_experimental"")) {}    RefCountedPtr<LoadBalancingPolicy::Config> MakeXdsOverrideHostConfig(-      bool exclude_draining_status = false,+      Json::Array override_host_status = {""UNKNOWN"", ""HEALTHY"", ""DRAINING""},","If you take my suggestion elsewhere about adding an `XdsHealthStatusSet` class, then we could use that type here as well.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/31985,1068493269,2023-01-12T18:46:04Z,test/core/client_channel/lb_policy/xds_override_host_test.cc,"@@ -213,6 +253,92 @@ TEST_F(XdsOverrideHostTest, ConnectingSubchannelIsQueued) {   picker = ExpectState(GRPC_CHANNEL_READY);   ExpectPickQueued(picker.get(), pick_arg); }++TEST_F(XdsOverrideHostTest, DrainingState) {","Yes, I think that update is expected.  The way you've written the test, the address is starting out in a state other than DRAINING, and then you are switching it to state DRAINING.  This will trigger an update to the child policy that no longer contains this address, which will cause the child policy to return a new picker that will no longer return the removed address.",
287917,eugeneo,https://api.github.com/repos/grpc/grpc/pulls/31985,1069850191,2023-01-13T18:40:42Z,test/core/client_channel/lb_policy/xds_override_host_test.cc,"@@ -54,15 +54,9 @@ class XdsOverrideHostTest : public LoadBalancingPolicyTest {       : policy_(MakeLbPolicy(""xds_override_host_experimental"")) {}    RefCountedPtr<LoadBalancingPolicy::Config> MakeXdsOverrideHostConfig(-      bool exclude_draining_status = false,+      Json::Array override_host_status = {""UNKNOWN"", ""HEALTHY"", ""DRAINING""},","This is for generating the JSON object. I am not sure additional complexity (extracting XdsHostStatus from mask, converting XdsHostStatus to string) is needed for tests.",X
287917,eugeneo,https://api.github.com/repos/grpc/grpc/pulls/31985,1069878285,2023-01-13T18:57:14Z,src/core/ext/filters/client_channel/lb_policy/xds/xds_override_host.cc,"@@ -139,42 +119,35 @@ class XdsOverrideHostLb : public LoadBalancingPolicy {         ConnectivityStateWatcherInterface* watcher) override;      grpc_connectivity_state connectivity_state() {-      return connectivity_state_.load();+      return watcher_->connectivity_state_.load();     }      XdsOverrideHostLb* policy() { return policy_.get(); } -    void detach() { key_ = absl::nullopt; }+    void Detach() { key_.reset(); }     private:     class ConnectivityStateWatcher : public ConnectivityStateWatcherInterface {      public:-      ConnectivityStateWatcher(-          std::unique_ptr<ConnectivityStateWatcherInterface> delegate,-          RefCountedPtr<SubchannelWrapper> subchannel)-          : delegate_(std::move(delegate)), subchannel_(subchannel) {}+      ConnectivityStateWatcher() {}        void OnConnectivityStateChange(grpc_connectivity_state state,-                                     absl::Status status) override {-        delegate_->OnConnectivityStateChange(state, status);-        subchannel_->connectivity_state_ = state;-      }+                                     absl::Status status) override; -      grpc_pollset_set* interested_parties() override {-        return delegate_->interested_parties();-      }+      grpc_pollset_set* interested_parties() override;       private:-      std::unique_ptr<ConnectivityStateWatcherInterface> delegate_;-      RefCountedPtr<SubchannelWrapper> subchannel_;-      XdsHealthStatus health_status_{XdsHealthStatus::kUnknown};+      friend class SubchannelWrapper;++      grpc_pollset_set* interested_parties_ = nullptr;",There is a lifetime issue. Looks like the watcher outlives its SubchannelWrapper parent. We cancel watching the subchannel in SubchannelWatcher dtor but I think it does not destroy the listener immediately. I believe it is more reliable to keep the fields in the watcher for now.,
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/32101,1069924859,2023-01-13T19:26:04Z,test/cpp/common/alarm_test.cc,"@@ -266,6 +266,30 @@ TEST(AlarmTest, NegativeExpiry) {   EXPECT_EQ(junk, output_tag); } +// Infinite past or unix epoch should fire immediately.+TEST(AlarmTest, InfPastExpiry) {+  CompletionQueue cq;+  void* junk = reinterpret_cast<void*>(1618033);+  Alarm alarm;+  alarm.Set(&cq, gpr_inf_past(GPR_CLOCK_REALTIME), junk);++  void* output_tag;+  bool ok;+  CompletionQueue::NextStatus status =+      cq.AsyncNext(&output_tag, &ok, grpc_timeout_seconds_to_deadline(1));","On a heavily loaded system with low resources, or maybe running this 10,000 times, I do wonder if we'll see flakes due to the short deadline. It may be safer to extend the deadline to 10s, given we expect it to complete immediately regardless.",
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/31661,1070038183,2023-01-13T20:56:03Z,src/core/BUILD,"@@ -2024,7 +2024,10 @@ grpc_cc_library(         ""//:windows"": [""windows_event_engine""],         ""//:windows_msvc"": [""windows_event_engine""],         ""//:windows_other"": [""windows_event_engine""],-        ""//conditions:default"": [""posix_event_engine""],+        ""//conditions:default"": [+            ""posix_event_engine"",+            ""posix_event_engine_endpoint"",","Since `posix_event_engine` already depends on `posix_event_engine_endpoint`, and `default_event_engine_factory.cc` doesn't need any endpoint-specific headers (so layering_check doesn't apply), I think this dependency can be removed.",
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/31661,1070083381,2023-01-13T21:27:53Z,src/core/lib/iomgr/tcp_client_posix.cc,"@@ -86,6 +100,41 @@ void do_tcp_client_global_init(void) {   g_connection_shards = new std::vector<struct ConnectionShard>(num_shards); } +int64_t event_engine_tcp_client_connect(",This appears to be implementation-agnostic. Can it be moved out of the posix-specific code paths? Otherwise we'll _duplicate_ it for every engine implementation we want to try with shims.,X
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/32075,1071253896,2023-01-16T13:35:40Z,src/csharp/BUILD-INTEGRATION.md,"@@ -1,351 +1,93 @@-Protocol Buffers/gRPC Codegen Integration Into .NET Build-=================================================+# Protocol Buffers/gRPC Codegen Integration Into .NET Build -With Grpc.Tools package version 1.17 we made it easier to compile .proto files-in your project using the `dotnet build` command, Visual Studio, or command-line-MSBuild. You need to configure the .csproj project according to the way you want-to integrate Protocol Buffer files into your build.+The [Grpc.Tools](https://www.nuget.org/packages/Grpc.Tools) NuGet package provides C# tooling support for `.proto` files in `.csproj` projects:+* It contains protocol buffers compiler and gRPC plugin to generate C# code.+* It can be used in building both grpc-dotnet projects and legacy c-core C# projects. -There is also a Reference section at the end of the file.+Using `Grpc.Tools` in `.csproj` files is described below. Other packages providing the runtime libraries for gRPC are described elsewhere. These include:+* Legacy gRPC c-core implementation+  * `Grpc.Core` - contains a gRPC client and server and supports .NET Framework, .NET Core, and .NET 5 or later.+* gRPC-dotnet implementation+  * `Grpc.AspNetCore` - contains a gRPC server that is hosted in ASP.NET Core and requires .NET Core 3.x or .NET 5 or later.+  * `Grpc.Net.Client` - contains a gRPC client. -Common scenarios-----------------+Other documentation giving an overview of gRPC for .NET, the tooling support, and a tutorial on how to create server and client projects in C# can be found here:+* [Overview for gRPC on .NET](https://learn.microsoft.com/en-us/aspnet/core/grpc/)+* [C# Tooling support for .proto files](https://learn.microsoft.com/en-us/aspnet/core/grpc/basics#c-tooling-support-for-proto-files)+* [Tutorial: Create a gRPC client and server in ASP.NET Core](https://learn.microsoft.com/en-us/aspnet/core/tutorials/grpc/grpc-start) -### I just want to compile .proto files into my library+For information for the legacy gRPC C# implementation based on the native gRPC Core library (Grpc.Core package) see:+* https://github.com/grpc/grpc/blob/master/src/csharp/README.md+* https://github.com/grpc/grpc/tree/v1.46.x/src/csharp#how-to-use -This is the approach taken by the examples in the `csharp/examples` directory.-Protoc output files (for example, `Helloworld.cs` and `HelloworldGrpc.cs`-compiled from `helloworld.proto`) are placed among *object* and other temporary-files of your project, and automatically provided as inputs to the C# compiler.-As with other automatically generated .cs files, they are included in the source-and symbols NuGet package, if you build one.+## Getting Started -Simply reference your .proto files in a `<Protobuf>` item group. The following-example will add all .proto files in a project and all its subdirectories-(excluding special directories such as `bin` and `obj`):+The package [Grpc.Tools](https://www.nuget.org/packages/Grpc.Tools) is used to generate the C# files from+`.proto` files. These files:+* are generated on an as-needed basis each time the project is built.+* aren't added to the project or checked into source control.+* are a build artefact usually contained in the obj directory. -```xml-  <ItemGroup>-    <Protobuf Include=""**/*.proto"" />-  </ItemGroup>-```--You must add a reference to the NuGet packages Grpc.Tools and Grpc (the latter-is a meta-package, in turn referencing Grpc.Core and Google.Protobuf packages).-It is **very important** to mark Grpc.Tools as a development-only dependency, so-that the *users* of your library do not fetch the tools package:--* ""dotnet SDK"" .csproj (Visual Studio, `dotnet new`): Add an attribute- `PrivateAssets=""All""` to the Grpc.Tools package reference. See an example in the- [Greeter.csproj](../../examples/csharp/Helloworld/Greeter/Greeter.csproj#L10)- example project in this repository. If adding a package reference in Visual- Studio, edit the project file and add this attribute. [This is a bug in NuGet- client](https://github.com/NuGet/Home/issues/4125).--* ""Classic"" .csproj with `packages.config` (Visual Studio before 2017, old versions of Mono):- This is handled automatically by NuGet after you set the `developmentDependency=""true""`- attribute on the `<package>` tag in `packages.config`.--If building a NuGet package from your library with the nuget command line tool-from a .nuspec file, then the spec file may (and probably should) reference the-Grpc metapackage, but **do not add a reference to Grpc.Tools** to it. ""dotnet SDK""-projects handle this automatically when called from `dotnet pack` by excluding-any packages with private assets, such as thus marked Grpc.Tools.--#### Per-file options that can be set in Visual Studio--For a ""dotnet SDK"" project, you have more control of some frequently used options.-**You may need to open and close Visual Studio** for this form to appear in the-properties window after adding a reference to Grpc.Tools package (we do not know-whether this is a bug or by design, but it looks like a bug):--![Properties in an SDK project](doc/integration.md-fig.2-sdk.png)--You can also change options of multiple files at once by selecting them in the-Project Explorer together.--For a ""classic"" project, you can only add .proto files with all options set to-default (if you find it necessary to modify these options, then hand-edit the-.csproj file). Click on the ""show all files"" button, add files to project, then-change file type of the .proto files to ""Protobuf"" in the Properties window-drop-down. This menu item will appear after you import the Grpc.Tools package:--![Properties in a classic project](doc/integration.md-fig.1-classic.png)--See the Reference section at end of this file for options that can be set-per-file by modifying the source .csproj directly.--#### My .proto files are in a directory outside the project--Refer to the example files-[RouteGuide.csproj](../../examples/csharp/RouteGuide/RouteGuide/RouteGuide.csproj#L58-L60)-and [Greeter.csproj](../../examples/csharp/Helloworld/Greeter/Greeter.csproj#L11)-in this repository. For the files to show up in Visual Studio properly, add a-`Link` attribute with just a filename to the `<Protobuf>` item. This will be the-display name of the file. In the `Include` attribute, specify the complete path-to file. A relative path is based off the project directory.--Or, if using Visual Studio, add files _as links_ from outside directory. In the-Add Files dialog, there is a little [down arrow near the Open-button](https://stackoverflow.com/a/9770061). Click on it, and choose ""Add as-link"". If you do not select this option, Visual Studio will copy files to the-project directory instead.--Alternatively, you can also specify `AdditionalImportDirs` and provide a list of directories to search for imported .proto files. The directories are searched in the order given.--Eg.+This package is required when building both the server and client projects, and by both c-core C# projects and grpc-dotnet projects:+* The `Grpc.AspNetCore` metapackage already includes a reference to `Grpc.Tools`. +* Client projects and projects using `Grpc.Core` need to directly reference `Grpc.Tools` alongside the other packages required. +It isn't required at runtime, so the dependency should be marked with `PrivateAssets=""All""`, e.g.","I think ""It isn't required at runtime"" could be a bit clearer. Basically the package doesn't have any runtime component, it only takes care of generating the code at build time so the dependency on Grpc.Tools is build-time-only as well. ",
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/32075,1071303911,2023-01-16T14:25:18Z,src/csharp/BUILD-INTEGRATION.md,"@@ -440,3 +182,256 @@ protoc --plugin=protoc-gen-grpc=grpc_csharp_plugin --csharp_out=OUT_DIR \     --grpc_out=OUT_DIR --grpc_opt=lite_client,no_server \     -I INCLUDE_DIR foo.proto ```+## Environment Variables++Environment variables can be set to change the behavior of `Grpc.Tools` - setting the CPU architecture or operating system, or using custom built protocol buffers compiler and gRPC plugin.++| Name                | Synopsis                                                                      |+|---------------------|-------------------------------------------------------------------------------|+|`PROTOBUF_TOOLS_OS`  | Operating system version of the tools to use: `linux`, `macosx`, or `windows` |+|`PROTOBUF_TOOLS_CPU` | CPU architecture version of the tools to use: `x86`, `x64`, or `arm64`        |+|`PROTOBUF_PROTOC`    | Full path to the protocol buffers compiler                                    |+|`GRPC_PROTOC_PLUGIN` | Full path to the grpc_csharp_plugin                                           |++For example, to use a custom built protoc compiler and grpc_csharp_plugin:+```bash+export PROTOBUF_PROTOC=$my_custom_build/protoc+export GRPC_PROTOC_PLUGIN=$my_custom_build/grpc_csharp_plugin+dotnet build myproject.csproj+```++## MSBuild Properties++You can set some Properties in your project file or on the MSBuild command line. The+following properties change the behavior of `Grpc.Tools`:++| Name                | Synopsis                                                                      |+|---------------------|-------------------------------------------------------------------------------|+| `Protobuf_ToolsOs`  | Same as `PROTOBUF_TOOLS_OS` environment variable                              |+| `Protobuf_ToolsCpu` | Same as `PROTOBUF_TOOLS_CPU` environment variable                             |+| `Protobuf_ProtocFullPath` | Same as `PROTOBUF_PROTOC` environment variable                          |+| `gRPC_PluginFullPath` | Same as `GRPC_PROTOC_PLUGIN` environment variable                           |+| `Protobuf_NoWarnMissingExpected` | Default: `false`. If `true` then no warnings are given if expected files not generated. See example below for an explanation. |+| `Protobuf_OutputPath`| Default: `IntermediateOutputPath` - ususally the `obj` directory. Sets the default value for `OutputDir` on `<Protobuf>` items.|++# Scenarios and Examples++For other examples see also the `.csproj` files in the examples in GitHub:+* Grpc-dotnet examples: https://github.com/grpc/grpc-dotnet/tree/master/examples+* Grpc c-core C# examples: https://github.com/grpc/grpc/tree/v1.46.x/examples/csharp++Quick links to the examples below:++* [AdditionalImportDirs - Setting location of imported `.proto` files](#AdditionalImportDirs)+* [ProtoRoot - Avoiding duplicate generated file names](#ProtoRoot)+* [GrpcServices - Generating gRPC services and protocol buffers messages](#grpcservices)+* [Generate proto and gRPC C# sources from .proto files (no C# compile)](#nocompile)+* [Visual Studio: setting per-file `.proto` file options](#visualstudio)+* [Bypassing Grpc.Tools to run the protocol buffers compiler explicitly](#compiler)++---+## <a name=""AdditionalImportDirs""></a>AdditionalImportDirs - Setting location of imported `.proto` files++If your `.proto` files import other files that are not co-located with the `.proto` file +you can specify the directories to search for the+imported files by specifying `AdditionalImportDirs` and provide a list of directories.+The directories are searched in the order given. E.g.:++```xml+  <Protobuf Include=""protos/*.proto"" ProtoRoot=""protos""+      AdditionalImportDirs=""/folder/protos/myapis/;/another/folder/""+      ... />+```++Note - the paths for standard imports included in the `Grpc.Tools` package are automatically passed to the protocol buffers compiler and do not need to be explicitly set.+E.g. the directory `""...\.nuget\packages\grpc.tools\2.51.0\build\native\include""` is automatically included.  This is the directory where a declaration such as `import ""google/protobuf/wrappers.proto"";` in a proto file would be found.++---+## <a name=""ProtoRoot""></a>ProtoRoot - Avoiding duplicate generated file names","The example title talks about ""Avoiding duplicate generate file names"" but the contents of this section don't match that. There no duplicate file name in `<Protobuf Include=""**\*.proto"" />` nor `<Protobuf Include=""**\*.proto"" ProtoRoot=""Protos"" />`.But if there would be another .proto file that does `import v1/hello.proto`, the example would work without also setting ProtoRoot. ",
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/32075,1071311496,2023-01-16T14:32:44Z,src/csharp/BUILD-INTEGRATION.md,"@@ -1,351 +1,93 @@-Protocol Buffers/gRPC Codegen Integration Into .NET Build-=================================================+# Protocol Buffers/gRPC Codegen Integration Into .NET Build -With Grpc.Tools package version 1.17 we made it easier to compile .proto files-in your project using the `dotnet build` command, Visual Studio, or command-line-MSBuild. You need to configure the .csproj project according to the way you want-to integrate Protocol Buffer files into your build.+The [Grpc.Tools](https://www.nuget.org/packages/Grpc.Tools) NuGet package provides C# tooling support for `.proto` files in `.csproj` projects:+* It contains protocol buffers compiler and gRPC plugin to generate C# code.+* It can be used in building both grpc-dotnet projects and legacy c-core C# projects. -There is also a Reference section at the end of the file.+Using `Grpc.Tools` in `.csproj` files is described below. Other packages providing the runtime libraries for gRPC are described elsewhere. These include:+* Legacy gRPC c-core implementation+  * `Grpc.Core` - contains a gRPC client and server and supports .NET Framework, .NET Core, and .NET 5 or later.+* gRPC-dotnet implementation+  * `Grpc.AspNetCore` - contains a gRPC server that is hosted in ASP.NET Core and requires .NET Core 3.x or .NET 5 or later.+  * `Grpc.Net.Client` - contains a gRPC client. -Common scenarios-----------------+Other documentation giving an overview of gRPC for .NET, the tooling support, and a tutorial on how to create server and client projects in C# can be found here:+* [Overview for gRPC on .NET](https://learn.microsoft.com/en-us/aspnet/core/grpc/)+* [C# Tooling support for .proto files](https://learn.microsoft.com/en-us/aspnet/core/grpc/basics#c-tooling-support-for-proto-files)+* [Tutorial: Create a gRPC client and server in ASP.NET Core](https://learn.microsoft.com/en-us/aspnet/core/tutorials/grpc/grpc-start) -### I just want to compile .proto files into my library+For information for the legacy gRPC C# implementation based on the native gRPC Core library (Grpc.Core package) see:+* https://github.com/grpc/grpc/blob/master/src/csharp/README.md+* https://github.com/grpc/grpc/tree/v1.46.x/src/csharp#how-to-use -This is the approach taken by the examples in the `csharp/examples` directory.-Protoc output files (for example, `Helloworld.cs` and `HelloworldGrpc.cs`-compiled from `helloworld.proto`) are placed among *object* and other temporary-files of your project, and automatically provided as inputs to the C# compiler.-As with other automatically generated .cs files, they are included in the source-and symbols NuGet package, if you build one.+## Getting Started -Simply reference your .proto files in a `<Protobuf>` item group. The following-example will add all .proto files in a project and all its subdirectories-(excluding special directories such as `bin` and `obj`):+The package [Grpc.Tools](https://www.nuget.org/packages/Grpc.Tools) is used to generate the C# files from+`.proto` files. These files:+* are generated on an as-needed basis each time the project is built.+* aren't added to the project or checked into source control.+* are a build artefact usually contained in the obj directory. -```xml-  <ItemGroup>-    <Protobuf Include=""**/*.proto"" />-  </ItemGroup>-```--You must add a reference to the NuGet packages Grpc.Tools and Grpc (the latter-is a meta-package, in turn referencing Grpc.Core and Google.Protobuf packages).-It is **very important** to mark Grpc.Tools as a development-only dependency, so-that the *users* of your library do not fetch the tools package:--* ""dotnet SDK"" .csproj (Visual Studio, `dotnet new`): Add an attribute- `PrivateAssets=""All""` to the Grpc.Tools package reference. See an example in the- [Greeter.csproj](../../examples/csharp/Helloworld/Greeter/Greeter.csproj#L10)- example project in this repository. If adding a package reference in Visual- Studio, edit the project file and add this attribute. [This is a bug in NuGet- client](https://github.com/NuGet/Home/issues/4125).--* ""Classic"" .csproj with `packages.config` (Visual Studio before 2017, old versions of Mono):- This is handled automatically by NuGet after you set the `developmentDependency=""true""`- attribute on the `<package>` tag in `packages.config`.--If building a NuGet package from your library with the nuget command line tool-from a .nuspec file, then the spec file may (and probably should) reference the-Grpc metapackage, but **do not add a reference to Grpc.Tools** to it. ""dotnet SDK""-projects handle this automatically when called from `dotnet pack` by excluding-any packages with private assets, such as thus marked Grpc.Tools.--#### Per-file options that can be set in Visual Studio--For a ""dotnet SDK"" project, you have more control of some frequently used options.-**You may need to open and close Visual Studio** for this form to appear in the-properties window after adding a reference to Grpc.Tools package (we do not know-whether this is a bug or by design, but it looks like a bug):--![Properties in an SDK project](doc/integration.md-fig.2-sdk.png)--You can also change options of multiple files at once by selecting them in the-Project Explorer together.--For a ""classic"" project, you can only add .proto files with all options set to-default (if you find it necessary to modify these options, then hand-edit the-.csproj file). Click on the ""show all files"" button, add files to project, then-change file type of the .proto files to ""Protobuf"" in the Properties window-drop-down. This menu item will appear after you import the Grpc.Tools package:--![Properties in a classic project](doc/integration.md-fig.1-classic.png)--See the Reference section at end of this file for options that can be set-per-file by modifying the source .csproj directly.--#### My .proto files are in a directory outside the project--Refer to the example files-[RouteGuide.csproj](../../examples/csharp/RouteGuide/RouteGuide/RouteGuide.csproj#L58-L60)-and [Greeter.csproj](../../examples/csharp/Helloworld/Greeter/Greeter.csproj#L11)-in this repository. For the files to show up in Visual Studio properly, add a-`Link` attribute with just a filename to the `<Protobuf>` item. This will be the-display name of the file. In the `Include` attribute, specify the complete path-to file. A relative path is based off the project directory.--Or, if using Visual Studio, add files _as links_ from outside directory. In the-Add Files dialog, there is a little [down arrow near the Open-button](https://stackoverflow.com/a/9770061). Click on it, and choose ""Add as-link"". If you do not select this option, Visual Studio will copy files to the-project directory instead.--Alternatively, you can also specify `AdditionalImportDirs` and provide a list of directories to search for imported .proto files. The directories are searched in the order given.--Eg.+This package is required when building both the server and client projects, and by both c-core C# projects and grpc-dotnet projects:+* The `Grpc.AspNetCore` metapackage already includes a reference to `Grpc.Tools`. +* Client projects and projects using `Grpc.Core` need to directly reference `Grpc.Tools` alongside the other packages required. +It isn't required at runtime, so the dependency should be marked with `PrivateAssets=""All""`, e.g. ```xml-  <Protobuf Include=""protos/*.proto"" ProtoRoot=""protos""-      AdditionalImportDirs=""/folder/ouside/project/protos/myapis/;/another/folder/"" ... />+<PackageReference Include=""Grpc.Tools"" Version=""2.50.0"">+  <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>+  <PrivateAssets>all</PrivateAssets>+</PackageReference> ``` -#### My .proto files have same filename in different folders--Starting from Grpc.Tools version 2.31, protocol buffers compilation preserves original folder structure for generated files. Eg.--- `../ProjectFolder/Protos/v2/http.proto`-- `../ProjectFolder/Protos/v3/http.proto`--Will result in:+Support is provided for the following platforms:+* Windows (x86, x64, and arm64 via using the x86 binaries)+* MacOS (arm64)+* Linux (x86, x64, and arm64) -- `../ProjectFolder/obj/CONFIGURATION/FRAMEWORK/Protos/v2/Greet.cs`-- `../ProjectFolder/obj/CONFIGURATION/FRAMEWORK/Protos/v2/GreetGrpc.cs`-- `../ProjectFolder/obj/CONFIGURATION/FRAMEWORK/Protos/v3/Greet.cs`-- `../ProjectFolder/obj/CONFIGURATION/FRAMEWORK/Protos/v3/GreetGrpc.cs`+## Adding `.proto` files to a project -This feature resolves problems we have faced in large projects. Moreover, There is now also a project-wide new option Protobuf_ProtoRoot to define the fallback ProtoRoot. If the ProtoRoot is set, this also reduces the amount of problems that lead to duplicates. Eg.+To add `.proto` files to a project edit the projects `.csproj` file and add an item group with a `<Protobuf>` element that refers to the `.proto` file, e.g.  ```xml-  <ItemGroup>-    <Protobuf Include=""Protos\v2\greet.proto"" ProtoRoot=""Protos"" />-  </ItemGroup>+<ItemGroup>+    <Protobuf Include=""Protos\greet.proto"" />+</ItemGroup> ``` -Before Grpc.Tools version 2.31 all .proto files were compiled into `obj` directory, flattening relative paths. For proto files with duplicated names it cause following errors `NETSDK1022 Duplicate 'Compile' items were included. [...]` or `MSB3105 [...] Duplicate items are not supported by the ""Sources"" parameter`. The workaround for this problem was introducing relative paths in your `obj` folder, by manipulating output path. Eg. +Wildcards can be used to select several `.proto` files, e.g.  ```xml-  <ItemGroup>-    <Protobuf Include=""Protos/v2/http.proto"" OutputDir=""$(Protobuf_OutputPath)%(RelativeDir)""  />-    <Protobuf Include=""Protos/v3/http.proto"" OutputDir=""$(Protobuf_OutputPath)%(RelativeDir)""  />-  </ItemGroup>-```--__Note, this was a workaround approach, we recommend updating Grpc.Tools to the latest version.__--### I just want to generate proto and gRPC C# sources from my .proto files (no C# compile)--Suppose you want to place generated files right beside each respective source-.proto file. Create a .csproj library file in the common root of your .proto-tree, and add a reference to Grpc.Tools package (this works in Windows too, `$`-below stands for a command prompt in either platform):-+<ItemGroup>+    <Protobuf Include=""**\*.proto"" />",This doc doesn't mention the option to enable auto-inclusion of .proto files anywhere.See https://github.com/grpc/grpc/blob/master/src/csharp/Grpc.Tools/implementation_notes.md#automatically-including-proto-files  - perhaps worth mentioning this somewhere?,
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/32075,1071313231,2023-01-16T14:34:34Z,src/csharp/BUILD-INTEGRATION.md,"@@ -440,3 +182,256 @@ protoc --plugin=protoc-gen-grpc=grpc_csharp_plugin --csharp_out=OUT_DIR \     --grpc_out=OUT_DIR --grpc_opt=lite_client,no_server \     -I INCLUDE_DIR foo.proto ```+## Environment Variables++Environment variables can be set to change the behavior of `Grpc.Tools` - setting the CPU architecture or operating system, or using custom built protocol buffers compiler and gRPC plugin.++| Name                | Synopsis                                                                      |+|---------------------|-------------------------------------------------------------------------------|+|`PROTOBUF_TOOLS_OS`  | Operating system version of the tools to use: `linux`, `macosx`, or `windows` |+|`PROTOBUF_TOOLS_CPU` | CPU architecture version of the tools to use: `x86`, `x64`, or `arm64`        |+|`PROTOBUF_PROTOC`    | Full path to the protocol buffers compiler                                    |+|`GRPC_PROTOC_PLUGIN` | Full path to the grpc_csharp_plugin                                           |++For example, to use a custom built protoc compiler and grpc_csharp_plugin:+```bash+export PROTOBUF_PROTOC=$my_custom_build/protoc+export GRPC_PROTOC_PLUGIN=$my_custom_build/grpc_csharp_plugin+dotnet build myproject.csproj+```++## MSBuild Properties++You can set some Properties in your project file or on the MSBuild command line. The+following properties change the behavior of `Grpc.Tools`:++| Name                | Synopsis                                                                      |+|---------------------|-------------------------------------------------------------------------------|+| `Protobuf_ToolsOs`  | Same as `PROTOBUF_TOOLS_OS` environment variable                              |+| `Protobuf_ToolsCpu` | Same as `PROTOBUF_TOOLS_CPU` environment variable                             |+| `Protobuf_ProtocFullPath` | Same as `PROTOBUF_PROTOC` environment variable                          |+| `gRPC_PluginFullPath` | Same as `GRPC_PROTOC_PLUGIN` environment variable                           |+| `Protobuf_NoWarnMissingExpected` | Default: `false`. If `true` then no warnings are given if expected files not generated. See example below for an explanation. |+| `Protobuf_OutputPath`| Default: `IntermediateOutputPath` - ususally the `obj` directory. Sets the default value for `OutputDir` on `<Protobuf>` items.|++# Scenarios and Examples++For other examples see also the `.csproj` files in the examples in GitHub:+* Grpc-dotnet examples: https://github.com/grpc/grpc-dotnet/tree/master/examples+* Grpc c-core C# examples: https://github.com/grpc/grpc/tree/v1.46.x/examples/csharp++Quick links to the examples below:++* [AdditionalImportDirs - Setting location of imported `.proto` files](#AdditionalImportDirs)+* [ProtoRoot - Avoiding duplicate generated file names](#ProtoRoot)+* [GrpcServices - Generating gRPC services and protocol buffers messages](#grpcservices)+* [Generate proto and gRPC C# sources from .proto files (no C# compile)](#nocompile)+* [Visual Studio: setting per-file `.proto` file options](#visualstudio)+* [Bypassing Grpc.Tools to run the protocol buffers compiler explicitly](#compiler)++---+## <a name=""AdditionalImportDirs""></a>AdditionalImportDirs - Setting location of imported `.proto` files++If your `.proto` files import other files that are not co-located with the `.proto` file +you can specify the directories to search for the+imported files by specifying `AdditionalImportDirs` and provide a list of directories.+The directories are searched in the order given. E.g.:++```xml+  <Protobuf Include=""protos/*.proto"" ProtoRoot=""protos""+      AdditionalImportDirs=""/folder/protos/myapis/;/another/folder/""+      ... />+```++Note - the paths for standard imports included in the `Grpc.Tools` package are automatically passed to the protocol buffers compiler and do not need to be explicitly set.+E.g. the directory `""...\.nuget\packages\grpc.tools\2.51.0\build\native\include""` is automatically included.  This is the directory where a declaration such as `import ""google/protobuf/wrappers.proto"";` in a proto file would be found.++---+## <a name=""ProtoRoot""></a>ProtoRoot - Avoiding duplicate generated file names++`Grpc.Tools` tries to preserve the original directory structure relative to where the `.proto`+files are when creating the `.cs` files under the `obj` directory. It does this by using the+`ProtoRoot` metadata on the `<Protobuf>` items.++`ProtoRoot` specifies a common directory that is an ancestor of all `.proto` files, and the generated files under the `obj` directory will have the same directory structure. ++For `.proto` files under the project directory `ProtoRoot` is by default set to .. It can also be explicitly set. ++E.g.+Specifying `<Protobuf Include=""**\*.proto"" />` for files:+```+	ProjectFolder\Protos\v1\hello.proto+	ProjectFolder\Protos\v2\hello.proto+```+Will generate files:+```+  ProjectFolder\obj\Debug\net6.0\Protos\v1\Hello.cs+  ProjectFolder\obj\Debug\net6.0\Protos\v1\HelloGrpc.cs+  ProjectFolder\obj\Debug\net6.0\Protos\v2\Hello.cs+  ProjectFolder\obj\Debug\net6.0\Protos\v2\HelloGrpc.cs+```+But `<Protobuf Include=""**\*.proto"" ProtoRoot=""Protos"" />` will generate files:++```+  ProjectFolder\obj\Debug\net6.0\v1\Hello.cs+  ProjectFolder\obj\Debug\net6.0\v1\HelloGrpc.cs+  ProjectFolder\obj\Debug\net6.0\v2\Hello.cs+  ProjectFolder\obj\Debug\net6.0\v2\HelloGrpc.cs+```++Setting `ProtoRoot` is useful if you have `.proto` files from different directories,+e.g. some from inside the project and some external to the project, to make sure that structure+under the `obj` directory does not cause any name clashes.++---+## <a name=""grpcservices""></a>GrpcServices - Generating gRPC services and protocol buffers messages+The protocol buffers files (`.proto` files) define both the service interface and the+structure of the payload messages.++Two `.cs` file can be generated from a `.proto` file. For example, if the `.proto` file +is `myfile.proto` then the two possible files are:+* `Myfile.cs` - contains the generated code for protocol buffers messages+* `MyfileGrpc.cs`  - contains the generated code for gRPC client and/or server++When a `.proto` file contains service definitions the protocol buffers compiler calls+the gRPC plugin to generate gRPC client and/or server stub code. Whether or not the `*Grpc.cs` file+is generated and what it contains is controlled by the `GrpcServices` metadata+on the `<Protobuf>` item.++* `GrpcServices=""both""` (the default) - `Myfile.cs` and `MyfileGrpc.cs` generated+* `GrpcServices=""none""` - just `Myfile.cs` generated+* `GrpcServices=""client""` - `Myfile.cs` and `MyfileGrpc.cs` (just client code)+* `GrpcServices=""server""` - `Myfile.cs` and `MyfileGrpc.cs` (just server code)++However when a `.proto` **does not file contains any service definitions** but only contains+message definitions then an empty (zero length) `MyfileGrpc.cs` may still be created+by `Grpc.Tools` unless the `.proto` file is specified with `GrpcServices=""none""` in the project file.++This is because `Grpc.Tools` has no way of knowing in advanced of running the protocol buffers+compiler whether a `.proto` file has a service clause. It creates the emtpy files as a marker+for incremental builds so that the `.proto` files are not unnecessarily recompiled. Empty files+are not a problem on a small project but you may wish to avoid them on a larger project.++Therefore it is better to explicitly mark files with the correct `GrpcServices` metadata if you can. For+example:++```xml+<ItemGroup>+  <Protobuf Include=""**/*.proto"" GrpcServices=""None"" />+  <Protobuf Update=""**/hello/*.proto;**/bye/*.proto"" GrpcServices=""Both"" />+</ItemGroup>+```+In the above example all `.proto` files are compiled with `GrpcServices=""None""`, except for `.proto`+files in subdirectories on any tree level named `hello` and `bye`, which will take +`GrpcServices=""Both""`. Note the use of the `Update` attribute instead of `Include` - otherwise+the files would be added twice.++Another example would be the use of globbing if your service `.proto` files are named according+to a pattern, for example `*_services.proto`. In this case the `Update` attribute can be written+as `Update=""**/*_service.proto""` to set the attribute `GrpcServices=""Both""` only on these files.++### Seeing a warning about a missing expected file++If a `*Grpc.cs` file is not generated because the `.proto` file does not contain a service clause+(see above) then `Grpc.Tools` only creates empty files for files generated in the intermediate+`obj` directory. If the files are configured to be generated elsewhere then empty files are not+ created so as not to pollute non-intermediate directories. In this case a warning is output:+ ```+ Some expected protoc outputs were not generated+ ```+The warning can be suppressed by setting the MSBuild property:+```xml+<PropertyGroup>+  <Protobuf_NoWarnMissingExpected>true</Protobuf_NoWarnMissingExpected>+</PropertyGroup>+```+but it is better to set `GrpcServices=""None""` on the `.proto` files affected to avoid+unnecessary rebuilds. ++---+## <a name=""nocompile""></a>Generate proto and gRPC C# sources from .proto files (no C# compile)++If you just want to generate the C# sources from `.proto` files without compiling the C# files+ (e.g. for use in other projects) then you can do something similar to this to a `.csproj` file:+ ```xml+<ItemGroup>+  <Protobuf Include=""**/*.proto""+      OutputDir=""%(RelativeDir)"" CompileOutputs=""false""  />+</ItemGroup>+```++* `Include` tells the build system to recursively examine project directory and its +subdirectories (**) include all files matching the wildcard `*.proto`.+* `OutputDir=""%(RelativeDir)""` makes the output directory for each `.cs` file to be +same as the corresponding `.proto` directory.+* `CompileOutputs=""false""` prevents compiling the generated files into an assembly.++Note that an empty assembly is still generated which can be ignored. ++NOTE: To start with an empty project to add your `.proto` files to you can do the following+at a command prompt:+```bash+dotnet new classlib+rm *.cs              # remove .cs files - for Windows the command is: del *.cs /y+dotnet add package Grpc.Tools+``` ++---+## <a name=""visualstudio""></a>Visual Studio: setting per-file `.proto` file options ++In Visual Studio it is possible to set some frequently used per-file options on `.proto` files +without editing the `.csproj` file directly. However editing the `.csproj` gives you more+flexibilty.++### ""dotnet SDK"" projects++For a ""dotnet SDK"" project, you have more control of some frequently used options.+**You may need to open and close Visual Studio** for this form to appear in the+properties window after adding a reference to `Grpc.Tools` package:++![Properties in an SDK project](doc/integration.md-fig.2-sdk.png)++You can also change options of multiple files at once by selecting them in the+Project Explorer together.++### ""classic"" projects++For a ""classic"" project, you can only add `.proto` files with all options set to+default. Click on the ""show all files"" button, add files to project, then+change file type of the `.proto` files to ""Protobuf"" in the Properties window+drop-down. This menu item will appear after you import the `Grpc.Tools` package:++![Properties in a classic project](doc/integration.md-fig.1-classic.png)++---+## <a name=""compiler""></a>Bypassing Grpc.Tools to run the protocol buffers compiler explicitly","Since you already wrote the ""implementation_notes.md"", perhaps you should provide a link from somewhere in the users doc for those who are curious how Grpc.Tools works under the hoodhttps://github.com/grpc/grpc/blob/master/src/csharp/Grpc.Tools/implementation_notes.md",
85715732,yousukseung,https://api.github.com/repos/grpc/grpc/pulls/31904,1071636239,2023-01-16T23:54:36Z,src/core/ext/filters/client_channel/lb_policy/weighted_round_robin/weighted_round_robin.cc,"@@ -0,0 +1,955 @@+//+// Copyright 2022 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+//++#include <grpc/support/port_platform.h>++#include <inttypes.h>+#include <stdlib.h>+#include <string.h>++#include <algorithm>+#include <functional>+#include <map>+#include <memory>+#include <set>+#include <string>+#include <type_traits>+#include <utility>+#include <vector>++#include ""absl/base/thread_annotations.h""+#include ""absl/random/random.h""+#include ""absl/status/status.h""+#include ""absl/status/statusor.h""+#include ""absl/strings/str_cat.h""+#include ""absl/strings/str_join.h""+#include ""absl/strings/string_view.h""+#include ""absl/types/optional.h""++#include <grpc/event_engine/event_engine.h>+#include <grpc/impl/connectivity_state.h>+#include <grpc/support/log.h>++#include ""src/core/ext/filters/client_channel/lb_policy/backend_metric_data.h""+#include ""src/core/ext/filters/client_channel/lb_policy/oob_backend_metric.h""+#include ""src/core/ext/filters/client_channel/lb_policy/subchannel_list.h""+#include ""src/core/ext/filters/client_channel/lb_policy/weighted_round_robin/static_stride_scheduler.h""+#include ""src/core/lib/address_utils/sockaddr_utils.h""+#include ""src/core/lib/channel/channel_args.h""+#include ""src/core/lib/config/core_configuration.h""+#include ""src/core/lib/debug/trace.h""+#include ""src/core/lib/gprpp/debug_location.h""+#include ""src/core/lib/gprpp/orphanable.h""+#include ""src/core/lib/gprpp/ref_counted.h""+#include ""src/core/lib/gprpp/ref_counted_ptr.h""+#include ""src/core/lib/gprpp/sync.h""+#include ""src/core/lib/gprpp/time.h""+#include ""src/core/lib/gprpp/validation_errors.h""+#include ""src/core/lib/iomgr/exec_ctx.h""+#include ""src/core/lib/iomgr/resolved_address.h""+#include ""src/core/lib/json/json.h""+#include ""src/core/lib/json/json_args.h""+#include ""src/core/lib/json/json_object_loader.h""+#include ""src/core/lib/load_balancing/lb_policy.h""+#include ""src/core/lib/load_balancing/lb_policy_factory.h""+#include ""src/core/lib/load_balancing/subchannel_interface.h""+#include ""src/core/lib/resolver/server_address.h""+#include ""src/core/lib/transport/connectivity_state.h""++namespace grpc_core {++TraceFlag grpc_lb_wrr_trace(false, ""weighted_round_robin_lb"");++namespace {++constexpr absl::string_view kWeightedRoundRobin =+    ""weighted_round_robin_experimental"";++// Config for WRR policy.+class WeightedRoundRobinConfig : public LoadBalancingPolicy::Config {+ public:+  WeightedRoundRobinConfig() = default;++  WeightedRoundRobinConfig(const WeightedRoundRobinConfig&) = delete;+  WeightedRoundRobinConfig& operator=(const WeightedRoundRobinConfig&) = delete;++  WeightedRoundRobinConfig(WeightedRoundRobinConfig&&) = delete;+  WeightedRoundRobinConfig& operator=(WeightedRoundRobinConfig&&) = delete;++  absl::string_view name() const override { return kWeightedRoundRobin; }++  bool enable_oob_load_report() const { return enable_oob_load_report_; }+  Duration oob_reporting_period() const { return oob_reporting_period_; }+  Duration blackout_period() const { return blackout_period_; }+  Duration weight_update_period() const { return weight_update_period_; }+  Duration weight_expiration_period() const {+    return weight_expiration_period_;+  }++  static const JsonLoaderInterface* JsonLoader(const JsonArgs&) {+    static const auto* loader =+        JsonObjectLoader<WeightedRoundRobinConfig>()+            .OptionalField(""enableOobLoadReport"",+                           &WeightedRoundRobinConfig::enable_oob_load_report_)+            .OptionalField(""oobReportingPeriod"",+                           &WeightedRoundRobinConfig::oob_reporting_period_)+            .OptionalField(""blackoutPeriod"",+                           &WeightedRoundRobinConfig::blackout_period_)+            .OptionalField(""weightUpdatePeriod"",+                           &WeightedRoundRobinConfig::weight_update_period_)+            .OptionalField(""weightExpirationPeriod"",+                           &WeightedRoundRobinConfig::weight_expiration_period_)+            .Finish();+    return loader;+  }++  void JsonPostLoad(const Json&, const JsonArgs&, ValidationErrors*) {+    // Impose lower bound of 100ms on weightUpdatePeriod.+    weight_update_period_ =+        std::max(weight_update_period_, Duration::Milliseconds(100));+  }++ private:+  bool enable_oob_load_report_ = false;+  Duration oob_reporting_period_ = Duration::Seconds(10);+  Duration blackout_period_ = Duration::Seconds(10);+  Duration weight_update_period_ = Duration::Seconds(1);+  Duration weight_expiration_period_ = Duration::Minutes(3);+};++// WRR LB policy.+class WeightedRoundRobin : public LoadBalancingPolicy {+ public:+  explicit WeightedRoundRobin(Args args);++  absl::string_view name() const override { return kWeightedRoundRobin; }++  absl::Status UpdateLocked(UpdateArgs args) override;+  void ResetBackoffLocked() override;++ private:+  // Represents the weight for a given address.+  class AddressWeight : public RefCounted<AddressWeight> {+   public:+    AddressWeight(RefCountedPtr<WeightedRoundRobin> wrr, std::string key)+        : wrr_(std::move(wrr)), key_(std::move(key)) {}+    ~AddressWeight() override;++    void MaybeUpdateWeight(double qps, double cpu_utilization);++    float GetWeight(Timestamp now, Duration weight_expiration_period,+                    Duration blackout_period);++    void ResetNonEmptySince();++   private:+    RefCountedPtr<WeightedRoundRobin> wrr_;+    const std::string key_;++    Mutex mu_;+    float weight_ ABSL_GUARDED_BY(&mu_) = 0;+    Timestamp non_empty_since_ ABSL_GUARDED_BY(&mu_) = Timestamp::InfFuture();+    Timestamp last_update_time_ ABSL_GUARDED_BY(&mu_) = Timestamp::InfPast();+  };++  // Forward declaration.+  class WeightedRoundRobinSubchannelList;++  // Data for a particular subchannel in a subchannel list.+  // This subclass adds the following functionality:+  // - Tracks the previous connectivity state of the subchannel, so that+  //   we know how many subchannels are in each state.+  class WeightedRoundRobinSubchannelData+      : public SubchannelData<WeightedRoundRobinSubchannelList,+                              WeightedRoundRobinSubchannelData> {+   public:+    WeightedRoundRobinSubchannelData(+        SubchannelList<WeightedRoundRobinSubchannelList,+                       WeightedRoundRobinSubchannelData>* subchannel_list,+        const ServerAddress& address, RefCountedPtr<SubchannelInterface> sc);++    absl::optional<grpc_connectivity_state> connectivity_state() const {+      return logical_connectivity_state_;+    }++    RefCountedPtr<AddressWeight> weight() const { return weight_; }++   private:+    class OobWatcher : public OobBackendMetricWatcher {+     public:+      explicit OobWatcher(RefCountedPtr<AddressWeight> weight)+          : weight_(std::move(weight)) {}++      void OnBackendMetricReport(+          const BackendMetricData& backend_metric_data) override;++     private:+      RefCountedPtr<AddressWeight> weight_;+    };++    // Performs connectivity state updates that need to be done only+    // after we have started watching.+    void ProcessConnectivityChangeLocked(+        absl::optional<grpc_connectivity_state> old_state,+        grpc_connectivity_state new_state) override;++    // Updates the logical connectivity state.+    void UpdateLogicalConnectivityStateLocked(+        grpc_connectivity_state connectivity_state);++    // The logical connectivity state of the subchannel.+    // Note that the logical connectivity state may differ from the+    // actual reported state in some cases (e.g., after we see+    // TRANSIENT_FAILURE, we ignore any subsequent state changes until+    // we see READY).+    absl::optional<grpc_connectivity_state> logical_connectivity_state_;++    RefCountedPtr<AddressWeight> weight_;+  };++  // A list of subchannels.+  class WeightedRoundRobinSubchannelList+      : public SubchannelList<WeightedRoundRobinSubchannelList,+                              WeightedRoundRobinSubchannelData> {+   public:+    WeightedRoundRobinSubchannelList(WeightedRoundRobin* policy,+                                     ServerAddressList addresses,+                                     const ChannelArgs& args)+        : SubchannelList(policy,+                         (GRPC_TRACE_FLAG_ENABLED(grpc_lb_wrr_trace)+                              ? ""WeightedRoundRobinSubchannelList""+                              : nullptr),+                         std::move(addresses), policy->channel_control_helper(),+                         args) {+      // Need to maintain a ref to the LB policy as long as we maintain+      // any references to subchannels, since the subchannels'+      // pollset_sets will include the LB policy's pollset_set.+      policy->Ref(DEBUG_LOCATION, ""subchannel_list"").release();+    }++    ~WeightedRoundRobinSubchannelList() override {+      WeightedRoundRobin* p = static_cast<WeightedRoundRobin*>(policy());+      p->Unref(DEBUG_LOCATION, ""subchannel_list"");+    }++    // Updates the counters of subchannels in each state when a+    // subchannel transitions from old_state to new_state.+    void UpdateStateCountersLocked(+        absl::optional<grpc_connectivity_state> old_state,+        grpc_connectivity_state new_state);++    // Ensures that the right subchannel list is used and then updates+    // the aggregated connectivity state based on the subchannel list's+    // state counters.+    void MaybeUpdateAggregatedConnectivityStateLocked(+        absl::Status status_for_tf);++   private:+    std::string CountersString() const {+      return absl::StrCat(""num_subchannels="", num_subchannels(),+                          "" num_ready="", num_ready_,+                          "" num_connecting="", num_connecting_,+                          "" num_transient_failure="", num_transient_failure_);+    }++    size_t num_ready_ = 0;+    size_t num_connecting_ = 0;+    size_t num_transient_failure_ = 0;++    absl::Status last_failure_;+  };++  // A picker that performs WRR picks with weights based on+  // endpoint-reported utilization and QPS.+  class Picker : public SubchannelPicker {+   public:+    Picker(RefCountedPtr<WeightedRoundRobin> wrr,+           WeightedRoundRobinSubchannelList* subchannel_list);++    ~Picker() override;++    PickResult Pick(PickArgs args) override;++    void Orphan() override;++   private:+    // A call tracker that collects per-call endpoint utilization reports.+    class SubchannelCallTracker : public SubchannelCallTrackerInterface {+     public:+      explicit SubchannelCallTracker(RefCountedPtr<AddressWeight> weight)+          : weight_(std::move(weight)) {}++      void Start() override {}++      void Finish(FinishArgs args) override;++     private:+      RefCountedPtr<AddressWeight> weight_;+    };++    // Info stored about each subchannel.+    struct SubchannelInfo {+      SubchannelInfo(RefCountedPtr<SubchannelInterface> subchannel,+                     RefCountedPtr<AddressWeight> weight)+          : subchannel(std::move(subchannel)), weight(std::move(weight)) {}++      RefCountedPtr<SubchannelInterface> subchannel;+      RefCountedPtr<AddressWeight> weight;+    };++    // Returns the index into subchannels_ to be picked.+    size_t PickIndex();++    // Builds a new scheduler and swaps it into place, then starts a+    // timer for the next update.+    void BuildSchedulerAndStartTimerLocked()+        ABSL_EXCLUSIVE_LOCKS_REQUIRED(&mu_);++    RefCountedPtr<WeightedRoundRobin> wrr_;+    const bool use_per_rpc_utilization_;+    const Duration weight_update_period_;+    const Duration weight_expiration_period_;+    const Duration blackout_period_;+    std::vector<SubchannelInfo> subchannels_;++    Mutex mu_;+    uint32_t scheduler_state_ ABSL_GUARDED_BY(&mu_);","This is persistent (part of WRR instance) in the design/Stubby and it is one of important properties, also mentioned in go/static-stride-scheduler#concurrency. If we start a new randomized counter every 1s, it just becomes a random weighted random selection. Its impact to longer term balancing (esp. with low qps) is not simple for us to guess, given we assume a big majority of weight updates will not involve no changes in the subchannel set with weights remain reasonably stable. The static stride scheduler does not exactly implement the original Strider paper regarding the weight update, but the persisted counter is an approximation AFAICT.That being said, the design proposes this to be a lambda in the WRR policy that encapsulates an atomic int.",
85715732,yousukseung,https://api.github.com/repos/grpc/grpc/pulls/31904,1071637203,2023-01-16T23:58:37Z,src/core/ext/filters/client_channel/lb_policy/weighted_round_robin/weighted_round_robin.cc,"@@ -0,0 +1,955 @@+//+// Copyright 2022 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+//++#include <grpc/support/port_platform.h>++#include <inttypes.h>+#include <stdlib.h>+#include <string.h>++#include <algorithm>+#include <functional>+#include <map>+#include <memory>+#include <set>+#include <string>+#include <type_traits>+#include <utility>+#include <vector>++#include ""absl/base/thread_annotations.h""+#include ""absl/random/random.h""+#include ""absl/status/status.h""+#include ""absl/status/statusor.h""+#include ""absl/strings/str_cat.h""+#include ""absl/strings/str_join.h""+#include ""absl/strings/string_view.h""+#include ""absl/types/optional.h""++#include <grpc/event_engine/event_engine.h>+#include <grpc/impl/connectivity_state.h>+#include <grpc/support/log.h>++#include ""src/core/ext/filters/client_channel/lb_policy/backend_metric_data.h""+#include ""src/core/ext/filters/client_channel/lb_policy/oob_backend_metric.h""+#include ""src/core/ext/filters/client_channel/lb_policy/subchannel_list.h""+#include ""src/core/ext/filters/client_channel/lb_policy/weighted_round_robin/static_stride_scheduler.h""+#include ""src/core/lib/address_utils/sockaddr_utils.h""+#include ""src/core/lib/channel/channel_args.h""+#include ""src/core/lib/config/core_configuration.h""+#include ""src/core/lib/debug/trace.h""+#include ""src/core/lib/gprpp/debug_location.h""+#include ""src/core/lib/gprpp/orphanable.h""+#include ""src/core/lib/gprpp/ref_counted.h""+#include ""src/core/lib/gprpp/ref_counted_ptr.h""+#include ""src/core/lib/gprpp/sync.h""+#include ""src/core/lib/gprpp/time.h""+#include ""src/core/lib/gprpp/validation_errors.h""+#include ""src/core/lib/iomgr/exec_ctx.h""+#include ""src/core/lib/iomgr/resolved_address.h""+#include ""src/core/lib/json/json.h""+#include ""src/core/lib/json/json_args.h""+#include ""src/core/lib/json/json_object_loader.h""+#include ""src/core/lib/load_balancing/lb_policy.h""+#include ""src/core/lib/load_balancing/lb_policy_factory.h""+#include ""src/core/lib/load_balancing/subchannel_interface.h""+#include ""src/core/lib/resolver/server_address.h""+#include ""src/core/lib/transport/connectivity_state.h""++namespace grpc_core {++TraceFlag grpc_lb_wrr_trace(false, ""weighted_round_robin_lb"");++namespace {++constexpr absl::string_view kWeightedRoundRobin =+    ""weighted_round_robin_experimental"";++// Config for WRR policy.+class WeightedRoundRobinConfig : public LoadBalancingPolicy::Config {+ public:+  WeightedRoundRobinConfig() = default;++  WeightedRoundRobinConfig(const WeightedRoundRobinConfig&) = delete;+  WeightedRoundRobinConfig& operator=(const WeightedRoundRobinConfig&) = delete;++  WeightedRoundRobinConfig(WeightedRoundRobinConfig&&) = delete;+  WeightedRoundRobinConfig& operator=(WeightedRoundRobinConfig&&) = delete;++  absl::string_view name() const override { return kWeightedRoundRobin; }++  bool enable_oob_load_report() const { return enable_oob_load_report_; }+  Duration oob_reporting_period() const { return oob_reporting_period_; }+  Duration blackout_period() const { return blackout_period_; }+  Duration weight_update_period() const { return weight_update_period_; }+  Duration weight_expiration_period() const {+    return weight_expiration_period_;+  }++  static const JsonLoaderInterface* JsonLoader(const JsonArgs&) {+    static const auto* loader =+        JsonObjectLoader<WeightedRoundRobinConfig>()+            .OptionalField(""enableOobLoadReport"",+                           &WeightedRoundRobinConfig::enable_oob_load_report_)+            .OptionalField(""oobReportingPeriod"",+                           &WeightedRoundRobinConfig::oob_reporting_period_)+            .OptionalField(""blackoutPeriod"",+                           &WeightedRoundRobinConfig::blackout_period_)+            .OptionalField(""weightUpdatePeriod"",+                           &WeightedRoundRobinConfig::weight_update_period_)+            .OptionalField(""weightExpirationPeriod"",+                           &WeightedRoundRobinConfig::weight_expiration_period_)+            .Finish();+    return loader;+  }++  void JsonPostLoad(const Json&, const JsonArgs&, ValidationErrors*) {+    // Impose lower bound of 100ms on weightUpdatePeriod.+    weight_update_period_ =+        std::max(weight_update_period_, Duration::Milliseconds(100));+  }++ private:+  bool enable_oob_load_report_ = false;+  Duration oob_reporting_period_ = Duration::Seconds(10);+  Duration blackout_period_ = Duration::Seconds(10);+  Duration weight_update_period_ = Duration::Seconds(1);+  Duration weight_expiration_period_ = Duration::Minutes(3);+};++// WRR LB policy.+class WeightedRoundRobin : public LoadBalancingPolicy {+ public:+  explicit WeightedRoundRobin(Args args);++  absl::string_view name() const override { return kWeightedRoundRobin; }++  absl::Status UpdateLocked(UpdateArgs args) override;+  void ResetBackoffLocked() override;++ private:+  // Represents the weight for a given address.+  class AddressWeight : public RefCounted<AddressWeight> {+   public:+    AddressWeight(RefCountedPtr<WeightedRoundRobin> wrr, std::string key)+        : wrr_(std::move(wrr)), key_(std::move(key)) {}+    ~AddressWeight() override;++    void MaybeUpdateWeight(double qps, double cpu_utilization);++    float GetWeight(Timestamp now, Duration weight_expiration_period,+                    Duration blackout_period);++    void ResetNonEmptySince();++   private:+    RefCountedPtr<WeightedRoundRobin> wrr_;+    const std::string key_;++    Mutex mu_;+    float weight_ ABSL_GUARDED_BY(&mu_) = 0;+    Timestamp non_empty_since_ ABSL_GUARDED_BY(&mu_) = Timestamp::InfFuture();+    Timestamp last_update_time_ ABSL_GUARDED_BY(&mu_) = Timestamp::InfPast();+  };++  // Forward declaration.+  class WeightedRoundRobinSubchannelList;++  // Data for a particular subchannel in a subchannel list.+  // This subclass adds the following functionality:+  // - Tracks the previous connectivity state of the subchannel, so that+  //   we know how many subchannels are in each state.+  class WeightedRoundRobinSubchannelData+      : public SubchannelData<WeightedRoundRobinSubchannelList,+                              WeightedRoundRobinSubchannelData> {+   public:+    WeightedRoundRobinSubchannelData(+        SubchannelList<WeightedRoundRobinSubchannelList,+                       WeightedRoundRobinSubchannelData>* subchannel_list,+        const ServerAddress& address, RefCountedPtr<SubchannelInterface> sc);++    absl::optional<grpc_connectivity_state> connectivity_state() const {+      return logical_connectivity_state_;+    }++    RefCountedPtr<AddressWeight> weight() const { return weight_; }++   private:+    class OobWatcher : public OobBackendMetricWatcher {+     public:+      explicit OobWatcher(RefCountedPtr<AddressWeight> weight)+          : weight_(std::move(weight)) {}++      void OnBackendMetricReport(+          const BackendMetricData& backend_metric_data) override;++     private:+      RefCountedPtr<AddressWeight> weight_;+    };++    // Performs connectivity state updates that need to be done only+    // after we have started watching.+    void ProcessConnectivityChangeLocked(+        absl::optional<grpc_connectivity_state> old_state,+        grpc_connectivity_state new_state) override;++    // Updates the logical connectivity state.+    void UpdateLogicalConnectivityStateLocked(+        grpc_connectivity_state connectivity_state);++    // The logical connectivity state of the subchannel.+    // Note that the logical connectivity state may differ from the+    // actual reported state in some cases (e.g., after we see+    // TRANSIENT_FAILURE, we ignore any subsequent state changes until+    // we see READY).+    absl::optional<grpc_connectivity_state> logical_connectivity_state_;++    RefCountedPtr<AddressWeight> weight_;+  };++  // A list of subchannels.+  class WeightedRoundRobinSubchannelList+      : public SubchannelList<WeightedRoundRobinSubchannelList,+                              WeightedRoundRobinSubchannelData> {+   public:+    WeightedRoundRobinSubchannelList(WeightedRoundRobin* policy,+                                     ServerAddressList addresses,+                                     const ChannelArgs& args)+        : SubchannelList(policy,+                         (GRPC_TRACE_FLAG_ENABLED(grpc_lb_wrr_trace)+                              ? ""WeightedRoundRobinSubchannelList""+                              : nullptr),+                         std::move(addresses), policy->channel_control_helper(),+                         args) {+      // Need to maintain a ref to the LB policy as long as we maintain+      // any references to subchannels, since the subchannels'+      // pollset_sets will include the LB policy's pollset_set.+      policy->Ref(DEBUG_LOCATION, ""subchannel_list"").release();+    }++    ~WeightedRoundRobinSubchannelList() override {+      WeightedRoundRobin* p = static_cast<WeightedRoundRobin*>(policy());+      p->Unref(DEBUG_LOCATION, ""subchannel_list"");+    }++    // Updates the counters of subchannels in each state when a+    // subchannel transitions from old_state to new_state.+    void UpdateStateCountersLocked(+        absl::optional<grpc_connectivity_state> old_state,+        grpc_connectivity_state new_state);++    // Ensures that the right subchannel list is used and then updates+    // the aggregated connectivity state based on the subchannel list's+    // state counters.+    void MaybeUpdateAggregatedConnectivityStateLocked(+        absl::Status status_for_tf);++   private:+    std::string CountersString() const {+      return absl::StrCat(""num_subchannels="", num_subchannels(),+                          "" num_ready="", num_ready_,+                          "" num_connecting="", num_connecting_,+                          "" num_transient_failure="", num_transient_failure_);+    }++    size_t num_ready_ = 0;+    size_t num_connecting_ = 0;+    size_t num_transient_failure_ = 0;++    absl::Status last_failure_;+  };++  // A picker that performs WRR picks with weights based on+  // endpoint-reported utilization and QPS.+  class Picker : public SubchannelPicker {+   public:+    Picker(RefCountedPtr<WeightedRoundRobin> wrr,+           WeightedRoundRobinSubchannelList* subchannel_list);++    ~Picker() override;++    PickResult Pick(PickArgs args) override;++    void Orphan() override;++   private:+    // A call tracker that collects per-call endpoint utilization reports.+    class SubchannelCallTracker : public SubchannelCallTrackerInterface {+     public:+      explicit SubchannelCallTracker(RefCountedPtr<AddressWeight> weight)+          : weight_(std::move(weight)) {}++      void Start() override {}++      void Finish(FinishArgs args) override;++     private:+      RefCountedPtr<AddressWeight> weight_;+    };++    // Info stored about each subchannel.+    struct SubchannelInfo {+      SubchannelInfo(RefCountedPtr<SubchannelInterface> subchannel,+                     RefCountedPtr<AddressWeight> weight)+          : subchannel(std::move(subchannel)), weight(std::move(weight)) {}++      RefCountedPtr<SubchannelInterface> subchannel;+      RefCountedPtr<AddressWeight> weight;+    };++    // Returns the index into subchannels_ to be picked.+    size_t PickIndex();++    // Builds a new scheduler and swaps it into place, then starts a+    // timer for the next update.+    void BuildSchedulerAndStartTimerLocked()+        ABSL_EXCLUSIVE_LOCKS_REQUIRED(&mu_);++    RefCountedPtr<WeightedRoundRobin> wrr_;+    const bool use_per_rpc_utilization_;+    const Duration weight_update_period_;+    const Duration weight_expiration_period_;+    const Duration blackout_period_;+    std::vector<SubchannelInfo> subchannels_;++    Mutex mu_;+    uint32_t scheduler_state_ ABSL_GUARDED_BY(&mu_);+    absl::optional<StaticStrideScheduler> scheduler_ ABSL_GUARDED_BY(&mu_);+    absl::optional<grpc_event_engine::experimental::EventEngine::TaskHandle>+        timer_handle_ ABSL_GUARDED_BY(&mu_);++    // Used when falling back to RR.+    size_t last_picked_index_;","We can use the persisted scheduler_state_, and I think we should. Similar to the above mentioned reason, in case this remains in RR for long, using the persisted counter is superior in terms of guaranteeing long-term balance.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/31904,1072407751,2023-01-17T16:10:22Z,src/core/ext/filters/client_channel/lb_policy/weighted_round_robin/weighted_round_robin.cc,"@@ -0,0 +1,955 @@+//+// Copyright 2022 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+//++#include <grpc/support/port_platform.h>++#include <inttypes.h>+#include <stdlib.h>+#include <string.h>++#include <algorithm>+#include <functional>+#include <map>+#include <memory>+#include <set>+#include <string>+#include <type_traits>+#include <utility>+#include <vector>++#include ""absl/base/thread_annotations.h""+#include ""absl/random/random.h""+#include ""absl/status/status.h""+#include ""absl/status/statusor.h""+#include ""absl/strings/str_cat.h""+#include ""absl/strings/str_join.h""+#include ""absl/strings/string_view.h""+#include ""absl/types/optional.h""++#include <grpc/event_engine/event_engine.h>+#include <grpc/impl/connectivity_state.h>+#include <grpc/support/log.h>++#include ""src/core/ext/filters/client_channel/lb_policy/backend_metric_data.h""+#include ""src/core/ext/filters/client_channel/lb_policy/oob_backend_metric.h""+#include ""src/core/ext/filters/client_channel/lb_policy/subchannel_list.h""+#include ""src/core/ext/filters/client_channel/lb_policy/weighted_round_robin/static_stride_scheduler.h""+#include ""src/core/lib/address_utils/sockaddr_utils.h""+#include ""src/core/lib/channel/channel_args.h""+#include ""src/core/lib/config/core_configuration.h""+#include ""src/core/lib/debug/trace.h""+#include ""src/core/lib/gprpp/debug_location.h""+#include ""src/core/lib/gprpp/orphanable.h""+#include ""src/core/lib/gprpp/ref_counted.h""+#include ""src/core/lib/gprpp/ref_counted_ptr.h""+#include ""src/core/lib/gprpp/sync.h""+#include ""src/core/lib/gprpp/time.h""+#include ""src/core/lib/gprpp/validation_errors.h""+#include ""src/core/lib/iomgr/exec_ctx.h""+#include ""src/core/lib/iomgr/resolved_address.h""+#include ""src/core/lib/json/json.h""+#include ""src/core/lib/json/json_args.h""+#include ""src/core/lib/json/json_object_loader.h""+#include ""src/core/lib/load_balancing/lb_policy.h""+#include ""src/core/lib/load_balancing/lb_policy_factory.h""+#include ""src/core/lib/load_balancing/subchannel_interface.h""+#include ""src/core/lib/resolver/server_address.h""+#include ""src/core/lib/transport/connectivity_state.h""++namespace grpc_core {++TraceFlag grpc_lb_wrr_trace(false, ""weighted_round_robin_lb"");++namespace {++constexpr absl::string_view kWeightedRoundRobin =+    ""weighted_round_robin_experimental"";++// Config for WRR policy.+class WeightedRoundRobinConfig : public LoadBalancingPolicy::Config {+ public:+  WeightedRoundRobinConfig() = default;++  WeightedRoundRobinConfig(const WeightedRoundRobinConfig&) = delete;+  WeightedRoundRobinConfig& operator=(const WeightedRoundRobinConfig&) = delete;++  WeightedRoundRobinConfig(WeightedRoundRobinConfig&&) = delete;+  WeightedRoundRobinConfig& operator=(WeightedRoundRobinConfig&&) = delete;++  absl::string_view name() const override { return kWeightedRoundRobin; }++  bool enable_oob_load_report() const { return enable_oob_load_report_; }+  Duration oob_reporting_period() const { return oob_reporting_period_; }+  Duration blackout_period() const { return blackout_period_; }+  Duration weight_update_period() const { return weight_update_period_; }+  Duration weight_expiration_period() const {+    return weight_expiration_period_;+  }++  static const JsonLoaderInterface* JsonLoader(const JsonArgs&) {+    static const auto* loader =+        JsonObjectLoader<WeightedRoundRobinConfig>()+            .OptionalField(""enableOobLoadReport"",+                           &WeightedRoundRobinConfig::enable_oob_load_report_)+            .OptionalField(""oobReportingPeriod"",+                           &WeightedRoundRobinConfig::oob_reporting_period_)+            .OptionalField(""blackoutPeriod"",+                           &WeightedRoundRobinConfig::blackout_period_)+            .OptionalField(""weightUpdatePeriod"",+                           &WeightedRoundRobinConfig::weight_update_period_)+            .OptionalField(""weightExpirationPeriod"",+                           &WeightedRoundRobinConfig::weight_expiration_period_)+            .Finish();+    return loader;+  }++  void JsonPostLoad(const Json&, const JsonArgs&, ValidationErrors*) {+    // Impose lower bound of 100ms on weightUpdatePeriod.+    weight_update_period_ =+        std::max(weight_update_period_, Duration::Milliseconds(100));+  }++ private:+  bool enable_oob_load_report_ = false;+  Duration oob_reporting_period_ = Duration::Seconds(10);+  Duration blackout_period_ = Duration::Seconds(10);+  Duration weight_update_period_ = Duration::Seconds(1);+  Duration weight_expiration_period_ = Duration::Minutes(3);+};++// WRR LB policy.+class WeightedRoundRobin : public LoadBalancingPolicy {+ public:+  explicit WeightedRoundRobin(Args args);++  absl::string_view name() const override { return kWeightedRoundRobin; }++  absl::Status UpdateLocked(UpdateArgs args) override;+  void ResetBackoffLocked() override;++ private:+  // Represents the weight for a given address.+  class AddressWeight : public RefCounted<AddressWeight> {+   public:+    AddressWeight(RefCountedPtr<WeightedRoundRobin> wrr, std::string key)+        : wrr_(std::move(wrr)), key_(std::move(key)) {}+    ~AddressWeight() override;++    void MaybeUpdateWeight(double qps, double cpu_utilization);++    float GetWeight(Timestamp now, Duration weight_expiration_period,+                    Duration blackout_period);++    void ResetNonEmptySince();++   private:+    RefCountedPtr<WeightedRoundRobin> wrr_;+    const std::string key_;++    Mutex mu_;+    float weight_ ABSL_GUARDED_BY(&mu_) = 0;+    Timestamp non_empty_since_ ABSL_GUARDED_BY(&mu_) = Timestamp::InfFuture();+    Timestamp last_update_time_ ABSL_GUARDED_BY(&mu_) = Timestamp::InfPast();+  };++  // Forward declaration.+  class WeightedRoundRobinSubchannelList;++  // Data for a particular subchannel in a subchannel list.+  // This subclass adds the following functionality:+  // - Tracks the previous connectivity state of the subchannel, so that+  //   we know how many subchannels are in each state.+  class WeightedRoundRobinSubchannelData+      : public SubchannelData<WeightedRoundRobinSubchannelList,+                              WeightedRoundRobinSubchannelData> {+   public:+    WeightedRoundRobinSubchannelData(+        SubchannelList<WeightedRoundRobinSubchannelList,+                       WeightedRoundRobinSubchannelData>* subchannel_list,+        const ServerAddress& address, RefCountedPtr<SubchannelInterface> sc);++    absl::optional<grpc_connectivity_state> connectivity_state() const {+      return logical_connectivity_state_;+    }++    RefCountedPtr<AddressWeight> weight() const { return weight_; }++   private:+    class OobWatcher : public OobBackendMetricWatcher {+     public:+      explicit OobWatcher(RefCountedPtr<AddressWeight> weight)+          : weight_(std::move(weight)) {}++      void OnBackendMetricReport(+          const BackendMetricData& backend_metric_data) override;++     private:+      RefCountedPtr<AddressWeight> weight_;+    };++    // Performs connectivity state updates that need to be done only+    // after we have started watching.+    void ProcessConnectivityChangeLocked(+        absl::optional<grpc_connectivity_state> old_state,+        grpc_connectivity_state new_state) override;++    // Updates the logical connectivity state.+    void UpdateLogicalConnectivityStateLocked(+        grpc_connectivity_state connectivity_state);++    // The logical connectivity state of the subchannel.+    // Note that the logical connectivity state may differ from the+    // actual reported state in some cases (e.g., after we see+    // TRANSIENT_FAILURE, we ignore any subsequent state changes until+    // we see READY).+    absl::optional<grpc_connectivity_state> logical_connectivity_state_;++    RefCountedPtr<AddressWeight> weight_;+  };++  // A list of subchannels.+  class WeightedRoundRobinSubchannelList+      : public SubchannelList<WeightedRoundRobinSubchannelList,+                              WeightedRoundRobinSubchannelData> {+   public:+    WeightedRoundRobinSubchannelList(WeightedRoundRobin* policy,+                                     ServerAddressList addresses,+                                     const ChannelArgs& args)+        : SubchannelList(policy,+                         (GRPC_TRACE_FLAG_ENABLED(grpc_lb_wrr_trace)+                              ? ""WeightedRoundRobinSubchannelList""+                              : nullptr),+                         std::move(addresses), policy->channel_control_helper(),+                         args) {+      // Need to maintain a ref to the LB policy as long as we maintain+      // any references to subchannels, since the subchannels'+      // pollset_sets will include the LB policy's pollset_set.+      policy->Ref(DEBUG_LOCATION, ""subchannel_list"").release();+    }++    ~WeightedRoundRobinSubchannelList() override {+      WeightedRoundRobin* p = static_cast<WeightedRoundRobin*>(policy());+      p->Unref(DEBUG_LOCATION, ""subchannel_list"");+    }++    // Updates the counters of subchannels in each state when a+    // subchannel transitions from old_state to new_state.+    void UpdateStateCountersLocked(+        absl::optional<grpc_connectivity_state> old_state,+        grpc_connectivity_state new_state);++    // Ensures that the right subchannel list is used and then updates+    // the aggregated connectivity state based on the subchannel list's+    // state counters.+    void MaybeUpdateAggregatedConnectivityStateLocked(+        absl::Status status_for_tf);++   private:+    std::string CountersString() const {+      return absl::StrCat(""num_subchannels="", num_subchannels(),+                          "" num_ready="", num_ready_,+                          "" num_connecting="", num_connecting_,+                          "" num_transient_failure="", num_transient_failure_);+    }++    size_t num_ready_ = 0;+    size_t num_connecting_ = 0;+    size_t num_transient_failure_ = 0;++    absl::Status last_failure_;+  };++  // A picker that performs WRR picks with weights based on+  // endpoint-reported utilization and QPS.+  class Picker : public SubchannelPicker {+   public:+    Picker(RefCountedPtr<WeightedRoundRobin> wrr,+           WeightedRoundRobinSubchannelList* subchannel_list);++    ~Picker() override;++    PickResult Pick(PickArgs args) override;++    void Orphan() override;++   private:+    // A call tracker that collects per-call endpoint utilization reports.+    class SubchannelCallTracker : public SubchannelCallTrackerInterface {+     public:+      explicit SubchannelCallTracker(RefCountedPtr<AddressWeight> weight)+          : weight_(std::move(weight)) {}++      void Start() override {}++      void Finish(FinishArgs args) override;++     private:+      RefCountedPtr<AddressWeight> weight_;+    };++    // Info stored about each subchannel.+    struct SubchannelInfo {+      SubchannelInfo(RefCountedPtr<SubchannelInterface> subchannel,+                     RefCountedPtr<AddressWeight> weight)+          : subchannel(std::move(subchannel)), weight(std::move(weight)) {}++      RefCountedPtr<SubchannelInterface> subchannel;+      RefCountedPtr<AddressWeight> weight;+    };++    // Returns the index into subchannels_ to be picked.+    size_t PickIndex();++    // Builds a new scheduler and swaps it into place, then starts a+    // timer for the next update.+    void BuildSchedulerAndStartTimerLocked()+        ABSL_EXCLUSIVE_LOCKS_REQUIRED(&mu_);++    RefCountedPtr<WeightedRoundRobin> wrr_;+    const bool use_per_rpc_utilization_;+    const Duration weight_update_period_;+    const Duration weight_expiration_period_;+    const Duration blackout_period_;+    std::vector<SubchannelInfo> subchannels_;++    Mutex mu_;+    uint32_t scheduler_state_ ABSL_GUARDED_BY(&mu_);","Is this comment just informational, or are you actually pointing out a problem or requesting a change here?  I think what the code currently implements is exactly what you describe here: this state is persistent for the lifetime of the picker; it does not get updated when the scheduler is updated.  The only time it changes is when we generate a new picker, which happens when the address list changes or when a subchannel's connectivity state changes.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/31904,1072419493,2023-01-17T16:19:24Z,src/core/ext/filters/client_channel/lb_policy/weighted_round_robin/weighted_round_robin.cc,"@@ -0,0 +1,955 @@+//+// Copyright 2022 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+//++#include <grpc/support/port_platform.h>++#include <inttypes.h>+#include <stdlib.h>+#include <string.h>++#include <algorithm>+#include <functional>+#include <map>+#include <memory>+#include <set>+#include <string>+#include <type_traits>+#include <utility>+#include <vector>++#include ""absl/base/thread_annotations.h""+#include ""absl/random/random.h""+#include ""absl/status/status.h""+#include ""absl/status/statusor.h""+#include ""absl/strings/str_cat.h""+#include ""absl/strings/str_join.h""+#include ""absl/strings/string_view.h""+#include ""absl/types/optional.h""++#include <grpc/event_engine/event_engine.h>+#include <grpc/impl/connectivity_state.h>+#include <grpc/support/log.h>++#include ""src/core/ext/filters/client_channel/lb_policy/backend_metric_data.h""+#include ""src/core/ext/filters/client_channel/lb_policy/oob_backend_metric.h""+#include ""src/core/ext/filters/client_channel/lb_policy/subchannel_list.h""+#include ""src/core/ext/filters/client_channel/lb_policy/weighted_round_robin/static_stride_scheduler.h""+#include ""src/core/lib/address_utils/sockaddr_utils.h""+#include ""src/core/lib/channel/channel_args.h""+#include ""src/core/lib/config/core_configuration.h""+#include ""src/core/lib/debug/trace.h""+#include ""src/core/lib/gprpp/debug_location.h""+#include ""src/core/lib/gprpp/orphanable.h""+#include ""src/core/lib/gprpp/ref_counted.h""+#include ""src/core/lib/gprpp/ref_counted_ptr.h""+#include ""src/core/lib/gprpp/sync.h""+#include ""src/core/lib/gprpp/time.h""+#include ""src/core/lib/gprpp/validation_errors.h""+#include ""src/core/lib/iomgr/exec_ctx.h""+#include ""src/core/lib/iomgr/resolved_address.h""+#include ""src/core/lib/json/json.h""+#include ""src/core/lib/json/json_args.h""+#include ""src/core/lib/json/json_object_loader.h""+#include ""src/core/lib/load_balancing/lb_policy.h""+#include ""src/core/lib/load_balancing/lb_policy_factory.h""+#include ""src/core/lib/load_balancing/subchannel_interface.h""+#include ""src/core/lib/resolver/server_address.h""+#include ""src/core/lib/transport/connectivity_state.h""++namespace grpc_core {++TraceFlag grpc_lb_wrr_trace(false, ""weighted_round_robin_lb"");++namespace {++constexpr absl::string_view kWeightedRoundRobin =+    ""weighted_round_robin_experimental"";++// Config for WRR policy.+class WeightedRoundRobinConfig : public LoadBalancingPolicy::Config {+ public:+  WeightedRoundRobinConfig() = default;++  WeightedRoundRobinConfig(const WeightedRoundRobinConfig&) = delete;+  WeightedRoundRobinConfig& operator=(const WeightedRoundRobinConfig&) = delete;++  WeightedRoundRobinConfig(WeightedRoundRobinConfig&&) = delete;+  WeightedRoundRobinConfig& operator=(WeightedRoundRobinConfig&&) = delete;++  absl::string_view name() const override { return kWeightedRoundRobin; }++  bool enable_oob_load_report() const { return enable_oob_load_report_; }+  Duration oob_reporting_period() const { return oob_reporting_period_; }+  Duration blackout_period() const { return blackout_period_; }+  Duration weight_update_period() const { return weight_update_period_; }+  Duration weight_expiration_period() const {+    return weight_expiration_period_;+  }++  static const JsonLoaderInterface* JsonLoader(const JsonArgs&) {+    static const auto* loader =+        JsonObjectLoader<WeightedRoundRobinConfig>()+            .OptionalField(""enableOobLoadReport"",+                           &WeightedRoundRobinConfig::enable_oob_load_report_)+            .OptionalField(""oobReportingPeriod"",+                           &WeightedRoundRobinConfig::oob_reporting_period_)+            .OptionalField(""blackoutPeriod"",+                           &WeightedRoundRobinConfig::blackout_period_)+            .OptionalField(""weightUpdatePeriod"",+                           &WeightedRoundRobinConfig::weight_update_period_)+            .OptionalField(""weightExpirationPeriod"",+                           &WeightedRoundRobinConfig::weight_expiration_period_)+            .Finish();+    return loader;+  }++  void JsonPostLoad(const Json&, const JsonArgs&, ValidationErrors*) {+    // Impose lower bound of 100ms on weightUpdatePeriod.+    weight_update_period_ =+        std::max(weight_update_period_, Duration::Milliseconds(100));+  }++ private:+  bool enable_oob_load_report_ = false;+  Duration oob_reporting_period_ = Duration::Seconds(10);+  Duration blackout_period_ = Duration::Seconds(10);+  Duration weight_update_period_ = Duration::Seconds(1);+  Duration weight_expiration_period_ = Duration::Minutes(3);+};++// WRR LB policy.+class WeightedRoundRobin : public LoadBalancingPolicy {+ public:+  explicit WeightedRoundRobin(Args args);++  absl::string_view name() const override { return kWeightedRoundRobin; }++  absl::Status UpdateLocked(UpdateArgs args) override;+  void ResetBackoffLocked() override;++ private:+  // Represents the weight for a given address.+  class AddressWeight : public RefCounted<AddressWeight> {+   public:+    AddressWeight(RefCountedPtr<WeightedRoundRobin> wrr, std::string key)+        : wrr_(std::move(wrr)), key_(std::move(key)) {}+    ~AddressWeight() override;++    void MaybeUpdateWeight(double qps, double cpu_utilization);++    float GetWeight(Timestamp now, Duration weight_expiration_period,+                    Duration blackout_period);++    void ResetNonEmptySince();++   private:+    RefCountedPtr<WeightedRoundRobin> wrr_;+    const std::string key_;++    Mutex mu_;+    float weight_ ABSL_GUARDED_BY(&mu_) = 0;+    Timestamp non_empty_since_ ABSL_GUARDED_BY(&mu_) = Timestamp::InfFuture();+    Timestamp last_update_time_ ABSL_GUARDED_BY(&mu_) = Timestamp::InfPast();+  };++  // Forward declaration.+  class WeightedRoundRobinSubchannelList;++  // Data for a particular subchannel in a subchannel list.+  // This subclass adds the following functionality:+  // - Tracks the previous connectivity state of the subchannel, so that+  //   we know how many subchannels are in each state.+  class WeightedRoundRobinSubchannelData+      : public SubchannelData<WeightedRoundRobinSubchannelList,+                              WeightedRoundRobinSubchannelData> {+   public:+    WeightedRoundRobinSubchannelData(+        SubchannelList<WeightedRoundRobinSubchannelList,+                       WeightedRoundRobinSubchannelData>* subchannel_list,+        const ServerAddress& address, RefCountedPtr<SubchannelInterface> sc);++    absl::optional<grpc_connectivity_state> connectivity_state() const {+      return logical_connectivity_state_;+    }++    RefCountedPtr<AddressWeight> weight() const { return weight_; }++   private:+    class OobWatcher : public OobBackendMetricWatcher {+     public:+      explicit OobWatcher(RefCountedPtr<AddressWeight> weight)+          : weight_(std::move(weight)) {}++      void OnBackendMetricReport(+          const BackendMetricData& backend_metric_data) override;++     private:+      RefCountedPtr<AddressWeight> weight_;+    };++    // Performs connectivity state updates that need to be done only+    // after we have started watching.+    void ProcessConnectivityChangeLocked(+        absl::optional<grpc_connectivity_state> old_state,+        grpc_connectivity_state new_state) override;++    // Updates the logical connectivity state.+    void UpdateLogicalConnectivityStateLocked(+        grpc_connectivity_state connectivity_state);++    // The logical connectivity state of the subchannel.+    // Note that the logical connectivity state may differ from the+    // actual reported state in some cases (e.g., after we see+    // TRANSIENT_FAILURE, we ignore any subsequent state changes until+    // we see READY).+    absl::optional<grpc_connectivity_state> logical_connectivity_state_;++    RefCountedPtr<AddressWeight> weight_;+  };++  // A list of subchannels.+  class WeightedRoundRobinSubchannelList+      : public SubchannelList<WeightedRoundRobinSubchannelList,+                              WeightedRoundRobinSubchannelData> {+   public:+    WeightedRoundRobinSubchannelList(WeightedRoundRobin* policy,+                                     ServerAddressList addresses,+                                     const ChannelArgs& args)+        : SubchannelList(policy,+                         (GRPC_TRACE_FLAG_ENABLED(grpc_lb_wrr_trace)+                              ? ""WeightedRoundRobinSubchannelList""+                              : nullptr),+                         std::move(addresses), policy->channel_control_helper(),+                         args) {+      // Need to maintain a ref to the LB policy as long as we maintain+      // any references to subchannels, since the subchannels'+      // pollset_sets will include the LB policy's pollset_set.+      policy->Ref(DEBUG_LOCATION, ""subchannel_list"").release();+    }++    ~WeightedRoundRobinSubchannelList() override {+      WeightedRoundRobin* p = static_cast<WeightedRoundRobin*>(policy());+      p->Unref(DEBUG_LOCATION, ""subchannel_list"");+    }++    // Updates the counters of subchannels in each state when a+    // subchannel transitions from old_state to new_state.+    void UpdateStateCountersLocked(+        absl::optional<grpc_connectivity_state> old_state,+        grpc_connectivity_state new_state);++    // Ensures that the right subchannel list is used and then updates+    // the aggregated connectivity state based on the subchannel list's+    // state counters.+    void MaybeUpdateAggregatedConnectivityStateLocked(+        absl::Status status_for_tf);++   private:+    std::string CountersString() const {+      return absl::StrCat(""num_subchannels="", num_subchannels(),+                          "" num_ready="", num_ready_,+                          "" num_connecting="", num_connecting_,+                          "" num_transient_failure="", num_transient_failure_);+    }++    size_t num_ready_ = 0;+    size_t num_connecting_ = 0;+    size_t num_transient_failure_ = 0;++    absl::Status last_failure_;+  };++  // A picker that performs WRR picks with weights based on+  // endpoint-reported utilization and QPS.+  class Picker : public SubchannelPicker {+   public:+    Picker(RefCountedPtr<WeightedRoundRobin> wrr,+           WeightedRoundRobinSubchannelList* subchannel_list);++    ~Picker() override;++    PickResult Pick(PickArgs args) override;++    void Orphan() override;++   private:+    // A call tracker that collects per-call endpoint utilization reports.+    class SubchannelCallTracker : public SubchannelCallTrackerInterface {+     public:+      explicit SubchannelCallTracker(RefCountedPtr<AddressWeight> weight)+          : weight_(std::move(weight)) {}++      void Start() override {}++      void Finish(FinishArgs args) override;++     private:+      RefCountedPtr<AddressWeight> weight_;+    };++    // Info stored about each subchannel.+    struct SubchannelInfo {+      SubchannelInfo(RefCountedPtr<SubchannelInterface> subchannel,+                     RefCountedPtr<AddressWeight> weight)+          : subchannel(std::move(subchannel)), weight(std::move(weight)) {}++      RefCountedPtr<SubchannelInterface> subchannel;+      RefCountedPtr<AddressWeight> weight;+    };++    // Returns the index into subchannels_ to be picked.+    size_t PickIndex();++    // Builds a new scheduler and swaps it into place, then starts a+    // timer for the next update.+    void BuildSchedulerAndStartTimerLocked()+        ABSL_EXCLUSIVE_LOCKS_REQUIRED(&mu_);++    RefCountedPtr<WeightedRoundRobin> wrr_;+    const bool use_per_rpc_utilization_;+    const Duration weight_update_period_;+    const Duration weight_expiration_period_;+    const Duration blackout_period_;+    std::vector<SubchannelInfo> subchannels_;++    Mutex mu_;+    uint32_t scheduler_state_ ABSL_GUARDED_BY(&mu_);+    absl::optional<StaticStrideScheduler> scheduler_ ABSL_GUARDED_BY(&mu_);+    absl::optional<grpc_event_engine::experimental::EventEngine::TaskHandle>+        timer_handle_ ABSL_GUARDED_BY(&mu_);++    // Used when falling back to RR.+    size_t last_picked_index_;","I don't think the scheduler state represents a simple index into the list of subchannels.  It has to be more than that, because the scheduler will return the same index multiple times for every ""pass"" in order to provide the appropriate weighting.  Given that, I don't see how we can use that state when we fall back to RR.Also, even if this was possible, I don't see that we'd get any significant benefit we'd get from doing it.  The WRR scheduler is not guaranteed to return indexes in the order in which they appear in the list, so it's not clear in the general case what next index *should* be used when transitioning from WRR to RR or vice-versa.  And these transitions should be fairly rare anyway, so I don't see that it's worth the effort to optimize this case; the behavior here is really no different than what happens in RR whenever we create a new picker.I believe the current behavior here is also consistent with how things work in Stubby.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/31904,1072426318,2023-01-17T16:25:03Z,src/core/ext/filters/client_channel/lb_policy/weighted_round_robin/weighted_round_robin.cc,"@@ -0,0 +1,955 @@+//+// Copyright 2022 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+//++#include <grpc/support/port_platform.h>++#include <inttypes.h>+#include <stdlib.h>+#include <string.h>++#include <algorithm>+#include <functional>+#include <map>+#include <memory>+#include <set>+#include <string>+#include <type_traits>+#include <utility>+#include <vector>++#include ""absl/base/thread_annotations.h""+#include ""absl/random/random.h""+#include ""absl/status/status.h""+#include ""absl/status/statusor.h""+#include ""absl/strings/str_cat.h""+#include ""absl/strings/str_join.h""+#include ""absl/strings/string_view.h""+#include ""absl/types/optional.h""++#include <grpc/event_engine/event_engine.h>+#include <grpc/impl/connectivity_state.h>+#include <grpc/support/log.h>++#include ""src/core/ext/filters/client_channel/lb_policy/backend_metric_data.h""+#include ""src/core/ext/filters/client_channel/lb_policy/oob_backend_metric.h""+#include ""src/core/ext/filters/client_channel/lb_policy/subchannel_list.h""+#include ""src/core/ext/filters/client_channel/lb_policy/weighted_round_robin/static_stride_scheduler.h""+#include ""src/core/lib/address_utils/sockaddr_utils.h""+#include ""src/core/lib/channel/channel_args.h""+#include ""src/core/lib/config/core_configuration.h""+#include ""src/core/lib/debug/trace.h""+#include ""src/core/lib/gprpp/debug_location.h""+#include ""src/core/lib/gprpp/orphanable.h""+#include ""src/core/lib/gprpp/ref_counted.h""+#include ""src/core/lib/gprpp/ref_counted_ptr.h""+#include ""src/core/lib/gprpp/sync.h""+#include ""src/core/lib/gprpp/time.h""+#include ""src/core/lib/gprpp/validation_errors.h""+#include ""src/core/lib/iomgr/exec_ctx.h""+#include ""src/core/lib/iomgr/resolved_address.h""+#include ""src/core/lib/json/json.h""+#include ""src/core/lib/json/json_args.h""+#include ""src/core/lib/json/json_object_loader.h""+#include ""src/core/lib/load_balancing/lb_policy.h""+#include ""src/core/lib/load_balancing/lb_policy_factory.h""+#include ""src/core/lib/load_balancing/subchannel_interface.h""+#include ""src/core/lib/resolver/server_address.h""+#include ""src/core/lib/transport/connectivity_state.h""++namespace grpc_core {++TraceFlag grpc_lb_wrr_trace(false, ""weighted_round_robin_lb"");++namespace {++constexpr absl::string_view kWeightedRoundRobin =+    ""weighted_round_robin_experimental"";++// Config for WRR policy.+class WeightedRoundRobinConfig : public LoadBalancingPolicy::Config {+ public:+  WeightedRoundRobinConfig() = default;++  WeightedRoundRobinConfig(const WeightedRoundRobinConfig&) = delete;+  WeightedRoundRobinConfig& operator=(const WeightedRoundRobinConfig&) = delete;++  WeightedRoundRobinConfig(WeightedRoundRobinConfig&&) = delete;+  WeightedRoundRobinConfig& operator=(WeightedRoundRobinConfig&&) = delete;++  absl::string_view name() const override { return kWeightedRoundRobin; }++  bool enable_oob_load_report() const { return enable_oob_load_report_; }+  Duration oob_reporting_period() const { return oob_reporting_period_; }+  Duration blackout_period() const { return blackout_period_; }+  Duration weight_update_period() const { return weight_update_period_; }+  Duration weight_expiration_period() const {+    return weight_expiration_period_;+  }++  static const JsonLoaderInterface* JsonLoader(const JsonArgs&) {+    static const auto* loader =+        JsonObjectLoader<WeightedRoundRobinConfig>()+            .OptionalField(""enableOobLoadReport"",+                           &WeightedRoundRobinConfig::enable_oob_load_report_)+            .OptionalField(""oobReportingPeriod"",+                           &WeightedRoundRobinConfig::oob_reporting_period_)+            .OptionalField(""blackoutPeriod"",+                           &WeightedRoundRobinConfig::blackout_period_)+            .OptionalField(""weightUpdatePeriod"",+                           &WeightedRoundRobinConfig::weight_update_period_)+            .OptionalField(""weightExpirationPeriod"",+                           &WeightedRoundRobinConfig::weight_expiration_period_)+            .Finish();+    return loader;+  }++  void JsonPostLoad(const Json&, const JsonArgs&, ValidationErrors*) {+    // Impose lower bound of 100ms on weightUpdatePeriod.+    weight_update_period_ =+        std::max(weight_update_period_, Duration::Milliseconds(100));+  }++ private:+  bool enable_oob_load_report_ = false;+  Duration oob_reporting_period_ = Duration::Seconds(10);+  Duration blackout_period_ = Duration::Seconds(10);+  Duration weight_update_period_ = Duration::Seconds(1);+  Duration weight_expiration_period_ = Duration::Minutes(3);+};++// WRR LB policy.+class WeightedRoundRobin : public LoadBalancingPolicy {+ public:+  explicit WeightedRoundRobin(Args args);++  absl::string_view name() const override { return kWeightedRoundRobin; }++  absl::Status UpdateLocked(UpdateArgs args) override;+  void ResetBackoffLocked() override;++ private:+  // Represents the weight for a given address.+  class AddressWeight : public RefCounted<AddressWeight> {+   public:+    AddressWeight(RefCountedPtr<WeightedRoundRobin> wrr, std::string key)+        : wrr_(std::move(wrr)), key_(std::move(key)) {}+    ~AddressWeight() override;++    void MaybeUpdateWeight(double qps, double cpu_utilization);++    float GetWeight(Timestamp now, Duration weight_expiration_period,+                    Duration blackout_period);++    void ResetNonEmptySince();++   private:+    RefCountedPtr<WeightedRoundRobin> wrr_;+    const std::string key_;++    Mutex mu_;+    float weight_ ABSL_GUARDED_BY(&mu_) = 0;+    Timestamp non_empty_since_ ABSL_GUARDED_BY(&mu_) = Timestamp::InfFuture();+    Timestamp last_update_time_ ABSL_GUARDED_BY(&mu_) = Timestamp::InfPast();+  };++  // Forward declaration.+  class WeightedRoundRobinSubchannelList;++  // Data for a particular subchannel in a subchannel list.+  // This subclass adds the following functionality:+  // - Tracks the previous connectivity state of the subchannel, so that+  //   we know how many subchannels are in each state.+  class WeightedRoundRobinSubchannelData+      : public SubchannelData<WeightedRoundRobinSubchannelList,+                              WeightedRoundRobinSubchannelData> {+   public:+    WeightedRoundRobinSubchannelData(+        SubchannelList<WeightedRoundRobinSubchannelList,+                       WeightedRoundRobinSubchannelData>* subchannel_list,+        const ServerAddress& address, RefCountedPtr<SubchannelInterface> sc);++    absl::optional<grpc_connectivity_state> connectivity_state() const {+      return logical_connectivity_state_;+    }++    RefCountedPtr<AddressWeight> weight() const { return weight_; }++   private:+    class OobWatcher : public OobBackendMetricWatcher {+     public:+      explicit OobWatcher(RefCountedPtr<AddressWeight> weight)+          : weight_(std::move(weight)) {}++      void OnBackendMetricReport(+          const BackendMetricData& backend_metric_data) override;++     private:+      RefCountedPtr<AddressWeight> weight_;+    };++    // Performs connectivity state updates that need to be done only+    // after we have started watching.+    void ProcessConnectivityChangeLocked(+        absl::optional<grpc_connectivity_state> old_state,+        grpc_connectivity_state new_state) override;++    // Updates the logical connectivity state.+    void UpdateLogicalConnectivityStateLocked(+        grpc_connectivity_state connectivity_state);++    // The logical connectivity state of the subchannel.+    // Note that the logical connectivity state may differ from the+    // actual reported state in some cases (e.g., after we see+    // TRANSIENT_FAILURE, we ignore any subsequent state changes until+    // we see READY).+    absl::optional<grpc_connectivity_state> logical_connectivity_state_;++    RefCountedPtr<AddressWeight> weight_;+  };++  // A list of subchannels.+  class WeightedRoundRobinSubchannelList+      : public SubchannelList<WeightedRoundRobinSubchannelList,+                              WeightedRoundRobinSubchannelData> {+   public:+    WeightedRoundRobinSubchannelList(WeightedRoundRobin* policy,+                                     ServerAddressList addresses,+                                     const ChannelArgs& args)+        : SubchannelList(policy,+                         (GRPC_TRACE_FLAG_ENABLED(grpc_lb_wrr_trace)+                              ? ""WeightedRoundRobinSubchannelList""+                              : nullptr),+                         std::move(addresses), policy->channel_control_helper(),+                         args) {+      // Need to maintain a ref to the LB policy as long as we maintain+      // any references to subchannels, since the subchannels'+      // pollset_sets will include the LB policy's pollset_set.+      policy->Ref(DEBUG_LOCATION, ""subchannel_list"").release();+    }++    ~WeightedRoundRobinSubchannelList() override {+      WeightedRoundRobin* p = static_cast<WeightedRoundRobin*>(policy());+      p->Unref(DEBUG_LOCATION, ""subchannel_list"");+    }++    // Updates the counters of subchannels in each state when a+    // subchannel transitions from old_state to new_state.+    void UpdateStateCountersLocked(+        absl::optional<grpc_connectivity_state> old_state,+        grpc_connectivity_state new_state);++    // Ensures that the right subchannel list is used and then updates+    // the aggregated connectivity state based on the subchannel list's+    // state counters.+    void MaybeUpdateAggregatedConnectivityStateLocked(+        absl::Status status_for_tf);++   private:+    std::string CountersString() const {+      return absl::StrCat(""num_subchannels="", num_subchannels(),+                          "" num_ready="", num_ready_,+                          "" num_connecting="", num_connecting_,+                          "" num_transient_failure="", num_transient_failure_);+    }++    size_t num_ready_ = 0;+    size_t num_connecting_ = 0;+    size_t num_transient_failure_ = 0;++    absl::Status last_failure_;+  };++  // A picker that performs WRR picks with weights based on+  // endpoint-reported utilization and QPS.+  class Picker : public SubchannelPicker {+   public:+    Picker(RefCountedPtr<WeightedRoundRobin> wrr,+           WeightedRoundRobinSubchannelList* subchannel_list);++    ~Picker() override;++    PickResult Pick(PickArgs args) override;++    void Orphan() override;++   private:+    // A call tracker that collects per-call endpoint utilization reports.+    class SubchannelCallTracker : public SubchannelCallTrackerInterface {+     public:+      explicit SubchannelCallTracker(RefCountedPtr<AddressWeight> weight)+          : weight_(std::move(weight)) {}++      void Start() override {}++      void Finish(FinishArgs args) override;++     private:+      RefCountedPtr<AddressWeight> weight_;+    };++    // Info stored about each subchannel.+    struct SubchannelInfo {+      SubchannelInfo(RefCountedPtr<SubchannelInterface> subchannel,+                     RefCountedPtr<AddressWeight> weight)+          : subchannel(std::move(subchannel)), weight(std::move(weight)) {}++      RefCountedPtr<SubchannelInterface> subchannel;+      RefCountedPtr<AddressWeight> weight;+    };++    // Returns the index into subchannels_ to be picked.+    size_t PickIndex();++    // Builds a new scheduler and swaps it into place, then starts a+    // timer for the next update.+    void BuildSchedulerAndStartTimerLocked()+        ABSL_EXCLUSIVE_LOCKS_REQUIRED(&mu_);++    RefCountedPtr<WeightedRoundRobin> wrr_;+    const bool use_per_rpc_utilization_;+    const Duration weight_update_period_;+    const Duration weight_expiration_period_;+    const Duration blackout_period_;+    std::vector<SubchannelInfo> subchannels_;++    Mutex mu_;+    uint32_t scheduler_state_ ABSL_GUARDED_BY(&mu_);+    absl::optional<StaticStrideScheduler> scheduler_ ABSL_GUARDED_BY(&mu_);+    absl::optional<grpc_event_engine::experimental::EventEngine::TaskHandle>+        timer_handle_ ABSL_GUARDED_BY(&mu_);++    // Used when falling back to RR.+    size_t last_picked_index_;+  };++  ~WeightedRoundRobin() override;++  void ShutdownLocked() override;++  RefCountedPtr<AddressWeight> GetOrCreateWeight(+      const grpc_resolved_address& address);++  RefCountedPtr<WeightedRoundRobinConfig> config_;++  // List of subchannels.+  RefCountedPtr<WeightedRoundRobinSubchannelList> subchannel_list_;+  // Latest pending subchannel list.+  // When we get an updated address list, we create a new subchannel list+  // for it here, and we wait to swap it into subchannel_list_ until the new+  // list becomes READY.+  RefCountedPtr<WeightedRoundRobinSubchannelList>+      latest_pending_subchannel_list_;++  Mutex address_weight_map_mu_;+  std::map<std::string, AddressWeight*, std::less<>> address_weight_map_+      ABSL_GUARDED_BY(&address_weight_map_mu_);++  bool shutdown_ = false;++  absl::BitGen bit_gen_;+};++//+// WeightedRoundRobin::AddressWeight+//++WeightedRoundRobin::AddressWeight::~AddressWeight() {+  MutexLock lock(&wrr_->address_weight_map_mu_);+  auto it = wrr_->address_weight_map_.find(key_);+  if (it != wrr_->address_weight_map_.end() && it->second == this) {+    wrr_->address_weight_map_.erase(it);+  }+}++void WeightedRoundRobin::AddressWeight::MaybeUpdateWeight(+    double qps, double cpu_utilization) {+  // Compute weight.+  float weight = 0;+  if (qps > 0 && cpu_utilization > 0) weight = qps / cpu_utilization;+  if (weight == 0) {+    if (GRPC_TRACE_FLAG_ENABLED(grpc_lb_wrr_trace)) {+      gpr_log(GPR_INFO,+              ""[WRR %p] subchannel %s: qps=%f, cpu_utilization=%f: weight=%f ""+              ""(not updating)"",+              wrr_.get(), key_.c_str(), qps, cpu_utilization, weight);+    }+    return;+  }+  Timestamp now = Timestamp::Now();+  // Grab the lock and update the data.+  MutexLock lock(&mu_);+  if (GRPC_TRACE_FLAG_ENABLED(grpc_lb_wrr_trace)) {+    gpr_log(GPR_INFO,+            ""[WRR %p] subchannel %s: qps=%f, cpu_utilization=%f: setting ""+            ""weight=%f weight_=%f now=%s last_update_time_=%s ""+            ""non_empty_since_=%s"",+            wrr_.get(), key_.c_str(), qps, cpu_utilization, weight, weight_,+            now.ToString().c_str(), last_update_time_.ToString().c_str(),+            non_empty_since_.ToString().c_str());+  }+  if (non_empty_since_ == Timestamp::InfFuture()) non_empty_since_ = now;","I believe we discussed this as part of adding the expiration period.  I think we want to treat ""we received a per-RPC report with value 0"" and ""we did not receive any backend metric report"" as being the same case.  Otherwise, we are using a different approach for per-RPC expiration than for OOB expiration, because in the OOB case, there will basically never be a report with value 0.  (It is *possible* for that to happen, but it's very unlikely in practice, because if the server does not mean to send utilization metrics, it won't send OOB reports in the first place.  Whereas with per-RPC, we will still look at the data when each RPC completes, even if there is no data supplied.)With regard to the actual code here, I think you need to update the design.  We decided to switch to using a mutex here instead of using atomics as part of introducing the expiration time, and as part of that, we are checking the blackout period when we *read* the weight, not when we write it.  Note that in the current code, resetting the weight to 0 would not actually affect the logic at all, because we won't use the value anyway if we're currently in the blackout period.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/31904,1072432543,2023-01-17T16:29:44Z,src/core/ext/filters/client_channel/lb_policy/weighted_round_robin/weighted_round_robin.cc,"@@ -0,0 +1,955 @@+//+// Copyright 2022 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+//++#include <grpc/support/port_platform.h>++#include <inttypes.h>+#include <stdlib.h>+#include <string.h>++#include <algorithm>+#include <functional>+#include <map>+#include <memory>+#include <set>+#include <string>+#include <type_traits>+#include <utility>+#include <vector>++#include ""absl/base/thread_annotations.h""+#include ""absl/random/random.h""+#include ""absl/status/status.h""+#include ""absl/status/statusor.h""+#include ""absl/strings/str_cat.h""+#include ""absl/strings/str_join.h""+#include ""absl/strings/string_view.h""+#include ""absl/types/optional.h""++#include <grpc/event_engine/event_engine.h>+#include <grpc/impl/connectivity_state.h>+#include <grpc/support/log.h>++#include ""src/core/ext/filters/client_channel/lb_policy/backend_metric_data.h""+#include ""src/core/ext/filters/client_channel/lb_policy/oob_backend_metric.h""+#include ""src/core/ext/filters/client_channel/lb_policy/subchannel_list.h""+#include ""src/core/ext/filters/client_channel/lb_policy/weighted_round_robin/static_stride_scheduler.h""+#include ""src/core/lib/address_utils/sockaddr_utils.h""+#include ""src/core/lib/channel/channel_args.h""+#include ""src/core/lib/config/core_configuration.h""+#include ""src/core/lib/debug/trace.h""+#include ""src/core/lib/gprpp/debug_location.h""+#include ""src/core/lib/gprpp/orphanable.h""+#include ""src/core/lib/gprpp/ref_counted.h""+#include ""src/core/lib/gprpp/ref_counted_ptr.h""+#include ""src/core/lib/gprpp/sync.h""+#include ""src/core/lib/gprpp/time.h""+#include ""src/core/lib/gprpp/validation_errors.h""+#include ""src/core/lib/iomgr/exec_ctx.h""+#include ""src/core/lib/iomgr/resolved_address.h""+#include ""src/core/lib/json/json.h""+#include ""src/core/lib/json/json_args.h""+#include ""src/core/lib/json/json_object_loader.h""+#include ""src/core/lib/load_balancing/lb_policy.h""+#include ""src/core/lib/load_balancing/lb_policy_factory.h""+#include ""src/core/lib/load_balancing/subchannel_interface.h""+#include ""src/core/lib/resolver/server_address.h""+#include ""src/core/lib/transport/connectivity_state.h""++namespace grpc_core {++TraceFlag grpc_lb_wrr_trace(false, ""weighted_round_robin_lb"");++namespace {++constexpr absl::string_view kWeightedRoundRobin =+    ""weighted_round_robin_experimental"";++// Config for WRR policy.+class WeightedRoundRobinConfig : public LoadBalancingPolicy::Config {+ public:+  WeightedRoundRobinConfig() = default;++  WeightedRoundRobinConfig(const WeightedRoundRobinConfig&) = delete;+  WeightedRoundRobinConfig& operator=(const WeightedRoundRobinConfig&) = delete;++  WeightedRoundRobinConfig(WeightedRoundRobinConfig&&) = delete;+  WeightedRoundRobinConfig& operator=(WeightedRoundRobinConfig&&) = delete;++  absl::string_view name() const override { return kWeightedRoundRobin; }++  bool enable_oob_load_report() const { return enable_oob_load_report_; }+  Duration oob_reporting_period() const { return oob_reporting_period_; }+  Duration blackout_period() const { return blackout_period_; }+  Duration weight_update_period() const { return weight_update_period_; }+  Duration weight_expiration_period() const {+    return weight_expiration_period_;+  }++  static const JsonLoaderInterface* JsonLoader(const JsonArgs&) {+    static const auto* loader =+        JsonObjectLoader<WeightedRoundRobinConfig>()+            .OptionalField(""enableOobLoadReport"",+                           &WeightedRoundRobinConfig::enable_oob_load_report_)+            .OptionalField(""oobReportingPeriod"",+                           &WeightedRoundRobinConfig::oob_reporting_period_)+            .OptionalField(""blackoutPeriod"",+                           &WeightedRoundRobinConfig::blackout_period_)+            .OptionalField(""weightUpdatePeriod"",+                           &WeightedRoundRobinConfig::weight_update_period_)+            .OptionalField(""weightExpirationPeriod"",+                           &WeightedRoundRobinConfig::weight_expiration_period_)+            .Finish();+    return loader;+  }++  void JsonPostLoad(const Json&, const JsonArgs&, ValidationErrors*) {+    // Impose lower bound of 100ms on weightUpdatePeriod.+    weight_update_period_ =+        std::max(weight_update_period_, Duration::Milliseconds(100));+  }++ private:+  bool enable_oob_load_report_ = false;+  Duration oob_reporting_period_ = Duration::Seconds(10);+  Duration blackout_period_ = Duration::Seconds(10);+  Duration weight_update_period_ = Duration::Seconds(1);+  Duration weight_expiration_period_ = Duration::Minutes(3);+};++// WRR LB policy.+class WeightedRoundRobin : public LoadBalancingPolicy {+ public:+  explicit WeightedRoundRobin(Args args);++  absl::string_view name() const override { return kWeightedRoundRobin; }++  absl::Status UpdateLocked(UpdateArgs args) override;+  void ResetBackoffLocked() override;++ private:+  // Represents the weight for a given address.+  class AddressWeight : public RefCounted<AddressWeight> {+   public:+    AddressWeight(RefCountedPtr<WeightedRoundRobin> wrr, std::string key)+        : wrr_(std::move(wrr)), key_(std::move(key)) {}+    ~AddressWeight() override;++    void MaybeUpdateWeight(double qps, double cpu_utilization);++    float GetWeight(Timestamp now, Duration weight_expiration_period,+                    Duration blackout_period);++    void ResetNonEmptySince();++   private:+    RefCountedPtr<WeightedRoundRobin> wrr_;+    const std::string key_;++    Mutex mu_;+    float weight_ ABSL_GUARDED_BY(&mu_) = 0;+    Timestamp non_empty_since_ ABSL_GUARDED_BY(&mu_) = Timestamp::InfFuture();+    Timestamp last_update_time_ ABSL_GUARDED_BY(&mu_) = Timestamp::InfPast();+  };++  // Forward declaration.+  class WeightedRoundRobinSubchannelList;++  // Data for a particular subchannel in a subchannel list.+  // This subclass adds the following functionality:+  // - Tracks the previous connectivity state of the subchannel, so that+  //   we know how many subchannels are in each state.+  class WeightedRoundRobinSubchannelData+      : public SubchannelData<WeightedRoundRobinSubchannelList,+                              WeightedRoundRobinSubchannelData> {+   public:+    WeightedRoundRobinSubchannelData(+        SubchannelList<WeightedRoundRobinSubchannelList,+                       WeightedRoundRobinSubchannelData>* subchannel_list,+        const ServerAddress& address, RefCountedPtr<SubchannelInterface> sc);++    absl::optional<grpc_connectivity_state> connectivity_state() const {+      return logical_connectivity_state_;+    }++    RefCountedPtr<AddressWeight> weight() const { return weight_; }++   private:+    class OobWatcher : public OobBackendMetricWatcher {+     public:+      explicit OobWatcher(RefCountedPtr<AddressWeight> weight)+          : weight_(std::move(weight)) {}++      void OnBackendMetricReport(+          const BackendMetricData& backend_metric_data) override;++     private:+      RefCountedPtr<AddressWeight> weight_;+    };++    // Performs connectivity state updates that need to be done only+    // after we have started watching.+    void ProcessConnectivityChangeLocked(+        absl::optional<grpc_connectivity_state> old_state,+        grpc_connectivity_state new_state) override;++    // Updates the logical connectivity state.+    void UpdateLogicalConnectivityStateLocked(+        grpc_connectivity_state connectivity_state);++    // The logical connectivity state of the subchannel.+    // Note that the logical connectivity state may differ from the+    // actual reported state in some cases (e.g., after we see+    // TRANSIENT_FAILURE, we ignore any subsequent state changes until+    // we see READY).+    absl::optional<grpc_connectivity_state> logical_connectivity_state_;++    RefCountedPtr<AddressWeight> weight_;+  };++  // A list of subchannels.+  class WeightedRoundRobinSubchannelList+      : public SubchannelList<WeightedRoundRobinSubchannelList,+                              WeightedRoundRobinSubchannelData> {+   public:+    WeightedRoundRobinSubchannelList(WeightedRoundRobin* policy,+                                     ServerAddressList addresses,+                                     const ChannelArgs& args)+        : SubchannelList(policy,+                         (GRPC_TRACE_FLAG_ENABLED(grpc_lb_wrr_trace)+                              ? ""WeightedRoundRobinSubchannelList""+                              : nullptr),+                         std::move(addresses), policy->channel_control_helper(),+                         args) {+      // Need to maintain a ref to the LB policy as long as we maintain+      // any references to subchannels, since the subchannels'+      // pollset_sets will include the LB policy's pollset_set.+      policy->Ref(DEBUG_LOCATION, ""subchannel_list"").release();+    }++    ~WeightedRoundRobinSubchannelList() override {+      WeightedRoundRobin* p = static_cast<WeightedRoundRobin*>(policy());+      p->Unref(DEBUG_LOCATION, ""subchannel_list"");+    }++    // Updates the counters of subchannels in each state when a+    // subchannel transitions from old_state to new_state.+    void UpdateStateCountersLocked(+        absl::optional<grpc_connectivity_state> old_state,+        grpc_connectivity_state new_state);++    // Ensures that the right subchannel list is used and then updates+    // the aggregated connectivity state based on the subchannel list's+    // state counters.+    void MaybeUpdateAggregatedConnectivityStateLocked(+        absl::Status status_for_tf);++   private:+    std::string CountersString() const {+      return absl::StrCat(""num_subchannels="", num_subchannels(),+                          "" num_ready="", num_ready_,+                          "" num_connecting="", num_connecting_,+                          "" num_transient_failure="", num_transient_failure_);+    }++    size_t num_ready_ = 0;+    size_t num_connecting_ = 0;+    size_t num_transient_failure_ = 0;++    absl::Status last_failure_;+  };++  // A picker that performs WRR picks with weights based on+  // endpoint-reported utilization and QPS.+  class Picker : public SubchannelPicker {+   public:+    Picker(RefCountedPtr<WeightedRoundRobin> wrr,+           WeightedRoundRobinSubchannelList* subchannel_list);++    ~Picker() override;++    PickResult Pick(PickArgs args) override;++    void Orphan() override;++   private:+    // A call tracker that collects per-call endpoint utilization reports.+    class SubchannelCallTracker : public SubchannelCallTrackerInterface {+     public:+      explicit SubchannelCallTracker(RefCountedPtr<AddressWeight> weight)+          : weight_(std::move(weight)) {}++      void Start() override {}++      void Finish(FinishArgs args) override;++     private:+      RefCountedPtr<AddressWeight> weight_;+    };++    // Info stored about each subchannel.+    struct SubchannelInfo {+      SubchannelInfo(RefCountedPtr<SubchannelInterface> subchannel,+                     RefCountedPtr<AddressWeight> weight)+          : subchannel(std::move(subchannel)), weight(std::move(weight)) {}++      RefCountedPtr<SubchannelInterface> subchannel;+      RefCountedPtr<AddressWeight> weight;+    };++    // Returns the index into subchannels_ to be picked.+    size_t PickIndex();++    // Builds a new scheduler and swaps it into place, then starts a+    // timer for the next update.+    void BuildSchedulerAndStartTimerLocked()+        ABSL_EXCLUSIVE_LOCKS_REQUIRED(&mu_);++    RefCountedPtr<WeightedRoundRobin> wrr_;+    const bool use_per_rpc_utilization_;+    const Duration weight_update_period_;+    const Duration weight_expiration_period_;+    const Duration blackout_period_;+    std::vector<SubchannelInfo> subchannels_;++    Mutex mu_;+    uint32_t scheduler_state_ ABSL_GUARDED_BY(&mu_);+    absl::optional<StaticStrideScheduler> scheduler_ ABSL_GUARDED_BY(&mu_);+    absl::optional<grpc_event_engine::experimental::EventEngine::TaskHandle>+        timer_handle_ ABSL_GUARDED_BY(&mu_);++    // Used when falling back to RR.+    size_t last_picked_index_;+  };++  ~WeightedRoundRobin() override;++  void ShutdownLocked() override;++  RefCountedPtr<AddressWeight> GetOrCreateWeight(+      const grpc_resolved_address& address);++  RefCountedPtr<WeightedRoundRobinConfig> config_;++  // List of subchannels.+  RefCountedPtr<WeightedRoundRobinSubchannelList> subchannel_list_;+  // Latest pending subchannel list.+  // When we get an updated address list, we create a new subchannel list+  // for it here, and we wait to swap it into subchannel_list_ until the new+  // list becomes READY.+  RefCountedPtr<WeightedRoundRobinSubchannelList>+      latest_pending_subchannel_list_;++  Mutex address_weight_map_mu_;+  std::map<std::string, AddressWeight*, std::less<>> address_weight_map_+      ABSL_GUARDED_BY(&address_weight_map_mu_);++  bool shutdown_ = false;++  absl::BitGen bit_gen_;+};++//+// WeightedRoundRobin::AddressWeight+//++WeightedRoundRobin::AddressWeight::~AddressWeight() {+  MutexLock lock(&wrr_->address_weight_map_mu_);+  auto it = wrr_->address_weight_map_.find(key_);+  if (it != wrr_->address_weight_map_.end() && it->second == this) {+    wrr_->address_weight_map_.erase(it);+  }+}++void WeightedRoundRobin::AddressWeight::MaybeUpdateWeight(+    double qps, double cpu_utilization) {+  // Compute weight.+  float weight = 0;+  if (qps > 0 && cpu_utilization > 0) weight = qps / cpu_utilization;+  if (weight == 0) {+    if (GRPC_TRACE_FLAG_ENABLED(grpc_lb_wrr_trace)) {+      gpr_log(GPR_INFO,+              ""[WRR %p] subchannel %s: qps=%f, cpu_utilization=%f: weight=%f ""+              ""(not updating)"",+              wrr_.get(), key_.c_str(), qps, cpu_utilization, weight);+    }+    return;+  }+  Timestamp now = Timestamp::Now();+  // Grab the lock and update the data.+  MutexLock lock(&mu_);+  if (GRPC_TRACE_FLAG_ENABLED(grpc_lb_wrr_trace)) {+    gpr_log(GPR_INFO,+            ""[WRR %p] subchannel %s: qps=%f, cpu_utilization=%f: setting ""+            ""weight=%f weight_=%f now=%s last_update_time_=%s ""+            ""non_empty_since_=%s"",+            wrr_.get(), key_.c_str(), qps, cpu_utilization, weight, weight_,+            now.ToString().c_str(), last_update_time_.ToString().c_str(),+            non_empty_since_.ToString().c_str());+  }+  if (non_empty_since_ == Timestamp::InfFuture()) non_empty_since_ = now;+  weight_ = weight;+  last_update_time_ = now;+}++float WeightedRoundRobin::AddressWeight::GetWeight(+    Timestamp now, Duration weight_expiration_period,+    Duration blackout_period) {+  MutexLock lock(&mu_);+  if (GRPC_TRACE_FLAG_ENABLED(grpc_lb_wrr_trace)) {+    gpr_log(GPR_INFO,+            ""[WRR %p] subchannel %s: getting weight: now=%s ""+            ""weight_expiration_period=%s blackout_period=%s ""+            ""last_update_time_=%s non_empty_since_=%s weight_=%f"",+            wrr_.get(), key_.c_str(), now.ToString().c_str(),+            weight_expiration_period.ToString().c_str(),+            blackout_period.ToString().c_str(),+            last_update_time_.ToString().c_str(),+            non_empty_since_.ToString().c_str(), weight_);+  }+  // If the most recent update was longer ago than the expiration+  // period, reset non_empty_since_ so that we apply the blackout period+  // again if we start getting data again in the future, and return 0.+  if (now - last_update_time_ >= weight_expiration_period) {+    non_empty_since_ = Timestamp::InfFuture();+    return 0;+  }+  // If we don't have at least blackout_period worth of data, return 0.+  if (blackout_period > Duration::Zero() &&+      now - non_empty_since_ < blackout_period) {+    return 0;+  }+  // Otherwise, return the weight.+  return weight_;+}++void WeightedRoundRobin::AddressWeight::ResetNonEmptySince() {+  MutexLock lock(&mu_);+  non_empty_since_ = Timestamp::InfFuture();+}++//+// WeightedRoundRobin::Picker::SubchannelCallTracker+//++void WeightedRoundRobin::Picker::SubchannelCallTracker::Finish(+    FinishArgs args) {+  auto* backend_metric_data =+      args.backend_metric_accessor->GetBackendMetricData();+  double qps = 0;+  double cpu_utilization = 0;+  if (backend_metric_data != nullptr) {+    qps = backend_metric_data->qps;+    cpu_utilization = backend_metric_data->cpu_utilization;+  }+  weight_->MaybeUpdateWeight(qps, cpu_utilization);+}++//+// WeightedRoundRobin::Picker+//++WeightedRoundRobin::Picker::Picker(+    RefCountedPtr<WeightedRoundRobin> wrr,+    WeightedRoundRobinSubchannelList* subchannel_list)+    : wrr_(std::move(wrr)),+      use_per_rpc_utilization_(!wrr_->config_->enable_oob_load_report()),+      weight_update_period_(wrr_->config_->weight_update_period()),+      weight_expiration_period_(wrr_->config_->weight_expiration_period()),+      blackout_period_(wrr_->config_->blackout_period()),+      scheduler_state_(absl::Uniform<uint32_t>(wrr_->bit_gen_)),+      last_picked_index_(absl::Uniform<size_t>(wrr_->bit_gen_)) {+  for (size_t i = 0; i < subchannel_list->num_subchannels(); ++i) {+    WeightedRoundRobinSubchannelData* sd = subchannel_list->subchannel(i);+    if (sd->connectivity_state() == GRPC_CHANNEL_READY) {+      subchannels_.emplace_back(sd->subchannel()->Ref(), sd->weight());+    }+  }+  if (GRPC_TRACE_FLAG_ENABLED(grpc_lb_wrr_trace)) {+    gpr_log(GPR_INFO,+            ""[WRR %p picker %p] created picker from subchannel_list=%p ""+            ""with %"" PRIuPTR "" subchannels"",+            wrr_.get(), this, subchannel_list, subchannels_.size());+  }+  BuildSchedulerAndStartTimerLocked();+}++WeightedRoundRobin::Picker::~Picker() {+  if (GRPC_TRACE_FLAG_ENABLED(grpc_lb_wrr_trace)) {+    gpr_log(GPR_INFO, ""[WRR %p picker %p] destroying picker"", wrr_.get(), this);+  }+}++void WeightedRoundRobin::Picker::Orphan() {+  MutexLock lock(&mu_);+  if (GRPC_TRACE_FLAG_ENABLED(grpc_lb_wrr_trace)) {+    gpr_log(GPR_INFO, ""[WRR %p picker %p] cancelling timer"", wrr_.get(), this);+  }+  wrr_->channel_control_helper()->GetEventEngine()->Cancel(*timer_handle_);+  timer_handle_.reset();+}++WeightedRoundRobin::PickResult WeightedRoundRobin::Picker::Pick(+    PickArgs /*args*/) {+  size_t index = PickIndex();+  GPR_ASSERT(index < subchannels_.size());+  auto& subchannel_info = subchannels_[index];+  // Collect per-call utilization data if needed.+  std::unique_ptr<SubchannelCallTrackerInterface> subchannel_call_tracker;+  if (use_per_rpc_utilization_) {+    subchannel_call_tracker =+        std::make_unique<SubchannelCallTracker>(subchannel_info.weight);+  }+  if (GRPC_TRACE_FLAG_ENABLED(grpc_lb_wrr_trace)) {+    gpr_log(GPR_INFO,+            ""[WRR %p picker %p] returning index %"" PRIuPTR "", subchannel=%p"",+            wrr_.get(), this, index, subchannel_info.subchannel.get());+  }+  return PickResult::Complete(subchannel_info.subchannel,+                              std::move(subchannel_call_tracker));+}++size_t WeightedRoundRobin::Picker::PickIndex() {+  // Grab the mutex and do WRR pick if we have a scheduler.+  {+    MutexLock lock(&mu_);+    if (scheduler_.has_value()) {","Yes, we did discuss using an atomic for the scheduler state, and we can certainly switch to that approach later if this turns out to be a bottleneck.  But after a quick chat with @ctiller, it seems like the amount of code executed in the scheduler before writing the atomic is so minimal that it's not clear that there's actually going to be a performance advantage by using the atomic instead of the mutex, so for now, I just did the simple thing.  We can easily change this later if need be.It's also worth noting that at the moment, the channel is holding the data plane mutex while calling the picker anyway, so using an atomic wouldn't do us any good in the first place.  It happens that I have started working on a PR to change the channel to not hold the mutex while calling the picker (#31973), in which case the atomic might help here, but even using the mutex, it will be no worse than what we have today.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/31448,1072559706,2023-01-17T17:43:09Z,src/core/lib/surface/call.cc,"@@ -2404,10 +2650,35 @@ void CallContext::IncrementRefCount(const char* reason) {  void CallContext::Unref(const char* reason) { call_->InternalUnref(reason); } +gpr_atm* CallContext::peer_string_atm_ptr() {+  return call_->peer_string_atm_ptr();+}+ void CallContext::UpdateDeadline(Timestamp deadline) {   call_->UpdateDeadline(deadline); } +ServerCallContext* CallContext::server_call_context() {+  return call_->server_call_context();+}++///////////////////////////////////////////////////////////////////////////////+// PublishMetadataArray++namespace {+void PublishMetadataArray(grpc_metadata_array* array, grpc_metadata_batch* md) {",Nit: Prefer input parameters before output parameters.,
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/31448,1072616589,2023-01-17T18:18:07Z,src/core/lib/surface/call.cc,"@@ -2893,26 +3069,353 @@ void ClientPromiseBasedCall::PublishStatus(                        PendingOp::kReceiveStatusOnClient); } -void ClientPromiseBasedCall::PublishMetadataArray(grpc_metadata_array* array,-                                                  ServerMetadata* md) {-  const auto md_count = md->count();-  if (md_count > array->capacity) {-    array->capacity =-        std::max(array->capacity + md->count(), array->capacity * 3 / 2);-    array->metadata = static_cast<grpc_metadata*>(-        gpr_realloc(array->metadata, sizeof(grpc_metadata) * array->capacity));+///////////////////////////////////////////////////////////////////////////////+// ServerPromiseBasedCall++class ServerPromiseBasedCall final : public PromiseBasedCall {+ public:+  ServerPromiseBasedCall(Arena* arena, grpc_call_create_args* args);++  void CancelWithErrorLocked(grpc_error_handle) override { abort(); }+  grpc_call_error StartBatch(const grpc_op* ops, size_t nops, void* notify_tag,+                             bool is_notify_tag_closure) override;+  bool failed_before_recv_message() const override { abort(); }+  bool is_trailers_only() const override { abort(); }+  absl::string_view GetServerAuthority() const override { abort(); }++  void UpdateOnce() ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu()) override;+  Poll<ServerMetadataHandle> PollTopOfCall()+      ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu());++  std::string DebugTag() const override {+    return absl::StrFormat(""SERVER_CALL[%p]: "", this);   }-  PublishToAppEncoder encoder(array);-  md->Encode(&encoder);++  ServerCallContext* server_call_context() override { return &call_context_; }++ private:+  struct Uninitialized {};++  class RecvCloseState {+   public:+    // Request that receiver be filled in per grpc_op_recv_close_on_server.+    // Returns true if the request can be fulfilled immediately.+    // Returns false if the request will be fulfilled later.+    bool RequestReceiveCloseOnServer(int* receiver) {+      switch (state_) {+        case kUnset:+          state_ = reinterpret_cast<uintptr_t>(receiver);+          return false;+        case kFinishedWithFailure:+          *receiver = 1;+          return true;+        case kFinishedWithSuccess:+          *receiver = 0;+          return true;+        default:+          abort();  // unreachable+      }+    }++    // Mark the call as having completed.+    // Returns true if this finishes a previous RequestReceiveCloseOnServer.+    bool CompleteCall(bool success) {+      switch (state_) {+        case kUnset:+          state_ = success ? kFinishedWithSuccess : kFinishedWithFailure;+          return false;+        case kFinishedWithFailure:+        case kFinishedWithSuccess:+          abort();  // unreachable+        default:+          *reinterpret_cast<int*>(state_) = success ? 0 : 1;+          state_ = success ? kFinishedWithSuccess : kFinishedWithFailure;+          return true;+      }+    }++    std::string ToString() const {+      switch (state_) {+        case kUnset:+          return ""Unset"";+        case kFinishedWithFailure:+          return ""FinishedWithFailure"";+        case kFinishedWithSuccess:+          return ""FinishedWithSuccess"";+        default:+          return absl::StrFormat(""WaitingForReceiver(%p)"",+                                 reinterpret_cast<void*>(state_));+      }+    }++   private:+    static constexpr uintptr_t kUnset = 0;+    static constexpr uintptr_t kFinishedWithFailure = 1;+    static constexpr uintptr_t kFinishedWithSuccess = 2;+    // Holds one of kUnset, kFinishedWithFailure, or kFinishedWithSuccess+    // OR an int* that wants to receive the final status.+    uintptr_t state_ = kUnset;+  };++  grpc_call_error ValidateBatch(const grpc_op* ops, size_t nops) const;+  void CommitBatch(const grpc_op* ops, size_t nops,+                   const Completion& completion)+      ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu());++  friend class ServerCallContext;+  ServerCallContext call_context_;+  Server* const server_;+  ArenaPromise<ServerMetadataHandle> promise_ ABSL_GUARDED_BY(mu());+  PipeSender<MessageHandle>* server_to_client_messages_ ABSL_GUARDED_BY(mu()) =+      nullptr;+  PipeReceiver<MessageHandle>* client_to_server_messages_+      ABSL_GUARDED_BY(mu()) = nullptr;+  using SendInitialMetadataState =+      absl::variant<Uninitialized, PipeSender<ServerMetadataHandle>*,+                    typename PipeSender<ServerMetadataHandle>::PushType>;+  SendInitialMetadataState send_initial_metadata_state_ ABSL_GUARDED_BY(mu()) =+      Uninitialized{};+  ServerMetadataHandle send_trailing_metadata_ ABSL_GUARDED_BY(mu());+  grpc_compression_algorithm incoming_compression_algorithm_+      ABSL_GUARDED_BY(mu());+  RecvCloseState recv_close_state_ ABSL_GUARDED_BY(mu());+  Completion recv_close_completion_ ABSL_GUARDED_BY(mu());+  Completion send_status_from_server_completion_ ABSL_GUARDED_BY(mu());+  ClientMetadataHandle client_initial_metadata_ ABSL_GUARDED_BY(mu());+};++ArenaPromise<ServerMetadataHandle> ServerCallContext::CompletePromise(","Suggest renaming this to reflect that it's completing promise *initialization*, rather than completeing the promise as a whole.",X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/31904,1072646875,2023-01-17T18:35:48Z,src/core/ext/filters/client_channel/lb_policy/weighted_round_robin/weighted_round_robin.cc,"@@ -0,0 +1,955 @@+//+// Copyright 2022 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+//++#include <grpc/support/port_platform.h>++#include <inttypes.h>+#include <stdlib.h>+#include <string.h>++#include <algorithm>+#include <functional>+#include <map>+#include <memory>+#include <set>+#include <string>+#include <type_traits>+#include <utility>+#include <vector>++#include ""absl/base/thread_annotations.h""+#include ""absl/random/random.h""+#include ""absl/status/status.h""+#include ""absl/status/statusor.h""+#include ""absl/strings/str_cat.h""+#include ""absl/strings/str_join.h""+#include ""absl/strings/string_view.h""+#include ""absl/types/optional.h""++#include <grpc/event_engine/event_engine.h>+#include <grpc/impl/connectivity_state.h>+#include <grpc/support/log.h>++#include ""src/core/ext/filters/client_channel/lb_policy/backend_metric_data.h""+#include ""src/core/ext/filters/client_channel/lb_policy/oob_backend_metric.h""+#include ""src/core/ext/filters/client_channel/lb_policy/subchannel_list.h""+#include ""src/core/ext/filters/client_channel/lb_policy/weighted_round_robin/static_stride_scheduler.h""+#include ""src/core/lib/address_utils/sockaddr_utils.h""+#include ""src/core/lib/channel/channel_args.h""+#include ""src/core/lib/config/core_configuration.h""+#include ""src/core/lib/debug/trace.h""+#include ""src/core/lib/gprpp/debug_location.h""+#include ""src/core/lib/gprpp/orphanable.h""+#include ""src/core/lib/gprpp/ref_counted.h""+#include ""src/core/lib/gprpp/ref_counted_ptr.h""+#include ""src/core/lib/gprpp/sync.h""+#include ""src/core/lib/gprpp/time.h""+#include ""src/core/lib/gprpp/validation_errors.h""+#include ""src/core/lib/iomgr/exec_ctx.h""+#include ""src/core/lib/iomgr/resolved_address.h""+#include ""src/core/lib/json/json.h""+#include ""src/core/lib/json/json_args.h""+#include ""src/core/lib/json/json_object_loader.h""+#include ""src/core/lib/load_balancing/lb_policy.h""+#include ""src/core/lib/load_balancing/lb_policy_factory.h""+#include ""src/core/lib/load_balancing/subchannel_interface.h""+#include ""src/core/lib/resolver/server_address.h""+#include ""src/core/lib/transport/connectivity_state.h""++namespace grpc_core {++TraceFlag grpc_lb_wrr_trace(false, ""weighted_round_robin_lb"");++namespace {++constexpr absl::string_view kWeightedRoundRobin =+    ""weighted_round_robin_experimental"";++// Config for WRR policy.+class WeightedRoundRobinConfig : public LoadBalancingPolicy::Config {+ public:+  WeightedRoundRobinConfig() = default;++  WeightedRoundRobinConfig(const WeightedRoundRobinConfig&) = delete;+  WeightedRoundRobinConfig& operator=(const WeightedRoundRobinConfig&) = delete;++  WeightedRoundRobinConfig(WeightedRoundRobinConfig&&) = delete;+  WeightedRoundRobinConfig& operator=(WeightedRoundRobinConfig&&) = delete;++  absl::string_view name() const override { return kWeightedRoundRobin; }++  bool enable_oob_load_report() const { return enable_oob_load_report_; }+  Duration oob_reporting_period() const { return oob_reporting_period_; }+  Duration blackout_period() const { return blackout_period_; }+  Duration weight_update_period() const { return weight_update_period_; }+  Duration weight_expiration_period() const {+    return weight_expiration_period_;+  }++  static const JsonLoaderInterface* JsonLoader(const JsonArgs&) {+    static const auto* loader =+        JsonObjectLoader<WeightedRoundRobinConfig>()+            .OptionalField(""enableOobLoadReport"",+                           &WeightedRoundRobinConfig::enable_oob_load_report_)+            .OptionalField(""oobReportingPeriod"",+                           &WeightedRoundRobinConfig::oob_reporting_period_)+            .OptionalField(""blackoutPeriod"",+                           &WeightedRoundRobinConfig::blackout_period_)+            .OptionalField(""weightUpdatePeriod"",+                           &WeightedRoundRobinConfig::weight_update_period_)+            .OptionalField(""weightExpirationPeriod"",+                           &WeightedRoundRobinConfig::weight_expiration_period_)+            .Finish();+    return loader;+  }++  void JsonPostLoad(const Json&, const JsonArgs&, ValidationErrors*) {+    // Impose lower bound of 100ms on weightUpdatePeriod.+    weight_update_period_ =+        std::max(weight_update_period_, Duration::Milliseconds(100));+  }++ private:+  bool enable_oob_load_report_ = false;+  Duration oob_reporting_period_ = Duration::Seconds(10);+  Duration blackout_period_ = Duration::Seconds(10);+  Duration weight_update_period_ = Duration::Seconds(1);+  Duration weight_expiration_period_ = Duration::Minutes(3);+};++// WRR LB policy.+class WeightedRoundRobin : public LoadBalancingPolicy {+ public:+  explicit WeightedRoundRobin(Args args);++  absl::string_view name() const override { return kWeightedRoundRobin; }++  absl::Status UpdateLocked(UpdateArgs args) override;+  void ResetBackoffLocked() override;++ private:+  // Represents the weight for a given address.+  class AddressWeight : public RefCounted<AddressWeight> {+   public:+    AddressWeight(RefCountedPtr<WeightedRoundRobin> wrr, std::string key)+        : wrr_(std::move(wrr)), key_(std::move(key)) {}+    ~AddressWeight() override;++    void MaybeUpdateWeight(double qps, double cpu_utilization);++    float GetWeight(Timestamp now, Duration weight_expiration_period,+                    Duration blackout_period);++    void ResetNonEmptySince();++   private:+    RefCountedPtr<WeightedRoundRobin> wrr_;+    const std::string key_;++    Mutex mu_;+    float weight_ ABSL_GUARDED_BY(&mu_) = 0;+    Timestamp non_empty_since_ ABSL_GUARDED_BY(&mu_) = Timestamp::InfFuture();+    Timestamp last_update_time_ ABSL_GUARDED_BY(&mu_) = Timestamp::InfPast();+  };++  // Forward declaration.+  class WeightedRoundRobinSubchannelList;++  // Data for a particular subchannel in a subchannel list.+  // This subclass adds the following functionality:+  // - Tracks the previous connectivity state of the subchannel, so that+  //   we know how many subchannels are in each state.+  class WeightedRoundRobinSubchannelData+      : public SubchannelData<WeightedRoundRobinSubchannelList,+                              WeightedRoundRobinSubchannelData> {+   public:+    WeightedRoundRobinSubchannelData(+        SubchannelList<WeightedRoundRobinSubchannelList,+                       WeightedRoundRobinSubchannelData>* subchannel_list,+        const ServerAddress& address, RefCountedPtr<SubchannelInterface> sc);++    absl::optional<grpc_connectivity_state> connectivity_state() const {+      return logical_connectivity_state_;+    }++    RefCountedPtr<AddressWeight> weight() const { return weight_; }++   private:+    class OobWatcher : public OobBackendMetricWatcher {+     public:+      explicit OobWatcher(RefCountedPtr<AddressWeight> weight)+          : weight_(std::move(weight)) {}++      void OnBackendMetricReport(+          const BackendMetricData& backend_metric_data) override;++     private:+      RefCountedPtr<AddressWeight> weight_;+    };++    // Performs connectivity state updates that need to be done only+    // after we have started watching.+    void ProcessConnectivityChangeLocked(+        absl::optional<grpc_connectivity_state> old_state,+        grpc_connectivity_state new_state) override;++    // Updates the logical connectivity state.+    void UpdateLogicalConnectivityStateLocked(+        grpc_connectivity_state connectivity_state);++    // The logical connectivity state of the subchannel.+    // Note that the logical connectivity state may differ from the+    // actual reported state in some cases (e.g., after we see+    // TRANSIENT_FAILURE, we ignore any subsequent state changes until+    // we see READY).+    absl::optional<grpc_connectivity_state> logical_connectivity_state_;++    RefCountedPtr<AddressWeight> weight_;+  };++  // A list of subchannels.+  class WeightedRoundRobinSubchannelList+      : public SubchannelList<WeightedRoundRobinSubchannelList,+                              WeightedRoundRobinSubchannelData> {+   public:+    WeightedRoundRobinSubchannelList(WeightedRoundRobin* policy,+                                     ServerAddressList addresses,+                                     const ChannelArgs& args)+        : SubchannelList(policy,+                         (GRPC_TRACE_FLAG_ENABLED(grpc_lb_wrr_trace)+                              ? ""WeightedRoundRobinSubchannelList""+                              : nullptr),+                         std::move(addresses), policy->channel_control_helper(),+                         args) {+      // Need to maintain a ref to the LB policy as long as we maintain+      // any references to subchannels, since the subchannels'+      // pollset_sets will include the LB policy's pollset_set.+      policy->Ref(DEBUG_LOCATION, ""subchannel_list"").release();+    }++    ~WeightedRoundRobinSubchannelList() override {+      WeightedRoundRobin* p = static_cast<WeightedRoundRobin*>(policy());+      p->Unref(DEBUG_LOCATION, ""subchannel_list"");+    }++    // Updates the counters of subchannels in each state when a+    // subchannel transitions from old_state to new_state.+    void UpdateStateCountersLocked(+        absl::optional<grpc_connectivity_state> old_state,+        grpc_connectivity_state new_state);++    // Ensures that the right subchannel list is used and then updates+    // the aggregated connectivity state based on the subchannel list's+    // state counters.+    void MaybeUpdateAggregatedConnectivityStateLocked(+        absl::Status status_for_tf);++   private:+    std::string CountersString() const {+      return absl::StrCat(""num_subchannels="", num_subchannels(),+                          "" num_ready="", num_ready_,+                          "" num_connecting="", num_connecting_,+                          "" num_transient_failure="", num_transient_failure_);+    }++    size_t num_ready_ = 0;+    size_t num_connecting_ = 0;+    size_t num_transient_failure_ = 0;++    absl::Status last_failure_;+  };++  // A picker that performs WRR picks with weights based on+  // endpoint-reported utilization and QPS.+  class Picker : public SubchannelPicker {+   public:+    Picker(RefCountedPtr<WeightedRoundRobin> wrr,+           WeightedRoundRobinSubchannelList* subchannel_list);++    ~Picker() override;++    PickResult Pick(PickArgs args) override;++    void Orphan() override;++   private:+    // A call tracker that collects per-call endpoint utilization reports.+    class SubchannelCallTracker : public SubchannelCallTrackerInterface {+     public:+      explicit SubchannelCallTracker(RefCountedPtr<AddressWeight> weight)+          : weight_(std::move(weight)) {}++      void Start() override {}++      void Finish(FinishArgs args) override;++     private:+      RefCountedPtr<AddressWeight> weight_;+    };++    // Info stored about each subchannel.+    struct SubchannelInfo {+      SubchannelInfo(RefCountedPtr<SubchannelInterface> subchannel,+                     RefCountedPtr<AddressWeight> weight)+          : subchannel(std::move(subchannel)), weight(std::move(weight)) {}++      RefCountedPtr<SubchannelInterface> subchannel;+      RefCountedPtr<AddressWeight> weight;+    };++    // Returns the index into subchannels_ to be picked.+    size_t PickIndex();++    // Builds a new scheduler and swaps it into place, then starts a+    // timer for the next update.+    void BuildSchedulerAndStartTimerLocked()+        ABSL_EXCLUSIVE_LOCKS_REQUIRED(&mu_);++    RefCountedPtr<WeightedRoundRobin> wrr_;+    const bool use_per_rpc_utilization_;+    const Duration weight_update_period_;+    const Duration weight_expiration_period_;+    const Duration blackout_period_;+    std::vector<SubchannelInfo> subchannels_;++    Mutex mu_;+    uint32_t scheduler_state_ ABSL_GUARDED_BY(&mu_);+    absl::optional<StaticStrideScheduler> scheduler_ ABSL_GUARDED_BY(&mu_);+    absl::optional<grpc_event_engine::experimental::EventEngine::TaskHandle>+        timer_handle_ ABSL_GUARDED_BY(&mu_);++    // Used when falling back to RR.+    size_t last_picked_index_;+  };++  ~WeightedRoundRobin() override;++  void ShutdownLocked() override;++  RefCountedPtr<AddressWeight> GetOrCreateWeight(+      const grpc_resolved_address& address);++  RefCountedPtr<WeightedRoundRobinConfig> config_;++  // List of subchannels.+  RefCountedPtr<WeightedRoundRobinSubchannelList> subchannel_list_;+  // Latest pending subchannel list.+  // When we get an updated address list, we create a new subchannel list+  // for it here, and we wait to swap it into subchannel_list_ until the new+  // list becomes READY.+  RefCountedPtr<WeightedRoundRobinSubchannelList>+      latest_pending_subchannel_list_;++  Mutex address_weight_map_mu_;+  std::map<std::string, AddressWeight*, std::less<>> address_weight_map_+      ABSL_GUARDED_BY(&address_weight_map_mu_);++  bool shutdown_ = false;++  absl::BitGen bit_gen_;+};++//+// WeightedRoundRobin::AddressWeight+//++WeightedRoundRobin::AddressWeight::~AddressWeight() {+  MutexLock lock(&wrr_->address_weight_map_mu_);+  auto it = wrr_->address_weight_map_.find(key_);+  if (it != wrr_->address_weight_map_.end() && it->second == this) {+    wrr_->address_weight_map_.erase(it);+  }+}++void WeightedRoundRobin::AddressWeight::MaybeUpdateWeight(+    double qps, double cpu_utilization) {+  // Compute weight.+  float weight = 0;+  if (qps > 0 && cpu_utilization > 0) weight = qps / cpu_utilization;+  if (weight == 0) {+    if (GRPC_TRACE_FLAG_ENABLED(grpc_lb_wrr_trace)) {+      gpr_log(GPR_INFO,+              ""[WRR %p] subchannel %s: qps=%f, cpu_utilization=%f: weight=%f ""+              ""(not updating)"",+              wrr_.get(), key_.c_str(), qps, cpu_utilization, weight);+    }+    return;+  }+  Timestamp now = Timestamp::Now();+  // Grab the lock and update the data.+  MutexLock lock(&mu_);+  if (GRPC_TRACE_FLAG_ENABLED(grpc_lb_wrr_trace)) {+    gpr_log(GPR_INFO,+            ""[WRR %p] subchannel %s: qps=%f, cpu_utilization=%f: setting ""+            ""weight=%f weight_=%f now=%s last_update_time_=%s ""+            ""non_empty_since_=%s"",+            wrr_.get(), key_.c_str(), qps, cpu_utilization, weight, weight_,+            now.ToString().c_str(), last_update_time_.ToString().c_str(),+            non_empty_since_.ToString().c_str());+  }+  if (non_empty_since_ == Timestamp::InfFuture()) non_empty_since_ = now;+  weight_ = weight;+  last_update_time_ = now;+}++float WeightedRoundRobin::AddressWeight::GetWeight(+    Timestamp now, Duration weight_expiration_period,+    Duration blackout_period) {+  MutexLock lock(&mu_);+  if (GRPC_TRACE_FLAG_ENABLED(grpc_lb_wrr_trace)) {+    gpr_log(GPR_INFO,+            ""[WRR %p] subchannel %s: getting weight: now=%s ""+            ""weight_expiration_period=%s blackout_period=%s ""+            ""last_update_time_=%s non_empty_since_=%s weight_=%f"",+            wrr_.get(), key_.c_str(), now.ToString().c_str(),+            weight_expiration_period.ToString().c_str(),+            blackout_period.ToString().c_str(),+            last_update_time_.ToString().c_str(),+            non_empty_since_.ToString().c_str(), weight_);+  }+  // If the most recent update was longer ago than the expiration+  // period, reset non_empty_since_ so that we apply the blackout period+  // again if we start getting data again in the future, and return 0.+  if (now - last_update_time_ >= weight_expiration_period) {+    non_empty_since_ = Timestamp::InfFuture();+    return 0;+  }+  // If we don't have at least blackout_period worth of data, return 0.+  if (blackout_period > Duration::Zero() &&+      now - non_empty_since_ < blackout_period) {+    return 0;+  }+  // Otherwise, return the weight.+  return weight_;+}++void WeightedRoundRobin::AddressWeight::ResetNonEmptySince() {+  MutexLock lock(&mu_);+  non_empty_since_ = Timestamp::InfFuture();+}++//+// WeightedRoundRobin::Picker::SubchannelCallTracker+//++void WeightedRoundRobin::Picker::SubchannelCallTracker::Finish(+    FinishArgs args) {+  auto* backend_metric_data =+      args.backend_metric_accessor->GetBackendMetricData();+  double qps = 0;+  double cpu_utilization = 0;+  if (backend_metric_data != nullptr) {+    qps = backend_metric_data->qps;+    cpu_utilization = backend_metric_data->cpu_utilization;+  }+  weight_->MaybeUpdateWeight(qps, cpu_utilization);+}++//+// WeightedRoundRobin::Picker+//++WeightedRoundRobin::Picker::Picker(+    RefCountedPtr<WeightedRoundRobin> wrr,+    WeightedRoundRobinSubchannelList* subchannel_list)+    : wrr_(std::move(wrr)),+      use_per_rpc_utilization_(!wrr_->config_->enable_oob_load_report()),+      weight_update_period_(wrr_->config_->weight_update_period()),+      weight_expiration_period_(wrr_->config_->weight_expiration_period()),+      blackout_period_(wrr_->config_->blackout_period()),+      scheduler_state_(absl::Uniform<uint32_t>(wrr_->bit_gen_)),+      last_picked_index_(absl::Uniform<size_t>(wrr_->bit_gen_)) {+  for (size_t i = 0; i < subchannel_list->num_subchannels(); ++i) {+    WeightedRoundRobinSubchannelData* sd = subchannel_list->subchannel(i);+    if (sd->connectivity_state() == GRPC_CHANNEL_READY) {+      subchannels_.emplace_back(sd->subchannel()->Ref(), sd->weight());+    }+  }+  if (GRPC_TRACE_FLAG_ENABLED(grpc_lb_wrr_trace)) {+    gpr_log(GPR_INFO,+            ""[WRR %p picker %p] created picker from subchannel_list=%p ""+            ""with %"" PRIuPTR "" subchannels"",+            wrr_.get(), this, subchannel_list, subchannels_.size());+  }+  BuildSchedulerAndStartTimerLocked();+}++WeightedRoundRobin::Picker::~Picker() {+  if (GRPC_TRACE_FLAG_ENABLED(grpc_lb_wrr_trace)) {+    gpr_log(GPR_INFO, ""[WRR %p picker %p] destroying picker"", wrr_.get(), this);+  }+}++void WeightedRoundRobin::Picker::Orphan() {+  MutexLock lock(&mu_);+  if (GRPC_TRACE_FLAG_ENABLED(grpc_lb_wrr_trace)) {+    gpr_log(GPR_INFO, ""[WRR %p picker %p] cancelling timer"", wrr_.get(), this);+  }+  wrr_->channel_control_helper()->GetEventEngine()->Cancel(*timer_handle_);+  timer_handle_.reset();+}++WeightedRoundRobin::PickResult WeightedRoundRobin::Picker::Pick(+    PickArgs /*args*/) {+  size_t index = PickIndex();+  GPR_ASSERT(index < subchannels_.size());+  auto& subchannel_info = subchannels_[index];+  // Collect per-call utilization data if needed.+  std::unique_ptr<SubchannelCallTrackerInterface> subchannel_call_tracker;+  if (use_per_rpc_utilization_) {+    subchannel_call_tracker =+        std::make_unique<SubchannelCallTracker>(subchannel_info.weight);+  }+  if (GRPC_TRACE_FLAG_ENABLED(grpc_lb_wrr_trace)) {+    gpr_log(GPR_INFO,+            ""[WRR %p picker %p] returning index %"" PRIuPTR "", subchannel=%p"",+            wrr_.get(), this, index, subchannel_info.subchannel.get());+  }+  return PickResult::Complete(subchannel_info.subchannel,+                              std::move(subchannel_call_tracker));+}++size_t WeightedRoundRobin::Picker::PickIndex() {+  // Grab the mutex and do WRR pick if we have a scheduler.+  {+    MutexLock lock(&mu_);+    if (scheduler_.has_value()) {+      return scheduler_->Pick();+    }+  }+  // We don't have a scheduler (i.e., either all of the weights are 0 or+  // there is only one subchannel), so fall back to RR.+  last_picked_index_ = (last_picked_index_ + 1) % subchannels_.size();+  return last_picked_index_;+}++void WeightedRoundRobin::Picker::BuildSchedulerAndStartTimerLocked() {+  // Build scheduler.+  const Timestamp now = Timestamp::Now();+  std::vector<float> weights;+  weights.reserve(subchannels_.size());+  for (const auto& subchannel : subchannels_) {+    weights.push_back(subchannel.weight->GetWeight(+        now, weight_expiration_period_, blackout_period_));+  }+  if (GRPC_TRACE_FLAG_ENABLED(grpc_lb_wrr_trace)) {+    gpr_log(GPR_INFO, ""[WRR %p picker %p] new weights: %s"", wrr_.get(), this,+            absl::StrJoin(weights, "" "").c_str());+  }+  scheduler_ = StaticStrideScheduler::Make(+      weights,+      // This requires holding mu_, but we don't have a way to plumb the+      // annotation through absl::AnyInvocable<>.+      [this]() ABSL_NO_THREAD_SAFETY_ANALYSIS { return scheduler_state_++; });+  // Start timer.+  WeakRefCountedPtr<Picker> self = WeakRef();+  timer_handle_ = wrr_->channel_control_helper()->GetEventEngine()->RunAfter(+      weight_update_period_, [self = std::move(self)]() mutable {+        ApplicationCallbackExecCtx callback_exec_ctx;+        ExecCtx exec_ctx;+        {+          MutexLock lock(&self->mu_);+          if (self->timer_handle_.has_value()) {+            if (GRPC_TRACE_FLAG_ENABLED(grpc_lb_wrr_trace)) {+              gpr_log(GPR_INFO, ""[WRR %p picker %p] timer fired"",+                      self->wrr_.get(), self.get());+            }+            self->BuildSchedulerAndStartTimerLocked();+          }+        }+        // Release ref before ExecCtx goes out of scope.+        self.reset();+      });+}++//+// WeightedRoundRobin+//++WeightedRoundRobin::WeightedRoundRobin(Args args)+    : LoadBalancingPolicy(std::move(args)) {+  if (GRPC_TRACE_FLAG_ENABLED(grpc_lb_wrr_trace)) {+    gpr_log(GPR_INFO, ""[WRR %p] Created"", this);+  }+}++WeightedRoundRobin::~WeightedRoundRobin() {+  if (GRPC_TRACE_FLAG_ENABLED(grpc_lb_wrr_trace)) {+    gpr_log(GPR_INFO, ""[WRR %p] Destroying Round Robin policy"", this);+  }+  GPR_ASSERT(subchannel_list_ == nullptr);+  GPR_ASSERT(latest_pending_subchannel_list_ == nullptr);+}++void WeightedRoundRobin::ShutdownLocked() {+  if (GRPC_TRACE_FLAG_ENABLED(grpc_lb_wrr_trace)) {+    gpr_log(GPR_INFO, ""[WRR %p] Shutting down"", this);+  }+  shutdown_ = true;+  subchannel_list_.reset();+  latest_pending_subchannel_list_.reset();+}++void WeightedRoundRobin::ResetBackoffLocked() {+  subchannel_list_->ResetBackoffLocked();+  if (latest_pending_subchannel_list_ != nullptr) {+    latest_pending_subchannel_list_->ResetBackoffLocked();+  }+}++absl::Status WeightedRoundRobin::UpdateLocked(UpdateArgs args) {+  config_ = std::move(args.config);+  ServerAddressList addresses;+  if (args.addresses.ok()) {+    if (GRPC_TRACE_FLAG_ENABLED(grpc_lb_wrr_trace)) {+      gpr_log(GPR_INFO, ""[WRR %p] received update with %"" PRIuPTR "" addresses"",+              this, args.addresses->size());+    }+    // Weed out duplicate addresses.+    struct AddressLessThan {+      bool operator()(const grpc_resolved_address& addr1,+                      const grpc_resolved_address& addr2) const {+        if (addr1.len != addr2.len) return addr1.len < addr2.len;+        return memcmp(addr1.addr, addr2.addr, addr1.len) < 0;+      }+    };+    std::set<grpc_resolved_address, AddressLessThan> seen_addresses;+    for (ServerAddress& address : *args.addresses) {+      auto it = seen_addresses.find(address.address());+      if (it != seen_addresses.end()) continue;+      seen_addresses.insert(address.address());+      addresses.emplace_back(std::move(address));+    }+  } else {+    if (GRPC_TRACE_FLAG_ENABLED(grpc_lb_wrr_trace)) {+      gpr_log(GPR_INFO, ""[WRR %p] received update with address error: %s"", this,+              args.addresses.status().ToString().c_str());+    }+    // If we already have a subchannel list, then keep using the existing+    // list, but still report back that the update was not accepted.+    if (subchannel_list_ != nullptr) return args.addresses.status();+  }+  // Create new subchannel list, replacing the previous pending list, if any.+  if (GRPC_TRACE_FLAG_ENABLED(grpc_lb_wrr_trace) &&+      latest_pending_subchannel_list_ != nullptr) {+    gpr_log(GPR_INFO, ""[WRR %p] replacing previous pending subchannel list %p"",+            this, latest_pending_subchannel_list_.get());+  }+  latest_pending_subchannel_list_ =+      MakeRefCounted<WeightedRoundRobinSubchannelList>(+          this, std::move(addresses), args.args);+  latest_pending_subchannel_list_->StartWatchingLocked();+  // If the new list is empty, immediately promote it to+  // subchannel_list_ and report TRANSIENT_FAILURE.+  if (latest_pending_subchannel_list_->num_subchannels() == 0) {+    if (GRPC_TRACE_FLAG_ENABLED(grpc_lb_wrr_trace) &&+        subchannel_list_ != nullptr) {+      gpr_log(GPR_INFO, ""[WRR %p] replacing previous subchannel list %p"", this,+              subchannel_list_.get());+    }+    subchannel_list_ = std::move(latest_pending_subchannel_list_);+    absl::Status status =+        args.addresses.ok() ? absl::UnavailableError(absl::StrCat(+                                  ""empty address list: "", args.resolution_note))+                            : args.addresses.status();+    channel_control_helper()->UpdateState(+        GRPC_CHANNEL_TRANSIENT_FAILURE, status,+        MakeRefCounted<TransientFailurePicker>(status));+    return status;+  }+  // Otherwise, if this is the initial update, immediately promote it to+  // subchannel_list_ and report CONNECTING.+  if (subchannel_list_.get() == nullptr) {+    subchannel_list_ = std::move(latest_pending_subchannel_list_);+    channel_control_helper()->UpdateState(+        GRPC_CHANNEL_CONNECTING, absl::Status(),+        MakeRefCounted<QueuePicker>(Ref(DEBUG_LOCATION, ""QueuePicker"")));+  }+  return absl::OkStatus();+}++RefCountedPtr<WeightedRoundRobin::AddressWeight>+WeightedRoundRobin::GetOrCreateWeight(const grpc_resolved_address& address) {+  auto key = grpc_sockaddr_to_uri(&address);+  if (!key.ok()) return nullptr;+  MutexLock lock(&address_weight_map_mu_);+  auto it = address_weight_map_.find(*key);+  if (it != address_weight_map_.end()) {+    auto weight = it->second->RefIfNonZero();+    if (weight != nullptr) return weight;+  }+  auto weight =+      MakeRefCounted<AddressWeight>(Ref(DEBUG_LOCATION, ""AddressWeight""), *key);+  address_weight_map_.emplace(*key, weight.get());+  return weight;+}++//+// WeightedRoundRobin::WeightedRoundRobinSubchannelList+//++void WeightedRoundRobin::WeightedRoundRobinSubchannelList::+    UpdateStateCountersLocked(absl::optional<grpc_connectivity_state> old_state,+                              grpc_connectivity_state new_state) {+  if (old_state.has_value()) {+    GPR_ASSERT(*old_state != GRPC_CHANNEL_SHUTDOWN);+    if (*old_state == GRPC_CHANNEL_READY) {+      GPR_ASSERT(num_ready_ > 0);+      --num_ready_;+    } else if (*old_state == GRPC_CHANNEL_CONNECTING) {+      GPR_ASSERT(num_connecting_ > 0);+      --num_connecting_;+    } else if (*old_state == GRPC_CHANNEL_TRANSIENT_FAILURE) {+      GPR_ASSERT(num_transient_failure_ > 0);+      --num_transient_failure_;+    }+  }+  GPR_ASSERT(new_state != GRPC_CHANNEL_SHUTDOWN);+  if (new_state == GRPC_CHANNEL_READY) {+    ++num_ready_;+  } else if (new_state == GRPC_CHANNEL_CONNECTING) {+    ++num_connecting_;+  } else if (new_state == GRPC_CHANNEL_TRANSIENT_FAILURE) {+    ++num_transient_failure_;+  }+}++void WeightedRoundRobin::WeightedRoundRobinSubchannelList::+    MaybeUpdateAggregatedConnectivityStateLocked(absl::Status status_for_tf) {+  WeightedRoundRobin* p = static_cast<WeightedRoundRobin*>(policy());+  // If this is latest_pending_subchannel_list_, then swap it into+  // subchannel_list_ in the following cases:+  // - subchannel_list_ has no READY subchannels.+  // - This list has at least one READY subchannel and we have seen the+  //   initial connectivity state notification for all subchannels.+  // - All of the subchannels in this list are in TRANSIENT_FAILURE.+  //   (This may cause the channel to go from READY to TRANSIENT_FAILURE,+  //   but we're doing what the control plane told us to do.)+  if (p->latest_pending_subchannel_list_.get() == this &&+      (p->subchannel_list_->num_ready_ == 0 ||+       (num_ready_ > 0 && AllSubchannelsSeenInitialState()) ||+       num_transient_failure_ == num_subchannels())) {+    if (GRPC_TRACE_FLAG_ENABLED(grpc_lb_wrr_trace)) {+      const std::string old_counters_string =+          p->subchannel_list_ != nullptr ? p->subchannel_list_->CountersString()+                                         : """";+      gpr_log(+          GPR_INFO,+          ""[WRR %p] swapping out subchannel list %p (%s) in favor of %p (%s)"",+          p, p->subchannel_list_.get(), old_counters_string.c_str(), this,+          CountersString().c_str());+    }+    p->subchannel_list_ = std::move(p->latest_pending_subchannel_list_);+  }+  // Only set connectivity state if this is the current subchannel list.+  if (p->subchannel_list_.get() != this) return;+  // First matching rule wins:+  // 1) ANY subchannel is READY => policy is READY.+  // 2) ANY subchannel is CONNECTING => policy is CONNECTING.+  // 3) ALL subchannels are TRANSIENT_FAILURE => policy is TRANSIENT_FAILURE.+  if (num_ready_ > 0) {+    if (GRPC_TRACE_FLAG_ENABLED(grpc_lb_wrr_trace)) {+      gpr_log(GPR_INFO, ""[WRR %p] reporting READY with subchannel list %p"", p,+              this);+    }+    p->channel_control_helper()->UpdateState(+        GRPC_CHANNEL_READY, absl::Status(),+        MakeRefCounted<Picker>(p->Ref(), this));+  } else if (num_connecting_ > 0) {+    if (GRPC_TRACE_FLAG_ENABLED(grpc_lb_wrr_trace)) {+      gpr_log(GPR_INFO, ""[WRR %p] reporting CONNECTING with subchannel list %p"",+              p, this);+    }+    p->channel_control_helper()->UpdateState(+        GRPC_CHANNEL_CONNECTING, absl::Status(),+        MakeRefCounted<QueuePicker>(p->Ref(DEBUG_LOCATION, ""QueuePicker"")));+  } else if (num_transient_failure_ == num_subchannels()) {+    if (GRPC_TRACE_FLAG_ENABLED(grpc_lb_wrr_trace)) {+      gpr_log(+          GPR_INFO,+          ""[WRR %p] reporting TRANSIENT_FAILURE with subchannel list %p: %s"", p,+          this, status_for_tf.ToString().c_str());+    }+    if (!status_for_tf.ok()) {+      last_failure_ = absl::UnavailableError(+          absl::StrCat(""connections to all backends failing; last error: "",+                       status_for_tf.ToString()));+    }+    p->channel_control_helper()->UpdateState(+        GRPC_CHANNEL_TRANSIENT_FAILURE, last_failure_,+        MakeRefCounted<TransientFailurePicker>(last_failure_));+  }+}++//+// WeightedRoundRobin::WeightedRoundRobinSubchannelData::OobWatcher+//++void WeightedRoundRobin::WeightedRoundRobinSubchannelData::OobWatcher::+    OnBackendMetricReport(const BackendMetricData& backend_metric_data) {+  weight_->MaybeUpdateWeight(backend_metric_data.qps,+                             backend_metric_data.cpu_utilization);+}++//+// WeightedRoundRobin::WeightedRoundRobinSubchannelData+//++WeightedRoundRobin::WeightedRoundRobinSubchannelData::+    WeightedRoundRobinSubchannelData(+        SubchannelList<WeightedRoundRobinSubchannelList,+                       WeightedRoundRobinSubchannelData>* subchannel_list,+        const ServerAddress& address, RefCountedPtr<SubchannelInterface> sc)+    : SubchannelData(subchannel_list, address, std::move(sc)),+      weight_(static_cast<WeightedRoundRobin*>(subchannel_list->policy())+                  ->GetOrCreateWeight(address.address())) {+  // Start OOB watch if configured.+  WeightedRoundRobin* p =+      static_cast<WeightedRoundRobin*>(subchannel_list->policy());+  if (p->config_->enable_oob_load_report()) {+    subchannel()->AddDataWatcher(+        MakeOobBackendMetricWatcher(p->config_->oob_reporting_period(),+                                    std::make_unique<OobWatcher>(weight_)));+  }+}++void WeightedRoundRobin::WeightedRoundRobinSubchannelData::+    ProcessConnectivityChangeLocked(+        absl::optional<grpc_connectivity_state> old_state,+        grpc_connectivity_state new_state) {+  WeightedRoundRobin* p =+      static_cast<WeightedRoundRobin*>(subchannel_list()->policy());+  GPR_ASSERT(subchannel() != nullptr);+  // If this is not the initial state notification and the new state is+  // TRANSIENT_FAILURE or IDLE, re-resolve.+  // Note that we don't want to do this on the initial state notification,+  // because that would result in an endless loop of re-resolution.+  if (old_state.has_value() && (new_state == GRPC_CHANNEL_TRANSIENT_FAILURE ||+                                new_state == GRPC_CHANNEL_IDLE)) {+    if (GRPC_TRACE_FLAG_ENABLED(grpc_lb_wrr_trace)) {+      gpr_log(GPR_INFO,+              ""[WRR %p] Subchannel %p reported %s; requesting re-resolution"", p,+              subchannel(), ConnectivityStateName(new_state));+    }+    p->channel_control_helper()->RequestReresolution();+  }+  if (new_state == GRPC_CHANNEL_IDLE) {+    if (GRPC_TRACE_FLAG_ENABLED(grpc_lb_wrr_trace)) {+      gpr_log(GPR_INFO,+              ""[WRR %p] Subchannel %p reported IDLE; requesting connection"", p,+              subchannel());+    }+    subchannel()->RequestConnection();+  } else if (new_state == GRPC_CHANNEL_READY) {+    // If we transition back to READY state, restart the blackout period.+    // Note that we cannot guarantee that we will never receive+    // lingering callbacks for backend metric reports from the previous+    // connection after the new connection has been established, but they+    // should be masked by new backend metric reports from the new+    // connection by the time the blackout period ends.+    weight_->ResetNonEmptySince();","Doing this later is actually safer than doing it earlier, because it minimizes the chances of the data being changed by a lingering callback for a backend metric report from the previous connection.  The longer we wait after the previous connection fails, the less likely it is that there are any lingering callbacks from the previous connection.There is no need to modify the weight or the last update timestamp, since the value will not be used if we are within the blackout period.",
9566254,apolcyn,https://api.github.com/repos/grpc/grpc/pulls/31867,1072674472,2023-01-17T18:55:49Z,src/core/tsi/alts/handshaker/alts_handshaker_client.cc,"@@ -732,16 +732,14 @@ alts_handshaker_client* alts_grpc_handshaker_client_create(   client->handshake_status_details = grpc_empty_slice();   client->max_frame_size = max_frame_size;   client->error = error;-  grpc_slice slice = grpc_slice_from_copied_string(handshaker_service_url);",nit: we can delete `handshaker_service_url` as a parameter since it looks unused now,X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32106,1072684769,2023-01-17T19:07:11Z,include/grpcpp/server_builder.h,"@@ -251,6 +251,16 @@ class ServerBuilder {   /// doc/workarounds.md.   ServerBuilder& EnableWorkaround(grpc_workaround_list id); +  // Enables per-call load reporting. The server will automatically send the+  // load metrics after each RPC. The caller can report load metrics for the+  // current call to what \a ServerContext::GetCallMetricRecorder() returns.+  // The server merges metrics from the optional \a server_metric_recorder when+  // provided where the call metric recorder take a higher precedence.+  // The caller owns and must ensure the server metric recorder outlives the+  // server.+  ServerBuilder& EnableCallMetricRecording(","For now, we want to keep the backend metric APIs experimental, so I don't think we want to add a first-class method like this.  We should instead stick with the existing experimental API:https://github.com/grpc/grpc/blob/baedc454e73cd8144ebb1c299a6babfb61a85f9f/include/grpcpp/ext/call_metric_recorder.h#L47I think it would be fine to add a `ServerMetricRecorder*` parameter to that function.Alternatively, we can replace that function with a new method on the `experimental_type` class below.  That approach might make it easier to pass the `ServerMetricRecorder*` to the `ServerBuilder`, because the `experimental_type` class is nested inside `ServerBuilder` and thus has access to its private data members.  If we stick with the external standalone function, we'll need to either make `experimental::EnableCallMetricRecording()` a friend of this class or pass the `ServerMetricRecorder*` via a new channel arg.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32106,1072689468,2023-01-17T19:12:29Z,include/grpcpp/server_context.h,"@@ -115,10 +120,46 @@ class ServerContextTestSpouse; class DefaultReactorTestPeer; }  // namespace testing -namespace experimental {-class OrcaServerInterceptor;-class CallMetricRecorder;-}  // namespace experimental+class CallMetricRecorder {",We want to keep this API experimental for now.  Please modify the existing definition in https://github.com/grpc/grpc/blob/master/include/grpcpp/ext/call_metric_recorder.h instead of duplicating it here.,X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32106,1072690760,2023-01-17T19:14:08Z,include/grpcpp/server_context.h,"@@ -51,6 +51,11 @@ struct grpc_metadata; struct grpc_call; struct census_context; +namespace grpc_core {","It should not be necessary to declare anything in the `grpc_core` namespace in a header file for the C++ public API.The `BackendMetricData` forward declaration does not need to be in this file, because it's not referred to anywhere in this file.The `ServerMetricRecorder` class should not be in the `grpc_core` namespace to begin with.  That's a C++-layer type, so it belongs in the `grpc` namespace, and it should be defined in a public header, so that it does not need a forward declaration here.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32106,1072695026,2023-01-17T19:19:26Z,src/core/BUILD,"@@ -3589,12 +3589,19 @@ grpc_cc_library(  grpc_cc_library(     name = ""grpc_backend_metric_data"",+    srcs = [+        ""ext/filters/load_reporting/backend_metric_data.cc"",+    ],     hdrs = [-        ""ext/filters/client_channel/lb_policy/backend_metric_data.h"",+        ""ext/filters/load_reporting/backend_metric_data.h"",","This does not belong in the load_reporting directory.  That directory is specifically for grpclb-based load reporting, which is not what this backend metric code is about.Instead, I suggest creating a new `ext/filters/backend_metrics` directory to contain this new filter and related files.",
1644595,gnossen,https://api.github.com/repos/grpc/grpc/pulls/31183,1072695151,2023-01-17T19:19:35Z,bazel/grpc_extra_deps.bzl,"@@ -53,7 +56,7 @@ def grpc_extra_deps(ignore_version_differences = False):     api_dependencies()      go_rules_dependencies()-    go_register_toolchains(version = ""1.18"")+    go_register_toolchains(version = go_version if go_version != ""host"" else None)","So if `go_version` is `""host""` here, we pass `None` to `go_register_toolchains`? This seems like it would be used for [registering a custom toolchain](https://github.com/bazelbuild/rules_go/blob/master/go/toolchains.rst#registering-a-custom-sdk), not using [the installed toolchain](https://github.com/bazelbuild/rules_go/blob/master/go/toolchains.rst#using-the-installed-go-sdk).Is there any reason not to just pass the `go_version` kwarg of `grpc_extra_deps` unmodified to `go_register_toolchains`?",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32106,1072696574,2023-01-17T19:21:20Z,src/core/ext/filters/load_reporting/backend_metric_data.cc,"@@ -0,0 +1,98 @@+#include ""src/core/ext/filters/load_reporting/backend_metric_data.h""++#include ""src/core/lib/debug/trace.h""++namespace grpc_core {++TraceFlag grpc_server_metric_recorder_trace(false, ""server_metric_recorder"");++namespace {++// All utilization values must be in [0, 1].+bool IsUtilizationValid(double utilization) {+  return utilization >= 0.0 && utilization <= 1.0;+}++// QPS must be in [0, infy).+bool IsQpsValid(double utilization) {",Please rename this parameter to `qps`.,X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32106,1072697734,2023-01-17T19:22:45Z,src/core/ext/filters/load_reporting/backend_metric_data.h,"@@ -0,0 +1,106 @@+/*+ *+ * Copyright 2022 gRPC authors.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ *     http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ *+ */++#ifndef GRPC_CORE_EXT_FILTERS_LOAD_REPORTING_BACKEND_METRIC_DATA_H+#define GRPC_CORE_EXT_FILTERS_LOAD_REPORTING_BACKEND_METRIC_DATA_H++#include <grpc/support/port_platform.h>++#include <atomic>+#include <map>++#include ""src/core/lib/gprpp/sync.h""+#include ""absl/strings/string_view.h""++namespace grpc {+class BackendMetricState;+}  // namespace grpc+ +namespace grpc_core {++// Represents backend metrics reported by the backend to the client.+struct BackendMetricData {+  /// CPU utilization expressed as a fraction of available CPU resources.+  double cpu_utilization = -1;+  /// Memory utilization expressed as a fraction of available memory+  /// resources.+  double mem_utilization = -1;+  /// Queries per second to the server.+  double qps = -1;+  /// Application-specific requests cost metrics.  Metric names are+  /// determined by the application.  Each value is an absolute cost+  /// (e.g. 3487 bytes of storage) associated with the request.+  std::map<absl::string_view, double> request_cost;+  /// Application-specific resource utilization metrics.  Metric names+  /// are determined by the application.  Each value is expressed as a+  /// fraction of total resources available.+  std::map<absl::string_view, double> utilization;+};++class BackendMetricProvider {+ public:+  virtual ~BackendMetricProvider() = default;+  // Only populates fields in `data` that this has recorded metrics.+  virtual void GetBackendMetricData(BackendMetricData* data) = 0;+};++class ServerMetricRecorder {","As mentioned elsewhere, this needs to be a C++ class, defined in a public header in the `grpc` namespace (*not* in the `grpc_core` namespace).  There should be nothing inside of C-core that knows about this class.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32106,1072699130,2023-01-17T19:24:28Z,src/core/ext/filters/load_reporting/backend_metric_data.h,"@@ -0,0 +1,106 @@+/*+ *+ * Copyright 2022 gRPC authors.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ *     http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ *+ */++#ifndef GRPC_CORE_EXT_FILTERS_LOAD_REPORTING_BACKEND_METRIC_DATA_H+#define GRPC_CORE_EXT_FILTERS_LOAD_REPORTING_BACKEND_METRIC_DATA_H++#include <grpc/support/port_platform.h>++#include <atomic>+#include <map>++#include ""src/core/lib/gprpp/sync.h""+#include ""absl/strings/string_view.h""++namespace grpc {+class BackendMetricState;+}  // namespace grpc+ +namespace grpc_core {++// Represents backend metrics reported by the backend to the client.+struct BackendMetricData {","I think this struct should continue to be in its own header file.  It is used both on the client side and the server side, whereas the `BackendMetricProvider` API defined below is used only on the server side.  We don't want client-side code to have to pull in server-side dependencies.I suggest having this struct in a file called backend_metric_data.h, and then have a separate file called backend_metric_provider.h that includes backend_metric_data.h and defines `BackendMetricProvider`.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32106,1072701434,2023-01-17T19:27:13Z,src/core/ext/filters/load_reporting/backend_metric_data.h,"@@ -0,0 +1,106 @@+/*+ *+ * Copyright 2022 gRPC authors.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ *     http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ *+ */++#ifndef GRPC_CORE_EXT_FILTERS_LOAD_REPORTING_BACKEND_METRIC_DATA_H+#define GRPC_CORE_EXT_FILTERS_LOAD_REPORTING_BACKEND_METRIC_DATA_H++#include <grpc/support/port_platform.h>++#include <atomic>+#include <map>++#include ""src/core/lib/gprpp/sync.h""+#include ""absl/strings/string_view.h""++namespace grpc {+class BackendMetricState;+}  // namespace grpc+ +namespace grpc_core {++// Represents backend metrics reported by the backend to the client.+struct BackendMetricData {+  /// CPU utilization expressed as a fraction of available CPU resources.+  double cpu_utilization = -1;+  /// Memory utilization expressed as a fraction of available memory+  /// resources.+  double mem_utilization = -1;+  /// Queries per second to the server.+  double qps = -1;+  /// Application-specific requests cost metrics.  Metric names are+  /// determined by the application.  Each value is an absolute cost+  /// (e.g. 3487 bytes of storage) associated with the request.+  std::map<absl::string_view, double> request_cost;+  /// Application-specific resource utilization metrics.  Metric names+  /// are determined by the application.  Each value is expressed as a+  /// fraction of total resources available.+  std::map<absl::string_view, double> utilization;+};++class BackendMetricProvider {+ public:+  virtual ~BackendMetricProvider() = default;+  // Only populates fields in `data` that this has recorded metrics.+  virtual void GetBackendMetricData(BackendMetricData* data) = 0;",This should just return a new `BackendMetricData` instance rather than taking a parameter.,
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32106,1072703254,2023-01-17T19:29:10Z,src/core/ext/filters/load_reporting/backend_metric_data.h,"@@ -0,0 +1,106 @@+/*+ *+ * Copyright 2022 gRPC authors.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ *     http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ *+ */++#ifndef GRPC_CORE_EXT_FILTERS_LOAD_REPORTING_BACKEND_METRIC_DATA_H+#define GRPC_CORE_EXT_FILTERS_LOAD_REPORTING_BACKEND_METRIC_DATA_H++#include <grpc/support/port_platform.h>++#include <atomic>+#include <map>++#include ""src/core/lib/gprpp/sync.h""+#include ""absl/strings/string_view.h""++namespace grpc {","We cannot use anything in the `grpc` namespace (i.e., the C++ layer) from inside the `grpc_core` namespace (i.e., the C-core layer), because C-core can be built for wrapped languages without the C++ layer.The `BackendMetricState` class should not be visible inside of C-core.  It is an implementation detail of the C++ layer.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32106,1072722065,2023-01-17T19:47:10Z,src/core/lib/surface/init.cc,"@@ -111,6 +120,8 @@ void RegisterSecurityFilters(CoreConfiguration::Builder* builder) {   // depends on to be higher on the channel stack.   builder->channel_init()->RegisterStage(       GRPC_SERVER_CHANNEL, INT_MAX - 2, maybe_prepend_grpc_server_authz_filter);+  builder->channel_init()->RegisterStage(","This does not belong in this function, because it's not a security-related filter.  Instead, the filter should define its own registration method, which should be called in grpc_plugin_registry.cc.As an example, here's the registration method defined for the message_size filter:https://github.com/grpc/grpc/blob/baedc454e73cd8144ebb1c299a6babfb61a85f9f/src/core/ext/filters/message_size/message_size_filter.cc#L361It is declared here:https://github.com/grpc/grpc/blob/baedc454e73cd8144ebb1c299a6babfb61a85f9f/src/core/plugin_registry/grpc_plugin_registry.cc#L46And here's where it's called:https://github.com/grpc/grpc/blob/baedc454e73cd8144ebb1c299a6babfb61a85f9f/src/core/plugin_registry/grpc_plugin_registry.cc#L93",X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32106,1072759359,2023-01-17T20:18:10Z,src/cpp/server/server_cc.cc,"@@ -171,6 +171,9 @@ bool ServerInterface::BaseAsyncRequest::FinalizeResult(void** tag,     return true;   }   context_->set_call(call_);","Instead of adding new code to all callers of `set_call()`, how about just adding a `ServerMetricRecorder*` parameter to `set_call()`?  That way, we're guaranteed that we don't accidentally miss any callers.",X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32106,1072761708,2023-01-17T20:20:10Z,src/cpp/server/server_context.cc,"@@ -54,12 +53,154 @@ #include <grpcpp/support/string_ref.h>  #include ""src/core/lib/gprpp/crash.h""+#include ""src/core/ext/filters/load_reporting/backend_metric_data.h"" #include ""src/core/lib/gprpp/ref_counted.h"" #include ""src/core/lib/gprpp/sync.h""-#include ""src/core/lib/resource_quota/arena.h"" #include ""src/core/lib/surface/call.h"" +grpc_core::TraceFlag grpc_backend_metric_state_trace(false, ""backend_metric_state"");+ namespace grpc {+namespace {+// All utilization values must be in [0, 1].+bool IsUtilizationValid(double utilization) {+  return utilization >= 0.0 && utilization <= 1.0;+}++// QPS must be in [0, infy).+bool IsQpsValid(double utilization) {",Please rename the parameter to `qps`.,X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32106,1072767221,2023-01-17T20:24:33Z,src/cpp/server/server_context.cc,"@@ -397,10 +538,18 @@ void ServerContextBase::SetLoadReportingCosts(   } } -void ServerContextBase::CreateCallMetricRecorder() {-  GPR_ASSERT(call_metric_recorder_ == nullptr);-  grpc_core::Arena* arena = grpc_call_get_arena(call_.call);-  call_metric_recorder_ = arena->New<experimental::CallMetricRecorder>(arena);+void ServerContextBase::CreateCallMetricRecorder(+    grpc_core::ServerMetricRecorder* server_metric_recorder) {+  if (call_metric_recorder_ == nullptr) {+    grpc_core::Arena* arena = grpc_call_get_arena(call_.call);+    auto* backend_metric_state =+        arena->New<BackendMetricState>(server_metric_recorder);+    call_metric_recorder_ = backend_metric_state;+    grpc_call_context_set(+        call_.call, GRPC_CONTEXT_BACKEND_METRICS,+        static_cast<grpc_core::BackendMetricProvider*>(backend_metric_state),","There's no need for this cast.  The `grpc_call_context_set()` method takes a `void*` parameter, so you can pass any pointer type.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32106,1072768324,2023-01-17T20:25:21Z,src/cpp/server/server_context.cc,"@@ -397,10 +538,18 @@ void ServerContextBase::SetLoadReportingCosts(   } } -void ServerContextBase::CreateCallMetricRecorder() {-  GPR_ASSERT(call_metric_recorder_ == nullptr);-  grpc_core::Arena* arena = grpc_call_get_arena(call_.call);-  call_metric_recorder_ = arena->New<experimental::CallMetricRecorder>(arena);+void ServerContextBase::CreateCallMetricRecorder(+    grpc_core::ServerMetricRecorder* server_metric_recorder) {+  if (call_metric_recorder_ == nullptr) {+    grpc_core::Arena* arena = grpc_call_get_arena(call_.call);+    auto* backend_metric_state =","I don't think there's any need for this temporary variable.  I think we can just directly set `call_metric_recorder_`, and then pass `call_metric_recorder_` to `grpc_call_context_set()`.",X
52979934,matthewstevenson88,https://api.github.com/repos/grpc/grpc/pulls/31867,1072889919,2023-01-17T22:24:46Z,src/core/tsi/alts/handshaker/alts_handshaker_client.cc,"@@ -732,16 +732,14 @@ alts_handshaker_client* alts_grpc_handshaker_client_create(   client->handshake_status_details = grpc_empty_slice();   client->max_frame_size = max_frame_size;   client->error = error;-  grpc_slice slice = grpc_slice_from_copied_string(handshaker_service_url);","It may be slightly tricky to remove the `handshaker_service_url` parameter since it's used on the next line:``` client->call = strcmp(handshaker_service_url, ALTS_HANDSHAKER_SERVICE_URL_FOR_TESTING) == 0 ? nullptr : ...```If this the `strcmp` is removed and `grpc_channel_create_pollset_set_call(...)` is always used instead, then we need to refactor the unit tests, which rely on this line, I think. If this is something you'd like to be done long-term, please file a bug and assign to me and I can clean it up when I have cycles.",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/31500,1072892775,2023-01-17T22:29:04Z,src/core/BUILD,"@@ -1302,14 +1349,39 @@ grpc_cc_library(     ], ) +grpc_cc_library(+    name = ""event_engine_interface"",",agree this should move - i'd argue that since this sprung out of an existing library in src/core let's keep it there for this pr and move it in the next one.,
672669,sergiitk,https://api.github.com/repos/grpc/grpc/pulls/31569,1073034922,2023-01-18T02:34:16Z,tools/internal_ci/linux/grpc_xds_k8s_run_test.sh,"@@ -0,0 +1,96 @@+#!/usr/bin/env bash+# Copyright 2022 gRPC authors.+#+# Licensed under the Apache License, Version 2.0 (the ""License"");+# you may not use this file except in compliance with the License.+# You may obtain a copy of the License at+#+#     http://www.apache.org/licenses/LICENSE-2.0+#+# Unless required by applicable law or agreed to in writing, software+# distributed under the License is distributed on an ""AS IS"" BASIS,+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+# See the License for the specific language governing permissions and+# limitations under the License.++## xDS test server/client Docker images+readonly IMAGE_REPO=""gcr.io/grpc-testing/xds-interop""++find_latest() {+  gcloud container images list-tags --filter=tags\~v1\.\\d\\d\.x ""${IMAGE_REPO}/${1}-${2}"" '--format=table[no-heading](tags)' | awk -F, '{print $2}' | sort | tail -n 1+}++if [ ""${LATEST_BRANCH}"" == """" ]; then+  cpp_server=$(find_latest cpp server)+  cpp_client=$(find_latest cpp client)+  go_server=$(find_latest go server)+  go_client=$(find_latest go client)+  java_server=$(find_latest java server)+  java_client=$(find_latest java client)+  LATEST_BRANCH=""$((echo $cpp_server; echo $cpp_client; echo $go_server; echo $go_client; echo $java_server; echo $java_client;) | sort -g | head -1)""","Ah - I accidentally deleted the comment. I was recommending switching to `printf`:> The printf command is recommended as a more portable and flexible replacement for tasks historically performed by echo.>  https://www.gnu.org/software/coreutils/manual/html_node/echo-invocation.html```sh java_server=""v1.52.x""  java_client=""v1.52.x""  cpp_server=""v1.52.x""  cpp_client=""v1.50.x""  go_server=""v1.51.x""  go_client=""v1.51.x"" printf ""%s\n"" ""${cpp_server}"" ""${cpp_client}"" ""${go_server}"" ""${go_client}"" ""${java_server}"" ""${java_client}""v1.52.xv1.50.xv1.51.xv1.51.xv1.52.xv1.52.x printf ""%s\n"" ""${cpp_server}"" ""${cpp_client}"" ""${go_server}"" ""${go_client}"" ""${java_server}"" ""${java_client}"" | sort --version-sort | head -1v1.50.x```",
110920239,erm-g,https://api.github.com/repos/grpc/grpc/pulls/31867,1073074530,2023-01-18T04:01:47Z,src/core/tsi/alts/handshaker/alts_handshaker_client.cc,"@@ -732,16 +732,14 @@ alts_handshaker_client* alts_grpc_handshaker_client_create(   client->handshake_status_details = grpc_empty_slice();   client->max_frame_size = max_frame_size;   client->error = error;-  grpc_slice slice = grpc_slice_from_copied_string(handshaker_service_url);",@matthewstevenson88 IIUC `handshaker_service_url ` is not removed from the parameter list of `alts_grpc_handshaker_client_create` so it still can be used in `strcmp` LOC. The commit removes it only from `grpc_channel_create_pollset_set_call ` (replaces with `nullptr`) so `alts_handshaker_client.cc` looks fine.However I couldn't find relevant tests across the codebase for `grpc_channel_create_pollset_set_call(...)` to make sure that authority will be calculated correctly. Could anybody point me in the right direction?,
672669,sergiitk,https://api.github.com/repos/grpc/grpc/pulls/31569,1073089015,2023-01-18T04:41:12Z,tools/internal_ci/linux/grpc_xds_k8s_run_xtest.sh,"@@ -0,0 +1,97 @@+#!/usr/bin/env bash+# Copyright 2022 gRPC authors.+#+# Licensed under the Apache License, Version 2.0 (the ""License"");+# you may not use this file except in compliance with the License.+# You may obtain a copy of the License at+#+#     http://www.apache.org/licenses/LICENSE-2.0+#+# Unless required by applicable law or agreed to in writing, software+# distributed under the License is distributed on an ""AS IS"" BASIS,+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+# See the License for the specific language governing permissions and+# limitations under the License.++## xDS test server/client Docker images+readonly IMAGE_REPO=""gcr.io/grpc-testing/xds-interop""++find_latest() {+  gcloud container images list-tags --filter=tags\~v1\.\\d\\d\.x ""${IMAGE_REPO}/${1}-${2}"" '--format=table[no-heading](tags)' | awk -F, '{print $2}' | sort | tail -n 1",```suggestion  gcloud container images list-tags --filter='tags~v1\.\d+\.x' --flatten='tags[]' --format='value(tags)' | sort --version-sort | tail -n 1```1. `--filter='tags~v1\.\d+\.x'` - a better filter; single quoted to  avoid escapes2. `--flatten='tags[]' --format='value(tags)'` - just prints the matched tag name. So awk is not needed3. `sort --version-sort` - see comment to the line 30,
85715732,yousukseung,https://api.github.com/repos/grpc/grpc/pulls/31904,1073180015,2023-01-18T07:35:33Z,src/core/ext/filters/client_channel/lb_policy/weighted_round_robin/weighted_round_robin.cc,"@@ -0,0 +1,955 @@+//+// Copyright 2022 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+//++#include <grpc/support/port_platform.h>++#include <inttypes.h>+#include <stdlib.h>+#include <string.h>++#include <algorithm>+#include <functional>+#include <map>+#include <memory>+#include <set>+#include <string>+#include <type_traits>+#include <utility>+#include <vector>++#include ""absl/base/thread_annotations.h""+#include ""absl/random/random.h""+#include ""absl/status/status.h""+#include ""absl/status/statusor.h""+#include ""absl/strings/str_cat.h""+#include ""absl/strings/str_join.h""+#include ""absl/strings/string_view.h""+#include ""absl/types/optional.h""++#include <grpc/event_engine/event_engine.h>+#include <grpc/impl/connectivity_state.h>+#include <grpc/support/log.h>++#include ""src/core/ext/filters/client_channel/lb_policy/backend_metric_data.h""+#include ""src/core/ext/filters/client_channel/lb_policy/oob_backend_metric.h""+#include ""src/core/ext/filters/client_channel/lb_policy/subchannel_list.h""+#include ""src/core/ext/filters/client_channel/lb_policy/weighted_round_robin/static_stride_scheduler.h""+#include ""src/core/lib/address_utils/sockaddr_utils.h""+#include ""src/core/lib/channel/channel_args.h""+#include ""src/core/lib/config/core_configuration.h""+#include ""src/core/lib/debug/trace.h""+#include ""src/core/lib/gprpp/debug_location.h""+#include ""src/core/lib/gprpp/orphanable.h""+#include ""src/core/lib/gprpp/ref_counted.h""+#include ""src/core/lib/gprpp/ref_counted_ptr.h""+#include ""src/core/lib/gprpp/sync.h""+#include ""src/core/lib/gprpp/time.h""+#include ""src/core/lib/gprpp/validation_errors.h""+#include ""src/core/lib/iomgr/exec_ctx.h""+#include ""src/core/lib/iomgr/resolved_address.h""+#include ""src/core/lib/json/json.h""+#include ""src/core/lib/json/json_args.h""+#include ""src/core/lib/json/json_object_loader.h""+#include ""src/core/lib/load_balancing/lb_policy.h""+#include ""src/core/lib/load_balancing/lb_policy_factory.h""+#include ""src/core/lib/load_balancing/subchannel_interface.h""+#include ""src/core/lib/resolver/server_address.h""+#include ""src/core/lib/transport/connectivity_state.h""++namespace grpc_core {++TraceFlag grpc_lb_wrr_trace(false, ""weighted_round_robin_lb"");++namespace {++constexpr absl::string_view kWeightedRoundRobin =+    ""weighted_round_robin_experimental"";++// Config for WRR policy.+class WeightedRoundRobinConfig : public LoadBalancingPolicy::Config {+ public:+  WeightedRoundRobinConfig() = default;++  WeightedRoundRobinConfig(const WeightedRoundRobinConfig&) = delete;+  WeightedRoundRobinConfig& operator=(const WeightedRoundRobinConfig&) = delete;++  WeightedRoundRobinConfig(WeightedRoundRobinConfig&&) = delete;+  WeightedRoundRobinConfig& operator=(WeightedRoundRobinConfig&&) = delete;++  absl::string_view name() const override { return kWeightedRoundRobin; }++  bool enable_oob_load_report() const { return enable_oob_load_report_; }+  Duration oob_reporting_period() const { return oob_reporting_period_; }+  Duration blackout_period() const { return blackout_period_; }+  Duration weight_update_period() const { return weight_update_period_; }+  Duration weight_expiration_period() const {+    return weight_expiration_period_;+  }++  static const JsonLoaderInterface* JsonLoader(const JsonArgs&) {+    static const auto* loader =+        JsonObjectLoader<WeightedRoundRobinConfig>()+            .OptionalField(""enableOobLoadReport"",+                           &WeightedRoundRobinConfig::enable_oob_load_report_)+            .OptionalField(""oobReportingPeriod"",+                           &WeightedRoundRobinConfig::oob_reporting_period_)+            .OptionalField(""blackoutPeriod"",+                           &WeightedRoundRobinConfig::blackout_period_)+            .OptionalField(""weightUpdatePeriod"",+                           &WeightedRoundRobinConfig::weight_update_period_)+            .OptionalField(""weightExpirationPeriod"",+                           &WeightedRoundRobinConfig::weight_expiration_period_)+            .Finish();+    return loader;+  }++  void JsonPostLoad(const Json&, const JsonArgs&, ValidationErrors*) {+    // Impose lower bound of 100ms on weightUpdatePeriod.+    weight_update_period_ =+        std::max(weight_update_period_, Duration::Milliseconds(100));+  }++ private:+  bool enable_oob_load_report_ = false;+  Duration oob_reporting_period_ = Duration::Seconds(10);+  Duration blackout_period_ = Duration::Seconds(10);+  Duration weight_update_period_ = Duration::Seconds(1);+  Duration weight_expiration_period_ = Duration::Minutes(3);+};++// WRR LB policy.+class WeightedRoundRobin : public LoadBalancingPolicy {+ public:+  explicit WeightedRoundRobin(Args args);++  absl::string_view name() const override { return kWeightedRoundRobin; }++  absl::Status UpdateLocked(UpdateArgs args) override;+  void ResetBackoffLocked() override;++ private:+  // Represents the weight for a given address.+  class AddressWeight : public RefCounted<AddressWeight> {+   public:+    AddressWeight(RefCountedPtr<WeightedRoundRobin> wrr, std::string key)+        : wrr_(std::move(wrr)), key_(std::move(key)) {}+    ~AddressWeight() override;++    void MaybeUpdateWeight(double qps, double cpu_utilization);++    float GetWeight(Timestamp now, Duration weight_expiration_period,+                    Duration blackout_period);++    void ResetNonEmptySince();++   private:+    RefCountedPtr<WeightedRoundRobin> wrr_;+    const std::string key_;++    Mutex mu_;+    float weight_ ABSL_GUARDED_BY(&mu_) = 0;+    Timestamp non_empty_since_ ABSL_GUARDED_BY(&mu_) = Timestamp::InfFuture();+    Timestamp last_update_time_ ABSL_GUARDED_BY(&mu_) = Timestamp::InfPast();+  };++  // Forward declaration.+  class WeightedRoundRobinSubchannelList;++  // Data for a particular subchannel in a subchannel list.+  // This subclass adds the following functionality:+  // - Tracks the previous connectivity state of the subchannel, so that+  //   we know how many subchannels are in each state.+  class WeightedRoundRobinSubchannelData+      : public SubchannelData<WeightedRoundRobinSubchannelList,+                              WeightedRoundRobinSubchannelData> {+   public:+    WeightedRoundRobinSubchannelData(+        SubchannelList<WeightedRoundRobinSubchannelList,+                       WeightedRoundRobinSubchannelData>* subchannel_list,+        const ServerAddress& address, RefCountedPtr<SubchannelInterface> sc);++    absl::optional<grpc_connectivity_state> connectivity_state() const {+      return logical_connectivity_state_;+    }++    RefCountedPtr<AddressWeight> weight() const { return weight_; }++   private:+    class OobWatcher : public OobBackendMetricWatcher {+     public:+      explicit OobWatcher(RefCountedPtr<AddressWeight> weight)+          : weight_(std::move(weight)) {}++      void OnBackendMetricReport(+          const BackendMetricData& backend_metric_data) override;++     private:+      RefCountedPtr<AddressWeight> weight_;+    };++    // Performs connectivity state updates that need to be done only+    // after we have started watching.+    void ProcessConnectivityChangeLocked(+        absl::optional<grpc_connectivity_state> old_state,+        grpc_connectivity_state new_state) override;++    // Updates the logical connectivity state.+    void UpdateLogicalConnectivityStateLocked(+        grpc_connectivity_state connectivity_state);++    // The logical connectivity state of the subchannel.+    // Note that the logical connectivity state may differ from the+    // actual reported state in some cases (e.g., after we see+    // TRANSIENT_FAILURE, we ignore any subsequent state changes until+    // we see READY).+    absl::optional<grpc_connectivity_state> logical_connectivity_state_;++    RefCountedPtr<AddressWeight> weight_;+  };++  // A list of subchannels.+  class WeightedRoundRobinSubchannelList+      : public SubchannelList<WeightedRoundRobinSubchannelList,+                              WeightedRoundRobinSubchannelData> {+   public:+    WeightedRoundRobinSubchannelList(WeightedRoundRobin* policy,+                                     ServerAddressList addresses,+                                     const ChannelArgs& args)+        : SubchannelList(policy,+                         (GRPC_TRACE_FLAG_ENABLED(grpc_lb_wrr_trace)+                              ? ""WeightedRoundRobinSubchannelList""+                              : nullptr),+                         std::move(addresses), policy->channel_control_helper(),+                         args) {+      // Need to maintain a ref to the LB policy as long as we maintain+      // any references to subchannels, since the subchannels'+      // pollset_sets will include the LB policy's pollset_set.+      policy->Ref(DEBUG_LOCATION, ""subchannel_list"").release();+    }++    ~WeightedRoundRobinSubchannelList() override {+      WeightedRoundRobin* p = static_cast<WeightedRoundRobin*>(policy());+      p->Unref(DEBUG_LOCATION, ""subchannel_list"");+    }++    // Updates the counters of subchannels in each state when a+    // subchannel transitions from old_state to new_state.+    void UpdateStateCountersLocked(+        absl::optional<grpc_connectivity_state> old_state,+        grpc_connectivity_state new_state);++    // Ensures that the right subchannel list is used and then updates+    // the aggregated connectivity state based on the subchannel list's+    // state counters.+    void MaybeUpdateAggregatedConnectivityStateLocked(+        absl::Status status_for_tf);++   private:+    std::string CountersString() const {+      return absl::StrCat(""num_subchannels="", num_subchannels(),+                          "" num_ready="", num_ready_,+                          "" num_connecting="", num_connecting_,+                          "" num_transient_failure="", num_transient_failure_);+    }++    size_t num_ready_ = 0;+    size_t num_connecting_ = 0;+    size_t num_transient_failure_ = 0;++    absl::Status last_failure_;+  };++  // A picker that performs WRR picks with weights based on+  // endpoint-reported utilization and QPS.+  class Picker : public SubchannelPicker {+   public:+    Picker(RefCountedPtr<WeightedRoundRobin> wrr,+           WeightedRoundRobinSubchannelList* subchannel_list);++    ~Picker() override;++    PickResult Pick(PickArgs args) override;++    void Orphan() override;++   private:+    // A call tracker that collects per-call endpoint utilization reports.+    class SubchannelCallTracker : public SubchannelCallTrackerInterface {+     public:+      explicit SubchannelCallTracker(RefCountedPtr<AddressWeight> weight)+          : weight_(std::move(weight)) {}++      void Start() override {}++      void Finish(FinishArgs args) override;++     private:+      RefCountedPtr<AddressWeight> weight_;+    };++    // Info stored about each subchannel.+    struct SubchannelInfo {+      SubchannelInfo(RefCountedPtr<SubchannelInterface> subchannel,+                     RefCountedPtr<AddressWeight> weight)+          : subchannel(std::move(subchannel)), weight(std::move(weight)) {}++      RefCountedPtr<SubchannelInterface> subchannel;+      RefCountedPtr<AddressWeight> weight;+    };++    // Returns the index into subchannels_ to be picked.+    size_t PickIndex();++    // Builds a new scheduler and swaps it into place, then starts a+    // timer for the next update.+    void BuildSchedulerAndStartTimerLocked()+        ABSL_EXCLUSIVE_LOCKS_REQUIRED(&mu_);++    RefCountedPtr<WeightedRoundRobin> wrr_;+    const bool use_per_rpc_utilization_;+    const Duration weight_update_period_;+    const Duration weight_expiration_period_;+    const Duration blackout_period_;+    std::vector<SubchannelInfo> subchannels_;++    Mutex mu_;+    uint32_t scheduler_state_ ABSL_GUARDED_BY(&mu_);+    absl::optional<StaticStrideScheduler> scheduler_ ABSL_GUARDED_BY(&mu_);+    absl::optional<grpc_event_engine::experimental::EventEngine::TaskHandle>+        timer_handle_ ABSL_GUARDED_BY(&mu_);++    // Used when falling back to RR.+    size_t last_picked_index_;+  };++  ~WeightedRoundRobin() override;++  void ShutdownLocked() override;++  RefCountedPtr<AddressWeight> GetOrCreateWeight(+      const grpc_resolved_address& address);++  RefCountedPtr<WeightedRoundRobinConfig> config_;++  // List of subchannels.+  RefCountedPtr<WeightedRoundRobinSubchannelList> subchannel_list_;+  // Latest pending subchannel list.+  // When we get an updated address list, we create a new subchannel list+  // for it here, and we wait to swap it into subchannel_list_ until the new+  // list becomes READY.+  RefCountedPtr<WeightedRoundRobinSubchannelList>+      latest_pending_subchannel_list_;++  Mutex address_weight_map_mu_;+  std::map<std::string, AddressWeight*, std::less<>> address_weight_map_+      ABSL_GUARDED_BY(&address_weight_map_mu_);++  bool shutdown_ = false;++  absl::BitGen bit_gen_;+};++//+// WeightedRoundRobin::AddressWeight+//++WeightedRoundRobin::AddressWeight::~AddressWeight() {+  MutexLock lock(&wrr_->address_weight_map_mu_);+  auto it = wrr_->address_weight_map_.find(key_);+  if (it != wrr_->address_weight_map_.end() && it->second == this) {+    wrr_->address_weight_map_.erase(it);+  }+}++void WeightedRoundRobin::AddressWeight::MaybeUpdateWeight(+    double qps, double cpu_utilization) {+  // Compute weight.+  float weight = 0;+  if (qps > 0 && cpu_utilization > 0) weight = qps / cpu_utilization;+  if (weight == 0) {+    if (GRPC_TRACE_FLAG_ENABLED(grpc_lb_wrr_trace)) {+      gpr_log(GPR_INFO,+              ""[WRR %p] subchannel %s: qps=%f, cpu_utilization=%f: weight=%f ""+              ""(not updating)"",+              wrr_.get(), key_.c_str(), qps, cpu_utilization, weight);+    }+    return;+  }+  Timestamp now = Timestamp::Now();+  // Grab the lock and update the data.+  MutexLock lock(&mu_);+  if (GRPC_TRACE_FLAG_ENABLED(grpc_lb_wrr_trace)) {+    gpr_log(GPR_INFO,+            ""[WRR %p] subchannel %s: qps=%f, cpu_utilization=%f: setting ""+            ""weight=%f weight_=%f now=%s last_update_time_=%s ""+            ""non_empty_since_=%s"",+            wrr_.get(), key_.c_str(), qps, cpu_utilization, weight, weight_,+            now.ToString().c_str(), last_update_time_.ToString().c_str(),+            non_empty_since_.ToString().c_str());+  }+  if (non_empty_since_ == Timestamp::InfFuture()) non_empty_since_ = now;+  weight_ = weight;+  last_update_time_ = now;+}++float WeightedRoundRobin::AddressWeight::GetWeight(+    Timestamp now, Duration weight_expiration_period,+    Duration blackout_period) {+  MutexLock lock(&mu_);+  if (GRPC_TRACE_FLAG_ENABLED(grpc_lb_wrr_trace)) {+    gpr_log(GPR_INFO,+            ""[WRR %p] subchannel %s: getting weight: now=%s ""+            ""weight_expiration_period=%s blackout_period=%s ""+            ""last_update_time_=%s non_empty_since_=%s weight_=%f"",+            wrr_.get(), key_.c_str(), now.ToString().c_str(),+            weight_expiration_period.ToString().c_str(),+            blackout_period.ToString().c_str(),+            last_update_time_.ToString().c_str(),+            non_empty_since_.ToString().c_str(), weight_);+  }+  // If the most recent update was longer ago than the expiration+  // period, reset non_empty_since_ so that we apply the blackout period+  // again if we start getting data again in the future, and return 0.+  if (now - last_update_time_ >= weight_expiration_period) {+    non_empty_since_ = Timestamp::InfFuture();+    return 0;+  }+  // If we don't have at least blackout_period worth of data, return 0.+  if (blackout_period > Duration::Zero() &&+      now - non_empty_since_ < blackout_period) {+    return 0;+  }+  // Otherwise, return the weight.+  return weight_;+}++void WeightedRoundRobin::AddressWeight::ResetNonEmptySince() {+  MutexLock lock(&mu_);+  non_empty_since_ = Timestamp::InfFuture();+}++//+// WeightedRoundRobin::Picker::SubchannelCallTracker+//++void WeightedRoundRobin::Picker::SubchannelCallTracker::Finish(+    FinishArgs args) {+  auto* backend_metric_data =+      args.backend_metric_accessor->GetBackendMetricData();+  double qps = 0;+  double cpu_utilization = 0;+  if (backend_metric_data != nullptr) {+    qps = backend_metric_data->qps;+    cpu_utilization = backend_metric_data->cpu_utilization;+  }+  weight_->MaybeUpdateWeight(qps, cpu_utilization);+}++//+// WeightedRoundRobin::Picker+//++WeightedRoundRobin::Picker::Picker(+    RefCountedPtr<WeightedRoundRobin> wrr,+    WeightedRoundRobinSubchannelList* subchannel_list)+    : wrr_(std::move(wrr)),+      use_per_rpc_utilization_(!wrr_->config_->enable_oob_load_report()),+      weight_update_period_(wrr_->config_->weight_update_period()),+      weight_expiration_period_(wrr_->config_->weight_expiration_period()),+      blackout_period_(wrr_->config_->blackout_period()),+      scheduler_state_(absl::Uniform<uint32_t>(wrr_->bit_gen_)),+      last_picked_index_(absl::Uniform<size_t>(wrr_->bit_gen_)) {+  for (size_t i = 0; i < subchannel_list->num_subchannels(); ++i) {+    WeightedRoundRobinSubchannelData* sd = subchannel_list->subchannel(i);+    if (sd->connectivity_state() == GRPC_CHANNEL_READY) {+      subchannels_.emplace_back(sd->subchannel()->Ref(), sd->weight());+    }+  }+  if (GRPC_TRACE_FLAG_ENABLED(grpc_lb_wrr_trace)) {+    gpr_log(GPR_INFO,+            ""[WRR %p picker %p] created picker from subchannel_list=%p ""+            ""with %"" PRIuPTR "" subchannels"",+            wrr_.get(), this, subchannel_list, subchannels_.size());+  }+  BuildSchedulerAndStartTimerLocked();+}++WeightedRoundRobin::Picker::~Picker() {+  if (GRPC_TRACE_FLAG_ENABLED(grpc_lb_wrr_trace)) {+    gpr_log(GPR_INFO, ""[WRR %p picker %p] destroying picker"", wrr_.get(), this);+  }+}++void WeightedRoundRobin::Picker::Orphan() {+  MutexLock lock(&mu_);+  if (GRPC_TRACE_FLAG_ENABLED(grpc_lb_wrr_trace)) {+    gpr_log(GPR_INFO, ""[WRR %p picker %p] cancelling timer"", wrr_.get(), this);+  }+  wrr_->channel_control_helper()->GetEventEngine()->Cancel(*timer_handle_);+  timer_handle_.reset();+}++WeightedRoundRobin::PickResult WeightedRoundRobin::Picker::Pick(+    PickArgs /*args*/) {+  size_t index = PickIndex();+  GPR_ASSERT(index < subchannels_.size());+  auto& subchannel_info = subchannels_[index];+  // Collect per-call utilization data if needed.+  std::unique_ptr<SubchannelCallTrackerInterface> subchannel_call_tracker;+  if (use_per_rpc_utilization_) {+    subchannel_call_tracker =+        std::make_unique<SubchannelCallTracker>(subchannel_info.weight);+  }+  if (GRPC_TRACE_FLAG_ENABLED(grpc_lb_wrr_trace)) {+    gpr_log(GPR_INFO,+            ""[WRR %p picker %p] returning index %"" PRIuPTR "", subchannel=%p"",+            wrr_.get(), this, index, subchannel_info.subchannel.get());+  }+  return PickResult::Complete(subchannel_info.subchannel,+                              std::move(subchannel_call_tracker));+}++size_t WeightedRoundRobin::Picker::PickIndex() {+  // Grab the mutex and do WRR pick if we have a scheduler.+  {+    MutexLock lock(&mu_);+    if (scheduler_.has_value()) {","I am not clear what you mean by ""before writing the atomic"", but StaticStrideScheduler::Pick() loops and the loop count is technically unbounded with a non-negligible chance to loop for a single-digit number of times. AFAIK this is a known trade-off that StaticStrideScheduler::Pick() design takes but assuming it's concurrent. I think we should use StaticStrideScheduler in a way that it is designed and optimized for now, esp. given there's an upcoming PR to make it concurrent.And I recall the LB pick() call was mentioned as one of the most important choke point in Stubby in the past. Any delay here adds up to the RPC latency directly that services care the most, so I think it's well worth it to optimize where possible.",
85715732,yousukseung,https://api.github.com/repos/grpc/grpc/pulls/31904,1073211224,2023-01-18T08:12:26Z,src/core/ext/filters/client_channel/lb_policy/weighted_round_robin/weighted_round_robin.cc,"@@ -0,0 +1,955 @@+//+// Copyright 2022 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+//++#include <grpc/support/port_platform.h>++#include <inttypes.h>+#include <stdlib.h>+#include <string.h>++#include <algorithm>+#include <functional>+#include <map>+#include <memory>+#include <set>+#include <string>+#include <type_traits>+#include <utility>+#include <vector>++#include ""absl/base/thread_annotations.h""+#include ""absl/random/random.h""+#include ""absl/status/status.h""+#include ""absl/status/statusor.h""+#include ""absl/strings/str_cat.h""+#include ""absl/strings/str_join.h""+#include ""absl/strings/string_view.h""+#include ""absl/types/optional.h""++#include <grpc/event_engine/event_engine.h>+#include <grpc/impl/connectivity_state.h>+#include <grpc/support/log.h>++#include ""src/core/ext/filters/client_channel/lb_policy/backend_metric_data.h""+#include ""src/core/ext/filters/client_channel/lb_policy/oob_backend_metric.h""+#include ""src/core/ext/filters/client_channel/lb_policy/subchannel_list.h""+#include ""src/core/ext/filters/client_channel/lb_policy/weighted_round_robin/static_stride_scheduler.h""+#include ""src/core/lib/address_utils/sockaddr_utils.h""+#include ""src/core/lib/channel/channel_args.h""+#include ""src/core/lib/config/core_configuration.h""+#include ""src/core/lib/debug/trace.h""+#include ""src/core/lib/gprpp/debug_location.h""+#include ""src/core/lib/gprpp/orphanable.h""+#include ""src/core/lib/gprpp/ref_counted.h""+#include ""src/core/lib/gprpp/ref_counted_ptr.h""+#include ""src/core/lib/gprpp/sync.h""+#include ""src/core/lib/gprpp/time.h""+#include ""src/core/lib/gprpp/validation_errors.h""+#include ""src/core/lib/iomgr/exec_ctx.h""+#include ""src/core/lib/iomgr/resolved_address.h""+#include ""src/core/lib/json/json.h""+#include ""src/core/lib/json/json_args.h""+#include ""src/core/lib/json/json_object_loader.h""+#include ""src/core/lib/load_balancing/lb_policy.h""+#include ""src/core/lib/load_balancing/lb_policy_factory.h""+#include ""src/core/lib/load_balancing/subchannel_interface.h""+#include ""src/core/lib/resolver/server_address.h""+#include ""src/core/lib/transport/connectivity_state.h""++namespace grpc_core {++TraceFlag grpc_lb_wrr_trace(false, ""weighted_round_robin_lb"");++namespace {++constexpr absl::string_view kWeightedRoundRobin =+    ""weighted_round_robin_experimental"";++// Config for WRR policy.+class WeightedRoundRobinConfig : public LoadBalancingPolicy::Config {+ public:+  WeightedRoundRobinConfig() = default;++  WeightedRoundRobinConfig(const WeightedRoundRobinConfig&) = delete;+  WeightedRoundRobinConfig& operator=(const WeightedRoundRobinConfig&) = delete;++  WeightedRoundRobinConfig(WeightedRoundRobinConfig&&) = delete;+  WeightedRoundRobinConfig& operator=(WeightedRoundRobinConfig&&) = delete;++  absl::string_view name() const override { return kWeightedRoundRobin; }++  bool enable_oob_load_report() const { return enable_oob_load_report_; }+  Duration oob_reporting_period() const { return oob_reporting_period_; }+  Duration blackout_period() const { return blackout_period_; }+  Duration weight_update_period() const { return weight_update_period_; }+  Duration weight_expiration_period() const {+    return weight_expiration_period_;+  }++  static const JsonLoaderInterface* JsonLoader(const JsonArgs&) {+    static const auto* loader =+        JsonObjectLoader<WeightedRoundRobinConfig>()+            .OptionalField(""enableOobLoadReport"",+                           &WeightedRoundRobinConfig::enable_oob_load_report_)+            .OptionalField(""oobReportingPeriod"",+                           &WeightedRoundRobinConfig::oob_reporting_period_)+            .OptionalField(""blackoutPeriod"",+                           &WeightedRoundRobinConfig::blackout_period_)+            .OptionalField(""weightUpdatePeriod"",+                           &WeightedRoundRobinConfig::weight_update_period_)+            .OptionalField(""weightExpirationPeriod"",+                           &WeightedRoundRobinConfig::weight_expiration_period_)+            .Finish();+    return loader;+  }++  void JsonPostLoad(const Json&, const JsonArgs&, ValidationErrors*) {+    // Impose lower bound of 100ms on weightUpdatePeriod.+    weight_update_period_ =+        std::max(weight_update_period_, Duration::Milliseconds(100));+  }++ private:+  bool enable_oob_load_report_ = false;+  Duration oob_reporting_period_ = Duration::Seconds(10);+  Duration blackout_period_ = Duration::Seconds(10);+  Duration weight_update_period_ = Duration::Seconds(1);+  Duration weight_expiration_period_ = Duration::Minutes(3);+};++// WRR LB policy.+class WeightedRoundRobin : public LoadBalancingPolicy {+ public:+  explicit WeightedRoundRobin(Args args);++  absl::string_view name() const override { return kWeightedRoundRobin; }++  absl::Status UpdateLocked(UpdateArgs args) override;+  void ResetBackoffLocked() override;++ private:+  // Represents the weight for a given address.+  class AddressWeight : public RefCounted<AddressWeight> {+   public:+    AddressWeight(RefCountedPtr<WeightedRoundRobin> wrr, std::string key)+        : wrr_(std::move(wrr)), key_(std::move(key)) {}+    ~AddressWeight() override;++    void MaybeUpdateWeight(double qps, double cpu_utilization);++    float GetWeight(Timestamp now, Duration weight_expiration_period,+                    Duration blackout_period);++    void ResetNonEmptySince();++   private:+    RefCountedPtr<WeightedRoundRobin> wrr_;+    const std::string key_;++    Mutex mu_;+    float weight_ ABSL_GUARDED_BY(&mu_) = 0;+    Timestamp non_empty_since_ ABSL_GUARDED_BY(&mu_) = Timestamp::InfFuture();+    Timestamp last_update_time_ ABSL_GUARDED_BY(&mu_) = Timestamp::InfPast();+  };++  // Forward declaration.+  class WeightedRoundRobinSubchannelList;++  // Data for a particular subchannel in a subchannel list.+  // This subclass adds the following functionality:+  // - Tracks the previous connectivity state of the subchannel, so that+  //   we know how many subchannels are in each state.+  class WeightedRoundRobinSubchannelData+      : public SubchannelData<WeightedRoundRobinSubchannelList,+                              WeightedRoundRobinSubchannelData> {+   public:+    WeightedRoundRobinSubchannelData(+        SubchannelList<WeightedRoundRobinSubchannelList,+                       WeightedRoundRobinSubchannelData>* subchannel_list,+        const ServerAddress& address, RefCountedPtr<SubchannelInterface> sc);++    absl::optional<grpc_connectivity_state> connectivity_state() const {+      return logical_connectivity_state_;+    }++    RefCountedPtr<AddressWeight> weight() const { return weight_; }++   private:+    class OobWatcher : public OobBackendMetricWatcher {+     public:+      explicit OobWatcher(RefCountedPtr<AddressWeight> weight)+          : weight_(std::move(weight)) {}++      void OnBackendMetricReport(+          const BackendMetricData& backend_metric_data) override;++     private:+      RefCountedPtr<AddressWeight> weight_;+    };++    // Performs connectivity state updates that need to be done only+    // after we have started watching.+    void ProcessConnectivityChangeLocked(+        absl::optional<grpc_connectivity_state> old_state,+        grpc_connectivity_state new_state) override;++    // Updates the logical connectivity state.+    void UpdateLogicalConnectivityStateLocked(+        grpc_connectivity_state connectivity_state);++    // The logical connectivity state of the subchannel.+    // Note that the logical connectivity state may differ from the+    // actual reported state in some cases (e.g., after we see+    // TRANSIENT_FAILURE, we ignore any subsequent state changes until+    // we see READY).+    absl::optional<grpc_connectivity_state> logical_connectivity_state_;++    RefCountedPtr<AddressWeight> weight_;+  };++  // A list of subchannels.+  class WeightedRoundRobinSubchannelList+      : public SubchannelList<WeightedRoundRobinSubchannelList,+                              WeightedRoundRobinSubchannelData> {+   public:+    WeightedRoundRobinSubchannelList(WeightedRoundRobin* policy,+                                     ServerAddressList addresses,+                                     const ChannelArgs& args)+        : SubchannelList(policy,+                         (GRPC_TRACE_FLAG_ENABLED(grpc_lb_wrr_trace)+                              ? ""WeightedRoundRobinSubchannelList""+                              : nullptr),+                         std::move(addresses), policy->channel_control_helper(),+                         args) {+      // Need to maintain a ref to the LB policy as long as we maintain+      // any references to subchannels, since the subchannels'+      // pollset_sets will include the LB policy's pollset_set.+      policy->Ref(DEBUG_LOCATION, ""subchannel_list"").release();+    }++    ~WeightedRoundRobinSubchannelList() override {+      WeightedRoundRobin* p = static_cast<WeightedRoundRobin*>(policy());+      p->Unref(DEBUG_LOCATION, ""subchannel_list"");+    }++    // Updates the counters of subchannels in each state when a+    // subchannel transitions from old_state to new_state.+    void UpdateStateCountersLocked(+        absl::optional<grpc_connectivity_state> old_state,+        grpc_connectivity_state new_state);++    // Ensures that the right subchannel list is used and then updates+    // the aggregated connectivity state based on the subchannel list's+    // state counters.+    void MaybeUpdateAggregatedConnectivityStateLocked(+        absl::Status status_for_tf);++   private:+    std::string CountersString() const {+      return absl::StrCat(""num_subchannels="", num_subchannels(),+                          "" num_ready="", num_ready_,+                          "" num_connecting="", num_connecting_,+                          "" num_transient_failure="", num_transient_failure_);+    }++    size_t num_ready_ = 0;+    size_t num_connecting_ = 0;+    size_t num_transient_failure_ = 0;++    absl::Status last_failure_;+  };++  // A picker that performs WRR picks with weights based on+  // endpoint-reported utilization and QPS.+  class Picker : public SubchannelPicker {+   public:+    Picker(RefCountedPtr<WeightedRoundRobin> wrr,+           WeightedRoundRobinSubchannelList* subchannel_list);++    ~Picker() override;++    PickResult Pick(PickArgs args) override;++    void Orphan() override;++   private:+    // A call tracker that collects per-call endpoint utilization reports.+    class SubchannelCallTracker : public SubchannelCallTrackerInterface {+     public:+      explicit SubchannelCallTracker(RefCountedPtr<AddressWeight> weight)+          : weight_(std::move(weight)) {}++      void Start() override {}++      void Finish(FinishArgs args) override;++     private:+      RefCountedPtr<AddressWeight> weight_;+    };++    // Info stored about each subchannel.+    struct SubchannelInfo {+      SubchannelInfo(RefCountedPtr<SubchannelInterface> subchannel,+                     RefCountedPtr<AddressWeight> weight)+          : subchannel(std::move(subchannel)), weight(std::move(weight)) {}++      RefCountedPtr<SubchannelInterface> subchannel;+      RefCountedPtr<AddressWeight> weight;+    };++    // Returns the index into subchannels_ to be picked.+    size_t PickIndex();++    // Builds a new scheduler and swaps it into place, then starts a+    // timer for the next update.+    void BuildSchedulerAndStartTimerLocked()+        ABSL_EXCLUSIVE_LOCKS_REQUIRED(&mu_);++    RefCountedPtr<WeightedRoundRobin> wrr_;+    const bool use_per_rpc_utilization_;+    const Duration weight_update_period_;+    const Duration weight_expiration_period_;+    const Duration blackout_period_;+    std::vector<SubchannelInfo> subchannels_;++    Mutex mu_;+    uint32_t scheduler_state_ ABSL_GUARDED_BY(&mu_);","By persisent I meant for the lifetime of the WeightRoundRobinPolicy as in Stubby. I misread that the counter is per-scheduler in the previous comment but I think it does not change the point I wanted to make that keeping next_seq_ stable the whole time always benefits. This section also mentions this is an important feature: go/static-stride-scheduler#concurrency.For example, since we use a map to dedup addresses the order is stable as long as the subchannel set is the same, and keeping next_seq_ persisent across pickers clearly helps improving the stability. This includes resolver updates with the same server address or a flapping subchannel (not perfect). In all I don't see a reason not to do what Stubby does here.class WRR {    atomic<uint32_t> next_seq_ { rand() };   uint32_t NextSeq() { return next_seq_ .fetch_add(1); }   void UpdateWeights(..) {       StaticStrideScheduler::Make(.., [this](){ return NextSeq(); });   }}",
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/31958,1073922783,2023-01-18T18:29:12Z,src/core/lib/iomgr/endpoint_pair_windows.cc,"@@ -63,8 +63,8 @@ static void create_sockets(SOCKET sv[2]) {   GPR_ASSERT(svr_sock != INVALID_SOCKET);    closesocket(lst_sock);-  grpc_tcp_prepare_socket(cli_sock);-  grpc_tcp_prepare_socket(svr_sock);+  GPR_ASSERT(grpc_tcp_prepare_socket(cli_sock).ok());","This assert fails in our test environments. I'm guessing it's `set_dualstack` that's failing here, which ends up resulting in some loss of network optimization (TCP_NODELAY, mostly). That is not a show-stopper of an error, but should be logged at least.If, however, this failed to set the socket non-blocking, that would be a bigger issue. We could separate the prepare socket functionality into `prepare` and `optimize` methods, the former being critical, and the latter only providing warning-level errors.However, given that iomgr is slated for deletion this year, I'd be fine to do the lighter weight thing, log the error and continue on. If it is a critical problem, it'll likely show up again later.",
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/31661,1073935708,2023-01-18T18:40:17Z,src/core/lib/event_engine/posix_engine/posix_endpoint.cc,"@@ -1203,6 +1203,8 @@ PosixEndpointImpl::PosixEndpointImpl(EventHandle* handle,                                      const PosixTcpOptions& options)     : sock_(PosixSocketWrapper(handle->WrappedFd())),       on_done_(on_done),+      peer_address_(),","What was causing what kind of an MSAN failure? Again, IIUC these lines are redundant, the default constructors will be used for those members in class definition order.",
5663878,yijiem,https://api.github.com/repos/grpc/grpc/pulls/31958,1073937932,2023-01-18T18:42:23Z,src/core/lib/iomgr/endpoint_pair_windows.cc,"@@ -63,8 +63,8 @@ static void create_sockets(SOCKET sv[2]) {   GPR_ASSERT(svr_sock != INVALID_SOCKET);    closesocket(lst_sock);-  grpc_tcp_prepare_socket(cli_sock);-  grpc_tcp_prepare_socket(svr_sock);+  GPR_ASSERT(grpc_tcp_prepare_socket(cli_sock).ok());+  GPR_ASSERT(grpc_tcp_prepare_socket(svr_sock).ok());","From the test failure it looks like the original code does not expect these calls to succeed. `grpc_tcp_prepare_socket` does 3 things:  1. set socket to nonblocking  2. set an IPv6 socket to dualstack  3. enable TCP_NODELAY on the socketI think for 2, we need to create IPv6 sockets first and this option should be set before `bind()` for both the server's listening socket and the client socket. This function creates IPv4 sockets so this setting will fail and it's also setting it on a connected server socket (which may also fail).Given this, I suggest we log the error here in case we want to deal with it later with something like:```  grpc_error_handle error = grpc_tcp_prepare_socket(cli_sock);  if (!error.ok()) {    gpr_log(GPR_ERROR, ""Prepare cli_sock failed with error: %s"",            grpc_core::StatusToString(error).c_str());  }  error = grpc_tcp_prepare_socket(svr_sock);  if (!error.ok()) {    gpr_log(GPR_ERROR, ""Prepare svr_sock failed with error: %s"",            grpc_core::StatusToString(error).c_str());  }```CC @drfloob who may have some thoughts on this.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/31904,1073962971,2023-01-18T19:08:32Z,src/core/ext/filters/client_channel/lb_policy/weighted_round_robin/weighted_round_robin.cc,"@@ -0,0 +1,955 @@+//+// Copyright 2022 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+//++#include <grpc/support/port_platform.h>++#include <inttypes.h>+#include <stdlib.h>+#include <string.h>++#include <algorithm>+#include <functional>+#include <map>+#include <memory>+#include <set>+#include <string>+#include <type_traits>+#include <utility>+#include <vector>++#include ""absl/base/thread_annotations.h""+#include ""absl/random/random.h""+#include ""absl/status/status.h""+#include ""absl/status/statusor.h""+#include ""absl/strings/str_cat.h""+#include ""absl/strings/str_join.h""+#include ""absl/strings/string_view.h""+#include ""absl/types/optional.h""++#include <grpc/event_engine/event_engine.h>+#include <grpc/impl/connectivity_state.h>+#include <grpc/support/log.h>++#include ""src/core/ext/filters/client_channel/lb_policy/backend_metric_data.h""+#include ""src/core/ext/filters/client_channel/lb_policy/oob_backend_metric.h""+#include ""src/core/ext/filters/client_channel/lb_policy/subchannel_list.h""+#include ""src/core/ext/filters/client_channel/lb_policy/weighted_round_robin/static_stride_scheduler.h""+#include ""src/core/lib/address_utils/sockaddr_utils.h""+#include ""src/core/lib/channel/channel_args.h""+#include ""src/core/lib/config/core_configuration.h""+#include ""src/core/lib/debug/trace.h""+#include ""src/core/lib/gprpp/debug_location.h""+#include ""src/core/lib/gprpp/orphanable.h""+#include ""src/core/lib/gprpp/ref_counted.h""+#include ""src/core/lib/gprpp/ref_counted_ptr.h""+#include ""src/core/lib/gprpp/sync.h""+#include ""src/core/lib/gprpp/time.h""+#include ""src/core/lib/gprpp/validation_errors.h""+#include ""src/core/lib/iomgr/exec_ctx.h""+#include ""src/core/lib/iomgr/resolved_address.h""+#include ""src/core/lib/json/json.h""+#include ""src/core/lib/json/json_args.h""+#include ""src/core/lib/json/json_object_loader.h""+#include ""src/core/lib/load_balancing/lb_policy.h""+#include ""src/core/lib/load_balancing/lb_policy_factory.h""+#include ""src/core/lib/load_balancing/subchannel_interface.h""+#include ""src/core/lib/resolver/server_address.h""+#include ""src/core/lib/transport/connectivity_state.h""++namespace grpc_core {++TraceFlag grpc_lb_wrr_trace(false, ""weighted_round_robin_lb"");++namespace {++constexpr absl::string_view kWeightedRoundRobin =+    ""weighted_round_robin_experimental"";++// Config for WRR policy.+class WeightedRoundRobinConfig : public LoadBalancingPolicy::Config {+ public:+  WeightedRoundRobinConfig() = default;++  WeightedRoundRobinConfig(const WeightedRoundRobinConfig&) = delete;+  WeightedRoundRobinConfig& operator=(const WeightedRoundRobinConfig&) = delete;++  WeightedRoundRobinConfig(WeightedRoundRobinConfig&&) = delete;+  WeightedRoundRobinConfig& operator=(WeightedRoundRobinConfig&&) = delete;++  absl::string_view name() const override { return kWeightedRoundRobin; }++  bool enable_oob_load_report() const { return enable_oob_load_report_; }+  Duration oob_reporting_period() const { return oob_reporting_period_; }+  Duration blackout_period() const { return blackout_period_; }+  Duration weight_update_period() const { return weight_update_period_; }+  Duration weight_expiration_period() const {+    return weight_expiration_period_;+  }++  static const JsonLoaderInterface* JsonLoader(const JsonArgs&) {+    static const auto* loader =+        JsonObjectLoader<WeightedRoundRobinConfig>()+            .OptionalField(""enableOobLoadReport"",+                           &WeightedRoundRobinConfig::enable_oob_load_report_)+            .OptionalField(""oobReportingPeriod"",+                           &WeightedRoundRobinConfig::oob_reporting_period_)+            .OptionalField(""blackoutPeriod"",+                           &WeightedRoundRobinConfig::blackout_period_)+            .OptionalField(""weightUpdatePeriod"",+                           &WeightedRoundRobinConfig::weight_update_period_)+            .OptionalField(""weightExpirationPeriod"",+                           &WeightedRoundRobinConfig::weight_expiration_period_)+            .Finish();+    return loader;+  }++  void JsonPostLoad(const Json&, const JsonArgs&, ValidationErrors*) {+    // Impose lower bound of 100ms on weightUpdatePeriod.+    weight_update_period_ =+        std::max(weight_update_period_, Duration::Milliseconds(100));+  }++ private:+  bool enable_oob_load_report_ = false;+  Duration oob_reporting_period_ = Duration::Seconds(10);+  Duration blackout_period_ = Duration::Seconds(10);+  Duration weight_update_period_ = Duration::Seconds(1);+  Duration weight_expiration_period_ = Duration::Minutes(3);+};++// WRR LB policy.+class WeightedRoundRobin : public LoadBalancingPolicy {+ public:+  explicit WeightedRoundRobin(Args args);++  absl::string_view name() const override { return kWeightedRoundRobin; }++  absl::Status UpdateLocked(UpdateArgs args) override;+  void ResetBackoffLocked() override;++ private:+  // Represents the weight for a given address.+  class AddressWeight : public RefCounted<AddressWeight> {+   public:+    AddressWeight(RefCountedPtr<WeightedRoundRobin> wrr, std::string key)+        : wrr_(std::move(wrr)), key_(std::move(key)) {}+    ~AddressWeight() override;++    void MaybeUpdateWeight(double qps, double cpu_utilization);++    float GetWeight(Timestamp now, Duration weight_expiration_period,+                    Duration blackout_period);++    void ResetNonEmptySince();++   private:+    RefCountedPtr<WeightedRoundRobin> wrr_;+    const std::string key_;++    Mutex mu_;+    float weight_ ABSL_GUARDED_BY(&mu_) = 0;+    Timestamp non_empty_since_ ABSL_GUARDED_BY(&mu_) = Timestamp::InfFuture();+    Timestamp last_update_time_ ABSL_GUARDED_BY(&mu_) = Timestamp::InfPast();+  };++  // Forward declaration.+  class WeightedRoundRobinSubchannelList;++  // Data for a particular subchannel in a subchannel list.+  // This subclass adds the following functionality:+  // - Tracks the previous connectivity state of the subchannel, so that+  //   we know how many subchannels are in each state.+  class WeightedRoundRobinSubchannelData+      : public SubchannelData<WeightedRoundRobinSubchannelList,+                              WeightedRoundRobinSubchannelData> {+   public:+    WeightedRoundRobinSubchannelData(+        SubchannelList<WeightedRoundRobinSubchannelList,+                       WeightedRoundRobinSubchannelData>* subchannel_list,+        const ServerAddress& address, RefCountedPtr<SubchannelInterface> sc);++    absl::optional<grpc_connectivity_state> connectivity_state() const {+      return logical_connectivity_state_;+    }++    RefCountedPtr<AddressWeight> weight() const { return weight_; }++   private:+    class OobWatcher : public OobBackendMetricWatcher {+     public:+      explicit OobWatcher(RefCountedPtr<AddressWeight> weight)+          : weight_(std::move(weight)) {}++      void OnBackendMetricReport(+          const BackendMetricData& backend_metric_data) override;++     private:+      RefCountedPtr<AddressWeight> weight_;+    };++    // Performs connectivity state updates that need to be done only+    // after we have started watching.+    void ProcessConnectivityChangeLocked(+        absl::optional<grpc_connectivity_state> old_state,+        grpc_connectivity_state new_state) override;++    // Updates the logical connectivity state.+    void UpdateLogicalConnectivityStateLocked(+        grpc_connectivity_state connectivity_state);++    // The logical connectivity state of the subchannel.+    // Note that the logical connectivity state may differ from the+    // actual reported state in some cases (e.g., after we see+    // TRANSIENT_FAILURE, we ignore any subsequent state changes until+    // we see READY).+    absl::optional<grpc_connectivity_state> logical_connectivity_state_;++    RefCountedPtr<AddressWeight> weight_;+  };++  // A list of subchannels.+  class WeightedRoundRobinSubchannelList+      : public SubchannelList<WeightedRoundRobinSubchannelList,+                              WeightedRoundRobinSubchannelData> {+   public:+    WeightedRoundRobinSubchannelList(WeightedRoundRobin* policy,+                                     ServerAddressList addresses,+                                     const ChannelArgs& args)+        : SubchannelList(policy,+                         (GRPC_TRACE_FLAG_ENABLED(grpc_lb_wrr_trace)+                              ? ""WeightedRoundRobinSubchannelList""+                              : nullptr),+                         std::move(addresses), policy->channel_control_helper(),+                         args) {+      // Need to maintain a ref to the LB policy as long as we maintain+      // any references to subchannels, since the subchannels'+      // pollset_sets will include the LB policy's pollset_set.+      policy->Ref(DEBUG_LOCATION, ""subchannel_list"").release();+    }++    ~WeightedRoundRobinSubchannelList() override {+      WeightedRoundRobin* p = static_cast<WeightedRoundRobin*>(policy());+      p->Unref(DEBUG_LOCATION, ""subchannel_list"");+    }++    // Updates the counters of subchannels in each state when a+    // subchannel transitions from old_state to new_state.+    void UpdateStateCountersLocked(+        absl::optional<grpc_connectivity_state> old_state,+        grpc_connectivity_state new_state);++    // Ensures that the right subchannel list is used and then updates+    // the aggregated connectivity state based on the subchannel list's+    // state counters.+    void MaybeUpdateAggregatedConnectivityStateLocked(+        absl::Status status_for_tf);++   private:+    std::string CountersString() const {+      return absl::StrCat(""num_subchannels="", num_subchannels(),+                          "" num_ready="", num_ready_,+                          "" num_connecting="", num_connecting_,+                          "" num_transient_failure="", num_transient_failure_);+    }++    size_t num_ready_ = 0;+    size_t num_connecting_ = 0;+    size_t num_transient_failure_ = 0;++    absl::Status last_failure_;+  };++  // A picker that performs WRR picks with weights based on+  // endpoint-reported utilization and QPS.+  class Picker : public SubchannelPicker {+   public:+    Picker(RefCountedPtr<WeightedRoundRobin> wrr,+           WeightedRoundRobinSubchannelList* subchannel_list);++    ~Picker() override;++    PickResult Pick(PickArgs args) override;++    void Orphan() override;++   private:+    // A call tracker that collects per-call endpoint utilization reports.+    class SubchannelCallTracker : public SubchannelCallTrackerInterface {+     public:+      explicit SubchannelCallTracker(RefCountedPtr<AddressWeight> weight)+          : weight_(std::move(weight)) {}++      void Start() override {}++      void Finish(FinishArgs args) override;++     private:+      RefCountedPtr<AddressWeight> weight_;+    };++    // Info stored about each subchannel.+    struct SubchannelInfo {+      SubchannelInfo(RefCountedPtr<SubchannelInterface> subchannel,+                     RefCountedPtr<AddressWeight> weight)+          : subchannel(std::move(subchannel)), weight(std::move(weight)) {}++      RefCountedPtr<SubchannelInterface> subchannel;+      RefCountedPtr<AddressWeight> weight;+    };++    // Returns the index into subchannels_ to be picked.+    size_t PickIndex();++    // Builds a new scheduler and swaps it into place, then starts a+    // timer for the next update.+    void BuildSchedulerAndStartTimerLocked()+        ABSL_EXCLUSIVE_LOCKS_REQUIRED(&mu_);++    RefCountedPtr<WeightedRoundRobin> wrr_;+    const bool use_per_rpc_utilization_;+    const Duration weight_update_period_;+    const Duration weight_expiration_period_;+    const Duration blackout_period_;+    std::vector<SubchannelInfo> subchannels_;++    Mutex mu_;+    uint32_t scheduler_state_ ABSL_GUARDED_BY(&mu_);","I think we already discussed this extensively in the design.  Whenever we update the picker, the list of subchannels can change (e.g., because we got a new address list from the channel, or because a subchannel transitioned into or out of READY state), so the indexes of the subchannels change.  When the indexes change, there is no benefit to retaining the scheduler state, because it may no longer point to the same place in the rotation that it had previously pointed to.Note that this is exactly consistent with how RR works in gRPC: whenever we generate a new picker, we [start from a random index in the list](https://github.com/grpc/grpc/blob/7fd808f6f9d12e3e63dc299984567aae591cf2eb/src/core/ext/filters/client_channel/lb_policy/round_robin/round_robin.cc#L212).  I think it makes sense to do the same thing in WRR until and unless it proves to be a problem.  Let's not add complexity that we don't know if we're actually going to need.(To be fair, there are some cases today where we update the picker without the subchannel indexes actually changing.  This can happen whenever a subchannel changes from one non-READY state to another, such as going from IDLE to CONNECTING.  In these cases, we do wind up needlessly losing the scheduler state, and we could optimize that by avoiding a picker update in those cases.  But again, I don't think we should add the extra complexity here until and unless we know we're going to need it.)",
5564114,Vignesh2208,https://api.github.com/repos/grpc/grpc/pulls/31661,1080564905,2023-01-18T21:16:15Z,test/core/event_engine/posix/posix_event_engine_connect_test.cc,"@@ -161,7 +162,7 @@ TEST(PosixEventEngineTest, IndefiniteConnectTimeoutOrRstTest) {         EXPECT_EQ(status.status().code(), absl::StatusCode::kUnknown);         signal.Notify();       },-      URIToResolvedAddress(target_addr), config,+      *URIToResolvedAddress(target_addr), config,",Fixed it now. I also de-duplicated the usage of URIToResolvedAddress wherever possible.,X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/31985,1080576066,2023-01-18T21:29:57Z,src/core/ext/filters/client_channel/lb_policy/xds/xds_override_host.cc,"@@ -471,77 +490,72 @@ OrphanablePtr<LoadBalancingPolicy> XdsOverrideHostLb::CreateChildPolicyLocked( }  absl::StatusOr<ServerAddressList> XdsOverrideHostLb::UpdateAddressMap(-    absl::StatusOr<ServerAddressList> addresses,-    int override_host_status_mask) {-  // It will also retain subchannels until after update. Otherwise destroying-  // the subchannels will try to reacquire the locks in the ResetSubchannel...-  std::map<std::string, SubchannelEntry, std::less<>> new_map;-  absl::StatusOr<ServerAddressList> child_addresses;+    absl::StatusOr<ServerAddressList> addresses) {+  if (!addresses.ok()) {+    return addresses;+  }+  ServerAddressList return_value;+  std::map<const std::string, XdsHealthStatus> addresses_for_map;+  for (const auto& address : *addresses) {+    XdsHealthStatus status = GetAddressHealthStatus(address);+    auto key = grpc_sockaddr_to_string(&address.address(), false);+    if (key.ok()) {+      addresses_for_map.insert({std::move(*key), status});+    }+    if (status.status() != XdsHealthStatus::kDraining) {+      return_value.push_back(address);+    }+  }+  // Channels going from DRAINING to other state might only be retained+  // by the policy. This makes sure their removal is processed after the+  // mutex is released.+  std::vector<RefCountedPtr<SubchannelWrapper>> retained;","The way this code is written, it's very hard to read and understand, for several reasons:- I don't think we should need this `retained` vector, because we will call `Shutdown()` on every subchannel before we remove it, and once we've called `Shutdown()` on a subchannel, it should not try to acquire the lock when it is destroyed, so there shouldn't be any reason we need to delay destroying the subchannels until after the loop.- It's confusing that we're modifying `addresses_for_map` after we construct it.  I think once we construct it, we should treat it as read-only, because it reflects the new set of entries that we need to make sure are the set that exist in the map.  I think we should structure this code such that we're modifying `subchannel_map_` to match `addresses_for_map`, not the other way around.- It's confusing to be dealing with entries that we *do* want in two different places.  I think we should do this in two passes, one for addresses that we don't want (i.e., those that exist in `subchannel_map_` but not in `addresses_for_map`) and another for addresses that we do want (i.e., those that exist in `subchannels_for_map`, which may or may not already exist in `subchannel_map_`).It looks like your intention here may have been to optimize the set of elements that we're iterating over.  In general, that's a good idea, but in this particular case, this code is not in a performance-sensitive path anyway, so I think we should be optimizing for readability and maintainability instead of performance.Assuming that you take my suggestion above about adding a dtor for `SubchannelEntry`, then I think the code here can be:```// Now grab the lock and update the map.{  MutexLock lock(&subchannel_map_mu_);  // For each address in the map that is not in the new list, remove it.  for (auto it = subchannel_map_.begin(); it != subchannel_map_.end(); ) {    if (addresses_for_map.find(it->first) == addresses_for_map.end()) {      it = subchannel_map_.erase(it);    } else {      ++it;    }  }  // For each address in the new list, update the EDS health status in the corresponding  // map entry, adding the entry if needed.  for (const auto& p : addresses_for_map) {    const std::string& key = p.first;    const XdsHealthStatus& health_status = p.second;    auto it = subchannel_map_.find(key);    if (it == subchannel_map_.end()) {      it = subchannel_map_.emplace(key, SubchannelEntry()).first;    }    it->second.SetEdsHealthStatus(health_status);  }}```",X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/31985,1080578396,2023-01-18T21:33:08Z,src/core/ext/filters/client_channel/lb_policy/xds/xds_override_host.cc,"@@ -106,48 +121,63 @@ class XdsOverrideHostLb : public LoadBalancingPolicy {  private:   class SubchannelWrapper : public DelegatingSubchannel {    public:+    using Handle =","I think this type belongs in `SubchannelEntry`, not in `SubchannelWrapper`.  Nothing in `SubchannelWrapper` should know or care how `SubchannelEntry` is storing its pointer.",X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/31985,1080582095,2023-01-18T21:38:09Z,src/core/ext/filters/client_channel/lb_policy/xds/xds_override_host.cc,"@@ -106,48 +121,63 @@ class XdsOverrideHostLb : public LoadBalancingPolicy {  private:   class SubchannelWrapper : public DelegatingSubchannel {    public:+    using Handle =+        absl::variant<SubchannelWrapper*, RefCountedPtr<SubchannelWrapper>>;+     SubchannelWrapper(RefCountedPtr<SubchannelInterface> subchannel,                       RefCountedPtr<XdsOverrideHostLb> policy,-                      absl::optional<const std::string> key);+                      absl::string_view key, XdsHealthStatus health_status);      ~SubchannelWrapper() override; +    static SubchannelWrapper* FromHandle(const Handle& handle);+     void WatchConnectivityState(         std::unique_ptr<ConnectivityStateWatcherInterface> watcher) override;      void CancelConnectivityStateWatch(         ConnectivityStateWatcherInterface* watcher) override;      grpc_connectivity_state connectivity_state() {-      return watcher_->connectivity_state_.load();+      return connectivity_state_.load();     } -    XdsOverrideHostLb* policy() { return policy_.get(); }+    XdsHealthStatus health_status() { return health_status_; }++    Handle UpdateHealthStatus(XdsHealthStatus health_status); -    void Detach() { key_.reset(); }+    void Shutdown();++    RefCountedPtr<XdsOverrideHostLb> policy() { return policy_; }     private:     class ConnectivityStateWatcher : public ConnectivityStateWatcherInterface {      public:-      ConnectivityStateWatcher() {}+      explicit ConnectivityStateWatcher(+          RefCountedPtr<SubchannelWrapper> subchannel)+          : subchannel_(subchannel) {}        void OnConnectivityStateChange(grpc_connectivity_state state,                                      absl::Status status) override;        grpc_pollset_set* interested_parties() override;       private:-      friend class SubchannelWrapper;--      grpc_pollset_set* interested_parties_ = nullptr;-      std::vector<std::unique_ptr<ConnectivityStateWatcherInterface>> watchers_;-      std::atomic<grpc_connectivity_state> connectivity_state_{-          GRPC_CHANNEL_IDLE};+      RefCountedPtr<SubchannelWrapper> subchannel_;     }; -    ConnectivityStateWatcher* watcher_ = nullptr;-    absl::optional<const std::string> key_;+    void UpdateConnectivityState(grpc_connectivity_state state,+                                 absl::Status status);++    ConnectivityStateWatcher* watcher_;+    absl::optional<std::string> key_;     RefCountedPtr<XdsOverrideHostLb> policy_;+    std::set<std::unique_ptr<ConnectivityStateWatcherInterface>,+             PtrLessThan<ConnectivityStateWatcherInterface>>+        watchers_;+    std::atomic<grpc_connectivity_state> connectivity_state_ = {+        GRPC_CHANNEL_IDLE};+    XdsHealthStatus health_status_;","I think this should live in `SubchannelEntry`, not in `SubchannelWrapper`.  It's not the health status of the individual subchannel, it's the health status of the address that we got in the address list from the channel.  The address list from the channel is what determines the set of entries in `subchannel_map_`, so this data belongs there as well.Note that there may be multiple `SubchannelWrapper`s in existance for the same address at any given time, because when the child policy gets an updated address list, it will create a new `SubchannelWrapper` for each address in the new list and then later destroy the `SubchannelWrapper`s from the old address list.  So storing this just once in `SubchannelEntry` will also save a small amount of memory.",X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/31985,1080600379,2023-01-18T21:59:20Z,src/core/ext/filters/client_channel/lb_policy/xds/xds_override_host.cc,"@@ -471,77 +490,72 @@ OrphanablePtr<LoadBalancingPolicy> XdsOverrideHostLb::CreateChildPolicyLocked( }  absl::StatusOr<ServerAddressList> XdsOverrideHostLb::UpdateAddressMap(-    absl::StatusOr<ServerAddressList> addresses,-    int override_host_status_mask) {-  // It will also retain subchannels until after update. Otherwise destroying-  // the subchannels will try to reacquire the locks in the ResetSubchannel...-  std::map<std::string, SubchannelEntry, std::less<>> new_map;-  absl::StatusOr<ServerAddressList> child_addresses;+    absl::StatusOr<ServerAddressList> addresses) {+  if (!addresses.ok()) {+    return addresses;+  }+  ServerAddressList return_value;+  std::map<const std::string, XdsHealthStatus> addresses_for_map;+  for (const auto& address : *addresses) {+    XdsHealthStatus status = GetAddressHealthStatus(address);+    auto key = grpc_sockaddr_to_string(&address.address(), false);+    if (key.ok()) {+      addresses_for_map.insert({std::move(*key), status});+    }+    if (status.status() != XdsHealthStatus::kDraining) {+      return_value.push_back(address);+    }+  }+  // Channels going from DRAINING to other state might only be retained+  // by the policy. This makes sure their removal is processed after the+  // mutex is released.+  std::vector<RefCountedPtr<SubchannelWrapper>> retained;   {     MutexLock lock(&subchannel_map_mu_);-    if (addresses.ok()) {-      child_addresses.emplace();-      for (const auto& address : *addresses) {-        auto status = GetAddressHealthStatus(address);-        bool draining = false;-        if (status.status() != XdsHealthStatus::HealthStatus::kDraining) {-          child_addresses->push_back(address);-        } else if ((override_host_status_mask & HealthStatusBitMask(status)) ==-                   0) {-          continue;-        } else {-          draining = true;+    for (auto it = subchannel_map_.begin(); it != subchannel_map_.end();) {+      auto key_status = addresses_for_map.find(it->first);+      SubchannelWrapper* subchannel = it->second.GetSubchannel();+      if (key_status == addresses_for_map.end()) {+        if (subchannel != nullptr) {+          subchannel->Shutdown();         }-        auto key = grpc_sockaddr_to_string(&address.address(), false);-        if (key.ok()) {-          auto it = subchannel_map_.find(*key);-          if (it == subchannel_map_.end()) {-            new_map.emplace(std::make_pair(*key, SubchannelEntry(nullptr)));-          } else {-            SubchannelWrapper* subchannel = it->second.GetSubchannel();-            if (subchannel != nullptr && draining) {-              new_map.emplace(-                  std::make_pair(*key, SubchannelEntry(subchannel->Ref())));-            } else {-              new_map.emplace(-                  std::make_pair(*key, SubchannelEntry(subchannel)));-            }-          }+        it = subchannel_map_.erase(it);+      } else {+        if (subchannel != nullptr) {+          it->second.SetSubchannel(+              subchannel->UpdateHealthStatus(key_status->second));+          retained.push_back(subchannel->Ref());+        } else {+          it->second.SetSubchannel(nullptr);         }+        addresses_for_map.erase(key_status);+        it++;       }-    } else {-      child_addresses = std::move(addresses);     }-    std::swap(new_map, subchannel_map_);+    for (const auto& key_status : addresses_for_map) {+      subchannel_map_.emplace(key_status.first, SubchannelEntry(nullptr));+    }   }-  return child_addresses;+  return return_value; }  RefCountedPtr<XdsOverrideHostLb::SubchannelWrapper> XdsOverrideHostLb::AdoptSubchannel(     ServerAddress address, RefCountedPtr<SubchannelInterface> subchannel) {-  auto subchannel_key = grpc_sockaddr_to_string(&address.address(), false);-  absl::optional<std::string> key;-  if (subchannel_key.ok()) {-    key = std::move(*subchannel_key);-  }-  auto wrapper =-      MakeRefCounted<SubchannelWrapper>(std::move(subchannel), Ref(), key);-  if (key.has_value()) {+  auto key = grpc_sockaddr_to_string(&address.address(), false);+  if (key.ok()) {+    auto status = GetAddressHealthStatus(address);+    auto wrapper = MakeRefCounted<SubchannelWrapper>(std::move(subchannel),+                                                     Ref(), *key, status);     MutexLock lock(&subchannel_map_mu_);     auto it = subchannel_map_.find(*key);     if (it != subchannel_map_.end()) {-      auto status = GetAddressHealthStatus(address);-      if (status.status() == XdsHealthStatus::HealthStatus::kDraining &&-          (config_->override_host_status_mask() &-           HealthStatusBitMask(status))) {-        it->second.SetSubchannel(wrapper);-      } else {-        it->second.SetSubchannel(wrapper.get());-      }+      it->second.SetSubchannel(wrapper->UpdateHealthStatus(status));     }+    return wrapper;+  } else {+    return subchannel;","Suggest handling the error case before the success case here, so that (a) the error handling is right next to the condition that catches it, and (b) the success case does not need to be indented an extra level.In other words:```auto key = grpc_sockaddr_to_string(&address.address(), false);if (!key.ok()) return subchannel;// ...now handle success case...```",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/31985,1080604693,2023-01-18T22:03:03Z,src/core/ext/filters/client_channel/lb_policy/xds/xds_override_host.cc,"@@ -559,7 +573,11 @@ XdsOverrideHostLb::GetSubchannelByAddress(absl::string_view address) {   auto it = subchannel_map_.find(address);   if (it != subchannel_map_.end()) {     auto subchannel = it->second.GetSubchannel();-    return subchannel == nullptr ? nullptr : subchannel->Ref();+    if (subchannel == nullptr || !config_->override_host_status_set().Contains(","It's not safe to directly access `config_` here, because this method (`GetSubchannelByAddress()`) will be called from the picker, which does not run in the `WorkSerializer`, but `config_` will be updated in the `WorkSerializer`.  So you can have one thread doing a pick at the same time that another thread is running `UpdateLocked()` in the `WorkSerializer` and setting `config_`.Instead, I think you will need to have the picker store its own copy of `config_->override_host_status_set()` when it is constructed, and you can pass that value from the picker in to `GetSubchannelByAddress()` as a parameter.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/31985,1080611028,2023-01-18T22:08:39Z,src/core/ext/filters/client_channel/lb_policy/xds/xds_override_host.cc,"@@ -615,57 +633,96 @@ void XdsOverrideHostLb::Helper::AddTraceEvent(TraceSeverity severity,  XdsOverrideHostLb::SubchannelWrapper::SubchannelWrapper(     RefCountedPtr<SubchannelInterface> subchannel,-    RefCountedPtr<XdsOverrideHostLb> policy,-    absl::optional<const std::string> key)+    RefCountedPtr<XdsOverrideHostLb> policy, absl::string_view key,+    XdsHealthStatus health_status)     : DelegatingSubchannel(std::move(subchannel)),-      key_(std::move(key)),-      policy_(std::move(policy)) {-  auto watcher = std::make_unique<ConnectivityStateWatcher>();+      key_(key),+      policy_(policy),+      health_status_(health_status) {+  auto watcher = std::make_unique<ConnectivityStateWatcher>(Ref());   watcher_ = watcher.get();   wrapped_subchannel()->WatchConnectivityState(std::move(watcher)); }  XdsOverrideHostLb::SubchannelWrapper::~SubchannelWrapper() {-  wrapped_subchannel()->CancelConnectivityStateWatch(watcher_);   if (key_.has_value()) {     policy_->ResetSubchannel(*key_, this);   } }  void XdsOverrideHostLb::SubchannelWrapper::WatchConnectivityState(     std::unique_ptr<ConnectivityStateWatcherInterface> watcher) {-  watcher_->watchers_.push_back(std::move(watcher));+  watchers_.insert(std::move(watcher)); }  void XdsOverrideHostLb::SubchannelWrapper::CancelConnectivityStateWatch(     ConnectivityStateWatcherInterface* watcher) {-  (void)std::remove_if(watcher_->watchers_.begin(), watcher_->watchers_.end(),-                       [watcher](const auto& watcher_ptr) {-                         return watcher_ptr.get() == watcher;-                       });+  auto it = watchers_.find(watcher);+  if (it != watchers_.end()) {+    watchers_.erase(it);+  }+}++void XdsOverrideHostLb::SubchannelWrapper::UpdateConnectivityState(+    grpc_connectivity_state state, absl::Status status) {+  connectivity_state_.store(state);+  // Assumption is that watchers may come and go as the events are processed","This assumption is incorrect.  Watchers are generally started when the subchannel is created, and in the vast majority of cases, they don't go away until the subchannel is destroyed.  (The only real exception to that is pick_first, and I will probably change it to do the same thing at some point in the future.)In any case, even if watchers did come and go more dynamically, starting or stopping a watcher would need to be done inside of the `WorkSerializer`, but this function is already running in the `WorlSerializer`, so the set of watchers cannot change while this function is running anyway.  So I think all we need here is:```for (const auto& watcher : watchers_) {  watcher->OnConnectivityStateChange(state, status);}```",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/31985,1080626468,2023-01-18T22:27:36Z,test/core/client_channel/lb_policy/xds_override_host_test.cc,"@@ -64,11 +64,13 @@ class XdsOverrideHostTest : public LoadBalancingPolicyTest {   }    RefCountedPtr<LoadBalancingPolicy::SubchannelPicker>-  ExpectStartupWithRoundRobin(absl::Span<const absl::string_view> addresses) {+  ExpectStartupWithRoundRobin(absl::Span<const absl::string_view> addresses,+                              RefCountedPtr<LoadBalancingPolicy::Config>+                                  config = MakeXdsOverrideHostConfig()) {     RefCountedPtr<LoadBalancingPolicy::SubchannelPicker> picker;-    EXPECT_EQ(ApplyUpdate(BuildUpdate(addresses, MakeXdsOverrideHostConfig()),-                          policy_.get()),-              absl::OkStatus());+    EXPECT_EQ(+        ApplyUpdate(BuildUpdate(addresses, std::move(config)), policy_.get()),","I don't think this `std::move()` is safe, because the parameter value will be initialized only one process-wide, not once per call.  That means the second call to this function will be left with nullptr here.I think a better approach here would be to use a config builder pattern, just like we do in the outlier detection test:https://github.com/grpc/grpc/blob/ee1d98083230f52071e9f170987be25deafe6c1b/test/core/client_channel/lb_policy/outlier_detection_test.cc#L45Then you can pass the config builder as a const reference, and you won't have to worry about moving it.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/31904,1080688398,2023-01-19T00:04:28Z,src/core/ext/filters/client_channel/lb_policy/weighted_round_robin/weighted_round_robin.cc,"@@ -0,0 +1,955 @@+//+// Copyright 2022 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+//++#include <grpc/support/port_platform.h>++#include <inttypes.h>+#include <stdlib.h>+#include <string.h>++#include <algorithm>+#include <functional>+#include <map>+#include <memory>+#include <set>+#include <string>+#include <type_traits>+#include <utility>+#include <vector>++#include ""absl/base/thread_annotations.h""+#include ""absl/random/random.h""+#include ""absl/status/status.h""+#include ""absl/status/statusor.h""+#include ""absl/strings/str_cat.h""+#include ""absl/strings/str_join.h""+#include ""absl/strings/string_view.h""+#include ""absl/types/optional.h""++#include <grpc/event_engine/event_engine.h>+#include <grpc/impl/connectivity_state.h>+#include <grpc/support/log.h>++#include ""src/core/ext/filters/client_channel/lb_policy/backend_metric_data.h""+#include ""src/core/ext/filters/client_channel/lb_policy/oob_backend_metric.h""+#include ""src/core/ext/filters/client_channel/lb_policy/subchannel_list.h""+#include ""src/core/ext/filters/client_channel/lb_policy/weighted_round_robin/static_stride_scheduler.h""+#include ""src/core/lib/address_utils/sockaddr_utils.h""+#include ""src/core/lib/channel/channel_args.h""+#include ""src/core/lib/config/core_configuration.h""+#include ""src/core/lib/debug/trace.h""+#include ""src/core/lib/gprpp/debug_location.h""+#include ""src/core/lib/gprpp/orphanable.h""+#include ""src/core/lib/gprpp/ref_counted.h""+#include ""src/core/lib/gprpp/ref_counted_ptr.h""+#include ""src/core/lib/gprpp/sync.h""+#include ""src/core/lib/gprpp/time.h""+#include ""src/core/lib/gprpp/validation_errors.h""+#include ""src/core/lib/iomgr/exec_ctx.h""+#include ""src/core/lib/iomgr/resolved_address.h""+#include ""src/core/lib/json/json.h""+#include ""src/core/lib/json/json_args.h""+#include ""src/core/lib/json/json_object_loader.h""+#include ""src/core/lib/load_balancing/lb_policy.h""+#include ""src/core/lib/load_balancing/lb_policy_factory.h""+#include ""src/core/lib/load_balancing/subchannel_interface.h""+#include ""src/core/lib/resolver/server_address.h""+#include ""src/core/lib/transport/connectivity_state.h""++namespace grpc_core {++TraceFlag grpc_lb_wrr_trace(false, ""weighted_round_robin_lb"");++namespace {++constexpr absl::string_view kWeightedRoundRobin =+    ""weighted_round_robin_experimental"";++// Config for WRR policy.+class WeightedRoundRobinConfig : public LoadBalancingPolicy::Config {+ public:+  WeightedRoundRobinConfig() = default;++  WeightedRoundRobinConfig(const WeightedRoundRobinConfig&) = delete;+  WeightedRoundRobinConfig& operator=(const WeightedRoundRobinConfig&) = delete;++  WeightedRoundRobinConfig(WeightedRoundRobinConfig&&) = delete;+  WeightedRoundRobinConfig& operator=(WeightedRoundRobinConfig&&) = delete;++  absl::string_view name() const override { return kWeightedRoundRobin; }++  bool enable_oob_load_report() const { return enable_oob_load_report_; }+  Duration oob_reporting_period() const { return oob_reporting_period_; }+  Duration blackout_period() const { return blackout_period_; }+  Duration weight_update_period() const { return weight_update_period_; }+  Duration weight_expiration_period() const {+    return weight_expiration_period_;+  }++  static const JsonLoaderInterface* JsonLoader(const JsonArgs&) {+    static const auto* loader =+        JsonObjectLoader<WeightedRoundRobinConfig>()+            .OptionalField(""enableOobLoadReport"",+                           &WeightedRoundRobinConfig::enable_oob_load_report_)+            .OptionalField(""oobReportingPeriod"",+                           &WeightedRoundRobinConfig::oob_reporting_period_)+            .OptionalField(""blackoutPeriod"",+                           &WeightedRoundRobinConfig::blackout_period_)+            .OptionalField(""weightUpdatePeriod"",+                           &WeightedRoundRobinConfig::weight_update_period_)+            .OptionalField(""weightExpirationPeriod"",+                           &WeightedRoundRobinConfig::weight_expiration_period_)+            .Finish();+    return loader;+  }++  void JsonPostLoad(const Json&, const JsonArgs&, ValidationErrors*) {+    // Impose lower bound of 100ms on weightUpdatePeriod.+    weight_update_period_ =+        std::max(weight_update_period_, Duration::Milliseconds(100));+  }++ private:+  bool enable_oob_load_report_ = false;+  Duration oob_reporting_period_ = Duration::Seconds(10);+  Duration blackout_period_ = Duration::Seconds(10);+  Duration weight_update_period_ = Duration::Seconds(1);+  Duration weight_expiration_period_ = Duration::Minutes(3);+};++// WRR LB policy.+class WeightedRoundRobin : public LoadBalancingPolicy {+ public:+  explicit WeightedRoundRobin(Args args);++  absl::string_view name() const override { return kWeightedRoundRobin; }++  absl::Status UpdateLocked(UpdateArgs args) override;+  void ResetBackoffLocked() override;++ private:+  // Represents the weight for a given address.+  class AddressWeight : public RefCounted<AddressWeight> {+   public:+    AddressWeight(RefCountedPtr<WeightedRoundRobin> wrr, std::string key)+        : wrr_(std::move(wrr)), key_(std::move(key)) {}+    ~AddressWeight() override;++    void MaybeUpdateWeight(double qps, double cpu_utilization);++    float GetWeight(Timestamp now, Duration weight_expiration_period,+                    Duration blackout_period);++    void ResetNonEmptySince();++   private:+    RefCountedPtr<WeightedRoundRobin> wrr_;+    const std::string key_;++    Mutex mu_;+    float weight_ ABSL_GUARDED_BY(&mu_) = 0;+    Timestamp non_empty_since_ ABSL_GUARDED_BY(&mu_) = Timestamp::InfFuture();+    Timestamp last_update_time_ ABSL_GUARDED_BY(&mu_) = Timestamp::InfPast();+  };++  // Forward declaration.+  class WeightedRoundRobinSubchannelList;++  // Data for a particular subchannel in a subchannel list.+  // This subclass adds the following functionality:+  // - Tracks the previous connectivity state of the subchannel, so that+  //   we know how many subchannels are in each state.+  class WeightedRoundRobinSubchannelData+      : public SubchannelData<WeightedRoundRobinSubchannelList,+                              WeightedRoundRobinSubchannelData> {+   public:+    WeightedRoundRobinSubchannelData(+        SubchannelList<WeightedRoundRobinSubchannelList,+                       WeightedRoundRobinSubchannelData>* subchannel_list,+        const ServerAddress& address, RefCountedPtr<SubchannelInterface> sc);++    absl::optional<grpc_connectivity_state> connectivity_state() const {+      return logical_connectivity_state_;+    }++    RefCountedPtr<AddressWeight> weight() const { return weight_; }++   private:+    class OobWatcher : public OobBackendMetricWatcher {+     public:+      explicit OobWatcher(RefCountedPtr<AddressWeight> weight)+          : weight_(std::move(weight)) {}++      void OnBackendMetricReport(+          const BackendMetricData& backend_metric_data) override;++     private:+      RefCountedPtr<AddressWeight> weight_;+    };++    // Performs connectivity state updates that need to be done only+    // after we have started watching.+    void ProcessConnectivityChangeLocked(+        absl::optional<grpc_connectivity_state> old_state,+        grpc_connectivity_state new_state) override;++    // Updates the logical connectivity state.+    void UpdateLogicalConnectivityStateLocked(+        grpc_connectivity_state connectivity_state);++    // The logical connectivity state of the subchannel.+    // Note that the logical connectivity state may differ from the+    // actual reported state in some cases (e.g., after we see+    // TRANSIENT_FAILURE, we ignore any subsequent state changes until+    // we see READY).+    absl::optional<grpc_connectivity_state> logical_connectivity_state_;++    RefCountedPtr<AddressWeight> weight_;+  };++  // A list of subchannels.+  class WeightedRoundRobinSubchannelList+      : public SubchannelList<WeightedRoundRobinSubchannelList,+                              WeightedRoundRobinSubchannelData> {+   public:+    WeightedRoundRobinSubchannelList(WeightedRoundRobin* policy,+                                     ServerAddressList addresses,+                                     const ChannelArgs& args)+        : SubchannelList(policy,+                         (GRPC_TRACE_FLAG_ENABLED(grpc_lb_wrr_trace)+                              ? ""WeightedRoundRobinSubchannelList""+                              : nullptr),+                         std::move(addresses), policy->channel_control_helper(),+                         args) {+      // Need to maintain a ref to the LB policy as long as we maintain+      // any references to subchannels, since the subchannels'+      // pollset_sets will include the LB policy's pollset_set.+      policy->Ref(DEBUG_LOCATION, ""subchannel_list"").release();+    }++    ~WeightedRoundRobinSubchannelList() override {+      WeightedRoundRobin* p = static_cast<WeightedRoundRobin*>(policy());+      p->Unref(DEBUG_LOCATION, ""subchannel_list"");+    }++    // Updates the counters of subchannels in each state when a+    // subchannel transitions from old_state to new_state.+    void UpdateStateCountersLocked(+        absl::optional<grpc_connectivity_state> old_state,+        grpc_connectivity_state new_state);++    // Ensures that the right subchannel list is used and then updates+    // the aggregated connectivity state based on the subchannel list's+    // state counters.+    void MaybeUpdateAggregatedConnectivityStateLocked(+        absl::Status status_for_tf);++   private:+    std::string CountersString() const {+      return absl::StrCat(""num_subchannels="", num_subchannels(),+                          "" num_ready="", num_ready_,+                          "" num_connecting="", num_connecting_,+                          "" num_transient_failure="", num_transient_failure_);+    }++    size_t num_ready_ = 0;+    size_t num_connecting_ = 0;+    size_t num_transient_failure_ = 0;++    absl::Status last_failure_;+  };++  // A picker that performs WRR picks with weights based on+  // endpoint-reported utilization and QPS.+  class Picker : public SubchannelPicker {+   public:+    Picker(RefCountedPtr<WeightedRoundRobin> wrr,+           WeightedRoundRobinSubchannelList* subchannel_list);++    ~Picker() override;++    PickResult Pick(PickArgs args) override;++    void Orphan() override;++   private:+    // A call tracker that collects per-call endpoint utilization reports.+    class SubchannelCallTracker : public SubchannelCallTrackerInterface {+     public:+      explicit SubchannelCallTracker(RefCountedPtr<AddressWeight> weight)+          : weight_(std::move(weight)) {}++      void Start() override {}++      void Finish(FinishArgs args) override;++     private:+      RefCountedPtr<AddressWeight> weight_;+    };++    // Info stored about each subchannel.+    struct SubchannelInfo {+      SubchannelInfo(RefCountedPtr<SubchannelInterface> subchannel,+                     RefCountedPtr<AddressWeight> weight)+          : subchannel(std::move(subchannel)), weight(std::move(weight)) {}++      RefCountedPtr<SubchannelInterface> subchannel;+      RefCountedPtr<AddressWeight> weight;+    };++    // Returns the index into subchannels_ to be picked.+    size_t PickIndex();++    // Builds a new scheduler and swaps it into place, then starts a+    // timer for the next update.+    void BuildSchedulerAndStartTimerLocked()+        ABSL_EXCLUSIVE_LOCKS_REQUIRED(&mu_);++    RefCountedPtr<WeightedRoundRobin> wrr_;+    const bool use_per_rpc_utilization_;+    const Duration weight_update_period_;+    const Duration weight_expiration_period_;+    const Duration blackout_period_;+    std::vector<SubchannelInfo> subchannels_;++    Mutex mu_;+    uint32_t scheduler_state_ ABSL_GUARDED_BY(&mu_);","As per our conversation, I've changed this to store the scheduler state in the LB policy itself so that it can be retained across pickers.I'm still not sure this will actually yield the same benefit for gRPC that it does for Stubby, because gRPC will not order the addresses the same way that Stubby does, especially when backend tasks move around.  But it doesn't add too much complexity, and it does pave the way for #31973.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/31904,1080688802,2023-01-19T00:05:28Z,src/core/ext/filters/client_channel/lb_policy/weighted_round_robin/weighted_round_robin.cc,"@@ -0,0 +1,955 @@+//+// Copyright 2022 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+//++#include <grpc/support/port_platform.h>++#include <inttypes.h>+#include <stdlib.h>+#include <string.h>++#include <algorithm>+#include <functional>+#include <map>+#include <memory>+#include <set>+#include <string>+#include <type_traits>+#include <utility>+#include <vector>++#include ""absl/base/thread_annotations.h""+#include ""absl/random/random.h""+#include ""absl/status/status.h""+#include ""absl/status/statusor.h""+#include ""absl/strings/str_cat.h""+#include ""absl/strings/str_join.h""+#include ""absl/strings/string_view.h""+#include ""absl/types/optional.h""++#include <grpc/event_engine/event_engine.h>+#include <grpc/impl/connectivity_state.h>+#include <grpc/support/log.h>++#include ""src/core/ext/filters/client_channel/lb_policy/backend_metric_data.h""+#include ""src/core/ext/filters/client_channel/lb_policy/oob_backend_metric.h""+#include ""src/core/ext/filters/client_channel/lb_policy/subchannel_list.h""+#include ""src/core/ext/filters/client_channel/lb_policy/weighted_round_robin/static_stride_scheduler.h""+#include ""src/core/lib/address_utils/sockaddr_utils.h""+#include ""src/core/lib/channel/channel_args.h""+#include ""src/core/lib/config/core_configuration.h""+#include ""src/core/lib/debug/trace.h""+#include ""src/core/lib/gprpp/debug_location.h""+#include ""src/core/lib/gprpp/orphanable.h""+#include ""src/core/lib/gprpp/ref_counted.h""+#include ""src/core/lib/gprpp/ref_counted_ptr.h""+#include ""src/core/lib/gprpp/sync.h""+#include ""src/core/lib/gprpp/time.h""+#include ""src/core/lib/gprpp/validation_errors.h""+#include ""src/core/lib/iomgr/exec_ctx.h""+#include ""src/core/lib/iomgr/resolved_address.h""+#include ""src/core/lib/json/json.h""+#include ""src/core/lib/json/json_args.h""+#include ""src/core/lib/json/json_object_loader.h""+#include ""src/core/lib/load_balancing/lb_policy.h""+#include ""src/core/lib/load_balancing/lb_policy_factory.h""+#include ""src/core/lib/load_balancing/subchannel_interface.h""+#include ""src/core/lib/resolver/server_address.h""+#include ""src/core/lib/transport/connectivity_state.h""++namespace grpc_core {++TraceFlag grpc_lb_wrr_trace(false, ""weighted_round_robin_lb"");++namespace {++constexpr absl::string_view kWeightedRoundRobin =+    ""weighted_round_robin_experimental"";++// Config for WRR policy.+class WeightedRoundRobinConfig : public LoadBalancingPolicy::Config {+ public:+  WeightedRoundRobinConfig() = default;++  WeightedRoundRobinConfig(const WeightedRoundRobinConfig&) = delete;+  WeightedRoundRobinConfig& operator=(const WeightedRoundRobinConfig&) = delete;++  WeightedRoundRobinConfig(WeightedRoundRobinConfig&&) = delete;+  WeightedRoundRobinConfig& operator=(WeightedRoundRobinConfig&&) = delete;++  absl::string_view name() const override { return kWeightedRoundRobin; }++  bool enable_oob_load_report() const { return enable_oob_load_report_; }+  Duration oob_reporting_period() const { return oob_reporting_period_; }+  Duration blackout_period() const { return blackout_period_; }+  Duration weight_update_period() const { return weight_update_period_; }+  Duration weight_expiration_period() const {+    return weight_expiration_period_;+  }++  static const JsonLoaderInterface* JsonLoader(const JsonArgs&) {+    static const auto* loader =+        JsonObjectLoader<WeightedRoundRobinConfig>()+            .OptionalField(""enableOobLoadReport"",+                           &WeightedRoundRobinConfig::enable_oob_load_report_)+            .OptionalField(""oobReportingPeriod"",+                           &WeightedRoundRobinConfig::oob_reporting_period_)+            .OptionalField(""blackoutPeriod"",+                           &WeightedRoundRobinConfig::blackout_period_)+            .OptionalField(""weightUpdatePeriod"",+                           &WeightedRoundRobinConfig::weight_update_period_)+            .OptionalField(""weightExpirationPeriod"",+                           &WeightedRoundRobinConfig::weight_expiration_period_)+            .Finish();+    return loader;+  }++  void JsonPostLoad(const Json&, const JsonArgs&, ValidationErrors*) {+    // Impose lower bound of 100ms on weightUpdatePeriod.+    weight_update_period_ =+        std::max(weight_update_period_, Duration::Milliseconds(100));+  }++ private:+  bool enable_oob_load_report_ = false;+  Duration oob_reporting_period_ = Duration::Seconds(10);+  Duration blackout_period_ = Duration::Seconds(10);+  Duration weight_update_period_ = Duration::Seconds(1);+  Duration weight_expiration_period_ = Duration::Minutes(3);+};++// WRR LB policy.+class WeightedRoundRobin : public LoadBalancingPolicy {+ public:+  explicit WeightedRoundRobin(Args args);++  absl::string_view name() const override { return kWeightedRoundRobin; }++  absl::Status UpdateLocked(UpdateArgs args) override;+  void ResetBackoffLocked() override;++ private:+  // Represents the weight for a given address.+  class AddressWeight : public RefCounted<AddressWeight> {+   public:+    AddressWeight(RefCountedPtr<WeightedRoundRobin> wrr, std::string key)+        : wrr_(std::move(wrr)), key_(std::move(key)) {}+    ~AddressWeight() override;++    void MaybeUpdateWeight(double qps, double cpu_utilization);++    float GetWeight(Timestamp now, Duration weight_expiration_period,+                    Duration blackout_period);++    void ResetNonEmptySince();++   private:+    RefCountedPtr<WeightedRoundRobin> wrr_;+    const std::string key_;++    Mutex mu_;+    float weight_ ABSL_GUARDED_BY(&mu_) = 0;+    Timestamp non_empty_since_ ABSL_GUARDED_BY(&mu_) = Timestamp::InfFuture();+    Timestamp last_update_time_ ABSL_GUARDED_BY(&mu_) = Timestamp::InfPast();+  };++  // Forward declaration.+  class WeightedRoundRobinSubchannelList;++  // Data for a particular subchannel in a subchannel list.+  // This subclass adds the following functionality:+  // - Tracks the previous connectivity state of the subchannel, so that+  //   we know how many subchannels are in each state.+  class WeightedRoundRobinSubchannelData+      : public SubchannelData<WeightedRoundRobinSubchannelList,+                              WeightedRoundRobinSubchannelData> {+   public:+    WeightedRoundRobinSubchannelData(+        SubchannelList<WeightedRoundRobinSubchannelList,+                       WeightedRoundRobinSubchannelData>* subchannel_list,+        const ServerAddress& address, RefCountedPtr<SubchannelInterface> sc);++    absl::optional<grpc_connectivity_state> connectivity_state() const {+      return logical_connectivity_state_;+    }++    RefCountedPtr<AddressWeight> weight() const { return weight_; }++   private:+    class OobWatcher : public OobBackendMetricWatcher {+     public:+      explicit OobWatcher(RefCountedPtr<AddressWeight> weight)+          : weight_(std::move(weight)) {}++      void OnBackendMetricReport(+          const BackendMetricData& backend_metric_data) override;++     private:+      RefCountedPtr<AddressWeight> weight_;+    };++    // Performs connectivity state updates that need to be done only+    // after we have started watching.+    void ProcessConnectivityChangeLocked(+        absl::optional<grpc_connectivity_state> old_state,+        grpc_connectivity_state new_state) override;++    // Updates the logical connectivity state.+    void UpdateLogicalConnectivityStateLocked(+        grpc_connectivity_state connectivity_state);++    // The logical connectivity state of the subchannel.+    // Note that the logical connectivity state may differ from the+    // actual reported state in some cases (e.g., after we see+    // TRANSIENT_FAILURE, we ignore any subsequent state changes until+    // we see READY).+    absl::optional<grpc_connectivity_state> logical_connectivity_state_;++    RefCountedPtr<AddressWeight> weight_;+  };++  // A list of subchannels.+  class WeightedRoundRobinSubchannelList+      : public SubchannelList<WeightedRoundRobinSubchannelList,+                              WeightedRoundRobinSubchannelData> {+   public:+    WeightedRoundRobinSubchannelList(WeightedRoundRobin* policy,+                                     ServerAddressList addresses,+                                     const ChannelArgs& args)+        : SubchannelList(policy,+                         (GRPC_TRACE_FLAG_ENABLED(grpc_lb_wrr_trace)+                              ? ""WeightedRoundRobinSubchannelList""+                              : nullptr),+                         std::move(addresses), policy->channel_control_helper(),+                         args) {+      // Need to maintain a ref to the LB policy as long as we maintain+      // any references to subchannels, since the subchannels'+      // pollset_sets will include the LB policy's pollset_set.+      policy->Ref(DEBUG_LOCATION, ""subchannel_list"").release();+    }++    ~WeightedRoundRobinSubchannelList() override {+      WeightedRoundRobin* p = static_cast<WeightedRoundRobin*>(policy());+      p->Unref(DEBUG_LOCATION, ""subchannel_list"");+    }++    // Updates the counters of subchannels in each state when a+    // subchannel transitions from old_state to new_state.+    void UpdateStateCountersLocked(+        absl::optional<grpc_connectivity_state> old_state,+        grpc_connectivity_state new_state);++    // Ensures that the right subchannel list is used and then updates+    // the aggregated connectivity state based on the subchannel list's+    // state counters.+    void MaybeUpdateAggregatedConnectivityStateLocked(+        absl::Status status_for_tf);++   private:+    std::string CountersString() const {+      return absl::StrCat(""num_subchannels="", num_subchannels(),+                          "" num_ready="", num_ready_,+                          "" num_connecting="", num_connecting_,+                          "" num_transient_failure="", num_transient_failure_);+    }++    size_t num_ready_ = 0;+    size_t num_connecting_ = 0;+    size_t num_transient_failure_ = 0;++    absl::Status last_failure_;+  };++  // A picker that performs WRR picks with weights based on+  // endpoint-reported utilization and QPS.+  class Picker : public SubchannelPicker {+   public:+    Picker(RefCountedPtr<WeightedRoundRobin> wrr,+           WeightedRoundRobinSubchannelList* subchannel_list);++    ~Picker() override;++    PickResult Pick(PickArgs args) override;++    void Orphan() override;++   private:+    // A call tracker that collects per-call endpoint utilization reports.+    class SubchannelCallTracker : public SubchannelCallTrackerInterface {+     public:+      explicit SubchannelCallTracker(RefCountedPtr<AddressWeight> weight)+          : weight_(std::move(weight)) {}++      void Start() override {}++      void Finish(FinishArgs args) override;++     private:+      RefCountedPtr<AddressWeight> weight_;+    };++    // Info stored about each subchannel.+    struct SubchannelInfo {+      SubchannelInfo(RefCountedPtr<SubchannelInterface> subchannel,+                     RefCountedPtr<AddressWeight> weight)+          : subchannel(std::move(subchannel)), weight(std::move(weight)) {}++      RefCountedPtr<SubchannelInterface> subchannel;+      RefCountedPtr<AddressWeight> weight;+    };++    // Returns the index into subchannels_ to be picked.+    size_t PickIndex();++    // Builds a new scheduler and swaps it into place, then starts a+    // timer for the next update.+    void BuildSchedulerAndStartTimerLocked()+        ABSL_EXCLUSIVE_LOCKS_REQUIRED(&mu_);++    RefCountedPtr<WeightedRoundRobin> wrr_;+    const bool use_per_rpc_utilization_;+    const Duration weight_update_period_;+    const Duration weight_expiration_period_;+    const Duration blackout_period_;+    std::vector<SubchannelInfo> subchannels_;++    Mutex mu_;+    uint32_t scheduler_state_ ABSL_GUARDED_BY(&mu_);+    absl::optional<StaticStrideScheduler> scheduler_ ABSL_GUARDED_BY(&mu_);+    absl::optional<grpc_event_engine::experimental::EventEngine::TaskHandle>+        timer_handle_ ABSL_GUARDED_BY(&mu_);++    // Used when falling back to RR.+    size_t last_picked_index_;+  };++  ~WeightedRoundRobin() override;++  void ShutdownLocked() override;++  RefCountedPtr<AddressWeight> GetOrCreateWeight(+      const grpc_resolved_address& address);++  RefCountedPtr<WeightedRoundRobinConfig> config_;++  // List of subchannels.+  RefCountedPtr<WeightedRoundRobinSubchannelList> subchannel_list_;+  // Latest pending subchannel list.+  // When we get an updated address list, we create a new subchannel list+  // for it here, and we wait to swap it into subchannel_list_ until the new+  // list becomes READY.+  RefCountedPtr<WeightedRoundRobinSubchannelList>+      latest_pending_subchannel_list_;++  Mutex address_weight_map_mu_;+  std::map<std::string, AddressWeight*, std::less<>> address_weight_map_+      ABSL_GUARDED_BY(&address_weight_map_mu_);++  bool shutdown_ = false;++  absl::BitGen bit_gen_;+};++//+// WeightedRoundRobin::AddressWeight+//++WeightedRoundRobin::AddressWeight::~AddressWeight() {+  MutexLock lock(&wrr_->address_weight_map_mu_);+  auto it = wrr_->address_weight_map_.find(key_);+  if (it != wrr_->address_weight_map_.end() && it->second == this) {+    wrr_->address_weight_map_.erase(it);+  }+}++void WeightedRoundRobin::AddressWeight::MaybeUpdateWeight(+    double qps, double cpu_utilization) {+  // Compute weight.+  float weight = 0;+  if (qps > 0 && cpu_utilization > 0) weight = qps / cpu_utilization;+  if (weight == 0) {+    if (GRPC_TRACE_FLAG_ENABLED(grpc_lb_wrr_trace)) {+      gpr_log(GPR_INFO,+              ""[WRR %p] subchannel %s: qps=%f, cpu_utilization=%f: weight=%f ""+              ""(not updating)"",+              wrr_.get(), key_.c_str(), qps, cpu_utilization, weight);+    }+    return;+  }+  Timestamp now = Timestamp::Now();+  // Grab the lock and update the data.+  MutexLock lock(&mu_);+  if (GRPC_TRACE_FLAG_ENABLED(grpc_lb_wrr_trace)) {+    gpr_log(GPR_INFO,+            ""[WRR %p] subchannel %s: qps=%f, cpu_utilization=%f: setting ""+            ""weight=%f weight_=%f now=%s last_update_time_=%s ""+            ""non_empty_since_=%s"",+            wrr_.get(), key_.c_str(), qps, cpu_utilization, weight, weight_,+            now.ToString().c_str(), last_update_time_.ToString().c_str(),+            non_empty_since_.ToString().c_str());+  }+  if (non_empty_since_ == Timestamp::InfFuture()) non_empty_since_ = now;+  weight_ = weight;+  last_update_time_ = now;+}++float WeightedRoundRobin::AddressWeight::GetWeight(+    Timestamp now, Duration weight_expiration_period,+    Duration blackout_period) {+  MutexLock lock(&mu_);+  if (GRPC_TRACE_FLAG_ENABLED(grpc_lb_wrr_trace)) {+    gpr_log(GPR_INFO,+            ""[WRR %p] subchannel %s: getting weight: now=%s ""+            ""weight_expiration_period=%s blackout_period=%s ""+            ""last_update_time_=%s non_empty_since_=%s weight_=%f"",+            wrr_.get(), key_.c_str(), now.ToString().c_str(),+            weight_expiration_period.ToString().c_str(),+            blackout_period.ToString().c_str(),+            last_update_time_.ToString().c_str(),+            non_empty_since_.ToString().c_str(), weight_);+  }+  // If the most recent update was longer ago than the expiration+  // period, reset non_empty_since_ so that we apply the blackout period+  // again if we start getting data again in the future, and return 0.+  if (now - last_update_time_ >= weight_expiration_period) {+    non_empty_since_ = Timestamp::InfFuture();+    return 0;+  }+  // If we don't have at least blackout_period worth of data, return 0.+  if (blackout_period > Duration::Zero() &&+      now - non_empty_since_ < blackout_period) {+    return 0;+  }+  // Otherwise, return the weight.+  return weight_;+}++void WeightedRoundRobin::AddressWeight::ResetNonEmptySince() {+  MutexLock lock(&mu_);+  non_empty_since_ = Timestamp::InfFuture();+}++//+// WeightedRoundRobin::Picker::SubchannelCallTracker+//++void WeightedRoundRobin::Picker::SubchannelCallTracker::Finish(+    FinishArgs args) {+  auto* backend_metric_data =+      args.backend_metric_accessor->GetBackendMetricData();+  double qps = 0;+  double cpu_utilization = 0;+  if (backend_metric_data != nullptr) {+    qps = backend_metric_data->qps;+    cpu_utilization = backend_metric_data->cpu_utilization;+  }+  weight_->MaybeUpdateWeight(qps, cpu_utilization);+}++//+// WeightedRoundRobin::Picker+//++WeightedRoundRobin::Picker::Picker(+    RefCountedPtr<WeightedRoundRobin> wrr,+    WeightedRoundRobinSubchannelList* subchannel_list)+    : wrr_(std::move(wrr)),+      use_per_rpc_utilization_(!wrr_->config_->enable_oob_load_report()),+      weight_update_period_(wrr_->config_->weight_update_period()),+      weight_expiration_period_(wrr_->config_->weight_expiration_period()),+      blackout_period_(wrr_->config_->blackout_period()),+      scheduler_state_(absl::Uniform<uint32_t>(wrr_->bit_gen_)),+      last_picked_index_(absl::Uniform<size_t>(wrr_->bit_gen_)) {+  for (size_t i = 0; i < subchannel_list->num_subchannels(); ++i) {+    WeightedRoundRobinSubchannelData* sd = subchannel_list->subchannel(i);+    if (sd->connectivity_state() == GRPC_CHANNEL_READY) {+      subchannels_.emplace_back(sd->subchannel()->Ref(), sd->weight());+    }+  }+  if (GRPC_TRACE_FLAG_ENABLED(grpc_lb_wrr_trace)) {+    gpr_log(GPR_INFO,+            ""[WRR %p picker %p] created picker from subchannel_list=%p ""+            ""with %"" PRIuPTR "" subchannels"",+            wrr_.get(), this, subchannel_list, subchannels_.size());+  }+  BuildSchedulerAndStartTimerLocked();+}++WeightedRoundRobin::Picker::~Picker() {+  if (GRPC_TRACE_FLAG_ENABLED(grpc_lb_wrr_trace)) {+    gpr_log(GPR_INFO, ""[WRR %p picker %p] destroying picker"", wrr_.get(), this);+  }+}++void WeightedRoundRobin::Picker::Orphan() {+  MutexLock lock(&mu_);+  if (GRPC_TRACE_FLAG_ENABLED(grpc_lb_wrr_trace)) {+    gpr_log(GPR_INFO, ""[WRR %p picker %p] cancelling timer"", wrr_.get(), this);+  }+  wrr_->channel_control_helper()->GetEventEngine()->Cancel(*timer_handle_);+  timer_handle_.reset();+}++WeightedRoundRobin::PickResult WeightedRoundRobin::Picker::Pick(+    PickArgs /*args*/) {+  size_t index = PickIndex();+  GPR_ASSERT(index < subchannels_.size());+  auto& subchannel_info = subchannels_[index];+  // Collect per-call utilization data if needed.+  std::unique_ptr<SubchannelCallTrackerInterface> subchannel_call_tracker;+  if (use_per_rpc_utilization_) {+    subchannel_call_tracker =+        std::make_unique<SubchannelCallTracker>(subchannel_info.weight);+  }+  if (GRPC_TRACE_FLAG_ENABLED(grpc_lb_wrr_trace)) {+    gpr_log(GPR_INFO,+            ""[WRR %p picker %p] returning index %"" PRIuPTR "", subchannel=%p"",+            wrr_.get(), this, index, subchannel_info.subchannel.get());+  }+  return PickResult::Complete(subchannel_info.subchannel,+                              std::move(subchannel_call_tracker));+}++size_t WeightedRoundRobin::Picker::PickIndex() {+  // Grab the mutex and do WRR pick if we have a scheduler.+  {+    MutexLock lock(&mu_);+    if (scheduler_.has_value()) {",I wound up changing this as part of the change we discussed to share the scheduler state between pickers.  But we're still not going to get any additional parallelism here until #31973 lands.,
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/31661,1080697410,2023-01-19T00:25:15Z,test/core/iomgr/endpoint_tests.cc,"@@ -134,8 +135,12 @@ static void read_and_write_test_read_handler(void* data,   struct read_and_write_test_state* state =       static_cast<struct read_and_write_test_state*>(data); -  state->bytes_read += count_slices(-      state->incoming.slices, state->incoming.count, &state->current_read_data);+  if (error.ok()) {","Here's a version that checks the error once:```static void read_and_write_test_read_handler_read_done(    read_and_write_test_state* state) {  gpr_log(GPR_DEBUG, ""Read handler done"");  gpr_mu_lock(g_mu);  GRPC_LOG_IF_ERROR(""pollset_kick"", grpc_pollset_kick(g_pollset, nullptr));  gpr_mu_unlock(g_mu);}static void read_and_write_test_read_handler(void* data,                                             grpc_error_handle error) {  struct read_and_write_test_state* state =      static_cast<struct read_and_write_test_state*>(data);  if (!error.ok()) {    state->read_done = 1;    read_and_write_test_read_handler_read_done();    return;  }  state->bytes_read += count_slices(      state->incoming.slices, state->incoming.count, &state->current_read_data);  if (state->bytes_read == state->target_bytes) {    state->read_done = 2;    read_and_write_test_read_handler_read_done();    return;  }  // We perform many reads one after another. If grpc_endpoint_read and the  // read_handler are both run inline, we might end up growing the stack  // beyond the limit. Schedule the read on ExecCtx to avoid this.  grpc_core::ExecCtx::Run(DEBUG_LOCATION, &state->read_scheduler,                          absl::OkStatus());}```Without thread annotations, it isn't super clear to me what needs to be guarded by g_mu, so the state->read_done value may need to move into the helper method (but I don't think so).",
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/32147,1080699887,2023-01-19T00:30:49Z,tools/internal_ci/linux/grpc_bazel_rbe.sh,"@@ -34,3 +34,7 @@ bazel_rbe/bazel_wrapper \   $BAZEL_FLAGS \   ""$@"" \   -- ${BAZEL_TESTS:-//test/...}++# Print disk usage+df -h+du -hs * | sort -rh | head -100","`du -h --max-depth=1` will also capture hidden dirs. `.cache` and `.local` on my systems are generally always hefty, unclear what the build environment may be hiding where. It'll be interesting to see if the repo root takes up the majority of the space, too.",
287917,eugeneo,https://api.github.com/repos/grpc/grpc/pulls/31985,1081711465,2023-01-19T19:16:28Z,test/core/client_channel/lb_policy/xds_override_host_test.cc,"@@ -64,11 +64,13 @@ class XdsOverrideHostTest : public LoadBalancingPolicyTest {   }    RefCountedPtr<LoadBalancingPolicy::SubchannelPicker>-  ExpectStartupWithRoundRobin(absl::Span<const absl::string_view> addresses) {+  ExpectStartupWithRoundRobin(absl::Span<const absl::string_view> addresses,+                              RefCountedPtr<LoadBalancingPolicy::Config>+                                  config = MakeXdsOverrideHostConfig()) {     RefCountedPtr<LoadBalancingPolicy::SubchannelPicker> picker;-    EXPECT_EQ(ApplyUpdate(BuildUpdate(addresses, MakeXdsOverrideHostConfig()),-                          policy_.get()),-              absl::OkStatus());+    EXPECT_EQ(+        ApplyUpdate(BuildUpdate(addresses, std::move(config)), policy_.get()),",I don't think we are mutating the config so removing the move should be enough.Changing to ConfigBuilder would be a bigger change that I can make in a separate PR.,X
52979934,matthewstevenson88,https://api.github.com/repos/grpc/grpc/pulls/31867,1081832779,2023-01-19T20:32:26Z,src/core/tsi/alts/handshaker/alts_handshaker_client.cc,"@@ -732,16 +732,14 @@ alts_handshaker_client* alts_grpc_handshaker_client_create(   client->handshake_status_details = grpc_empty_slice();   client->max_frame_size = max_frame_size;   client->error = error;-  grpc_slice slice = grpc_slice_from_copied_string(handshaker_service_url);","@erm-g My understanding of @apolcyn's suggestion was that the `handshaker_service_url` *should* be removed from the parameter list of `alts_grpc_handshakerclient_create`, and I just wanted to call out an obstruction to doing so. :)+1 to @erm-g's question: is there any way to test this? Deferring to @apolcyn here.",
9566254,apolcyn,https://api.github.com/repos/grpc/grpc/pulls/31867,1081850627,2023-01-19T20:50:12Z,src/core/tsi/alts/handshaker/alts_handshaker_client.cc,"@@ -732,16 +732,14 @@ alts_handshaker_client* alts_grpc_handshaker_client_create(   client->handshake_status_details = grpc_empty_slice();   client->max_frame_size = max_frame_size;   client->error = error;-  grpc_slice slice = grpc_slice_from_copied_string(handshaker_service_url);","One idea to test this:We could start up the [fake ALTS handshaker service](https://github.com/grpc/grpc/blob/master/test/core/tsi/alts/fake_handshaker/fake_handshaker_server.cc) (an in-process gRPC server), and perform an ALTS handshake, setting the handshaker service url to something that needs this PR. We could add a field to the ALTS handshake server to check the RPC authority with [ExperimentalGetAuthority()](https://github.com/grpc/grpc/blob/c8407f8ef955ec064119790f41eb6e0469cc2df1/include/grpcpp/server_context.h#L300)",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/31448,1081926139,2023-01-19T22:13:29Z,src/core/lib/channel/connected_channel.cc,"@@ -825,8 +916,405 @@ class ClientConnectedCallPromise {   OrphanablePtr<ClientStream> impl_; }; +class ServerStream final : public ConnectedChannelStream {+ public:+  ServerStream(grpc_transport* transport,+               NextPromiseFactory next_promise_factory)+      : ConnectedChannelStream(transport) {+    SetStream(static_cast<grpc_stream*>(+        GetContext<Arena>()->Alloc(transport->vtable->sizeof_stream)));+    grpc_transport_init_stream(+        transport, stream(), stream_refcount(),+        GetContext<CallContext>()->server_call_context()->server_stream_data(),+        GetContext<Arena>());+    grpc_transport_set_pops(transport, stream(),+                            GetContext<CallContext>()->polling_entity());++    // Fetch initial metadata+    auto& gim =+        client_initial_metadata_state_.emplace<GettingInitialMetadata>(this);+    gim.recv_initial_metadata_ready_waker =+        Activity::current()->MakeOwningWaker();+    memset(&gim.recv_initial_metadata, 0, sizeof(gim.recv_initial_metadata));+    gim.recv_initial_metadata.payload = batch_payload();+    gim.recv_initial_metadata.on_complete = nullptr;+    gim.recv_initial_metadata.recv_initial_metadata = true;+    gim.next_promise_factory = std::move(next_promise_factory);+    batch_payload()->recv_initial_metadata.recv_initial_metadata =+        gim.client_initial_metadata.get();+    batch_payload()->recv_initial_metadata.recv_initial_metadata_ready =+        &gim.recv_initial_metadata_ready;+    SchedulePush(&gim.recv_initial_metadata);++    // Fetch trailing metadata (to catch cancellations)+    auto& gtm =+        client_trailing_metadata_state_.emplace<WaitingForTrailingMetadata>();+    gtm.recv_trailing_metadata_ready =+        MakeMemberClosure<ServerStream,+                          &ServerStream::RecvTrailingMetadataReady>(this);+    memset(&gtm.recv_trailing_metadata, 0, sizeof(gtm.recv_trailing_metadata));+    gtm.recv_trailing_metadata.payload = batch_payload();+    gtm.recv_trailing_metadata.recv_trailing_metadata = true;+    batch_payload()->recv_trailing_metadata.recv_trailing_metadata =+        gtm.result.get();+    batch_payload()->recv_trailing_metadata.collect_stats =+        &GetContext<CallContext>()->call_stats()->transport_stream_stats;+    batch_payload()->recv_trailing_metadata.recv_trailing_metadata_ready =+        &gtm.recv_trailing_metadata_ready;+    SchedulePush(&gtm.recv_trailing_metadata);+    gtm.waker = Activity::current()->MakeOwningWaker();+  }++  Poll<ServerMetadataHandle> PollOnce() {+    MutexLock lock(mu());++    auto poll_send_initial_metadata = [this]() ABSL_EXCLUSIVE_LOCKS_REQUIRED(+                                          mu()) {+      if (auto* promise =+              absl::get_if<PipeReceiverNextType<ServerMetadataHandle>>(+                  &server_initial_metadata_)) {+        auto r = (*promise)();+        if (auto* md = absl::get_if<NextResult<ServerMetadataHandle>>(&r)) {+          if (grpc_call_trace.enabled()) {+            gpr_log(+                GPR_INFO, ""%s[connected] got initial metadata %s"",+                Activity::current()->DebugTag().c_str(),+                (md->has_value() ? (**md)->DebugString() : ""<trailers-only>"")+                    .c_str());+          }+          memset(&send_initial_metadata_, 0, sizeof(send_initial_metadata_));+          send_initial_metadata_.send_initial_metadata = true;+          send_initial_metadata_.payload = batch_payload();+          send_initial_metadata_.on_complete = &send_initial_metadata_done_;+          batch_payload()->send_initial_metadata.send_initial_metadata =+              server_initial_metadata_+                  .emplace<ServerMetadataHandle>(std::move(**md))+                  .get();+          batch_payload()->send_initial_metadata.peer_string = nullptr;+          SchedulePush(&send_initial_metadata_);+          return true;+        } else {+          return false;+        }+      } else {+        return true;+      }+    };++    if (grpc_call_trace.enabled()) {+      gpr_log(GPR_INFO, ""%s[connected] PollConnectedChannel: %s"",+              Activity::current()->DebugTag().c_str(),+              ActiveOpsString().c_str());+    }++    poll_send_initial_metadata();++    if (auto* p = absl::get_if<GotTrailingMetadata>(+            &client_trailing_metadata_state_)) {+      if (absl::holds_alternative<Uninitialized>(+              client_initial_metadata_state_) ||+          absl::holds_alternative<GotInitialMetadata>(+              client_initial_metadata_state_) ||+          absl::holds_alternative<Running>(client_initial_metadata_state_)) {+        if (!absl::holds_alternative<ServerMetadataHandle>(+                server_initial_metadata_)) {+          server_initial_metadata_.emplace<ServerMetadataHandle>();+        }+        client_initial_metadata_state_.emplace<Complete>(+            Complete{ServerMetadataFromStatus(p->result)});+      }+    }++    if (auto* p =+            absl::get_if<GotInitialMetadata>(&client_initial_metadata_state_)) {+      incoming_messages_ = &pipes_.client_to_server.sender;+      auto promise = p->next_promise_factory(CallArgs{+          std::move(p->client_initial_metadata),+          &pipes_.server_initial_metadata.sender,+          &pipes_.client_to_server.receiver, &pipes_.server_to_client.sender});+      client_initial_metadata_state_.emplace<Running>(+          Running{&pipes_.server_to_client.receiver, std::move(promise)});+      server_initial_metadata_+          .emplace<PipeReceiverNextType<ServerMetadataHandle>>(+              pipes_.server_initial_metadata.receiver.Next());+    }+    if (incoming_messages_ != nullptr) {+      PollRecvMessage(incoming_messages_);+    }+    if (auto* p = absl::get_if<Running>(&client_initial_metadata_state_)) {+      if (absl::holds_alternative<ServerMetadataHandle>(+              server_initial_metadata_)) {+        PollSendMessage(p->outgoing_messages, nullptr);+      }+      auto poll = p->promise();+      if (auto* r = absl::get_if<ServerMetadataHandle>(&poll)) {+        if (grpc_call_trace.enabled()) {+          gpr_log(GPR_INFO, ""%s[connected] got trailing metadata %s; %s"",+                  Activity::current()->DebugTag().c_str(),+                  (*r)->DebugString().c_str(), ActiveOpsString().c_str());+        }+        auto& completing = client_initial_metadata_state_.emplace<Completing>();+        completing.server_trailing_metadata = std::move(*r);+        completing.on_complete =+            MakeMemberClosure<ServerStream,+                              &ServerStream::SendTrailingMetadataDone>(this);+        completing.waker = Activity::current()->MakeOwningWaker();+        auto& op = completing.send_trailing_metadata;+        memset(&op, 0, sizeof(op));+        op.payload = batch_payload();+        op.on_complete = &completing.on_complete;+        // If we've gotten initial server metadata, we can send trailing+        // metadata.+        // Otherwise we need to cancel the call.+        // There could be an unlucky ordering, so we poll here to make sure.+        if (poll_send_initial_metadata()) {+          op.send_trailing_metadata = true;+          batch_payload()->send_trailing_metadata.send_trailing_metadata =+              completing.server_trailing_metadata.get();+          batch_payload()->send_trailing_metadata.sent = &completing.sent;+        } else {+          op.cancel_stream = true;+          const auto status_code =+              completing.server_trailing_metadata->get(GrpcStatusMetadata())+                  .value_or(GRPC_STATUS_UNKNOWN);+          batch_payload()->cancel_stream.cancel_error = grpc_error_set_int(+              absl::Status(static_cast<absl::StatusCode>(status_code),+                           completing.server_trailing_metadata+                               ->GetOrCreatePointer(GrpcMessageMetadata())+                               ->as_string_view()),+              StatusIntProperty::kRpcStatus, status_code);+        }+        SchedulePush(&op);+      }+    }+    if (auto* p = absl::get_if<Complete>(&client_initial_metadata_state_)) {+      set_finished();+      return std::move(p->result);+    }+    return Pending{};+  }++ private:+  struct Uninitialized {};++  struct GettingInitialMetadata {+    explicit GettingInitialMetadata(ServerStream* stream)+        : recv_initial_metadata_ready(+              MakeMemberClosure<ServerStream,+                                &ServerStream::RecvInitialMetadataReady>(+                  stream)) {}+    grpc_transport_stream_op_batch recv_initial_metadata;+    Waker recv_initial_metadata_ready_waker;+    ClientMetadataHandle client_initial_metadata =+        GetContext<Arena>()->MakePooled<ClientMetadata>(GetContext<Arena>());+    grpc_closure recv_initial_metadata_ready;+    NextPromiseFactory next_promise_factory;+  };++  struct GotInitialMetadata {+    ClientMetadataHandle client_initial_metadata;+    NextPromiseFactory next_promise_factory;+  };++  struct Running {","Suggest renaming this to better reflect the state it indicates.Comments on all of these structus that go into the variants would be helpful, since these are basically states (as if they were a state enum).",X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/31448,1081927619,2023-01-19T22:15:39Z,src/core/lib/channel/connected_channel.cc,"@@ -825,8 +916,405 @@ class ClientConnectedCallPromise {   OrphanablePtr<ClientStream> impl_; }; +class ServerStream final : public ConnectedChannelStream {+ public:+  ServerStream(grpc_transport* transport,+               NextPromiseFactory next_promise_factory)+      : ConnectedChannelStream(transport) {+    SetStream(static_cast<grpc_stream*>(+        GetContext<Arena>()->Alloc(transport->vtable->sizeof_stream)));+    grpc_transport_init_stream(+        transport, stream(), stream_refcount(),+        GetContext<CallContext>()->server_call_context()->server_stream_data(),+        GetContext<Arena>());+    grpc_transport_set_pops(transport, stream(),+                            GetContext<CallContext>()->polling_entity());++    // Fetch initial metadata+    auto& gim =+        client_initial_metadata_state_.emplace<GettingInitialMetadata>(this);+    gim.recv_initial_metadata_ready_waker =+        Activity::current()->MakeOwningWaker();+    memset(&gim.recv_initial_metadata, 0, sizeof(gim.recv_initial_metadata));+    gim.recv_initial_metadata.payload = batch_payload();+    gim.recv_initial_metadata.on_complete = nullptr;+    gim.recv_initial_metadata.recv_initial_metadata = true;+    gim.next_promise_factory = std::move(next_promise_factory);+    batch_payload()->recv_initial_metadata.recv_initial_metadata =+        gim.client_initial_metadata.get();+    batch_payload()->recv_initial_metadata.recv_initial_metadata_ready =+        &gim.recv_initial_metadata_ready;+    SchedulePush(&gim.recv_initial_metadata);++    // Fetch trailing metadata (to catch cancellations)+    auto& gtm =+        client_trailing_metadata_state_.emplace<WaitingForTrailingMetadata>();+    gtm.recv_trailing_metadata_ready =+        MakeMemberClosure<ServerStream,+                          &ServerStream::RecvTrailingMetadataReady>(this);+    memset(&gtm.recv_trailing_metadata, 0, sizeof(gtm.recv_trailing_metadata));+    gtm.recv_trailing_metadata.payload = batch_payload();+    gtm.recv_trailing_metadata.recv_trailing_metadata = true;+    batch_payload()->recv_trailing_metadata.recv_trailing_metadata =+        gtm.result.get();+    batch_payload()->recv_trailing_metadata.collect_stats =+        &GetContext<CallContext>()->call_stats()->transport_stream_stats;+    batch_payload()->recv_trailing_metadata.recv_trailing_metadata_ready =+        &gtm.recv_trailing_metadata_ready;+    SchedulePush(&gtm.recv_trailing_metadata);+    gtm.waker = Activity::current()->MakeOwningWaker();+  }++  Poll<ServerMetadataHandle> PollOnce() {+    MutexLock lock(mu());++    auto poll_send_initial_metadata = [this]() ABSL_EXCLUSIVE_LOCKS_REQUIRED(+                                          mu()) {+      if (auto* promise =+              absl::get_if<PipeReceiverNextType<ServerMetadataHandle>>(+                  &server_initial_metadata_)) {+        auto r = (*promise)();+        if (auto* md = absl::get_if<NextResult<ServerMetadataHandle>>(&r)) {+          if (grpc_call_trace.enabled()) {+            gpr_log(+                GPR_INFO, ""%s[connected] got initial metadata %s"",+                Activity::current()->DebugTag().c_str(),+                (md->has_value() ? (**md)->DebugString() : ""<trailers-only>"")+                    .c_str());+          }+          memset(&send_initial_metadata_, 0, sizeof(send_initial_metadata_));+          send_initial_metadata_.send_initial_metadata = true;+          send_initial_metadata_.payload = batch_payload();+          send_initial_metadata_.on_complete = &send_initial_metadata_done_;+          batch_payload()->send_initial_metadata.send_initial_metadata =+              server_initial_metadata_+                  .emplace<ServerMetadataHandle>(std::move(**md))+                  .get();+          batch_payload()->send_initial_metadata.peer_string = nullptr;+          SchedulePush(&send_initial_metadata_);+          return true;+        } else {+          return false;+        }+      } else {+        return true;+      }+    };++    if (grpc_call_trace.enabled()) {+      gpr_log(GPR_INFO, ""%s[connected] PollConnectedChannel: %s"",+              Activity::current()->DebugTag().c_str(),+              ActiveOpsString().c_str());+    }++    poll_send_initial_metadata();++    if (auto* p = absl::get_if<GotTrailingMetadata>(+            &client_trailing_metadata_state_)) {+      if (absl::holds_alternative<Uninitialized>(+              client_initial_metadata_state_) ||+          absl::holds_alternative<GotInitialMetadata>(+              client_initial_metadata_state_) ||+          absl::holds_alternative<Running>(client_initial_metadata_state_)) {+        if (!absl::holds_alternative<ServerMetadataHandle>(+                server_initial_metadata_)) {+          server_initial_metadata_.emplace<ServerMetadataHandle>();+        }+        client_initial_metadata_state_.emplace<Complete>(+            Complete{ServerMetadataFromStatus(p->result)});+      }+    }++    if (auto* p =+            absl::get_if<GotInitialMetadata>(&client_initial_metadata_state_)) {+      incoming_messages_ = &pipes_.client_to_server.sender;+      auto promise = p->next_promise_factory(CallArgs{+          std::move(p->client_initial_metadata),+          &pipes_.server_initial_metadata.sender,+          &pipes_.client_to_server.receiver, &pipes_.server_to_client.sender});+      client_initial_metadata_state_.emplace<Running>(+          Running{&pipes_.server_to_client.receiver, std::move(promise)});+      server_initial_metadata_+          .emplace<PipeReceiverNextType<ServerMetadataHandle>>(+              pipes_.server_initial_metadata.receiver.Next());+    }+    if (incoming_messages_ != nullptr) {+      PollRecvMessage(incoming_messages_);+    }+    if (auto* p = absl::get_if<Running>(&client_initial_metadata_state_)) {+      if (absl::holds_alternative<ServerMetadataHandle>(+              server_initial_metadata_)) {+        PollSendMessage(p->outgoing_messages, nullptr);+      }+      auto poll = p->promise();+      if (auto* r = absl::get_if<ServerMetadataHandle>(&poll)) {+        if (grpc_call_trace.enabled()) {+          gpr_log(GPR_INFO, ""%s[connected] got trailing metadata %s; %s"",+                  Activity::current()->DebugTag().c_str(),+                  (*r)->DebugString().c_str(), ActiveOpsString().c_str());+        }+        auto& completing = client_initial_metadata_state_.emplace<Completing>();+        completing.server_trailing_metadata = std::move(*r);+        completing.on_complete =+            MakeMemberClosure<ServerStream,+                              &ServerStream::SendTrailingMetadataDone>(this);+        completing.waker = Activity::current()->MakeOwningWaker();+        auto& op = completing.send_trailing_metadata;+        memset(&op, 0, sizeof(op));+        op.payload = batch_payload();+        op.on_complete = &completing.on_complete;+        // If we've gotten initial server metadata, we can send trailing+        // metadata.+        // Otherwise we need to cancel the call.+        // There could be an unlucky ordering, so we poll here to make sure.+        if (poll_send_initial_metadata()) {+          op.send_trailing_metadata = true;+          batch_payload()->send_trailing_metadata.send_trailing_metadata =+              completing.server_trailing_metadata.get();+          batch_payload()->send_trailing_metadata.sent = &completing.sent;+        } else {+          op.cancel_stream = true;+          const auto status_code =+              completing.server_trailing_metadata->get(GrpcStatusMetadata())+                  .value_or(GRPC_STATUS_UNKNOWN);+          batch_payload()->cancel_stream.cancel_error = grpc_error_set_int(+              absl::Status(static_cast<absl::StatusCode>(status_code),+                           completing.server_trailing_metadata+                               ->GetOrCreatePointer(GrpcMessageMetadata())+                               ->as_string_view()),+              StatusIntProperty::kRpcStatus, status_code);+        }+        SchedulePush(&op);+      }+    }+    if (auto* p = absl::get_if<Complete>(&client_initial_metadata_state_)) {+      set_finished();+      return std::move(p->result);+    }+    return Pending{};+  }++ private:+  struct Uninitialized {};++  struct GettingInitialMetadata {+    explicit GettingInitialMetadata(ServerStream* stream)+        : recv_initial_metadata_ready(+              MakeMemberClosure<ServerStream,+                                &ServerStream::RecvInitialMetadataReady>(+                  stream)) {}+    grpc_transport_stream_op_batch recv_initial_metadata;+    Waker recv_initial_metadata_ready_waker;+    ClientMetadataHandle client_initial_metadata =+        GetContext<Arena>()->MakePooled<ClientMetadata>(GetContext<Arena>());+    grpc_closure recv_initial_metadata_ready;+    NextPromiseFactory next_promise_factory;+  };++  struct GotInitialMetadata {+    ClientMetadataHandle client_initial_metadata;+    NextPromiseFactory next_promise_factory;+  };++  struct Running {+    PipeReceiver<MessageHandle>* outgoing_messages;+    ArenaPromise<ServerMetadataHandle> promise;+  };++  struct Completing {+    ServerMetadataHandle server_trailing_metadata;+    grpc_transport_stream_op_batch send_trailing_metadata;+    grpc_closure on_complete;+    bool sent = false;+    Waker waker;+  };++  struct Complete {+    ServerMetadataHandle result;+  };++  struct WaitingForTrailingMetadata {+    ClientMetadataHandle result =+        GetContext<Arena>()->MakePooled<ClientMetadata>(GetContext<Arena>());+    grpc_transport_stream_op_batch recv_trailing_metadata;+    grpc_closure recv_trailing_metadata_ready;+    Waker waker;+  };++  struct GotTrailingMetadata {+    absl::Status result;+  };++  void RecvInitialMetadataReady(absl::Status status) {+    MutexLock lock(mu());+    auto& getting =+        absl::get<GettingInitialMetadata>(client_initial_metadata_state_);+    auto waker = std::move(getting.recv_initial_metadata_ready_waker);+    if (grpc_call_trace.enabled()) {+      gpr_log(GPR_DEBUG, ""%sGOT INITIAL METADATA: err=%s %s"",+              waker.ActivityDebugTag().c_str(), status.ToString().c_str(),+              getting.client_initial_metadata->DebugString().c_str());+    }+    GotInitialMetadata got{std::move(getting.client_initial_metadata),+                           std::move(getting.next_promise_factory)};+    client_initial_metadata_state_.emplace<GotInitialMetadata>(std::move(got));+    waker.Wakeup();+  }++  void SendTrailingMetadataDone(absl::Status result) {+    MutexLock lock(mu());+    auto& completing = absl::get<Completing>(client_initial_metadata_state_);+    auto md = std::move(completing.server_trailing_metadata);+    auto waker = std::move(completing.waker);+    if (grpc_call_trace.enabled()) {+      gpr_log(GPR_DEBUG, ""%sSEND TRAILING METADATA DONE: err=%s sent=%s %s"",+              waker.ActivityDebugTag().c_str(), result.ToString().c_str(),+              completing.sent ? ""true"" : ""false"", md->DebugString().c_str());+    }+    md->Set(GrpcStatusFromWire(), completing.sent);+    if (!result.ok()) {+      md->Clear();+      md->Set(GrpcStatusMetadata(),+              static_cast<grpc_status_code>(result.code()));+      md->Set(GrpcMessageMetadata(), Slice::FromCopiedString(result.message()));+      md->Set(GrpcStatusFromWire(), false);+    }+    client_initial_metadata_state_.emplace<Complete>(Complete{std::move(md)});+    waker.Wakeup();+  }++  std::string ActiveOpsString() const override+      ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu()) {+    std::vector<std::string> ops;+    ops.push_back(absl::StrCat(+        ""client_initial_metadata_state:"",+        Match(+            client_initial_metadata_state_,+            [](const Uninitialized&) { return ""UNINITIALIZED""; },+            [](const GettingInitialMetadata&) { return ""GETTING""; },+            [](const GotInitialMetadata&) { return ""GOT""; },+            [](const Running&) { return ""RUNNING""; },+            [](const Completing&) { return ""COMPLETING""; },+            [](const Complete&) { return ""COMPLETE""; })));+    ops.push_back(absl::StrCat(+        ""client_trailing_metadata_state:"",+        Match(+            client_trailing_metadata_state_,+            [](const Uninitialized&) -> std::string { return ""UNINITIALIZED""; },+            [](const WaitingForTrailingMetadata&) -> std::string {+              return ""WAITING"";+            },+            [](const GotTrailingMetadata& got) -> std::string {+              return absl::StrCat(""GOT:"", got.result.ToString());+            })));+    // Send initial metadata+    ops.push_back(+        absl::StrCat(""server_initial_metadata_state:"",+                     Match(+                         server_initial_metadata_,+                         [](const Uninitialized&) { return ""UNINITIALIZED""; },+                         [](const PipeReceiverNextType<ServerMetadataHandle>&) {+                           return ""WAITING"";+                         },+                         [](const ServerMetadataHandle&) { return ""GOT""; })));+    // Send message+    std::string send_message_state = SendMessageString();+    if (send_message_state != ""WAITING"") {+      ops.push_back(absl::StrCat(""send_message:"", send_message_state));+    }+    // Receive message+    std::string recv_message_state = RecvMessageString();+    if (recv_message_state != ""IDLE"") {+      ops.push_back(absl::StrCat(""recv_message:"", recv_message_state));+    }+    return absl::StrJoin(ops, "" "");+  }++  void SendInitialMetadataDone() {}++  void RecvTrailingMetadataReady(absl::Status error) {+    MutexLock lock(mu());+    auto& state =+        absl::get<WaitingForTrailingMetadata>(client_trailing_metadata_state_);+    if (grpc_call_trace.enabled()) {+      gpr_log(GPR_INFO,+              ""%sRecvTrailingMetadataReady: error:%s metadata:%s state:%s"",+              state.waker.ActivityDebugTag().c_str(), error.ToString().c_str(),+              state.result->DebugString().c_str(), ActiveOpsString().c_str());+    }+    auto waker = std::move(state.waker);+    ServerMetadataHandle result = std::move(state.result);+    if (error.ok()) {+      auto* message = result->get_pointer(GrpcMessageMetadata());+      error = absl::Status(+          static_cast<absl::StatusCode>(+              result->get(GrpcStatusMetadata()).value_or(GRPC_STATUS_UNKNOWN)),+          message == nullptr ? """" : message->as_string_view());+    }+    client_trailing_metadata_state_.emplace<GotTrailingMetadata>(+        GotTrailingMetadata{});+    waker.Wakeup();+  }++  struct Pipes {+    Pipe<MessageHandle> server_to_client;+    Pipe<MessageHandle> client_to_server;+    Pipe<ServerMetadataHandle> server_initial_metadata;+  };++  using ClientInitialMetadataState =",Suggest renaming this.  It's actually the entire call's state.,X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/31448,1081944875,2023-01-19T22:40:36Z,src/core/lib/surface/server.cc,"@@ -306,11 +349,66 @@ class Server::RealRequestMatcher : public RequestMatcherInterface {     calld->Publish(cq_idx, rc);   } +  ArenaPromise<absl::StatusOr<MatchResult>> MatchRequest(+      size_t start_request_queue_index) override {+    for (size_t i = 0; i < requests_per_cq_.size(); i++) {+      size_t cq_idx = (start_request_queue_index + i) % requests_per_cq_.size();+      RequestedCall* rc =+          reinterpret_cast<RequestedCall*>(requests_per_cq_[cq_idx].TryPop());+      if (rc != nullptr) {+        return Immediate(MatchResult{cq_idx, rc});+      }+    }+    // No cq to take the request found; queue it on the slow list.+    // We need to ensure that all the queues are empty.  We do this under+    // the server mu_call_ lock to ensure that if something is added to+    // an empty request queue, it will block until the call is actually+    // added to the pending list.+    RequestedCall* rc = nullptr;+    size_t cq_idx = 0;+    size_t loop_count;+    {+      MutexLock lock(&server_->mu_call_);+      for (loop_count = 0; loop_count < requests_per_cq_.size(); loop_count++) {+        cq_idx =+            (start_request_queue_index + loop_count) % requests_per_cq_.size();+        rc = reinterpret_cast<RequestedCall*>(requests_per_cq_[cq_idx].Pop());+        if (rc != nullptr) {+          break;+        }+      }+      if (rc == nullptr) {+        auto w = std::make_shared<ActivityWaiter>(+            Activity::current()->MakeNonOwningWaker());+        pending_.push(w);+        return [w]() -> Poll<absl::StatusOr<MatchResult>> {+          std::unique_ptr<absl::StatusOr<MatchResult>> r(+              w->result.exchange(nullptr, std::memory_order_acq_rel));+          if (r == nullptr) return Pending{};+          return std::move(*r);+        };+      }+    }+    return Immediate(MatchResult{cq_idx, rc});+  }+   Server* server() const override { return server_; }   private:   Server* const server_;-  std::queue<CallData*> pending_;+  struct ActivityWaiter {+    explicit ActivityWaiter(Waker waker) : waker(std::move(waker)) {}+    ~ActivityWaiter() { delete result.load(std::memory_order_acquire); }+    void Finish(absl::StatusOr<MatchResult> r) {+      result.store(new absl::StatusOr<MatchResult>(std::move(r)),+                   std::memory_order_release);+      waker.Wakeup();+    }+    Waker waker;+    std::atomic<absl::StatusOr<MatchResult>*> result{nullptr};","Suggest using `std::atomic<bool>` here and then adding a `absl::StatusOr<MatchResult>` data member, just to avoid an allocation.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/31448,1081954686,2023-01-19T22:56:22Z,src/core/lib/surface/server.cc,"@@ -306,11 +349,66 @@ class Server::RealRequestMatcher : public RequestMatcherInterface {     calld->Publish(cq_idx, rc);   } +  ArenaPromise<absl::StatusOr<MatchResult>> MatchRequest(","This looks almost-but-not-quite identical to `MatchOrQueue()`.  Is there a way of refactoring the code a bit to avoid some of the duplication?Obviously, this may not be worth doing if the amount of complexity involved would be worse than the duplication.",X
85715732,yousukseung,https://api.github.com/repos/grpc/grpc/pulls/31904,1081982684,2023-01-19T23:48:34Z,src/core/ext/filters/client_channel/lb_policy/weighted_round_robin/weighted_round_robin.cc,"@@ -523,17 +524,21 @@ WeightedRoundRobin::PickResult WeightedRoundRobin::Picker::Pick( }  size_t WeightedRoundRobin::Picker::PickIndex() {-  // Grab the mutex and do WRR pick if we have a scheduler.+  // Grab a ref to the scheduler.+  std::shared_ptr<StaticStrideScheduler> scheduler;   {     MutexLock lock(&mu_);-    if (scheduler_.has_value()) {-      return scheduler_->Pick();-    }+    scheduler = scheduler_;   }+  // If we have a scheduler, use it to do a WRR pick.+  if (scheduler != nullptr) return scheduler->Pick();   // We don't have a scheduler (i.e., either all of the weights are 0 or   // there is only one subchannel), so fall back to RR.-  last_picked_index_ = (last_picked_index_ + 1) % subchannels_.size();-  return last_picked_index_;+  size_t index = last_picked_index_.fetch_add(1);+  if (index > 0 && index % subchannels_.size() == 0) {+    last_picked_index_.fetch_sub(subchannels_.size());","I think it's not critical but still not sure if we need this. When it wraps it will jump to an index which will be approximately uniformly random, which is the same as when we create a new picker. Given we are not concerned with the impact of a new picker that much I think it's fine to not have this. And when the subchannel list is very small I guess the overhead becomes a bit unnecessary.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/31904,1082003727,2023-01-20T00:30:31Z,src/core/ext/filters/client_channel/lb_policy/weighted_round_robin/weighted_round_robin.cc,"@@ -523,17 +524,21 @@ WeightedRoundRobin::PickResult WeightedRoundRobin::Picker::Pick( }  size_t WeightedRoundRobin::Picker::PickIndex() {-  // Grab the mutex and do WRR pick if we have a scheduler.+  // Grab a ref to the scheduler.+  std::shared_ptr<StaticStrideScheduler> scheduler;   {     MutexLock lock(&mu_);-    if (scheduler_.has_value()) {-      return scheduler_->Pick();-    }+    scheduler = scheduler_;   }+  // If we have a scheduler, use it to do a WRR pick.+  if (scheduler != nullptr) return scheduler->Pick();   // We don't have a scheduler (i.e., either all of the weights are 0 or   // there is only one subchannel), so fall back to RR.-  last_picked_index_ = (last_picked_index_ + 1) % subchannels_.size();-  return last_picked_index_;+  size_t index = last_picked_index_.fetch_add(1);+  if (index > 0 && index % subchannels_.size() == 0) {+    last_picked_index_.fetch_sub(subchannels_.size());","We create a new picker only when something is changing (either the list of addresses changes or a subchannel connectivity state changes), in which case there's already going to be churn.  In the case where there is no external churn, I don't think we want this kind of discontinuity.The existing RR policy in gRPC already does this, so I think it's good to be consistent here -- and this code path will be executed only when we don't have any weights anyway.  But I'll follow up on whether or not this is worth doing performance-wise.",
85715732,yousukseung,https://api.github.com/repos/grpc/grpc/pulls/32106,1082114131,2023-01-20T05:08:27Z,src/core/ext/filters/load_reporting/backend_metric_data.h,"@@ -0,0 +1,106 @@+/*+ *+ * Copyright 2022 gRPC authors.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ *     http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ *+ */++#ifndef GRPC_CORE_EXT_FILTERS_LOAD_REPORTING_BACKEND_METRIC_DATA_H+#define GRPC_CORE_EXT_FILTERS_LOAD_REPORTING_BACKEND_METRIC_DATA_H++#include <grpc/support/port_platform.h>++#include <atomic>+#include <map>++#include ""src/core/lib/gprpp/sync.h""+#include ""absl/strings/string_view.h""++namespace grpc {+class BackendMetricState;+}  // namespace grpc+ +namespace grpc_core {++// Represents backend metrics reported by the backend to the client.+struct BackendMetricData {","Moved BackendMetricProvider to its own file, and moved backend_metric_data.h to src/core/ext/filters/backend_metrics/",X
85715732,yousukseung,https://api.github.com/repos/grpc/grpc/pulls/32106,1082122157,2023-01-20T05:29:08Z,src/cpp/server/server_context.cc,"@@ -54,12 +53,154 @@ #include <grpcpp/support/string_ref.h>  #include ""src/core/lib/gprpp/crash.h""+#include ""src/core/ext/filters/load_reporting/backend_metric_data.h"" #include ""src/core/lib/gprpp/ref_counted.h"" #include ""src/core/lib/gprpp/sync.h""-#include ""src/core/lib/resource_quota/arena.h"" #include ""src/core/lib/surface/call.h"" +grpc_core::TraceFlag grpc_backend_metric_state_trace(false, ""backend_metric_state"");+ namespace grpc {+namespace {+// All utilization values must be in [0, 1].+bool IsUtilizationValid(double utilization) {+  return utilization >= 0.0 && utilization <= 1.0;+}++// QPS must be in [0, infy).+bool IsQpsValid(double utilization) {+  return utilization >= 0.0;+}+}  // namespace++class BackendMetricState : public CallMetricRecorder,+                           public grpc_core::BackendMetricProvider {+ public:+  // `server_metric_recorder` is optional. When set, GetBackendMetricData()+  // merges metrics from `server_metric_recorder` with metrics recorded to this.+  explicit BackendMetricState(grpc_core::ServerMetricRecorder* server_metric_recorder)+      : server_metric_recorder_(server_metric_recorder) {}+  ~BackendMetricState() override = default;+  CallMetricRecorder& RecordCpuUtilizationMetric(double value) override {+    if (!IsUtilizationValid(value)) {+      if (GRPC_TRACE_FLAG_ENABLED(grpc_backend_metric_state_trace)) {+        gpr_log(GPR_INFO, ""[%p] CPU utilization value rejected: %f"", this, value);+      }+      return *this;+    }+    cpu_utilization_.store(value, std::memory_order_relaxed);+    if (GRPC_TRACE_FLAG_ENABLED(grpc_backend_metric_state_trace)) {+      gpr_log(GPR_INFO, ""[%p] CPU utilization recorded: %f"", this, value);+    }+    return *this;+  }+  CallMetricRecorder& RecordMemoryUtilizationMetric(double value) override {+    if (!IsUtilizationValid(value)) {+      if (GRPC_TRACE_FLAG_ENABLED(grpc_backend_metric_state_trace)) {+        gpr_log(GPR_INFO, ""[%p] Mem utilization value rejected: %f"", this, value);+      }+      return *this;+    }+    mem_utilization_.store(value, std::memory_order_relaxed);+    if (GRPC_TRACE_FLAG_ENABLED(grpc_backend_metric_state_trace)) {+      gpr_log(GPR_INFO, ""[%p] Mem utilization recorded: %f"", this, value);+    }+    return *this;+  }+  CallMetricRecorder& RecordQpsMetric(double value) override {+    if (!IsQpsValid(value)) {+      if (GRPC_TRACE_FLAG_ENABLED(grpc_backend_metric_state_trace)) {+        gpr_log(GPR_INFO, ""[%p] QPS value rejected: %f"", this, value);+      }+      return *this;+    }+    qps_.store(value, std::memory_order_relaxed);+    if (GRPC_TRACE_FLAG_ENABLED(grpc_backend_metric_state_trace)) {+      gpr_log(GPR_INFO, ""[%p] QPS recorded: %f"", this, value);+    }+    return *this;+  }+  CallMetricRecorder& RecordUtilizationMetric(string_ref name,+                                              double value) override {+    if (!IsUtilizationValid(value)) {+      if (GRPC_TRACE_FLAG_ENABLED(grpc_backend_metric_state_trace)) {+        gpr_log(GPR_INFO, ""[%p] Utilization value rejected: %s %f"", this,+                std::string(name.data(), name.length()).c_str(), value);+      }+      return *this;+    }+    internal::MutexLock lock(&mu_);+    absl::string_view name_sv(name.data(), name.length());+    utilization_[name_sv] = value;+    if (GRPC_TRACE_FLAG_ENABLED(grpc_backend_metric_state_trace)) {+      gpr_log(GPR_INFO, ""[%p] Utilization recorded: %s %f"", this,+              std::string(name_sv).c_str(), value);+    }+    return *this;+  }+  CallMetricRecorder& RecordRequestCostMetric(string_ref name,+                                              double value) override {+    internal::MutexLock lock(&mu_);+    absl::string_view name_sv(name.data(), name.length());+    request_cost_[name_sv] = value;+    if (GRPC_TRACE_FLAG_ENABLED(grpc_backend_metric_state_trace)) {+      gpr_log(GPR_INFO, ""[%p] Request cost recorded: %s %f"", this,+              std::string(name_sv).c_str(), value);+    }+    return *this;+  }++ private:+  void GetBackendMetricData(grpc_core::BackendMetricData* data) override {+    // Merge metrics from the ServerMetricRecorder first since metrics recorded+    // to this (CallMetricRecorder) takes a higher precedence.+    if (server_metric_recorder_) {+      server_metric_recorder_->GetMetrics(data);+    }+    // Only overwrite if the value is set i.e. in the valid range.+    const double cpu = cpu_utilization_.load(std::memory_order_relaxed);+    if (IsUtilizationValid(cpu)) {+      data->cpu_utilization = cpu;+    }+    const double mem = mem_utilization_.load(std::memory_order_relaxed);+    if (IsUtilizationValid(mem)) {+      data->mem_utilization = mem;+    }+    const double qps = qps_.load(std::memory_order_relaxed);+    if (IsQpsValid(qps)) {+      data->qps = qps;+    }+    {+      internal::MutexLock lock(&mu_);+      if (!utilization_.empty() || !request_cost_.empty()) {","I intended to put the lock inside the if, updated and PTAL. The rational is that since we don't guarantee strict synchronization between set/get, we can return without acquiring the lock if both are empty. E.g. in prod I expect we'll return here in a big majority of cases.",
85715732,yousukseung,https://api.github.com/repos/grpc/grpc/pulls/32106,1082129190,2023-01-20T05:46:14Z,src/cpp/server/server_cc.cc,"@@ -171,6 +171,9 @@ bool ServerInterface::BaseAsyncRequest::FinalizeResult(void** tag,     return true;   }   context_->set_call(call_);","Done, though since ServerMetricRecorder is optional I added two parameters.Craig said this part will soon be refactored and he does not care much and was fine with the current version, but I think the updated version is still better as we don't repeat the same snippet. Let me know.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/31985,1082916816,2023-01-20T18:27:01Z,src/core/ext/filters/client_channel/lb_policy/xds/xds_override_host.cc,"@@ -572,16 +589,22 @@ XdsOverrideHostLb::GetSubchannelByAddress(absl::string_view address) {   MutexLock lock(&subchannel_map_mu_);   auto it = subchannel_map_.find(address);   if (it != subchannel_map_.end()) {-    auto subchannel = it->second.GetSubchannel();-    if (subchannel == nullptr || !config_->override_host_status_set().Contains(-                                     subchannel->health_status())) {-      return nullptr;-    }-    return subchannel->Ref();+    return it->second.GetSubchannel()->Ref();","This code still needs to check whether the override status set from the config includes the status of the address.  You had this in the previous snapshot, but it looks like you removed it accidentally.To do this, you will need to have the picker pass its `override_host_health_status_set_` data member into `GetSubchannelByAddress` as a parameter.Also, the tests should be catching this bug.  If they're not, then we need to fix the tests.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32106,1083084968,2023-01-20T21:57:28Z,include/grpcpp/ext/call_metric_recorder.h,"@@ -37,7 +37,6 @@ namespace grpc { class ServerBuilder;","Please remove this forward declaration, as well as the `namespace grpc_core` block on lines 31-34 above.  These are no longer needed.",X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32106,1083124897,2023-01-20T23:07:33Z,src/core/ext/filters/backend_metrics/backend_metric_data.h,"@@ -0,0 +1,60 @@+/*+ *+ * Copyright 2022 gRPC authors.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ *     http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ *+ */++#ifndef GRPC_CORE_EXT_FILTERS_BACKEND_METRICS_BACKEND_METRIC_DATA_H","Now that we're keeping `BackendMetricData` in its own file with nothing else, I think we should actually just keep it in the existing location:https://github.com/grpc/grpc/blob/master/src/core/ext/filters/client_channel/lb_policy/backend_metric_data.hLet's remove this duplicate copy.  The original location makes more sense, since it's actually part of the LB policy API on the client side, whereas on the server side it's a completely hidden implementation detail.",X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32106,1083126021,2023-01-20T23:09:09Z,src/core/ext/filters/backend_metrics/backend_metric_provider.h,"@@ -0,0 +1,34 @@+/*+ *+ * Copyright 2023 gRPC authors.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ *     http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ *+ */++#ifndef GRPC_CORE_EXT_FILTERS_BACKEND_METRICS_BACKEND_METRIC_DATA_H+#define GRPC_CORE_EXT_FILTERS_BACKEND_METRICS_BACKEND_METRIC_DATA_H++namespace grpc_core {++struct BackendMetricData;+class BackendMetricProvider {+ public:+  virtual ~BackendMetricProvider() = default;+  // Only populates fields in `data` that this has recorded metrics.+  virtual void GetBackendMetricData(BackendMetricData* data) = 0;","I requested this change earlier, and it looks like you changed the implementation, but you didn't actually update the interface:This should return `BackendMetricData` instead of making it an output parameter.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32106,1083139068,2023-01-20T23:34:05Z,src/cpp/server/server_context.cc,"@@ -68,23 +72,24 @@ bool IsUtilizationValid(double utilization) { }  // QPS must be in [0, infy).-bool IsQpsValid(double utilization) {-  return utilization >= 0.0;-}+bool IsQpsValid(double qps) { return qps >= 0.0; } }  // namespace -class BackendMetricState : public CallMetricRecorder,+class BackendMetricState : public experimental::CallMetricRecorder,","I suggest defining this class and `ServerMetricRecorder` in the same file, since they're very similar code, and the validation functions can be shared between them.Specifically, I suggest:1. Rename server_metric_recorder.cc to backend_metric_recorder.cc.2. Move the declaration of `BackendMetricState` to a new file called backend_metric_recorder.h.3. Move the implementation of `BackendMetricState` to backend_metric_recorder.cc.",X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32106,1083142373,2023-01-20T23:44:49Z,src/cpp/server/server_context.cc,"@@ -54,12 +53,154 @@ #include <grpcpp/support/string_ref.h>  #include ""src/core/lib/gprpp/crash.h""+#include ""src/core/ext/filters/load_reporting/backend_metric_data.h"" #include ""src/core/lib/gprpp/ref_counted.h"" #include ""src/core/lib/gprpp/sync.h""-#include ""src/core/lib/resource_quota/arena.h"" #include ""src/core/lib/surface/call.h"" +grpc_core::TraceFlag grpc_backend_metric_state_trace(false, ""backend_metric_state"");+ namespace grpc {+namespace {+// All utilization values must be in [0, 1].+bool IsUtilizationValid(double utilization) {+  return utilization >= 0.0 && utilization <= 1.0;+}++// QPS must be in [0, infy).+bool IsQpsValid(double utilization) {+  return utilization >= 0.0;+}+}  // namespace++class BackendMetricState : public CallMetricRecorder,+                           public grpc_core::BackendMetricProvider {+ public:+  // `server_metric_recorder` is optional. When set, GetBackendMetricData()+  // merges metrics from `server_metric_recorder` with metrics recorded to this.+  explicit BackendMetricState(grpc_core::ServerMetricRecorder* server_metric_recorder)+      : server_metric_recorder_(server_metric_recorder) {}+  ~BackendMetricState() override = default;+  CallMetricRecorder& RecordCpuUtilizationMetric(double value) override {+    if (!IsUtilizationValid(value)) {+      if (GRPC_TRACE_FLAG_ENABLED(grpc_backend_metric_state_trace)) {+        gpr_log(GPR_INFO, ""[%p] CPU utilization value rejected: %f"", this, value);+      }+      return *this;+    }+    cpu_utilization_.store(value, std::memory_order_relaxed);+    if (GRPC_TRACE_FLAG_ENABLED(grpc_backend_metric_state_trace)) {+      gpr_log(GPR_INFO, ""[%p] CPU utilization recorded: %f"", this, value);+    }+    return *this;+  }+  CallMetricRecorder& RecordMemoryUtilizationMetric(double value) override {+    if (!IsUtilizationValid(value)) {+      if (GRPC_TRACE_FLAG_ENABLED(grpc_backend_metric_state_trace)) {+        gpr_log(GPR_INFO, ""[%p] Mem utilization value rejected: %f"", this, value);+      }+      return *this;+    }+    mem_utilization_.store(value, std::memory_order_relaxed);+    if (GRPC_TRACE_FLAG_ENABLED(grpc_backend_metric_state_trace)) {+      gpr_log(GPR_INFO, ""[%p] Mem utilization recorded: %f"", this, value);+    }+    return *this;+  }+  CallMetricRecorder& RecordQpsMetric(double value) override {+    if (!IsQpsValid(value)) {+      if (GRPC_TRACE_FLAG_ENABLED(grpc_backend_metric_state_trace)) {+        gpr_log(GPR_INFO, ""[%p] QPS value rejected: %f"", this, value);+      }+      return *this;+    }+    qps_.store(value, std::memory_order_relaxed);+    if (GRPC_TRACE_FLAG_ENABLED(grpc_backend_metric_state_trace)) {+      gpr_log(GPR_INFO, ""[%p] QPS recorded: %f"", this, value);+    }+    return *this;+  }+  CallMetricRecorder& RecordUtilizationMetric(string_ref name,+                                              double value) override {+    if (!IsUtilizationValid(value)) {+      if (GRPC_TRACE_FLAG_ENABLED(grpc_backend_metric_state_trace)) {+        gpr_log(GPR_INFO, ""[%p] Utilization value rejected: %s %f"", this,+                std::string(name.data(), name.length()).c_str(), value);+      }+      return *this;+    }+    internal::MutexLock lock(&mu_);+    absl::string_view name_sv(name.data(), name.length());+    utilization_[name_sv] = value;+    if (GRPC_TRACE_FLAG_ENABLED(grpc_backend_metric_state_trace)) {+      gpr_log(GPR_INFO, ""[%p] Utilization recorded: %s %f"", this,+              std::string(name_sv).c_str(), value);+    }+    return *this;+  }+  CallMetricRecorder& RecordRequestCostMetric(string_ref name,+                                              double value) override {+    internal::MutexLock lock(&mu_);+    absl::string_view name_sv(name.data(), name.length());+    request_cost_[name_sv] = value;+    if (GRPC_TRACE_FLAG_ENABLED(grpc_backend_metric_state_trace)) {+      gpr_log(GPR_INFO, ""[%p] Request cost recorded: %s %f"", this,+              std::string(name_sv).c_str(), value);+    }+    return *this;+  }++ private:+  void GetBackendMetricData(grpc_core::BackendMetricData* data) override {+    // Merge metrics from the ServerMetricRecorder first since metrics recorded+    // to this (CallMetricRecorder) takes a higher precedence.+    if (server_metric_recorder_) {+      server_metric_recorder_->GetMetrics(data);+    }+    // Only overwrite if the value is set i.e. in the valid range.+    const double cpu = cpu_utilization_.load(std::memory_order_relaxed);+    if (IsUtilizationValid(cpu)) {+      data->cpu_utilization = cpu;+    }+    const double mem = mem_utilization_.load(std::memory_order_relaxed);+    if (IsUtilizationValid(mem)) {+      data->mem_utilization = mem;+    }+    const double qps = qps_.load(std::memory_order_relaxed);+    if (IsQpsValid(qps)) {+      data->qps = qps;+    }+    {+      internal::MutexLock lock(&mu_);+      if (!utilization_.empty() || !request_cost_.empty()) {","I don't think it's safe to check whether the maps are empty without holding the lock.  There could be another thread adding an entry to one of the maps at the same moment that this code is checking whether they're empty.A more efficient way to do this would be something like this:```{  internal::MutexLock lock(&mu_);  data->utilization = std::move(utilization_);  data->request_cost = std::move(request_cost_);}```I think this basically amounts to a couple of pointer swaps, regardless of whether or not the maps are empty.  And it's much more efficient in the case that the maps are *not* empty.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32067,1083159632,2023-01-21T00:25:06Z,src/proto/grpc/testing/xds/v3/client_side_weighted_round_robin.proto,"@@ -0,0 +1,67 @@+// Copyright 2023 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++// Local copy of Envoy xDS proto file, used for testing only.++syntax = ""proto3"";++package envoy.extensions.load_balancing_policies.client_side_weighted_round_robin.v3;++import ""google/protobuf/duration.proto"";+import ""google/protobuf/wrappers.proto"";++// [#protodoc-title: Client-Side Weighted Round Robin Load Balancing Policy]+// [#not-implemented-hide:]++// Configuration for the client_side_weighted_round_robin LB policy.+//+// This policy differs from the built-in ROUND_ROBIN policy in terms of+// how the endpoint weights are determined. In the ROUND_ROBIN policy,+// the endpoint weights are sent by the control plane via EDS. However,+// in this policy, the endpoint weights are instead determined via+// qps and CPU utilization metrics sent by the endpoint using the Open+// Request Cost Aggregation (ORCA) protocol. The weight of a given endpoint+// is computed as qps / cpu_utilization.+//+// See the :ref:`load balancing architecture overview<arch_overview_load_balancing_types>` for more information.+//+// [#next-free-field: 6]+message ClientSideWeightedRoundRobin {+  // Whether to enable out-of-band utilization reporting collection from+  // the endpoints. By default, per-request utilization reporting is used.+  google.protobuf.BoolValue enable_oob_load_report = 1;++  // Load reporting interval to request from the server. Note that the+  // server may not provide reports as frequently as the client requests.+  // Used only when enable_oob_load_report is true. Default is 10 seconds.+  google.protobuf.Duration oob_reporting_period = 2;++  // A given endpoint must report load metrics continuously for at least+  // this long before the endpoint weight will be used. This avoids+  // churn when the set of endpoint addresses changes. Takes effect+  // both immediately after we establish a connection to an endpoint and+  // after weight_expiration_period has caused us to stop using the most+  // recent load metrics. Default is 10 seconds.+  google.protobuf.Duration blackout_period = 3;++  // If a given endpoint has not reported load metrics in this long,+  // then we stop using the reported weight. This ensures that we do+  // not continue to use very stale weights. Once we stop using a stale+  // value, if we later start seeing fresh reports again, the+  // blackout_period applies. Defaults to 3 minutes.+  google.protobuf.Duration weight_expiration_period = 4;++  // How often endpoint weights are recalculated.  Default is 1 second.","This file is just a local copy of the xDS proto file, used only for tests.  We unfortunately need this due to some circular dependency problems with protos whose BUILD rules depend on gRPC itself.  No one is going to actually look at the comments in this file, so there's no point in changing them.",X
85715732,yousukseung,https://api.github.com/repos/grpc/grpc/pulls/32106,1083241417,2023-01-21T04:41:18Z,include/grpcpp/server.h,"@@ -338,6 +347,12 @@ class Server : public ServerInterface, private internal::GrpcLibrary {   // Shutdown.  Even though this is only used with NDEBUG, instantiate it in all   // cases since otherwise the size will be inconsistent.   std::vector<CompletionQueue*> cq_list_;++  // Whetner per-call load reporting is enabled.+  bool call_metric_recording_enabled_ = false;","I'll update once can conclude what we want:- Creating CMR lazily makes a lot of sense and I can update. I just kept the old behavior where it's always created when call metric recording is enabled (OrcaInterceptor creates upon seeing the init metadata).- But I also want to keep the current behavior that GetCallMetricRecorder() returns null when call metric recording is not enabled (effectively, since OrcaInterceptor creates it). I think this is a very good design, it will save users from misusing and save time to debug as they will fail outright instead of silently falling back to RR.- Current implementation already is designed so that if SMR is set, CMR is always set. The case I raise above is the inverse. When CMR is set and the call metric recording is enabled, we don't necessarily need to require to instantiate and pass SMR if server metrics are not collected. RR + GSLB is just one example, but I don't think it's prod specific.If we want all of the above I think we need a way to tell if the call metric recording was enabled when the server was built. I could not find a way other than storing a flag.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32106,1084376927,2023-01-23T18:00:54Z,include/grpcpp/ext/orca_service.h,"@@ -48,38 +49,16 @@ class OrcaService : public Service {     }   }; -  explicit OrcaService(Options options);--  // Sets or removes the CPU utilization value to be reported to clients.-  void SetCpuUtilization(double cpu_utilization);-  void DeleteCpuUtilization();--  // Sets of removes the memory utilization value to be reported to clients.-  void SetMemoryUtilization(double memory_utilization);-  void DeleteMemoryUtilization();--  // Sets of removes the QPS value to be reported to clients.-  void SetQps(double qps);-  void DeleteQps();--  // Sets or removed named utilization values to be reported to clients.-  void SetNamedUtilization(std::string name, double utilization);-  void DeleteNamedUtilization(const std::string& name);-  void SetAllNamedUtilization(std::map<std::string, double> named_utilization);+  OrcaService(const ServerMetricRecorder& server_metric_recorder,+              Options options);   private:   class Reactor; -  Slice GetOrCreateSerializedResponse();+  Slice CreateSerializedResponse(); +  const ServerMetricRecorder& server_metric_recorder_;   const absl::Duration min_report_duration_;--  grpc::internal::Mutex mu_;-  double cpu_utilization_ ABSL_GUARDED_BY(&mu_) = -1;-  double memory_utilization_ ABSL_GUARDED_BY(&mu_) = -1;-  double qps_ ABSL_GUARDED_BY(&mu_) = -1;-  std::map<std::string, double> named_utilization_ ABSL_GUARDED_BY(&mu_);-  absl::optional<Slice> response_slice_ ABSL_GUARDED_BY(&mu_);","This change loses the optimization that we currently have here to avoid reserializing the ORCA proto on each individual response.  I think we do want to try to retain that optimization, because a given `OrcaService` could have a very large number of clients, all of which will be getting the same data.One possible option here would be to have `ServerMetricRecorder` track a timestamp for the last time any of its fields were updated, and have `OrcaService` cache the serialized proto along with the last time it grabbed data from `ServerMetricRecorder`.  That way, `OrcaService` could reserialize the proto only when the data has changed.  But we might need to use a mutex instead of separate atomics for each field in order to make that work properly.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32106,1084385728,2023-01-23T18:08:38Z,src/cpp/server/server_context.cc,"@@ -157,14 +157,15 @@ class BackendMetricState : public experimental::CallMetricRecorder,   }   private:+  // Once returned metrics recorded with CallMetricRecorder APIs are cleared.   grpc_core::BackendMetricData GetBackendMetricData() override       ABSL_NO_THREAD_SAFETY_ANALYSIS {-    grpc_core::BackendMetricData data;     // Merge metrics from the ServerMetricRecorder first since metrics recorded-    // to this (CallMetricRecorder) takes a higher precedence.-    if (server_metric_recorder_ != nullptr) {-      server_metric_recorder_->GetMetrics(&data);-    }+    // to CallMetricRecorder takes a higher precedence.+    grpc_core::BackendMetricData data =",Suggest writing this as:```grpc_core::BackendMetricData data;if (server_metric_recorder_ != nullptr) {  data = server_metric_recorder_->GetMetrics();}```,
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32106,1084391473,2023-01-23T18:15:02Z,src/cpp/server/server_context.cc,"@@ -54,12 +53,154 @@ #include <grpcpp/support/string_ref.h>  #include ""src/core/lib/gprpp/crash.h""+#include ""src/core/ext/filters/load_reporting/backend_metric_data.h"" #include ""src/core/lib/gprpp/ref_counted.h"" #include ""src/core/lib/gprpp/sync.h""-#include ""src/core/lib/resource_quota/arena.h"" #include ""src/core/lib/surface/call.h"" +grpc_core::TraceFlag grpc_backend_metric_state_trace(false, ""backend_metric_state"");+ namespace grpc {+namespace {+// All utilization values must be in [0, 1].+bool IsUtilizationValid(double utilization) {+  return utilization >= 0.0 && utilization <= 1.0;+}++// QPS must be in [0, infy).+bool IsQpsValid(double utilization) {+  return utilization >= 0.0;+}+}  // namespace++class BackendMetricState : public CallMetricRecorder,+                           public grpc_core::BackendMetricProvider {+ public:+  // `server_metric_recorder` is optional. When set, GetBackendMetricData()+  // merges metrics from `server_metric_recorder` with metrics recorded to this.+  explicit BackendMetricState(grpc_core::ServerMetricRecorder* server_metric_recorder)+      : server_metric_recorder_(server_metric_recorder) {}+  ~BackendMetricState() override = default;+  CallMetricRecorder& RecordCpuUtilizationMetric(double value) override {+    if (!IsUtilizationValid(value)) {+      if (GRPC_TRACE_FLAG_ENABLED(grpc_backend_metric_state_trace)) {+        gpr_log(GPR_INFO, ""[%p] CPU utilization value rejected: %f"", this, value);+      }+      return *this;+    }+    cpu_utilization_.store(value, std::memory_order_relaxed);+    if (GRPC_TRACE_FLAG_ENABLED(grpc_backend_metric_state_trace)) {+      gpr_log(GPR_INFO, ""[%p] CPU utilization recorded: %f"", this, value);+    }+    return *this;+  }+  CallMetricRecorder& RecordMemoryUtilizationMetric(double value) override {+    if (!IsUtilizationValid(value)) {+      if (GRPC_TRACE_FLAG_ENABLED(grpc_backend_metric_state_trace)) {+        gpr_log(GPR_INFO, ""[%p] Mem utilization value rejected: %f"", this, value);+      }+      return *this;+    }+    mem_utilization_.store(value, std::memory_order_relaxed);+    if (GRPC_TRACE_FLAG_ENABLED(grpc_backend_metric_state_trace)) {+      gpr_log(GPR_INFO, ""[%p] Mem utilization recorded: %f"", this, value);+    }+    return *this;+  }+  CallMetricRecorder& RecordQpsMetric(double value) override {+    if (!IsQpsValid(value)) {+      if (GRPC_TRACE_FLAG_ENABLED(grpc_backend_metric_state_trace)) {+        gpr_log(GPR_INFO, ""[%p] QPS value rejected: %f"", this, value);+      }+      return *this;+    }+    qps_.store(value, std::memory_order_relaxed);+    if (GRPC_TRACE_FLAG_ENABLED(grpc_backend_metric_state_trace)) {+      gpr_log(GPR_INFO, ""[%p] QPS recorded: %f"", this, value);+    }+    return *this;+  }+  CallMetricRecorder& RecordUtilizationMetric(string_ref name,+                                              double value) override {+    if (!IsUtilizationValid(value)) {+      if (GRPC_TRACE_FLAG_ENABLED(grpc_backend_metric_state_trace)) {+        gpr_log(GPR_INFO, ""[%p] Utilization value rejected: %s %f"", this,+                std::string(name.data(), name.length()).c_str(), value);+      }+      return *this;+    }+    internal::MutexLock lock(&mu_);+    absl::string_view name_sv(name.data(), name.length());+    utilization_[name_sv] = value;+    if (GRPC_TRACE_FLAG_ENABLED(grpc_backend_metric_state_trace)) {+      gpr_log(GPR_INFO, ""[%p] Utilization recorded: %s %f"", this,+              std::string(name_sv).c_str(), value);+    }+    return *this;+  }+  CallMetricRecorder& RecordRequestCostMetric(string_ref name,+                                              double value) override {+    internal::MutexLock lock(&mu_);+    absl::string_view name_sv(name.data(), name.length());+    request_cost_[name_sv] = value;+    if (GRPC_TRACE_FLAG_ENABLED(grpc_backend_metric_state_trace)) {+      gpr_log(GPR_INFO, ""[%p] Request cost recorded: %s %f"", this,+              std::string(name_sv).c_str(), value);+    }+    return *this;+  }++ private:+  void GetBackendMetricData(grpc_core::BackendMetricData* data) override {+    // Merge metrics from the ServerMetricRecorder first since metrics recorded+    // to this (CallMetricRecorder) takes a higher precedence.+    if (server_metric_recorder_) {+      server_metric_recorder_->GetMetrics(data);+    }+    // Only overwrite if the value is set i.e. in the valid range.+    const double cpu = cpu_utilization_.load(std::memory_order_relaxed);+    if (IsUtilizationValid(cpu)) {+      data->cpu_utilization = cpu;+    }+    const double mem = mem_utilization_.load(std::memory_order_relaxed);+    if (IsUtilizationValid(mem)) {+      data->mem_utilization = mem;+    }+    const double qps = qps_.load(std::memory_order_relaxed);+    if (IsQpsValid(qps)) {+      data->qps = qps;+    }+    {+      internal::MutexLock lock(&mu_);+      if (!utilization_.empty() || !request_cost_.empty()) {","> Map's const methods are safe to call without a lockAs far as I know, that is an incorrect statement.  I certainly do not see anything in the API definition that says that this would be safe.I think the only way this could possibly be true is if the implementation of `std::map<>` internally used an atomic to store the size of the map, because otherwise it's possible for one thread to be in the middle of adding an element while another thread uses a const pointer to call `empty()`.  And I very much doubt that any implementation would use an atomic for that, since that would impose overhead on every caller, even those that don't actually need the thread-safety that this would provide.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32106,1084418168,2023-01-23T18:42:27Z,src/core/ext/filters/backend_metrics/backend_metric_filter.cc,"@@ -0,0 +1,108 @@+#include ""src/core/ext/filters/backend_metrics/backend_metric_filter.h""++#include <grpc/support/port_platform.h>++#include ""upb/upb.h""+#include ""upb/upb.hpp""+#include ""xds/data/orca/v3/orca_load_report.upb.h""++#include ""src/core/ext/filters/client_channel/lb_policy/backend_metric_data.h""+#include ""src/core/lib/debug/trace.h""+#include ""src/core/lib/promise/map.h""+#include ""src/core/lib/resource_quota/arena.h""++namespace grpc_core {++TraceFlag grpc_backend_metric_filter_trace(false, ""backend_metric_filter"");++absl::optional<std::string> BackendMetricFilter::MaybeSerializeBackendMetrics(+    BackendMetricProvider* provider) const {+  if (provider == nullptr) return absl::nullopt;+  BackendMetricData d = provider->GetBackendMetricData();+  upb::Arena arena;+  xds_data_orca_v3_OrcaLoadReport* response =+      xds_data_orca_v3_OrcaLoadReport_new(arena.ptr());++  if (d.cpu_utilization != -1) {+    xds_data_orca_v3_OrcaLoadReport_set_cpu_utilization(response,+                                                        d.cpu_utilization);+  }+  if (d.mem_utilization != -1) {+    xds_data_orca_v3_OrcaLoadReport_set_mem_utilization(response,+                                                        d.mem_utilization);+  }+  if (d.qps != -1) {+    xds_data_orca_v3_OrcaLoadReport_set_rps_fractional(response, d.qps);+  }+  for (const auto& p : d.request_cost) {+    xds_data_orca_v3_OrcaLoadReport_request_cost_set(+        response,+        upb_StringView_FromDataAndSize(p.first.data(), p.first.size()),+        p.second, arena.ptr());+  }+  for (const auto& p : d.utilization) {+    xds_data_orca_v3_OrcaLoadReport_utilization_set(+        response,+        upb_StringView_FromDataAndSize(p.first.data(), p.first.size()),+        p.second, arena.ptr());+  }+  size_t len;+  char* buf =+      xds_data_orca_v3_OrcaLoadReport_serialize(response, arena.ptr(), &len);","Given that we are going to be unconditionally creating the `CallMetricRecorder` whenever call metric reporting is enabled, even if the application does not actually provide any metrics, I think we should add an optimization here to avoid serializing the proto (or therefore adding the metadata) if none of the fields were actually populated.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32106,1084420026,2023-01-23T18:44:37Z,test/cpp/end2end/client_lb_end2end_test.cc,"@@ -394,7 +395,8 @@ class ClientLbEnd2endTest : public ::testing::Test {     const int port_;     std::unique_ptr<Server> server_;     MyTestServiceImpl service_;-    experimental::OrcaService orca_service_;+    experimental::ServerMetricRecorder server_metric_recorder_;+    std::unique_ptr<experimental::OrcaService> orca_service_;",Why did you make this a `unique_ptr<>`?  I think it was fine being a direct data member.,
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32106,1084422417,2023-01-23T18:47:20Z,test/cpp/end2end/orca_service_end2end_test.cc,"@@ -107,16 +112,13 @@ class OrcaServiceEnd2endTest : public ::testing::Test {   ~OrcaServiceEnd2endTest() override { server_->Shutdown(); }    std::string server_address_;-  OrcaService orca_service_;+  ServerMetricRecorder server_metric_recorder_;+  std::unique_ptr<OrcaService> orca_service_;",I don't think this needs to be changed to be a `unique_ptr<>`.  I think it's fine being a direct data member.,
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/31985,1084472313,2023-01-23T19:41:05Z,src/core/ext/filters/client_channel/lb_policy/xds/xds_override_host.cc,"@@ -242,21 +243,18 @@ class XdsOverrideHostLb : public LoadBalancingPolicy {     explicit SubchannelEntry(XdsHealthStatus eds_health_status)         : eds_health_status_(eds_health_status) {} -    ~SubchannelEntry() {-      SubchannelWrapper* subchannel = GetSubchannel();-      if (subchannel != nullptr) subchannel->Shutdown();-    }--    void SetSubchannel(RefCountedPtr<SubchannelWrapper> subchannel) {+    void SetSubchannel(SubchannelWrapper* subchannel) {+      ResetSubchannel();       if (eds_health_status_.status() == XdsHealthStatus::kDraining) {-        subchannel_ = subchannel;+        subchannel_ = subchannel->Ref();       } else {-        subchannel_ = subchannel.get();+        subchannel_ = subchannel;       }     } -    void ResetSubchannel(SubchannelWrapper* expected) {-      if (GetSubchannel() == expected) {+    void ResetSubchannel() {+      SubchannelWrapper* subchannel = GetSubchannel();+      if (subchannel != nullptr) {",I think there's no need for this check anymore.  It should be fine to just unconditionally set it to null.,
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/31985,1084484466,2023-01-23T19:55:27Z,src/core/ext/filters/client_channel/lb_policy/xds/xds_override_host.cc,"@@ -529,15 +523,15 @@ absl::StatusOr<ServerAddressList> XdsOverrideHostLb::UpdateAddressMap(     XdsHealthStatus status = GetAddressHealthStatus(address);     if (status.status() != XdsHealthStatus::kDraining) {       return_value.push_back(address);+    } else if (!config_->override_host_status_set().Contains(+                   XdsHealthStatus(status))) {",No need to explicitly instantiate a new `XdsHealthStatus` object here; you can just pass `status` directly.,
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/31985,1084552257,2023-01-23T21:06:05Z,src/core/ext/filters/client_channel/lb_policy/xds/xds_override_host.cc,"@@ -242,21 +243,18 @@ class XdsOverrideHostLb : public LoadBalancingPolicy {     explicit SubchannelEntry(XdsHealthStatus eds_health_status)         : eds_health_status_(eds_health_status) {} -    ~SubchannelEntry() {-      SubchannelWrapper* subchannel = GetSubchannel();-      if (subchannel != nullptr) subchannel->Shutdown();-    }--    void SetSubchannel(RefCountedPtr<SubchannelWrapper> subchannel) {+    void SetSubchannel(SubchannelWrapper* subchannel) {+      ResetSubchannel();","Now that we've changed the subchannel to shut down automatically when it loses all of its strong refs, I think we no longer need this line.",X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/31985,1084558158,2023-01-23T21:11:27Z,src/core/ext/filters/client_channel/lb_policy/xds/xds_override_host.cc,"@@ -239,15 +302,21 @@ class XdsOverrideHostLb : public LoadBalancingPolicy {    RefCountedPtr<SubchannelWrapper> LookupSubchannel(absl::string_view address); -  void UpdateAddressMap(const absl::StatusOr<ServerAddressList>& addresses);+  absl::StatusOr<ServerAddressList> UpdateAddressMap(+      absl::StatusOr<ServerAddressList> addresses);    RefCountedPtr<SubchannelWrapper> AdoptSubchannel(       ServerAddress address, RefCountedPtr<SubchannelInterface> subchannel);    void ResetSubchannel(absl::string_view key, SubchannelWrapper* subchannel);",Suggest renaming this to `UnsetSubchannel()` as well.,X
133680,sampajano,https://api.github.com/repos/grpc/grpc/pulls/32077,1084637613,2023-01-23T22:30:12Z,src/core/lib/event_engine/cf_engine/cf_engine.cc,"@@ -89,12 +109,12 @@ std::unique_ptr<EventEngine::DNSResolver> CFEventEngine::GetDNSResolver(   grpc_core::Crash(""unimplemented""); } -void CFEventEngine::Run(EventEngine::Closure* /* closure */) {-  grpc_core::Crash(""unimplemented"");+void CFEventEngine::Run(EventEngine::Closure* closure) {+  executor_->Run(closure);","there's a null check here, do we need it?https://github.com/grpc/grpc/blob/1bcaa3e9351a9b00f5ce2a4b68c5e3bf61f6be8d/src/core/lib/event_engine/posix_engine/posix_engine.cc#L301-L312",
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/31928,1084691735,2023-01-23T23:59:55Z,src/core/lib/experiments/experiments.yaml,"@@ -119,4 +119,11 @@   expiry: 2023/04/01   owner: alishananda@google.com   test_tags: [resource_quota_test]+- name: event_engine_server","nit: suggest `event_engine_listener`, because it enables use of the `EventEngine::Listener`.",
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/31928,1084695835,2023-01-24T00:06:40Z,src/core/lib/iomgr/event_engine_shims/endpoint.cc,"@@ -128,6 +128,12 @@ class EventEngineEndpointWrapper {   void ShutdownUnref() {     if (shutdown_ref_.fetch_sub(1, std::memory_order_acq_rel) ==         kShutdownBit + 1) {+#ifdef GRPC_POSIX_SOCKET_TCP","This is going to be problematic on Posix-compatible platforms that aren't using an engine that implements the `PosixEndpointWithFdSupport` interface (we support this use case). We probably can't do RTTI since it might not be enabled everywhere, so we may want to invent some other means of detecting implementations at runtime. Let's brainstorm this a bit.",
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/31928,1084704828,2023-01-24T00:23:03Z,src/core/lib/iomgr/tcp_server_posix.cc,"@@ -105,6 +136,100 @@ static grpc_error_handle tcp_server_create(grpc_closure* shutdown_complete,   s->memory_quota = s->options.resource_quota->memory_quota();   s->pre_allocated_fd = -1;   gpr_atm_no_barrier_store(&s->next_pollset_to_assign, 0);+  s->n_bind_ports = 0;+  new (&s->listen_fd_to_index_map)+      absl::flat_hash_map<int, std::tuple<int, int>>();+  if (grpc_event_engine::experimental::UseEventEngineServer()) {+    PosixEventEngineWithFdSupport::PosixAcceptCallback accept_cb =",I'd suggest moving these 100 lines of code to their own EventEngine instantiation function.,X
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/31928,1084709040,2023-01-24T00:31:55Z,src/core/lib/iomgr/tcp_server_posix.cc,"@@ -105,6 +136,100 @@ static grpc_error_handle tcp_server_create(grpc_closure* shutdown_complete,   s->memory_quota = s->options.resource_quota->memory_quota();   s->pre_allocated_fd = -1;   gpr_atm_no_barrier_store(&s->next_pollset_to_assign, 0);+  s->n_bind_ports = 0;+  new (&s->listen_fd_to_index_map)+      absl::flat_hash_map<int, std::tuple<int, int>>();+  if (grpc_event_engine::experimental::UseEventEngineServer()) {+    PosixEventEngineWithFdSupport::PosixAcceptCallback accept_cb =+        [s](int listener_fd, std::unique_ptr<EventEngine::Endpoint> ep,+            bool is_external, MemoryAllocator /*allocator*/,+            SliceBuffer* pending_data) {+          grpc_core::ApplicationCallbackExecCtx app_ctx;+          grpc_core::ExecCtx exec_ctx;+          grpc_tcp_server_acceptor* acceptor =+              static_cast<grpc_tcp_server_acceptor*>(+                  gpr_malloc(sizeof(*acceptor)));+          acceptor->from_server = s;+          acceptor->port_index = -1;+          acceptor->fd_index = -1;+          if (!is_external) {+            auto it = s->listen_fd_to_index_map.find(listener_fd);+            if (it != s->listen_fd_to_index_map.end()) {+              acceptor->port_index = std::get<0>(it->second);+              acceptor->fd_index = std::get<1>(it->second);+            }+          } else {+            // External connection handling.+            grpc_resolved_address addr;+            memset(&addr, 0, sizeof(addr));+            addr.len = static_cast<socklen_t>(sizeof(struct sockaddr_storage));+            // Get the fd of the socket connected to peer.+            int fd = reinterpret_cast<grpc_event_engine::experimental::+                                          PosixEndpointWithFdSupport*>(ep.get())+                         ->GetWrappedFd();+            if (getpeername(fd, reinterpret_cast<struct sockaddr*>(addr.addr),+                            &(addr.len)) < 0) {+              gpr_log(GPR_ERROR, ""Failed getpeername: %s"",+                      grpc_core::StrError(errno).c_str());+              close(fd);+              return;+            }+            (void)grpc_set_socket_no_sigpipe_if_possible(fd);+            auto addr_uri = grpc_sockaddr_to_uri(&addr);+            if (!addr_uri.ok()) {+              gpr_log(GPR_ERROR, ""Invalid address: %s"",+                      addr_uri.status().ToString().c_str());+              return;+            }+            if (grpc_tcp_trace.enabled()) {+              gpr_log(GPR_INFO,+                      ""SERVER_CONNECT: incoming external connection: %s"",+                      addr_uri->c_str());+            }+          }+          grpc_pollset* read_notifier_pollset =+              (*(s->pollsets))[static_cast<size_t>(gpr_atm_no_barrier_fetch_add(+                                   &s->next_pollset_to_assign, 1)) %+                               s->pollsets->size()];+          acceptor->external_connection = is_external;+          acceptor->listener_fd = listener_fd;+          grpc_byte_buffer* buf = nullptr;+          if (pending_data != nullptr && pending_data->Length() > 0) {+            buf = grpc_raw_byte_buffer_create(nullptr, 0);+            grpc_slice_buffer_swap(&buf->data.raw.slice_buffer,+                                   pending_data->c_slice_buffer());+            pending_data->Clear();+          }+          acceptor->pending_data = buf;+          s->on_accept_cb(s->on_accept_cb_arg,+                          grpc_event_engine::experimental::+                              grpc_event_engine_endpoint_create(std::move(ep)),+                          read_notifier_pollset, acceptor);+        };+    auto on_shutdown_complete_cb =+        grpc_event_engine::experimental::GrpcClosureToStatusCallback(+            shutdown_complete);+    auto listener =+        reinterpret_cast<PosixEventEngineWithFdSupport*>(+            grpc_event_engine::experimental::GetDefaultEventEngine().get())","I do wonder if we'll see lifetime issues here, listeners outliving the default EventEngine instance, but we _shouldn't_ see it if this contract can be maintained in gRPC core.https://github.com/grpc/grpc/blob/1c4b138322bbe5f6091092013b318aece2d3a55a/include/grpc/event_engine/event_engine.h#L360-L367",
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/32127,1084720562,2023-01-24T00:48:36Z,test/core/event_engine/event_engine_test_utils.cc,"@@ -241,5 +217,29 @@ ConnectionManager::CreateConnection(std::string target_addr,   return absl::CancelledError(""Failed to create connection.""); } +// Returns a random message with bounded length.+std::string GetNextSendMessage() {","No, it was a merge artifact, we had both done similar changes here. I've moved it back up near the top.",
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/32127,1084721448,2023-01-24T00:50:40Z,test/core/event_engine/test_suite/tests/client_test.cc,"@@ -44,10 +44,18 @@ #include ""src/core/lib/iomgr/exec_ctx.h"" #include ""src/core/lib/resource_quota/memory_quota.h"" #include ""src/core/lib/resource_quota/resource_quota.h""-#include ""test/core/event_engine/test_suite/event_engine_test.h""-#include ""test/core/event_engine/test_suite/event_engine_test_utils.h""+#include ""test/core/event_engine/event_engine_test_utils.h""+#include ""test/core/event_engine/test_suite/event_engine_test_framework.h"" #include ""test/core/util/port.h"" +namespace grpc_event_engine {+namespace experimental {++void InitClientTests() {}","Nothing, unfortunately. This bit of code allows `fix_build_deps` to see a source file dependency between the custom test specifications and the test suite test implementations. They were previously only associated at link-time, which is fundamentally opposed to what `fix_build_deps` is trying to do. Without this hack, the tests themselves get removed from the test suite targets.",
5564114,Vignesh2208,https://api.github.com/repos/grpc/grpc/pulls/31928,1084814316,2023-01-24T04:54:14Z,src/core/lib/iomgr/tcp_server_posix.cc,"@@ -105,6 +136,100 @@ static grpc_error_handle tcp_server_create(grpc_closure* shutdown_complete,   s->memory_quota = s->options.resource_quota->memory_quota();   s->pre_allocated_fd = -1;   gpr_atm_no_barrier_store(&s->next_pollset_to_assign, 0);+  s->n_bind_ports = 0;+  new (&s->listen_fd_to_index_map)+      absl::flat_hash_map<int, std::tuple<int, int>>();+  if (grpc_event_engine::experimental::UseEventEngineServer()) {+    PosixEventEngineWithFdSupport::PosixAcceptCallback accept_cb =+        [s](int listener_fd, std::unique_ptr<EventEngine::Endpoint> ep,+            bool is_external, MemoryAllocator /*allocator*/,+            SliceBuffer* pending_data) {+          grpc_core::ApplicationCallbackExecCtx app_ctx;+          grpc_core::ExecCtx exec_ctx;+          grpc_tcp_server_acceptor* acceptor =+              static_cast<grpc_tcp_server_acceptor*>(+                  gpr_malloc(sizeof(*acceptor)));+          acceptor->from_server = s;+          acceptor->port_index = -1;+          acceptor->fd_index = -1;+          if (!is_external) {+            auto it = s->listen_fd_to_index_map.find(listener_fd);+            if (it != s->listen_fd_to_index_map.end()) {+              acceptor->port_index = std::get<0>(it->second);+              acceptor->fd_index = std::get<1>(it->second);+            }+          } else {+            // External connection handling.+            grpc_resolved_address addr;+            memset(&addr, 0, sizeof(addr));+            addr.len = static_cast<socklen_t>(sizeof(struct sockaddr_storage));+            // Get the fd of the socket connected to peer.+            int fd = reinterpret_cast<grpc_event_engine::experimental::+                                          PosixEndpointWithFdSupport*>(ep.get())+                         ->GetWrappedFd();+            if (getpeername(fd, reinterpret_cast<struct sockaddr*>(addr.addr),+                            &(addr.len)) < 0) {+              gpr_log(GPR_ERROR, ""Failed getpeername: %s"",+                      grpc_core::StrError(errno).c_str());+              close(fd);+              return;+            }+            (void)grpc_set_socket_no_sigpipe_if_possible(fd);+            auto addr_uri = grpc_sockaddr_to_uri(&addr);+            if (!addr_uri.ok()) {+              gpr_log(GPR_ERROR, ""Invalid address: %s"",+                      addr_uri.status().ToString().c_str());+              return;+            }+            if (grpc_tcp_trace.enabled()) {+              gpr_log(GPR_INFO,+                      ""SERVER_CONNECT: incoming external connection: %s"",+                      addr_uri->c_str());+            }+          }+          grpc_pollset* read_notifier_pollset =+              (*(s->pollsets))[static_cast<size_t>(gpr_atm_no_barrier_fetch_add(+                                   &s->next_pollset_to_assign, 1)) %+                               s->pollsets->size()];+          acceptor->external_connection = is_external;+          acceptor->listener_fd = listener_fd;+          grpc_byte_buffer* buf = nullptr;+          if (pending_data != nullptr && pending_data->Length() > 0) {+            buf = grpc_raw_byte_buffer_create(nullptr, 0);+            grpc_slice_buffer_swap(&buf->data.raw.slice_buffer,+                                   pending_data->c_slice_buffer());+            pending_data->Clear();+          }+          acceptor->pending_data = buf;+          s->on_accept_cb(s->on_accept_cb_arg,+                          grpc_event_engine::experimental::+                              grpc_event_engine_endpoint_create(std::move(ep)),+                          read_notifier_pollset, acceptor);+        };+    auto on_shutdown_complete_cb =+        grpc_event_engine::experimental::GrpcClosureToStatusCallback(+            shutdown_complete);+    auto listener =+        reinterpret_cast<PosixEventEngineWithFdSupport*>(+            grpc_event_engine::experimental::GetDefaultEventEngine().get())","I dont think this would be an issue with the default event engine at least. The listeners take a shared ptr to the event engine, so the event engine is alive as long as the listener is alive.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/31985,1085571788,2023-01-24T16:23:07Z,test/core/client_channel/lb_policy/xds_override_host_test.cc,"@@ -18,46 +18,57 @@  #include <array> #include <map>+#include <memory> #include <string>+#include <utility>+#include <vector>  #include ""absl/status/status.h""+#include ""absl/status/statusor.h"" #include ""absl/strings/string_view.h"" #include ""absl/types/span.h"" #include ""gtest/gtest.h""  #include <grpc/grpc.h>  #include ""src/core/ext/filters/stateful_session/stateful_session_filter.h""+#include ""src/core/ext/xds/xds_health_status.h"" #include ""src/core/lib/gprpp/orphanable.h"" #include ""src/core/lib/gprpp/ref_counted_ptr.h"" #include ""src/core/lib/gprpp/unique_type_name.h"" #include ""src/core/lib/json/json.h"" #include ""src/core/lib/load_balancing/lb_policy.h""+#include ""src/core/lib/resolver/server_address.h"" #include ""test/core/client_channel/lb_policy/lb_policy_test_lib.h"" #include ""test/core/util/test_config.h""  namespace grpc_core { namespace testing { namespace {+using AddressAttributes =",Looks like you inlined it but didn't remove this (now unused) type definition.,X
1644595,gnossen,https://api.github.com/repos/grpc/grpc/pulls/32183,1085676624,2023-01-24T17:43:32Z,examples/python/wait_for_ready/wait_for_ready_with_client_timeout_example_client.py,"@@ -0,0 +1,73 @@+# Copyright 2023 The gRPC Authors+#+# Licensed under the Apache License, Version 2.0 (the ""License"");+# you may not use this file except in compliance with the License.+# You may obtain a copy of the License at+#+#     http://www.apache.org/licenses/LICENSE-2.0+#+# Unless required by applicable law or agreed to in writing, software+# distributed under the License is distributed on an ""AS IS"" BASIS,+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+# See the License for the specific language governing permissions and+# limitations under the License.+""""""The Python client of utilizing wait-for-ready flag with client time out.""""""++import logging+import threading++import grpc++helloworld_pb2, helloworld_pb2_grpc = grpc.protos_and_services(+    ""helloworld.proto"")++_LOGGER = logging.getLogger(__name__)+_LOGGER.setLevel(logging.INFO)+++def wait_for_metadata(response_future, event):+    for key, value in response_future.initial_metadata():","I think it would make it more clear what's happening here if you pull the call to `initial_metadata()` onto another line  and save it off to a typed variable. Something like:```metadata: Sequence[Tuple[str, str]] = response_future.initial_metadata()```The way this is currently written, it looks like `initial_metadata` might actual be a streaming method.",X
1644595,gnossen,https://api.github.com/repos/grpc/grpc/pulls/32183,1085678701,2023-01-24T17:45:23Z,examples/python/wait_for_ready/wait_for_ready_with_client_timeout_example_client.py,"@@ -0,0 +1,73 @@+# Copyright 2023 The gRPC Authors+#+# Licensed under the Apache License, Version 2.0 (the ""License"");+# you may not use this file except in compliance with the License.+# You may obtain a copy of the License at+#+#     http://www.apache.org/licenses/LICENSE-2.0+#+# Unless required by applicable law or agreed to in writing, software+# distributed under the License is distributed on an ""AS IS"" BASIS,+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+# See the License for the specific language governing permissions and+# limitations under the License.+""""""The Python client of utilizing wait-for-ready flag with client time out.""""""++import logging+import threading++import grpc++helloworld_pb2, helloworld_pb2_grpc = grpc.protos_and_services(+    ""helloworld.proto"")++_LOGGER = logging.getLogger(__name__)+_LOGGER.setLevel(logging.INFO)+++def wait_for_metadata(response_future, event):+    for key, value in response_future.initial_metadata():+        print('Greeter client received initial metadata: key=%s value=%s' %+              (key, value))+    event.set()+++def check_status(response_future, wait_success):+    if wait_success:+        print(""received initial metadata before time out!"")+        for response in response_future:+            message = response.message+        print(""Greeter client received: "" + message)+    else:+        print(""Timed out before receiving any initial metadata!"")+        response_future.cancel()+++def main():+    # Create gRPC channel+    with grpc.insecure_channel('localhost:50051') as channel:+        stub = helloworld_pb2_grpc.GreeterStub(channel)++        event_for_delay = threading.Event()++        # Server will delay send initial metadata back for this RPC+        response_future_delay = stub.SayHelloStreamReply(+            helloworld_pb2.HelloRequest(name='you'), wait_for_ready=True)++        # Fire RPC and wait for metadata+        thread_with_delay = threading.Thread(target=wait_for_metadata,+                                             args=(response_future_delay,+                                                   event_for_delay))+        thread_with_delay.start()++        # Wait on client side with timeout+        timeout = 3+        check_status(response_future_delay, event_for_delay.wait(timeout))++        # Expected to timeout.+        thread_with_delay.join()",Does the process successfully exit if the server never returns initial metadata?,
1644595,gnossen,https://api.github.com/repos/grpc/grpc/pulls/32183,1085684945,2023-01-24T17:50:44Z,examples/python/wait_for_ready/wait_for_ready_with_client_timeout_example_server.py,"@@ -0,0 +1,54 @@+# Copyright 2023 The gRPC Authors+#+# Licensed under the Apache License, Version 2.0 (the ""License"");+# you may not use this file except in compliance with the License.+# You may obtain a copy of the License at+#+#     http://www.apache.org/licenses/LICENSE-2.0+#+# Unless required by applicable law or agreed to in writing, software+# distributed under the License is distributed on an ""AS IS"" BASIS,+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+# See the License for the specific language governing permissions and+# limitations under the License.+""""""The Python serer of utilizing wait-for-ready flag with client time out.""""""++from concurrent import futures+import logging+from time import sleep++import grpc++helloworld_pb2, helloworld_pb2_grpc = grpc.protos_and_services(+    ""helloworld.proto"")++_INITIAL_METADATA = ((b'initial-md', 'initial-md-value'),)+++class Greeter(helloworld_pb2_grpc.GreeterServicer):++    def SayHelloStreamReply(self, request, servicer_context):+        # Send initial metadata back to indicate server is ready and running.+        print(""sleeping 5s before sending metadata back"")+        sleep(5)",This sleep should come _after_ we send initial metadata. The point of this example is to use the initial metadata as an indication that the request has been received and being processed.,
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/31448,1085722481,2023-01-24T18:23:27Z,src/core/lib/promise/interceptor_list.h,"@@ -0,0 +1,275 @@+// Copyright 2022 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++#ifndef GRPC_SRC_CORE_LIB_PROMISE_INTERCEPTOR_LIST_H+#define GRPC_SRC_CORE_LIB_PROMISE_INTERCEPTOR_LIST_H++#include <grpc/support/port_platform.h>++#include <stddef.h>++#include <algorithm>+#include <new>+#include <string>+#include <utility>++#include ""absl/strings/str_cat.h""+#include ""absl/strings/str_format.h""+#include ""absl/types/optional.h""+#include ""absl/types/variant.h""++#include <grpc/support/log.h>++#include ""src/core/lib/debug/trace.h""+#include ""src/core/lib/gprpp/construct_destruct.h""+#include ""src/core/lib/gprpp/debug_location.h""+#include ""src/core/lib/promise/context.h""+#include ""src/core/lib/promise/detail/promise_factory.h""+#include ""src/core/lib/promise/poll.h""+#include ""src/core/lib/promise/trace.h""+#include ""src/core/lib/resource_quota/arena.h""++namespace grpc_core {++template <typename T>+class InterceptorList {","Please document the overall class, nested classes, methods, etc.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/31448,1085735330,2023-01-24T18:34:03Z,src/core/lib/promise/interceptor_list.h,"@@ -0,0 +1,275 @@+// Copyright 2022 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++#ifndef GRPC_SRC_CORE_LIB_PROMISE_INTERCEPTOR_LIST_H+#define GRPC_SRC_CORE_LIB_PROMISE_INTERCEPTOR_LIST_H++#include <grpc/support/port_platform.h>++#include <stddef.h>++#include <algorithm>+#include <new>+#include <string>+#include <utility>++#include ""absl/strings/str_cat.h""+#include ""absl/strings/str_format.h""+#include ""absl/types/optional.h""+#include ""absl/types/variant.h""++#include <grpc/support/log.h>++#include ""src/core/lib/debug/trace.h""+#include ""src/core/lib/gprpp/construct_destruct.h""+#include ""src/core/lib/gprpp/debug_location.h""+#include ""src/core/lib/promise/context.h""+#include ""src/core/lib/promise/detail/promise_factory.h""+#include ""src/core/lib/promise/poll.h""+#include ""src/core/lib/promise/trace.h""+#include ""src/core/lib/resource_quota/arena.h""++namespace grpc_core {++template <typename T>+class InterceptorList {+ public:+  class MapFactory {+   public:+    explicit MapFactory(DebugLocation from) : from_(from) {}+    virtual void MakePromise(T x, void* memory) = 0;+    virtual void Destroy(void* memory) = 0;+    virtual Poll<absl::optional<T>> PollOnce(void* memory) = 0;+    virtual ~MapFactory() = default;++    void SetNext(MapFactory* next) {+      GPR_DEBUG_ASSERT(next_ == nullptr);+      next_ = next;+    }++    DebugLocation from() { return from_; }++    MapFactory* next() const { return next_; }++   private:+    GPR_NO_UNIQUE_ADDRESS const DebugLocation from_;+    MapFactory* next_ = nullptr;+  };++  class RunPromise {+   public:+    RunPromise(size_t memory_required, MapFactory* factory,+               absl::optional<T> value) {+      if (!value.has_value() || factory == nullptr) {+        is_running_ = false;+        Construct(&result_, std::move(value));+      } else {+        is_running_ = true;+        Construct(&running_, memory_required);+        factory->MakePromise(std::move(*value), running_.space.get());+        running_.current_factory = factory;+      }+    }++    ~RunPromise() {+      if (is_running_) {+        if (running_.current_factory != nullptr) {+          running_.current_factory->Destroy(running_.space.get());+        }+        Destruct(&running_);+      } else {+        Destruct(&result_);+      }+    }++    RunPromise(const RunPromise&) = delete;+    RunPromise& operator=(const RunPromise&) = delete;++    RunPromise(RunPromise&& other) noexcept : is_running_(other.is_running_) {+      if (is_running_) {+        Construct(&running_, std::move(other.running_));+      } else {+        Construct(&result_, std::move(other.result_));+      }+    }++    RunPromise& operator=(RunPromise&& other) noexcept = delete;++    Poll<absl::optional<T>> operator()() {+      if (grpc_trace_promise_primitives.enabled()) {+        gpr_log(GPR_DEBUG, ""InterceptorList::RunPromise: %s"",+                DebugString().c_str());+      }+      while (is_running_) {+        auto r = running_.current_factory->PollOnce(running_.space.get());+        if (auto* p = absl::get_if<kPollReadyIdx>(&r)) {+          running_.current_factory->Destroy(running_.space.get());+          running_.current_factory = running_.current_factory->next();+          if (running_.current_factory == nullptr || !p->has_value()) {+            return std::move(*p);+          }+          running_.current_factory->MakePromise(std::move(**p),+                                                running_.space.get());+          continue;+        }+        return Pending{};+      }+      return std::move(result_);+    }++   private:+    std::string DebugString() const {+      if (is_running_) {+        return absl::StrCat(+            ""Running:"", running_.current_factory == nullptr+                            ? ""END""+                            : ([p = running_.current_factory->from()]() {+                                return absl::StrCat(p.file(), "":"", p.line());+                              })()+                                  .c_str());+      } else {+        return absl::StrFormat(""Result:has_value:%d"", result_.has_value());+      }+    }+    struct Running {+      explicit Running(size_t max_size)+          : space(GetContext<Arena>()->MakePooledArray<char>(max_size)) {}+      Running(const Running&) = delete;+      Running& operator=(const Running&) = delete;+      Running(Running&& other) noexcept+          : current_factory(std::exchange(other.current_factory, nullptr)),+            space(std::move(other.space)) {}+      MapFactory* current_factory;+      Arena::PoolPtr<char[]> space;+    };+    union {+      Running running_;+      absl::optional<T> result_;+    };+    bool is_running_;",Suggest inverting the meaning of this and renaming it to something like `need_to_run_`.,X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/31448,1085796160,2023-01-24T19:14:04Z,test/core/end2end/tests/max_message_length.cc,"@@ -596,7 +596,7 @@ static void test_max_receive_message_length_on_compressed_request(                                 nullptr);   GPR_ASSERT(GRPC_CALL_OK == error); -  cqv.Expect(tag(102), false);+  cqv.Expect(tag(102), true);","Are we sure this behavior is correct?  If the message is too large, it seems like the batch should fail.",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/31448,1085913183,2023-01-24T20:55:50Z,src/core/lib/surface/call.cc,"@@ -2893,26 +3069,353 @@ void ClientPromiseBasedCall::PublishStatus(                        PendingOp::kReceiveStatusOnClient); } -void ClientPromiseBasedCall::PublishMetadataArray(grpc_metadata_array* array,-                                                  ServerMetadata* md) {-  const auto md_count = md->count();-  if (md_count > array->capacity) {-    array->capacity =-        std::max(array->capacity + md->count(), array->capacity * 3 / 2);-    array->metadata = static_cast<grpc_metadata*>(-        gpr_realloc(array->metadata, sizeof(grpc_metadata) * array->capacity));+///////////////////////////////////////////////////////////////////////////////+// ServerPromiseBasedCall++class ServerPromiseBasedCall final : public PromiseBasedCall {+ public:+  ServerPromiseBasedCall(Arena* arena, grpc_call_create_args* args);++  void CancelWithErrorLocked(grpc_error_handle) override { abort(); }+  grpc_call_error StartBatch(const grpc_op* ops, size_t nops, void* notify_tag,+                             bool is_notify_tag_closure) override;+  bool failed_before_recv_message() const override { abort(); }+  bool is_trailers_only() const override { abort(); }+  absl::string_view GetServerAuthority() const override { abort(); }++  void UpdateOnce() ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu()) override;+  Poll<ServerMetadataHandle> PollTopOfCall()+      ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu());++  std::string DebugTag() const override {+    return absl::StrFormat(""SERVER_CALL[%p]: "", this);   }-  PublishToAppEncoder encoder(array);-  md->Encode(&encoder);++  ServerCallContext* server_call_context() override { return &call_context_; }++ private:+  struct Uninitialized {};++  class RecvCloseState {+   public:+    // Request that receiver be filled in per grpc_op_recv_close_on_server.+    // Returns true if the request can be fulfilled immediately.+    // Returns false if the request will be fulfilled later.+    bool RequestReceiveCloseOnServer(int* receiver) {+      switch (state_) {+        case kUnset:+          state_ = reinterpret_cast<uintptr_t>(receiver);+          return false;+        case kFinishedWithFailure:+          *receiver = 1;+          return true;+        case kFinishedWithSuccess:+          *receiver = 0;+          return true;+        default:+          abort();  // unreachable+      }+    }++    // Mark the call as having completed.+    // Returns true if this finishes a previous RequestReceiveCloseOnServer.+    bool CompleteCall(bool success) {+      switch (state_) {+        case kUnset:+          state_ = success ? kFinishedWithSuccess : kFinishedWithFailure;+          return false;+        case kFinishedWithFailure:+        case kFinishedWithSuccess:+          abort();  // unreachable+        default:+          *reinterpret_cast<int*>(state_) = success ? 0 : 1;+          state_ = success ? kFinishedWithSuccess : kFinishedWithFailure;+          return true;+      }+    }++    std::string ToString() const {+      switch (state_) {+        case kUnset:+          return ""Unset"";+        case kFinishedWithFailure:+          return ""FinishedWithFailure"";+        case kFinishedWithSuccess:+          return ""FinishedWithSuccess"";+        default:+          return absl::StrFormat(""WaitingForReceiver(%p)"",+                                 reinterpret_cast<void*>(state_));+      }+    }++   private:+    static constexpr uintptr_t kUnset = 0;+    static constexpr uintptr_t kFinishedWithFailure = 1;+    static constexpr uintptr_t kFinishedWithSuccess = 2;+    // Holds one of kUnset, kFinishedWithFailure, or kFinishedWithSuccess+    // OR an int* that wants to receive the final status.+    uintptr_t state_ = kUnset;+  };++  grpc_call_error ValidateBatch(const grpc_op* ops, size_t nops) const;+  void CommitBatch(const grpc_op* ops, size_t nops,+                   const Completion& completion)+      ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu());++  friend class ServerCallContext;+  ServerCallContext call_context_;+  Server* const server_;+  ArenaPromise<ServerMetadataHandle> promise_ ABSL_GUARDED_BY(mu());+  PipeSender<MessageHandle>* server_to_client_messages_ ABSL_GUARDED_BY(mu()) =+      nullptr;+  PipeReceiver<MessageHandle>* client_to_server_messages_+      ABSL_GUARDED_BY(mu()) = nullptr;+  using SendInitialMetadataState =+      absl::variant<Uninitialized, PipeSender<ServerMetadataHandle>*,+                    typename PipeSender<ServerMetadataHandle>::PushType>;+  SendInitialMetadataState send_initial_metadata_state_ ABSL_GUARDED_BY(mu()) =+      Uninitialized{};+  ServerMetadataHandle send_trailing_metadata_ ABSL_GUARDED_BY(mu());+  grpc_compression_algorithm incoming_compression_algorithm_+      ABSL_GUARDED_BY(mu());+  RecvCloseState recv_close_state_ ABSL_GUARDED_BY(mu());+  Completion recv_close_completion_ ABSL_GUARDED_BY(mu());+  Completion send_status_from_server_completion_ ABSL_GUARDED_BY(mu());+  ClientMetadataHandle client_initial_metadata_ ABSL_GUARDED_BY(mu());+};++ArenaPromise<ServerMetadataHandle> ServerCallContext::CompletePromise(",gave it a longer but more consistent name,X
24593237,XuanWang-Amos,https://api.github.com/repos/grpc/grpc/pulls/32183,1085944466,2023-01-24T21:27:36Z,examples/python/wait_for_ready/wait_for_ready_with_client_timeout_example_server.py,"@@ -0,0 +1,54 @@+# Copyright 2023 The gRPC Authors+#+# Licensed under the Apache License, Version 2.0 (the ""License"");+# you may not use this file except in compliance with the License.+# You may obtain a copy of the License at+#+#     http://www.apache.org/licenses/LICENSE-2.0+#+# Unless required by applicable law or agreed to in writing, software+# distributed under the License is distributed on an ""AS IS"" BASIS,+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+# See the License for the specific language governing permissions and+# limitations under the License.+""""""The Python serer of utilizing wait-for-ready flag with client time out.""""""++from concurrent import futures+import logging+from time import sleep++import grpc++helloworld_pb2, helloworld_pb2_grpc = grpc.protos_and_services(+    ""helloworld.proto"")++_INITIAL_METADATA = ((b'initial-md', 'initial-md-value'),)+++class Greeter(helloworld_pb2_grpc.GreeterServicer):++    def SayHelloStreamReply(self, request, servicer_context):+        # Send initial metadata back to indicate server is ready and running.+        print(""sleeping 5s before sending metadata back"")+        sleep(5)","We can add sleep at both places, the sleep before send initial_metadata means server is starting up, and client should cancel RPC if server didn't finish starting up before client timeout, I'll add some comments too.",
2793282,veblush,https://api.github.com/repos/grpc/grpc/pulls/32190,1086013514,2023-01-24T22:37:41Z,src/compiler/cpp_generator.cc,"@@ -54,6 +54,16 @@ std::string FilenameIdentifier(const std::string& filename) {   }   return result; }++std::string EscapeVariableDelimiters(std::string&& mut_str) {+  size_t index = 0;",I feel like we should be careful on adding more dependency to `grpc_plugin_support`.,
85715732,yousukseung,https://api.github.com/repos/grpc/grpc/pulls/32106,1086061873,2023-01-24T23:59:50Z,include/grpcpp/ext/orca_service.h,"@@ -48,38 +49,16 @@ class OrcaService : public Service {     }   }; -  explicit OrcaService(Options options);--  // Sets or removes the CPU utilization value to be reported to clients.-  void SetCpuUtilization(double cpu_utilization);-  void DeleteCpuUtilization();--  // Sets of removes the memory utilization value to be reported to clients.-  void SetMemoryUtilization(double memory_utilization);-  void DeleteMemoryUtilization();--  // Sets of removes the QPS value to be reported to clients.-  void SetQps(double qps);-  void DeleteQps();--  // Sets or removed named utilization values to be reported to clients.-  void SetNamedUtilization(std::string name, double utilization);-  void DeleteNamedUtilization(const std::string& name);-  void SetAllNamedUtilization(std::map<std::string, double> named_utilization);+  OrcaService(const ServerMetricRecorder& server_metric_recorder,+              Options options);   private:   class Reactor; -  Slice GetOrCreateSerializedResponse();+  Slice CreateSerializedResponse(); +  const ServerMetricRecorder& server_metric_recorder_;   const absl::Duration min_report_duration_;--  grpc::internal::Mutex mu_;-  double cpu_utilization_ ABSL_GUARDED_BY(&mu_) = -1;-  double memory_utilization_ ABSL_GUARDED_BY(&mu_) = -1;-  double qps_ ABSL_GUARDED_BY(&mu_) = -1;-  std::map<std::string, double> named_utilization_ ABSL_GUARDED_BY(&mu_);-  absl::optional<Slice> response_slice_ ABSL_GUARDED_BY(&mu_);","Updated, PTAL.I introduced an atomic monotonically increasing counter. It guarantees that the caller can reuse the result if the sequence number is identical but not the inverse i.e. dup serialization with data race. I think this is fine while allowing us to keep atomic for root-level metrics but lmk.",
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/32077,1086147970,2023-01-25T02:28:16Z,src/core/lib/event_engine/cf_engine/cf_engine.cc,"@@ -72,14 +76,30 @@ CFEventEngine::CreateListener( }  CFEventEngine::ConnectionHandle CFEventEngine::Connect(-    OnConnectCallback /* on_connect */, const ResolvedAddress& /* addr */,-    const EndpointConfig& /* args */, MemoryAllocator /* memory_allocator */,-    Duration /* timeout */) {-  grpc_core::Crash(""unimplemented"");+    OnConnectCallback on_connect, const ResolvedAddress& addr,+    const EndpointConfig& /* args */, MemoryAllocator memory_allocator,+    Duration timeout) {+  auto addr_uri = ResolvedAddressToURI(addr);+  gpr_log(GPR_INFO, ""CFEventEngine::connect: %s"", addr_uri.value().c_str());","Do you use trace flags on iOS? In the core library, we would set an environment variable like `GRPC_TRACE=ios` when we wanted verbose logging, and guard logging lines like this behind it. If that's available to you, that could cut down on log spam. Example: https://github.com/grpc/grpc/blob/fa5a6c42a6b386428239f5d9634d07486f3331ea/src/core/lib/event_engine/posix_engine/posix_engine.cc#L414-L422",
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/32077,1086151779,2023-01-25T02:36:03Z,src/core/lib/event_engine/cf_engine/cfstream_endpoint.cc,"@@ -0,0 +1,294 @@+// Copyright 2022 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++#include <grpc/support/port_platform.h>++#ifdef GPR_APPLE++#include ""src/core/lib/event_engine/cf_engine/cfstream_endpoint.h""+#include ""src/core/lib/gprpp/strerror.h""++namespace grpc_event_engine {+namespace experimental {++namespace {++absl::Status CFErrorToStatus(CFTypeUniqueRef<CFErrorRef> cf_error) {+  CFErrorDomain cf_domain = CFErrorGetDomain((cf_error));+  CFIndex code = CFErrorGetCode((cf_error));+  CFTypeUniqueRef<CFStringRef> cf_desc = CFErrorCopyDescription((cf_error));+  char domain_buf[256];+  char desc_buf[256];+  CFStringGetCString(cf_domain, domain_buf, 256, kCFStringEncodingUTF8);+  CFStringGetCString(cf_desc, desc_buf, 256, kCFStringEncodingUTF8);+  return absl::Status(absl::StatusCode::kInternal,","nit: I'd suggest maybe defaulting to `absl::StatusCode::Unknown`, since internal errors are usually meant to convey serious system-level problems. See the error definitions here: https://github.com/abseil/abseil-cpp/blob/b0a2b10bb125a90b35727be67b972f4e5b89283b/absl/status/status.h#L231-L236It may not matter much on iOS, but it can sometimes be a significant difference in core.",
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/32077,1086153274,2023-01-25T02:40:09Z,src/core/lib/event_engine/cf_engine/cfstream_endpoint.cc,"@@ -0,0 +1,294 @@+// Copyright 2022 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++#include <grpc/support/port_platform.h>++#ifdef GPR_APPLE++#include ""src/core/lib/event_engine/cf_engine/cfstream_endpoint.h""+#include ""src/core/lib/gprpp/strerror.h""++namespace grpc_event_engine {+namespace experimental {++namespace {++absl::Status CFErrorToStatus(CFTypeUniqueRef<CFErrorRef> cf_error) {+  CFErrorDomain cf_domain = CFErrorGetDomain((cf_error));+  CFIndex code = CFErrorGetCode((cf_error));+  CFTypeUniqueRef<CFStringRef> cf_desc = CFErrorCopyDescription((cf_error));+  char domain_buf[256];+  char desc_buf[256];+  CFStringGetCString(cf_domain, domain_buf, 256, kCFStringEncodingUTF8);+  CFStringGetCString(cf_desc, desc_buf, 256, kCFStringEncodingUTF8);+  return absl::Status(absl::StatusCode::kInternal,+                      absl::StrFormat(""(domain:%s, code:%ld, description:%s)"",+                                      domain_buf, code, desc_buf));+}++absl::StatusOr<EventEngine::ResolvedAddress> CFReadStreamLocallAddress(+    CFReadStreamRef stream) {+  CFTypeUniqueRef<CFDataRef> cf_native_handle = static_cast<CFDataRef>(+      CFReadStreamCopyProperty(stream, kCFStreamPropertySocketNativeHandle));+  CFSocketNativeHandle socket;+  CFDataGetBytes(cf_native_handle, CFRangeMake(0, sizeof(CFSocketNativeHandle)),+                 (UInt8*)&socket);+  EventEngine::ResolvedAddress addr;+  socklen_t len = EventEngine::ResolvedAddress::MAX_SIZE_BYTES;+  if (getsockname(socket, const_cast<sockaddr*>(addr.address()), &len) < 0) {+    return absl::InternalError(+        absl::StrCat(""getsockname:"", grpc_core::StrError(errno)));+  }+  return EventEngine::ResolvedAddress(addr.address(), len);+}++}  // namespace++void CFStreamEndpoint::Connect(EventEngine::OnConnectCallback on_connect,+                               EventEngine::ResolvedAddress addr,+                               EventEngine::Duration timeout) {+  peer_address_ = std::move(addr);+  std::string host_port =+      grpc_sockaddr_to_string(reinterpret_cast<const grpc_resolved_address*>(","There are a family of similar methods that work with EventEngine::ResolvedAddress types already. Here instead, you can use this: https://github.com/grpc/grpc/blob/fa5a6c42a6b386428239f5d9634d07486f3331ea/src/core/lib/event_engine/tcp_socket_utils.h#L71-L76",
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/32077,1086160713,2023-01-25T02:53:00Z,src/core/lib/event_engine/cf_engine/cfstream_endpoint.cc,"@@ -0,0 +1,294 @@+// Copyright 2022 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++#include <grpc/support/port_platform.h>++#ifdef GPR_APPLE++#include ""src/core/lib/event_engine/cf_engine/cfstream_endpoint.h""+#include ""src/core/lib/gprpp/strerror.h""++namespace grpc_event_engine {+namespace experimental {++namespace {++absl::Status CFErrorToStatus(CFTypeUniqueRef<CFErrorRef> cf_error) {+  CFErrorDomain cf_domain = CFErrorGetDomain((cf_error));+  CFIndex code = CFErrorGetCode((cf_error));+  CFTypeUniqueRef<CFStringRef> cf_desc = CFErrorCopyDescription((cf_error));+  char domain_buf[256];+  char desc_buf[256];+  CFStringGetCString(cf_domain, domain_buf, 256, kCFStringEncodingUTF8);+  CFStringGetCString(cf_desc, desc_buf, 256, kCFStringEncodingUTF8);+  return absl::Status(absl::StatusCode::kInternal,+                      absl::StrFormat(""(domain:%s, code:%ld, description:%s)"",+                                      domain_buf, code, desc_buf));+}++absl::StatusOr<EventEngine::ResolvedAddress> CFReadStreamLocallAddress(+    CFReadStreamRef stream) {+  CFTypeUniqueRef<CFDataRef> cf_native_handle = static_cast<CFDataRef>(+      CFReadStreamCopyProperty(stream, kCFStreamPropertySocketNativeHandle));+  CFSocketNativeHandle socket;+  CFDataGetBytes(cf_native_handle, CFRangeMake(0, sizeof(CFSocketNativeHandle)),+                 (UInt8*)&socket);+  EventEngine::ResolvedAddress addr;+  socklen_t len = EventEngine::ResolvedAddress::MAX_SIZE_BYTES;+  if (getsockname(socket, const_cast<sockaddr*>(addr.address()), &len) < 0) {+    return absl::InternalError(+        absl::StrCat(""getsockname:"", grpc_core::StrError(errno)));+  }+  return EventEngine::ResolvedAddress(addr.address(), len);+}++}  // namespace++void CFStreamEndpoint::Connect(EventEngine::OnConnectCallback on_connect,+                               EventEngine::ResolvedAddress addr,+                               EventEngine::Duration timeout) {+  peer_address_ = std::move(addr);+  std::string host_port =+      grpc_sockaddr_to_string(reinterpret_cast<const grpc_resolved_address*>(+                                  peer_address_.address()),+                              true)+          .value();+  gpr_log(GPR_INFO, ""CFStreamClient::connect, host_port: %s"",+          host_port.c_str());+  std::string host_string;+  std::string port_string;+  grpc_core::SplitHostPort(host_port, &host_string, &port_string);+  CFStringRef host = CFStringCreateWithCString(NULL, host_string.c_str(),+                                               kCFStringEncodingUTF8);+  int port = ResolvedAddressGetPort(peer_address_);+  CFStreamCreatePairWithSocketToHost(NULL, host, port, &cf_read_stream_,+                                     &cf_write_stream_);++  CFStreamClientContext cf_context = {0, static_cast<void*>(this), nullptr,+                                      nullptr, nullptr};+  CFReadStreamSetClient(+      cf_read_stream_,+      kCFStreamEventOpenCompleted | kCFStreamEventHasBytesAvailable |+          kCFStreamEventErrorOccurred | kCFStreamEventEndEncountered,+      ReadCallback, &cf_context);+  CFWriteStreamSetClient(+      cf_write_stream_,+      kCFStreamEventOpenCompleted | kCFStreamEventCanAcceptBytes |+          kCFStreamEventErrorOccurred | kCFStreamEventEndEncountered,+      WriteCallback, &cf_context);+  CFReadStreamSetDispatchQueue(cf_read_stream_,+                               dispatch_get_global_queue(QOS_CLASS_DEFAULT, 0));+  CFWriteStreamSetDispatchQueue(+      cf_write_stream_, dispatch_get_global_queue(QOS_CLASS_DEFAULT, 0));++  if (!CFReadStreamOpen(cf_read_stream_)) {+    auto status = CFErrorToStatus(CFReadStreamCopyError(cf_read_stream_));+    on_connect(std::move(status));+    delete this;+    return;+  }++  if (!CFWriteStreamOpen(cf_write_stream_)) {+    auto status = CFErrorToStatus(CFWriteStreamCopyError(cf_write_stream_));+    on_connect(std::move(status));+    delete this;+    return;+  }++  auto connect_timeout_timer = engine_->RunAfter(timeout, [this]() {+    open_event_.SetShutdown(absl::DeadlineExceededError(""Connect timed out""));+  });++  open_event_.NotifyOn(new PosixEngineClosure(+      [this, on_connect = std::move(on_connect),+       connect_timeout_timer](absl::Status status) mutable {+        engine_->Cancel(connect_timeout_timer);++        if (!status.ok()) {+          on_connect(std::move(status));+          delete this;+          return;+        }++        auto status_or_local_addr = CFReadStreamLocallAddress(cf_read_stream_);","nit: suggest naming this `local_addr`, per some best practices. See https://abseil.io/tips/181",X
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/32077,1086164515,2023-01-25T03:02:53Z,src/core/lib/event_engine/cf_engine/cfstream_endpoint.cc,"@@ -0,0 +1,294 @@+// Copyright 2022 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++#include <grpc/support/port_platform.h>++#ifdef GPR_APPLE++#include ""src/core/lib/event_engine/cf_engine/cfstream_endpoint.h""+#include ""src/core/lib/gprpp/strerror.h""++namespace grpc_event_engine {+namespace experimental {++namespace {++absl::Status CFErrorToStatus(CFTypeUniqueRef<CFErrorRef> cf_error) {+  CFErrorDomain cf_domain = CFErrorGetDomain((cf_error));+  CFIndex code = CFErrorGetCode((cf_error));+  CFTypeUniqueRef<CFStringRef> cf_desc = CFErrorCopyDescription((cf_error));+  char domain_buf[256];+  char desc_buf[256];+  CFStringGetCString(cf_domain, domain_buf, 256, kCFStringEncodingUTF8);+  CFStringGetCString(cf_desc, desc_buf, 256, kCFStringEncodingUTF8);+  return absl::Status(absl::StatusCode::kInternal,+                      absl::StrFormat(""(domain:%s, code:%ld, description:%s)"",+                                      domain_buf, code, desc_buf));+}++absl::StatusOr<EventEngine::ResolvedAddress> CFReadStreamLocallAddress(+    CFReadStreamRef stream) {+  CFTypeUniqueRef<CFDataRef> cf_native_handle = static_cast<CFDataRef>(+      CFReadStreamCopyProperty(stream, kCFStreamPropertySocketNativeHandle));+  CFSocketNativeHandle socket;+  CFDataGetBytes(cf_native_handle, CFRangeMake(0, sizeof(CFSocketNativeHandle)),+                 (UInt8*)&socket);+  EventEngine::ResolvedAddress addr;+  socklen_t len = EventEngine::ResolvedAddress::MAX_SIZE_BYTES;+  if (getsockname(socket, const_cast<sockaddr*>(addr.address()), &len) < 0) {+    return absl::InternalError(+        absl::StrCat(""getsockname:"", grpc_core::StrError(errno)));+  }+  return EventEngine::ResolvedAddress(addr.address(), len);+}++}  // namespace++void CFStreamEndpoint::Connect(EventEngine::OnConnectCallback on_connect,+                               EventEngine::ResolvedAddress addr,+                               EventEngine::Duration timeout) {+  peer_address_ = std::move(addr);+  std::string host_port =+      grpc_sockaddr_to_string(reinterpret_cast<const grpc_resolved_address*>(+                                  peer_address_.address()),+                              true)+          .value();+  gpr_log(GPR_INFO, ""CFStreamClient::connect, host_port: %s"",+          host_port.c_str());+  std::string host_string;+  std::string port_string;+  grpc_core::SplitHostPort(host_port, &host_string, &port_string);+  CFStringRef host = CFStringCreateWithCString(NULL, host_string.c_str(),+                                               kCFStringEncodingUTF8);+  int port = ResolvedAddressGetPort(peer_address_);+  CFStreamCreatePairWithSocketToHost(NULL, host, port, &cf_read_stream_,+                                     &cf_write_stream_);++  CFStreamClientContext cf_context = {0, static_cast<void*>(this), nullptr,+                                      nullptr, nullptr};+  CFReadStreamSetClient(+      cf_read_stream_,+      kCFStreamEventOpenCompleted | kCFStreamEventHasBytesAvailable |+          kCFStreamEventErrorOccurred | kCFStreamEventEndEncountered,+      ReadCallback, &cf_context);+  CFWriteStreamSetClient(+      cf_write_stream_,+      kCFStreamEventOpenCompleted | kCFStreamEventCanAcceptBytes |+          kCFStreamEventErrorOccurred | kCFStreamEventEndEncountered,+      WriteCallback, &cf_context);+  CFReadStreamSetDispatchQueue(cf_read_stream_,+                               dispatch_get_global_queue(QOS_CLASS_DEFAULT, 0));+  CFWriteStreamSetDispatchQueue(+      cf_write_stream_, dispatch_get_global_queue(QOS_CLASS_DEFAULT, 0));++  if (!CFReadStreamOpen(cf_read_stream_)) {+    auto status = CFErrorToStatus(CFReadStreamCopyError(cf_read_stream_));+    on_connect(std::move(status));+    delete this;+    return;+  }++  if (!CFWriteStreamOpen(cf_write_stream_)) {+    auto status = CFErrorToStatus(CFWriteStreamCopyError(cf_write_stream_));+    on_connect(std::move(status));+    delete this;+    return;+  }++  auto connect_timeout_timer = engine_->RunAfter(timeout, [this]() {+    open_event_.SetShutdown(absl::DeadlineExceededError(""Connect timed out""));+  });++  open_event_.NotifyOn(new PosixEngineClosure(+      [this, on_connect = std::move(on_connect),+       connect_timeout_timer](absl::Status status) mutable {+        engine_->Cancel(connect_timeout_timer);++        if (!status.ok()) {+          on_connect(std::move(status));+          delete this;+          return;+        }++        auto status_or_local_addr = CFReadStreamLocallAddress(cf_read_stream_);+        if (!status_or_local_addr.ok()) {+          on_connect(std::move(status_or_local_addr).status());+          delete this;+          return;+        }++        local_address_ = status_or_local_addr.value();+        on_connect(std::unique_ptr<EventEngine::Endpoint>(this));+      },+      false /* is_permanent */));+}++/* static */ void CFStreamEndpoint::ReadCallback(CFReadStreamRef stream,+                                                 CFStreamEventType type,+                                                 void* client_callback_info) {+  auto self = static_cast<CFStreamEndpoint*>(client_callback_info);++  switch (type) {+    case kCFStreamEventOpenCompleted:+      break;+    case kCFStreamEventHasBytesAvailable:+    case kCFStreamEventEndEncountered:+      self->read_event_.SetReady();+      break;+    case kCFStreamEventErrorOccurred: {+      auto status = CFErrorToStatus(CFReadStreamCopyError(stream));+      gpr_log(GPR_ERROR, ""CFStream Read error: %s"", status.ToString().c_str());+      self->open_event_.SetShutdown(status);+      self->read_event_.SetShutdown(status);+      self->write_event_.SetShutdown(status);+    } break;+    default:+      GPR_UNREACHABLE_CODE(return);+  }+}++/* static */+void CFStreamEndpoint::WriteCallback(CFWriteStreamRef stream,+                                     CFStreamEventType type,+                                     void* client_callback_info) {+  auto self = static_cast<CFStreamEndpoint*>(client_callback_info);++  switch (type) {+    case kCFStreamEventOpenCompleted:+      self->open_event_.SetReady();+      break;+    case kCFStreamEventCanAcceptBytes:+    case kCFStreamEventEndEncountered:+      self->write_event_.SetReady();+      break;+    case kCFStreamEventErrorOccurred: {+      auto status = CFErrorToStatus(CFWriteStreamCopyError(stream));+      gpr_log(GPR_ERROR, ""CFStream Write error: %s"", status.ToString().c_str());+      self->open_event_.SetShutdown(status);+      self->read_event_.SetShutdown(status);+      self->write_event_.SetShutdown(status);+    } break;+    default:+      GPR_UNREACHABLE_CODE(return);+  }+}++CFStreamEndpoint::CFStreamEndpoint(std::shared_ptr<CFEventEngine> engine,+                                   MemoryAllocator memory_allocator)+    : engine_(std::move(engine)),+      memory_allocator_(std::move(memory_allocator)),+      open_event_(engine_.get()),+      read_event_(engine_.get()),+      write_event_(engine_.get()) {+  open_event_.InitEvent();+  read_event_.InitEvent();+  write_event_.InitEvent();+}++CFStreamEndpoint::~CFStreamEndpoint() {+  CFReadStreamClose(cf_read_stream_);+  CFWriteStreamClose(cf_write_stream_);++  open_event_.SetShutdown(absl::OkStatus());+  read_event_.SetShutdown(absl::OkStatus());+  write_event_.SetShutdown(absl::OkStatus());+  open_event_.DestroyEvent();+  read_event_.DestroyEvent();+  write_event_.DestroyEvent();+}++void CFStreamEndpoint::Read(absl::AnyInvocable<void(absl::Status)> on_read,+                            SliceBuffer* buffer, const ReadArgs* /* args */) {+  read_event_.NotifyOn(new PosixEngineClosure(+      [this, on_read = std::move(on_read),+       buffer](absl::Status status) mutable {+        if (status.ok()) {+          DoRead(std::move(on_read), buffer);+        } else {+          on_read(status);+        }+      },+      false /* is_permanent*/));+}++void CFStreamEndpoint::DoRead(absl::AnyInvocable<void(absl::Status)> on_read,+                              SliceBuffer* buffer) {+  int buffer_size = 8192;+  auto buffer_index =+      buffer->AppendIndexed(Slice(memory_allocator_.MakeSlice(buffer_size)));++  CFIndex read_size = CFReadStreamRead(+      cf_read_stream_,+      internal::SliceCast<MutableSlice>(buffer->MutableSliceAt(buffer_index))+          .begin(),+      buffer_size);++  if (read_size < 0) {+    auto status = CFErrorToStatus(CFReadStreamCopyError(cf_read_stream_));+    gpr_log(GPR_ERROR, ""CFStream read error: %s"", status.ToString().c_str());+    on_read(status);+    return;+  }++  buffer->RemoveLastNBytes(buffer->Length() - read_size);+  on_read(absl::OkStatus());+}++void CFStreamEndpoint::Write(absl::AnyInvocable<void(absl::Status)> on_writable,+                             SliceBuffer* data, const WriteArgs* /* args */) {+  write_event_.NotifyOn(new PosixEngineClosure(","I'm a bit lost here, what is actually writing the data? I believe the lockfree event here is triggered when a write finishes, and no write has been initiated yet. Does this work?",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32106,1086849451,2023-01-25T16:15:56Z,include/grpcpp/ext/server_metric_recorder.h,"@@ -54,26 +57,42 @@ class ServerMetricRecorder {   /// Values outside of the valid range are rejected.   /// Overrides the stored value when called again with a valid value.   void SetQps(double value);+  /// Records a named resource utilization value in the range [0, 1].+  /// Values outside of the valid range are rejected. Consumes `name`.","I don't think it's necessary to say ""Consumes name"".  The parameter is being passed in by value, which makes the semantics clear.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32106,1086860045,2023-01-25T16:23:58Z,src/cpp/server/backend_metric_recorder.h,"@@ -0,0 +1,46 @@+#ifndef LOCAL_GOOGLE_HOME_YSSEUNG_WORK_GRPC_GIT_GRPC_SRC_CPP_SERVER_BACKEND_METRIC_RECORDER_H_+#define LOCAL_GOOGLE_HOME_YSSEUNG_WORK_GRPC_GIT_GRPC_SRC_CPP_SERVER_BACKEND_METRIC_RECORDER_H_++#include <map>++#include <grpcpp/ext/call_metric_recorder.h>++#include ""src/core/ext/filters/backend_metrics/backend_metric_provider.h""++namespace grpc {++class BackendMetricState : public grpc_core::BackendMetricProvider,+                           public experimental::CallMetricRecorder {+ public:+  // `server_metric_recorder` is optional. When set, GetBackendMetricData()+  // merges metrics from `server_metric_recorder` with metrics recorded to this.+  explicit BackendMetricState(+      experimental::ServerMetricRecorder* server_metric_recorder)+      : server_metric_recorder_(server_metric_recorder) {}+  ~BackendMetricState() override = default;+  experimental::CallMetricRecorder& RecordCpuUtilizationMetric(+      double value) override;+  experimental::CallMetricRecorder& RecordMemoryUtilizationMetric(+      double value) override;+  experimental::CallMetricRecorder& RecordQpsMetric(double value) override;+  experimental::CallMetricRecorder& RecordUtilizationMetric(+      string_ref name, double value) override;+  experimental::CallMetricRecorder& RecordRequestCostMetric(+      string_ref name, double value) override;++ private:+  // This clears metrics currently recorded. Don't call twice.+  grpc_core::BackendMetricData GetBackendMetricData() override;","It seems inconsistent for this method to be private while the `Record*()` methods are public.  All of these methods are actually implementations of methods defined in the base classes, and since the callers will be accessing the methods via those base classes, it doesn't matter whether the implementations here in the subclass are public or private.I don't actually care whether we use public or private here, but let's use the same one for all of the methods.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32106,1086881844,2023-01-25T16:39:38Z,src/cpp/server/orca/backend_metric_recorder.cc,"@@ -0,0 +1,291 @@+//+// Copyright 2023 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+//++#include <inttypes.h>++#include <grpc/support/log.h>+#include <grpcpp/ext/server_metric_recorder.h>++#include ""src/core/ext/filters/client_channel/lb_policy/backend_metric_data.h""+#include ""src/core/lib/debug/trace.h""+#include ""src/cpp/server/backend_metric_recorder.h""++namespace {+// All utilization values must be in [0, 1].+bool IsUtilizationValid(double utilization) {+  return utilization >= 0.0 && utilization <= 1.0;+}++// QPS must be in [0, infy).+bool IsQpsValid(double qps) { return qps >= 0.0; }++grpc_core::TraceFlag grpc_backend_metric_trace(false, ""backend_metric"");+}  // namespace++namespace grpc {+namespace experimental {++void ServerMetricRecorder::SetCpuUtilization(double value) {+  if (!IsUtilizationValid(value)) {+    if (GRPC_TRACE_FLAG_ENABLED(grpc_backend_metric_trace)) {+      gpr_log(GPR_INFO, ""[%p] CPU utilization rejected: %f"", this, value);+    }+    return;+  }+  if (GRPC_TRACE_FLAG_ENABLED(grpc_backend_metric_trace)) {+    gpr_log(GPR_INFO, ""[%p] CPU utilization set: %f"", this, value);+  }+  update_seq_.fetch_add(1, std::memory_order_acq_rel);+  cpu_utilization_.store(value, std::memory_order_relaxed);+}++void ServerMetricRecorder::SetMemoryUtilization(double value) {+  if (!IsUtilizationValid(value)) {+    if (GRPC_TRACE_FLAG_ENABLED(grpc_backend_metric_trace)) {+      gpr_log(GPR_INFO, ""[%p] Mem utilization rejected: %f"", this, value);+    }+    return;+  }+  if (GRPC_TRACE_FLAG_ENABLED(grpc_backend_metric_trace)) {+    gpr_log(GPR_INFO, ""[%p] Mem utilization set: %f"", this, value);+  }+  update_seq_.fetch_add(1, std::memory_order_acq_rel);+  mem_utilization_.store(value, std::memory_order_relaxed);+}++void ServerMetricRecorder::SetQps(double value) {+  if (!IsQpsValid(value)) {+    if (GRPC_TRACE_FLAG_ENABLED(grpc_backend_metric_trace)) {+      gpr_log(GPR_INFO, ""[%p] QPS rejected: %f"", this, value);+    }+    return;+  }+  if (GRPC_TRACE_FLAG_ENABLED(grpc_backend_metric_trace)) {+    gpr_log(GPR_INFO, ""[%p] QPS set: %f"", this, value);+  }+  update_seq_.fetch_add(1, std::memory_order_acq_rel);+  qps_.store(value, std::memory_order_relaxed);+}++void ServerMetricRecorder::SetNamedUtilization(std::string name, double value) {+  if (!IsUtilizationValid(value)) {+    if (GRPC_TRACE_FLAG_ENABLED(grpc_backend_metric_trace)) {+      gpr_log(GPR_INFO, ""[%p] Named utilization rejected: %f name: %s"", this,+              value, name.c_str());+    }+    return;+  }+  internal::MutexLock lock(&mu_);+  if (GRPC_TRACE_FLAG_ENABLED(grpc_backend_metric_trace)) {+    gpr_log(GPR_INFO, ""[%p] Named utilization set: %f name: %s"", this, value,+            name.c_str());+  }+  update_seq_.fetch_add(1, std::memory_order_relaxed);+  named_utilization_[std::move(name)] = value;+}++void ServerMetricRecorder::SetAllNamedUtilization(+    std::map<std::string, double> named_utilization) {+  internal::MutexLock lock(&mu_);+  update_seq_.fetch_add(1, std::memory_order_relaxed);+  named_utilization_ = std::move(named_utilization);+  if (GRPC_TRACE_FLAG_ENABLED(grpc_backend_metric_trace)) {+    gpr_log(GPR_INFO, ""[%p] All named utilization updated."", this);+  }+}++void ServerMetricRecorder::ClearCpuUtilization() {+  update_seq_.fetch_add(1, std::memory_order_acq_rel);+  cpu_utilization_.store(-1.0, std::memory_order_relaxed);+  if (GRPC_TRACE_FLAG_ENABLED(grpc_backend_metric_trace)) {+    gpr_log(GPR_INFO, ""[%p] CPU utilization cleared."", this);+  }+}++void ServerMetricRecorder::ClearMemoryUtilization() {+  update_seq_.fetch_add(1, std::memory_order_acq_rel);+  mem_utilization_.store(-1.0, std::memory_order_relaxed);+  if (GRPC_TRACE_FLAG_ENABLED(grpc_backend_metric_trace)) {+    gpr_log(GPR_INFO, ""[%p] Mem utilization cleared."", this);+  }+}++void ServerMetricRecorder::ClearQps() {+  update_seq_.fetch_add(1, std::memory_order_acq_rel);+  qps_.store(-1.0, std::memory_order_relaxed);+  if (GRPC_TRACE_FLAG_ENABLED(grpc_backend_metric_trace)) {+    gpr_log(GPR_INFO, ""[%p] QPS utilization cleared."", this);+  }+}++void ServerMetricRecorder::ClearNamedUtilization(absl::string_view name) {+  std::string name_str(name);+  internal::MutexLock lock(&mu_);+  if (GRPC_TRACE_FLAG_ENABLED(grpc_backend_metric_trace)) {+    gpr_log(GPR_INFO, ""[%p] Named utilization cleared. name: %s"", this,+            name_str.c_str());+  }+  update_seq_.fetch_add(1, std::memory_order_relaxed);+  named_utilization_.erase(name_str);+}++std::pair<grpc_core::BackendMetricData, uint64_t>+ServerMetricRecorder::GetMetrics() const {+  grpc_core::BackendMetricData data;+  const double cpu = cpu_utilization_.load(std::memory_order_relaxed);","This approach means that we're reading all of these atomics even if the data has not changed.  Given that for per-call reporting (the common case), we are going to be calling this method for every RPC, and that we expect most RPCs will use cached data, it seems more efficient to instead cache the `BackendMetricData` struct and directly return it.One thing to keep in mind here is that I think we want to optimize for `GetMetrics()`, not for the setter methods, because `GetMetrics()` is the one that's going to be called in the performance-sensitive path.  I think that using a single mutex would actually be more efficient here than using atomics, because it would mean that `GetMetrics()` could grab a single mutex rather than accessing 4 atomics and grabbing a mutex for the named utilization map.  And there are things we can do to minimize lock contention if need be.Note that I am suggesting this change only for `ServerMetricRecorder`, not for `BackendMetricState`.  I think the current approach does make sense for `BackendMetricState`, since (a) both the setters and the getter are per-call and thus performance-sensitive, and (b) there is no expectation that most RPCs will use cached data for the data set via the `CallMetricRecorder` API.",
28025951,HannahShiSFB,https://api.github.com/repos/grpc/grpc/pulls/32077,1086883028,2023-01-25T16:40:29Z,test/core/event_engine/test_suite/BUILD,"@@ -119,8 +120,10 @@ grpc_cc_test(         ""no_linux"",         ""no_windows"",     ],-    uses_polling = False,+    uses_polling = True,","I believe it caused additional tests with polling=none (or something similar) which fails, let me change it back and test it again",
28025951,HannahShiSFB,https://api.github.com/repos/grpc/grpc/pulls/32077,1086890634,2023-01-25T16:45:36Z,src/core/lib/event_engine/cf_engine/cfstream_endpoint.cc,"@@ -0,0 +1,294 @@+// Copyright 2022 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++#include <grpc/support/port_platform.h>++#ifdef GPR_APPLE++#include ""src/core/lib/event_engine/cf_engine/cfstream_endpoint.h""+#include ""src/core/lib/gprpp/strerror.h""++namespace grpc_event_engine {+namespace experimental {++namespace {++absl::Status CFErrorToStatus(CFTypeUniqueRef<CFErrorRef> cf_error) {+  CFErrorDomain cf_domain = CFErrorGetDomain((cf_error));+  CFIndex code = CFErrorGetCode((cf_error));+  CFTypeUniqueRef<CFStringRef> cf_desc = CFErrorCopyDescription((cf_error));+  char domain_buf[256];+  char desc_buf[256];+  CFStringGetCString(cf_domain, domain_buf, 256, kCFStringEncodingUTF8);+  CFStringGetCString(cf_desc, desc_buf, 256, kCFStringEncodingUTF8);+  return absl::Status(absl::StatusCode::kInternal,+                      absl::StrFormat(""(domain:%s, code:%ld, description:%s)"",+                                      domain_buf, code, desc_buf));+}++absl::StatusOr<EventEngine::ResolvedAddress> CFReadStreamLocallAddress(+    CFReadStreamRef stream) {+  CFTypeUniqueRef<CFDataRef> cf_native_handle = static_cast<CFDataRef>(+      CFReadStreamCopyProperty(stream, kCFStreamPropertySocketNativeHandle));+  CFSocketNativeHandle socket;+  CFDataGetBytes(cf_native_handle, CFRangeMake(0, sizeof(CFSocketNativeHandle)),+                 (UInt8*)&socket);+  EventEngine::ResolvedAddress addr;+  socklen_t len = EventEngine::ResolvedAddress::MAX_SIZE_BYTES;+  if (getsockname(socket, const_cast<sockaddr*>(addr.address()), &len) < 0) {+    return absl::InternalError(+        absl::StrCat(""getsockname:"", grpc_core::StrError(errno)));+  }+  return EventEngine::ResolvedAddress(addr.address(), len);+}++}  // namespace++void CFStreamEndpoint::Connect(EventEngine::OnConnectCallback on_connect,+                               EventEngine::ResolvedAddress addr,+                               EventEngine::Duration timeout) {+  peer_address_ = std::move(addr);+  std::string host_port =+      grpc_sockaddr_to_string(reinterpret_cast<const grpc_resolved_address*>(+                                  peer_address_.address()),+                              true)+          .value();+  gpr_log(GPR_INFO, ""CFStreamClient::connect, host_port: %s"",+          host_port.c_str());+  std::string host_string;+  std::string port_string;+  grpc_core::SplitHostPort(host_port, &host_string, &port_string);+  CFStringRef host = CFStringCreateWithCString(NULL, host_string.c_str(),+                                               kCFStringEncodingUTF8);+  int port = ResolvedAddressGetPort(peer_address_);+  CFStreamCreatePairWithSocketToHost(NULL, host, port, &cf_read_stream_,+                                     &cf_write_stream_);++  CFStreamClientContext cf_context = {0, static_cast<void*>(this), nullptr,+                                      nullptr, nullptr};+  CFReadStreamSetClient(+      cf_read_stream_,+      kCFStreamEventOpenCompleted | kCFStreamEventHasBytesAvailable |+          kCFStreamEventErrorOccurred | kCFStreamEventEndEncountered,+      ReadCallback, &cf_context);+  CFWriteStreamSetClient(+      cf_write_stream_,+      kCFStreamEventOpenCompleted | kCFStreamEventCanAcceptBytes |+          kCFStreamEventErrorOccurred | kCFStreamEventEndEncountered,+      WriteCallback, &cf_context);+  CFReadStreamSetDispatchQueue(cf_read_stream_,+                               dispatch_get_global_queue(QOS_CLASS_DEFAULT, 0));+  CFWriteStreamSetDispatchQueue(+      cf_write_stream_, dispatch_get_global_queue(QOS_CLASS_DEFAULT, 0));++  if (!CFReadStreamOpen(cf_read_stream_)) {+    auto status = CFErrorToStatus(CFReadStreamCopyError(cf_read_stream_));+    on_connect(std::move(status));+    delete this;+    return;+  }++  if (!CFWriteStreamOpen(cf_write_stream_)) {+    auto status = CFErrorToStatus(CFWriteStreamCopyError(cf_write_stream_));+    on_connect(std::move(status));+    delete this;+    return;+  }++  auto connect_timeout_timer = engine_->RunAfter(timeout, [this]() {+    open_event_.SetShutdown(absl::DeadlineExceededError(""Connect timed out""));+  });++  open_event_.NotifyOn(new PosixEngineClosure(+      [this, on_connect = std::move(on_connect),+       connect_timeout_timer](absl::Status status) mutable {+        engine_->Cancel(connect_timeout_timer);++        if (!status.ok()) {+          on_connect(std::move(status));+          delete this;+          return;+        }++        auto status_or_local_addr = CFReadStreamLocallAddress(cf_read_stream_);+        if (!status_or_local_addr.ok()) {+          on_connect(std::move(status_or_local_addr).status());+          delete this;+          return;+        }++        local_address_ = status_or_local_addr.value();+        on_connect(std::unique_ptr<EventEngine::Endpoint>(this));+      },+      false /* is_permanent */));+}++/* static */ void CFStreamEndpoint::ReadCallback(CFReadStreamRef stream,+                                                 CFStreamEventType type,+                                                 void* client_callback_info) {+  auto self = static_cast<CFStreamEndpoint*>(client_callback_info);++  switch (type) {+    case kCFStreamEventOpenCompleted:+      break;+    case kCFStreamEventHasBytesAvailable:+    case kCFStreamEventEndEncountered:+      self->read_event_.SetReady();+      break;+    case kCFStreamEventErrorOccurred: {+      auto status = CFErrorToStatus(CFReadStreamCopyError(stream));+      gpr_log(GPR_ERROR, ""CFStream Read error: %s"", status.ToString().c_str());+      self->open_event_.SetShutdown(status);+      self->read_event_.SetShutdown(status);+      self->write_event_.SetShutdown(status);+    } break;+    default:+      GPR_UNREACHABLE_CODE(return);+  }+}++/* static */+void CFStreamEndpoint::WriteCallback(CFWriteStreamRef stream,+                                     CFStreamEventType type,+                                     void* client_callback_info) {+  auto self = static_cast<CFStreamEndpoint*>(client_callback_info);++  switch (type) {+    case kCFStreamEventOpenCompleted:+      self->open_event_.SetReady();+      break;+    case kCFStreamEventCanAcceptBytes:+    case kCFStreamEventEndEncountered:+      self->write_event_.SetReady();+      break;+    case kCFStreamEventErrorOccurred: {+      auto status = CFErrorToStatus(CFWriteStreamCopyError(stream));+      gpr_log(GPR_ERROR, ""CFStream Write error: %s"", status.ToString().c_str());+      self->open_event_.SetShutdown(status);+      self->read_event_.SetShutdown(status);+      self->write_event_.SetShutdown(status);+    } break;+    default:+      GPR_UNREACHABLE_CODE(return);+  }+}++CFStreamEndpoint::CFStreamEndpoint(std::shared_ptr<CFEventEngine> engine,+                                   MemoryAllocator memory_allocator)+    : engine_(std::move(engine)),+      memory_allocator_(std::move(memory_allocator)),+      open_event_(engine_.get()),+      read_event_(engine_.get()),+      write_event_(engine_.get()) {+  open_event_.InitEvent();+  read_event_.InitEvent();+  write_event_.InitEvent();+}++CFStreamEndpoint::~CFStreamEndpoint() {+  CFReadStreamClose(cf_read_stream_);+  CFWriteStreamClose(cf_write_stream_);++  open_event_.SetShutdown(absl::OkStatus());+  read_event_.SetShutdown(absl::OkStatus());+  write_event_.SetShutdown(absl::OkStatus());+  open_event_.DestroyEvent();+  read_event_.DestroyEvent();+  write_event_.DestroyEvent();+}++void CFStreamEndpoint::Read(absl::AnyInvocable<void(absl::Status)> on_read,+                            SliceBuffer* buffer, const ReadArgs* /* args */) {+  read_event_.NotifyOn(new PosixEngineClosure(+      [this, on_read = std::move(on_read),+       buffer](absl::Status status) mutable {+        if (status.ok()) {+          DoRead(std::move(on_read), buffer);+        } else {+          on_read(status);+        }+      },+      false /* is_permanent*/));+}++void CFStreamEndpoint::DoRead(absl::AnyInvocable<void(absl::Status)> on_read,+                              SliceBuffer* buffer) {+  int buffer_size = 8192;+  auto buffer_index =+      buffer->AppendIndexed(Slice(memory_allocator_.MakeSlice(buffer_size)));++  CFIndex read_size = CFReadStreamRead(+      cf_read_stream_,+      internal::SliceCast<MutableSlice>(buffer->MutableSliceAt(buffer_index))+          .begin(),+      buffer_size);++  if (read_size < 0) {+    auto status = CFErrorToStatus(CFReadStreamCopyError(cf_read_stream_));+    gpr_log(GPR_ERROR, ""CFStream read error: %s"", status.ToString().c_str());+    on_read(status);+    return;+  }++  buffer->RemoveLastNBytes(buffer->Length() - read_size);+  on_read(absl::OkStatus());+}++void CFStreamEndpoint::Write(absl::AnyInvocable<void(absl::Status)> on_writable,+                             SliceBuffer* data, const WriteArgs* /* args */) {+  write_event_.NotifyOn(new PosixEngineClosure(","write_event_ is triggered when cfstream is ready to accept writes, then DoWrite in the closure will be called.Yes, it works and I tested it with very small and very large (40M) message by modifying the test suit, to trigger the case that send buffer is full so write had to wait.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32106,1086912512,2023-01-25T17:02:10Z,test/cpp/end2end/orca_service_end2end_test.cc,"@@ -107,16 +112,13 @@ class OrcaServiceEnd2endTest : public ::testing::Test {   ~OrcaServiceEnd2endTest() override { server_->Shutdown(); }    std::string server_address_;-  OrcaService orca_service_;+  ServerMetricRecorder server_metric_recorder_;+  std::unique_ptr<OrcaService> orca_service_;",There is no need to use dynamic allocation to pass the parameter here.  You can set the parameter via the ctor's initialization list:```class MyClass { public:  MyClass() : orca_service_(&server_metric_recorder_) {} private:  ServerMetricRecorder server_metric_recorder_;  OrcaService orca_service_;};```,
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32106,1086916244,2023-01-25T17:05:20Z,src/cpp/server/server_context.cc,"@@ -157,14 +157,15 @@ class BackendMetricState : public experimental::CallMetricRecorder,   }   private:+  // Once returned metrics recorded with CallMetricRecorder APIs are cleared.   grpc_core::BackendMetricData GetBackendMetricData() override       ABSL_NO_THREAD_SAFETY_ANALYSIS {-    grpc_core::BackendMetricData data;     // Merge metrics from the ServerMetricRecorder first since metrics recorded-    // to this (CallMetricRecorder) takes a higher precedence.-    if (server_metric_recorder_ != nullptr) {-      server_metric_recorder_->GetMetrics(&data);-    }+    // to CallMetricRecorder takes a higher precedence.+    grpc_core::BackendMetricData data =","There is no dynamic allocation here; all objects are allocated on the stack.The code you currently have is actually slightly less optimal in the case where `server_metric_recorder_` is null, since it instantiates two objects and uses a move ctor, whereas the alternative code I provided instantiates only one object.",
1644595,gnossen,https://api.github.com/repos/grpc/grpc/pulls/32183,1087013169,2023-01-25T18:21:18Z,examples/python/wait_for_ready/wait_for_ready_with_client_timeout_example_client.py,"@@ -11,10 +11,18 @@ # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License.-""""""The Python client of utilizing wait-for-ready flag with client time out.""""""","Suggestion: ""An example of setting a server connection timeout independent from the overall RPC timeout.""",
5663878,yijiem,https://api.github.com/repos/grpc/grpc/pulls/31958,1087113167,2023-01-25T20:01:13Z,src/core/lib/iomgr/endpoint_pair_windows.cc,"@@ -63,8 +63,16 @@ static void create_sockets(SOCKET sv[2]) {   GPR_ASSERT(svr_sock != INVALID_SOCKET);    closesocket(lst_sock);-  grpc_tcp_prepare_socket(cli_sock);-  grpc_tcp_prepare_socket(svr_sock);+  grpc_error_handle error = grpc_tcp_prepare_socket(cli_sock);+  if (!error.ok()) {+    gpr_log(GPR_WARN, ""Prepare cli_sock failed with error: %s"",","gRPC does not have `GPR_WARN`, maybe it could be useful to have one, but for now I suggest to just use `GPR_INFO`: https://github.com/grpc/grpc/blob/67f364e23e4989c6e7837d03ea4e9d415f3cd890/include/grpc/support/log.h#L53-L55",
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/32077,1087114923,2023-01-25T20:03:13Z,src/core/lib/event_engine/cf_engine/cf_engine.cc,"@@ -72,14 +76,30 @@ CFEventEngine::CreateListener( }  CFEventEngine::ConnectionHandle CFEventEngine::Connect(-    OnConnectCallback /* on_connect */, const ResolvedAddress& /* addr */,-    const EndpointConfig& /* args */, MemoryAllocator /* memory_allocator */,-    Duration /* timeout */) {-  grpc_core::Crash(""unimplemented"");+    OnConnectCallback on_connect, const ResolvedAddress& addr,+    const EndpointConfig& /* args */, MemoryAllocator memory_allocator,+    Duration timeout) {+  auto addr_uri = ResolvedAddressToURI(addr);+  gpr_log(GPR_INFO, ""CFEventEngine::connect: %s"", addr_uri.value().c_str());+  if (!addr_uri.ok()) {+    Run([on_connect = std::move(on_connect),+         ep = absl::FailedPreconditionError(absl::StrCat(+             ""connect failed: "", ""invalid addr: "",+             addr_uri.value()))]() mutable { on_connect(std::move(ep)); });+    return {0, 0};+  }++  auto endpoint_ptr = new CFStreamEndpoint(+      std::static_pointer_cast<CFEventEngine>(shared_from_this()),+      std::move(memory_allocator));++  endpoint_ptr->Connect(std::move(on_connect), addr, std::move(timeout));++  return {reinterpret_cast<intptr_t>(endpoint_ptr), 0};","I see, thanks for explaining. It should be valid to have an EventEngine instance that does not support connection cancellation, I imagine there may be cases where things like gRPC shutdown takes longer. We can try it without that support.",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/31448,1087285551,2023-01-25T23:29:26Z,test/core/end2end/tests/max_message_length.cc,"@@ -596,7 +596,7 @@ static void test_max_receive_message_length_on_compressed_request(                                 nullptr);   GPR_ASSERT(GRPC_CALL_OK == error); -  cqv.Expect(tag(102), false);+  cqv.Expect(tag(102), true);","it was not, but woah nelly the only test we have covering some substantial api surface (fixed, please see pipe.h especially, but also changes in call.cc and promise_based_filter.cc)",
85715732,yousukseung,https://api.github.com/repos/grpc/grpc/pulls/32106,1087337694,2023-01-26T01:02:03Z,src/cpp/server/orca/backend_metric_recorder.cc,"@@ -0,0 +1,291 @@+//+// Copyright 2023 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+//++#include <inttypes.h>++#include <grpc/support/log.h>+#include <grpcpp/ext/server_metric_recorder.h>++#include ""src/core/ext/filters/client_channel/lb_policy/backend_metric_data.h""+#include ""src/core/lib/debug/trace.h""+#include ""src/cpp/server/backend_metric_recorder.h""++namespace {+// All utilization values must be in [0, 1].+bool IsUtilizationValid(double utilization) {+  return utilization >= 0.0 && utilization <= 1.0;+}++// QPS must be in [0, infy).+bool IsQpsValid(double qps) { return qps >= 0.0; }++grpc_core::TraceFlag grpc_backend_metric_trace(false, ""backend_metric"");+}  // namespace++namespace grpc {+namespace experimental {++void ServerMetricRecorder::SetCpuUtilization(double value) {+  if (!IsUtilizationValid(value)) {+    if (GRPC_TRACE_FLAG_ENABLED(grpc_backend_metric_trace)) {+      gpr_log(GPR_INFO, ""[%p] CPU utilization rejected: %f"", this, value);+    }+    return;+  }+  if (GRPC_TRACE_FLAG_ENABLED(grpc_backend_metric_trace)) {+    gpr_log(GPR_INFO, ""[%p] CPU utilization set: %f"", this, value);+  }+  update_seq_.fetch_add(1, std::memory_order_acq_rel);+  cpu_utilization_.store(value, std::memory_order_relaxed);+}++void ServerMetricRecorder::SetMemoryUtilization(double value) {+  if (!IsUtilizationValid(value)) {+    if (GRPC_TRACE_FLAG_ENABLED(grpc_backend_metric_trace)) {+      gpr_log(GPR_INFO, ""[%p] Mem utilization rejected: %f"", this, value);+    }+    return;+  }+  if (GRPC_TRACE_FLAG_ENABLED(grpc_backend_metric_trace)) {+    gpr_log(GPR_INFO, ""[%p] Mem utilization set: %f"", this, value);+  }+  update_seq_.fetch_add(1, std::memory_order_acq_rel);+  mem_utilization_.store(value, std::memory_order_relaxed);+}++void ServerMetricRecorder::SetQps(double value) {+  if (!IsQpsValid(value)) {+    if (GRPC_TRACE_FLAG_ENABLED(grpc_backend_metric_trace)) {+      gpr_log(GPR_INFO, ""[%p] QPS rejected: %f"", this, value);+    }+    return;+  }+  if (GRPC_TRACE_FLAG_ENABLED(grpc_backend_metric_trace)) {+    gpr_log(GPR_INFO, ""[%p] QPS set: %f"", this, value);+  }+  update_seq_.fetch_add(1, std::memory_order_acq_rel);+  qps_.store(value, std::memory_order_relaxed);+}++void ServerMetricRecorder::SetNamedUtilization(std::string name, double value) {+  if (!IsUtilizationValid(value)) {+    if (GRPC_TRACE_FLAG_ENABLED(grpc_backend_metric_trace)) {+      gpr_log(GPR_INFO, ""[%p] Named utilization rejected: %f name: %s"", this,+              value, name.c_str());+    }+    return;+  }+  internal::MutexLock lock(&mu_);+  if (GRPC_TRACE_FLAG_ENABLED(grpc_backend_metric_trace)) {+    gpr_log(GPR_INFO, ""[%p] Named utilization set: %f name: %s"", this, value,+            name.c_str());+  }+  update_seq_.fetch_add(1, std::memory_order_relaxed);+  named_utilization_[std::move(name)] = value;+}++void ServerMetricRecorder::SetAllNamedUtilization(+    std::map<std::string, double> named_utilization) {+  internal::MutexLock lock(&mu_);+  update_seq_.fetch_add(1, std::memory_order_relaxed);+  named_utilization_ = std::move(named_utilization);+  if (GRPC_TRACE_FLAG_ENABLED(grpc_backend_metric_trace)) {+    gpr_log(GPR_INFO, ""[%p] All named utilization updated."", this);+  }+}++void ServerMetricRecorder::ClearCpuUtilization() {+  update_seq_.fetch_add(1, std::memory_order_acq_rel);+  cpu_utilization_.store(-1.0, std::memory_order_relaxed);+  if (GRPC_TRACE_FLAG_ENABLED(grpc_backend_metric_trace)) {+    gpr_log(GPR_INFO, ""[%p] CPU utilization cleared."", this);+  }+}++void ServerMetricRecorder::ClearMemoryUtilization() {+  update_seq_.fetch_add(1, std::memory_order_acq_rel);+  mem_utilization_.store(-1.0, std::memory_order_relaxed);+  if (GRPC_TRACE_FLAG_ENABLED(grpc_backend_metric_trace)) {+    gpr_log(GPR_INFO, ""[%p] Mem utilization cleared."", this);+  }+}++void ServerMetricRecorder::ClearQps() {+  update_seq_.fetch_add(1, std::memory_order_acq_rel);+  qps_.store(-1.0, std::memory_order_relaxed);+  if (GRPC_TRACE_FLAG_ENABLED(grpc_backend_metric_trace)) {+    gpr_log(GPR_INFO, ""[%p] QPS utilization cleared."", this);+  }+}++void ServerMetricRecorder::ClearNamedUtilization(absl::string_view name) {+  std::string name_str(name);+  internal::MutexLock lock(&mu_);+  if (GRPC_TRACE_FLAG_ENABLED(grpc_backend_metric_trace)) {+    gpr_log(GPR_INFO, ""[%p] Named utilization cleared. name: %s"", this,+            name_str.c_str());+  }+  update_seq_.fetch_add(1, std::memory_order_relaxed);+  named_utilization_.erase(name_str);+}++std::pair<grpc_core::BackendMetricData, uint64_t>+ServerMetricRecorder::GetMetrics() const {+  grpc_core::BackendMetricData data;+  const double cpu = cpu_utilization_.load(std::memory_order_relaxed);","Updated. I made two changes to ServerMetricRecorder:- GetMetrics() returns optional<Data> instead of Data where nullopt indicates the data is empty and the per-call filter skips if nullopt. Making the same change to OrcaService fails tests so I instead make it shortcut to send an empty Slice.- GetMetrics() accepts an optional last_seq from the caller, and when it matches ServerMetricRecorder skips copying out data as the caller already has data cached.- I kept the seq atomic in ServerMetricRecorder  so that GetMetrics() can return lock-free with a cache hit. Data members are made non-atomic. So we still allow false cache misses in corner cases (but no false hits).",
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/32196,1087404563,2023-01-26T03:09:04Z,src/core/lib/gprpp/fork.cc,"@@ -228,5 +235,6 @@ void Fork::AwaitThreads() {  std::atomic<bool> Fork::support_enabled_(false); bool Fork::override_enabled_ = false;-Fork::child_postfork_func Fork::reset_child_polling_engine_ = nullptr;+std::vector<Fork::child_postfork_func>* Fork::reset_child_polling_engine_ =","I don't think this needs to be a pointer, the nullptr check doesn't seem to have much purpose other than to lazy initialize the vector.",
1644595,gnossen,https://api.github.com/repos/grpc/grpc/pulls/32196,1087423838,2023-01-26T04:01:42Z,src/core/lib/gprpp/fork.cc,"@@ -228,5 +235,6 @@ void Fork::AwaitThreads() {  std::atomic<bool> Fork::support_enabled_(false); bool Fork::override_enabled_ = false;-Fork::child_postfork_func Fork::reset_child_polling_engine_ = nullptr;+std::vector<Fork::child_postfork_func>* Fork::reset_child_polling_engine_ =","Is `std::vector<T*>` trivially destructible? I know this is `static`, not technically global, but I figured the same rules applied.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32106,1088063604,2023-01-26T16:18:52Z,include/grpcpp/ext/server_metric_recorder.h,"@@ -27,11 +27,9 @@ #include ""absl/strings/string_view.h"" #include ""absl/types/optional.h"" -#include <grpcpp/impl/sync.h>+#include ""src/core/ext/filters/client_channel/lb_policy/backend_metric_data.h""","It's not okay to include a file in the src tree from inside the include tree, because when a user installs gRPC on their system in binary form, the src tree will not be present, only the include tree.Was there some problem with using a forward declaration, the way you had this before?  If the compiler is unhappy with not having the full definition of `BackendMetricData` here, then I think we need to do one of the following:1. Move backend_metric_data.h from the src tree to include/grpc/impl, and probably move the struct into the `grpc_core::internal` namespace.  This is a bit ugly, because it exposes something in a public header that should really be hidden as an implementation detail.2. Define a duplicate copy of the struct as an private member of `ServerMetricRecorder`.  This will be a bit sub-optimal, because it will require the code in `BackendMetricState` to explicitly copy individual fields between the two types.3. Change `ServerMetricRecorder` to be an abstract interface with a static factory method, with the concrete implementation defined only internally.  The abstract interface would not include the `GetMetrics()` method, so it would not depend on `BackendMetricData`, thus eliminating the need to refer to it in a public header.Option 3 is probably the cleanest.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32106,1088066604,2023-01-26T16:21:36Z,src/core/ext/filters/backend_metrics/backend_metric_filter.cc,"@@ -18,29 +18,29 @@ TraceFlag grpc_backend_metric_filter_trace(false, ""backend_metric_filter""); absl::optional<std::string> BackendMetricFilter::MaybeSerializeBackendMetrics(     BackendMetricProvider* provider) const {   if (provider == nullptr) return absl::nullopt;-  BackendMetricData d = provider->GetBackendMetricData();+  absl::optional<BackendMetricData> d = provider->GetBackendMetricData();",Please call this `data` instead of `d`.https://google.github.io/styleguide/cppguide.html#General_Naming_Rules,X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32106,1088067471,2023-01-26T16:22:14Z,src/core/ext/filters/backend_metrics/backend_metric_filter.cc,"@@ -18,29 +18,29 @@ TraceFlag grpc_backend_metric_filter_trace(false, ""backend_metric_filter""); absl::optional<std::string> BackendMetricFilter::MaybeSerializeBackendMetrics(     BackendMetricProvider* provider) const {   if (provider == nullptr) return absl::nullopt;-  BackendMetricData d = provider->GetBackendMetricData();+  absl::optional<BackendMetricData> d = provider->GetBackendMetricData();+  if (d == absl::nullopt) return absl::nullopt;","Please write this as `!d.has_value()`.Alternatively, an even better approach would be not to have `BackendMetricProvider::GetBackendMetricData()` return `absl::optional<>` in the first place.  Similar to my suggestion elsewhere for `ServerMetricRecorder`, I think we can just return an empty `BackendMetricData` struct if there is no data, which eliminates the need for the `IsEmpty()` check in `BackendMetricState`.  The code here in the filter is already needing to look at each individual field to populate the proto, so we can probably just have a local `bool have_data` variable that we set to true whenever we populate a field, and then at the end we can just return nullopt if `have_data` is false.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32106,1088162346,2023-01-26T17:49:35Z,src/cpp/server/orca/backend_metric_recorder.cc,"@@ -0,0 +1,291 @@+//+// Copyright 2023 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+//++#include <inttypes.h>++#include <grpc/support/log.h>+#include <grpcpp/ext/server_metric_recorder.h>++#include ""src/core/ext/filters/client_channel/lb_policy/backend_metric_data.h""+#include ""src/core/lib/debug/trace.h""+#include ""src/cpp/server/backend_metric_recorder.h""++namespace {+// All utilization values must be in [0, 1].+bool IsUtilizationValid(double utilization) {+  return utilization >= 0.0 && utilization <= 1.0;+}++// QPS must be in [0, infy).+bool IsQpsValid(double qps) { return qps >= 0.0; }++grpc_core::TraceFlag grpc_backend_metric_trace(false, ""backend_metric"");+}  // namespace++namespace grpc {+namespace experimental {++void ServerMetricRecorder::SetCpuUtilization(double value) {+  if (!IsUtilizationValid(value)) {+    if (GRPC_TRACE_FLAG_ENABLED(grpc_backend_metric_trace)) {+      gpr_log(GPR_INFO, ""[%p] CPU utilization rejected: %f"", this, value);+    }+    return;+  }+  if (GRPC_TRACE_FLAG_ENABLED(grpc_backend_metric_trace)) {+    gpr_log(GPR_INFO, ""[%p] CPU utilization set: %f"", this, value);+  }+  update_seq_.fetch_add(1, std::memory_order_acq_rel);+  cpu_utilization_.store(value, std::memory_order_relaxed);+}++void ServerMetricRecorder::SetMemoryUtilization(double value) {+  if (!IsUtilizationValid(value)) {+    if (GRPC_TRACE_FLAG_ENABLED(grpc_backend_metric_trace)) {+      gpr_log(GPR_INFO, ""[%p] Mem utilization rejected: %f"", this, value);+    }+    return;+  }+  if (GRPC_TRACE_FLAG_ENABLED(grpc_backend_metric_trace)) {+    gpr_log(GPR_INFO, ""[%p] Mem utilization set: %f"", this, value);+  }+  update_seq_.fetch_add(1, std::memory_order_acq_rel);+  mem_utilization_.store(value, std::memory_order_relaxed);+}++void ServerMetricRecorder::SetQps(double value) {+  if (!IsQpsValid(value)) {+    if (GRPC_TRACE_FLAG_ENABLED(grpc_backend_metric_trace)) {+      gpr_log(GPR_INFO, ""[%p] QPS rejected: %f"", this, value);+    }+    return;+  }+  if (GRPC_TRACE_FLAG_ENABLED(grpc_backend_metric_trace)) {+    gpr_log(GPR_INFO, ""[%p] QPS set: %f"", this, value);+  }+  update_seq_.fetch_add(1, std::memory_order_acq_rel);+  qps_.store(value, std::memory_order_relaxed);+}++void ServerMetricRecorder::SetNamedUtilization(std::string name, double value) {+  if (!IsUtilizationValid(value)) {+    if (GRPC_TRACE_FLAG_ENABLED(grpc_backend_metric_trace)) {+      gpr_log(GPR_INFO, ""[%p] Named utilization rejected: %f name: %s"", this,+              value, name.c_str());+    }+    return;+  }+  internal::MutexLock lock(&mu_);+  if (GRPC_TRACE_FLAG_ENABLED(grpc_backend_metric_trace)) {+    gpr_log(GPR_INFO, ""[%p] Named utilization set: %f name: %s"", this, value,+            name.c_str());+  }+  update_seq_.fetch_add(1, std::memory_order_relaxed);+  named_utilization_[std::move(name)] = value;+}++void ServerMetricRecorder::SetAllNamedUtilization(+    std::map<std::string, double> named_utilization) {+  internal::MutexLock lock(&mu_);+  update_seq_.fetch_add(1, std::memory_order_relaxed);+  named_utilization_ = std::move(named_utilization);+  if (GRPC_TRACE_FLAG_ENABLED(grpc_backend_metric_trace)) {+    gpr_log(GPR_INFO, ""[%p] All named utilization updated."", this);+  }+}++void ServerMetricRecorder::ClearCpuUtilization() {+  update_seq_.fetch_add(1, std::memory_order_acq_rel);+  cpu_utilization_.store(-1.0, std::memory_order_relaxed);+  if (GRPC_TRACE_FLAG_ENABLED(grpc_backend_metric_trace)) {+    gpr_log(GPR_INFO, ""[%p] CPU utilization cleared."", this);+  }+}++void ServerMetricRecorder::ClearMemoryUtilization() {+  update_seq_.fetch_add(1, std::memory_order_acq_rel);+  mem_utilization_.store(-1.0, std::memory_order_relaxed);+  if (GRPC_TRACE_FLAG_ENABLED(grpc_backend_metric_trace)) {+    gpr_log(GPR_INFO, ""[%p] Mem utilization cleared."", this);+  }+}++void ServerMetricRecorder::ClearQps() {+  update_seq_.fetch_add(1, std::memory_order_acq_rel);+  qps_.store(-1.0, std::memory_order_relaxed);+  if (GRPC_TRACE_FLAG_ENABLED(grpc_backend_metric_trace)) {+    gpr_log(GPR_INFO, ""[%p] QPS utilization cleared."", this);+  }+}++void ServerMetricRecorder::ClearNamedUtilization(absl::string_view name) {+  std::string name_str(name);+  internal::MutexLock lock(&mu_);+  if (GRPC_TRACE_FLAG_ENABLED(grpc_backend_metric_trace)) {+    gpr_log(GPR_INFO, ""[%p] Named utilization cleared. name: %s"", this,+            name_str.c_str());+  }+  update_seq_.fetch_add(1, std::memory_order_relaxed);+  named_utilization_.erase(name_str);+}++std::pair<grpc_core::BackendMetricData, uint64_t>+ServerMetricRecorder::GetMetrics() const {+  grpc_core::BackendMetricData data;+  const double cpu = cpu_utilization_.load(std::memory_order_relaxed);","This API seems fairly cumbersome.  I think there are a few things we can do to make it easier to understand.First, it's confusing that nullopt represents both (a) no backend metric data available and (b) if a sequence number was specified, no new data is available.  I think the API would be easier to understand if nullopt only meant (b).  For (a), I think we should instead return an empty `BackendMetricData` struct.  I think this will actually make the code simpler in both callers: in `BackendMetricState`, we can just unconditionally use the result, and in `OrcaService` there will be no more need for the special-case where we return an empty slice.Also, I think the API would be a bit easier to use if we split it into two separate methods, one for per-call (no caching) and the other for OOB (caching).And finally, for the OOB method, please define a struct for the return type rather than using `std::pair<>`, as per:https://google.github.io/styleguide/cppguide.html#Structs_vs._TuplesGiven all of the above, I think the API should look something like this:```// (This is for the per-call case, with no caching -- no sequence number// needed as either input or output.)// Returns the recorded backend metrics.grpc_core::BackendMetricData GetMetrics();// (This is for the OOB case.)// Returns the recorded backend metrics, with sequence number caching.// If the specified sequence number is still current, returns nullopt.struct GetMetricsResult {  grpc_core::BackendMetricData backend_metric_data;  uint64_t sequence_number;};absl::optional<GetMetricsResult> GetMetricsIfChanged(    absl::optional<uint64_t> sequence_number);```If you're concerned about lock contention here, an alternative might be to cache the resulting `BackendMetricData` object, so that we don't have to construct a new one on each call.  We could use the same approach here that we used for the scheduler in the WRR picker: we can store a ref-counted `BackendMetricData` object protected by a mutex, so that `GetMetrics()` just has to acquire the mutex, take a ref, and then drop the mutex.  We would then create a new `BackendMetricData` object and swap it into place when any of the setter methods are called.If we go with that approach, another option would be to actually use the address of the cached `BackendMetricData` instead of the sequence number.  In that case, the API would instead look like this (same method for per-call and OOB):```// Returns backend metric data.// If cached_data is non-null and still points to the current data, returns nullptr.std::shared_ptr<BackendMetricData> GetMetricsIfChanged(BackendMetricData* cached_data = nullptr);```The idea here is that `OrcaService` would cache the most recently seen result in a data member, so it could do something like this:```std::shared_ptr<BackendMetricData> data =    server_metric_recorder_->GetMetrics(cached_data_.get());if (data != nullptr) {  response_slice_ = BuildResponseProto(*data);  cached_data_ = std::move(data);}return response_slice_;```That particular variant here does have the slight disadvantage that `OrcaService` would need to cache the `BackendMetricData` object in addition to the serialized proto, but since that's just one object per server, it's not that big of a waste.",X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32106,1088255721,2023-01-26T19:27:44Z,test/cpp/end2end/client_lb_end2end_test.cc,"@@ -96,10 +96,6 @@ class MyTestServiceImpl : public TestServiceImpl {     }     AddClient(context->peer());     absl::optional<xds::data::orca::v3::OrcaLoadReport> load_report;","I don't think we actually need this variable anymore.  I think this code can now be simplified to be closer to how it looked prior to #31904:```    if (request->has_param() && request->param().has_backend_metrics()) {      const auto& load_report = request->param().backend_metrics();      auto* recorder = context->ExperimentalGetCallMetricRecorder();      EXPECT_NE(recorder, nullptr);      recorder->RecordCpuUtilizationMetric(load_report.cpu_utilization())          .RecordMemoryUtilizationMetric(load_report.mem_utilization())          .RecordQpsMetric(load_report.rps_fractional());      for (const auto& p : load_report.request_cost()) {        char* key = static_cast<char*>(            grpc_call_arena_alloc(context->c_call(), p.first.size() + 1));        strncpy(key, p.first.data(), p.first.size());        key[p.first.size()] = '\0';        recorder->RecordRequestCostMetric(key, p.second);      }      for (const auto& p : load_report.utilization()) {        char* key = static_cast<char*>(            grpc_call_arena_alloc(context->c_call(), p.first.size() + 1));        strncpy(key, p.first.data(), p.first.size());        key[p.first.size()] = '\0';        recorder->RecordUtilizationMetric(key, p.second);      }    }```",X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32106,1088259837,2023-01-26T19:32:31Z,test/cpp/end2end/client_lb_end2end_test.cc,"@@ -2931,48 +2951,73 @@ TEST_F(WeightedRoundRobinTest, Basic) {             channel->GetLoadBalancingPolicyName()); } -TEST_F(WeightedRoundRobinTest, OobReporting) {+INSTANTIATE_TEST_SUITE_P(WeightedRoundRobin, WeightedRoundRobinParamTest,","Please move this up to line 2916, so that it's easy to see how the test suite is being parameterized right after it is defined.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32106,1088266765,2023-01-26T19:39:53Z,test/cpp/end2end/client_lb_end2end_test.cc,"@@ -2882,43 +2890,55 @@ TEST_F(ControlPlaneStatusRewritingTest, RewritesFromConfigSelector) { // WeightedRoundRobinTest // -using WeightedRoundRobinTest = ClientLbEnd2endTest;--TEST_F(WeightedRoundRobinTest, Basic) {+const char kServiceConfigPerCall[] =+    ""{\n""+    ""  \""loadBalancingConfig\"": [\n""+    ""    {\""weighted_round_robin_experimental\"": {\n""+    ""      \""blackoutPeriod\"": \""0s\""\n""+    ""    }}\n""+    ""  ]\n""+    ""}"";++const char kServiceConfigOob[] =+    ""{\n""+    ""  \""loadBalancingConfig\"": [\n""+    ""    {\""weighted_round_robin_experimental\"": {\n""+    ""      \""blackoutPeriod\"": \""0s\"",\n""+    ""      \""enableOobLoadReport\"": true\n""+    ""    }}\n""+    ""  ]\n""+    ""}"";++class WeightedRoundRobinParamTest+    : public ClientLbEnd2endTest,+      public ::testing::WithParamInterface<const char*> {};++TEST_P(WeightedRoundRobinParamTest, Basic) {   const int kNumServers = 3;   StartServers(kNumServers);-  // Tell each server to report the appropriate CPU utilization.-  xds::data::orca::v3::OrcaLoadReport load_report;-  load_report.set_rps_fractional(100);-  load_report.set_cpu_utilization(0.9);-  servers_[0]->service_.SetLoadReport(load_report);-  load_report.set_cpu_utilization(0.3);-  servers_[1]->service_.SetLoadReport(load_report);-  servers_[2]->service_.SetLoadReport(load_report);+  // Report server metrics that should give 1:3:3 WRR picks.+  servers_[0]->server_metric_recorder_.SetCpuUtilization(0.9);+  servers_[0]->server_metric_recorder_.SetQps(100);+  servers_[1]->server_metric_recorder_.SetCpuUtilization(0.3);+  servers_[1]->server_metric_recorder_.SetQps(100);+  servers_[2]->server_metric_recorder_.SetCpuUtilization(0.3);+  servers_[2]->server_metric_recorder_.SetQps(100);   // Create channel.   auto response_generator = BuildResolverResponseGenerator();   auto channel = BuildChannel("""", response_generator);   auto stub = BuildStub(channel);-  const char kServiceConfig[] =-      ""{\n""-      ""  \""loadBalancingConfig\"": [\n""-      ""    {\""weighted_round_robin_experimental\"": {\n""-      ""      \""blackoutPeriod\"": \""0s\""\n""-      ""    }}\n""-      ""  ]\n""-      ""}"";-  response_generator.SetNextResolution(GetServersPorts(), kServiceConfig);+  response_generator.SetNextResolution(GetServersPorts(), GetParam());   // Wait for the right set of WRR picks.   size_t num_picks = 0;   SendRpcsUntil(DEBUG_LOCATION, stub, [&](const Status&) {-    if (++num_picks == 7) {+    if (++num_picks == 21) {","I think we want to be more rigorous here than just checking that the aggregate counts are right after 3 full passes -- we actually need to check that each individual pass has the right counts.  If the policy wound up effectively combining all three passes into one, the aggregate counts would be fine, but the data in one individual pass would not be okay, and the test would not detect that.I suggest something like this:```[&](const Status&) {  if (++num_picks == 7) {    if (servers_[0]->service_.request_count() == 1 &&        servers_[1]->service_.request_count() == 3 &&        servers_[2]->service_.request_count() == 3) {      if (++num_passes == 3) return false;    } else {      num_passes = 0;    }    num_picks = 0;    ResetCounters();  }  return true;}```Note that this lambda is now duplicated in about 3 different places, so it might make sense to refactor it into a helper function, parameterized by the expected counts to see for each server in each pass.",X
1644595,gnossen,https://api.github.com/repos/grpc/grpc/pulls/31769,1088398070,2023-01-26T22:21:03Z,src/python/grpcio/grpc/__init__.py,"@@ -616,7 +646,8 @@ def __call__(self, metadata, error): class AuthMetadataPlugin(abc.ABC):     """"""A specification for custom authentication."""""" -    def __call__(self, context, callback):+    def __call__(self, contex: AuthMetadataContext,","Actually, now that I think about it, the name of this parameter doesn't matter since it's positional and this is just the interface, not a concrete implementation.",
1644595,gnossen,https://api.github.com/repos/grpc/grpc/pulls/31769,1088431865,2023-01-26T23:13:08Z,src/python/grpcio/grpc/__init__.py,"@@ -1160,7 +1205,8 @@ def send_initial_metadata(self, initial_metadata):         raise NotImplementedError()      @abc.abstractmethod-    def set_trailing_metadata(self, trailing_metadata):+    def set_trailing_metadata(+            self, trailing_metadata: Optional[MetadataType]) -> None:","Your example is the opposite of the situation above. `Optional[int]` should be on the parent, not the child. The following, _does_ fail with `pytype` for me:```pythonimport abcfrom typing import Optionalclass A(metaclass=abc.ABCMeta):    @abc.abstractmethod    def foo(self, bar: Optional[int]) -> None:        raise NotImplementedError()class B(A):    def foo(self, bar: int) -> None:        returnb = B()print(b.foo(123))``````File ""/usr/local/google/home/rbellevi/dev/tmp/pytype-testing/subclass2.py"", line 11, in B: Overriding method signature mismatch [signature-mismatch]  Base signature: 'def A.foo(self, bar: Optional[int]) -> None'.  Subclass signature: 'def B.foo(self, bar: int) -> None'.  Type mismatch for parameter 'bar'.```We need to get to the bottom of why the pytype check running in CI did not catch this.",
1644595,gnossen,https://api.github.com/repos/grpc/grpc/pulls/31769,1088448034,2023-01-26T23:45:06Z,tools/internal_ci/linux/grpc_python_bazel_test_in_docker.sh,"@@ -19,6 +19,8 @@ RESULTSTORE_RESULTS_FLAG=""--bazelrc=tools/remote_build/include/test_locally_with TEST_TARGETS=""//src/python/... //tools/distrib/python/grpcio_tools/... //examples/python/..."" BAZEL_FLAGS=""--test_output=errors"" +python3 -m pip install typeguard","[We need to include this dependency via Bazel](https://github.com/grpc/grpc/blob/843cf42d6a76291b98be267152a3c5d99de8c965/requirements.bazel.txt), not out of band.",
1644595,gnossen,https://api.github.com/repos/grpc/grpc/pulls/31769,1088448618,2023-01-26T23:45:52Z,tools/run_tests/helper_scripts/build_python.sh,"@@ -165,7 +165,7 @@ pip_install_dir_and_deps() { pip_install -U gevent  pip_install --upgrade cython-pip_install --upgrade six protobuf>=4.21.3+pip_install --upgrade six protobuf>=4.21.3 typeguard","Likewise, since `typeguard` is only a dependency of a Bazel-run test, we should not be installing it at the system level here.",
85715732,yousukseung,https://api.github.com/repos/grpc/grpc/pulls/32106,1088529663,2023-01-27T02:16:13Z,src/core/ext/filters/backend_metrics/backend_metric_filter.cc,"@@ -18,29 +18,29 @@ TraceFlag grpc_backend_metric_filter_trace(false, ""backend_metric_filter""); absl::optional<std::string> BackendMetricFilter::MaybeSerializeBackendMetrics(     BackendMetricProvider* provider) const {   if (provider == nullptr) return absl::nullopt;-  BackendMetricData d = provider->GetBackendMetricData();+  absl::optional<BackendMetricData> d = provider->GetBackendMetricData();+  if (d == absl::nullopt) return absl::nullopt;","Done, it no longer returns an optional.",
8676893,lripoche,https://api.github.com/repos/grpc/grpc/pulls/31183,1089050715,2023-01-27T14:52:43Z,bazel/grpc_extra_deps.bzl,"@@ -53,7 +56,7 @@ def grpc_extra_deps(ignore_version_differences = False):     api_dependencies()      go_rules_dependencies()-    go_register_toolchains(version = ""1.18"")+    go_register_toolchains(version = go_version if go_version != ""host"" else None)","> So if go_version is ""host"" here, we pass None to go_register_toolchains? Yes> This seems like it would be used for [registering a custom toolchain](https://github.com/bazelbuild/rules_go/blob/master/go/toolchains.rst#registering-a-custom-sdk), not using [the installed toolchain](https://github.com/bazelbuild/rules_go/blob/master/go/toolchains.rst#using-the-installed-go-sdk).I was not aware of this but it makes using ""host"" confusing. Alternatively I could use another string such as `bazel-toolchains`.> Is there any reason not to just pass the go_version kwarg of grpc_extra_deps unmodified to go_register_toolchains?It would not work as by default `grpc_extra_deps` passes `version = ""1.18""` to `go_register_toolchains`, making `go_version` useless. From [rules_go source code](https://github.com/bazelbuild/rules_go/blob/8d309d5af15814b4096d80b60f80fa86128c43f2/go/private/sdk.bzl#L544):```def go_register_toolchains(version = None, nogo = None, go_version = None, experiments = None):    """"""See /go/toolchains.rst#go-register-toolchains for full documentation.""""""    if not version:        version = go_version  # old name```",
2793282,veblush,https://api.github.com/repos/grpc/grpc/pulls/31916,1089202511,2023-01-27T16:57:16Z,tools/run_tests/run_tests.py,"@@ -477,7 +477,7 @@ def _compiler_options(self, use_docker, compiler):             _check_compiler(compiler, ['default', 'cmake'])          if compiler == 'default' or compiler == 'cmake':-            return ('debian11', [])+            return ('debian11', [""-DCMAKE_CXX_STANDARD=14""])",This is required because of Apple clang which uses C++98 by default (yay). Also this is only for tests and gRPC library targets don't specify it so that C++ version can be picked by applications.,
2793282,veblush,https://api.github.com/repos/grpc/grpc/pulls/32200,1089253462,2023-01-27T17:49:50Z,templates/gRPC-C++.podspec.template,"@@ -136,7 +136,9 @@       'USER_HEADER_SEARCH_PATHS' => '""$(PODS_TARGET_SRCROOT)""'${""\\""}           ' ""$(PODS_TARGET_SRCROOT)/src/core/ext/upb-generated""'${""\\""}           ' ""$(PODS_TARGET_SRCROOT)/src/core/ext/upbdefs-generated""'${""\\""}-          ' ""$(PODS_TARGET_SRCROOT)/third_party/**""',+          ' ""$(PODS_TARGET_SRCROOT)/third_party/re2""'${""\\""}+          ' ""$(PODS_TARGET_SRCROOT)/third_party/upb""'${""\\""}+          ' ""$(PODS_TARGET_SRCROOT)/third_party/xxhash""',",We used to manage a list of dependencies to third_party and but it changed by https://github.com/grpc/grpc/pull/27609 so I used it to find these dependencies.,
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32106,1089255911,2023-01-27T17:52:42Z,include/grpcpp/ext/server_metric_recorder.h,"@@ -27,11 +27,9 @@ #include ""absl/strings/string_view.h"" #include ""absl/types/optional.h"" -#include <grpcpp/impl/sync.h>+#include ""src/core/ext/filters/client_channel/lb_policy/backend_metric_data.h""","I think the `BackendMetricDataState` struct can just be a private data member of `ServerMetricRecorder`.It doesn't make sense for this struct to be in backend_metric_data.h, because this struct is used only on the server side, and that file is for a struct that is used on both the client and server side.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32106,1089262661,2023-01-27T18:00:42Z,src/core/ext/filters/backend_metrics/backend_metric_filter.cc,"@@ -18,29 +18,29 @@ TraceFlag grpc_backend_metric_filter_trace(false, ""backend_metric_filter""); absl::optional<std::string> BackendMetricFilter::MaybeSerializeBackendMetrics(     BackendMetricProvider* provider) const {   if (provider == nullptr) return absl::nullopt;-  BackendMetricData d = provider->GetBackendMetricData();+  absl::optional<BackendMetricData> d = provider->GetBackendMetricData();+  if (d == absl::nullopt) return absl::nullopt;","You still need to add the `bool have_data` check, so that we don't actually populate the metadata if we have no data to report.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32106,1089296925,2023-01-27T18:39:40Z,include/grpcpp/ext/server_metric_recorder.h,"@@ -76,22 +81,21 @@ class ServerMetricRecorder {   friend class grpc::BackendMetricState;   friend class OrcaService; -  // Returns a pair of backend metrics recorded and the sequence number-  // associated with the current data. Backend metrics will be nullopt if empty.-  // Returned metrics are guaranteed to be identical between two calls if the-  // sequence numbers are identical. Returns {nullopt, seq} if the caller sets-  // `last_seq` and this matches with the current sequence number.-  std::pair<absl::optional<grpc_core::BackendMetricData>, uint64_t> GetMetrics(+  // Updates the metric state by applying `updater` to the data and incrementing+  // the sequence number.+  template <typename Updater>",I don't think this needs to be a template.  The parameter can be of type `std::function<void(BackendMetricData*)>`.,
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32106,1089301765,2023-01-27T18:45:42Z,src/cpp/server/backend_metric_recorder.cc,"@@ -33,32 +36,39 @@ bool IsUtilizationValid(double utilization) { // QPS must be in [0, infy). bool IsQpsValid(double qps) { return qps >= 0.0; } -bool IsEmpty(const BackendMetricData& data) {-  return !IsUtilizationValid(data.cpu_utilization) &&-         !IsUtilizationValid(data.mem_utilization) && !IsQpsValid(data.qps) &&-         data.request_cost.empty() && data.utilization.empty();-}- grpc_core::TraceFlag grpc_backend_metric_trace(false, ""backend_metric""); }  // namespace  namespace grpc { namespace experimental { +ServerMetricRecorder::ServerMetricRecorder() {+  // Starts with an empty result.+  metric_state_ = std::make_shared<const BackendMetricDataState>();+}++template <typename Updater>+void ServerMetricRecorder::UpdateBackendMetricDataState(Updater updater) {+  internal::MutexLock lock(&mu_);+  BackendMetricDataState result = *metric_state_.get();+  updater(result.data);","Please pass this in as a pointer, since it's an output parameter.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32106,1089311964,2023-01-27T18:56:57Z,src/cpp/server/backend_metric_recorder.cc,"@@ -33,32 +36,39 @@ bool IsUtilizationValid(double utilization) { // QPS must be in [0, infy). bool IsQpsValid(double qps) { return qps >= 0.0; } -bool IsEmpty(const BackendMetricData& data) {-  return !IsUtilizationValid(data.cpu_utilization) &&-         !IsUtilizationValid(data.mem_utilization) && !IsQpsValid(data.qps) &&-         data.request_cost.empty() && data.utilization.empty();-}- grpc_core::TraceFlag grpc_backend_metric_trace(false, ""backend_metric""); }  // namespace  namespace grpc { namespace experimental { +ServerMetricRecorder::ServerMetricRecorder() {+  // Starts with an empty result.+  metric_state_ = std::make_shared<const BackendMetricDataState>();+}++template <typename Updater>+void ServerMetricRecorder::UpdateBackendMetricDataState(Updater updater) {+  internal::MutexLock lock(&mu_);+  BackendMetricDataState result = *metric_state_.get();+  updater(result.data);+  ++result.seq;+  metric_state_ =+      std::make_shared<const BackendMetricDataState>(std::move(result));","Instead of doing a `std::move()` on the whole `BackendMetricDataState` struct, which has to move a whole bunch of fields, I suggest creating a new `shared_ptr<>` at the top, so that you can just `std::move()` a single pointer into place here:```auto* new_state = std::make_shared<BackendMetricDataState>(*metric_state);updater(&new_state->data);++new_state->seq;metric_state_ = std::move(new_state);```",X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32106,1089348473,2023-01-27T19:30:31Z,include/grpcpp/ext/server_metric_recorder.h,"@@ -76,22 +81,21 @@ class ServerMetricRecorder {   friend class grpc::BackendMetricState;   friend class OrcaService; -  // Returns a pair of backend metrics recorded and the sequence number-  // associated with the current data. Backend metrics will be nullopt if empty.-  // Returned metrics are guaranteed to be identical between two calls if the-  // sequence numbers are identical. Returns {nullopt, seq} if the caller sets-  // `last_seq` and this matches with the current sequence number.-  std::pair<absl::optional<grpc_core::BackendMetricData>, uint64_t> GetMetrics(+  // Updates the metric state by applying `updater` to the data and incrementing+  // the sequence number.+  template <typename Updater>+  void UpdateBackendMetricDataState(Updater updater);++  grpc_core::BackendMetricData GetMetrics() const;+  // Returned metric data is guaranteed to be identical between two calls if the+  // sequence numbers match. Returns null if the caller sets `last_seq` and+  // this matches with the current sequence number i.e. cache hit.+  std::shared_ptr<const grpc_core::BackendMetricDataState> GetMetricsIfChanged(","Now that we're storing the sequence number in the same `shared_ptr<>` as the data, I think we can just return the `shared_ptr` unconditionally, and let the caller deal with the sequence number check.  In other words, we can just have this:```std::shared_ptr<const BackendMetricDataState> GetMetricsAndSequenceNumber() {  MutexLock lock(&mu_);  return metric_state_;}```In `OrcaService`, we can do something like this:```auto metrics = server_metric_recorder_->GetMetricsAndSequenceNumber();if (metrics->sequence_number != last_sequence_number_) {  response_slice_ = BuildResponseProto(metrics->data);  last_sequence_number_ = metrics->sequence_number;}return response_slice_;```",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32106,1089379626,2023-01-27T20:01:23Z,test/cpp/end2end/client_lb_end2end_test.cc,"@@ -2882,43 +2890,55 @@ TEST_F(ControlPlaneStatusRewritingTest, RewritesFromConfigSelector) { // WeightedRoundRobinTest // -using WeightedRoundRobinTest = ClientLbEnd2endTest;--TEST_F(WeightedRoundRobinTest, Basic) {+const char kServiceConfigPerCall[] =+    ""{\n""+    ""  \""loadBalancingConfig\"": [\n""+    ""    {\""weighted_round_robin_experimental\"": {\n""+    ""      \""blackoutPeriod\"": \""0s\""\n""+    ""    }}\n""+    ""  ]\n""+    ""}"";++const char kServiceConfigOob[] =+    ""{\n""+    ""  \""loadBalancingConfig\"": [\n""+    ""    {\""weighted_round_robin_experimental\"": {\n""+    ""      \""blackoutPeriod\"": \""0s\"",\n""+    ""      \""enableOobLoadReport\"": true\n""+    ""    }}\n""+    ""  ]\n""+    ""}"";++class WeightedRoundRobinParamTest+    : public ClientLbEnd2endTest,+      public ::testing::WithParamInterface<const char*> {};++TEST_P(WeightedRoundRobinParamTest, Basic) {   const int kNumServers = 3;   StartServers(kNumServers);-  // Tell each server to report the appropriate CPU utilization.-  xds::data::orca::v3::OrcaLoadReport load_report;-  load_report.set_rps_fractional(100);-  load_report.set_cpu_utilization(0.9);-  servers_[0]->service_.SetLoadReport(load_report);-  load_report.set_cpu_utilization(0.3);-  servers_[1]->service_.SetLoadReport(load_report);-  servers_[2]->service_.SetLoadReport(load_report);+  // Report server metrics that should give 1:3:3 WRR picks.+  servers_[0]->server_metric_recorder_.SetCpuUtilization(0.9);+  servers_[0]->server_metric_recorder_.SetQps(100);+  servers_[1]->server_metric_recorder_.SetCpuUtilization(0.3);+  servers_[1]->server_metric_recorder_.SetQps(100);+  servers_[2]->server_metric_recorder_.SetCpuUtilization(0.3);+  servers_[2]->server_metric_recorder_.SetQps(100);   // Create channel.   auto response_generator = BuildResolverResponseGenerator();   auto channel = BuildChannel("""", response_generator);   auto stub = BuildStub(channel);-  const char kServiceConfig[] =-      ""{\n""-      ""  \""loadBalancingConfig\"": [\n""-      ""    {\""weighted_round_robin_experimental\"": {\n""-      ""      \""blackoutPeriod\"": \""0s\""\n""-      ""    }}\n""-      ""  ]\n""-      ""}"";-  response_generator.SetNextResolution(GetServersPorts(), kServiceConfig);+  response_generator.SetNextResolution(GetServersPorts(), GetParam());   // Wait for the right set of WRR picks.   size_t num_picks = 0;   SendRpcsUntil(DEBUG_LOCATION, stub, [&](const Status&) {-    if (++num_picks == 7) {+    if (++num_picks == 21) {","I think that TotT is primarily talking about making sure that all of the data that affects a test is defined in the test itself.  But here we're not talking about data, we're talking about code.  I think it's totally reasonable to have helper functions for common operations like this, especially if they're represented in an API that makes the test more readable.I think you can do this as follows:```class WeightedRoundRobinTest : public ClientLbEnd2endTest { protected:  void ExpectWeightedRoundRobinPicks(      const grpc_core::DebugLocation& location,      const std::unique_ptr<grpc::testing::EchoTestService::Stub>& stub,      const std::vector<size_t>& expected_weights, size_t total_passes) {    GPR_ASSERT(expected_weights.size() == servers_.size());    size_t total_picks_per_pass = 0;    for (size_t picks : expected_weights) {      total_picks_per_pass += picks;    }    size_t num_picks = 0;    size_t num_passes = 0;    SendRpcsUntil(        location, stub, [&](const Status&) {          if (++num_picks == total_picks_per_pass) {            bool match = true;            for (size_t i = 0; i < expected_weights.size(); ++i) {              if (servers_[i]->service_.request_count() != expected_weights[i]) {                match = false;                break;              }            }            if (match) {              if (++num_passes = total_passes) return false;            } else {              num_passes = 0;            }            num_picks = 0;            ResetCounters();          }          return true;        });  }};class WeightedRoundRobinParamTest    : public WeightedRoundRobinTest,      public ::testing::WithParamInterface<const char*> {};```Then, in the individual tests, you can do something like this:```ExpectWeightedRoundRobinPicks(    DEBUG_LOCATION, stub, {1, 3, 3}, 3);```",X
52979934,matthewstevenson88,https://api.github.com/repos/grpc/grpc/pulls/32215,1089462067,2023-01-27T21:41:27Z,src/core/tsi/ssl_transport_security.cc,"@@ -144,6 +144,7 @@ struct tsi_ssl_frame_protector { static gpr_once g_init_openssl_once = GPR_ONCE_INIT; static int g_ssl_ctx_ex_factory_index = -1; static const unsigned char kSslSessionIdContext[] = {'g', 'r', 'p', 'c'};+static int g_ssl_ex_ca_cert_index = -1;","Here and throughout: we seem to always refer to ""ca cert"", but really we're interested in the root CA cert that was used to verify the chain. Can we rename instead say (e.g.) ""verified root cert""? For example, this variable would become `g_ssl_ex_verified_root_cert_index`?",
52979934,matthewstevenson88,https://api.github.com/repos/grpc/grpc/pulls/32215,1089464040,2023-01-27T21:43:50Z,test/core/tsi/ssl_transport_security_test.cc,"@@ -191,6 +191,18 @@ static void ssl_test_setup_handshakers(tsi_test_fixture* fixture) {       TSI_OK); } +static void check_ca_cert_subject(ssl_tsi_test_fixture* /*ssl_fixture*/,","IIUC, we are only testing in the case when verification is successful and there are no intermediate CAs in the chain. I think it would be good to test in the following cases as well:1. When verification fails (e.g. we can use the self-signed cert in the /src/core/tsi/test_creds directory).2. When verification succeeds but there is >=1 intermediate CA in the chain. (If there are no examples of this in /src/core/tsi/test_creds let me know and I can help you generate them.)",
16962414,gtcooke94,https://api.github.com/repos/grpc/grpc/pulls/32215,1089479483,2023-01-27T22:07:10Z,src/core/tsi/ssl_transport_security.cc,"@@ -853,6 +882,38 @@ static int NullVerifyCallback(int /*preverify_ok*/, X509_STORE_CTX* /*ctx*/) {   return 1; } +static int RootCertExtractCallback(int preverify_ok, X509_STORE_CTX* ctx) {+  // There's a case where this function is set in SSL_CTX_set_verify and a CRL+  // related callback is set with X509_STORE_set_verify_cb. They overlap and+  // this will take precedence, thus we need to ensure the CRL related callback+  // is still called+  X509_VERIFY_PARAM* param = X509_STORE_CTX_get0_param(ctx);+  auto flags = X509_VERIFY_PARAM_get_flags(param);+  if (flags & X509_V_FLAG_CRL_CHECK) {+    preverify_ok = verify_cb(preverify_ok, ctx);+  }++  if (preverify_ok == 0) {+    return 0;+  }++  // If we're here, verification was successful+  // Get the verified chain from the X509_STORE_CTX and put it on the SSL object+  // so that we have access to it when populating the tsi_peer+  STACK_OF(X509)* chain = X509_STORE_CTX_get0_chain(ctx);+  if (chain == nullptr) {+    return 1;","Above this is a line for `if preverify_ok == 0 return 0;`, so behaviorally here `preverify_ok` will always be 1, but it could be cleaner to just re-use `preverify_ok`.One of the intents here was that, if `preverify_ok` is _not_ ok (`== 0`) then there won't be a verified chain so we should not continue.Thoughts?",
16962414,gtcooke94,https://api.github.com/repos/grpc/grpc/pulls/32215,1089480388,2023-01-27T22:08:32Z,src/core/tsi/ssl_transport_security.cc,"@@ -853,6 +882,38 @@ static int NullVerifyCallback(int /*preverify_ok*/, X509_STORE_CTX* /*ctx*/) {   return 1; } +static int RootCertExtractCallback(int preverify_ok, X509_STORE_CTX* ctx) {+  // There's a case where this function is set in SSL_CTX_set_verify and a CRL+  // related callback is set with X509_STORE_set_verify_cb. They overlap and+  // this will take precedence, thus we need to ensure the CRL related callback+  // is still called+  X509_VERIFY_PARAM* param = X509_STORE_CTX_get0_param(ctx);+  auto flags = X509_VERIFY_PARAM_get_flags(param);+  if (flags & X509_V_FLAG_CRL_CHECK) {+    preverify_ok = verify_cb(preverify_ok, ctx);+  }++  if (preverify_ok == 0) {+    return 0;+  }++  // If we're here, verification was successful+  // Get the verified chain from the X509_STORE_CTX and put it on the SSL object+  // so that we have access to it when populating the tsi_peer+  STACK_OF(X509)* chain = X509_STORE_CTX_get0_chain(ctx);+  if (chain == nullptr) {+    return 1;+  }++  // The ca cert is the last in the chain+  X509* ca_cert = sk_X509_value(chain, sk_X509_num(chain) - 1);","Good idea, I'll add the additional checks for this and for `nullptr`. I think if `chain` were empty but not `nullptr` this would have an issue",
16962414,gtcooke94,https://api.github.com/repos/grpc/grpc/pulls/32215,1089481905,2023-01-27T22:11:13Z,src/core/tsi/ssl_transport_security.cc,"@@ -144,6 +144,7 @@ struct tsi_ssl_frame_protector { static gpr_once g_init_openssl_once = GPR_ONCE_INIT; static int g_ssl_ctx_ex_factory_index = -1; static const unsigned char kSslSessionIdContext[] = {'g', 'r', 'p', 'c'};+static int g_ssl_ex_ca_cert_index = -1;","I like that naming better, will change to that.",X
16962414,gtcooke94,https://api.github.com/repos/grpc/grpc/pulls/32215,1089483696,2023-01-27T22:14:18Z,test/core/tsi/ssl_transport_security_test.cc,"@@ -191,6 +191,18 @@ static void ssl_test_setup_handshakers(tsi_test_fixture* fixture) {       TSI_OK); } +static void check_ca_cert_subject(ssl_tsi_test_fixture* /*ssl_fixture*/,+                                  const tsi_peer* peer) {+  const tsi_peer_property* ca_cert_subject =+      tsi_peer_get_property_by_name(peer, TSI_X509_CA_SUBJECT_PEER_PROPERTY);+  ASSERT_NE(ca_cert_subject, nullptr);+  const char* expected_match =","`const char* expected_match` is used through this test file, [example](https://github.com/grpc/grpc/blob/a4e3a22f5179fabc1670dcfa6d58e4adfaf7b02a/test/core/tsi/ssl_transport_security_test.cc#L322)",
16962414,gtcooke94,https://api.github.com/repos/grpc/grpc/pulls/32215,1089523074,2023-01-27T22:48:38Z,src/core/tsi/ssl_transport_security.cc,"@@ -1146,6 +1211,17 @@ static tsi_result ssl_handshaker_result_extract_peer(       &peer->properties[peer->property_count]);   if (result != TSI_OK) return result;   peer->property_count++;++  if (ca_cert != nullptr) {+    result = peer_property_from_x509_subject(+        ca_cert, &peer->properties[peer->property_count], true);+    if (result != TSI_OK) {+      gpr_log(GPR_ERROR, ""resut: %d"", static_cast<int>(result));","We had placed this log here for debugging - do you think we actually need it? Above a lot of the properties follow the pattern `if result != TSI_OK) return result;`. I think the `peer_chain` is the only property above that doesn't return result.I guess if we reach here, what we're saying is ""there is a root cert that is set in the ex_data, but adding it as a property to `tsi_peer` is failing."" So what's our desired behavior here?",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32009,1089531297,2023-01-27T23:04:10Z,src/core/ext/filters/client_channel/lb_policy/xds/xds_override_host.cc,"@@ -785,7 +796,7 @@ void XdsOverrideHostLbConfig::JsonPostLoad(const Json& json,     auto host_status_list = LoadJsonObjectField<std::vector<std::string>>(         json.object_value(), args, ""overrideHostStatus"", errors,         /*required=*/false);-    if (host_status_list.has_value()) {+    if (host_status_list.has_value() && !host_status_list->empty()) {","I don't think this change is correct.  The list should never be empty in practice, but if it was, I think we should just accept the empty set, in which case we will not actually use any override hosts.Alternatively, if there's some reason we want to not support this case, then I think we should reject the config with an error if the list is empty.  But I don't think we should just use the default in this case, because the default should apply only if the field is not specified, not if the field is specified but has an invalid value.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32009,1089537857,2023-01-27T23:16:28Z,test/cpp/end2end/xds/xds_end2end_test_lib.h,"@@ -787,8 +787,10 @@ class XdsEnd2endTest : public ::testing::TestWithParam<XdsTestType> {   // Sends an RPC with the specified options.   // If response is non-null, it will be populated with the response.   // Returns the status of the RPC.-  Status SendRpc(const RpcOptions& rpc_options = RpcOptions(),-                 EchoResponse* response = nullptr);+  Status SendRpc(+      const RpcOptions& rpc_options = RpcOptions(),+      EchoResponse* response = nullptr,+      std::map<std::string, std::string, std::less<>>* metadata = nullptr);","Please call this parameter `server_initial_metadata`, to differentiate it from client initial metadata or server trailing metadata.  Also, please document the parameter in the comment above.",X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32009,1089547238,2023-01-27T23:36:13Z,test/cpp/end2end/xds/xds_end2end_test_lib.h,"@@ -787,8 +787,10 @@ class XdsEnd2endTest : public ::testing::TestWithParam<XdsTestType> {   // Sends an RPC with the specified options.   // If response is non-null, it will be populated with the response.   // Returns the status of the RPC.-  Status SendRpc(const RpcOptions& rpc_options = RpcOptions(),-                 EchoResponse* response = nullptr);+  Status SendRpc(+      const RpcOptions& rpc_options = RpcOptions(),+      EchoResponse* response = nullptr,+      std::map<std::string, std::string, std::less<>>* metadata = nullptr);","It's possible that there can be multiple headers with the same name, so I think we should use a data structure here that can support that.  I suggest either `std::multimap<>` or something like `std::vector<std::pair<std::string, std::string>>`.  (We use the latter for request metadata (see line 753 above), but the former would probably be better in this case, since it would make it easier to find a particular key.)",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32009,1089549916,2023-01-27T23:43:34Z,test/cpp/end2end/xds/xds_end2end_test_lib.h,"@@ -811,16 +813,21 @@ class XdsEnd2endTest : public ::testing::TestWithParam<XdsTestType> {   struct RpcResult {     Status status;     EchoResponse response;+    std::map<std::string, std::string> initial_metadata;","Please call this `server_initial_metadata`, to differentiate it from client initial metadata.",X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32009,1089555241,2023-01-27T23:58:36Z,test/cpp/end2end/xds/xds_override_host_end2end_test.cc,"@@ -0,0 +1,241 @@+// Copyright 2023 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++#include <chrono>+#include <string>+#include <thread>+#include <vector>++#include <gmock/gmock.h>+#include <gtest/gtest.h>++#include ""absl/strings/str_format.h""+#include ""absl/strings/str_join.h""+#include ""absl/strings/str_split.h""++#include ""src/core/ext/filters/client_channel/backup_poller.h""+#include ""src/core/lib/gprpp/match.h""+#include ""src/proto/grpc/testing/xds/v3/cluster.grpc.pb.h""+#include ""src/proto/grpc/testing/xds/v3/outlier_detection.grpc.pb.h""+#include ""src/proto/grpc/testing/xds/v3/router.grpc.pb.h""+#include ""src/proto/grpc/testing/xds/v3/stateful_session.grpc.pb.h""+#include ""src/proto/grpc/testing/xds/v3/stateful_session_cookie.pb.h""+#include ""test/core/util/scoped_env_var.h""+#include ""test/cpp/end2end/xds/xds_end2end_test_lib.h""++namespace grpc {+namespace testing {+namespace {+using ::envoy::extensions::filters::http::stateful_session::v3::StatefulSession;+using ::envoy::extensions::filters::network::http_connection_manager::v3::+    HttpFilter;+using ::envoy::extensions::http::stateful_session::cookie::v3 ::+    CookieBasedSessionState;++class OverrideHostTest : public XdsEnd2endTest {+ protected:+  struct Cookie {+    std::string value;+    std::set<std::string> attributes;+    std::string raw;+  };++  static std::map<std::string, Cookie, std::less<>> ParseCookies(+      const std::map<std::string, std::string, std::less<>>& initial_metadata) {+    auto it = initial_metadata.find(""set-cookie"");+    if (it == initial_metadata.end()) {+      return {};+    }+    // Right now we only support a single cookie. This will be revised as+    // semantics are better understood+    std::pair<absl::string_view, absl::string_view> name_value =+        absl::StrSplit(it->second, absl::MaxSplits('=', 1));+    if (name_value.first.empty()) {+      return {};+    }+    std::pair<absl::string_view, absl::string_view> value_attrs =+        absl::StrSplit(name_value.second, absl::MaxSplits(';', 1));+    std::set<std::string> attributes;+    for (absl::string_view segment : absl::StrSplit(name_value.second, ';')) {+      attributes.insert(std::string(absl::StripAsciiWhitespace(segment)));+    }+    return {{std::string(name_value.first),+             Cookie({std::string(value_attrs.first), std::move(attributes),+                     std::string(name_value.second)})}};+  }++  static absl::optional<std::string> GetStatefulSessionCookie(+      const std::map<std::string, std::string, std::less<>>& initial_metadata,+      absl::string_view cookie_name = ""grpc_session_cookie"") {+    auto cookies = ParseCookies(initial_metadata);+    auto it = cookies.find(cookie_name);+    if (it == cookies.end()) {+      return absl::nullopt;+    }+    Cookie& grpc_session_cookie = it->second;+    EXPECT_FALSE(grpc_session_cookie.value.empty());+    EXPECT_NE(grpc_session_cookie.attributes.find(""HttpOnly""),+              grpc_session_cookie.attributes.end())+        << grpc_session_cookie.raw;+    return grpc_session_cookie.value;+  }++  // Builds a Listener with Fault Injection filter config. If the http_fault+  // is nullptr, then assign an empty filter config. This filter config is+  // required to enable the fault injection features.+  static Listener BuildListenerWithStatefulSessionFilter() {+    CookieBasedSessionState cookie_state;+    cookie_state.mutable_cookie()->set_name(""grpc_session_cookie"");+    StatefulSession stateful_session;+    stateful_session.mutable_session_state()->mutable_typed_config()->PackFrom(+        cookie_state);+    HttpConnectionManager http_connection_manager;+    Listener listener;+    listener.set_name(kServerName);+    HttpFilter* session_filter = http_connection_manager.add_http_filters();+    session_filter->set_name(""envoy.stateful_session"");+    session_filter->mutable_typed_config()->PackFrom(stateful_session);+    HttpFilter* router_filter = http_connection_manager.add_http_filters();+    router_filter->set_name(""router"");+    router_filter->mutable_typed_config()->PackFrom(+        envoy::extensions::filters::http::router::v3::Router());+    listener.mutable_api_listener()->mutable_api_listener()->PackFrom(+        http_connection_manager);+    return listener;+  }++  size_t GetAndResetRequestCount(size_t backend_idx, RpcService service) {+    size_t result = 1000;  // Will know there's a new service...+    switch (service) {+      case RpcService::SERVICE_ECHO:+        result = backends_[backend_idx]->backend_service()->request_count();+        backends_[backend_idx]->backend_service()->ResetCounters();+        break;+      case RpcService::SERVICE_ECHO1:+        result = backends_[backend_idx]->backend_service1()->request_count();+        backends_[backend_idx]->backend_service1()->ResetCounters();+        break;+      case RpcService::SERVICE_ECHO2:+        result = backends_[backend_idx]->backend_service2()->request_count();+        backends_[backend_idx]->backend_service2()->ResetCounters();+        break;+    }+    return result;+  }++  void CheckBackendCallCounts(+      absl::variant<std::function<int(size_t backend_idx)>, int> call_count,+      RpcService service = RpcService::SERVICE_ECHO,+      const grpc_core::DebugLocation& debug_location = DEBUG_LOCATION) {+    for (size_t i = 0; i < backends_.size(); i++) {+      EXPECT_EQ(+          grpc_core::Match(+              call_count,+              [i](std::function<int(size_t backend_idx)> fn) { return fn(i); },+              [](int count) { return count; }),+          GetAndResetRequestCount(i, service))+          << ""Backend "" << i << ""\n""+          << debug_location.file() << "":"" << debug_location.line();+      // Make sure no other calls are there, mostly to prevent coding errors in+      // tests+      EXPECT_EQ(0, backends_[i]->backend_service()->request_count())+          << ""Backend "" << i << ""\n""+          << debug_location.file() << "":"" << debug_location.line();+      EXPECT_EQ(0, backends_[i]->backend_service1()->request_count())+          << ""Backend "" << i << ""\n""+          << debug_location.file() << "":"" << debug_location.line();+      EXPECT_EQ(0, backends_[i]->backend_service2()->request_count())+          << ""Backend "" << i << ""\n""+          << debug_location.file() << "":"" << debug_location.line();+    }+  }+};++INSTANTIATE_TEST_SUITE_P(XdsTest, OverrideHostTest,+                         ::testing::Values(XdsTestType()), &XdsTestType::Name);+TEST_P(OverrideHostTest, HappyPath) {+  CreateAndStartBackends(2);+  auto cluster = default_cluster_;+  cluster.set_lb_policy(Cluster::ROUND_ROBIN);+  balancer_->ads_service()->SetCdsResource(cluster);+  SetListenerAndRouteConfiguration(balancer_.get(),+                                   BuildListenerWithStatefulSessionFilter(),+                                   default_route_config_);+  EdsResourceArgs args({{""locality0"", CreateEndpointsForBackends()}});+  balancer_->ads_service()->SetEdsResource(BuildEdsResource(args));+  balancer_->ads_service()->SetRdsResource(RouteConfiguration());+  WaitForBackend(DEBUG_LOCATION, 0, /*check_status=*/nullptr,","These two calls can be combined into one:```WaitForAllBackends(DEBUG_LOCATION);```Note that the `check_status` and `wait_options` parameters are optional, so there's no need to specify them if you're just using the defaults.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32009,1089557735,2023-01-28T00:06:35Z,test/cpp/end2end/xds/xds_end2end_test_lib.h,"@@ -811,16 +813,21 @@ class XdsEnd2endTest : public ::testing::TestWithParam<XdsTestType> {   struct RpcResult {     Status status;     EchoResponse response;+    std::map<std::string, std::string> initial_metadata;   };-  void SendRpcsUntil(const grpc_core::DebugLocation& debug_location,-                     std::function<bool(const RpcResult&)> continue_predicate,-                     int timeout_ms = 15000,-                     const RpcOptions& rpc_options = RpcOptions());+  void SendRpcsUntil(+      const grpc_core::DebugLocation& debug_location,+      std::function<bool(const RpcResult&)> continue_predicate,+      int timeout_ms = 15000, const RpcOptions& rpc_options = RpcOptions(),+      std::vector<std::map<std::string, std::string, std::less<>>>*","This parameter is not necessary.  Instead, the caller can access the server initial metadata from inside the `continue_predicate` function.",X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32009,1089561114,2023-01-28T00:14:20Z,test/cpp/end2end/xds/xds_end2end_test_lib.h,"@@ -811,16 +813,21 @@ class XdsEnd2endTest : public ::testing::TestWithParam<XdsTestType> {   struct RpcResult {     Status status;     EchoResponse response;+    std::map<std::string, std::string> initial_metadata;   };-  void SendRpcsUntil(const grpc_core::DebugLocation& debug_location,-                     std::function<bool(const RpcResult&)> continue_predicate,-                     int timeout_ms = 15000,-                     const RpcOptions& rpc_options = RpcOptions());+  void SendRpcsUntil(+      const grpc_core::DebugLocation& debug_location,+      std::function<bool(const RpcResult&)> continue_predicate,+      int timeout_ms = 15000, const RpcOptions& rpc_options = RpcOptions(),+      std::vector<std::map<std::string, std::string, std::less<>>>*+          responses_initial_metadata = nullptr);    // Sends the specified number of RPCs and fails if the RPC fails.-  void CheckRpcSendOk(const grpc_core::DebugLocation& debug_location,-                      const size_t times = 1,-                      const RpcOptions& rpc_options = RpcOptions());+  void CheckRpcSendOk(+      const grpc_core::DebugLocation& debug_location, const size_t times = 1,+      const RpcOptions& rpc_options = RpcOptions(),+      std::vector<std::map<std::string, std::string, std::less<>>>*","This parameter really doesn't make sense when `times` is greater than 1.  Any caller that is going to need to send more than one RPC but still needs to look at the metadata for each individual RPC will probably be looking at the metadata to decide what to do anyway, so they will likely use `SendRpcsUntil()` instead of `CheckRpcSendOk()` anyway.I suggest leaving this method as it was originally, without the new parameter, and instead adding a separate method that sends exactly one RPC and supports this new parameter:```void CheckOneRpcSendOk(    const grpc_core::DebugLocation& debug_location,    const RpcOptions& rpc_options = RpcOptions(),    std::map<std::string, std::string, std::less<>>* server_initial_metadata =        nullptr) {  EchoResponse response;  Status status = SendRpc(rpc_options, &response, server_initial_metadata);  EXPECT_TRUE(status.ok())      << ""code="" << status.error_code()      << "" message="" << status.error_message() << "" at ""      << debug_location.file() << "":"" << debug_location.line();  EXPECT_EQ(response.message(), kRequestMessage)      << debug_location.file() << "":"" << debug_location.line();}```For bonus points, you can find all existing callers of `CheckRpcSendOk()` that set `times` to 1 and change them to instead call `CheckOneRpcSendOk()`, and then you can make the `times` parameter of `CheckRpcSendOk()` non-optional.  But that's optional -- it's fine to leave this for a later cleanup if you'd prefer.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32009,1089575898,2023-01-28T01:00:48Z,test/cpp/end2end/xds/xds_override_host_end2end_test.cc,"@@ -0,0 +1,241 @@+// Copyright 2023 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++#include <chrono>+#include <string>+#include <thread>+#include <vector>++#include <gmock/gmock.h>+#include <gtest/gtest.h>++#include ""absl/strings/str_format.h""+#include ""absl/strings/str_join.h""+#include ""absl/strings/str_split.h""++#include ""src/core/ext/filters/client_channel/backup_poller.h""+#include ""src/core/lib/gprpp/match.h""+#include ""src/proto/grpc/testing/xds/v3/cluster.grpc.pb.h""+#include ""src/proto/grpc/testing/xds/v3/outlier_detection.grpc.pb.h""+#include ""src/proto/grpc/testing/xds/v3/router.grpc.pb.h""+#include ""src/proto/grpc/testing/xds/v3/stateful_session.grpc.pb.h""+#include ""src/proto/grpc/testing/xds/v3/stateful_session_cookie.pb.h""+#include ""test/core/util/scoped_env_var.h""+#include ""test/cpp/end2end/xds/xds_end2end_test_lib.h""++namespace grpc {+namespace testing {+namespace {+using ::envoy::extensions::filters::http::stateful_session::v3::StatefulSession;+using ::envoy::extensions::filters::network::http_connection_manager::v3::+    HttpFilter;+using ::envoy::extensions::http::stateful_session::cookie::v3 ::+    CookieBasedSessionState;++class OverrideHostTest : public XdsEnd2endTest {+ protected:+  struct Cookie {+    std::string value;+    std::set<std::string> attributes;+    std::string raw;+  };++  static std::map<std::string, Cookie, std::less<>> ParseCookies(+      const std::map<std::string, std::string, std::less<>>& initial_metadata) {+    auto it = initial_metadata.find(""set-cookie"");+    if (it == initial_metadata.end()) {+      return {};+    }+    // Right now we only support a single cookie. This will be revised as+    // semantics are better understood+    std::pair<absl::string_view, absl::string_view> name_value =+        absl::StrSplit(it->second, absl::MaxSplits('=', 1));+    if (name_value.first.empty()) {+      return {};+    }+    std::pair<absl::string_view, absl::string_view> value_attrs =+        absl::StrSplit(name_value.second, absl::MaxSplits(';', 1));+    std::set<std::string> attributes;+    for (absl::string_view segment : absl::StrSplit(name_value.second, ';')) {+      attributes.insert(std::string(absl::StripAsciiWhitespace(segment)));+    }+    return {{std::string(name_value.first),+             Cookie({std::string(value_attrs.first), std::move(attributes),+                     std::string(name_value.second)})}};+  }++  static absl::optional<std::string> GetStatefulSessionCookie(+      const std::map<std::string, std::string, std::less<>>& initial_metadata,+      absl::string_view cookie_name = ""grpc_session_cookie"") {+    auto cookies = ParseCookies(initial_metadata);+    auto it = cookies.find(cookie_name);+    if (it == cookies.end()) {+      return absl::nullopt;+    }+    Cookie& grpc_session_cookie = it->second;+    EXPECT_FALSE(grpc_session_cookie.value.empty());+    EXPECT_NE(grpc_session_cookie.attributes.find(""HttpOnly""),+              grpc_session_cookie.attributes.end())+        << grpc_session_cookie.raw;+    return grpc_session_cookie.value;+  }++  // Builds a Listener with Fault Injection filter config. If the http_fault+  // is nullptr, then assign an empty filter config. This filter config is+  // required to enable the fault injection features.+  static Listener BuildListenerWithStatefulSessionFilter() {+    CookieBasedSessionState cookie_state;+    cookie_state.mutable_cookie()->set_name(""grpc_session_cookie"");+    StatefulSession stateful_session;+    stateful_session.mutable_session_state()->mutable_typed_config()->PackFrom(+        cookie_state);+    HttpConnectionManager http_connection_manager;+    Listener listener;+    listener.set_name(kServerName);+    HttpFilter* session_filter = http_connection_manager.add_http_filters();+    session_filter->set_name(""envoy.stateful_session"");+    session_filter->mutable_typed_config()->PackFrom(stateful_session);+    HttpFilter* router_filter = http_connection_manager.add_http_filters();+    router_filter->set_name(""router"");+    router_filter->mutable_typed_config()->PackFrom(+        envoy::extensions::filters::http::router::v3::Router());+    listener.mutable_api_listener()->mutable_api_listener()->PackFrom(+        http_connection_manager);+    return listener;+  }++  size_t GetAndResetRequestCount(size_t backend_idx, RpcService service) {+    size_t result = 1000;  // Will know there's a new service...+    switch (service) {+      case RpcService::SERVICE_ECHO:+        result = backends_[backend_idx]->backend_service()->request_count();+        backends_[backend_idx]->backend_service()->ResetCounters();+        break;+      case RpcService::SERVICE_ECHO1:+        result = backends_[backend_idx]->backend_service1()->request_count();+        backends_[backend_idx]->backend_service1()->ResetCounters();+        break;+      case RpcService::SERVICE_ECHO2:+        result = backends_[backend_idx]->backend_service2()->request_count();+        backends_[backend_idx]->backend_service2()->ResetCounters();+        break;+    }+    return result;+  }++  void CheckBackendCallCounts(+      absl::variant<std::function<int(size_t backend_idx)>, int> call_count,+      RpcService service = RpcService::SERVICE_ECHO,+      const grpc_core::DebugLocation& debug_location = DEBUG_LOCATION) {+    for (size_t i = 0; i < backends_.size(); i++) {+      EXPECT_EQ(+          grpc_core::Match(+              call_count,+              [i](std::function<int(size_t backend_idx)> fn) { return fn(i); },+              [](int count) { return count; }),+          GetAndResetRequestCount(i, service))+          << ""Backend "" << i << ""\n""+          << debug_location.file() << "":"" << debug_location.line();+      // Make sure no other calls are there, mostly to prevent coding errors in+      // tests+      EXPECT_EQ(0, backends_[i]->backend_service()->request_count())+          << ""Backend "" << i << ""\n""+          << debug_location.file() << "":"" << debug_location.line();+      EXPECT_EQ(0, backends_[i]->backend_service1()->request_count())+          << ""Backend "" << i << ""\n""+          << debug_location.file() << "":"" << debug_location.line();+      EXPECT_EQ(0, backends_[i]->backend_service2()->request_count())+          << ""Backend "" << i << ""\n""+          << debug_location.file() << "":"" << debug_location.line();+    }+  }+};++INSTANTIATE_TEST_SUITE_P(XdsTest, OverrideHostTest,+                         ::testing::Values(XdsTestType()), &XdsTestType::Name);+TEST_P(OverrideHostTest, HappyPath) {+  CreateAndStartBackends(2);+  auto cluster = default_cluster_;+  cluster.set_lb_policy(Cluster::ROUND_ROBIN);+  balancer_->ads_service()->SetCdsResource(cluster);+  SetListenerAndRouteConfiguration(balancer_.get(),+                                   BuildListenerWithStatefulSessionFilter(),+                                   default_route_config_);+  EdsResourceArgs args({{""locality0"", CreateEndpointsForBackends()}});+  balancer_->ads_service()->SetEdsResource(BuildEdsResource(args));+  balancer_->ads_service()->SetRdsResource(RouteConfiguration());+  WaitForBackend(DEBUG_LOCATION, 0, /*check_status=*/nullptr,+                 WaitForBackendOptions());+  WaitForBackend(DEBUG_LOCATION, 1, /*check_status=*/nullptr,+                 WaitForBackendOptions());+  std::vector<std::map<std::string, std::string, std::less<>>> initial_metadata;+  // First call gets the cookie. RR policy picks the backend we will use.+  CheckRpcSendOk(DEBUG_LOCATION, 1, RpcOptions(), &initial_metadata);+  absl::optional<std::string> stateful_session_cookie =+      GetStatefulSessionCookie(initial_metadata[0]);+  ASSERT_TRUE(stateful_session_cookie.has_value());+  size_t backend_idx = -1;+  for (size_t i = 0; i < backends_.size(); i++) {+    if (backends_[i]->backend_service()->request_count() == 1) {+      backends_[i]->backend_service()->ResetCounters();+      backend_idx = i;+      break;+    }+  }+  ASSERT_NE(-1, backend_idx);+  CheckBackendCallCounts(0);+  // All requests go to the backend we specified+  CheckRpcSendOk(DEBUG_LOCATION, 5,+                 RpcOptions().set_metadata(+                     {{""cookie"", absl::StrFormat(""%s=%s"", ""grpc_session_cookie"",","I suggest declaring a local variable with this metadata, so that you don't need to repeat it in multiple call sites:```std::vector<std::pair<std::string, std::string>> metadata = {  {""cookie"", absl::StrFormat(""%s=%s"", kCookieName, *stateful_session_cookie)}};```Then, later, you can just say `RpcOptions().set_metadata(metadata)`.",X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32009,1089576245,2023-01-28T01:02:01Z,test/cpp/end2end/xds/xds_override_host_end2end_test.cc,"@@ -0,0 +1,241 @@+// Copyright 2023 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++#include <chrono>+#include <string>+#include <thread>+#include <vector>++#include <gmock/gmock.h>+#include <gtest/gtest.h>++#include ""absl/strings/str_format.h""+#include ""absl/strings/str_join.h""+#include ""absl/strings/str_split.h""++#include ""src/core/ext/filters/client_channel/backup_poller.h""+#include ""src/core/lib/gprpp/match.h""+#include ""src/proto/grpc/testing/xds/v3/cluster.grpc.pb.h""+#include ""src/proto/grpc/testing/xds/v3/outlier_detection.grpc.pb.h""+#include ""src/proto/grpc/testing/xds/v3/router.grpc.pb.h""+#include ""src/proto/grpc/testing/xds/v3/stateful_session.grpc.pb.h""+#include ""src/proto/grpc/testing/xds/v3/stateful_session_cookie.pb.h""+#include ""test/core/util/scoped_env_var.h""+#include ""test/cpp/end2end/xds/xds_end2end_test_lib.h""++namespace grpc {+namespace testing {+namespace {+using ::envoy::extensions::filters::http::stateful_session::v3::StatefulSession;+using ::envoy::extensions::filters::network::http_connection_manager::v3::+    HttpFilter;+using ::envoy::extensions::http::stateful_session::cookie::v3 ::+    CookieBasedSessionState;++class OverrideHostTest : public XdsEnd2endTest {+ protected:+  struct Cookie {+    std::string value;+    std::set<std::string> attributes;+    std::string raw;+  };++  static std::map<std::string, Cookie, std::less<>> ParseCookies(+      const std::map<std::string, std::string, std::less<>>& initial_metadata) {+    auto it = initial_metadata.find(""set-cookie"");+    if (it == initial_metadata.end()) {+      return {};+    }+    // Right now we only support a single cookie. This will be revised as+    // semantics are better understood+    std::pair<absl::string_view, absl::string_view> name_value =+        absl::StrSplit(it->second, absl::MaxSplits('=', 1));+    if (name_value.first.empty()) {+      return {};+    }+    std::pair<absl::string_view, absl::string_view> value_attrs =+        absl::StrSplit(name_value.second, absl::MaxSplits(';', 1));+    std::set<std::string> attributes;+    for (absl::string_view segment : absl::StrSplit(name_value.second, ';')) {+      attributes.insert(std::string(absl::StripAsciiWhitespace(segment)));+    }+    return {{std::string(name_value.first),+             Cookie({std::string(value_attrs.first), std::move(attributes),+                     std::string(name_value.second)})}};+  }++  static absl::optional<std::string> GetStatefulSessionCookie(+      const std::map<std::string, std::string, std::less<>>& initial_metadata,+      absl::string_view cookie_name = ""grpc_session_cookie"") {+    auto cookies = ParseCookies(initial_metadata);+    auto it = cookies.find(cookie_name);+    if (it == cookies.end()) {+      return absl::nullopt;+    }+    Cookie& grpc_session_cookie = it->second;+    EXPECT_FALSE(grpc_session_cookie.value.empty());+    EXPECT_NE(grpc_session_cookie.attributes.find(""HttpOnly""),+              grpc_session_cookie.attributes.end())+        << grpc_session_cookie.raw;+    return grpc_session_cookie.value;+  }++  // Builds a Listener with Fault Injection filter config. If the http_fault+  // is nullptr, then assign an empty filter config. This filter config is+  // required to enable the fault injection features.+  static Listener BuildListenerWithStatefulSessionFilter() {+    CookieBasedSessionState cookie_state;+    cookie_state.mutable_cookie()->set_name(""grpc_session_cookie"");+    StatefulSession stateful_session;+    stateful_session.mutable_session_state()->mutable_typed_config()->PackFrom(+        cookie_state);+    HttpConnectionManager http_connection_manager;+    Listener listener;+    listener.set_name(kServerName);+    HttpFilter* session_filter = http_connection_manager.add_http_filters();+    session_filter->set_name(""envoy.stateful_session"");+    session_filter->mutable_typed_config()->PackFrom(stateful_session);+    HttpFilter* router_filter = http_connection_manager.add_http_filters();+    router_filter->set_name(""router"");+    router_filter->mutable_typed_config()->PackFrom(+        envoy::extensions::filters::http::router::v3::Router());+    listener.mutable_api_listener()->mutable_api_listener()->PackFrom(+        http_connection_manager);+    return listener;+  }++  size_t GetAndResetRequestCount(size_t backend_idx, RpcService service) {+    size_t result = 1000;  // Will know there's a new service...+    switch (service) {+      case RpcService::SERVICE_ECHO:+        result = backends_[backend_idx]->backend_service()->request_count();+        backends_[backend_idx]->backend_service()->ResetCounters();+        break;+      case RpcService::SERVICE_ECHO1:+        result = backends_[backend_idx]->backend_service1()->request_count();+        backends_[backend_idx]->backend_service1()->ResetCounters();+        break;+      case RpcService::SERVICE_ECHO2:+        result = backends_[backend_idx]->backend_service2()->request_count();+        backends_[backend_idx]->backend_service2()->ResetCounters();+        break;+    }+    return result;+  }++  void CheckBackendCallCounts(+      absl::variant<std::function<int(size_t backend_idx)>, int> call_count,+      RpcService service = RpcService::SERVICE_ECHO,+      const grpc_core::DebugLocation& debug_location = DEBUG_LOCATION) {+    for (size_t i = 0; i < backends_.size(); i++) {+      EXPECT_EQ(+          grpc_core::Match(+              call_count,+              [i](std::function<int(size_t backend_idx)> fn) { return fn(i); },+              [](int count) { return count; }),+          GetAndResetRequestCount(i, service))+          << ""Backend "" << i << ""\n""+          << debug_location.file() << "":"" << debug_location.line();+      // Make sure no other calls are there, mostly to prevent coding errors in+      // tests+      EXPECT_EQ(0, backends_[i]->backend_service()->request_count())+          << ""Backend "" << i << ""\n""+          << debug_location.file() << "":"" << debug_location.line();+      EXPECT_EQ(0, backends_[i]->backend_service1()->request_count())+          << ""Backend "" << i << ""\n""+          << debug_location.file() << "":"" << debug_location.line();+      EXPECT_EQ(0, backends_[i]->backend_service2()->request_count())+          << ""Backend "" << i << ""\n""+          << debug_location.file() << "":"" << debug_location.line();+    }+  }+};++INSTANTIATE_TEST_SUITE_P(XdsTest, OverrideHostTest,+                         ::testing::Values(XdsTestType()), &XdsTestType::Name);+TEST_P(OverrideHostTest, HappyPath) {+  CreateAndStartBackends(2);+  auto cluster = default_cluster_;+  cluster.set_lb_policy(Cluster::ROUND_ROBIN);+  balancer_->ads_service()->SetCdsResource(cluster);+  SetListenerAndRouteConfiguration(balancer_.get(),+                                   BuildListenerWithStatefulSessionFilter(),+                                   default_route_config_);+  EdsResourceArgs args({{""locality0"", CreateEndpointsForBackends()}});+  balancer_->ads_service()->SetEdsResource(BuildEdsResource(args));+  balancer_->ads_service()->SetRdsResource(RouteConfiguration());+  WaitForBackend(DEBUG_LOCATION, 0, /*check_status=*/nullptr,+                 WaitForBackendOptions());+  WaitForBackend(DEBUG_LOCATION, 1, /*check_status=*/nullptr,+                 WaitForBackendOptions());+  std::vector<std::map<std::string, std::string, std::less<>>> initial_metadata;+  // First call gets the cookie. RR policy picks the backend we will use.+  CheckRpcSendOk(DEBUG_LOCATION, 1, RpcOptions(), &initial_metadata);+  absl::optional<std::string> stateful_session_cookie =+      GetStatefulSessionCookie(initial_metadata[0]);+  ASSERT_TRUE(stateful_session_cookie.has_value());+  size_t backend_idx = -1;+  for (size_t i = 0; i < backends_.size(); i++) {+    if (backends_[i]->backend_service()->request_count() == 1) {+      backends_[i]->backend_service()->ResetCounters();+      backend_idx = i;+      break;+    }+  }+  ASSERT_NE(-1, backend_idx);+  CheckBackendCallCounts(0);+  // All requests go to the backend we specified+  CheckRpcSendOk(DEBUG_LOCATION, 5,+                 RpcOptions().set_metadata(+                     {{""cookie"", absl::StrFormat(""%s=%s"", ""grpc_session_cookie"",+                                                 *stateful_session_cookie)}}),+                 &initial_metadata);+  CheckBackendCallCounts(+      [=](size_t idx) { return idx == backend_idx ? 5 : 0; });+  // Round-robin spreads the load+  CheckRpcSendOk(DEBUG_LOCATION, backends_.size() * 2);+  CheckBackendCallCounts(2);+  // Call a different service with the same cookie+  CheckRpcSendOk(+      DEBUG_LOCATION, 5,+      RpcOptions()+          .set_metadata(+              {{""cookie"", absl::StrFormat(""%s=%s"", ""grpc_session_cookie"",+                                          *stateful_session_cookie)}})+          .set_rpc_service(RpcService::SERVICE_ECHO2),+      &initial_metadata);","There's no need to capture the server initial metadata here, since we're not using it for anything.",X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32009,1089576296,2023-01-28T01:02:13Z,test/cpp/end2end/xds/xds_override_host_end2end_test.cc,"@@ -0,0 +1,241 @@+// Copyright 2023 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++#include <chrono>+#include <string>+#include <thread>+#include <vector>++#include <gmock/gmock.h>+#include <gtest/gtest.h>++#include ""absl/strings/str_format.h""+#include ""absl/strings/str_join.h""+#include ""absl/strings/str_split.h""++#include ""src/core/ext/filters/client_channel/backup_poller.h""+#include ""src/core/lib/gprpp/match.h""+#include ""src/proto/grpc/testing/xds/v3/cluster.grpc.pb.h""+#include ""src/proto/grpc/testing/xds/v3/outlier_detection.grpc.pb.h""+#include ""src/proto/grpc/testing/xds/v3/router.grpc.pb.h""+#include ""src/proto/grpc/testing/xds/v3/stateful_session.grpc.pb.h""+#include ""src/proto/grpc/testing/xds/v3/stateful_session_cookie.pb.h""+#include ""test/core/util/scoped_env_var.h""+#include ""test/cpp/end2end/xds/xds_end2end_test_lib.h""++namespace grpc {+namespace testing {+namespace {+using ::envoy::extensions::filters::http::stateful_session::v3::StatefulSession;+using ::envoy::extensions::filters::network::http_connection_manager::v3::+    HttpFilter;+using ::envoy::extensions::http::stateful_session::cookie::v3 ::+    CookieBasedSessionState;++class OverrideHostTest : public XdsEnd2endTest {+ protected:+  struct Cookie {+    std::string value;+    std::set<std::string> attributes;+    std::string raw;+  };++  static std::map<std::string, Cookie, std::less<>> ParseCookies(+      const std::map<std::string, std::string, std::less<>>& initial_metadata) {+    auto it = initial_metadata.find(""set-cookie"");+    if (it == initial_metadata.end()) {+      return {};+    }+    // Right now we only support a single cookie. This will be revised as+    // semantics are better understood+    std::pair<absl::string_view, absl::string_view> name_value =+        absl::StrSplit(it->second, absl::MaxSplits('=', 1));+    if (name_value.first.empty()) {+      return {};+    }+    std::pair<absl::string_view, absl::string_view> value_attrs =+        absl::StrSplit(name_value.second, absl::MaxSplits(';', 1));+    std::set<std::string> attributes;+    for (absl::string_view segment : absl::StrSplit(name_value.second, ';')) {+      attributes.insert(std::string(absl::StripAsciiWhitespace(segment)));+    }+    return {{std::string(name_value.first),+             Cookie({std::string(value_attrs.first), std::move(attributes),+                     std::string(name_value.second)})}};+  }++  static absl::optional<std::string> GetStatefulSessionCookie(+      const std::map<std::string, std::string, std::less<>>& initial_metadata,+      absl::string_view cookie_name = ""grpc_session_cookie"") {+    auto cookies = ParseCookies(initial_metadata);+    auto it = cookies.find(cookie_name);+    if (it == cookies.end()) {+      return absl::nullopt;+    }+    Cookie& grpc_session_cookie = it->second;+    EXPECT_FALSE(grpc_session_cookie.value.empty());+    EXPECT_NE(grpc_session_cookie.attributes.find(""HttpOnly""),+              grpc_session_cookie.attributes.end())+        << grpc_session_cookie.raw;+    return grpc_session_cookie.value;+  }++  // Builds a Listener with Fault Injection filter config. If the http_fault+  // is nullptr, then assign an empty filter config. This filter config is+  // required to enable the fault injection features.+  static Listener BuildListenerWithStatefulSessionFilter() {+    CookieBasedSessionState cookie_state;+    cookie_state.mutable_cookie()->set_name(""grpc_session_cookie"");+    StatefulSession stateful_session;+    stateful_session.mutable_session_state()->mutable_typed_config()->PackFrom(+        cookie_state);+    HttpConnectionManager http_connection_manager;+    Listener listener;+    listener.set_name(kServerName);+    HttpFilter* session_filter = http_connection_manager.add_http_filters();+    session_filter->set_name(""envoy.stateful_session"");+    session_filter->mutable_typed_config()->PackFrom(stateful_session);+    HttpFilter* router_filter = http_connection_manager.add_http_filters();+    router_filter->set_name(""router"");+    router_filter->mutable_typed_config()->PackFrom(+        envoy::extensions::filters::http::router::v3::Router());+    listener.mutable_api_listener()->mutable_api_listener()->PackFrom(+        http_connection_manager);+    return listener;+  }++  size_t GetAndResetRequestCount(size_t backend_idx, RpcService service) {+    size_t result = 1000;  // Will know there's a new service...+    switch (service) {+      case RpcService::SERVICE_ECHO:+        result = backends_[backend_idx]->backend_service()->request_count();+        backends_[backend_idx]->backend_service()->ResetCounters();+        break;+      case RpcService::SERVICE_ECHO1:+        result = backends_[backend_idx]->backend_service1()->request_count();+        backends_[backend_idx]->backend_service1()->ResetCounters();+        break;+      case RpcService::SERVICE_ECHO2:+        result = backends_[backend_idx]->backend_service2()->request_count();+        backends_[backend_idx]->backend_service2()->ResetCounters();+        break;+    }+    return result;+  }++  void CheckBackendCallCounts(+      absl::variant<std::function<int(size_t backend_idx)>, int> call_count,+      RpcService service = RpcService::SERVICE_ECHO,+      const grpc_core::DebugLocation& debug_location = DEBUG_LOCATION) {+    for (size_t i = 0; i < backends_.size(); i++) {+      EXPECT_EQ(+          grpc_core::Match(+              call_count,+              [i](std::function<int(size_t backend_idx)> fn) { return fn(i); },+              [](int count) { return count; }),+          GetAndResetRequestCount(i, service))+          << ""Backend "" << i << ""\n""+          << debug_location.file() << "":"" << debug_location.line();+      // Make sure no other calls are there, mostly to prevent coding errors in+      // tests+      EXPECT_EQ(0, backends_[i]->backend_service()->request_count())+          << ""Backend "" << i << ""\n""+          << debug_location.file() << "":"" << debug_location.line();+      EXPECT_EQ(0, backends_[i]->backend_service1()->request_count())+          << ""Backend "" << i << ""\n""+          << debug_location.file() << "":"" << debug_location.line();+      EXPECT_EQ(0, backends_[i]->backend_service2()->request_count())+          << ""Backend "" << i << ""\n""+          << debug_location.file() << "":"" << debug_location.line();+    }+  }+};++INSTANTIATE_TEST_SUITE_P(XdsTest, OverrideHostTest,+                         ::testing::Values(XdsTestType()), &XdsTestType::Name);+TEST_P(OverrideHostTest, HappyPath) {+  CreateAndStartBackends(2);+  auto cluster = default_cluster_;+  cluster.set_lb_policy(Cluster::ROUND_ROBIN);+  balancer_->ads_service()->SetCdsResource(cluster);+  SetListenerAndRouteConfiguration(balancer_.get(),+                                   BuildListenerWithStatefulSessionFilter(),+                                   default_route_config_);+  EdsResourceArgs args({{""locality0"", CreateEndpointsForBackends()}});+  balancer_->ads_service()->SetEdsResource(BuildEdsResource(args));+  balancer_->ads_service()->SetRdsResource(RouteConfiguration());+  WaitForBackend(DEBUG_LOCATION, 0, /*check_status=*/nullptr,+                 WaitForBackendOptions());+  WaitForBackend(DEBUG_LOCATION, 1, /*check_status=*/nullptr,+                 WaitForBackendOptions());+  std::vector<std::map<std::string, std::string, std::less<>>> initial_metadata;+  // First call gets the cookie. RR policy picks the backend we will use.+  CheckRpcSendOk(DEBUG_LOCATION, 1, RpcOptions(), &initial_metadata);+  absl::optional<std::string> stateful_session_cookie =+      GetStatefulSessionCookie(initial_metadata[0]);+  ASSERT_TRUE(stateful_session_cookie.has_value());+  size_t backend_idx = -1;+  for (size_t i = 0; i < backends_.size(); i++) {+    if (backends_[i]->backend_service()->request_count() == 1) {+      backends_[i]->backend_service()->ResetCounters();+      backend_idx = i;+      break;+    }+  }+  ASSERT_NE(-1, backend_idx);+  CheckBackendCallCounts(0);+  // All requests go to the backend we specified+  CheckRpcSendOk(DEBUG_LOCATION, 5,+                 RpcOptions().set_metadata(+                     {{""cookie"", absl::StrFormat(""%s=%s"", ""grpc_session_cookie"",+                                                 *stateful_session_cookie)}}),+                 &initial_metadata);","There's no need to capture the server initial metadata here, since we're not using it for anything.",X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32009,1089578381,2023-01-28T01:11:19Z,test/cpp/end2end/xds/xds_override_host_end2end_test.cc,"@@ -0,0 +1,241 @@+// Copyright 2023 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++#include <chrono>+#include <string>+#include <thread>+#include <vector>++#include <gmock/gmock.h>+#include <gtest/gtest.h>++#include ""absl/strings/str_format.h""+#include ""absl/strings/str_join.h""+#include ""absl/strings/str_split.h""++#include ""src/core/ext/filters/client_channel/backup_poller.h""+#include ""src/core/lib/gprpp/match.h""+#include ""src/proto/grpc/testing/xds/v3/cluster.grpc.pb.h""+#include ""src/proto/grpc/testing/xds/v3/outlier_detection.grpc.pb.h""+#include ""src/proto/grpc/testing/xds/v3/router.grpc.pb.h""+#include ""src/proto/grpc/testing/xds/v3/stateful_session.grpc.pb.h""+#include ""src/proto/grpc/testing/xds/v3/stateful_session_cookie.pb.h""+#include ""test/core/util/scoped_env_var.h""+#include ""test/cpp/end2end/xds/xds_end2end_test_lib.h""++namespace grpc {+namespace testing {+namespace {+using ::envoy::extensions::filters::http::stateful_session::v3::StatefulSession;+using ::envoy::extensions::filters::network::http_connection_manager::v3::+    HttpFilter;+using ::envoy::extensions::http::stateful_session::cookie::v3 ::+    CookieBasedSessionState;++class OverrideHostTest : public XdsEnd2endTest {+ protected:+  struct Cookie {+    std::string value;+    std::set<std::string> attributes;+    std::string raw;+  };++  static std::map<std::string, Cookie, std::less<>> ParseCookies(","The way this is written, it requires passing in all of the metadata, and it returns and parses every single cookie, which seems like overkill when the caller just wants one cookie.  Instead, I suggest something like this:```static Cookie ParseCookie(    absl::string_view cookie_name,    absl::string_view set_cookie_header_value);```The caller can find the `set-cookie` header and pass the value of that header in, and the function can return just the one specific cookie that the caller wants.",
85715732,yousukseung,https://api.github.com/repos/grpc/grpc/pulls/32106,1090188634,2023-01-30T05:31:10Z,include/grpcpp/ext/server_metric_recorder.h,"@@ -27,11 +27,9 @@ #include ""absl/strings/string_view.h"" #include ""absl/types/optional.h"" -#include <grpcpp/impl/sync.h>+#include ""src/core/ext/filters/client_channel/lb_policy/backend_metric_data.h""","Updated, I *think* I went with the option 3 you suggested.But now all tests are stuck and I still could not find why. It's stuck in grpc_init() likely due to a deadlock holding the global lock, but I have no idea why this happened. Thoughts?",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32106,1090931816,2023-01-30T17:28:06Z,include/grpcpp/ext/server_metric_recorder.h,"@@ -19,25 +19,21 @@ #ifndef GRPCPP_EXT_SERVER_METRIC_RECORDER_H #define GRPCPP_EXT_SERVER_METRIC_RECORDER_H -#include <atomic> #include <map> #include <memory>-#include <string>--#include ""absl/strings/string_view.h""-#include ""absl/types/optional.h""  #include <grpcpp/impl/sync.h>+#include <grpcpp/support/string_ref.h>  namespace grpc_core { struct BackendMetricData;-struct BackendMetricDataState; }  // namespace grpc_core  namespace grpc { class BackendMetricState;  namespace experimental {+struct BackendMetricDataState;","This should be inside the private section of `ServerMetricRecorder`.  It is not used outside of that class, so there's no reason it needs to be declared outside of it.In other words, here in this file, we can say:```class ServerMetricRecorder { public:  // ... private:  friend class grpc::BackendMetricState;  friend class OrcaService;  struct BackendMetricDataState;  // ...};```Then, in backend_metric_recorder.h, we can say:```namespace experimental {// Backend metrics and an associated update sequence number.struct ServerMetricRecorder::BackendMetricDataState {  grpc_core::BackendMetricData data;  uint64_t sequence_number = 0;};}  // namespace experimental```",X
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/32229,1090955752,2023-01-30T17:50:09Z,src/core/lib/gprpp/fork.cc,"@@ -63,6 +64,13 @@ class ExecCtxState {   }    void IncExecCtxCount() {+    // If we are in an EventEngine thread, we should not block any ExecCtx","Can we update this comment with more precise language then? I assume it's ""EventEngine is expected to terminate all threads before fork, and so this extra work is unnecessary"" or something along those lines?",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32106,1090962168,2023-01-30T17:56:21Z,test/cpp/end2end/client_lb_end2end_test.cc,"@@ -558,6 +558,46 @@ class ClientLbEnd2endTest : public ::testing::Test {     return WaitForChannelState(channel, predicate, true, timeout_seconds);   } +  void ExpectWeightedRoundRobinPicks(","Instead of putting this in `ClientLbEnd2endTest`, please put this in `WeightedRoundRobinTest`, since it's not going to be used for any non-WRR tests.Note that you can make `WeightedRoundRobinParamTest` inherit from `WeightedRoundRobinTest` instead of inheritting directly from `ClientLbEnd2endTest`, so that both `WeightedRoundRobinTest` and `WeightedRoundRobinParamTest` can use this method.  In other words:```class WeightedRoundRobinTest : public ClientLbEnd2endTest { protected:  void ExpectWeightedRoundRobinPicks(...) { ... }};class WeightedRoundRobinParamTest    : public WeightedRoundRobinTest,      public ::testing::WithParamInterface<const char*> {};INSTANTIATE_TEST_SUITE_P(WeightedRoundRobin, WeightedRoundRobinParamTest,                         ::testing::Values(kServiceConfigPerCall,                                           kServiceConfigOob));```",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32106,1090994759,2023-01-30T18:27:35Z,include/grpcpp/ext/server_metric_recorder.h,"@@ -27,11 +27,9 @@ #include ""absl/strings/string_view.h"" #include ""absl/types/optional.h"" -#include <grpcpp/impl/sync.h>+#include ""src/core/ext/filters/client_channel/lb_policy/backend_metric_data.h""","I think the way you had this looked basically right.  You might need to have `ServerMetricRecorderImpl` also inherit from [`internal::GrpcLibrary`](https://github.com/grpc/grpc/blob/54ad01cf01696a614df8b2256a134aa561ed7315/include/grpcpp/impl/grpc_library.h#L32) to make sure `grpc_init()` gets handled right.I'd prefer that approach if possible, because it avoids exposing the internal implementation details in the header file at all, even as private.  But if you can't make that work for some reason, I can live with the way you have this now, as long as we preserve the option to switch to the other approach later.  Specifically, please make the ctor private and add a factory method, so that we can later change this to be an abstract interface if we want to:```class ServerMetricRecorder { public:  static std::unique_ptr<ServerMetricRecorder> Create();  // ... private:  ServerMetricRecorder();  // ...};```",
287917,eugeneo,https://api.github.com/repos/grpc/grpc/pulls/32009,1091026358,2023-01-30T18:58:15Z,test/cpp/end2end/xds/xds_end2end_test_lib.h,"@@ -811,16 +813,21 @@ class XdsEnd2endTest : public ::testing::TestWithParam<XdsTestType> {   struct RpcResult {     Status status;     EchoResponse response;+    std::map<std::string, std::string> initial_metadata;   };-  void SendRpcsUntil(const grpc_core::DebugLocation& debug_location,-                     std::function<bool(const RpcResult&)> continue_predicate,-                     int timeout_ms = 15000,-                     const RpcOptions& rpc_options = RpcOptions());+  void SendRpcsUntil(+      const grpc_core::DebugLocation& debug_location,+      std::function<bool(const RpcResult&)> continue_predicate,+      int timeout_ms = 15000, const RpcOptions& rpc_options = RpcOptions(),+      std::vector<std::map<std::string, std::string, std::less<>>>*+          responses_initial_metadata = nullptr);    // Sends the specified number of RPCs and fails if the RPC fails.-  void CheckRpcSendOk(const grpc_core::DebugLocation& debug_location,-                      const size_t times = 1,-                      const RpcOptions& rpc_options = RpcOptions());+  void CheckRpcSendOk(+      const grpc_core::DebugLocation& debug_location, const size_t times = 1,+      const RpcOptions& rpc_options = RpcOptions(),+      std::vector<std::map<std::string, std::string, std::less<>>>*",I reverted most changes in common library and moved the method you suggested to `xds_override_host_end2end_test.cc` so it can be specialized for that test needs.,
16962414,gtcooke94,https://api.github.com/repos/grpc/grpc/pulls/32215,1091054969,2023-01-30T19:28:27Z,test/core/tsi/ssl_transport_security_test.cc,"@@ -191,6 +191,18 @@ static void ssl_test_setup_handshakers(tsi_test_fixture* fixture) {       TSI_OK); } +static void check_ca_cert_subject(ssl_tsi_test_fixture* /*ssl_fixture*/,","Added nullptr checks in the test for cases where this should be unsetIs case 2 a special case? The implementation just gets the last cert in the verified chain, should it matter if there are intermediate CAs?",
52979934,matthewstevenson88,https://api.github.com/repos/grpc/grpc/pulls/32215,1091249304,2023-01-30T22:49:15Z,src/core/tsi/ssl_transport_security.cc,"@@ -853,6 +882,52 @@ static int NullVerifyCallback(int /*preverify_ok*/, X509_STORE_CTX* /*ctx*/) {   return 1; } +static int RootCertExtractCallback(int preverify_ok, X509_STORE_CTX* ctx) {","Please check whether `ctx` is null when we enter the function. If we call `X509_STORE_CTX_get0_chain` and `ctx` is null, then we will segfault.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32106,1091290067,2023-01-31T00:02:13Z,src/cpp/server/backend_metric_recorder.cc,"@@ -41,16 +42,23 @@ grpc_core::TraceFlag grpc_backend_metric_trace(false, ""backend_metric""); namespace grpc { namespace experimental { +std::unique_ptr<ServerMetricRecorder> ServerMetricRecorder::Create() {+  return std::unique_ptr<ServerMetricRecorder>(new ServerMetricRecorder());+}+ ServerMetricRecorder::ServerMetricRecorder() {   // Starts with an empty result.-  metric_state_ = std::make_shared<const BackendMetricDataState>();+  metric_state_ =",Nit: This can be set in the initializer list rather than in the body.,
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32106,1091290259,2023-01-31T00:02:39Z,src/cpp/server/backend_metric_recorder.cc,"@@ -41,16 +42,23 @@ grpc_core::TraceFlag grpc_backend_metric_trace(false, ""backend_metric""); namespace grpc { namespace experimental { +std::unique_ptr<ServerMetricRecorder> ServerMetricRecorder::Create() {+  return std::unique_ptr<ServerMetricRecorder>(new ServerMetricRecorder());+}+ ServerMetricRecorder::ServerMetricRecorder() {   // Starts with an empty result.-  metric_state_ = std::make_shared<const BackendMetricDataState>();+  metric_state_ =+      std::make_shared<const ServerMetricRecorder::BackendMetricDataState>(); }  void ServerMetricRecorder::UpdateBackendMetricDataState(     std::function<void(BackendMetricData*)> updater) {   internal::MutexLock lock(&mu_);-  auto new_state = std::make_shared<BackendMetricDataState>(*metric_state_);-  updater(&(new_state->data));+  auto new_state =+      std::make_shared<ServerMetricRecorder::BackendMetricDataState>(","No need to say `ServerMetricRecorder::` here, since you're already in that class.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32106,1091297274,2023-01-31T00:16:58Z,test/cpp/end2end/client_lb_end2end_test.cc,"@@ -2928,13 +2889,128 @@ const char kServiceConfigOob[] =     ""    {\""weighted_round_robin_experimental\"": {\n""     ""      \""blackoutPeriod\"": \""0s\"",\n""     ""      \""weightUpdatePeriod\"": \""0.1s\"",\n""+    ""      \""weightExpirationPeriod\"": \""2s\"",\n""     ""      \""enableOobLoadReport\"": true\n""     ""    }}\n""     ""  ]\n""     ""}""; +class WeightedRoundRobinTest : public ClientLbEnd2endTest {+ protected:+  void ExpectWeightedRoundRobinPicks(+      const grpc_core::DebugLocation& location,+      const std::unique_ptr<grpc::testing::EchoTestService::Stub>& stub,+      const std::vector<size_t>& expected_weights, size_t total_passes,+      EchoRequest* request_ptr = nullptr, int timeout_ms = 15000,","I don't see where `timeout_ms` is actually being used here.  I assume you intended to pass this along to `SendRpcsUntil()`, but you're not actually doing that.If the test is passing as-is, then I think that's a pretty good indicator that this parameter is not actually needed.",X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32106,1091299479,2023-01-31T00:21:27Z,test/cpp/end2end/client_lb_end2end_test.cc,"@@ -558,6 +558,46 @@ class ClientLbEnd2endTest : public ::testing::Test {     return WaitForChannelState(channel, predicate, true, timeout_seconds);   } +  void ExpectWeightedRoundRobinPicks(+      const grpc_core::DebugLocation& location,+      const std::unique_ptr<grpc::testing::EchoTestService::Stub>& stub,+      const std::vector<size_t>& expected_weights, size_t total_passes,+      absl::Duration wait_between_rounds = absl::ZeroDuration(),+      EchoRequest* request_ptr = nullptr) {+    GPR_ASSERT(expected_weights.size() == servers_.size());+    size_t total_picks_per_pass = 0;+    for (size_t picks : expected_weights) {+      total_picks_per_pass += picks;+    }+    size_t num_picks = 0;+    size_t num_passes = 0;+    SendRpcsUntil(+        location, stub,+        [&](const Status&) {+          gpr_sleep_until(grpc_timeout_milliseconds_to_deadline(","Right, a pass here is not a scheduler update, it's just making sure that when we iterate through the rotation a few times in a row, we consistently get back picks with the right weights.I intentionally did not add tests here for things like expiration and blackout.  Those are already covered in the unit tests (starting [here](https://github.com/grpc/grpc/blob/f06ebb7407cef95384d10e5686d5e8d2746228d2/test/core/client_channel/lb_policy/weighted_round_robin_test.cc#L506)), and we don't need to cover them again here.  These e2e tests are much heavier-weight than the unit tests and much more likely to be flaky, but they're useful for making sure that the LB policy code actually interacts correctly with the rest of the client channel and backend metric reporting code.  But to do that, we really only need a couple of fairly simple tests.Of the new tests you added, I think the `InvalidWeight` is useful, but it should be added as a unit test, not as an e2e test -- and it does not need to be added as part of this PR.  I think the other tests are all duplicates of existing unit tests, so they can just be removed.And I still think we do not need this sleep.  Please remove it.",X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32009,1091306789,2023-01-31T00:36:00Z,test/cpp/end2end/xds/xds_end2end_test_lib.h,"@@ -787,8 +787,10 @@ class XdsEnd2endTest : public ::testing::TestWithParam<XdsTestType> {   // Sends an RPC with the specified options.   // If response is non-null, it will be populated with the response.   // Returns the status of the RPC.-  Status SendRpc(const RpcOptions& rpc_options = RpcOptions(),-                 EchoResponse* response = nullptr);+  Status SendRpc(+      const RpcOptions& rpc_options = RpcOptions(),+      EchoResponse* response = nullptr,+      std::map<std::string, std::string, std::less<>>* metadata = nullptr);",Still need to document the parameter.,
16962414,gtcooke94,https://api.github.com/repos/grpc/grpc/pulls/32215,1092170639,2023-01-31T16:21:58Z,test/core/tsi/ssl_transport_security_test.cc,"@@ -191,6 +191,18 @@ static void ssl_test_setup_handshakers(tsi_test_fixture* fixture) {       TSI_OK); } +static void check_ca_cert_subject(ssl_tsi_test_fixture* /*ssl_fixture*/,","There are failed verifications in the [CRL related SSL tests](https://github.com/grpc/grpc/blob/master/test/core/tsi/crl_ssl_transport_security_test.cc)I'll happily add more tests though, I'll discuss with you offline about setting up the chain for 2.",
16962414,gtcooke94,https://api.github.com/repos/grpc/grpc/pulls/32215,1092195347,2023-01-31T16:31:13Z,src/core/tsi/ssl_transport_security.cc,"@@ -853,6 +882,52 @@ static int NullVerifyCallback(int /*preverify_ok*/, X509_STORE_CTX* /*ctx*/) {   return 1; } +static int RootCertExtractCallback(int preverify_ok, X509_STORE_CTX* ctx) {+  // There's a case where this function is set in SSL_CTX_set_verify and a CRL+  // related callback is set with X509_STORE_set_verify_cb. They overlap and+  // this will take precedence, thus we need to ensure the CRL related callback","It's because of this [code in boringssl](https://boringssl.googlesource.com/boringssl/+/refs/heads/master/ssl/ssl_x509.cc#402).In the chain of BoringSSL, if you set a verification callback with `SSL_CTX_set_verify` it ends up as the callback here on `hs->config->verify_callback`. So if that is set, it will override a callback set on `X509_STORE_CTX_set_verify` with whatever is there.And this is the case here - we've maybe set a CRL-related verification callback with `X509_STORE_CTX_set_verify`, but we've also set the callback to extract the root cert with `SSL_CTX_set_verify`",
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/32229,1092384951,2023-01-31T19:27:44Z,src/core/lib/gprpp/fork.cc,"@@ -63,6 +64,12 @@ class ExecCtxState {   }    void IncExecCtxCount() {+    // EventEngine is expected to terminate all threads before fork, and so this+    // extra work is unnecessary+    if (grpc_event_engine::experimental::ThreadLocal::IsEventEngineThread()) {+      gpr_atm_no_barrier_fetch_add(&count_, 1);","Not quite. EventEngines are expected to terminate all of their threads pre-fork (or otherwise confirm they are fork-safe). We are dealing with an intersection of fork handlers, and non-determinism around where and when callbacks are run. This code guarantees that the _blocking behavior_ of ExecCtx on fork only applies to the older fork handling code. If an EventEngine is running this bit of code, all current known implementations are going to wait on this code to finish before allowing the fork to proceed.I don't see anything being papered over here. This older fork code is going away, ExecCtx is (hopefully, eventually) going away. This change allows fork handlers to coexist in the meantime.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32106,1093464657,2023-02-01T16:33:15Z,src/core/ext/filters/backend_metrics/backend_metric_provider.h,"@@ -0,0 +1,34 @@+/*+ *+ * Copyright 2023 gRPC authors.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ *     http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ *+ */++#ifndef GRPC_SRC_CORE_EXT_FILTERS_BACKEND_METRICS_BACKEND_METRIC_PROVIDER_H+#define GRPC_SRC_CORE_EXT_FILTERS_BACKEND_METRICS_BACKEND_METRIC_PROVIDER_H++namespace grpc_core {++struct BackendMetricData;+class BackendMetricProvider {+ public:+  virtual ~BackendMetricProvider() = default;+  // Returns nullopt when empty.",This comment is no longer correct.  Please remove.,X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32248,1093486013,2023-02-01T16:50:50Z,test/cpp/end2end/xds/xds_override_host_end2end_test.cc,"@@ -126,52 +117,143 @@ class OverrideHostTest : public XdsEnd2endTest {         http_connection_manager);     return listener;   }++  std::multimap<std::string, std::string> SendRpcGetServerMetadata(+      const grpc_core::DebugLocation& debug_location,+      const RpcOptions& rpc_options) {+    std::multimap<std::string, std::string> server_initial_metadata;+    EchoResponse response;+    grpc::Status status =+        SendRpc(rpc_options, &response, &server_initial_metadata);+    EXPECT_TRUE(status.ok())+        << ""code="" << status.error_code()+        << "", message="" << status.error_message() << ""\n""+        << debug_location.file() << "":"" << debug_location.line();+    EXPECT_EQ(response.message(), kRequestMessage)+        << debug_location.file() << "":"" << debug_location.line();+    return server_initial_metadata;+  }++  ClusterLoadAssignment EdsResourceWithChannelHealth(","I don't think we need yet another helper method for creating EDS resources; we already have several such methods in the test framework.  Instead, tests can do something like this:```std::vector<EdsResourceArgs::Endpoint> endpoints = {  CreateEndpoint(0, HealthStatus::HEALTHY),  CreateEndpoint(1, HealthStatus::DRAINING),};auto args = BuildEdsResourceArgs({{""locality0"", endpoints}});```Or, if there is a case with a large number of endpoints and we want only one of them to have a different health status, they can do something like this:```auto endpoints = CreateEndpointsForBackends(0, 0, HealthStatus::HEALTHY);endpoints[1].health_status = HealthStatus::DRAINING;auto args = BuildEdsResourceArgs({{""locality0"", endpoints}});```",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32248,1093526166,2023-02-01T17:25:27Z,test/cpp/end2end/xds/xds_override_host_end2end_test.cc,"@@ -126,52 +117,143 @@ class OverrideHostTest : public XdsEnd2endTest {         http_connection_manager);     return listener;   }++  std::multimap<std::string, std::string> SendRpcGetServerMetadata(+      const grpc_core::DebugLocation& debug_location,+      const RpcOptions& rpc_options) {+    std::multimap<std::string, std::string> server_initial_metadata;+    EchoResponse response;+    grpc::Status status =+        SendRpc(rpc_options, &response, &server_initial_metadata);+    EXPECT_TRUE(status.ok())+        << ""code="" << status.error_code()+        << "", message="" << status.error_message() << ""\n""+        << debug_location.file() << "":"" << debug_location.line();+    EXPECT_EQ(response.message(), kRequestMessage)+        << debug_location.file() << "":"" << debug_location.line();+    return server_initial_metadata;+  }++  ClusterLoadAssignment EdsResourceWithChannelHealth(+      absl::Span<const HealthStatus> backend_health_statuses) {+    std::vector<EdsResourceArgs::Endpoint> endpoints;+    int ind = 0;+    for (HealthStatus status : backend_health_statuses) {+      endpoints.emplace_back(CreateEndpoint(ind++, status));+    }+    return BuildEdsResource(EdsResourceArgs({{""locality0"", endpoints}}));+  }++  size_t FindBackendWithRequest() {+    for (size_t i = 0; i < backends_.size(); ++i) {+      if (backends_[i]->backend_service()->request_count() == 1) {+        return i;+      }+    }+    return -1;+  } };  INSTANTIATE_TEST_SUITE_P(XdsTest, OverrideHostTest,                          ::testing::Values(XdsTestType()), &XdsTestType::Name); -TEST_P(OverrideHostTest, HappyPath) {-  CreateAndStartBackends(2);+TEST_P(OverrideHostTest, DefaultConfigurationNoDraining) {+  CreateAndStartBackends(3);   SetListenerAndRouteConfiguration(balancer_.get(),                                    BuildListenerWithStatefulSessionFilter(),                                    default_route_config_);-  EdsResourceArgs args({{""locality0"", CreateEndpointsForBackends()}});-  balancer_->ads_service()->SetEdsResource(BuildEdsResource(args));-  WaitForAllBackends(DEBUG_LOCATION);+  balancer_->ads_service()->SetEdsResource(EdsResourceWithChannelHealth(+      {HealthStatus::HEALTHY, HealthStatus::HEALTHY}));+  WaitForAllBackends(DEBUG_LOCATION, 0, 2);   // First call gets the cookie. RR policy picks the backend we will use.   auto server_initial_metadata =       SendRpcGetServerMetadata(DEBUG_LOCATION, RpcOptions());-  std::vector<std::string> stateful_session_cookie =-      GetStatefulSessionCookie(server_initial_metadata);-  ASSERT_EQ(stateful_session_cookie.size(), 1);-  size_t backend_idx = -1;-  for (size_t i = 0; i < backends_.size(); ++i) {-    if (backends_[i]->backend_service()->request_count() == 1) {-      backend_idx = i;-      break;-    }-  }+  auto session_cookie = GetHeadersWithSessionCookie(server_initial_metadata);+  ASSERT_FALSE(session_cookie.empty());+  size_t backend_idx = FindBackendWithRequest();   ASSERT_NE(-1, backend_idx);   ResetBackendCounters();-  std::vector<std::pair<std::string, std::string>> session_cookie = {-      {""cookie"",-       absl::StrFormat(""%s=%s"", kCookieName, stateful_session_cookie[0])}};   // All requests go to the backend we specified   CheckRpcSendOk(DEBUG_LOCATION, 5, RpcOptions().set_metadata(session_cookie));   EXPECT_EQ(backends_[backend_idx]->backend_service()->request_count(), 5);   // Round-robin spreads the load   ResetBackendCounters();-  CheckRpcSendOk(DEBUG_LOCATION, backends_.size() * 2);+  CheckRpcSendOk(DEBUG_LOCATION, 4);   EXPECT_EQ(2, backends_[0]->backend_service()->request_count());   EXPECT_EQ(2, backends_[1]->backend_service()->request_count());+  // Should be disabled for now+  EXPECT_EQ(0, backends_[2]->backend_service()->request_count());   // Call a different service with the same cookie   ResetBackendCounters();   CheckRpcSendOk(DEBUG_LOCATION, 5,                  RpcOptions()                      .set_metadata(session_cookie)                      .set_rpc_service(RpcService::SERVICE_ECHO2));   EXPECT_EQ(backends_[backend_idx]->backend_service2()->request_count(), 5);+  // DRAINING is not overridden here so this channel should just disappear+  std::array<HealthStatus, 3> statuses(+      {HealthStatus::HEALTHY, HealthStatus::HEALTHY, HealthStatus::HEALTHY});+  statuses[backend_idx] = HealthStatus::DRAINING;+  balancer_->ads_service()->SetEdsResource(+      EdsResourceWithChannelHealth(statuses));+  WaitForAllBackends(DEBUG_LOCATION);+  // Draining channel is not overridden+  CheckRpcSendOk(DEBUG_LOCATION, (backends_.size() - 1) * 2,+                 RpcOptions().set_metadata(session_cookie));+  EXPECT_EQ(0, backends_[backend_idx]->backend_service()->request_count());+  // The second of the ""initial backends""+  EXPECT_EQ(2, backends_[1 - backend_idx]->backend_service()->request_count());+  EXPECT_EQ(2, backends_[2]->backend_service()->request_count());+}++TEST_P(OverrideHostTest, DefaultConfigurationDrainingOverridden) {+  CreateAndStartBackends(3);+  Cluster cluster = default_cluster_;+  auto* lb_config = cluster.mutable_common_lb_config();+  auto* override_health_status_set = lb_config->mutable_override_host_status();+  override_health_status_set->add_statuses(HealthStatus::HEALTHY);+  override_health_status_set->add_statuses(HealthStatus::UNKNOWN);+  override_health_status_set->add_statuses(HealthStatus::DRAINING);+  balancer_->ads_service()->SetCdsResource(cluster);+  SetListenerAndRouteConfiguration(balancer_.get(),+                                   BuildListenerWithStatefulSessionFilter(),+                                   default_route_config_);+  balancer_->ads_service()->SetEdsResource(EdsResourceWithChannelHealth(+      {HealthStatus::HEALTHY, HealthStatus::HEALTHY}));+  WaitForAllBackends(DEBUG_LOCATION, 0, 2);+  // First call gets the cookie. RR policy picks the backend we will use.+  auto server_initial_metadata =+      SendRpcGetServerMetadata(DEBUG_LOCATION, RpcOptions());+  auto session_cookie = GetHeadersWithSessionCookie(server_initial_metadata);+  ASSERT_FALSE(session_cookie.empty());+  size_t backend_idx = FindBackendWithRequest();","Consider forcing the test to get a cookie for one particular backend, so that the code below can use fixed expectations for each backend:```// Get a cookie for backend 0.std::vector<std::pair<std::string, std::string>> session_cookie;do {  auto server_initial_metadata =      SendRpcGetServerMetadata(DEBUG_LOCATION, RpcOptions());  session_cookie = GetHeadersWithSessionCookie(server_initial_metadata);  ASSERT_FALSE(session_cookie.empty());} while (FindBackendWithRequest() != 0);```",
5663878,yijiem,https://api.github.com/repos/grpc/grpc/pulls/32240,1093920838,2023-02-02T01:30:43Z,src/core/ext/transport/chttp2/transport/writing.cc,"@@ -152,14 +153,14 @@ static void maybe_initiate_ping(grpc_chttp2_transport* t) {           next_allowed_ping.milliseconds_after_process_epoch(),           now.milliseconds_after_process_epoch());     }-    if (!t->ping_state.is_delayed_ping_timer_set) {-      t->ping_state.is_delayed_ping_timer_set = true;+    if (!t->ping_state.delayed_ping_timer_handle) {       GRPC_CHTTP2_REF_TRANSPORT(t, ""retry_initiate_ping_locked"");-      GRPC_CLOSURE_INIT(&t->retry_initiate_ping_locked,-                        grpc_chttp2_retry_initiate_ping, t,-                        grpc_schedule_on_exec_ctx);-      grpc_timer_init(&t->ping_state.delayed_ping_timer, next_allowed_ping,-                      &t->retry_initiate_ping_locked);+      t->ping_state.delayed_ping_timer_handle =","Hmmm, I didn't see the race... `maybe_initiate_ping` only runs in the transport's combiner lock, same for `close_transport_locked` I would think... So I don't think they will run concurrently or in parallel (correct me if I'm wrong though).",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32248,1094949809,2023-02-02T18:57:23Z,test/cpp/end2end/xds/xds_override_host_end2end_test.cc,"@@ -97,14 +97,14 @@ class OverrideHostTest : public XdsEnd2endTest {   // Builds a Listener with Fault Injection filter config. If the http_fault   // is nullptr, then assign an empty filter config. This filter config is   // required to enable the fault injection features.-  static Listener BuildListenerWithStatefulSessionFilter() {+  Listener BuildListenerWithStatefulSessionFilter() {     CookieBasedSessionState cookie_state;     cookie_state.mutable_cookie()->set_name(std::string(kCookieName));     StatefulSession stateful_session;     stateful_session.mutable_session_state()->mutable_typed_config()->PackFrom(         cookie_state);     HttpConnectionManager http_connection_manager;-    Listener listener;+    Listener listener = default_listener_;","If you're going to use `default_listener_` here, then I suggest just modifying the existing `HttpConnectionManager` config instead of overwriting it:```Listener listener = default_listener_;HttpConnectionManager http_connection_manager =    ClientHcmAccessor().Unpack(listener);// Insert new filter ahead of the existing router filter.HttpFilter* filter = http_connection_manager.mutable_http_filters(0);*http_connection_manager.add_http_filters() = *filter;filter->set_name(""envoy.stateful_session"");filter->mutable_typed_config()->PackFrom(stateful_session);ClientHcmAccessor().Pack(http_connection_manager, &listener);return listener;```",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32248,1094959837,2023-02-02T19:07:26Z,test/cpp/end2end/xds/xds_override_host_end2end_test.cc,"@@ -136,42 +160,112 @@ TEST_P(OverrideHostTest, HappyPath) {   SetListenerAndRouteConfiguration(balancer_.get(),                                    BuildListenerWithStatefulSessionFilter(),                                    default_route_config_);-  EdsResourceArgs args({{""locality0"", CreateEndpointsForBackends()}});-  balancer_->ads_service()->SetEdsResource(BuildEdsResource(args));+  balancer_->ads_service()->SetEdsResource(BuildEdsResource(+      EdsResourceArgs({{""locality0"",+                        {CreateEndpoint(0, HealthStatus::HEALTHY),+                         CreateEndpoint(1, HealthStatus::UNKNOWN)}}})));   WaitForAllBackends(DEBUG_LOCATION);   // First call gets the cookie. RR policy picks the backend we will use.","Please update this comment.  We're no longer just getting a cookie for a random backend; instead, we're getting a cookie for backend 0 specifically.",
52979934,matthewstevenson88,https://api.github.com/repos/grpc/grpc/pulls/32215,1095223819,2023-02-03T00:20:52Z,src/core/tsi/test_creds/README,"@@ -99,6 +99,25 @@ multi-domain-openssl.cnf $ openssl req -x509 -new -extensions v3_req -key multi-domain.key -out multi-domain.pem -days 3650 -config multi-domain-openssl.cnf ++Intermediate is an intermediate CA used to sign leaf certs used to test having","nit: This comment is a bit circular, could you clarify? Also please mention the other files (e.g. leaf_and_intermediate_chain.pem) that are being created.",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/32294,1096634417,2023-02-05T07:12:48Z,src/cpp/ext/filters/census/environment_autodetect.cc,"@@ -0,0 +1,337 @@+//+//+// Copyright 2023 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+//+//++#include <grpc/support/port_platform.h>++#include ""src/cpp/ext/filters/census/environment_autodetect.h""++#include <deque>+#include <memory>++#include ""src/core/lib/event_engine/default_event_engine.h""+#include ""src/core/lib/gprpp/env.h""+#include ""src/core/lib/gprpp/load_file.h""+#include ""src/core/lib/gprpp/status_helper.h""+#include ""src/core/lib/http/httpcli.h""+#include ""src/core/lib/security/credentials/credentials.h""++namespace grpc {+namespace internal {++namespace {++constexpr const char kZoneAttribute[] = ""/computeMetadata/v1/instance/zone"";+constexpr const char kClusterNameAttribute[] =+    ""/computeMetadata/v1/instance/attributes/cluster-name"";+constexpr const char kRegionAttribute[] = ""/computeMetadata/v1/instance/region"";+constexpr const char kInstanceIdAttribute[] = ""/computeMetadata/v1/instance/id"";++// Fire and Forget class (Cleans up after itself.)+// Fetches the value of an attribute from the MetadataServer on a GCP+// environment.+class MetadataQuery {+ public:+  MetadataQuery(std::string attribute, grpc_polling_entity* pollent,+                absl::AnyInvocable<void(std::string /* attribute */,+                                        std::string /* result */)>+                    callback)+      : attribute_(std::move(attribute)), callback_(std::move(callback)) {+    GRPC_CLOSURE_INIT(&on_done_, OnDone, this, nullptr);+    auto uri =+        grpc_core::URI::Create(""http"", ""metadata.google.internal."", attribute_,+                               {} /* query params */, """" /* fragment */);+    GPR_ASSERT(uri.ok());  // params are hardcoded+    grpc_http_request request;+    memset(&request, 0, sizeof(grpc_http_request));+    grpc_http_header header = {const_cast<char*>(""Metadata-Flavor""),+                               const_cast<char*>(""Google"")};+    request.hdr_count = 1;+    request.hdrs = &header;+    // The http call is local. If it takes more than one sec, it is probably not+    // on GCP.+    auto http_request = grpc_core::HttpRequest::Get(+        std::move(*uri), nullptr /* channel args */, pollent, &request,+        grpc_core::Timestamp::Now() + grpc_core::Duration::Seconds(1),+        &on_done_, &response_,+        grpc_core::RefCountedPtr<grpc_channel_credentials>(+            grpc_insecure_credentials_create()));+    http_request->Start();+  }++ private:+  static void OnDone(void* arg, grpc_error_handle error) {+    auto* self = static_cast<MetadataQuery*>(arg);+    std::string result;+    if (!error.ok()) {+      gpr_log(GPR_ERROR, ""MetadataServer Query failed for %s: %s"",+              self->attribute_.c_str(),+              grpc_core::StatusToString(error).c_str());+    } else if (self->response_.status != 200) {+      gpr_log(+          GPR_ERROR, ""MetadataServer Query received non-200 status for %s: %s"",+          self->attribute_.c_str(), grpc_core::StatusToString(error).c_str());+    } else if (self->attribute_ == kZoneAttribute) {+      absl::string_view body(self->response_.body, self->response_.body_length);+      size_t pos = result.find_last_of('/');+      if (pos == body.npos) {+        gpr_log(GPR_ERROR, ""MetadataServer Could not parse zone: %s"",+                std::string(body).c_str());+      } else {+        result = std::string(body.substr(pos + 1));+      }+    } else {+      result = self->response_.body;+    }+    auto callback = std::move(self->callback_);+    auto attribute = std::move(self->attribute_);+    delete self;+    return callback(std::move(attribute), std::move(result));+  }++  grpc_closure on_done_;+  std::string attribute_;+  absl::AnyInvocable<void(std::string /* attribute */,+                          std::string /* result */)>+      callback_;+  grpc_http_response response_;+};++// This is not a definite method to get the namespace name for GKE, but it is+// the best we have.+std::string GetNamespaceName() {+  // Read the root file.+  const char* filename =+      ""/var/run/secrets/kubernetes.io/serviceaccount/namespace"";+  auto namespace_name = grpc_core::LoadFile(filename, false);+  if (!namespace_name.ok()) {+    gpr_log(GPR_DEBUG, ""Reading file %s failed: %s"", filename,+            grpc_core::StatusToString(namespace_name.status()).c_str());+    // Fallback on an environment variable+    return grpc_core::GetEnv(""NAMESPACE_NAME"").value_or("""");+  }+  return std::string(reinterpret_cast<const char*>((*namespace_name).begin()),+                     (*namespace_name).length());+}++// Get pod name for GKE+std::string GetPodName() {+  auto pod_name = grpc_core::GetEnv(""POD_NAME"");+  if (pod_name.has_value()) {+    return pod_name.value();+  }+  return grpc_core::GetEnv(""HOSTNAME"").value_or("""");+}++// Get container name for GKE+std::string GetContainerName() {+  return grpc_core::GetEnv(""HOSTNAME"").value_or("""");+}++// Get function name for Cloud Functions+std::string GetFunctionName() {+  auto k_service = grpc_core::GetEnv(""K_SERVICE"");+  if (k_service.has_value()) {+    return k_service.value();+  }+  return grpc_core::GetEnv(""FUNCTION_NAME"").value_or("""");+}++// Get revision name for Cloud run+std::string GetRevisionName() {+  return grpc_core::GetEnv(""K_REVISION"").value_or("""");+}++// Get service name for Cloud run+std::string GetServiceName() {+  return grpc_core::GetEnv(""K_SERVICE"").value_or("""");+}++// Get configuration name for Cloud run+std::string GetConfiguratioName() {+  return grpc_core::GetEnv(""K_CONFIGURATION"").value_or("""");+}++// Get module ID for App Engine+std::string GetModuleId() {+  return grpc_core::GetEnv(""GAE_SERVICE"").value_or("""");+}++// Get version ID for App Engine+std::string GetVersionId() {+  return grpc_core::GetEnv(""GAE_VERSION"").value_or("""");+}++// Fire and forget class+class EnvironmentAutoDetectHelper {+ public:+  explicit EnvironmentAutoDetectHelper(+      std::string project_id, grpc_polling_entity* pollent,+      absl::AnyInvocable<void(EnvironmentAutoDetect::ResourceType)> on_done)+      : project_id_(std::move(project_id)),+        pollent_(pollent),+        on_done_(std::move(on_done)) {+    grpc_core::MutexLock lock(&mu_);+    // GKE+    resource_.labels.emplace(""project_id"", project_id_);+    if (grpc_core::GetEnv(""KUBERNETES_SERVICE_HOST"").has_value()) {+      resource_.resource_type = ""k8s_container"";+      resource_.labels.emplace(""namespace_name"", GetNamespaceName());+      resource_.labels.emplace(""pod_name"", GetPodName());+      resource_.labels.emplace(""container_name"", GetContainerName());+      attributes_to_fetch_.push_back({""location"", kZoneAttribute});+      attributes_to_fetch_.push_back({""cluster_name"", kClusterNameAttribute});+    }+    // Cloud Functions+    else if (grpc_core::GetEnv(""FUNCTION_NAME"").has_value() ||+             grpc_core::GetEnv(""FUNCTION_TARGET"").has_value()) {+      resource_.resource_type = ""cloud_function"";+      resource_.labels.emplace(""function_name"", GetFunctionName());+      attributes_to_fetch_.push_back({""region"", kRegionAttribute});+    }+    // Cloud Run+    else if (grpc_core::GetEnv(""K_CONFIGURATION"").has_value()) {+      resource_.resource_type = ""cloud_run_revision"";+      resource_.labels.emplace(""revision_name"", GetRevisionName());+      resource_.labels.emplace(""service_name"", GetServiceName());+      resource_.labels.emplace(""configuration_name"", GetConfiguratioName());+      attributes_to_fetch_.push_back({""location"", kRegionAttribute});+    }+    // App Engine+    else if (grpc_core::GetEnv(""GAE_SERVICE"").has_value()) {+      resource_.resource_type = ""gae_app"";+      resource_.labels.emplace(""module_id"", GetModuleId());+      resource_.labels.emplace(""version_id"", GetVersionId());+      attributes_to_fetch_.push_back({""zone"", kZoneAttribute});+    }+    // Assume GCE+    else {+      assuming_gce_ = true;+      resource_.resource_type = ""gce_instance"";+      attributes_to_fetch_.push_back({""instance_id"", kInstanceIdAttribute});+      attributes_to_fetch_.push_back({""zone"", kZoneAttribute});+    }+    FetchMetadataServerAttributesAsynchronouslyLocked();+  }++ private:+  struct Attribute {+    std::string resource_attribute;+    std::string metadata_server_atttribute;+  };++  const std::string project_id_;+  grpc_polling_entity* pollent_;+  absl::AnyInvocable<void(EnvironmentAutoDetect::ResourceType)> on_done_;+  grpc_core::Mutex mu_;+  std::list<Attribute> attributes_to_fetch_ ABSL_GUARDED_BY(mu_);","This seems like it would be simpler & clearer if it was a `flat_hash_map<string /* metadata_server_attribute */, string /* resource_attribute */>`",X
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/32303,1097544631,2023-02-06T15:31:48Z,src/cpp/ext/filters/census/client_filter.cc,"@@ -68,53 +75,42 @@ constexpr uint32_t     OpenCensusCallTracer::OpenCensusCallAttemptTracer::kMaxTagsLen;  //-// OpenCensusClientChannelData+// OpenCensusClientFilter // -grpc_error_handle OpenCensusClientChannelData::Init(-    grpc_channel_element* /*elem*/, grpc_channel_element_args* args) {+const grpc_channel_filter OpenCensusClientFilter::kFilter =+    grpc_core::MakePromiseBasedFilter<+        OpenCensusClientFilter, grpc_core::FilterEndpoint::kClient,+        grpc_core::kFilterExaminesServerInitialMetadata>(""opencensus_client"");",I don't see where this examines server initial metadata?,
4181124,yashykt,https://api.github.com/repos/grpc/grpc/pulls/32303,1097936826,2023-02-06T21:27:02Z,src/cpp/ext/filters/census/client_filter.cc,"@@ -68,53 +75,42 @@ constexpr uint32_t     OpenCensusCallTracer::OpenCensusCallAttemptTracer::kMaxTagsLen;  //-// OpenCensusClientChannelData+// OpenCensusClientFilter // -grpc_error_handle OpenCensusClientChannelData::Init(-    grpc_channel_element* /*elem*/, grpc_channel_element_args* args) {+const grpc_channel_filter OpenCensusClientFilter::kFilter =+    grpc_core::MakePromiseBasedFilter<+        OpenCensusClientFilter, grpc_core::FilterEndpoint::kClient,+        grpc_core::kFilterExaminesServerInitialMetadata>(""opencensus_client"");","Thanks! Yeah, I think I misread it as client initial metadata. This makes more sense!",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32327,1100482652,2023-02-08T17:43:47Z,test/core/end2end/tests/max_connection_age.cc,"@@ -157,68 +157,83 @@ static void test_max_age_forcibly_close(grpc_end2end_test_config config) {       grpc_server_request_call(f.server, &s, &call_details,                                &request_metadata_recv, f.cq, f.cq, tag(101));   GPR_ASSERT(GRPC_CALL_OK == error);-  cqv->Expect(tag(101), true);-  cqv->Verify();--  gpr_timespec expect_shutdown_time = grpc_timeout_milliseconds_to_deadline(-      static_cast<int>(MAX_CONNECTION_AGE_MS *-                       MAX_CONNECTION_AGE_JITTER_MULTIPLIER) +-      MAX_CONNECTION_AGE_GRACE_MS + IMMEDIATE_SHUTDOWN_GRACE_TIME_MS);--  // Wait for the channel to reach its max age-  cqv->VerifyEmpty(-      grpc_core::Duration::Seconds(CQ_MAX_CONNECTION_AGE_WAIT_TIME_S));--  // After the channel reaches its max age, we still do nothing here. And wait-  // for it to use up its max age grace period.-  cqv->Expect(tag(1), true);-  cqv->Verify();--  gpr_timespec channel_shutdown_time = gpr_now(GPR_CLOCK_MONOTONIC);-  GPR_ASSERT(gpr_time_cmp(channel_shutdown_time, expect_shutdown_time) < 0); -  memset(ops, 0, sizeof(ops));-  op = ops;-  op->op = GRPC_OP_SEND_INITIAL_METADATA;-  op->data.send_initial_metadata.count = 0;-  op->flags = 0;-  op->reserved = nullptr;-  op++;-  op->op = GRPC_OP_SEND_STATUS_FROM_SERVER;-  op->data.send_status_from_server.trailing_metadata_count = 0;-  op->data.send_status_from_server.status = GRPC_STATUS_UNIMPLEMENTED;-  grpc_slice status_details = grpc_slice_from_static_string(""xyz"");-  op->data.send_status_from_server.status_details = &status_details;-  op->flags = 0;-  op->reserved = nullptr;-  op++;-  op->op = GRPC_OP_RECV_CLOSE_ON_SERVER;-  op->data.recv_close_on_server.cancelled = &was_cancelled;-  op->flags = 0;-  op->reserved = nullptr;-  op++;-  error = grpc_call_start_batch(s, ops, static_cast<size_t>(op - ops), tag(102),-                                nullptr);-  GPR_ASSERT(GRPC_CALL_OK == error);-  cqv->Expect(tag(102), true);-  cqv->Verify();+  grpc_event ev = grpc_completion_queue_next(+      f.cq, gpr_inf_future(GPR_CLOCK_MONOTONIC), nullptr);+  GPR_ASSERT(ev.type == GRPC_OP_COMPLETE);+  GPR_ASSERT(ev.tag == tag(1) || ev.tag == tag(101));++  if (ev.tag == tag(101)) {+    // Request got through to the server before connection timeout++    // Wait for the channel to reach its max age+    cqv->VerifyEmpty(+        grpc_core::Duration::Seconds(CQ_MAX_CONNECTION_AGE_WAIT_TIME_S));++    // After the channel reaches its max age, we still do nothing here. And wait+    // for it to use up its max age grace period.+    cqv->Expect(tag(1), true);+    cqv->Verify();++    gpr_timespec expect_shutdown_time = grpc_timeout_milliseconds_to_deadline(+        static_cast<int>(MAX_CONNECTION_AGE_MS *+                         MAX_CONNECTION_AGE_JITTER_MULTIPLIER) ++        MAX_CONNECTION_AGE_GRACE_MS + IMMEDIATE_SHUTDOWN_GRACE_TIME_MS);++    gpr_timespec channel_shutdown_time = gpr_now(GPR_CLOCK_MONOTONIC);+    GPR_ASSERT(gpr_time_cmp(channel_shutdown_time, expect_shutdown_time) < 0);++    memset(ops, 0, sizeof(ops));+    op = ops;+    op->op = GRPC_OP_SEND_INITIAL_METADATA;+    op->data.send_initial_metadata.count = 0;+    op->flags = 0;+    op->reserved = nullptr;+    op++;+    op->op = GRPC_OP_SEND_STATUS_FROM_SERVER;+    op->data.send_status_from_server.trailing_metadata_count = 0;+    op->data.send_status_from_server.status = GRPC_STATUS_UNIMPLEMENTED;+    grpc_slice status_details = grpc_slice_from_static_string(""xyz"");+    op->data.send_status_from_server.status_details = &status_details;+    op->flags = 0;+    op->reserved = nullptr;+    op++;+    op->op = GRPC_OP_RECV_CLOSE_ON_SERVER;+    op->data.recv_close_on_server.cancelled = &was_cancelled;+    op->flags = 0;+    op->reserved = nullptr;+    op++;+    error = grpc_call_start_batch(s, ops, static_cast<size_t>(op - ops),+                                  tag(102), nullptr);+    GPR_ASSERT(GRPC_CALL_OK == error);+    cqv->Expect(tag(102), true);+    cqv->Verify();++    GPR_ASSERT(0 == grpc_slice_str_cmp(call_details.method, ""/foo""));+    GPR_ASSERT(was_cancelled == 1);+  } else {+    // Request failed before getting to the server","In this case, aren't we basically not testing what we're supposed to be testing here?I'm wondering if it would be safer to just increase the max age time so that it's long enough to ensure that the call always gets to the server before it hits.  I realize that's more of a whack-a-mole solution, but it seems like it would at least give us some indication if things get slow enough that the test stops covering what it's supposed to.",
52979934,matthewstevenson88,https://api.github.com/repos/grpc/grpc/pulls/32335,1101832346,2023-02-09T17:52:10Z,include/grpc/grpc_security.h,"@@ -931,6 +931,9 @@ typedef struct grpc_tls_custom_verification_check_request {      * grpc_security_constants.h.      * TODO(ZhenLian): Consider fixing this in the future. */     const char* peer_cert_full_chain;+    /* The verified root cert subject.+     * This value will only be filled if the validation was successful */","nit: I'd suggest we say ""cryptographic peer certificate verification"" instead of ""validation"".Rationale: I think it's important to disambiguate between the ""validator"" that we're modifying here (which occurs after the TLS handshake) and the cryptographic verification (which happens during the TLS handshake).",
52979934,matthewstevenson88,https://api.github.com/repos/grpc/grpc/pulls/32335,1101835949,2023-02-09T17:55:38Z,include/grpcpp/security/tls_certificate_verifier.h,"@@ -62,10 +62,12 @@ class TlsCustomVerificationCheckRequest {   grpc::string_ref peer_cert() const;   grpc::string_ref peer_cert_full_chain() const;   grpc::string_ref common_name() const;+  grpc::string_ref verified_root_cert_subject() const;","We need to be explicit about the contract/format for this API: for example,* If verification fails or the peer cert is self-signed, this will be the empty string.* If verification is successful, it is a comma-separated list, where the entries are of the form ""FIELD_ABBREVIATION=string"" and give a list of supported field abbreviations.We also need tests to ensure that this contract is adhered to.",
16962414,gtcooke94,https://api.github.com/repos/grpc/grpc/pulls/32335,1102056515,2023-02-09T21:46:46Z,include/grpcpp/security/tls_certificate_verifier.h,"@@ -62,10 +62,12 @@ class TlsCustomVerificationCheckRequest {   grpc::string_ref peer_cert() const;   grpc::string_ref peer_cert_full_chain() const;   grpc::string_ref common_name() const;+  grpc::string_ref verified_root_cert_subject() const;","Working on more unit tests for this, particularly the self-signed cert scenario.In terms of listing all support field abbreviations, I hesitate to create a listing of them here - it should be a list of anything that is valid for the subject name of a certificate, so the best place to get that information is the user's certificate, or an RFC",
4181124,yashykt,https://api.github.com/repos/grpc/grpc/pulls/32295,1102176036,2023-02-10T01:06:00Z,src/core/lib/event_engine/windows/windows_listener.h,"@@ -0,0 +1,126 @@+// Copyright 2023 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+#ifndef GRPC_SRC_CORE_LIB_EVENT_ENGINE_WINDOWS_WINDOWS_LISTENER_H+#define GRPC_SRC_CORE_LIB_EVENT_ENGINE_WINDOWS_WINDOWS_LISTENER_H++#include <grpc/support/port_platform.h>++#ifdef GPR_WINDOWS++#include <list>++#include ""absl/status/statusor.h""++#include <grpc/event_engine/event_engine.h>+#include <grpc/event_engine/memory_allocator.h>++#include ""src/core/lib/event_engine/common_closures.h""+#include ""src/core/lib/event_engine/windows/iocp.h""+#include ""src/core/lib/gprpp/orphanable.h""+#include ""src/core/lib/gprpp/sync.h""++namespace grpc_event_engine {+namespace experimental {++class WindowsEventEngineListener : public EventEngine::Listener {+ public:+  WindowsEventEngineListener(+      IOCP* iocp, AcceptCallback accept_cb,+      absl::AnyInvocable<void(absl::Status)> on_shutdown,+      std::unique_ptr<MemoryAllocatorFactory> memory_allocator_factory,+      Executor* executor, const EndpointConfig& config);+  ~WindowsEventEngineListener() override;+  absl::StatusOr<int> Bind(const EventEngine::ResolvedAddress& addr) override;+  absl::Status Start() override;++ private:+  friend class SinglePortSocketListener;",SinglePortSocketListener is an inner class right? Do you still need this?,
4181124,yashykt,https://api.github.com/repos/grpc/grpc/pulls/32295,1102213797,2023-02-10T02:26:43Z,src/core/lib/event_engine/windows/windows_listener.h,"@@ -0,0 +1,126 @@+// Copyright 2023 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+#ifndef GRPC_SRC_CORE_LIB_EVENT_ENGINE_WINDOWS_WINDOWS_LISTENER_H+#define GRPC_SRC_CORE_LIB_EVENT_ENGINE_WINDOWS_WINDOWS_LISTENER_H++#include <grpc/support/port_platform.h>++#ifdef GPR_WINDOWS++#include <list>++#include ""absl/status/statusor.h""++#include <grpc/event_engine/event_engine.h>+#include <grpc/event_engine/memory_allocator.h>++#include ""src/core/lib/event_engine/common_closures.h""+#include ""src/core/lib/event_engine/windows/iocp.h""+#include ""src/core/lib/gprpp/orphanable.h""+#include ""src/core/lib/gprpp/sync.h""++namespace grpc_event_engine {+namespace experimental {++class WindowsEventEngineListener : public EventEngine::Listener {+ public:+  WindowsEventEngineListener(+      IOCP* iocp, AcceptCallback accept_cb,+      absl::AnyInvocable<void(absl::Status)> on_shutdown,+      std::unique_ptr<MemoryAllocatorFactory> memory_allocator_factory,+      Executor* executor, const EndpointConfig& config);+  ~WindowsEventEngineListener() override;+  absl::StatusOr<int> Bind(const EventEngine::ResolvedAddress& addr) override;+  absl::Status Start() override;++ private:+  friend class SinglePortSocketListener;+  /// Responsible for listening on a single port.+  class SinglePortSocketListener {+   public:+    ~SinglePortSocketListener();+    // This factory will create a bound, listening WinSocket, registered with+    // the listener's IOCP poller.+    static absl::StatusOr<std::unique_ptr<SinglePortSocketListener>> Create(+        WindowsEventEngineListener* listener, SOCKET sock,+        EventEngine::ResolvedAddress addr);++    // Two-stage initialization, allows creation of all bound sockets before the+    // listener is started.+    absl::Status Start();+    absl::Status StartLocked() ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu_);++    // Accessor methods+    EventEngine::ResolvedAddress listener_sockname() {+      return listener_sockname_;+    };+    int port() { return port_; }+    WinSocket* listener_socket() { return listener_socket_.get(); }++   private:+    SinglePortSocketListener(WindowsEventEngineListener* listener,+                             LPFN_ACCEPTEX AcceptEx,+                             grpc_core::OrphanablePtr<WinSocket> win_socket,+                             int port, EventEngine::ResolvedAddress hostbyname);++    // Bind a recently-created socket for listening+    struct PrepareListenerSocketResult {+      int port;+      EventEngine::ResolvedAddress hostbyname;+    };+    static absl::StatusOr<PrepareListenerSocketResult> PrepareListenerSocket(+        SOCKET sock, const EventEngine::ResolvedAddress& addr);++    void OnAcceptCallbackImpl();++    // The cached AcceptEx for that port.+    LPFN_ACCEPTEX AcceptEx;+    // This seemingly magic number comes from AcceptEx's documentation. each+    // address buffer needs to have at least 16 more bytes at their end.+    uint8_t addresses_[(sizeof(sockaddr_in6) + 16) * 2] = {};+    // The parent listener+    WindowsEventEngineListener* listener_;+    // closure for socket notification of accept being ready+    AnyInvocableClosure on_accept_;+    // The actual TCP port number.+    int port_;+    // Syncronize accept handling on the same socket.+    grpc_core::Mutex mu_;+    // This will hold the socket for the next accept.+    SOCKET accept_socket_ ABSL_GUARDED_BY(mu_) = INVALID_SOCKET;+    // The listener winsocket.+    grpc_core::OrphanablePtr<WinSocket> listener_socket_ ABSL_GUARDED_BY(mu_);+    EventEngine::ResolvedAddress listener_sockname_;+  };+  absl::StatusOr<SinglePortSocketListener*> AddSinglePortSocketListener(+      SOCKET sock, EventEngine::ResolvedAddress addr);++  IOCP* iocp_;",maybe change the ordering of the data members to start with the stuff that doesn't change through the life of the object.,
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/32295,1102246345,2023-02-10T03:48:23Z,src/core/lib/event_engine/windows/windows_listener.h,"@@ -0,0 +1,126 @@+// Copyright 2023 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+#ifndef GRPC_SRC_CORE_LIB_EVENT_ENGINE_WINDOWS_WINDOWS_LISTENER_H+#define GRPC_SRC_CORE_LIB_EVENT_ENGINE_WINDOWS_WINDOWS_LISTENER_H++#include <grpc/support/port_platform.h>++#ifdef GPR_WINDOWS++#include <list>++#include ""absl/status/statusor.h""++#include <grpc/event_engine/event_engine.h>+#include <grpc/event_engine/memory_allocator.h>++#include ""src/core/lib/event_engine/common_closures.h""+#include ""src/core/lib/event_engine/windows/iocp.h""+#include ""src/core/lib/gprpp/orphanable.h""+#include ""src/core/lib/gprpp/sync.h""++namespace grpc_event_engine {+namespace experimental {++class WindowsEventEngineListener : public EventEngine::Listener {+ public:+  WindowsEventEngineListener(+      IOCP* iocp, AcceptCallback accept_cb,+      absl::AnyInvocable<void(absl::Status)> on_shutdown,+      std::unique_ptr<MemoryAllocatorFactory> memory_allocator_factory,+      Executor* executor, const EndpointConfig& config);+  ~WindowsEventEngineListener() override;+  absl::StatusOr<int> Bind(const EventEngine::ResolvedAddress& addr) override;+  absl::Status Start() override;++ private:+  friend class SinglePortSocketListener;","We do not need it, thanks. I had initially hidden the class declaration in the `cc` file, but opted to put it here instead.",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/32308,1102942735,2023-02-10T16:02:53Z,src/core/lib/promise/activity.cc,"@@ -124,7 +124,7 @@ void FreestandingActivity::DropHandle() {  Waker FreestandingActivity::MakeNonOwningWaker() {   mu_.AssertHeld();","I'll give it a shot again... compiler was getting messed up last time I tried it.That said, I think longer term this class goes away and we make everything `Party`",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/32308,1103013700,2023-02-10T17:06:37Z,src/core/lib/promise/activity.h,"@@ -51,108 +51,93 @@ class Wakeable {  public:   // Wake up the underlying activity.   // After calling, this Wakeable cannot be used again.-  virtual void Wakeup() = 0;+  // arg comes from the Waker object and allows one Wakeable instance to be used+  // for multiple disjoint subparts of an Activity.+  virtual void Wakeup(void* arg) = 0;   // Drop this wakeable without waking up the underlying activity.-  virtual void Drop() = 0;+  virtual void Drop(void* arg) = 0;    // Return the underlying activity debug tag, or ""<unknown>"" if not available.-  virtual std::string ActivityDebugTag() const = 0;+  virtual std::string ActivityDebugTag(void* arg) const = 0;   protected:   inline ~Wakeable() {} };  namespace promise_detail { struct Unwakeable final : public Wakeable {-  void Wakeup() override {}-  void Drop() override {}-  std::string ActivityDebugTag() const override;+  void Wakeup(void*) override {}+  void Drop(void*) override {}+  std::string ActivityDebugTag(void*) const override; }; static Unwakeable* unwakeable() {   return NoDestructSingleton<Unwakeable>::Get(); } }  // namespace promise_detail -class AtomicWaker;- // An owning reference to a Wakeable. // This type is non-copyable but movable. class Waker {  public:-  explicit Waker(Wakeable* wakeable) : wakeable_(wakeable) {}-  Waker() : Waker(promise_detail::unwakeable()) {}-  ~Waker() { wakeable_->Drop(); }+  Waker(Wakeable* wakeable, void* arg) : wakeable_and_arg_{wakeable, arg} {}+  Waker() : Waker(promise_detail::unwakeable(), nullptr) {}+  ~Waker() { wakeable_and_arg_.Drop(); }   Waker(const Waker&) = delete;   Waker& operator=(const Waker&) = delete;-  Waker(Waker&& other) noexcept : wakeable_(other.Take()) {}+  Waker(Waker&& other) noexcept : wakeable_and_arg_(other.Take()) {}   Waker& operator=(Waker&& other) noexcept {-    std::swap(wakeable_, other.wakeable_);+    std::swap(wakeable_and_arg_, other.wakeable_and_arg_);     return *this;   }    // Wake the underlying activity.-  void Wakeup() { Take()->Wakeup(); }+  void Wakeup() { Take().Wakeup(); }    template <typename H>   friend H AbslHashValue(H h, const Waker& w) {-    return H::combine(std::move(h), w.wakeable_);+    return H::combine(H::combine(std::move(h), w.wakeable_and_arg_.wakeable),+                      w.wakeable_and_arg_.arg);   }    bool operator==(const Waker& other) const noexcept {-    return wakeable_ == other.wakeable_;+    return wakeable_and_arg_ == other.wakeable_and_arg_;   }    bool operator!=(const Waker& other) const noexcept {-    return wakeable_ != other.wakeable_;+    return !operator==(other);   }    std::string ActivityDebugTag() {-    return wakeable_ == nullptr ? ""<unknown>"" : wakeable_->ActivityDebugTag();+    return wakeable_and_arg_.ActivityDebugTag();   } - private:-  friend class AtomicWaker;--  Wakeable* Take() {-    return std::exchange(wakeable_, promise_detail::unwakeable());-  }--  Wakeable* wakeable_;-};--// An atomic variant of Waker - this type is non-copyable and non-movable.-class AtomicWaker {- public:-  explicit AtomicWaker(Wakeable* wakeable) : wakeable_(wakeable) {}-  AtomicWaker() : AtomicWaker(promise_detail::unwakeable()) {}-  explicit AtomicWaker(Waker waker) : AtomicWaker(waker.Take()) {}-  ~AtomicWaker() { wakeable_.load(std::memory_order_acquire)->Drop(); }-  AtomicWaker(const AtomicWaker&) = delete;-  AtomicWaker& operator=(const AtomicWaker&) = delete;-  AtomicWaker(AtomicWaker&& other) noexcept = delete;-  AtomicWaker& operator=(AtomicWaker&& other) noexcept = delete;--  // Wake the underlying activity.-  void Wakeup() { Take()->Wakeup(); }--  // Return true if there is a not-unwakeable wakeable present.-  bool Armed() const noexcept {-    return wakeable_.load(std::memory_order_relaxed) !=-           promise_detail::unwakeable();-  }--  // Set to some new waker-  void Set(Waker waker) {-    wakeable_.exchange(waker.Take(), std::memory_order_acq_rel)->Wakeup();+  // This is for tests to assert that a waker is occupied or not.+  bool is_unwakeable() const {+    return wakeable_and_arg_.wakeable == promise_detail::unwakeable();   }   private:-  Wakeable* Take() {-    return wakeable_.exchange(promise_detail::unwakeable(),-                              std::memory_order_acq_rel);+  struct WakeableAndArg {+    Wakeable* wakeable;+    void* arg;++    void Wakeup() { wakeable->Wakeup(arg); }+    void Drop() { wakeable->Drop(arg); }+    std::string ActivityDebugTag() const {+      return wakeable == nullptr ? ""<unknown>""+                                 : wakeable->ActivityDebugTag(arg);+    }+    bool operator==(const WakeableAndArg& other) const noexcept {+      return wakeable == other.wakeable && arg == other.arg;+    }+  };++  WakeableAndArg Take() {+    return std::exchange(wakeable_and_arg_,","it's shorthand for:```auto r = wakeable_and_arg_;wakeable_and_arg_ = {promise_detail::unwakeable(), nullptr};return r;```we use the pattern relatively frequently",
52979934,matthewstevenson88,https://api.github.com/repos/grpc/grpc/pulls/32335,1103116519,2023-02-10T18:52:43Z,test/core/security/tls_security_connector_test.cc,"@@ -737,6 +737,44 @@ TEST_F(TlsSecurityConnectorTest,                             on_peer_checked); } +TEST_F(TlsSecurityConnectorTest,+       ChannelSecurityConnectorWithVerifiedRootCertSubjectSucceeds) {+  auto* sync_verifier_ = new SyncExternalVerifier(true);","nit: The `_` suffix should not be used on this local variable, only for class member fields.",
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/32294,1103160290,2023-02-10T19:36:43Z,src/cpp/ext/filters/census/environment_autodetect.cc,"@@ -0,0 +1,421 @@+//+//+// Copyright 2023 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+//+//++#include ""src/cpp/ext/filters/census/environment_autodetect.h""++#include <grpc/support/port_platform.h>+#include <string.h>+#include <grpc/event_engine/event_engine.h>+#include <grpc/grpc.h>+#include <grpc/grpc_security.h>+#include <grpc/support/log.h>+#include <grpcpp/impl/grpc_library.h>+#include <grpc/support/alloc.h>+#include <grpc/support/sync.h>+#include <algorithm>+#include <memory>+#include <utility>++#include ""absl/container/flat_hash_map.h""+#include ""absl/meta/type_traits.h""+#include ""absl/status/status.h""+#include ""absl/status/statusor.h""+#include ""absl/strings/string_view.h""+#include ""absl/types/optional.h""+#include ""src/core/lib/event_engine/default_event_engine.h""+#include ""src/core/lib/gprpp/env.h""+#include ""src/core/lib/gprpp/load_file.h""+#include ""src/core/lib/gprpp/ref_counted_ptr.h""+#include ""src/core/lib/gprpp/status_helper.h""+#include ""src/core/lib/gprpp/thd.h""+#include ""src/core/lib/gprpp/time.h""+#include ""src/core/lib/http/httpcli.h""+#include ""src/core/lib/http/parser.h""+#include ""src/core/lib/iomgr/closure.h""+#include ""src/core/lib/security/credentials/credentials.h""+#include ""src/core/lib/slice/slice.h""+#include ""src/core/lib/uri/uri_parser.h""+#include ""src/core/lib/gprpp/orphanable.h""+#include ""src/core/lib/iomgr/error.h""+#include ""src/core/lib/iomgr/exec_ctx.h""+#include ""src/core/lib/iomgr/iomgr_fwd.h""+#include ""src/core/lib/iomgr/polling_entity.h""+#include ""src/core/lib/iomgr/pollset.h""++namespace grpc {+namespace internal {++namespace {++constexpr const char kZoneAttribute[] = ""/computeMetadata/v1/instance/zone"";+constexpr const char kClusterNameAttribute[] =+    ""/computeMetadata/v1/instance/attributes/cluster-name"";+constexpr const char kRegionAttribute[] = ""/computeMetadata/v1/instance/region"";+constexpr const char kInstanceIdAttribute[] = ""/computeMetadata/v1/instance/id"";++// Fire and Forget class (Cleans up after itself.)+// Fetches the value of an attribute from the MetadataServer on a GCP+// environment.+class MetadataQuery {+ public:+  MetadataQuery(std::string attribute, grpc_polling_entity* pollent,+                absl::AnyInvocable<void(std::string /* attribute */,+                                        std::string /* result */)>+                    callback)+      : attribute_(std::move(attribute)), callback_(std::move(callback)) {+    GRPC_CLOSURE_INIT(&on_done_, OnDone, this, nullptr);+    auto uri =+        grpc_core::URI::Create(""http"", ""metadata.google.internal."", attribute_,+                               {} /* query params */, """" /* fragment */);+    GPR_ASSERT(uri.ok());  // params are hardcoded+    grpc_http_request request;+    memset(&request, 0, sizeof(grpc_http_request));+    grpc_http_header header = {const_cast<char*>(""Metadata-Flavor""),+                               const_cast<char*>(""Google"")};+    request.hdr_count = 1;+    request.hdrs = &header;+    // The http call is local. If it takes more than one sec, it is probably not+    // on GCP.+    auto http_request = grpc_core::HttpRequest::Get(+        std::move(*uri), nullptr /* channel args */, pollent, &request,+        grpc_core::Timestamp::Now() + grpc_core::Duration::Seconds(1),+        &on_done_, &response_,+        grpc_core::RefCountedPtr<grpc_channel_credentials>(+            grpc_insecure_credentials_create()));+    http_request->Start();+  }++ private:+  static void OnDone(void* arg, absl::Status error) {+    auto* self = static_cast<MetadataQuery*>(arg);+    std::string result;+    if (!error.ok()) {+      gpr_log(GPR_ERROR, ""MetadataServer Query failed for %s: %s"",+              self->attribute_.c_str(),+              grpc_core::StatusToString(error).c_str());+    } else if (self->response_.status != 200) {+      gpr_log(+          GPR_ERROR, ""MetadataServer Query received non-200 status for %s: %s"",+          self->attribute_.c_str(), grpc_core::StatusToString(error).c_str());+    } else if (self->attribute_ == kZoneAttribute) {+      absl::string_view body(self->response_.body, self->response_.body_length);+      size_t pos = result.find_last_of('/');+      if (pos == body.npos) {+        gpr_log(GPR_ERROR, ""MetadataServer Could not parse zone: %s"",+                std::string(body).c_str());+      } else {+        result = std::string(body.substr(pos + 1));+      }+    } else {+      result = self->response_.body;+    }+    auto callback = std::move(self->callback_);+    auto attribute = std::move(self->attribute_);+    delete self;+    return callback(std::move(attribute), std::move(result));+  }++  grpc_closure on_done_;+  std::string attribute_;+  absl::AnyInvocable<void(std::string /* attribute */,+                          std::string /* result */)>+      callback_;+  grpc_http_response response_;+};++// This is not a definite method to get the namespace name for GKE, but it is+// the best we have.+std::string GetNamespaceName() {+  // Read the root file.+  const char* filename =+      ""/var/run/secrets/kubernetes.io/serviceaccount/namespace"";+  auto namespace_name = grpc_core::LoadFile(filename, false);+  if (!namespace_name.ok()) {+    gpr_log(GPR_DEBUG, ""Reading file %s failed: %s"", filename,+            grpc_core::StatusToString(namespace_name.status()).c_str());+    // Fallback on an environment variable+    return grpc_core::GetEnv(""NAMESPACE_NAME"").value_or("""");+  }+  return std::string(reinterpret_cast<const char*>((*namespace_name).begin()),+                     (*namespace_name).length());+}++// Get pod name for GKE+std::string GetPodName() {+  auto pod_name = grpc_core::GetEnv(""POD_NAME"");+  if (pod_name.has_value()) {+    return pod_name.value();+  }+  return grpc_core::GetEnv(""HOSTNAME"").value_or("""");+}++// Get container name for GKE+std::string GetContainerName() {+  return grpc_core::GetEnv(""HOSTNAME"").value_or("""");+}++// Get function name for Cloud Functions+std::string GetFunctionName() {+  auto k_service = grpc_core::GetEnv(""K_SERVICE"");+  if (k_service.has_value()) {+    return k_service.value();+  }+  return grpc_core::GetEnv(""FUNCTION_NAME"").value_or("""");+}++// Get revision name for Cloud run+std::string GetRevisionName() {+  return grpc_core::GetEnv(""K_REVISION"").value_or("""");+}++// Get service name for Cloud run+std::string GetServiceName() {+  return grpc_core::GetEnv(""K_SERVICE"").value_or("""");+}++// Get configuration name for Cloud run+std::string GetConfiguratioName() {+  return grpc_core::GetEnv(""K_CONFIGURATION"").value_or("""");+}++// Get module ID for App Engine+std::string GetModuleId() {+  return grpc_core::GetEnv(""GAE_SERVICE"").value_or("""");+}++// Get version ID for App Engine+std::string GetVersionId() {+  return grpc_core::GetEnv(""GAE_VERSION"").value_or("""");+}++// Fire and forget class+class EnvironmentAutoDetectHelper+    : public grpc_core::InternallyRefCounted<EnvironmentAutoDetectHelper>,+      private internal::GrpcLibrary {+ public:+  explicit EnvironmentAutoDetectHelper(+      std::string project_id,+      absl::AnyInvocable<void(EnvironmentAutoDetect::ResourceType)> on_done)+      : InternallyRefCounted(/*trace=*/nullptr, /*initial_refcount=*/2),+        project_id_(std::move(project_id)),+        on_done_(std::move(on_done)) {+    grpc_core::ExecCtx exec_ctx;+    // TODO(yashykt): The pollset stuff should go away once the HTTP library is+    // ported over to use EventEngine.+    pollset_ = static_cast<grpc_pollset*>(gpr_zalloc(grpc_pollset_size()));+    grpc_pollset_init(pollset_, &mu_poll_);+    pollent_ = grpc_polling_entity_create_from_pollset(pollset_);+    poller_ = grpc_core::Thread(","This can be replaced by `GetDefaultEventEngine()->Run([this]{ PollLoop(); });`. Note that with either a thread like this or using EventEngine::Run, we don't strictly have to worry about fork support since this is in C++ code, not the core library where Python requires a clean fork story, but it might be worth adding a comment that this is not fork-safe for anyone who wants fork support in C++. If you want to make this fork-safe, we can have a short design chat.",
672669,sergiitk,https://api.github.com/repos/grpc/grpc/pulls/31569,1103194028,2023-02-10T20:11:41Z,tools/internal_ci/linux/grpc_xds_k8s_run_xtest.sh,"@@ -0,0 +1,97 @@+#!/usr/bin/env bash+# Copyright 2022 gRPC authors.+#+# Licensed under the Apache License, Version 2.0 (the ""License"");+# you may not use this file except in compliance with the License.+# You may obtain a copy of the License at+#+#     http://www.apache.org/licenses/LICENSE-2.0+#+# Unless required by applicable law or agreed to in writing, software+# distributed under the License is distributed on an ""AS IS"" BASIS,+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+# See the License for the specific language governing permissions and+# limitations under the License.++## xDS test server/client Docker images+readonly IMAGE_REPO=""gcr.io/grpc-testing/xds-interop""++find_latest() {+  gcloud container images list-tags --filter='tags~v1\.\d+\.x' --flatten='tags[]' --format='value(tags)' | sort --version-sort | tail -n 1+}++if [ ""${LATEST_BRANCH}"" == """" ]; then","I highly recommend to create a function. Then it's much clearer what's happening. Side-effects should be avoided as much as possible.> Put all functions together in the file just below constants. **Dont hide executable code between functions.** Doing so makes the code difficult to follow and results in nasty surprises when debugging.  > If youve got functions, put them all together near the top of the file. **Only includes, set statements and setting constants may be done before declaring functions.**  >  https://google.github.io/styleguide/shellguide.html#function-location",X
7221003,rockspore,https://api.github.com/repos/grpc/grpc/pulls/32335,1103220138,2023-02-10T20:37:45Z,test/core/security/tls_security_connector_test.cc,"@@ -737,6 +737,44 @@ TEST_F(TlsSecurityConnectorTest,                             on_peer_checked); } +TEST_F(TlsSecurityConnectorTest,+       ChannelSecurityConnectorWithVerifiedRootCertSubjectSucceeds) {+  auto* sync_verifier_ = new SyncExternalVerifier(true);",It doesn't seem to be a good pattern to introduce dependencies in test/cpp for test/core. It will be more tedious but I'd create a separate external verifier test class in core itself.,
16962414,gtcooke94,https://api.github.com/repos/grpc/grpc/pulls/32335,1103228396,2023-02-10T20:48:42Z,test/core/security/tls_security_connector_test.cc,"@@ -737,6 +737,44 @@ TEST_F(TlsSecurityConnectorTest,                             on_peer_checked); } +TEST_F(TlsSecurityConnectorTest,+       ChannelSecurityConnectorWithVerifiedRootCertSubjectSucceeds) {+  auto* sync_verifier_ = new SyncExternalVerifier(true);","~This is a pattern used in other tests in this file that I've re-used, I don't believe I've introduced a new dependency? Can you clarify what you mean?~Should've refreshed the page before commenting :)",
16962414,gtcooke94,https://api.github.com/repos/grpc/grpc/pulls/32335,1103271867,2023-02-10T21:34:11Z,test/core/security/tls_security_connector_test.cc,"@@ -737,6 +737,44 @@ TEST_F(TlsSecurityConnectorTest,                             on_peer_checked); } +TEST_F(TlsSecurityConnectorTest,+       ChannelSecurityConnectorWithVerifiedRootCertSubjectSucceeds) {+  auto* sync_verifier_ = new SyncExternalVerifier(true);",This pattern copies the structure used in other tests - would we rather keep it matching all of the other tests or change it to this?,
16962414,gtcooke94,https://api.github.com/repos/grpc/grpc/pulls/32335,1103272858,2023-02-10T21:35:09Z,test/core/security/tls_security_connector_test.cc,"@@ -737,6 +737,44 @@ TEST_F(TlsSecurityConnectorTest,                             on_peer_checked); } +TEST_F(TlsSecurityConnectorTest,+       ChannelSecurityConnectorWithVerifiedRootCertSubjectSucceeds) {+  auto* sync_verifier_ = new SyncExternalVerifier(true);","My bad, fixed",
16962414,gtcooke94,https://api.github.com/repos/grpc/grpc/pulls/32335,1103275037,2023-02-10T21:37:24Z,test/core/security/tls_security_connector_test.cc,"@@ -737,6 +737,44 @@ TEST_F(TlsSecurityConnectorTest,                             on_peer_checked); } +TEST_F(TlsSecurityConnectorTest,+       ChannelSecurityConnectorWithVerifiedRootCertSubjectSucceeds) {+  auto* sync_verifier_ = new SyncExternalVerifier(true);+  ExternalCertificateVerifier core_external_verifier(sync_verifier_->base());+  RefCountedPtr<grpc_tls_credentials_options> options =+      MakeRefCounted<grpc_tls_credentials_options>();+  options->set_verify_server_cert(true);+  options->set_certificate_verifier(core_external_verifier.Ref());+  options->set_check_call_host(false);+  RefCountedPtr<TlsCredentials> credential =+      MakeRefCounted<TlsCredentials>(options);+  ChannelArgs new_args;+  RefCountedPtr<grpc_channel_security_connector> connector =+      credential->create_security_connector(nullptr, kTargetName, &new_args);+  EXPECT_NE(connector, nullptr);+  TlsChannelSecurityConnector* tls_connector =+      static_cast<TlsChannelSecurityConnector*>(connector.get());+  EXPECT_NE(tls_connector->ClientHandshakerFactoryForTesting(), nullptr);+  // Construct a basic TSI Peer.+  char* expected_subject = const_cast<char*>(+      ""CN=testca,O=Internet Widgits Pty Ltd,ST=Some-State,C=AU"");+  tsi_peer peer;+  GPR_ASSERT(tsi_construct_peer(2, &peer) == TSI_OK);","We should be able to, but this is another of those patterns taken from the existing tests, so open question of changing just here, or keeping the pattern and doing a fix PR to clean the whole test file another time.",
16962414,gtcooke94,https://api.github.com/repos/grpc/grpc/pulls/32335,1103285702,2023-02-10T21:44:44Z,test/core/security/tls_security_connector_test.cc,"@@ -737,6 +737,44 @@ TEST_F(TlsSecurityConnectorTest,                             on_peer_checked); } +TEST_F(TlsSecurityConnectorTest,+       ChannelSecurityConnectorWithVerifiedRootCertSubjectSucceeds) {+  auto* sync_verifier_ = new SyncExternalVerifier(true);+  ExternalCertificateVerifier core_external_verifier(sync_verifier_->base());+  RefCountedPtr<grpc_tls_credentials_options> options =+      MakeRefCounted<grpc_tls_credentials_options>();+  options->set_verify_server_cert(true);+  options->set_certificate_verifier(core_external_verifier.Ref());+  options->set_check_call_host(false);+  RefCountedPtr<TlsCredentials> credential =+      MakeRefCounted<TlsCredentials>(options);+  ChannelArgs new_args;+  RefCountedPtr<grpc_channel_security_connector> connector =+      credential->create_security_connector(nullptr, kTargetName, &new_args);+  EXPECT_NE(connector, nullptr);+  TlsChannelSecurityConnector* tls_connector =+      static_cast<TlsChannelSecurityConnector*>(connector.get());+  EXPECT_NE(tls_connector->ClientHandshakerFactoryForTesting(), nullptr);+  // Construct a basic TSI Peer.+  char* expected_subject = const_cast<char*>(+      ""CN=testca,O=Internet Widgits Pty Ltd,ST=Some-State,C=AU"");+  tsi_peer peer;+  GPR_ASSERT(tsi_construct_peer(2, &peer) == TSI_OK);+  GPR_ASSERT(tsi_construct_string_peer_property(TSI_SSL_ALPN_SELECTED_PROTOCOL,+                                                ""grpc"", strlen(""grpc""),+                                                &peer.properties[0]) == TSI_OK);+  GPR_ASSERT(tsi_construct_string_peer_property_from_cstring(+                 TSI_X509_VERIFIED_ROOT_CERT_SUBECT_PEER_PROPERTY,+                 expected_subject, &peer.properties[1]) == TSI_OK);+  RefCountedPtr<grpc_auth_context> auth_context;+  ExecCtx exec_ctx;+  grpc_closure* on_peer_checked = GRPC_CLOSURE_CREATE(+      VerifyExpectedErrorCallback, nullptr, grpc_schedule_on_exec_ctx);+  ChannelArgs args;+  tls_connector->check_peer(peer, nullptr, args, &auth_context,+                            on_peer_checked);+}","`PendingVerifierRequestInit` is only in the cpp file, not the header.It's called indirectly through `connector->check_peer`. The stack is short - it's called [during the constructor of {Channel/Server}PendingVerifierRequest}](https://github.com/grpc/grpc/blob/d5fcbce4b4ff81f246bf63899f51f5a3bd56fb8c/src/core/lib/security/security_connector/tls/tls_security_connector.cc#L476), and those are created [during the associated check_peer](https://github.com/grpc/grpc/blob/d5fcbce4b4ff81f246bf63899f51f5a3bd56fb8c/src/core/lib/security/security_connector/tls/tls_security_connector.cc#L370).I could simplify the test and just make sure that we can construct the `{Channel/Server}PendingVerifierRequest` object since `PendingVerifierRequestInit` is called during their constructors. Thoughts?",
16962414,gtcooke94,https://api.github.com/repos/grpc/grpc/pulls/32335,1103286029,2023-02-10T21:45:13Z,test/core/security/tls_security_connector_test.cc,"@@ -1089,6 +1127,38 @@ TEST_F(TlsSecurityConnectorTest,   core_external_verifier->Unref(); } +TEST_F(TlsSecurityConnectorTest,",Addressed in [this comment chain](https://github.com/grpc/grpc/pull/32335#discussion_r1103285702),
133680,sampajano,https://api.github.com/repos/grpc/grpc/pulls/32077,1103369384,2023-02-10T23:28:27Z,src/core/lib/event_engine/cf_engine/cftype_unique_ref.h,"@@ -0,0 +1,76 @@+// Copyright 2022 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+#ifndef GRPC_SRC_CORE_LIB_EVENT_ENGINE_CF_ENGINE_CFTYPE_UNIQUE_REF_H+#define GRPC_SRC_CORE_LIB_EVENT_ENGINE_CF_ENGINE_CFTYPE_UNIQUE_REF_H+#include <grpc/support/port_platform.h>++#ifdef GPR_APPLE++#include <CoreFoundation/CoreFoundation.h>++namespace grpc_event_engine {+namespace experimental {++template <typename T>+class CFTypeUniqueRef {",@drfloob Hey AJ I wonder there are existing utilities like this in the grpc codebase?This class seems quite generic to me so i'm hoping we could reuse if there exists one. Thanks!,
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/32077,1103384759,2023-02-10T23:41:28Z,src/core/lib/event_engine/cf_engine/cftype_unique_ref.h,"@@ -0,0 +1,76 @@+// Copyright 2022 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+#ifndef GRPC_SRC_CORE_LIB_EVENT_ENGINE_CF_ENGINE_CFTYPE_UNIQUE_REF_H+#define GRPC_SRC_CORE_LIB_EVENT_ENGINE_CF_ENGINE_CFTYPE_UNIQUE_REF_H+#include <grpc/support/port_platform.h>++#ifdef GPR_APPLE++#include <CoreFoundation/CoreFoundation.h>++namespace grpc_event_engine {+namespace experimental {++template <typename T>+class CFTypeUniqueRef {","It looks like this class provides some sugar specifically for `CFTypeRef` objects (implicit conversions and output-parameter specializations). My hunch is that a `std::unique_ptr` could do this job, albeit without the sugar on top. I'm mostly ambivalent about it, but we don't have anything `CFTypeRef`-specific in the core codebase.",
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/32350,1103435771,2023-02-11T00:27:46Z,src/objective-c/tests/InteropTests/InteropTests.m,"@@ -1603,7 +1603,13 @@ - (void)testKeepaliveWithV2API {   GRPCTestRunWithFlakeRepeats(self, ^(GRPCTestWaiter waiterBlock, GRPCTestAssert assertBlock) {     // The test is highly flaky when ran as part of InteropTestsRemote     // TODO(jtattermusch): fix and re-enable the test.-    if ([[self class] isRemoteTest]) {+    // if ([[self class] isRemoteTest]) {","Instead of leaving code commented out (it's a smell, since the code could get out of sync if it's not being compiled) ... I'd recommend moving the TODO up to the top of the function, and having an unconditional `return`.",X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32294,1104789594,2023-02-13T17:15:21Z,src/cpp/ext/filters/census/environment_autodetect.cc,"@@ -0,0 +1,425 @@+//+//+// Copyright 2023 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+//+//++#include <grpc/support/port_platform.h>++#include ""src/cpp/ext/filters/census/environment_autodetect.h""++#include <string.h>++#include <algorithm>+#include <memory>+#include <utility>++#include ""absl/container/flat_hash_map.h""+#include ""absl/meta/type_traits.h""+#include ""absl/status/status.h""+#include ""absl/status/statusor.h""+#include ""absl/strings/string_view.h""+#include ""absl/types/optional.h""++#include <grpc/event_engine/event_engine.h>+#include <grpc/grpc.h>+#include <grpc/grpc_security.h>+#include <grpc/support/alloc.h>+#include <grpc/support/log.h>+#include <grpc/support/sync.h>+#include <grpcpp/impl/grpc_library.h>++#include ""src/core/lib/event_engine/default_event_engine.h""+#include ""src/core/lib/gprpp/crash.h""+#include ""src/core/lib/gprpp/env.h""+#include ""src/core/lib/gprpp/load_file.h""+#include ""src/core/lib/gprpp/orphanable.h""+#include ""src/core/lib/gprpp/ref_counted_ptr.h""+#include ""src/core/lib/gprpp/status_helper.h""+#include ""src/core/lib/gprpp/time.h""+#include ""src/core/lib/http/httpcli.h""+#include ""src/core/lib/http/parser.h""+#include ""src/core/lib/iomgr/closure.h""+#include ""src/core/lib/iomgr/error.h""+#include ""src/core/lib/iomgr/exec_ctx.h""+#include ""src/core/lib/iomgr/iomgr_fwd.h""+#include ""src/core/lib/iomgr/polling_entity.h""+#include ""src/core/lib/iomgr/pollset.h""+#include ""src/core/lib/security/credentials/credentials.h""+#include ""src/core/lib/slice/slice.h""+#include ""src/core/lib/uri/uri_parser.h""++namespace grpc {+namespace internal {++namespace {++constexpr const char kZoneAttribute[] = ""/computeMetadata/v1/instance/zone"";+constexpr const char kClusterNameAttribute[] =+    ""/computeMetadata/v1/instance/attributes/cluster-name"";+constexpr const char kRegionAttribute[] = ""/computeMetadata/v1/instance/region"";+constexpr const char kInstanceIdAttribute[] = ""/computeMetadata/v1/instance/id"";++// Fire and Forget class (Cleans up after itself.)+// Fetches the value of an attribute from the MetadataServer on a GCP+// environment.+class MetadataQuery {","Since this code essentially already exists in the google-c2p resolver, I think we should move it into a common library instead of duplicating it.",X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32294,1104808712,2023-02-13T17:28:27Z,src/cpp/ext/filters/census/environment_autodetect.h,"@@ -0,0 +1,71 @@+//+// Copyright 2023 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+//++#ifndef GRPC_SRC_CPP_EXT_FILTERS_CENSUS_ENVIRONMENT_AUTODETECT_H+#define GRPC_SRC_CPP_EXT_FILTERS_CENSUS_ENVIRONMENT_AUTODETECT_H++#include <grpc/support/port_platform.h>++#include <map>+#include <memory>+#include <string>+#include <vector>++#include ""absl/base/thread_annotations.h""+#include ""absl/functional/any_invocable.h""++#include ""src/core/lib/gprpp/sync.h""++namespace grpc {+namespace internal {++class EnvironmentAutoDetect {","Does this code actually belong in the census filter directory?  It seems to me that it's really a more general GCP-specific autodetection thing, not really anything specific to the census filter.  Maybe this should go in its own library somewhere?Note that we also have some other existing code to detect GCP platform here, which we use in ALTS and in GoogleDefaultCreds:https://github.com/grpc/grpc/blob/0ecc18ef0f51eb38880835db34f38f99980367e4/src/core/lib/security/credentials/alts/check_gcp_environment.h#L55@apolcyn may have some thoughts about the best way to structure all of this code into a single combined library.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32294,1104822448,2023-02-13T17:40:24Z,src/cpp/ext/filters/census/environment_autodetect.cc,"@@ -0,0 +1,425 @@+//+//+// Copyright 2023 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+//+//++#include <grpc/support/port_platform.h>++#include ""src/cpp/ext/filters/census/environment_autodetect.h""++#include <string.h>++#include <algorithm>+#include <memory>+#include <utility>++#include ""absl/container/flat_hash_map.h""+#include ""absl/meta/type_traits.h""+#include ""absl/status/status.h""+#include ""absl/status/statusor.h""+#include ""absl/strings/string_view.h""+#include ""absl/types/optional.h""++#include <grpc/event_engine/event_engine.h>+#include <grpc/grpc.h>+#include <grpc/grpc_security.h>+#include <grpc/support/alloc.h>+#include <grpc/support/log.h>+#include <grpc/support/sync.h>+#include <grpcpp/impl/grpc_library.h>++#include ""src/core/lib/event_engine/default_event_engine.h""+#include ""src/core/lib/gprpp/crash.h""+#include ""src/core/lib/gprpp/env.h""+#include ""src/core/lib/gprpp/load_file.h""+#include ""src/core/lib/gprpp/orphanable.h""+#include ""src/core/lib/gprpp/ref_counted_ptr.h""+#include ""src/core/lib/gprpp/status_helper.h""+#include ""src/core/lib/gprpp/time.h""+#include ""src/core/lib/http/httpcli.h""+#include ""src/core/lib/http/parser.h""+#include ""src/core/lib/iomgr/closure.h""+#include ""src/core/lib/iomgr/error.h""+#include ""src/core/lib/iomgr/exec_ctx.h""+#include ""src/core/lib/iomgr/iomgr_fwd.h""+#include ""src/core/lib/iomgr/polling_entity.h""+#include ""src/core/lib/iomgr/pollset.h""+#include ""src/core/lib/security/credentials/credentials.h""+#include ""src/core/lib/slice/slice.h""+#include ""src/core/lib/uri/uri_parser.h""++namespace grpc {+namespace internal {++namespace {++constexpr const char kZoneAttribute[] = ""/computeMetadata/v1/instance/zone"";+constexpr const char kClusterNameAttribute[] =+    ""/computeMetadata/v1/instance/attributes/cluster-name"";+constexpr const char kRegionAttribute[] = ""/computeMetadata/v1/instance/region"";+constexpr const char kInstanceIdAttribute[] = ""/computeMetadata/v1/instance/id"";++// Fire and Forget class (Cleans up after itself.)+// Fetches the value of an attribute from the MetadataServer on a GCP+// environment.+class MetadataQuery {+ public:+  MetadataQuery(std::string attribute, grpc_polling_entity* pollent,+                absl::AnyInvocable<void(std::string /* attribute */,+                                        std::string /* result */)>+                    callback)+      : attribute_(std::move(attribute)), callback_(std::move(callback)) {+    GRPC_CLOSURE_INIT(&on_done_, OnDone, this, nullptr);+    auto uri =+        grpc_core::URI::Create(""http"", ""metadata.google.internal."", attribute_,+                               {} /* query params */, """" /* fragment */);+    GPR_ASSERT(uri.ok());  // params are hardcoded+    grpc_http_request request;+    memset(&request, 0, sizeof(grpc_http_request));+    grpc_http_header header = {const_cast<char*>(""Metadata-Flavor""),+                               const_cast<char*>(""Google"")};+    request.hdr_count = 1;+    request.hdrs = &header;+    // The http call is local. If it takes more than one sec, it is probably not+    // on GCP.+    auto http_request = grpc_core::HttpRequest::Get(+        std::move(*uri), nullptr /* channel args */, pollent, &request,+        grpc_core::Timestamp::Now() + grpc_core::Duration::Seconds(1),+        &on_done_, &response_,+        grpc_core::RefCountedPtr<grpc_channel_credentials>(+            grpc_insecure_credentials_create()));+    http_request->Start();+  }++ private:+  static void OnDone(void* arg, absl::Status error) {+    auto* self = static_cast<MetadataQuery*>(arg);+    std::string result;+    if (!error.ok()) {+      gpr_log(GPR_ERROR, ""MetadataServer Query failed for %s: %s"",+              self->attribute_.c_str(),+              grpc_core::StatusToString(error).c_str());+    } else if (self->response_.status != 200) {+      gpr_log(+          GPR_ERROR, ""MetadataServer Query received non-200 status for %s: %s"",+          self->attribute_.c_str(), grpc_core::StatusToString(error).c_str());+    } else if (self->attribute_ == kZoneAttribute) {+      absl::string_view body(self->response_.body, self->response_.body_length);+      size_t pos = result.find_last_of('/');+      if (pos == body.npos) {+        gpr_log(GPR_ERROR, ""MetadataServer Could not parse zone: %s"",+                std::string(body).c_str());+      } else {+        result = std::string(body.substr(pos + 1));+      }+    } else {+      result = self->response_.body;+    }+    auto callback = std::move(self->callback_);+    auto attribute = std::move(self->attribute_);+    delete self;+    return callback(std::move(attribute), std::move(result));+  }++  grpc_closure on_done_;+  std::string attribute_;+  absl::AnyInvocable<void(std::string /* attribute */,+                          std::string /* result */)>+      callback_;+  grpc_http_response response_;+};++// This is not a definite method to get the namespace name for GKE, but it is+// the best we have.+std::string GetNamespaceName() {+  // Read the root file.+  const char* filename =+      ""/var/run/secrets/kubernetes.io/serviceaccount/namespace"";+  auto namespace_name = grpc_core::LoadFile(filename, false);+  if (!namespace_name.ok()) {+    gpr_log(GPR_DEBUG, ""Reading file %s failed: %s"", filename,+            grpc_core::StatusToString(namespace_name.status()).c_str());+    // Fallback on an environment variable+    return grpc_core::GetEnv(""NAMESPACE_NAME"").value_or("""");+  }+  return std::string(reinterpret_cast<const char*>((*namespace_name).begin()),+                     (*namespace_name).length());+}++// Get pod name for GKE+std::string GetPodName() {+  auto pod_name = grpc_core::GetEnv(""POD_NAME"");+  if (pod_name.has_value()) {+    return pod_name.value();+  }+  return grpc_core::GetEnv(""HOSTNAME"").value_or("""");+}++// Get container name for GKE+std::string GetContainerName() {+  return grpc_core::GetEnv(""HOSTNAME"").value_or("""");+}++// Get function name for Cloud Functions+std::string GetFunctionName() {+  auto k_service = grpc_core::GetEnv(""K_SERVICE"");+  if (k_service.has_value()) {+    return k_service.value();+  }+  return grpc_core::GetEnv(""FUNCTION_NAME"").value_or("""");+}++// Get revision name for Cloud run+std::string GetRevisionName() {+  return grpc_core::GetEnv(""K_REVISION"").value_or("""");+}++// Get service name for Cloud run+std::string GetServiceName() {+  return grpc_core::GetEnv(""K_SERVICE"").value_or("""");+}++// Get configuration name for Cloud run+std::string GetConfiguratioName() {+  return grpc_core::GetEnv(""K_CONFIGURATION"").value_or("""");+}++// Get module ID for App Engine+std::string GetModuleId() {+  return grpc_core::GetEnv(""GAE_SERVICE"").value_or("""");+}++// Get version ID for App Engine+std::string GetVersionId() {+  return grpc_core::GetEnv(""GAE_VERSION"").value_or("""");+}++// Fire and forget class+class EnvironmentAutoDetectHelper+    : public grpc_core::InternallyRefCounted<EnvironmentAutoDetectHelper>,+      private internal::GrpcLibrary {+ public:+  explicit EnvironmentAutoDetectHelper(+      std::string project_id,+      absl::AnyInvocable<void(EnvironmentAutoDetect::ResourceType)> on_done)+      : InternallyRefCounted(/*trace=*/nullptr, /*initial_refcount=*/2),+        project_id_(std::move(project_id)),+        on_done_(std::move(on_done)) {+    grpc_core::ExecCtx exec_ctx;+    // TODO(yashykt): The pollset stuff should go away once the HTTP library is+    // ported over to use EventEngine.+    pollset_ = static_cast<grpc_pollset*>(gpr_zalloc(grpc_pollset_size()));+    grpc_pollset_init(pollset_, &mu_poll_);+    pollent_ = grpc_polling_entity_create_from_pollset(pollset_);+    // TODO(yashykt): Note that using EventEngine::Run is not fork-safe. If we+    // want to make this fork-safe, we might need some re-work here.+    grpc_event_engine::experimental::GetDefaultEventEngine()->Run(+        [this] { PollLoop(); });+    AutoDetect();+  }++  ~EnvironmentAutoDetectHelper() override {+    grpc_core::ExecCtx exec_ctx;+    grpc_pollset_shutdown(+        pollset_, GRPC_CLOSURE_CREATE(+                      [](void* arg, absl::Status /* status */) {+                        grpc_pollset_destroy(static_cast<grpc_pollset*>(arg));+                        gpr_free(arg);+                      },+                      pollset_, nullptr));+  }++  void Orphan() override {+    grpc_core::Crash(""Illegal Orphan() call on EnvironmentAutoDetectHelper."");+  }++ private:+  struct Attribute {+    std::string resource_attribute;+    std::string metadata_server_atttribute;+  };++  void PollLoop() {+    grpc_core::ExecCtx exec_ctx;+    bool done = false;+    gpr_mu_lock(mu_poll_);+    grpc_pollset_worker* worker = nullptr;+    if (!GRPC_LOG_IF_ERROR(+            ""pollset_work"",+            grpc_pollset_work(grpc_polling_entity_pollset(&pollent_), &worker,+                              grpc_core::Timestamp::InfPast()))) {+      notify_poller_ = true;+    }+    done = notify_poller_;+    gpr_mu_unlock(mu_poll_);+    if (!done) {+      grpc_event_engine::experimental::GetDefaultEventEngine()->Run(+          [this] { PollLoop(); });+    } else {+      Unref();+    }+  }++  void AutoDetect() {+    grpc_core::MutexLock lock(&mu_);+    // GKE+    resource_.labels.emplace(""project_id"", project_id_);+    if (grpc_core::GetEnv(""KUBERNETES_SERVICE_HOST"").has_value()) {+      resource_.resource_type = ""k8s_container"";+      resource_.labels.emplace(""namespace_name"", GetNamespaceName());+      resource_.labels.emplace(""pod_name"", GetPodName());+      resource_.labels.emplace(""container_name"", GetContainerName());+      attributes_to_fetch_.emplace(kZoneAttribute, ""location"");+      attributes_to_fetch_.emplace(kClusterNameAttribute, ""cluster_name"");+    }+    // Cloud Functions+    else if (grpc_core::GetEnv(""FUNCTION_NAME"").has_value() ||+             grpc_core::GetEnv(""FUNCTION_TARGET"").has_value()) {+      resource_.resource_type = ""cloud_function"";+      resource_.labels.emplace(""function_name"", GetFunctionName());+      attributes_to_fetch_.emplace(kRegionAttribute, ""region"");+    }+    // Cloud Run+    else if (grpc_core::GetEnv(""K_CONFIGURATION"").has_value()) {+      resource_.resource_type = ""cloud_run_revision"";+      resource_.labels.emplace(""revision_name"", GetRevisionName());+      resource_.labels.emplace(""service_name"", GetServiceName());+      resource_.labels.emplace(""configuration_name"", GetConfiguratioName());+      attributes_to_fetch_.emplace(kRegionAttribute, ""location"");+    }+    // App Engine+    else if (grpc_core::GetEnv(""GAE_SERVICE"").has_value()) {+      resource_.resource_type = ""gae_app"";+      resource_.labels.emplace(""module_id"", GetModuleId());+      resource_.labels.emplace(""version_id"", GetVersionId());+      attributes_to_fetch_.emplace(kZoneAttribute, ""zone"");+    }+    // Assume GCE+    else {+      assuming_gce_ = true;+      resource_.resource_type = ""gce_instance"";+      attributes_to_fetch_.emplace(kInstanceIdAttribute, ""instance_id"");+      attributes_to_fetch_.emplace(kZoneAttribute, ""zone"");+    }+    FetchMetadataServerAttributesAsynchronouslyLocked();+  }++  void FetchMetadataServerAttributesAsynchronouslyLocked()+      ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu_) {+    GPR_ASSERT(!attributes_to_fetch_.empty());+    for (const auto& element : attributes_to_fetch_) {+      new MetadataQuery(+          element.first, &pollent_,+          [this](std::string attribute, std::string result) {+            absl::optional<EnvironmentAutoDetect::ResourceType> resource;+            {+              grpc_core::MutexLock lock(&mu_);+              auto it = attributes_to_fetch_.find(attribute);+              if (it != attributes_to_fetch_.end()) {+                if (!result.empty()) {+                  resource_.labels.emplace(std::move(it->second),+                                           std::move(result));+                }+                // If fetching from the MetadataServer failed and we were+                // assuming a GCE environment, fallback to ""global"".+                else if (assuming_gce_) {+                  assuming_gce_ = false;+                  resource_.resource_type = ""global"";+                }+                attributes_to_fetch_.erase(it);+              } else {+                // This should not happen+                gpr_log(GPR_ERROR,+                        ""An unexpected attribute was seen from the ""+                        ""MetadataServer: %s"",+                        attribute.c_str());+              }+              if (attributes_to_fetch_.empty()) {+                resource = std::move(resource_);+              }+            }+            gpr_mu_lock(mu_poll_);+            notify_poller_ = true;+            gpr_mu_unlock(mu_poll_);+            if (resource.has_value()) {+              auto on_done = std::move(on_done_);+              Unref();+              on_done(std::move(resource).value());+            }+          });+    }+  }++  const std::string project_id_;+  grpc_pollset* pollset_ = nullptr;+  grpc_polling_entity pollent_;+  gpr_mu* mu_poll_ = nullptr;+  absl::AnyInvocable<void(EnvironmentAutoDetect::ResourceType)> on_done_;+  grpc_core::Mutex mu_;+  bool notify_poller_ = false;+  absl::flat_hash_map<std::string /* metadata_server_attribute */,+                      std::string /* resource_attribute */>+      attributes_to_fetch_ ABSL_GUARDED_BY(mu_);+  EnvironmentAutoDetect::ResourceType resource_ ABSL_GUARDED_BY(mu_);+  // This would be true if we are assuming the resource to be GCE. In this case,+  // there is a chance that it will fail and we should instead just use+  // ""global"".+  bool assuming_gce_ ABSL_GUARDED_BY(mu_) = false;+};++}  // namespace++EnvironmentAutoDetect& EnvironmentAutoDetect::Create(std::string project_id) {+  static EnvironmentAutoDetect auto_detector(std::move(project_id));+  return auto_detector;+}++EnvironmentAutoDetect& EnvironmentAutoDetect::Get() { return Create(""""); }++EnvironmentAutoDetect::EnvironmentAutoDetect(std::string project_id)+    : project_id_(std::move(project_id)) {+  GPR_ASSERT(!project_id_.empty());+  new EnvironmentAutoDetectHelper(+      project_id_, [this](EnvironmentAutoDetect::ResourceType resource) {+        std::vector<absl::AnyInvocable<void()>> callbacks;+        {+          grpc_core::MutexLock lock(&mu_);+          resource_ = std::make_unique<EnvironmentAutoDetect::ResourceType>(+              std::move(resource));+          callbacks = std::move(callbacks_);+        }+        for (auto& callback : callbacks) {+          callback();+        }+      });+}++void EnvironmentAutoDetect::NotifyOnDone(absl::AnyInvocable<void()> callback) {+  {+    grpc_core::ReleasableMutexLock lock(&mu_);","I generally consider `ReleasableMutexLock` to be a code smell.  And in this case, since you're invoking the callback asynchronously, it looks like you don't actually need to release the lock early in the first place.",X
4181124,yashykt,https://api.github.com/repos/grpc/grpc/pulls/32294,1104990977,2023-02-13T20:36:37Z,src/cpp/ext/filters/census/environment_autodetect.cc,"@@ -0,0 +1,425 @@+//+//+// Copyright 2023 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+//+//++#include <grpc/support/port_platform.h>++#include ""src/cpp/ext/filters/census/environment_autodetect.h""++#include <string.h>++#include <algorithm>+#include <memory>+#include <utility>++#include ""absl/container/flat_hash_map.h""+#include ""absl/meta/type_traits.h""+#include ""absl/status/status.h""+#include ""absl/status/statusor.h""+#include ""absl/strings/string_view.h""+#include ""absl/types/optional.h""++#include <grpc/event_engine/event_engine.h>+#include <grpc/grpc.h>+#include <grpc/grpc_security.h>+#include <grpc/support/alloc.h>+#include <grpc/support/log.h>+#include <grpc/support/sync.h>+#include <grpcpp/impl/grpc_library.h>++#include ""src/core/lib/event_engine/default_event_engine.h""+#include ""src/core/lib/gprpp/crash.h""+#include ""src/core/lib/gprpp/env.h""+#include ""src/core/lib/gprpp/load_file.h""+#include ""src/core/lib/gprpp/orphanable.h""+#include ""src/core/lib/gprpp/ref_counted_ptr.h""+#include ""src/core/lib/gprpp/status_helper.h""+#include ""src/core/lib/gprpp/time.h""+#include ""src/core/lib/http/httpcli.h""+#include ""src/core/lib/http/parser.h""+#include ""src/core/lib/iomgr/closure.h""+#include ""src/core/lib/iomgr/error.h""+#include ""src/core/lib/iomgr/exec_ctx.h""+#include ""src/core/lib/iomgr/iomgr_fwd.h""+#include ""src/core/lib/iomgr/polling_entity.h""+#include ""src/core/lib/iomgr/pollset.h""+#include ""src/core/lib/security/credentials/credentials.h""+#include ""src/core/lib/slice/slice.h""+#include ""src/core/lib/uri/uri_parser.h""++namespace grpc {+namespace internal {++namespace {++constexpr const char kZoneAttribute[] = ""/computeMetadata/v1/instance/zone"";+constexpr const char kClusterNameAttribute[] =+    ""/computeMetadata/v1/instance/attributes/cluster-name"";+constexpr const char kRegionAttribute[] = ""/computeMetadata/v1/instance/region"";+constexpr const char kInstanceIdAttribute[] = ""/computeMetadata/v1/instance/id"";++// Fire and Forget class (Cleans up after itself.)+// Fetches the value of an attribute from the MetadataServer on a GCP+// environment.+class MetadataQuery {+ public:+  MetadataQuery(std::string attribute, grpc_polling_entity* pollent,+                absl::AnyInvocable<void(std::string /* attribute */,+                                        std::string /* result */)>+                    callback)+      : attribute_(std::move(attribute)), callback_(std::move(callback)) {+    GRPC_CLOSURE_INIT(&on_done_, OnDone, this, nullptr);+    auto uri =+        grpc_core::URI::Create(""http"", ""metadata.google.internal."", attribute_,+                               {} /* query params */, """" /* fragment */);+    GPR_ASSERT(uri.ok());  // params are hardcoded+    grpc_http_request request;+    memset(&request, 0, sizeof(grpc_http_request));+    grpc_http_header header = {const_cast<char*>(""Metadata-Flavor""),+                               const_cast<char*>(""Google"")};+    request.hdr_count = 1;+    request.hdrs = &header;+    // The http call is local. If it takes more than one sec, it is probably not+    // on GCP.+    auto http_request = grpc_core::HttpRequest::Get(+        std::move(*uri), nullptr /* channel args */, pollent, &request,+        grpc_core::Timestamp::Now() + grpc_core::Duration::Seconds(1),+        &on_done_, &response_,+        grpc_core::RefCountedPtr<grpc_channel_credentials>(+            grpc_insecure_credentials_create()));+    http_request->Start();+  }++ private:+  static void OnDone(void* arg, absl::Status error) {+    auto* self = static_cast<MetadataQuery*>(arg);+    std::string result;+    if (!error.ok()) {+      gpr_log(GPR_ERROR, ""MetadataServer Query failed for %s: %s"",+              self->attribute_.c_str(),+              grpc_core::StatusToString(error).c_str());+    } else if (self->response_.status != 200) {+      gpr_log(+          GPR_ERROR, ""MetadataServer Query received non-200 status for %s: %s"",+          self->attribute_.c_str(), grpc_core::StatusToString(error).c_str());+    } else if (self->attribute_ == kZoneAttribute) {+      absl::string_view body(self->response_.body, self->response_.body_length);+      size_t pos = result.find_last_of('/');+      if (pos == body.npos) {+        gpr_log(GPR_ERROR, ""MetadataServer Could not parse zone: %s"",+                std::string(body).c_str());+      } else {+        result = std::string(body.substr(pos + 1));+      }+    } else {+      result = self->response_.body;+    }+    auto callback = std::move(self->callback_);+    auto attribute = std::move(self->attribute_);+    delete self;+    return callback(std::move(attribute), std::move(result));+  }++  grpc_closure on_done_;+  std::string attribute_;+  absl::AnyInvocable<void(std::string /* attribute */,+                          std::string /* result */)>+      callback_;+  grpc_http_response response_;+};++// This is not a definite method to get the namespace name for GKE, but it is+// the best we have.+std::string GetNamespaceName() {+  // Read the root file.+  const char* filename =+      ""/var/run/secrets/kubernetes.io/serviceaccount/namespace"";+  auto namespace_name = grpc_core::LoadFile(filename, false);+  if (!namespace_name.ok()) {+    gpr_log(GPR_DEBUG, ""Reading file %s failed: %s"", filename,+            grpc_core::StatusToString(namespace_name.status()).c_str());+    // Fallback on an environment variable+    return grpc_core::GetEnv(""NAMESPACE_NAME"").value_or("""");+  }+  return std::string(reinterpret_cast<const char*>((*namespace_name).begin()),+                     (*namespace_name).length());+}++// Get pod name for GKE+std::string GetPodName() {+  auto pod_name = grpc_core::GetEnv(""POD_NAME"");+  if (pod_name.has_value()) {+    return pod_name.value();+  }+  return grpc_core::GetEnv(""HOSTNAME"").value_or("""");+}++// Get container name for GKE+std::string GetContainerName() {+  return grpc_core::GetEnv(""HOSTNAME"").value_or("""");+}++// Get function name for Cloud Functions+std::string GetFunctionName() {+  auto k_service = grpc_core::GetEnv(""K_SERVICE"");+  if (k_service.has_value()) {+    return k_service.value();+  }+  return grpc_core::GetEnv(""FUNCTION_NAME"").value_or("""");+}++// Get revision name for Cloud run+std::string GetRevisionName() {+  return grpc_core::GetEnv(""K_REVISION"").value_or("""");+}++// Get service name for Cloud run+std::string GetServiceName() {+  return grpc_core::GetEnv(""K_SERVICE"").value_or("""");+}++// Get configuration name for Cloud run+std::string GetConfiguratioName() {+  return grpc_core::GetEnv(""K_CONFIGURATION"").value_or("""");+}++// Get module ID for App Engine+std::string GetModuleId() {+  return grpc_core::GetEnv(""GAE_SERVICE"").value_or("""");+}++// Get version ID for App Engine+std::string GetVersionId() {+  return grpc_core::GetEnv(""GAE_VERSION"").value_or("""");+}++// Fire and forget class+class EnvironmentAutoDetectHelper+    : public grpc_core::InternallyRefCounted<EnvironmentAutoDetectHelper>,+      private internal::GrpcLibrary {+ public:+  explicit EnvironmentAutoDetectHelper(+      std::string project_id,+      absl::AnyInvocable<void(EnvironmentAutoDetect::ResourceType)> on_done)+      : InternallyRefCounted(/*trace=*/nullptr, /*initial_refcount=*/2),+        project_id_(std::move(project_id)),+        on_done_(std::move(on_done)) {+    grpc_core::ExecCtx exec_ctx;+    // TODO(yashykt): The pollset stuff should go away once the HTTP library is+    // ported over to use EventEngine.+    pollset_ = static_cast<grpc_pollset*>(gpr_zalloc(grpc_pollset_size()));+    grpc_pollset_init(pollset_, &mu_poll_);+    pollent_ = grpc_polling_entity_create_from_pollset(pollset_);+    // TODO(yashykt): Note that using EventEngine::Run is not fork-safe. If we+    // want to make this fork-safe, we might need some re-work here.+    grpc_event_engine::experimental::GetDefaultEventEngine()->Run(+        [this] { PollLoop(); });+    AutoDetect();+  }++  ~EnvironmentAutoDetectHelper() override {+    grpc_core::ExecCtx exec_ctx;+    grpc_pollset_shutdown(+        pollset_, GRPC_CLOSURE_CREATE(+                      [](void* arg, absl::Status /* status */) {+                        grpc_pollset_destroy(static_cast<grpc_pollset*>(arg));+                        gpr_free(arg);+                      },+                      pollset_, nullptr));+  }++  void Orphan() override {+    grpc_core::Crash(""Illegal Orphan() call on EnvironmentAutoDetectHelper."");+  }++ private:+  struct Attribute {+    std::string resource_attribute;+    std::string metadata_server_atttribute;+  };++  void PollLoop() {+    grpc_core::ExecCtx exec_ctx;+    bool done = false;+    gpr_mu_lock(mu_poll_);+    grpc_pollset_worker* worker = nullptr;+    if (!GRPC_LOG_IF_ERROR(+            ""pollset_work"",+            grpc_pollset_work(grpc_polling_entity_pollset(&pollent_), &worker,+                              grpc_core::Timestamp::InfPast()))) {+      notify_poller_ = true;+    }+    done = notify_poller_;+    gpr_mu_unlock(mu_poll_);+    if (!done) {+      grpc_event_engine::experimental::GetDefaultEventEngine()->Run(+          [this] { PollLoop(); });+    } else {+      Unref();+    }+  }++  void AutoDetect() {+    grpc_core::MutexLock lock(&mu_);+    // GKE+    resource_.labels.emplace(""project_id"", project_id_);+    if (grpc_core::GetEnv(""KUBERNETES_SERVICE_HOST"").has_value()) {+      resource_.resource_type = ""k8s_container"";+      resource_.labels.emplace(""namespace_name"", GetNamespaceName());+      resource_.labels.emplace(""pod_name"", GetPodName());+      resource_.labels.emplace(""container_name"", GetContainerName());+      attributes_to_fetch_.emplace(kZoneAttribute, ""location"");+      attributes_to_fetch_.emplace(kClusterNameAttribute, ""cluster_name"");+    }+    // Cloud Functions+    else if (grpc_core::GetEnv(""FUNCTION_NAME"").has_value() ||+             grpc_core::GetEnv(""FUNCTION_TARGET"").has_value()) {+      resource_.resource_type = ""cloud_function"";+      resource_.labels.emplace(""function_name"", GetFunctionName());+      attributes_to_fetch_.emplace(kRegionAttribute, ""region"");+    }+    // Cloud Run+    else if (grpc_core::GetEnv(""K_CONFIGURATION"").has_value()) {+      resource_.resource_type = ""cloud_run_revision"";+      resource_.labels.emplace(""revision_name"", GetRevisionName());+      resource_.labels.emplace(""service_name"", GetServiceName());+      resource_.labels.emplace(""configuration_name"", GetConfiguratioName());+      attributes_to_fetch_.emplace(kRegionAttribute, ""location"");+    }+    // App Engine+    else if (grpc_core::GetEnv(""GAE_SERVICE"").has_value()) {+      resource_.resource_type = ""gae_app"";+      resource_.labels.emplace(""module_id"", GetModuleId());+      resource_.labels.emplace(""version_id"", GetVersionId());+      attributes_to_fetch_.emplace(kZoneAttribute, ""zone"");+    }+    // Assume GCE+    else {+      assuming_gce_ = true;+      resource_.resource_type = ""gce_instance"";+      attributes_to_fetch_.emplace(kInstanceIdAttribute, ""instance_id"");+      attributes_to_fetch_.emplace(kZoneAttribute, ""zone"");+    }+    FetchMetadataServerAttributesAsynchronouslyLocked();+  }++  void FetchMetadataServerAttributesAsynchronouslyLocked()+      ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu_) {+    GPR_ASSERT(!attributes_to_fetch_.empty());+    for (const auto& element : attributes_to_fetch_) {+      new MetadataQuery(+          element.first, &pollent_,+          [this](std::string attribute, std::string result) {+            absl::optional<EnvironmentAutoDetect::ResourceType> resource;+            {+              grpc_core::MutexLock lock(&mu_);+              auto it = attributes_to_fetch_.find(attribute);+              if (it != attributes_to_fetch_.end()) {+                if (!result.empty()) {+                  resource_.labels.emplace(std::move(it->second),+                                           std::move(result));+                }+                // If fetching from the MetadataServer failed and we were+                // assuming a GCE environment, fallback to ""global"".+                else if (assuming_gce_) {+                  assuming_gce_ = false;+                  resource_.resource_type = ""global"";+                }+                attributes_to_fetch_.erase(it);+              } else {+                // This should not happen+                gpr_log(GPR_ERROR,+                        ""An unexpected attribute was seen from the ""+                        ""MetadataServer: %s"",+                        attribute.c_str());+              }+              if (attributes_to_fetch_.empty()) {+                resource = std::move(resource_);+              }+            }+            gpr_mu_lock(mu_poll_);+            notify_poller_ = true;+            gpr_mu_unlock(mu_poll_);+            if (resource.has_value()) {+              auto on_done = std::move(on_done_);+              Unref();+              on_done(std::move(resource).value());+            }+          });+    }+  }++  const std::string project_id_;+  grpc_pollset* pollset_ = nullptr;+  grpc_polling_entity pollent_;+  gpr_mu* mu_poll_ = nullptr;+  absl::AnyInvocable<void(EnvironmentAutoDetect::ResourceType)> on_done_;+  grpc_core::Mutex mu_;+  bool notify_poller_ = false;+  absl::flat_hash_map<std::string /* metadata_server_attribute */,+                      std::string /* resource_attribute */>+      attributes_to_fetch_ ABSL_GUARDED_BY(mu_);+  EnvironmentAutoDetect::ResourceType resource_ ABSL_GUARDED_BY(mu_);+  // This would be true if we are assuming the resource to be GCE. In this case,+  // there is a chance that it will fail and we should instead just use+  // ""global"".+  bool assuming_gce_ ABSL_GUARDED_BY(mu_) = false;+};++}  // namespace++EnvironmentAutoDetect& EnvironmentAutoDetect::Create(std::string project_id) {+  static EnvironmentAutoDetect auto_detector(std::move(project_id));+  return auto_detector;+}++EnvironmentAutoDetect& EnvironmentAutoDetect::Get() { return Create(""""); }++EnvironmentAutoDetect::EnvironmentAutoDetect(std::string project_id)+    : project_id_(std::move(project_id)) {+  GPR_ASSERT(!project_id_.empty());+  new EnvironmentAutoDetectHelper(+      project_id_, [this](EnvironmentAutoDetect::ResourceType resource) {+        std::vector<absl::AnyInvocable<void()>> callbacks;+        {+          grpc_core::MutexLock lock(&mu_);+          resource_ = std::make_unique<EnvironmentAutoDetect::ResourceType>(+              std::move(resource));+          callbacks = std::move(callbacks_);+        }+        for (auto& callback : callbacks) {+          callback();+        }+      });+}++void EnvironmentAutoDetect::NotifyOnDone(absl::AnyInvocable<void()> callback) {+  {+    grpc_core::ReleasableMutexLock lock(&mu_);","Done. I was intending to reduce the critical region as much as I could, but the EventEngine::Run call is not so bad that we need to worry about it here.",
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/32294,1105302481,2023-02-14T05:14:39Z,src/cpp/ext/filters/census/environment_autodetect.cc,"@@ -0,0 +1,349 @@+//+//+// Copyright 2023 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+//+//++#include ""src/cpp/ext/filters/census/environment_autodetect.h""++#include <grpc/support/port_platform.h>+#include <grpc/support/alloc.h>+#include <grpc/support/log.h>+#include <grpc/support/sync.h>+#include <grpcpp/impl/grpc_library.h>+#include <algorithm>+#include <memory>+#include <utility>++#include ""absl/container/flat_hash_map.h""+#include ""absl/meta/type_traits.h""+#include ""absl/status/status.h""+#include ""absl/status/statusor.h""+#include ""absl/types/optional.h""+#include ""src/core/ext/gcp/metadata_query.h""+#include ""src/core/lib/event_engine/default_event_engine.h""+#include ""src/core/lib/gprpp/crash.h""+#include ""src/core/lib/gprpp/env.h""+#include ""src/core/lib/gprpp/load_file.h""+#include ""src/core/lib/gprpp/orphanable.h""+#include ""src/core/lib/gprpp/status_helper.h""+#include ""src/core/lib/gprpp/time.h""+#include ""src/core/lib/iomgr/closure.h""+#include ""src/core/lib/iomgr/error.h""+#include ""src/core/lib/iomgr/exec_ctx.h""+#include ""src/core/lib/iomgr/iomgr_fwd.h""+#include ""src/core/lib/iomgr/polling_entity.h""+#include ""src/core/lib/iomgr/pollset.h""+#include ""src/core/lib/slice/slice.h""++namespace grpc {+namespace internal {++namespace {++// This is not a definite method to get the namespace name for GKE, but it is+// the best we have.+std::string GetNamespaceName() {+  // Read the root file.+  const char* filename =+      ""/var/run/secrets/kubernetes.io/serviceaccount/namespace"";+  auto namespace_name = grpc_core::LoadFile(filename, false);+  if (!namespace_name.ok()) {+    gpr_log(GPR_DEBUG, ""Reading file %s failed: %s"", filename,+            grpc_core::StatusToString(namespace_name.status()).c_str());+    // Fallback on an environment variable+    return grpc_core::GetEnv(""NAMESPACE_NAME"").value_or("""");+  }+  return std::string(reinterpret_cast<const char*>((*namespace_name).begin()),+                     (*namespace_name).length());+}++// Get pod name for GKE+std::string GetPodName() {+  auto pod_name = grpc_core::GetEnv(""POD_NAME"");+  if (pod_name.has_value()) {+    return pod_name.value();+  }+  return grpc_core::GetEnv(""HOSTNAME"").value_or("""");+}++// Get container name for GKE+std::string GetContainerName() {+  return grpc_core::GetEnv(""HOSTNAME"").value_or("""");+}++// Get function name for Cloud Functions+std::string GetFunctionName() {+  auto k_service = grpc_core::GetEnv(""K_SERVICE"");+  if (k_service.has_value()) {+    return k_service.value();+  }+  return grpc_core::GetEnv(""FUNCTION_NAME"").value_or("""");+}++// Get revision name for Cloud run+std::string GetRevisionName() {+  return grpc_core::GetEnv(""K_REVISION"").value_or("""");+}++// Get service name for Cloud run+std::string GetServiceName() {+  return grpc_core::GetEnv(""K_SERVICE"").value_or("""");+}++// Get configuration name for Cloud run+std::string GetConfiguratioName() {+  return grpc_core::GetEnv(""K_CONFIGURATION"").value_or("""");+}++// Get module ID for App Engine+std::string GetModuleId() {+  return grpc_core::GetEnv(""GAE_SERVICE"").value_or("""");+}++// Get version ID for App Engine+std::string GetVersionId() {+  return grpc_core::GetEnv(""GAE_VERSION"").value_or("""");+}++// Fire and forget class+class EnvironmentAutoDetectHelper+    : public grpc_core::InternallyRefCounted<EnvironmentAutoDetectHelper>,+      private internal::GrpcLibrary {+ public:+  explicit EnvironmentAutoDetectHelper(","I don't see this constructor used with an initializer list, and I'm not sure you'd want to prevent that regardless, so removing `explicit` here seems the right thing to do.",
4181124,yashykt,https://api.github.com/repos/grpc/grpc/pulls/32294,1105406676,2023-02-14T07:37:32Z,src/cpp/ext/filters/census/environment_autodetect.cc,"@@ -0,0 +1,349 @@+//+//+// Copyright 2023 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+//+//++#include ""src/cpp/ext/filters/census/environment_autodetect.h""++#include <grpc/support/port_platform.h>+#include <grpc/support/alloc.h>+#include <grpc/support/log.h>+#include <grpc/support/sync.h>+#include <grpcpp/impl/grpc_library.h>+#include <algorithm>+#include <memory>+#include <utility>++#include ""absl/container/flat_hash_map.h""+#include ""absl/meta/type_traits.h""+#include ""absl/status/status.h""+#include ""absl/status/statusor.h""+#include ""absl/types/optional.h""+#include ""src/core/ext/gcp/metadata_query.h""+#include ""src/core/lib/event_engine/default_event_engine.h""+#include ""src/core/lib/gprpp/crash.h""+#include ""src/core/lib/gprpp/env.h""+#include ""src/core/lib/gprpp/load_file.h""+#include ""src/core/lib/gprpp/orphanable.h""+#include ""src/core/lib/gprpp/status_helper.h""+#include ""src/core/lib/gprpp/time.h""+#include ""src/core/lib/iomgr/closure.h""+#include ""src/core/lib/iomgr/error.h""+#include ""src/core/lib/iomgr/exec_ctx.h""+#include ""src/core/lib/iomgr/iomgr_fwd.h""+#include ""src/core/lib/iomgr/polling_entity.h""+#include ""src/core/lib/iomgr/pollset.h""+#include ""src/core/lib/slice/slice.h""++namespace grpc {+namespace internal {++namespace {++// This is not a definite method to get the namespace name for GKE, but it is+// the best we have.+std::string GetNamespaceName() {+  // Read the root file.+  const char* filename =+      ""/var/run/secrets/kubernetes.io/serviceaccount/namespace"";+  auto namespace_name = grpc_core::LoadFile(filename, false);+  if (!namespace_name.ok()) {+    gpr_log(GPR_DEBUG, ""Reading file %s failed: %s"", filename,+            grpc_core::StatusToString(namespace_name.status()).c_str());+    // Fallback on an environment variable+    return grpc_core::GetEnv(""NAMESPACE_NAME"").value_or("""");+  }+  return std::string(reinterpret_cast<const char*>((*namespace_name).begin()),+                     (*namespace_name).length());+}++// Get pod name for GKE+std::string GetPodName() {+  auto pod_name = grpc_core::GetEnv(""POD_NAME"");+  if (pod_name.has_value()) {+    return pod_name.value();+  }+  return grpc_core::GetEnv(""HOSTNAME"").value_or("""");+}++// Get container name for GKE+std::string GetContainerName() {+  return grpc_core::GetEnv(""HOSTNAME"").value_or("""");+}++// Get function name for Cloud Functions+std::string GetFunctionName() {+  auto k_service = grpc_core::GetEnv(""K_SERVICE"");+  if (k_service.has_value()) {+    return k_service.value();+  }+  return grpc_core::GetEnv(""FUNCTION_NAME"").value_or("""");+}++// Get revision name for Cloud run+std::string GetRevisionName() {+  return grpc_core::GetEnv(""K_REVISION"").value_or("""");+}++// Get service name for Cloud run+std::string GetServiceName() {+  return grpc_core::GetEnv(""K_SERVICE"").value_or("""");+}++// Get configuration name for Cloud run+std::string GetConfiguratioName() {+  return grpc_core::GetEnv(""K_CONFIGURATION"").value_or("""");+}++// Get module ID for App Engine+std::string GetModuleId() {+  return grpc_core::GetEnv(""GAE_SERVICE"").value_or("""");+}++// Get version ID for App Engine+std::string GetVersionId() {+  return grpc_core::GetEnv(""GAE_VERSION"").value_or("""");+}++// Fire and forget class+class EnvironmentAutoDetectHelper+    : public grpc_core::InternallyRefCounted<EnvironmentAutoDetectHelper>,+      private internal::GrpcLibrary {+ public:+  explicit EnvironmentAutoDetectHelper(+      std::string project_id,+      absl::AnyInvocable<void(EnvironmentAutoDetect::ResourceType)> on_done,+      std::shared_ptr<grpc_event_engine::experimental::EventEngine>+          event_engine)+      : InternallyRefCounted(/*trace=*/nullptr, /*initial_refcount=*/2),+        project_id_(std::move(project_id)),+        on_done_(std::move(on_done)),+        event_engine_(std::move(event_engine)) {+    grpc_core::ExecCtx exec_ctx;+    // TODO(yashykt): The pollset stuff should go away once the HTTP library is+    // ported over to use EventEngine.+    pollset_ = static_cast<grpc_pollset*>(gpr_zalloc(grpc_pollset_size()));+    grpc_pollset_init(pollset_, &mu_poll_);+    pollent_ = grpc_polling_entity_create_from_pollset(pollset_);+    // TODO(yashykt): Note that using EventEngine::Run is not fork-safe. If we+    // want to make this fork-safe, we might need some re-work here.+    event_engine_->Run([this] { PollLoop(); });+    AutoDetect();+  }++  ~EnvironmentAutoDetectHelper() override {+    grpc_core::ExecCtx exec_ctx;+    grpc_pollset_shutdown(+        pollset_, GRPC_CLOSURE_CREATE(+                      [](void* arg, absl::Status /* status */) {+                        grpc_pollset_destroy(static_cast<grpc_pollset*>(arg));+                        gpr_free(arg);+                      },+                      pollset_, nullptr));+  }++  void Orphan() override {+    grpc_core::Crash(""Illegal Orphan() call on EnvironmentAutoDetectHelper."");+  }++ private:+  struct Attribute {+    std::string resource_attribute;+    std::string metadata_server_atttribute;+  };++  void PollLoop() {+    gpr_log(GPR_ERROR, ""polling"");+    grpc_core::ExecCtx exec_ctx;+    bool done = false;+    gpr_mu_lock(mu_poll_);+    grpc_pollset_worker* worker = nullptr;+    if (!GRPC_LOG_IF_ERROR(+            ""pollset_work"",+            grpc_pollset_work(grpc_polling_entity_pollset(&pollent_), &worker,+                              grpc_core::Timestamp::InfPast()))) {+      notify_poller_ = true;+    }+    done = notify_poller_;+    gpr_mu_unlock(mu_poll_);+    if (!done) {+      event_engine_->RunAfter(grpc_core::Duration::Milliseconds(100),","Isn't it bad to do a blocking sleep in an event manager thread. That seems like something we definitely do not want to do. Also note that in this case, we really do not care about performance.",
16962414,gtcooke94,https://api.github.com/repos/grpc/grpc/pulls/32365,1106051342,2023-02-14T16:19:00Z,src/core/lib/security/credentials/tls/grpc_tls_certificate_provider.cc,"@@ -117,14 +117,26 @@ gpr_timespec TimeoutSecondsToDeadline(int64_t seconds) {  }  // namespace +static const int64_t MINIMUM_FILE_WATCHER_REFRESH_INTERVAL_SECONDS = 1;","I'm not sure exactly what the style is, I'll dig around some more codeI saw these - https://source.corp.google.com/github/grpc/grpc/src/core/tsi/ssl_transport_security.cc;rcl=1d8fac36b3914fc17296158d4cb90b3fe51f4654;l=68 but those _are_ macros so I suppose I shouldn't be re-using that naming pattern",
9566254,apolcyn,https://api.github.com/repos/grpc/grpc/pulls/32294,1106143223,2023-02-14T17:35:30Z,src/core/ext/gcp/metadata_query.h,"@@ -0,0 +1,64 @@+//+// Copyright 2023 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+//++#ifndef GRPC_SRC_CORE_EXT_GCP_METADATA_QUERY_H+#define GRPC_SRC_CORE_EXT_GCP_METADATA_QUERY_H++#include <grpc/support/port_platform.h>++#include <string>++#include ""absl/functional/any_invocable.h""+#include ""absl/status/status.h""++#include ""src/core/lib/http/parser.h""+#include ""src/core/lib/iomgr/closure.h""+#include ""src/core/lib/iomgr/polling_entity.h""++namespace grpc_core {++// Fire and Forget class (Cleans up after itself.)+// Fetches the value of an attribute from the MetadataServer on a GCP+// environment.+class MetadataQuery {","The existing `MetadataQuery` object used by the google-c2p resolver is cancellable, and e.g. the resolver will cancel outstanding MD server queries during shutdown.Looks like cancellation is removed from the revised API, is that intentional?",
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/32370,1106162874,2023-02-14T17:52:16Z,src/core/lib/event_engine/posix_engine/posix_endpoint.cc,"@@ -1114,11 +1137,15 @@ void PosixEndpointImpl::Write(   GPR_DEBUG_ASSERT(data != nullptr);    if (data->Length() == 0) {-    on_writable(handle_->IsHandleShutdown()-                    ? TcpAnnotateError(absl::InternalError(""EOF""))-                    : status);     TcpShutdownTracedBufferList();-    return;+    if (handle_->IsHandleShutdown()) {+      status = TcpAnnotateError(absl::InternalError(""EOF""));+      engine_->Run([on_writable = std::move(on_writable), status]() mutable {+        on_writable(status);+      });+      return false;+    }+    return true;","You didn't introduce a change in behavior here, but I just realized that this swallows a potential error that the caller tried to do a Write with 0 data. Would it be better to run this async with an InvalidArgument error?",
52979934,matthewstevenson88,https://api.github.com/repos/grpc/grpc/pulls/32335,1106196650,2023-02-14T18:20:12Z,test/core/security/tls_security_connector_test.cc,"@@ -1089,6 +1127,38 @@ TEST_F(TlsSecurityConnectorTest,   core_external_verifier->Unref(); } +TEST_F(TlsSecurityConnectorTest,+       ServerSecurityConnectorWithVerifiedRootSubjectCertSucceeds) {+  auto* sync_verifier = new SyncExternalVerifier(true);+  ExternalCertificateVerifier core_external_verifier(sync_verifier->base());+  RefCountedPtr<grpc_tls_credentials_options> options =+      MakeRefCounted<grpc_tls_credentials_options>();+  options->set_cert_request_type(GRPC_SSL_DONT_REQUEST_CLIENT_CERTIFICATE);","I'm guessing it doesn't make a big difference to the test, but this option should be set to something different, since if the server is not requesting the client cert then it doesn't make sense to get the verified root.Can we just remove this line entirely? If it is necessary, can we change it to request and require verify?",
4181124,yashykt,https://api.github.com/repos/grpc/grpc/pulls/32294,1106246531,2023-02-14T18:52:35Z,src/core/ext/gcp/metadata_query.h,"@@ -0,0 +1,64 @@+//+// Copyright 2023 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+//++#ifndef GRPC_SRC_CORE_EXT_GCP_METADATA_QUERY_H+#define GRPC_SRC_CORE_EXT_GCP_METADATA_QUERY_H++#include <grpc/support/port_platform.h>++#include <string>++#include ""absl/functional/any_invocable.h""+#include ""absl/status/status.h""++#include ""src/core/lib/http/parser.h""+#include ""src/core/lib/iomgr/closure.h""+#include ""src/core/lib/iomgr/polling_entity.h""++namespace grpc_core {++// Fire and Forget class (Cleans up after itself.)+// Fetches the value of an attribute from the MetadataServer on a GCP+// environment.+class MetadataQuery {","MetadataQuery requests are intended to be quick enough that I don't think that the cancellation matters so much but it is also trivial enough to add, so I don't mind adding it.",
5564114,Vignesh2208,https://api.github.com/repos/grpc/grpc/pulls/32370,1106376945,2023-02-14T21:07:08Z,src/core/lib/event_engine/posix_engine/posix_endpoint.cc,"@@ -1114,11 +1137,15 @@ void PosixEndpointImpl::Write(   GPR_DEBUG_ASSERT(data != nullptr);    if (data->Length() == 0) {-    on_writable(handle_->IsHandleShutdown()-                    ? TcpAnnotateError(absl::InternalError(""EOF""))-                    : status);     TcpShutdownTracedBufferList();-    return;+    if (handle_->IsHandleShutdown()) {+      status = TcpAnnotateError(absl::InternalError(""EOF""));+      engine_->Run([on_writable = std::move(on_writable), status]() mutable {+        on_writable(status);+      });+      return false;+    }+    return true;","In the iomgr code, a write with 0 data isn't necessarily considered an error unless the endpoint is shutdown. Not sure what could happen if we break that semantics",
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/32370,1106440270,2023-02-14T22:20:28Z,src/core/lib/iomgr/event_engine_shims/endpoint.cc,"@@ -93,15 +94,98 @@ class EventEngineEndpointWrapper {   grpc_endpoint* GetGrpcEndpoint() { return &eeep_->base; }    // Read using the underlying EventEngine endpoint object.-  void Read(absl::AnyInvocable<void(absl::Status)> on_read, SliceBuffer* buffer,+  bool Read(grpc_closure* read_cb, grpc_slice_buffer* pending_read_buffer,             const EventEngine::Endpoint::ReadArgs* args) {-    endpoint_->Read(std::move(on_read), buffer, args);+    Ref();+    pending_read_cb_ = read_cb;+    pending_read_buffer_ = pending_read_buffer;+    // TODO(vigneshbabu): Use SliceBufferCast<> here.+    SliceBuffer* read_buffer = new (&eeep_->read_buffer)+        SliceBuffer(SliceBuffer::TakeCSliceBuffer(*pending_read_buffer_));+    read_buffer->Clear();","> The endpoint read implementations can only append to the read buffer.Interesting. We didn't document it that way (in iomgr either), and there are a few spots that make other assumptions about the state of buffers before and after calling read. https://github.com/grpc/grpc/blob/dd07fd8669d4dc0a8c51f4d8841e1d6c8710b371/src/core/lib/transport/http_connect_handshaker.cc#L249-L255We could stand to save a few allocations by reusing any slices in the buffer as ""sacrificial"", but we can experiment later.",
4181124,yashykt,https://api.github.com/repos/grpc/grpc/pulls/32294,1106441086,2023-02-14T22:21:19Z,src/core/ext/gcp/metadata_query.cc,"@@ -0,0 +1,113 @@+//+//+// Copyright 2023 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+//+//++#include <grpc/support/port_platform.h>++#include ""src/core/ext/gcp/metadata_query.h""++#include <string.h>++#include <memory>+#include <utility>++#include ""absl/status/statusor.h""+#include ""absl/strings/string_view.h""++#include <grpc/grpc.h>+#include <grpc/grpc_security.h>+#include <grpc/support/log.h>++#include ""src/core/lib/gprpp/ref_counted_ptr.h""+#include ""src/core/lib/gprpp/status_helper.h""+#include ""src/core/lib/gprpp/time.h""+#include ""src/core/lib/http/httpcli.h""+#include ""src/core/lib/security/credentials/credentials.h""+#include ""src/core/lib/uri/uri_parser.h""++namespace grpc_core {++constexpr const char MetadataQuery::kZoneAttribute[] =+    ""/computeMetadata/v1/instance/zone"";+constexpr const char MetadataQuery::kClusterNameAttribute[] =+    ""/computeMetadata/v1/instance/attributes/cluster-name"";+constexpr const char MetadataQuery::kRegionAttribute[] =+    ""/computeMetadata/v1/instance/region"";+constexpr const char MetadataQuery::kInstanceIdAttribute[] =+    ""/computeMetadata/v1/instance/id"";+constexpr const char MetadataQuery::kIPv6Attribute[] =+    ""/computeMetadata/v1/instance/network-interfaces/0/ipv6s"";++MetadataQuery::MetadataQuery(+    std::string attribute, grpc_polling_entity* pollent,+    absl::AnyInvocable<void(std::string /* attribute */,+                            std::string /* result */)>+        callback)+    : attribute_(std::move(attribute)), callback_(std::move(callback)) {+  GRPC_CLOSURE_INIT(&on_done_, OnDone, this, nullptr);+  auto uri =+      grpc_core::URI::Create(""http"", ""metadata.google.internal."", attribute_,+                             {} /* query params */, """" /* fragment */);+  GPR_ASSERT(uri.ok());  // params are hardcoded+  grpc_http_request request;+  memset(&request, 0, sizeof(grpc_http_request));+  grpc_http_header header = {const_cast<char*>(""Metadata-Flavor""),+                             const_cast<char*>(""Google"")};+  request.hdr_count = 1;+  request.hdrs = &header;+  // The http call is local. If it takes more than one sec, it is probably not+  // on GCP.+  auto http_request = grpc_core::HttpRequest::Get(+      std::move(*uri), nullptr /* channel args */, pollent, &request,+      grpc_core::Timestamp::Now() + grpc_core::Duration::Seconds(1), &on_done_,+      &response_,+      grpc_core::RefCountedPtr<grpc_channel_credentials>(+          grpc_insecure_credentials_create()));+  http_request->Start();+}++MetadataQuery::~MetadataQuery() { grpc_http_response_destroy(&response_); }++void MetadataQuery::OnDone(void* arg, absl::Status error) {+  auto* self = static_cast<MetadataQuery*>(arg);+  std::string result;+  if (!error.ok()) {+    gpr_log(GPR_ERROR, ""MetadataServer Query failed for %s: %s"",","Given that Alex had similar concerns, guarded it with TraceFlags",
9566254,apolcyn,https://api.github.com/repos/grpc/grpc/pulls/32294,1107524473,2023-02-15T18:17:01Z,src/core/ext/gcp/metadata_query.cc,"@@ -0,0 +1,127 @@+//+//+// Copyright 2023 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+//+//++#include <grpc/support/port_platform.h>++#include ""src/core/ext/gcp/metadata_query.h""++#include <string.h>++#include <memory>+#include <utility>++#include ""absl/status/statusor.h""+#include ""absl/strings/string_view.h""++#include <grpc/grpc.h>+#include <grpc/grpc_security.h>+#include <grpc/support/log.h>++#include ""src/core/lib/debug/trace.h""+#include ""src/core/lib/gprpp/ref_counted_ptr.h""+#include ""src/core/lib/gprpp/status_helper.h""+#include ""src/core/lib/gprpp/time.h""+#include ""src/core/lib/security/credentials/credentials.h""+#include ""src/core/lib/uri/uri_parser.h""++namespace grpc_core {++TraceFlag grpc_metadata_query_trace(false, ""metadata_query"");++constexpr const char MetadataQuery::kZoneAttribute[] =+    ""/computeMetadata/v1/instance/zone"";+constexpr const char MetadataQuery::kClusterNameAttribute[] =+    ""/computeMetadata/v1/instance/attributes/cluster-name"";+constexpr const char MetadataQuery::kRegionAttribute[] =+    ""/computeMetadata/v1/instance/region"";+constexpr const char MetadataQuery::kInstanceIdAttribute[] =+    ""/computeMetadata/v1/instance/id"";+constexpr const char MetadataQuery::kIPv6Attribute[] =+    ""/computeMetadata/v1/instance/network-interfaces/0/ipv6s"";++MetadataQuery::MetadataQuery(+    std::string attribute, grpc_polling_entity* pollent,+    absl::AnyInvocable<void(std::string /* attribute */,+                            std::string /* result */)>+        callback,+    Duration timeout)+    : InternallyRefCounted<MetadataQuery>(nullptr, 2),+      attribute_(std::move(attribute)),+      callback_(std::move(callback)) {+  GRPC_CLOSURE_INIT(&on_done_, OnDone, this, nullptr);+  auto uri = URI::Create(""http"", ""metadata.google.internal."", attribute_,+                         {} /* query params */, """" /* fragment */);+  GPR_ASSERT(uri.ok());  // params are hardcoded+  grpc_http_request request;+  memset(&request, 0, sizeof(grpc_http_request));+  grpc_http_header header = {const_cast<char*>(""Metadata-Flavor""),+                             const_cast<char*>(""Google"")};+  request.hdr_count = 1;+  request.hdrs = &header;+  // The http call is local. If it takes more than one sec, it is probably not+  // on GCP.+  http_request_ = HttpRequest::Get(+      std::move(*uri), nullptr /* channel args */, pollent, &request,+      Timestamp::Now() + timeout, &on_done_, &response_,+      RefCountedPtr<grpc_channel_credentials>(+          grpc_insecure_credentials_create()));+  http_request_->Start();+}++MetadataQuery::~MetadataQuery() { grpc_http_response_destroy(&response_); }++void MetadataQuery::Orphan() {+  http_request_.reset();+  Unref();+}++void MetadataQuery::OnDone(void* arg, absl::Status error) {+  auto* self = static_cast<MetadataQuery*>(arg);+  std::string result;+  if (!error.ok()) {+    if (GRPC_TRACE_FLAG_ENABLED(grpc_metadata_query_trace)) {+      gpr_log(GPR_INFO, ""MetadataServer Query failed for %s: %s"",+              self->attribute_.c_str(), StatusToString(error).c_str());+    }+  } else if (self->response_.status != 200) {+    if (GRPC_TRACE_FLAG_ENABLED(grpc_metadata_query_trace)) {","nit: as long as this tracer flag is enabled, it will probably be helpful to log all MD server query results, and the HTTP status will probably be useful to include in the log too.e.g. suggest replacing:```if (!error.ok()) {  ...} else if (self->response_.status != 200) {  ...}```with just one log at the top:```if (GRPC_TRACE_FLAG_ENABLED(grpc_metadata_query_trace)) {    gpr_log(GPR_INFO, ""MetadataServer Query for %s: http status: %d, error: %s"",            self->attribute_.c_str(), self->response_.status, StatusToString(error).c_str());}```",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32110,1107847944,2023-02-15T23:32:31Z,test/core/filters/filter_test.h,"@@ -0,0 +1,201 @@+// Copyright 2023 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++#ifndef GRPC_TEST_CORE_FILTERS_FILTER_TEST_H+#define GRPC_TEST_CORE_FILTERS_FILTER_TEST_H++#include <stddef.h>+#include <stdint.h>++#include <initializer_list>+#include <iosfwd>+#include <memory>+#include <ostream>+#include <string>+#include <utility>++#include <gtest/gtest.h>++#include ""absl/status/statusor.h""+#include ""absl/strings/escaping.h""+#include ""absl/strings/string_view.h""+#include ""gmock/gmock.h""++#include <grpc/event_engine/event_engine.h>+#include <grpc/event_engine/memory_allocator.h>++#include ""src/core/lib/channel/channel_args.h""+#include ""src/core/lib/channel/promise_based_filter.h""+#include ""src/core/lib/gprpp/ref_counted_ptr.h""+#include ""src/core/lib/resource_quota/memory_quota.h""+#include ""src/core/lib/resource_quota/resource_quota.h""+#include ""src/core/lib/slice/slice_buffer.h""+#include ""src/core/lib/transport/metadata_batch.h""+#include ""src/core/lib/transport/transport.h""+#include ""test/core/event_engine/fuzzing_event_engine/fuzzing_event_engine.h""+#include ""test/core/filters/filter_test.h""++// gmock matcher to ensure that metadata has a key/value pair.+MATCHER_P2(HasMetadataKeyValue, key, value, """") {+  std::string temp;+  auto r = arg.GetStringValue(key, &temp);+  return r == value;+}++// gmock matcher to ensure that a message has a given set of flags.+MATCHER_P(HasMessageFlags, value, """") { return arg.flags() == value; }++// gmock matcher to ensure that a message has a given payload.+MATCHER_P(HasMessagePayload, value, """") {+  return arg.payload()->JoinIntoString() == value;+}++namespace grpc_core {++inline std::ostream& operator<<(std::ostream& os,+                                const grpc_metadata_batch& md) {+  return os << md.DebugString();+}++inline std::ostream& operator<<(std::ostream& os, const Message& msg) {+  return os << ""flags:"" << msg.flags()+            << "" payload:"" << absl::CEscape(msg.payload()->JoinIntoString());+}++class FilterTestBase : public ::testing::Test {+ public:+  class Call;++  class Channel {+   private:+    struct Impl {+      Impl(std::unique_ptr<ChannelFilter> filter, FilterTestBase* test)+          : filter(std::move(filter)), test(test) {}+      size_t initial_arena_size = 1024;+      MemoryAllocator memory_allocator =+          ResourceQuota::Default()->memory_quota()->CreateMemoryAllocator(+              ""test"");+      std::unique_ptr<ChannelFilter> filter;+      FilterTestBase* const test;+    };++   public:+    void set_initial_arena_size(size_t size) {+      impl_->initial_arena_size = size;+    }++    Call MakeCall();++   private:+    friend class FilterTestBase;+    friend class Call;++    explicit Channel(std::unique_ptr<ChannelFilter> filter,+                     FilterTestBase* test)+        : impl_(std::make_shared<Impl>(std::move(filter), test)) {}++    std::shared_ptr<Impl> impl_;+  };++  // One ""call"" outstanding against this filter.+  // In reality - this filter is the only thing in the call.+  // Provides mocks to trap events that happen on the call.+  class Call {+   public:+    ~Call();+    explicit Call(const Channel& channel);++    Call(const Call&) = delete;+    Call& operator=(const Call&) = delete;++    // Construct client metadata in the arena of this call.+    // Optional argument is a list of key/value pairs to add to the metadata.+    ClientMetadataHandle NewClientMetadata(+        std::initializer_list<std::pair<absl::string_view, absl::string_view>>+            init = {});+    // Construct server metadata in the arena of this call.+    // Optional argument is a list of key/value pairs to add to the metadata.+    ServerMetadataHandle NewServerMetadata(+        std::initializer_list<std::pair<absl::string_view, absl::string_view>>+            init = {});+    // Construct a message in the arena of this call.+    MessageHandle NewMessage(absl::string_view payload = """",+                             uint32_t flags = 0);++    // Start the call.+    void Start(ClientMetadataHandle md);+    // Cancel the call.+    void Cancel();+    // Forward server initial metadata through this filter.+    void ForwardServerInitialMetadata(ServerMetadataHandle md);+    // Forward a message from client to server through this filter.+    void ForwardMessageClientToServer(MessageHandle msg);+    // Forward a message from server to client through this filter.+    void ForwardMessageServerToClient(MessageHandle msg);+    // Have the 'next' filter in the chain finish this call and return trailing+    // metadata.+    void FinishNextFilter(ServerMetadataHandle md);++    // Mock to trap starting the next filter in the chain.+    MOCK_METHOD(void, Started, (const ClientMetadata& client_initial_metadata));","This seems like a bit of a weird use of gmock, since we're not actually mocking out any interface here.  In particular, this seems to push some boilerplate into the tests with the need to use things like `StrictMock<>`, and it requires the test author to understand the specific points at which gmock expectations are checked (generally not until the mock's destruction, which can sometimes be a bit counter-intuitive when reading the code).  It seems like maybe we'd be better off with a bespoke event notification system here, which the tests can check at the specific points where they expect the events to occur, maybe something like the [event queue](https://github.com/grpc/grpc/blob/49b5dfc14f2d3b8723dcc865e93c5a59f2538e4a/test/core/client_channel/lb_policy/lb_policy_test_lib.h#L431) that we use in the LB policy test framework?",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/32110,1107905001,2023-02-16T01:11:13Z,test/core/filters/filter_test.h,"@@ -0,0 +1,201 @@+// Copyright 2023 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++#ifndef GRPC_TEST_CORE_FILTERS_FILTER_TEST_H+#define GRPC_TEST_CORE_FILTERS_FILTER_TEST_H++#include <stddef.h>+#include <stdint.h>++#include <initializer_list>+#include <iosfwd>+#include <memory>+#include <ostream>+#include <string>+#include <utility>++#include <gtest/gtest.h>++#include ""absl/status/statusor.h""+#include ""absl/strings/escaping.h""+#include ""absl/strings/string_view.h""+#include ""gmock/gmock.h""++#include <grpc/event_engine/event_engine.h>+#include <grpc/event_engine/memory_allocator.h>++#include ""src/core/lib/channel/channel_args.h""+#include ""src/core/lib/channel/promise_based_filter.h""+#include ""src/core/lib/gprpp/ref_counted_ptr.h""+#include ""src/core/lib/resource_quota/memory_quota.h""+#include ""src/core/lib/resource_quota/resource_quota.h""+#include ""src/core/lib/slice/slice_buffer.h""+#include ""src/core/lib/transport/metadata_batch.h""+#include ""src/core/lib/transport/transport.h""+#include ""test/core/event_engine/fuzzing_event_engine/fuzzing_event_engine.h""+#include ""test/core/filters/filter_test.h""++// gmock matcher to ensure that metadata has a key/value pair.+MATCHER_P2(HasMetadataKeyValue, key, value, """") {+  std::string temp;+  auto r = arg.GetStringValue(key, &temp);+  return r == value;+}++// gmock matcher to ensure that a message has a given set of flags.+MATCHER_P(HasMessageFlags, value, """") { return arg.flags() == value; }++// gmock matcher to ensure that a message has a given payload.+MATCHER_P(HasMessagePayload, value, """") {+  return arg.payload()->JoinIntoString() == value;+}++namespace grpc_core {++inline std::ostream& operator<<(std::ostream& os,+                                const grpc_metadata_batch& md) {+  return os << md.DebugString();+}++inline std::ostream& operator<<(std::ostream& os, const Message& msg) {+  return os << ""flags:"" << msg.flags()+            << "" payload:"" << absl::CEscape(msg.payload()->JoinIntoString());+}++class FilterTestBase : public ::testing::Test {+ public:+  class Call;++  class Channel {+   private:+    struct Impl {+      Impl(std::unique_ptr<ChannelFilter> filter, FilterTestBase* test)+          : filter(std::move(filter)), test(test) {}+      size_t initial_arena_size = 1024;+      MemoryAllocator memory_allocator =+          ResourceQuota::Default()->memory_quota()->CreateMemoryAllocator(+              ""test"");+      std::unique_ptr<ChannelFilter> filter;+      FilterTestBase* const test;+    };++   public:+    void set_initial_arena_size(size_t size) {+      impl_->initial_arena_size = size;+    }++    Call MakeCall();++   private:+    friend class FilterTestBase;+    friend class Call;++    explicit Channel(std::unique_ptr<ChannelFilter> filter,+                     FilterTestBase* test)+        : impl_(std::make_shared<Impl>(std::move(filter), test)) {}++    std::shared_ptr<Impl> impl_;+  };++  // One ""call"" outstanding against this filter.+  // In reality - this filter is the only thing in the call.+  // Provides mocks to trap events that happen on the call.+  class Call {+   public:+    ~Call();+    explicit Call(const Channel& channel);++    Call(const Call&) = delete;+    Call& operator=(const Call&) = delete;++    // Construct client metadata in the arena of this call.+    // Optional argument is a list of key/value pairs to add to the metadata.+    ClientMetadataHandle NewClientMetadata(+        std::initializer_list<std::pair<absl::string_view, absl::string_view>>+            init = {});+    // Construct server metadata in the arena of this call.+    // Optional argument is a list of key/value pairs to add to the metadata.+    ServerMetadataHandle NewServerMetadata(+        std::initializer_list<std::pair<absl::string_view, absl::string_view>>+            init = {});+    // Construct a message in the arena of this call.+    MessageHandle NewMessage(absl::string_view payload = """",+                             uint32_t flags = 0);++    // Start the call.+    void Start(ClientMetadataHandle md);+    // Cancel the call.+    void Cancel();+    // Forward server initial metadata through this filter.+    void ForwardServerInitialMetadata(ServerMetadataHandle md);+    // Forward a message from client to server through this filter.+    void ForwardMessageClientToServer(MessageHandle msg);+    // Forward a message from server to client through this filter.+    void ForwardMessageServerToClient(MessageHandle msg);+    // Have the 'next' filter in the chain finish this call and return trailing+    // metadata.+    void FinishNextFilter(ServerMetadataHandle md);++    // Mock to trap starting the next filter in the chain.+    MOCK_METHOD(void, Started, (const ClientMetadata& client_initial_metadata));","I'd actually argue that the LB testing framework could use picking up something like this.We seem to be in the process of designing and building an army of almost-gmock-matchers, each of which will be maintained and behave just a little bit differently.Instead, I'd prefer to leverage already built and battle tested systems where I can, and save our teams efforts for building RPC systems instead of testing frameworks wherever possible.Leveraging gmock here means I can use all of the actions built into gmock trivially, and have an already defined playbook for making extensions to the system.",
16962414,gtcooke94,https://api.github.com/repos/grpc/grpc/pulls/32335,1108765512,2023-02-16T16:57:43Z,test/core/end2end/fixtures/h2_tls_common.h,"@@ -51,7 +51,8 @@ struct SecurityPrimitives {   enum VerifierType {     EXTERNAL_SYNC_VERIFIER = 0,     EXTERNAL_ASYNC_VERIFIER = 1,-    HOSTNAME_VERIFIER = 2+    HOSTNAME_VERIFIER = 2,+    TEST_VERIFIER = 3,","Not sure if you saw my comment in the other chain, copying here:> I named the custom verifier TestExternalVerifier instead of something specific to root cert subject. I did this so that we have a modifiable custom verifier for checking any property if it is something we want to expand in the future.Really, there's nothing that tests all of these properties yet, so this test verifier should get expanded to test all the different properties that we populate from `tsi_peer`",X
7221003,rockspore,https://api.github.com/repos/grpc/grpc/pulls/32335,1108776056,2023-02-16T17:04:10Z,test/core/end2end/fixtures/h2_tls_common.h,"@@ -51,7 +51,8 @@ struct SecurityPrimitives {   enum VerifierType {     EXTERNAL_SYNC_VERIFIER = 0,     EXTERNAL_ASYNC_VERIFIER = 1,-    HOSTNAME_VERIFIER = 2+    HOSTNAME_VERIFIER = 2,+    TEST_VERIFIER = 3,","Yes I saw the comment there. Sorry, should have left it there.hmm, in the sense that this is using `grpc_core::testing::TestExternalVerifier`, it makes sense for the consistent naming. Otherwise, I'd argue that this class itself could be renamed to be more descriptive.Anyway, I don't have any strong opinion here. The test itself looks good to me.",X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32294,1108988952,2023-02-16T20:26:07Z,src/core/BUILD,"@@ -5310,6 +5304,37 @@ grpc_cc_library(     ], ) +grpc_cc_library(+    name = ""metadata_query"",",Suggest calling this `gcp_metadata_query`.,X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32294,1109001054,2023-02-16T20:39:39Z,src/core/ext/gcp/metadata_query.h,"@@ -0,0 +1,72 @@+//+// Copyright 2023 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+//++#ifndef GRPC_SRC_CORE_EXT_GCP_METADATA_QUERY_H+#define GRPC_SRC_CORE_EXT_GCP_METADATA_QUERY_H++#include <grpc/support/port_platform.h>++#include <string>++#include ""absl/functional/any_invocable.h""+#include ""absl/status/status.h""+#include ""absl/status/statusor.h""++#include ""src/core/lib/gprpp/orphanable.h""+#include ""src/core/lib/gprpp/time.h""+#include ""src/core/lib/http/httpcli.h""+#include ""src/core/lib/http/parser.h""+#include ""src/core/lib/iomgr/closure.h""+#include ""src/core/lib/iomgr/polling_entity.h""++namespace grpc_core {++// Fetches the value of an attribute from the MetadataServer on a GCP+// environment.+class MetadataQuery : public InternallyRefCounted<MetadataQuery> {+ public:+  static const char kZoneAttribute[];+  static const char kClusterNameAttribute[];+  static const char kRegionAttribute[];+  static const char kInstanceIdAttribute[];+  static const char kIPv6Attribute[];++  MetadataQuery(+      std::string attribute, grpc_polling_entity* pollent,+      absl::AnyInvocable<void(std::string /* attribute */,+                              absl::StatusOr<std::string> /* result */)>+          callback,+      Duration timeout);++  ~MetadataQuery() override;++  void Orphan() override;++ private:+  static void OnDone(void* arg, absl::Status error);","I think we should use `grpc_error_handle` instead of `absl::Status` as the type for this parameter, since this is a C-style closure.  That will be a signal to us that this is something that needs to be cleaned up later.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32294,1109008508,2023-02-16T20:48:55Z,src/cpp/ext/gcp/environment_autodetect.h,"@@ -59,7 +65,14 @@ class EnvironmentAutoDetect {   }   private:+  friend absl::Status grpc::experimental::GcpObservabilityInit();++  // GcpObservabilityInit() is responsible for setting up the singleton with the+  // project_id.+  static EnvironmentAutoDetect& Create(std::string project_id);","I don't think `Create()` should return the instance anymore, since it's just for initializing the global singleton.  Instead, it should set a static data member (or just a global in the .cc file), and `Get()` should directly return that global instead of calling `Create()`.",
52979934,matthewstevenson88,https://api.github.com/repos/grpc/grpc/pulls/32335,1109013631,2023-02-16T20:55:05Z,test/core/end2end/fixtures/h2_tls_common.h,"@@ -51,7 +51,8 @@ struct SecurityPrimitives {   enum VerifierType {     EXTERNAL_SYNC_VERIFIER = 0,     EXTERNAL_ASYNC_VERIFIER = 1,-    HOSTNAME_VERIFIER = 2+    HOSTNAME_VERIFIER = 2,+    TEST_VERIFIER = 3,","+1 that the name is a bit generic. Maybe ""PeerPropertyExternalVerifier"" or similar? WDYT?",
4181124,yashykt,https://api.github.com/repos/grpc/grpc/pulls/32294,1109026687,2023-02-16T21:10:54Z,test/cpp/ext/gcp/environment_autodetect_test.cc,"@@ -124,17 +118,17 @@ TEST_F(EnvironmentAutoDetectTest, AppEngine) { TEST_F(EnvironmentAutoDetectTest, MultipleNotifyWaiters) {   grpc::internal::EnvironmentAutoDetect env(""project""); -  absl::Notification notify[10];+  grpc_core::Notification notify[10];   for (int i = 0; i < 10; ++i) {     GetNotifiedOnEnvironmentDetection(&env, &notify[i]);   }   for (int i = 0; i < 10; ++i) {     notify[i].WaitForNotification();   } -  EXPECT_EQ(env.resource()->resource_type, ""global"");-  EXPECT_THAT(env.resource()->labels,-              UnorderedElementsAre(Pair(""project_id"", ""project"")));+  // Unless we test in a specific GCP resource, we should get ""global"" here.+  // EXPECT_EQ(env.resource()->resource_type, ""global"");","This is a problem of our testing environments. I can't be sure whether we'd be running on an environment that has MetadataServer or not, so unless I mock the MetadataServer, I can not get a stable result here across environments.",
4181124,yashykt,https://api.github.com/repos/grpc/grpc/pulls/32294,1109026786,2023-02-16T21:11:00Z,test/cpp/ext/gcp/environment_autodetect_test.cc,"@@ -55,25 +54,23 @@ class EnvironmentAutoDetectTest : public ::testing::Test { TEST_F(EnvironmentAutoDetectTest, Basic) {   grpc::internal::EnvironmentAutoDetect env(""project""); -  absl::Notification notify;+  grpc_core::Notification notify;   GetNotifiedOnEnvironmentDetection(&env, &notify);   notify.WaitForNotification();    // Unless we test in a specific GCP resource, we should get ""global"" here.-  EXPECT_EQ(env.resource()->resource_type, ""global"");-  EXPECT_THAT(env.resource()->labels,-              UnorderedElementsAre(Pair(""project_id"", ""project"")));+  // EXPECT_EQ(env.resource()->resource_type, ""global"");","This is a problem of our testing environments. I can't be sure whether we'd be running on an environment that has MetadataServer or not, so unless I mock the MetadataServer, I can not get a stable result here across environments.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32359,1113361570,2023-02-21T17:18:21Z,src/core/lib/promise/party.h,"@@ -24,124 +24,179 @@ #include <string> #include <utility> -#include ""absl/container/inlined_vector.h""+#include ""absl/strings/string_view.h"" #include ""absl/types/variant.h"" +#include <grpc/support/log.h>++#include ""src/core/lib/gprpp/construct_destruct.h""+#include ""src/core/lib/gprpp/crash.h""+#include ""src/core/lib/gprpp/debug_location.h"" #include ""src/core/lib/promise/activity.h""+#include ""src/core/lib/promise/context.h""+#include ""src/core/lib/promise/detail/promise_factory.h"" #include ""src/core/lib/promise/poll.h"" #include ""src/core/lib/resource_quota/arena.h""  namespace grpc_core {  // A Party is an Activity with multiple participant promises. class Party : public Activity, private Wakeable {- public:-  explicit Party(Arena* arena) : arena_(arena) {}+ private:+  // Non-owning wakeup handle.+  class Handle;++  // One participant in the party.+  class Participant {+   public:+    explicit Participant(absl::string_view name) : name_(name) {}+    // Poll the participant. Return true if complete.+    // Participant should take care of its own deallocation in this case.+    virtual bool Poll() = 0;++    // Destroy the participant before finishing.+    virtual void Destroy() = 0;++    // Return a Handle instance for this participant.+    Wakeable* MakeNonOwningWakeable(Party* party); +    absl::string_view name() const { return name_; }++   protected:+    ~Participant();++   private:+    Handle* handle_ = nullptr;+    absl::string_view name_;+  };++  // Number of bits reserved for wakeups gives us the maximum number of+  // participants.+  static constexpr size_t kMaxParticipants = 16;++ public:   Party(const Party&) = delete;   Party& operator=(const Party&) = delete; -  // Spawn one promise onto the arena.+  // Spawn one promise into the party.   // The promise will be polled until it is resolved, or until the party is shut   // down.   // The on_complete callback will be called with the result of the promise if   // it completes.   // A maximum of sixteen promises can be spawned onto a party.-  template <typename Promise, typename OnComplete>-  void Spawn(Promise promise, OnComplete on_complete);+  template <typename Factory, typename OnComplete>+  void Spawn(absl::string_view name, Factory promise_factory,+             OnComplete on_complete); -  void Orphan() final;+  void Orphan() final { Crash(""unused""); }    // Activity implementation: not allowed to be overridden by derived types.-  void ForceImmediateRepoll() final;+  void ForceImmediateRepoll(WakeupMask mask) final;+  WakeupMask CurrentParticipant() const final {+    GPR_DEBUG_ASSERT(currently_polling_ != kNotPolling);+    return 1u << currently_polling_;+  }   Waker MakeOwningWaker() final;   Waker MakeNonOwningWaker() final;-  std::string ActivityDebugTag(void* arg) const final;+  std::string ActivityDebugTag(WakeupMask arg) const final;   protected:+  explicit Party(Arena* arena, size_t initial_refs)+      : state_(kOneRef * initial_refs), arena_(arena) {}   ~Party() override;    // Main run loop. Must be locked.   // Polls participants and drains the add queue until there is no work left to   // be done.   // Derived types will likely want to override this to set up their   // contexts before polling.-  virtual void Run();--  Arena* arena() const { return arena_; }-- private:-  // Non-owning wakeup handle.-  class Handle;--  // One participant in the party.-  class Participant {-   public:-    virtual ~Participant();-    // Poll the participant. Return true if complete.-    virtual bool Poll() = 0;+  // Should not be called by derived types except as a tail call to RunParty.","Suggest changing ""to RunParty"" to say something like ""to the base class RunParty when overriding this method to add custom context"".",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32359,1113438639,2023-02-21T18:39:17Z,src/core/lib/channel/connected_channel.cc,"@@ -541,902 +421,562 @@ class ConnectedChannelStream : public Orphanable {     }   } -  // Called from outside the activity to push work down to the transport.-  void Push() {-    PushBatches push_batches;-    {-      MutexLock lock(&mu_);-      push_batches.swap(push_batches_);-    }-    for (auto* batch : push_batches) {-      if (stream() != nullptr) {-        grpc_transport_perform_stream_op(transport(), stream(), batch);-      } else {-        grpc_transport_stream_op_batch_finish_with_failure_from_transport(-            batch, absl::CancelledError());-      }-    }-    Unref(""push"");-  }--  void SendMessageBatchDone(grpc_error_handle error) {-    {-      MutexLock lock(&mu_);-      if (error != absl::OkStatus()) {-        // Note that we're in error here, the call will be closed by the-        // transport in a moment, and we'll return from the promise with an-        // error - so we don't need to do any extra work to close out pipes or-        // the like.-        send_message_state_ = Closed{};-      }-      if (!absl::holds_alternative<Closed>(send_message_state_)) {-        send_message_state_ = Idle{};-      }-      send_message_waker_.Wakeup();-    }-    Unref(""send_message"");-  }--  void RecvMessageBatchDone(grpc_error_handle error) {-    {-      MutexLock lock(mu());-      if (absl::holds_alternative<Closed>(recv_message_state_)) {-        if (grpc_call_trace.enabled()) {-          gpr_log(GPR_INFO,-                  ""%s[connected] RecvMessageBatchDone: already closed, ""-                  ""ignoring"",-                  recv_message_waker_.ActivityDebugTag().c_str());-        }-      } else {-        auto pending =-            absl::get_if<PendingReceiveMessage>(&recv_message_state_);-        GPR_ASSERT(pending != nullptr);-        if (!error.ok()) {-          if (grpc_call_trace.enabled()) {-            gpr_log(GPR_INFO, ""%s[connected] RecvMessageBatchDone: error=%s"",-                    recv_message_waker_.ActivityDebugTag().c_str(),-                    StatusToString(error).c_str());-          }-          pending->payload.reset();-        } else if (grpc_call_trace.enabled()) {-          gpr_log(GPR_INFO,-                  ""%s[connected] RecvMessageBatchDone: received message"",-                  recv_message_waker_.ActivityDebugTag().c_str());-        }-        GPR_ASSERT(pending->received == false);-        pending->received = true;-      }-      recv_message_waker_.Wakeup();-    }-    Unref(""recv_message"");-  }--  void PushRecvMessage() ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu_) {-    recv_message_state_ = PendingReceiveMessage{};-    auto& pending_recv_message =-        absl::get<PendingReceiveMessage>(recv_message_state_);-    memset(&recv_message_, 0, sizeof(recv_message_));-    recv_message_.payload = batch_payload();-    recv_message_.on_complete = nullptr;-    recv_message_.recv_message = true;-    batch_payload()->recv_message.recv_message = &pending_recv_message.payload;-    batch_payload()->recv_message.flags = &pending_recv_message.flags;-    batch_payload()->recv_message.call_failed_before_recv_message = nullptr;-    batch_payload()->recv_message.recv_message_ready =-        &recv_message_batch_done_;-    IncrementRefCount(""recv_message"");-    recv_message_waker_ = Activity::current()->MakeOwningWaker();-    SchedulePush(&recv_message_);-  }--  mutable Mutex mu_;   grpc_transport* const transport_;-  CallContext* const call_context_{GetContext<CallContext>()};+  RefCountedPtr<CallContext> const call_context_{+      GetContext<CallContext>()->Ref()};   grpc_closure stream_destroyed_ =       MakeMemberClosure<ConnectedChannelStream,                         &ConnectedChannelStream::StreamDestroyed>(           this, DEBUG_LOCATION);   grpc_stream_refcount stream_refcount_;   StreamPtr stream_;-  using PushBatches = absl::InlinedVector<grpc_transport_stream_op_batch*, 3>;-  PushBatches push_batches_ ABSL_GUARDED_BY(mu_);-  grpc_closure push_ =-      MakeMemberClosure<ConnectedChannelStream, &ConnectedChannelStream::Push>(-          this, DEBUG_LOCATION);--  NextResult<MessageHandle> message_to_send_ ABSL_GUARDED_BY(mu_);-  absl::variant<Idle, Closed, PipeReceiverNextType<MessageHandle>,-                SendMessageToTransport>-      send_message_state_ ABSL_GUARDED_BY(mu_);-  grpc_transport_stream_op_batch send_message_;-  grpc_closure send_message_batch_done_ =-      MakeMemberClosure<ConnectedChannelStream,-                        &ConnectedChannelStream::SendMessageBatchDone>(-          this, DEBUG_LOCATION);--  struct PendingReceiveMessage {-    absl::optional<SliceBuffer> payload;-    uint32_t flags;-    bool received = false;-  };-  absl::variant<Idle, PendingReceiveMessage, Closed,-                PipeSender<MessageHandle>::PushType>-      recv_message_state_ ABSL_GUARDED_BY(mu_);-  grpc_closure recv_message_batch_done_ =-      MakeMemberClosure<ConnectedChannelStream,-                        &ConnectedChannelStream::RecvMessageBatchDone>(-          this, DEBUG_LOCATION);-  grpc_transport_stream_op_batch recv_message_;--  Waker send_message_waker_ ABSL_GUARDED_BY(mu_);-  Waker recv_message_waker_ ABSL_GUARDED_BY(mu_);-  bool finished_ ABSL_GUARDED_BY(mu_) = false;+  Arena* arena_ = GetContext<Arena>();+  Party* const party_ = static_cast<Party*>(Activity::current());+  std::atomic<bool> finished_{false};","Please document how these two data members are related.Also consider refactoring into a class for this pattern, since it's popped up in a few places now.",X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32335,1113642296,2023-02-21T22:37:40Z,test/core/end2end/generate_tests.bzl,"@@ -117,6 +117,7 @@ END2END_FIXTURES = {     ""h2_tls_static_async_tls1_3"": _fixture_options(secure = True),     ""h2_tls_certwatch_sync_tls1_2"": _fixture_options(secure = True),     ""h2_tls_certwatch_async_tls1_3"": _fixture_options(secure = True),+    ""h2_tls_peer_property_external_verifier"": _fixture_options(secure = True),","Do we actually need to add a new test fixture for this?  Adding a test fixture is a pretty big multiplier for the set of test cases, because we basically run every core e2e test case in every fixture.  But it's not clear to me that this particular code is actually useful to run against every one of the e2e test cases -- it seems like we really need to test this functionality only once.I suggest instead just adding a single one-off test to cover this case with one common config.  As an example of such a one-off e2e test, see:https://github.com/grpc/grpc/blob/master/test/core/end2end/h2_ssl_session_reuse_test.cc",
16962414,gtcooke94,https://api.github.com/repos/grpc/grpc/pulls/32335,1114607078,2023-02-22T16:30:43Z,test/cpp/security/tls_certificate_verifier_test.cc,"@@ -161,6 +161,84 @@ TEST(TlsCertificateVerifierTest,   EXPECT_EQ(sync_status.error_message(), ""Hostname Verification Check failed.""); } +TEST(TlsCertificateVerifierTest,+     NoOpCertificateVerifierSucceedsWithVerifiedRootCertSubject) {+  grpc_tls_custom_verification_check_request request;+  std::string expected_subject =+      ""CN=testca,O=Internet Widgits Pty Ltd,ST=Some-State,C=AU"";+  request.peer_info.verified_root_cert_subject = expected_subject.c_str();+  auto verifier = std::make_shared<NoOpCertificateVerifier>();+  TlsCustomVerificationCheckRequest cpp_request(&request);+  EXPECT_EQ(cpp_request.verified_root_cert_subject(), expected_subject);+  grpc::Status sync_status;+  bool is_sync = verifier->Verify(&cpp_request, nullptr, &sync_status);+  EXPECT_TRUE(is_sync);+  EXPECT_TRUE(sync_status.ok())+      << sync_status.error_code() << "" "" << sync_status.error_message();+}++TEST(TlsCertificateVerifierTest,+     NoOpCertificateVerifierSucceedsWithoutVerifiedRootCertSubject) {+  grpc_tls_custom_verification_check_request request;+  memset(&request, 0, sizeof(request));+  auto verifier = std::make_shared<NoOpCertificateVerifier>();+  TlsCustomVerificationCheckRequest cpp_request(&request);+  EXPECT_EQ(cpp_request.verified_root_cert_subject(), """");+  grpc::Status sync_status;+  bool is_sync = verifier->Verify(&cpp_request, nullptr, &sync_status);+  EXPECT_TRUE(is_sync);+  EXPECT_TRUE(sync_status.ok())+      << sync_status.error_code() << "" "" << sync_status.error_message();+}++TEST(TlsCertificateVerifierTest, VerifiedRootCertSubjectVerifierSucceeds) {+  grpc_tls_custom_verification_check_request request;+  std::string expected_subject =","I original had these as `char*`, similar to the other tests in this file, but was suggested to use `std::string` to be more modern. I'll change it to `constexpr char[]`, but I want to make sure I understand why this is preferred here?",
28025951,HannahShiSFB,https://api.github.com/repos/grpc/grpc/pulls/32077,1114647655,2023-02-22T16:51:07Z,src/core/lib/event_engine/cf_engine/cftype_unique_ref.h,"@@ -0,0 +1,76 @@+// Copyright 2022 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+#ifndef GRPC_SRC_CORE_LIB_EVENT_ENGINE_CF_ENGINE_CFTYPE_UNIQUE_REF_H+#define GRPC_SRC_CORE_LIB_EVENT_ENGINE_CF_ENGINE_CFTYPE_UNIQUE_REF_H+#include <grpc/support/port_platform.h>++#ifdef GPR_APPLE++#include <CoreFoundation/CoreFoundation.h>++namespace grpc_event_engine {+namespace experimental {++template <typename T>+class CFTypeUniqueRef {","I tries with something like```template <typename T>using CFTypeUniqueRef =    std::unique_ptr<std::remove_cvref_t<decltype(*std::declval<T>())>,                    decltype(& CFRelease)>;```Which is very difficult to use because:1. Unlike typical unique_ptr use case, `T` (CFStringRef, CFErrorRef, etc.) is the pointer type thus the complex alias2. Deleter (&CFRelease) needs to be passed everywhere creating a pointer2. I don't do dereference (operator* and operator->) but only convert back and forth when using with CF APIs.3. I need `operator&` for using as output parameter",
28025951,HannahShiSFB,https://api.github.com/repos/grpc/grpc/pulls/32077,1114663219,2023-02-22T17:03:18Z,src/core/lib/event_engine/cf_engine/cftype_unique_ref.h,"@@ -0,0 +1,76 @@+// Copyright 2022 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+#ifndef GRPC_SRC_CORE_LIB_EVENT_ENGINE_CF_ENGINE_CFTYPE_UNIQUE_REF_H+#define GRPC_SRC_CORE_LIB_EVENT_ENGINE_CF_ENGINE_CFTYPE_UNIQUE_REF_H+#include <grpc/support/port_platform.h>++#ifdef GPR_APPLE++#include <CoreFoundation/CoreFoundation.h>++namespace grpc_event_engine {+namespace experimental {++template <typename T>+class CFTypeUniqueRef {","Alternative to this, I can also try warp a unique pointer for auto release then add implicit conversions and `operator&` if you prefer. It'll have a slightly overhead and will be something like```template <typename T>class CFTypeUniqueRef {public:  // conversions, operator&private:  std::unique_ptr<std::remove_cvref_t<decltype(*std::declval<T>())>,                    decltype(& CFRelease)> ref_;};```",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32335,1115045080,2023-02-22T22:33:45Z,test/cpp/security/tls_certificate_verifier_test.cc,"@@ -161,6 +161,84 @@ TEST(TlsCertificateVerifierTest,   EXPECT_EQ(sync_status.error_message(), ""Hostname Verification Check failed.""); } +TEST(TlsCertificateVerifierTest,+     NoOpCertificateVerifierSucceedsWithVerifiedRootCertSubject) {+  grpc_tls_custom_verification_check_request request;+  std::string expected_subject =+      ""CN=testca,O=Internet Widgits Pty Ltd,ST=Some-State,C=AU"";+  request.peer_info.verified_root_cert_subject = expected_subject.c_str();+  auto verifier = std::make_shared<NoOpCertificateVerifier>();+  TlsCustomVerificationCheckRequest cpp_request(&request);+  EXPECT_EQ(cpp_request.verified_root_cert_subject(), expected_subject);+  grpc::Status sync_status;+  bool is_sync = verifier->Verify(&cpp_request, nullptr, &sync_status);+  EXPECT_TRUE(is_sync);+  EXPECT_TRUE(sync_status.ok())+      << sync_status.error_code() << "" "" << sync_status.error_message();+}++TEST(TlsCertificateVerifierTest,+     NoOpCertificateVerifierSucceedsWithoutVerifiedRootCertSubject) {+  grpc_tls_custom_verification_check_request request;+  memset(&request, 0, sizeof(request));+  auto verifier = std::make_shared<NoOpCertificateVerifier>();+  TlsCustomVerificationCheckRequest cpp_request(&request);+  EXPECT_EQ(cpp_request.verified_root_cert_subject(), """");+  grpc::Status sync_status;+  bool is_sync = verifier->Verify(&cpp_request, nullptr, &sync_status);+  EXPECT_TRUE(is_sync);+  EXPECT_TRUE(sync_status.ok())+      << sync_status.error_code() << "" "" << sync_status.error_message();+}++TEST(TlsCertificateVerifierTest, VerifiedRootCertSubjectVerifierSucceeds) {+  grpc_tls_custom_verification_check_request request;+  std::string expected_subject =","`std::string` is generally not a good choice for a constant, because it needlessly copies the string and may dynamically allocate memory if the string is too long to be inlined (where the definition of ""too long"" is implementation-dependent).In general, I think `absl::string_view` is actually the best type for this kind of constant, but that type does not guarantee that the string is nul-terminated, so in cases like this one where you need to use it in a C-style API as a nul-terminated string, a simple char array seems like the best choice.Note that you generally do *not* want to use a non-const local variable the way you're currently doing on line 196, since modifying a constant string would cause a crash (it's effectively program code, not data).  That's why in this case, I am suggesting doing the `const_cast<>` only when setting the field in the `grpc_tls_custom_verification_check_request` struct, which is what requires the non-const pointer.  (More generally, I think it's actually a bug that the `grpc_tls_custom_verification_check_request` struct uses non-const `char*` pointers, because the verifier should not be allowed to change any of those strings.  I think we should actually change all of the string fields in that struct to use `const char*` instead.  But that can be done in a separate PR.)",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32335,1115070586,2023-02-22T23:00:36Z,test/cpp/util/tls_test_utils.h,"@@ -76,6 +76,25 @@ class AsyncCertificateVerifier   std::deque<Request> queue_ ABSL_GUARDED_BY(mu_); }; +class VerifiedRootCertSubjectVerifier+    : public grpc::experimental::ExternalCertificateVerifier {+ public:+  explicit VerifiedRootCertSubjectVerifier(const std::string& expected_subject)+      : expected_subject_(expected_subject) {}","Option 1: The way this is currently written:- If the caller has a `std::string` object, then we'll get a ref to that object passed into this ctor, and we'll make a copy of the `std::string` for the new object.- If the caller has a `char*` instead of a `std::string`, then the compiler will construct a temporary `std::string` object from the `char*` in the caller, so that it has an object that it can pass down a reference to, then we'll make a copy of that `std::string` for the new object, and then the compiler will immediately destroy the temporary `std::string` it created in the caller.  So we'll create two `std::string` objects and then immediately delete one of them.- If the caller has an `absl::string_view`, the caller will need to explicitly convert it to a `std::string`.  The result in this case is basically the same as the `char*` case, but it's a little more annoying to write, because there is no explicit conversion from `absl::string_view` to `std::string`.Option 2: If you change the parameter to `std::string` and use `std::move()` here:- If the caller has a `std::string` object, then a copy will be made to pass the string in by value, and then we'll move that copy into place in the new object, so we're just creating a single `std::string`.- If the caller has a `char*`, the compiler will construct a new `std::string` object from the `char*`, it will pass that in by value, and we'll move it into place in the new object, so we're just creating a single `std::string`.- If the caller has an `absl::string_view`, the caller will need to explicitly convert it to `std::string`.  The result in this case is basically the same as the `char*` case, but it's a little more annoying to write, because there is no explicit conversion from `absl::string_view` to `std::string`.- If the caller happens to have a `std::string` that they don't need to hold on to, then the caller can use `std::move()` to pass in the parameter, in which case we're not creating *any* new `std::string` objects.  (This case isn't necessarily that common, but it can be a useful optimization at times.)Option 3: Another option is to use `absl::string_view` as the parameter type, in which case:- Regardless of whether the caller has a `std::string`, `char*`, or `absl::string_view`, we will construct a new `absl::string_view` to pass in by value (which is much cheaper than constructing a `std::string`).  We will then create a new `std::string` from the `absl::string_view` for this object, so we're creating just one `std::string`.In general, `absl::string_view` is probably the right thing to use for any C++ code that takes a string as input.  But using `std::string` and then using `std::move()` to store it does allow optimizing for the occasional case where the caller already has a `std::string` that they no longer need.  So either of those options seems like a reasonable choice here.To be clear, the performance does not matter at all in this particular case, but I find that it's generally a good idea to consider the performance implications of the various ways of writing this sort of thing, so that you're in good habits when you do encounter a case where it really matters. :)",
16962414,gtcooke94,https://api.github.com/repos/grpc/grpc/pulls/32335,1115943889,2023-02-23T16:24:48Z,test/cpp/util/tls_test_utils.h,"@@ -76,6 +76,25 @@ class AsyncCertificateVerifier   std::deque<Request> queue_ ABSL_GUARDED_BY(mu_); }; +class VerifiedRootCertSubjectVerifier+    : public grpc::experimental::ExternalCertificateVerifier {+ public:+  explicit VerifiedRootCertSubjectVerifier(const std::string& expected_subject)+      : expected_subject_(expected_subject) {}",Thanks for the thorough explanation! I've swapped the parameter to an `absl::string_view`,
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/32459,1116206579,2023-02-23T20:20:04Z,test/distrib/bazel/cpp/.bazelrc,"@@ -1,4 +1,15 @@ # bazelrc file+common --enable_platform_specific_config","Python bazel distribtests only run on linux. The garden-variety distribtests hide all output unless there's an error, but luckily we've had an error recently, and the logs contain Megabytes of `cl : Command line warning D9002 : ignoring unknown option '-std=c++14'`.",
1535036,tamird,https://api.github.com/repos/grpc/grpc/pulls/32468,1117371568,2023-02-24T17:34:43Z,src/core/lib/event_engine/posix_engine/posix_engine_listener.cc,"@@ -246,7 +246,7 @@ absl::Status PosixEngineListenerImpl::HandleExternalConnection( void PosixEngineListenerImpl::AsyncConnectionAcceptor::Shutdown() {   // The ShutdownHandle whould trigger any waiting notify_on_accept_ to get   // scheduled with the not-OK status.-  handle_->ShutdownHandle(absl::InternalError(""Shutting down acceptor""));+  handle_->ShutdownHandle(absl::AbortedError(""Shutting down acceptor""));","Is that _long_ for ""yes""?",
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/32468,1117386000,2023-02-24T17:44:53Z,src/core/lib/event_engine/posix_engine/posix_engine_listener.cc,"@@ -246,7 +246,7 @@ absl::Status PosixEngineListenerImpl::HandleExternalConnection( void PosixEngineListenerImpl::AsyncConnectionAcceptor::Shutdown() {   // The ShutdownHandle whould trigger any waiting notify_on_accept_ to get   // scheduled with the not-OK status.-  handle_->ShutdownHandle(absl::InternalError(""Shutting down acceptor""));+  handle_->ShutdownHandle(absl::AbortedError(""Shutting down acceptor""));","Not really, it's an explanation, your question was ambiguous. ~I've added a TODO anyhow.~ It would be a whole project to systematically track the cleanup opportunities in this codebase. A valuable one, but not in scope for this PR.",
5663878,yijiem,https://api.github.com/repos/grpc/grpc/pulls/32488,1120706324,2023-02-28T20:02:20Z,src/core/lib/event_engine/windows/windows_listener.cc,"@@ -0,0 +1,356 @@+// Copyright 2023 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+#include <grpc/support/port_platform.h>++#ifdef GPR_WINDOWS++#include ""absl/status/status.h""+#include ""absl/strings/str_format.h""++#include ""src/core/lib/event_engine/tcp_socket_utils.h""+#include ""src/core/lib/event_engine/trace.h""+#include ""src/core/lib/event_engine/windows/iocp.h""+#include ""src/core/lib/event_engine/windows/win_socket.h""+#include ""src/core/lib/event_engine/windows/windows_endpoint.h""+#include ""src/core/lib/event_engine/windows/windows_listener.h""+#include ""src/core/lib/gprpp/crash.h""+#include ""src/core/lib/gprpp/sync.h""+#include ""src/core/lib/iomgr/error.h""++namespace grpc_event_engine {+namespace experimental {++// ---- SinglePortSocketListener::AsyncIOState ----++WindowsEventEngineListener::SinglePortSocketListener::AsyncIOState::+    AsyncIOState(SinglePortSocketListener* port_listener,+                 std::unique_ptr<WinSocket> listener_socket)+    : port_listener(port_listener),+      listener_socket(std::move(listener_socket)) {}++WindowsEventEngineListener::SinglePortSocketListener::AsyncIOState::+    ~AsyncIOState() {+  closesocket(accept_socket);+}++void WindowsEventEngineListener::SinglePortSocketListener::+    OnAcceptCallbackWrapper::Run() {+  GPR_ASSERT(io_state_ != nullptr);+  grpc_core::ReleasableMutexLock lock(&io_state_->mu);+  if (io_state_->listener_socket->IsShutdown()) {+    GRPC_EVENT_ENGINE_TRACE(+        ""SinglePortSocketListener::%p listener socket is shut down. Shutting ""+        ""down listener."",+        io_state_->port_listener);+    lock.Release();+    io_state_.reset();+    return;+  }+  io_state_->port_listener->OnAcceptCallbackLocked();+}++void WindowsEventEngineListener::SinglePortSocketListener::+    OnAcceptCallbackWrapper::Prime(std::shared_ptr<AsyncIOState> io_state) {+  io_state_ = std::move(io_state);+}++// ---- SinglePortSocketListener ----++WindowsEventEngineListener::SinglePortSocketListener::+    ~SinglePortSocketListener() {+  io_state_->listener_socket->Shutdown(DEBUG_LOCATION,+                                       ""~SinglePortSocketListener"");+  GRPC_EVENT_ENGINE_TRACE(""~SinglePortSocketListener::%p"", this);+}++absl::StatusOr<+    std::unique_ptr<WindowsEventEngineListener::SinglePortSocketListener>>+WindowsEventEngineListener::SinglePortSocketListener::Create(+    WindowsEventEngineListener* listener, SOCKET sock,+    EventEngine::ResolvedAddress addr) {+  // We need to grab the AcceptEx pointer for that port, as it may be+  // interface-dependent. We'll cache it to avoid doing that again.+  GUID guid = WSAID_ACCEPTEX;+  DWORD ioctl_num_bytes;+  LPFN_ACCEPTEX AcceptEx;+  int status =+      WSAIoctl(sock, SIO_GET_EXTENSION_FUNCTION_POINTER, &guid, sizeof(guid),+               &AcceptEx, sizeof(AcceptEx), &ioctl_num_bytes, NULL, NULL);+  if (status != 0) {+    auto error = GRPC_WSA_ERROR(WSAGetLastError(), ""WSASocket"");+    closesocket(sock);+    return error;+  }+  auto result = SinglePortSocketListener::PrepareListenerSocket(sock, addr);+  GRPC_RETURN_IF_ERROR(result.status());+  GPR_ASSERT(result->port >= 0);+  // Using `new` to access non-public constructor+  return absl::WrapUnique(new SinglePortSocketListener(+      listener, AcceptEx, /*win_socket=*/listener->iocp_->Watch(sock),+      result->port, result->hostbyname));+}++absl::Status WindowsEventEngineListener::SinglePortSocketListener::Start() {+  grpc_core::MutexLock lock(&io_state_->mu);+  return StartLocked();+}++absl::Status+WindowsEventEngineListener::SinglePortSocketListener::StartLocked() {+  SOCKET accept_socket = WSASocket(AF_INET6, SOCK_STREAM, IPPROTO_TCP, NULL, 0,+                                   IOCP::GetDefaultSocketFlags());+  if (accept_socket == INVALID_SOCKET) {+    return GRPC_WSA_ERROR(WSAGetLastError(), ""WSASocket"");+  }+  auto fail = [&](absl::Status error) -> absl::Status {+    if (accept_socket != INVALID_SOCKET) closesocket(accept_socket);+    return error;+  };+  auto error = PrepareSocket(accept_socket);+  if (!error.ok()) return fail(error);+  // Start the ""accept"" asynchronously.+  DWORD addrlen = sizeof(sockaddr_in6) + 16;+  DWORD bytes_received = 0;+  int success =+      AcceptEx(io_state_->listener_socket->raw_socket(), accept_socket,+               addresses_, 0, addrlen, addrlen, &bytes_received,+               io_state_->listener_socket->read_info()->overlapped());+  // It is possible to get an accept immediately without delay. However, we+  // will still get an IOCP notification for it. So let's just ignore it.+  if (success != 0) {+    int last_error = WSAGetLastError();+    if (last_error != ERROR_IO_PENDING) {+      return fail(GRPC_WSA_ERROR(last_error, ""AcceptEx""));+    }+  }+  // We're ready to do the accept. Calling NotifyOnRead may immediately process+  // an accept that happened in the meantime.+  io_state_->accept_socket = accept_socket;+  io_state_->listener_socket->NotifyOnRead(&io_state_->on_accept_cb);+  GRPC_EVENT_ENGINE_TRACE(+      ""SinglePortSocketListener::%p listening. listener_socket::%p"", this,+      io_state_->listener_socket.get());+  return absl::OkStatus();+}++void WindowsEventEngineListener::SinglePortSocketListener::+    OnAcceptCallbackLocked() {+  auto close_socket_and_restart =+      [&](bool do_close_socket = true)+          ABSL_EXCLUSIVE_LOCKS_REQUIRED(io_state_->mu) {+            if (do_close_socket) closesocket(io_state_->accept_socket);+            GPR_ASSERT(GRPC_LOG_IF_ERROR(""SinglePortSocketListener::Start"",+                                         StartLocked()));+          };+  const auto& overlapped_result =+      io_state_->listener_socket->read_info()->result();+  if (overlapped_result.wsa_error != 0) {+    gpr_log(GPR_ERROR, ""%s"",+            GRPC_WSA_ERROR(overlapped_result.wsa_error,+                           ""Skipping on_accept due to error"")+                .ToString()+                .c_str());+    return close_socket_and_restart();+  }+  SOCKET tmp_listener_socket = io_state_->listener_socket->raw_socket();+  int err =+      setsockopt(io_state_->accept_socket, SOL_SOCKET, SO_UPDATE_ACCEPT_CONTEXT,+                 reinterpret_cast<char*>(&tmp_listener_socket),+                 sizeof(tmp_listener_socket));+  if (err != 0) {+    gpr_log(GPR_ERROR, ""%s"",+            GRPC_WSA_ERROR(WSAGetLastError(), ""setsockopt"").ToString().c_str());+    return close_socket_and_restart();+  }+  EventEngine::ResolvedAddress peer_address;+  int peer_name_len = EventEngine::ResolvedAddress::MAX_SIZE_BYTES;+  err = getpeername(io_state_->accept_socket,+                    const_cast<sockaddr*>(peer_address.address()),+                    &peer_name_len);+  if (err != 0) {+    gpr_log(+        GPR_ERROR, ""%s"",+        GRPC_WSA_ERROR(WSAGetLastError(), ""getpeername"").ToString().c_str());+    return close_socket_and_restart();+  }+  peer_address =+      EventEngine::ResolvedAddress(peer_address.address(), peer_name_len);+  auto addr_uri = ResolvedAddressToURI(peer_address);+  std::string peer_name = ""unknown"";+  if (!addr_uri.ok()) {+    // TODO(hork): test an early exit/restart here with end2end tests+    gpr_log(GPR_ERROR, ""invalid peer name: %s"",+            addr_uri.status().ToString().c_str());+  } else {+    peer_name = *addr_uri;+  }+  auto endpoint = std::make_unique<WindowsEndpoint>(+      peer_address, listener_->iocp_->Watch(io_state_->accept_socket),+      listener_->memory_allocator_factory_->CreateMemoryAllocator(+          absl::StrFormat(""listener endpoint %s"", peer_name)),+      listener_->config_, listener_->executor_);+  listener_->accept_cb_(+      std::move(endpoint),+      listener_->memory_allocator_factory_->CreateMemoryAllocator(+          absl::StrFormat(""listener accept cb for %s"", peer_name)));+  close_socket_and_restart(/*do_close_socket=*/false);+}++WindowsEventEngineListener::SinglePortSocketListener::SinglePortSocketListener(+    WindowsEventEngineListener* listener, LPFN_ACCEPTEX AcceptEx,+    std::unique_ptr<WinSocket> listener_socket, int port,+    EventEngine::ResolvedAddress hostbyname)+    : AcceptEx(AcceptEx),+      listener_(listener),+      io_state_(+          std::make_shared<AsyncIOState>(this, std::move(listener_socket))),+      port_(port),+      listener_sockname_(hostbyname) {+  io_state_->on_accept_cb.Prime(io_state_);+}++absl::StatusOr<WindowsEventEngineListener::SinglePortSocketListener::+                   PrepareListenerSocketResult>+WindowsEventEngineListener::SinglePortSocketListener::PrepareListenerSocket(+    SOCKET sock, const EventEngine::ResolvedAddress& addr) {+  auto fail = [&](absl::Status error) -> absl::Status {+    GPR_ASSERT(!error.ok());+    auto addr_uri = ResolvedAddressToURI(addr);+    error = grpc_error_set_int(+        grpc_error_set_str(+            GRPC_ERROR_CREATE_REFERENCING(""Failed to prepare server socket"",+                                          &error, 1),+            grpc_core::StatusStrProperty::kTargetAddress,+            addr_uri.ok() ? *addr_uri : addr_uri.status().ToString()),+        grpc_core::StatusIntProperty::kFd, static_cast<intptr_t>(sock));+    if (sock != INVALID_SOCKET) closesocket(sock);+    return error;+  };+  auto error = PrepareSocket(sock);+  if (!error.ok()) return fail(error);+  if (bind(sock, addr.address(), addr.size()) == SOCKET_ERROR) {+    return fail(GRPC_WSA_ERROR(WSAGetLastError(), ""bind""));+  }+  if (listen(sock, SOMAXCONN) == SOCKET_ERROR) {+    return fail(GRPC_WSA_ERROR(WSAGetLastError(), ""listen""));+  }+  int sockname_temp_len = sizeof(struct sockaddr_storage);+  EventEngine::ResolvedAddress sockname_temp;+  if (getsockname(sock, const_cast<sockaddr*>(sockname_temp.address()),+                  &sockname_temp_len) == SOCKET_ERROR) {+    return fail(GRPC_WSA_ERROR(WSAGetLastError(), ""getsockname""));+  }+  sockname_temp =+      EventEngine::ResolvedAddress(sockname_temp.address(), sockname_temp_len);+  return PrepareListenerSocketResult{ResolvedAddressGetPort(sockname_temp),+                                     sockname_temp};+}++// ---- WindowsEventEngineListener ----++WindowsEventEngineListener::WindowsEventEngineListener(+    IOCP* iocp, AcceptCallback accept_cb,+    absl::AnyInvocable<void(absl::Status)> on_shutdown,+    std::unique_ptr<MemoryAllocatorFactory> memory_allocator_factory,+    std::shared_ptr<EventEngine> engine, Executor* executor,+    const EndpointConfig& config)+    : iocp_(iocp),+      config_(config),+      engine_(std::move(engine)),+      executor_(executor),+      memory_allocator_factory_(std::move(memory_allocator_factory)),+      accept_cb_(std::move(accept_cb)),+      on_shutdown_(std::move(on_shutdown)) {}++WindowsEventEngineListener::~WindowsEventEngineListener() {+  GRPC_EVENT_ENGINE_TRACE(+      ""%s"",+      absl::StrFormat(""WindowsEventEngineListener::%p shutting down"", this)+          .c_str());+  // Shut down each port listener before destroying this EventEngine::Listener+  for (auto& port_listener : port_listeners_) {+    port_listener.reset();+  }+  on_shutdown_(absl::OkStatus());+}++absl::StatusOr<int> WindowsEventEngineListener::Bind(+    const EventEngine::ResolvedAddress& addr) {+  if (started_.load()) {+    return absl::FailedPreconditionError(+        absl::StrFormat(""WindowsEventEngineListener::%p is already started, ""+                        ""ports can no longer be bound"",+                        this));+  }+  int out_port = ResolvedAddressGetPort(addr);+  EventEngine::ResolvedAddress out_addr(addr);+  EventEngine::ResolvedAddress tmp_addr;+  // Check if this is a  wildcard port, and if so, try to keep the port the same+  // as some previously created listener.+  if (out_port == 0) {+    grpc_core::MutexLock lock(&socket_listeners_mu_);+    for (const auto& port_listener : port_listeners_) {+      tmp_addr = port_listener->listener_sockname();+      out_port = ResolvedAddressGetPort(tmp_addr);+      if (out_port > 0) {+        ResolvedAddressSetPort(out_addr, out_port);+        break;+      }+    }+  }+  if (ResolvedAddressToV4Mapped(out_addr, &tmp_addr)) {+    out_addr = tmp_addr;+  }+  // Treat :: or 0.0.0.0 as a family-agnostic wildcard.+  if (ResolvedAddressIsWildcard(out_addr)) {+    out_addr = ResolvedAddressMakeWild6(out_port);+  }+  // open the socket+  SOCKET sock = WSASocket(AF_INET6, SOCK_STREAM, IPPROTO_TCP, nullptr, 0,+                          IOCP::GetDefaultSocketFlags());+  if (sock == INVALID_SOCKET) {+    auto error = GRPC_WSA_ERROR(WSAGetLastError(), ""WSASocket"");+    return GRPC_ERROR_CREATE_REFERENCING(""Failed to add port to server"", &error,+                                         1);+  }+  auto port_listener = AddSinglePortSocketListener(sock, out_addr);+  GRPC_RETURN_IF_ERROR(port_listener.status());+  return (*port_listener)->port();+}++absl::Status WindowsEventEngineListener::Start() {+  GPR_ASSERT(!started_.exchange(true));+  grpc_core::MutexLock lock(&socket_listeners_mu_);+  for (auto& port_listener : port_listeners_) {+    GRPC_RETURN_IF_ERROR(port_listener->Start());+  }+  return absl::OkStatus();+}++absl::StatusOr<WindowsEventEngineListener::SinglePortSocketListener*>+WindowsEventEngineListener::AddSinglePortSocketListener(+    SOCKET sock, EventEngine::ResolvedAddress addr) {+  auto single_port_listener =+      SinglePortSocketListener::Create(this, sock, addr);+  GRPC_RETURN_IF_ERROR(single_port_listener.status());+  auto* single_port_listener_ptr = single_port_listener->get();+  grpc_core::MutexLock lock(&socket_listeners_mu_);+  port_listeners_.emplace_back(std::move(*single_port_listener));","Looks like it's possible that a `single_port_listener` gets added (bind + listen) after the EE Listener has started (i.e. if `Start` is called on one thread when `Bind` is called on another thread)? If that happened, this SPL would not start to accept connections. If it's the same behavior as the old code, then probably fine? Just want to confirm.",
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/32488,1120878404,2023-02-28T22:34:58Z,src/core/lib/event_engine/windows/windows_listener.cc,"@@ -0,0 +1,356 @@+// Copyright 2023 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+#include <grpc/support/port_platform.h>++#ifdef GPR_WINDOWS++#include ""absl/status/status.h""+#include ""absl/strings/str_format.h""++#include ""src/core/lib/event_engine/tcp_socket_utils.h""+#include ""src/core/lib/event_engine/trace.h""+#include ""src/core/lib/event_engine/windows/iocp.h""+#include ""src/core/lib/event_engine/windows/win_socket.h""+#include ""src/core/lib/event_engine/windows/windows_endpoint.h""+#include ""src/core/lib/event_engine/windows/windows_listener.h""+#include ""src/core/lib/gprpp/crash.h""+#include ""src/core/lib/gprpp/sync.h""+#include ""src/core/lib/iomgr/error.h""++namespace grpc_event_engine {+namespace experimental {++// ---- SinglePortSocketListener::AsyncIOState ----++WindowsEventEngineListener::SinglePortSocketListener::AsyncIOState::+    AsyncIOState(SinglePortSocketListener* port_listener,+                 std::unique_ptr<WinSocket> listener_socket)+    : port_listener(port_listener),+      listener_socket(std::move(listener_socket)) {}++WindowsEventEngineListener::SinglePortSocketListener::AsyncIOState::+    ~AsyncIOState() {+  closesocket(accept_socket);+}++void WindowsEventEngineListener::SinglePortSocketListener::+    OnAcceptCallbackWrapper::Run() {+  GPR_ASSERT(io_state_ != nullptr);+  grpc_core::ReleasableMutexLock lock(&io_state_->mu);+  if (io_state_->listener_socket->IsShutdown()) {+    GRPC_EVENT_ENGINE_TRACE(+        ""SinglePortSocketListener::%p listener socket is shut down. Shutting ""+        ""down listener."",+        io_state_->port_listener);+    lock.Release();+    io_state_.reset();+    return;+  }+  io_state_->port_listener->OnAcceptCallbackLocked();+}++void WindowsEventEngineListener::SinglePortSocketListener::+    OnAcceptCallbackWrapper::Prime(std::shared_ptr<AsyncIOState> io_state) {+  io_state_ = std::move(io_state);+}++// ---- SinglePortSocketListener ----++WindowsEventEngineListener::SinglePortSocketListener::+    ~SinglePortSocketListener() {+  io_state_->listener_socket->Shutdown(DEBUG_LOCATION,+                                       ""~SinglePortSocketListener"");+  GRPC_EVENT_ENGINE_TRACE(""~SinglePortSocketListener::%p"", this);+}++absl::StatusOr<+    std::unique_ptr<WindowsEventEngineListener::SinglePortSocketListener>>+WindowsEventEngineListener::SinglePortSocketListener::Create(+    WindowsEventEngineListener* listener, SOCKET sock,+    EventEngine::ResolvedAddress addr) {+  // We need to grab the AcceptEx pointer for that port, as it may be+  // interface-dependent. We'll cache it to avoid doing that again.+  GUID guid = WSAID_ACCEPTEX;+  DWORD ioctl_num_bytes;+  LPFN_ACCEPTEX AcceptEx;+  int status =+      WSAIoctl(sock, SIO_GET_EXTENSION_FUNCTION_POINTER, &guid, sizeof(guid),+               &AcceptEx, sizeof(AcceptEx), &ioctl_num_bytes, NULL, NULL);+  if (status != 0) {+    auto error = GRPC_WSA_ERROR(WSAGetLastError(), ""WSASocket"");+    closesocket(sock);+    return error;+  }+  auto result = SinglePortSocketListener::PrepareListenerSocket(sock, addr);+  GRPC_RETURN_IF_ERROR(result.status());+  GPR_ASSERT(result->port >= 0);+  // Using `new` to access non-public constructor+  return absl::WrapUnique(new SinglePortSocketListener(+      listener, AcceptEx, /*win_socket=*/listener->iocp_->Watch(sock),+      result->port, result->hostbyname));+}++absl::Status WindowsEventEngineListener::SinglePortSocketListener::Start() {+  grpc_core::MutexLock lock(&io_state_->mu);+  return StartLocked();+}++absl::Status+WindowsEventEngineListener::SinglePortSocketListener::StartLocked() {+  SOCKET accept_socket = WSASocket(AF_INET6, SOCK_STREAM, IPPROTO_TCP, NULL, 0,+                                   IOCP::GetDefaultSocketFlags());+  if (accept_socket == INVALID_SOCKET) {+    return GRPC_WSA_ERROR(WSAGetLastError(), ""WSASocket"");+  }+  auto fail = [&](absl::Status error) -> absl::Status {+    if (accept_socket != INVALID_SOCKET) closesocket(accept_socket);+    return error;+  };+  auto error = PrepareSocket(accept_socket);+  if (!error.ok()) return fail(error);+  // Start the ""accept"" asynchronously.+  DWORD addrlen = sizeof(sockaddr_in6) + 16;+  DWORD bytes_received = 0;+  int success =+      AcceptEx(io_state_->listener_socket->raw_socket(), accept_socket,+               addresses_, 0, addrlen, addrlen, &bytes_received,+               io_state_->listener_socket->read_info()->overlapped());+  // It is possible to get an accept immediately without delay. However, we+  // will still get an IOCP notification for it. So let's just ignore it.+  if (success != 0) {+    int last_error = WSAGetLastError();+    if (last_error != ERROR_IO_PENDING) {+      return fail(GRPC_WSA_ERROR(last_error, ""AcceptEx""));+    }+  }+  // We're ready to do the accept. Calling NotifyOnRead may immediately process+  // an accept that happened in the meantime.+  io_state_->accept_socket = accept_socket;+  io_state_->listener_socket->NotifyOnRead(&io_state_->on_accept_cb);+  GRPC_EVENT_ENGINE_TRACE(+      ""SinglePortSocketListener::%p listening. listener_socket::%p"", this,+      io_state_->listener_socket.get());+  return absl::OkStatus();+}++void WindowsEventEngineListener::SinglePortSocketListener::+    OnAcceptCallbackLocked() {+  auto close_socket_and_restart =+      [&](bool do_close_socket = true)+          ABSL_EXCLUSIVE_LOCKS_REQUIRED(io_state_->mu) {+            if (do_close_socket) closesocket(io_state_->accept_socket);+            GPR_ASSERT(GRPC_LOG_IF_ERROR(""SinglePortSocketListener::Start"",+                                         StartLocked()));+          };+  const auto& overlapped_result =+      io_state_->listener_socket->read_info()->result();+  if (overlapped_result.wsa_error != 0) {+    gpr_log(GPR_ERROR, ""%s"",+            GRPC_WSA_ERROR(overlapped_result.wsa_error,+                           ""Skipping on_accept due to error"")+                .ToString()+                .c_str());+    return close_socket_and_restart();+  }+  SOCKET tmp_listener_socket = io_state_->listener_socket->raw_socket();+  int err =+      setsockopt(io_state_->accept_socket, SOL_SOCKET, SO_UPDATE_ACCEPT_CONTEXT,+                 reinterpret_cast<char*>(&tmp_listener_socket),+                 sizeof(tmp_listener_socket));+  if (err != 0) {+    gpr_log(GPR_ERROR, ""%s"",+            GRPC_WSA_ERROR(WSAGetLastError(), ""setsockopt"").ToString().c_str());+    return close_socket_and_restart();+  }+  EventEngine::ResolvedAddress peer_address;+  int peer_name_len = EventEngine::ResolvedAddress::MAX_SIZE_BYTES;+  err = getpeername(io_state_->accept_socket,+                    const_cast<sockaddr*>(peer_address.address()),+                    &peer_name_len);+  if (err != 0) {+    gpr_log(+        GPR_ERROR, ""%s"",+        GRPC_WSA_ERROR(WSAGetLastError(), ""getpeername"").ToString().c_str());+    return close_socket_and_restart();+  }+  peer_address =+      EventEngine::ResolvedAddress(peer_address.address(), peer_name_len);+  auto addr_uri = ResolvedAddressToURI(peer_address);+  std::string peer_name = ""unknown"";+  if (!addr_uri.ok()) {+    // TODO(hork): test an early exit/restart here with end2end tests+    gpr_log(GPR_ERROR, ""invalid peer name: %s"",+            addr_uri.status().ToString().c_str());+  } else {+    peer_name = *addr_uri;+  }+  auto endpoint = std::make_unique<WindowsEndpoint>(+      peer_address, listener_->iocp_->Watch(io_state_->accept_socket),+      listener_->memory_allocator_factory_->CreateMemoryAllocator(+          absl::StrFormat(""listener endpoint %s"", peer_name)),+      listener_->config_, listener_->executor_);+  listener_->accept_cb_(+      std::move(endpoint),+      listener_->memory_allocator_factory_->CreateMemoryAllocator(+          absl::StrFormat(""listener accept cb for %s"", peer_name)));+  close_socket_and_restart(/*do_close_socket=*/false);+}++WindowsEventEngineListener::SinglePortSocketListener::SinglePortSocketListener(+    WindowsEventEngineListener* listener, LPFN_ACCEPTEX AcceptEx,+    std::unique_ptr<WinSocket> listener_socket, int port,+    EventEngine::ResolvedAddress hostbyname)+    : AcceptEx(AcceptEx),+      listener_(listener),+      io_state_(+          std::make_shared<AsyncIOState>(this, std::move(listener_socket))),+      port_(port),+      listener_sockname_(hostbyname) {+  io_state_->on_accept_cb.Prime(io_state_);+}++absl::StatusOr<WindowsEventEngineListener::SinglePortSocketListener::+                   PrepareListenerSocketResult>+WindowsEventEngineListener::SinglePortSocketListener::PrepareListenerSocket(+    SOCKET sock, const EventEngine::ResolvedAddress& addr) {+  auto fail = [&](absl::Status error) -> absl::Status {+    GPR_ASSERT(!error.ok());+    auto addr_uri = ResolvedAddressToURI(addr);+    error = grpc_error_set_int(+        grpc_error_set_str(+            GRPC_ERROR_CREATE_REFERENCING(""Failed to prepare server socket"",+                                          &error, 1),+            grpc_core::StatusStrProperty::kTargetAddress,+            addr_uri.ok() ? *addr_uri : addr_uri.status().ToString()),+        grpc_core::StatusIntProperty::kFd, static_cast<intptr_t>(sock));+    if (sock != INVALID_SOCKET) closesocket(sock);+    return error;+  };+  auto error = PrepareSocket(sock);+  if (!error.ok()) return fail(error);+  if (bind(sock, addr.address(), addr.size()) == SOCKET_ERROR) {+    return fail(GRPC_WSA_ERROR(WSAGetLastError(), ""bind""));+  }+  if (listen(sock, SOMAXCONN) == SOCKET_ERROR) {+    return fail(GRPC_WSA_ERROR(WSAGetLastError(), ""listen""));+  }+  int sockname_temp_len = sizeof(struct sockaddr_storage);+  EventEngine::ResolvedAddress sockname_temp;+  if (getsockname(sock, const_cast<sockaddr*>(sockname_temp.address()),+                  &sockname_temp_len) == SOCKET_ERROR) {+    return fail(GRPC_WSA_ERROR(WSAGetLastError(), ""getsockname""));+  }+  sockname_temp =+      EventEngine::ResolvedAddress(sockname_temp.address(), sockname_temp_len);+  return PrepareListenerSocketResult{ResolvedAddressGetPort(sockname_temp),+                                     sockname_temp};+}++// ---- WindowsEventEngineListener ----++WindowsEventEngineListener::WindowsEventEngineListener(+    IOCP* iocp, AcceptCallback accept_cb,+    absl::AnyInvocable<void(absl::Status)> on_shutdown,+    std::unique_ptr<MemoryAllocatorFactory> memory_allocator_factory,+    std::shared_ptr<EventEngine> engine, Executor* executor,+    const EndpointConfig& config)+    : iocp_(iocp),+      config_(config),+      engine_(std::move(engine)),+      executor_(executor),+      memory_allocator_factory_(std::move(memory_allocator_factory)),+      accept_cb_(std::move(accept_cb)),+      on_shutdown_(std::move(on_shutdown)) {}++WindowsEventEngineListener::~WindowsEventEngineListener() {+  GRPC_EVENT_ENGINE_TRACE(+      ""%s"",+      absl::StrFormat(""WindowsEventEngineListener::%p shutting down"", this)+          .c_str());+  // Shut down each port listener before destroying this EventEngine::Listener+  for (auto& port_listener : port_listeners_) {+    port_listener.reset();+  }+  on_shutdown_(absl::OkStatus());+}++absl::StatusOr<int> WindowsEventEngineListener::Bind(+    const EventEngine::ResolvedAddress& addr) {+  if (started_.load()) {+    return absl::FailedPreconditionError(+        absl::StrFormat(""WindowsEventEngineListener::%p is already started, ""+                        ""ports can no longer be bound"",+                        this));+  }+  int out_port = ResolvedAddressGetPort(addr);+  EventEngine::ResolvedAddress out_addr(addr);+  EventEngine::ResolvedAddress tmp_addr;+  // Check if this is a  wildcard port, and if so, try to keep the port the same+  // as some previously created listener.+  if (out_port == 0) {+    grpc_core::MutexLock lock(&socket_listeners_mu_);+    for (const auto& port_listener : port_listeners_) {+      tmp_addr = port_listener->listener_sockname();+      out_port = ResolvedAddressGetPort(tmp_addr);+      if (out_port > 0) {+        ResolvedAddressSetPort(out_addr, out_port);+        break;+      }+    }+  }+  if (ResolvedAddressToV4Mapped(out_addr, &tmp_addr)) {+    out_addr = tmp_addr;+  }+  // Treat :: or 0.0.0.0 as a family-agnostic wildcard.+  if (ResolvedAddressIsWildcard(out_addr)) {+    out_addr = ResolvedAddressMakeWild6(out_port);+  }+  // open the socket+  SOCKET sock = WSASocket(AF_INET6, SOCK_STREAM, IPPROTO_TCP, nullptr, 0,+                          IOCP::GetDefaultSocketFlags());+  if (sock == INVALID_SOCKET) {+    auto error = GRPC_WSA_ERROR(WSAGetLastError(), ""WSASocket"");+    return GRPC_ERROR_CREATE_REFERENCING(""Failed to add port to server"", &error,+                                         1);+  }+  auto port_listener = AddSinglePortSocketListener(sock, out_addr);+  GRPC_RETURN_IF_ERROR(port_listener.status());+  return (*port_listener)->port();+}++absl::Status WindowsEventEngineListener::Start() {+  GPR_ASSERT(!started_.exchange(true));+  grpc_core::MutexLock lock(&socket_listeners_mu_);+  for (auto& port_listener : port_listeners_) {+    GRPC_RETURN_IF_ERROR(port_listener->Start());+  }+  return absl::OkStatus();+}++absl::StatusOr<WindowsEventEngineListener::SinglePortSocketListener*>+WindowsEventEngineListener::AddSinglePortSocketListener(+    SOCKET sock, EventEngine::ResolvedAddress addr) {+  auto single_port_listener =+      SinglePortSocketListener::Create(this, sock, addr);+  GRPC_RETURN_IF_ERROR(single_port_listener.status());+  auto* single_port_listener_ptr = single_port_listener->get();+  grpc_core::MutexLock lock(&socket_listeners_mu_);+  port_listeners_.emplace_back(std::move(*single_port_listener));","That is true, good catch, I hadn't noticed. The iomgr server implementation was subject to this race as well. Rather than take another mutex lock here, I opted to check again if the Listener is started after the SPL is created, then log an error about invalid usage and start the SPL if `Listener::Start` had been called concurrently.I think there's a similar race on `Bind` and Listener destruction, I'm debating with myself whether it's worth adding a `shutdown_` flag just to check for it, I feel it will be exceedingly rare. What do you think?",
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/32488,1120987568,2023-03-01T00:58:20Z,src/core/lib/event_engine/windows/windows_listener.cc,"@@ -0,0 +1,364 @@+// Copyright 2023 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+#include <grpc/support/port_platform.h>++#ifdef GPR_WINDOWS++#include ""absl/status/status.h""+#include ""absl/strings/str_format.h""++#include ""src/core/lib/event_engine/tcp_socket_utils.h""+#include ""src/core/lib/event_engine/trace.h""+#include ""src/core/lib/event_engine/windows/iocp.h""+#include ""src/core/lib/event_engine/windows/win_socket.h""+#include ""src/core/lib/event_engine/windows/windows_endpoint.h""+#include ""src/core/lib/event_engine/windows/windows_listener.h""+#include ""src/core/lib/gprpp/crash.h""+#include ""src/core/lib/gprpp/sync.h""+#include ""src/core/lib/iomgr/error.h""++namespace grpc_event_engine {+namespace experimental {++// ---- SinglePortSocketListener::AsyncIOState ----++WindowsEventEngineListener::SinglePortSocketListener::AsyncIOState::+    AsyncIOState(SinglePortSocketListener* port_listener,+                 std::unique_ptr<WinSocket> listener_socket)+    : port_listener(port_listener),+      listener_socket(std::move(listener_socket)) {}++WindowsEventEngineListener::SinglePortSocketListener::AsyncIOState::+    ~AsyncIOState() {+  closesocket(accept_socket);+}++void WindowsEventEngineListener::SinglePortSocketListener::+    OnAcceptCallbackWrapper::Run() {+  GPR_ASSERT(io_state_ != nullptr);+  grpc_core::ReleasableMutexLock lock(&io_state_->mu);+  if (io_state_->listener_socket->IsShutdown()) {+    GRPC_EVENT_ENGINE_TRACE(+        ""SinglePortSocketListener::%p listener socket is shut down. Shutting ""+        ""down listener."",+        io_state_->port_listener);+    lock.Release();+    io_state_.reset();+    return;+  }+  io_state_->port_listener->OnAcceptCallbackLocked();+}++void WindowsEventEngineListener::SinglePortSocketListener::+    OnAcceptCallbackWrapper::Prime(std::shared_ptr<AsyncIOState> io_state) {+  io_state_ = std::move(io_state);+}++// ---- SinglePortSocketListener ----++WindowsEventEngineListener::SinglePortSocketListener::+    ~SinglePortSocketListener() {+  io_state_->listener_socket->Shutdown(DEBUG_LOCATION,+                                       ""~SinglePortSocketListener"");+  GRPC_EVENT_ENGINE_TRACE(""~SinglePortSocketListener::%p"", this);+}++absl::StatusOr<+    std::unique_ptr<WindowsEventEngineListener::SinglePortSocketListener>>+WindowsEventEngineListener::SinglePortSocketListener::Create(+    WindowsEventEngineListener* listener, SOCKET sock,+    EventEngine::ResolvedAddress addr) {+  // We need to grab the AcceptEx pointer for that port, as it may be+  // interface-dependent. We'll cache it to avoid doing that again.+  GUID guid = WSAID_ACCEPTEX;+  DWORD ioctl_num_bytes;+  LPFN_ACCEPTEX AcceptEx;+  int status =+      WSAIoctl(sock, SIO_GET_EXTENSION_FUNCTION_POINTER, &guid, sizeof(guid),+               &AcceptEx, sizeof(AcceptEx), &ioctl_num_bytes, NULL, NULL);+  if (status != 0) {+    auto error = GRPC_WSA_ERROR(WSAGetLastError(), ""WSASocket"");+    closesocket(sock);+    return error;+  }+  auto result = SinglePortSocketListener::PrepareListenerSocket(sock, addr);+  GRPC_RETURN_IF_ERROR(result.status());+  GPR_ASSERT(result->port >= 0);+  // Using `new` to access non-public constructor+  return absl::WrapUnique(new SinglePortSocketListener(+      listener, AcceptEx, /*win_socket=*/listener->iocp_->Watch(sock),+      result->port, result->hostbyname));+}++absl::Status WindowsEventEngineListener::SinglePortSocketListener::Start() {+  grpc_core::MutexLock lock(&io_state_->mu);+  return StartLocked();+}++absl::Status+WindowsEventEngineListener::SinglePortSocketListener::StartLocked() {+  SOCKET accept_socket = WSASocket(AF_INET6, SOCK_STREAM, IPPROTO_TCP, NULL, 0,+                                   IOCP::GetDefaultSocketFlags());+  if (accept_socket == INVALID_SOCKET) {+    return GRPC_WSA_ERROR(WSAGetLastError(), ""WSASocket"");+  }+  auto fail = [&](absl::Status error) -> absl::Status {+    if (accept_socket != INVALID_SOCKET) closesocket(accept_socket);+    return error;+  };+  auto error = PrepareSocket(accept_socket);+  if (!error.ok()) return fail(error);+  // Start the ""accept"" asynchronously.+  DWORD addrlen = sizeof(sockaddr_in6) + 16;+  DWORD bytes_received = 0;+  int success =+      AcceptEx(io_state_->listener_socket->raw_socket(), accept_socket,+               addresses_, 0, addrlen, addrlen, &bytes_received,+               io_state_->listener_socket->read_info()->overlapped());+  // It is possible to get an accept immediately without delay. However, we+  // will still get an IOCP notification for it. So let's just ignore it.+  if (success != 0) {+    int last_error = WSAGetLastError();+    if (last_error != ERROR_IO_PENDING) {+      return fail(GRPC_WSA_ERROR(last_error, ""AcceptEx""));+    }+  }+  // We're ready to do the accept. Calling NotifyOnRead may immediately process+  // an accept that happened in the meantime.+  io_state_->accept_socket = accept_socket;+  io_state_->listener_socket->NotifyOnRead(&io_state_->on_accept_cb);+  GRPC_EVENT_ENGINE_TRACE(+      ""SinglePortSocketListener::%p listening. listener_socket::%p"", this,+      io_state_->listener_socket.get());+  return absl::OkStatus();+}++void WindowsEventEngineListener::SinglePortSocketListener::+    OnAcceptCallbackLocked() {+  auto close_socket_and_restart =+      [&](bool do_close_socket = true)+          ABSL_EXCLUSIVE_LOCKS_REQUIRED(io_state_->mu) {+            if (do_close_socket) closesocket(io_state_->accept_socket);+            GPR_ASSERT(GRPC_LOG_IF_ERROR(""SinglePortSocketListener::Start"",+                                         StartLocked()));+          };+  const auto& overlapped_result =+      io_state_->listener_socket->read_info()->result();+  if (overlapped_result.wsa_error != 0) {+    gpr_log(GPR_ERROR, ""%s"",+            GRPC_WSA_ERROR(overlapped_result.wsa_error,+                           ""Skipping on_accept due to error"")+                .ToString()+                .c_str());+    return close_socket_and_restart();+  }+  SOCKET tmp_listener_socket = io_state_->listener_socket->raw_socket();+  int err =+      setsockopt(io_state_->accept_socket, SOL_SOCKET, SO_UPDATE_ACCEPT_CONTEXT,+                 reinterpret_cast<char*>(&tmp_listener_socket),+                 sizeof(tmp_listener_socket));+  if (err != 0) {+    gpr_log(GPR_ERROR, ""%s"",+            GRPC_WSA_ERROR(WSAGetLastError(), ""setsockopt"").ToString().c_str());+    return close_socket_and_restart();+  }+  EventEngine::ResolvedAddress peer_address;+  int peer_name_len = EventEngine::ResolvedAddress::MAX_SIZE_BYTES;+  err = getpeername(io_state_->accept_socket,+                    const_cast<sockaddr*>(peer_address.address()),+                    &peer_name_len);+  if (err != 0) {+    gpr_log(+        GPR_ERROR, ""%s"",+        GRPC_WSA_ERROR(WSAGetLastError(), ""getpeername"").ToString().c_str());+    return close_socket_and_restart();+  }+  peer_address =+      EventEngine::ResolvedAddress(peer_address.address(), peer_name_len);+  auto addr_uri = ResolvedAddressToURI(peer_address);+  std::string peer_name = ""unknown"";+  if (!addr_uri.ok()) {+    // TODO(hork): test an early exit/restart here with end2end tests+    gpr_log(GPR_ERROR, ""invalid peer name: %s"",+            addr_uri.status().ToString().c_str());+  } else {+    peer_name = *addr_uri;+  }+  auto endpoint = std::make_unique<WindowsEndpoint>(+      peer_address, listener_->iocp_->Watch(io_state_->accept_socket),","Sure, done. I'm not sure the race is possible, maybe an in-use `accept_socket` could get closed inadvertently if the listener and its SPLs are shut down between handing the accept_socket off to the endpoint, before StartLocked is called. Even if that's not possible now, I'm fine with the added caution and future-proofing.",
1255371,rock1246,https://api.github.com/repos/grpc/grpc/pulls/32438,1121257041,2023-03-01T07:18:37Z,src/core/ext/transport/binder/wire_format/wire_reader_impl.cc,"@@ -380,8 +392,12 @@ absl::Status WireReaderImpl::ProcessStreamingTransactionImpl(                                                 ""binder.authority"");       }     }-    transport_stream_receiver_->NotifyRecvInitialMetadata(-        code, *initial_metadata_or_error);+    deferred_func_queue.emplace([this, code,+                                 initial_metadata_or_error = std::move(+                                     initial_metadata_or_error)]() mutable {","Yes. We need the `mutable` here. If there is no `mutable`, `initial_metadata_or_error` will be const and NOT movable to the next function call.",
57042389,tonydnewell,https://api.github.com/repos/grpc/grpc/pulls/32311,1121897051,2023-03-01T15:15:36Z,src/csharp/Grpc.Tools.Tests/MsBuildIntegrationTest.cs,"@@ -126,6 +126,61 @@ public void TestProtoOutsideProject()             TryRunMsBuild(""TestProtoOutsideProject/project"", expectedFiles.ToString());         } +        [Test]+        public void TestCharactersInName()+        {+            // see https://github.com/grpc/grpc/issues/17661 - dot in name+            // and https://github.com/grpc/grpc/issues/18698 - numbers in name+            SetUpForTest(nameof(TestCharactersInName));++            var expectedFiles = new ExpectedFilesBuilder();+            expectedFiles.Add(""protos/hello.world.proto"", ""HelloWorld.cs"", ""Hello.worldGrpc.cs"");+            expectedFiles.Add(""protos/m_double_2d.proto"", ""MDouble2D.cs"", ""MDouble2dGrpc.cs"");++            TryRunMsBuild(""TestCharactersInName"", expectedFiles.ToString());+        }++        [Test]+        public void TestExtraOptions()+        {+            // Test various extra options passed to protoc and plugin+            // See https://github.com/grpc/grpc/issues/25950+            // Tests setting AdditionalProtocArguments, OutputOptions and GrpcOutputOptions+            SetUpForTest(nameof(TestExtraOptions));++            var expectedFiles = new ExpectedFilesBuilder();+            expectedFiles.Add(""file.proto"", ""File.cs"", ""FileGrpc.cs"");++            TryRunMsBuild(""TestExtraOptions"", expectedFiles.ToString());+        }++        [Test]+        public void TestGrpcServices()",Changed to TestGrpcServicesMetadata as it is the GrpcServices metadata on the Protobuf item that is being tested. Not sure if there is a better name.,
5663878,yijiem,https://api.github.com/repos/grpc/grpc/pulls/31942,1122140636,2023-03-01T18:16:39Z,src/core/ext/transport/chttp2/server/chttp2_server.cc,"@@ -407,29 +410,33 @@ void Chttp2ServerListener::ActiveConnection::HandshakingState::Start(                              OnHandshakeDone, this); } -void Chttp2ServerListener::ActiveConnection::HandshakingState::OnTimeout(-    void* arg, grpc_error_handle error) {-  HandshakingState* self = static_cast<HandshakingState*>(arg);-  // Note that we may be called with absl::OkStatus() when the timer fires-  // or with an error indicating that the timer system is being shut down.-  if (error != absl::CancelledError()) {+void Chttp2ServerListener::ActiveConnection::HandshakingState::OnTimeout() {+  grpc_chttp2_transport* transport = nullptr;+  {+    MutexLock lock(&connection_->mu_);+    if (timer_handle_.has_value()) {+      transport = connection_->transport_;+      timer_handle_.reset();+    }+  }+  if (transport) {","Totally, implicit boolean conversion is bad.",X
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/31942,1122406807,2023-03-01T23:10:16Z,src/core/ext/transport/chttp2/server/chttp2_server.cc,"@@ -579,20 +590,18 @@ void Chttp2ServerListener::ActiveConnection::SendGoAway() {     MutexLock lock(&mu_);     if (transport_ != nullptr && !shutdown_) {       transport = transport_;-      Ref().release();  // Ref held by OnDrainGraceTimeExpiry-      GRPC_CLOSURE_INIT(&on_drain_grace_time_expiry_, OnDrainGraceTimeExpiry,-                        this, nullptr);-      grpc_timer_init(-          &drain_grace_timer_,-          Timestamp::Now() +-              std::max(-                  Duration::Zero(),-                  listener_->args_-                      .GetDurationFromIntMillis(-                          GRPC_ARG_SERVER_CONFIG_CHANGE_DRAIN_GRACE_TIME_MS)-                      .value_or(Duration::Minutes(10))),-          &on_drain_grace_time_expiry_);-      drain_grace_timer_expiry_callback_pending_ = true;+      drain_grace_timer_handle_ = event_engine_->RunAfter(+          std::max(Duration::Zero(),+                   listener_->args_+                       .GetDurationFromIntMillis(+                           GRPC_ARG_SERVER_CONFIG_CHANGE_DRAIN_GRACE_TIME_MS)+                       .value_or(Duration::Minutes(10))),+          [self = Ref(DEBUG_LOCATION, ""drain_grace_timer"")]() mutable {+            ApplicationCallbackExecCtx callback_exec_ctx;","_Need_ is a string word, but yes, the policy is that all callbacks must create both ExecCtx types locally at the moment. Debugging missing ExecCtxs in EventEngine callbacks has been complicated, and it will be trivially easy to remove them all once we've migrate away from `ExecCtx::Run` (a long-term thing).",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/32514,1122447416,2023-03-02T00:02:46Z,src/core/lib/promise/poll.h,"@@ -43,17 +47,97 @@ struct Empty { // Can be either pending - the Promise has not yet completed, or ready - // indicating that the Promise has completed AND should not be polled again. template <typename T>-using Poll = absl::variant<Pending, T>;+class Poll {+ public:+  // NOLINTNEXTLINE(google-explicit-constructor)+  Poll(Pending) : ready_(false) {}+  Poll() : ready_(false) {}+  Poll(const Poll& other) : ready_(other.ready_) {+    if (ready_) Construct(&value_, other.value_);+  }+  Poll(Poll&& other) noexcept : ready_(other.ready_) {+    if (ready_) Construct(&value_, std::move(other.value_));+  }+  Poll& operator=(const Poll& other) {+    if (ready_) {+      if (other.ready_) {+        value_ = other.value_;+      } else {+        Destruct(&value_);+        ready_ = false;+      }+    } else if (other.ready_) {+      Construct(&value_, other.value_);+      ready_ = true;+    }+    return *this;+  }+  Poll& operator=(Poll&& other) noexcept {+    if (ready_) {+      if (other.ready_) {+        value_ = std::move(other.value_);+      } else {+        Destruct(&value_);+        ready_ = false;+      }+    } else if (other.ready_) {+      Construct(&value_, std::move(other.value_));+      ready_ = true;+    }+    return *this;+  }+  template <typename U>+  // NOLINTNEXTLINE(google-explicit-constructor)+  Poll(U value) : ready_(true) {+    Construct(&value_, std::move(value));+  }+  ~Poll() {+    if (ready_) Destruct(&value_);+  }++  bool pending() const { return !ready_; }+  bool ready() const { return ready_; }++  T& value() {+    GPR_DEBUG_ASSERT(ready());+    return value_;+  }++  const T& value() const {+    GPR_DEBUG_ASSERT(ready());+    return value_;+  }++  T* value_if_ready() {+    if (ready()) return &value_;+    return nullptr;+  }++  const T* value_if_ready() const {+    if (ready()) return &value_;+    return nullptr;+  }++ private:+  bool ready_;+  union {+    T value_;","I did optional<> to start this... but you're not allowed to write `optional<nullopt_t>` and via convoluted means we end up needing `Poll<nullopt_t>`.`union` here allows lazy construction whilst getting alignment and whatnot right, and avoiding some of the traps that come with ManualConstructor.",
5663878,yijiem,https://api.github.com/repos/grpc/grpc/pulls/31942,1122479624,2023-03-02T00:39:25Z,src/core/ext/transport/chttp2/server/chttp2_server.cc,"@@ -206,10 +208,9 @@ class Chttp2ServerListener : public Server::ListenerInterface {     // is created.     grpc_chttp2_transport* transport_ ABSL_GUARDED_BY(&mu_) = nullptr;     grpc_closure on_close_;-    grpc_timer drain_grace_timer_;-    grpc_closure on_drain_grace_time_expiry_;-    bool drain_grace_timer_expiry_callback_pending_ ABSL_GUARDED_BY(&mu_) =-        false;+    absl::optional<EventEngine::TaskHandle> drain_grace_timer_handle_+        ABSL_GUARDED_BY(&mu_);+    EventEngine* event_engine_ ABSL_GUARDED_BY(&mu_);",Good callout! This event_engine_ is grabbed from a copy of the listener_'s ChannelArgs. And it also held a `RefCounterPtr<Chttp2ServerListener> listener_;` at line 202. Added a comment to clarify that.,
4181124,yashykt,https://api.github.com/repos/grpc/grpc/pulls/31942,1122483157,2023-03-02T00:45:56Z,src/core/ext/transport/chttp2/server/chttp2_server.cc,"@@ -206,10 +208,9 @@ class Chttp2ServerListener : public Server::ListenerInterface {     // is created.     grpc_chttp2_transport* transport_ ABSL_GUARDED_BY(&mu_) = nullptr;     grpc_closure on_close_;-    grpc_timer drain_grace_timer_;-    grpc_closure on_drain_grace_time_expiry_;-    bool drain_grace_timer_expiry_callback_pending_ ABSL_GUARDED_BY(&mu_) =-        false;+    absl::optional<EventEngine::TaskHandle> drain_grace_timer_handle_+        ABSL_GUARDED_BY(&mu_);+    EventEngine* event_engine_ ABSL_GUARDED_BY(&mu_);","Slightly incorrect. We make a copy of the listener args, modify it and then pass it to `ActiveConnection`. I would suggest getting the pointer from the channel args in the listener and then explicitly pass the EventEngine pointer as a parameter to the constructor of ActiveConnection.",
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/32077,1122570647,2023-03-02T03:50:38Z,src/core/BUILD,"@@ -2057,16 +2057,31 @@ grpc_cc_library(  grpc_cc_library(     name = ""cf_event_engine"",-    srcs = [""lib/event_engine/cf_engine/cf_engine.cc""],-    hdrs = [""lib/event_engine/cf_engine/cf_engine.h""],+    srcs = [+        ""lib/event_engine/cf_engine/cf_engine.cc"",+        ""lib/event_engine/cf_engine/cfstream_endpoint.cc"",+    ],+    hdrs = [+        ""lib/event_engine/cf_engine/cf_engine.h"",+        ""lib/event_engine/cf_engine/cfstream_endpoint.h"",+        ""lib/event_engine/cf_engine/cftype_unique_ref.h"",+    ],+    defines = [""GRPC_CFSTREAM=1""],","Is this necessary? `port_platform.h` should set this automatically for the right platforms. And further, we would have to be careful to ensure that no general target accidentally depends on `cf_event_engine` (even if it's unused), because the defines here will propagate to every rule that depends on it ... on every platform. https://bazel.build/reference/be/c-cpp#cc_binary.defines",
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/32492,1122758835,2023-03-02T08:41:33Z,setup.py,"@@ -375,7 +375,9 @@ def _quote_build_define(argument):     elif LINUX_AARCH64 == boringssl_asm_platform:         asm_key = 'crypto_linux_aarch64'     elif ""mac"" in boringssl_asm_platform and ""x86_64"" in boringssl_asm_platform:-        asm_key = 'crypto_mac_x86_64'+        asm_key = 'crypto_apple_x86_64'+    elif ""mac"" in boringssl_asm_platform and ""arm64"" in boringssl_asm_platform:","AFAIK we don't publish python wheels for M1 Macs currently, so it sounds like this is being proactive.Anyway, the entire section that select the asm_key can be simplified as a followup (since we the asm files are `#ifdef` conditioned to only kick in on the right platform, it's no longer important so select only the asm files that exactly match the target platforms, we can simply determine whether we want the asm optimizations or not, set OPENSSL_NO_ASM accordingly and include all gcc-style asm files in the build).Since likely want the followup simplification, it's fine to leave this change as is.",
9566254,apolcyn,https://api.github.com/repos/grpc/grpc/pulls/32204,1123721400,2023-03-02T21:23:42Z,src/core/lib/event_engine/posix_engine/tcp_socket_utils.cc,"@@ -96,8 +97,20 @@ absl::Status ErrorForFd(  int CreateSocket(std::function<int(int, int, int)> socket_factory, int family,                  int type, int protocol) {-  return socket_factory != nullptr ? socket_factory(family, type, protocol)-                                   : socket(family, type, protocol);+  int res = socket_factory != nullptr ? socket_factory(family, type, protocol)+                                      : socket(family, type, protocol);+  if (res < 0 && errno == EMFILE) {+    int saved_errno = errno;+    GRPC_LOG_EVERY_N_SEC(+        10, GPR_ERROR,+        ""socket(%d, %d, %d) returned %d with error: |%s|. This process ""+        ""might not have a sufficient file descriptor limit for the number ""+        ""of connections we want to open (which is a function of the LB policy, ""","Changed this - what do you think about 3rd person ""gRPC wants to open"", to scope it to the gRPC library",
9566254,apolcyn,https://api.github.com/repos/grpc/grpc/pulls/32204,1123781759,2023-03-02T22:12:04Z,src/core/lib/event_engine/posix_engine/tcp_socket_utils.cc,"@@ -96,8 +97,20 @@ absl::Status ErrorForFd(  int CreateSocket(std::function<int(int, int, int)> socket_factory, int family,                  int type, int protocol) {-  return socket_factory != nullptr ? socket_factory(family, type, protocol)-                                   : socket(family, type, protocol);+  int res = socket_factory != nullptr ? socket_factory(family, type, protocol)+                                      : socket(family, type, protocol);+  if (res < 0 && errno == EMFILE) {+    int saved_errno = errno;+    GRPC_LOG_EVERY_N_SEC(+        10, GPR_ERROR,+        ""socket(%d, %d, %d) returned %d with error: |%s|. This process ""+        ""might not have a sufficient file descriptor limit for the number ""+        ""of connections we want to open (which is a function of the LB policy, ""","Perhaps it can be tweaked - as long as we're bike-shedding, I'll leave as is :)",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32524,1125151699,2023-03-04T00:02:48Z,test/cpp/interop/interop_client.h,"@@ -39,11 +39,17 @@ typedef std::function<std::shared_ptr<Channel>(void)> ChannelCreationFunc;  class InteropClient {  public:+  using LoadReportsFromLbPolicy =+      std::shared_ptr<std::vector<xds::data::orca::v3::OrcaLoadReport>>;++  static LoadReportsFromLbPolicy InitializeCustomLbPolicy();","Instead of exposing this type and passing it into the ctor, why not just register the LB policy inside the ctor and have the callback directly write to the data member of `InteropClient`, so that it doesn't need to be a `shared_ptr<>`?  Even if you need this behavior to be configurable for the Android client, you can pass in a bool indicating whether to configure the LB policy.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32524,1125155047,2023-03-04T00:09:18Z,test/cpp/interop/interop_server.cc,"@@ -136,6 +139,26 @@ bool CheckExpectedCompression(const ServerContext& context,   return true; } +void RecordMetrics(grpc::experimental::CallMetricRecorder* recorder,+                   const xds::data::orca::v3::OrcaLoadReport& request_metrics) {+  // Do not record when zero since it indicates no test per-call report.+  if (request_metrics.cpu_utilization() > 0) {+    recorder->RecordCpuUtilizationMetric(request_metrics.cpu_utilization());+  }+  if (request_metrics.mem_utilization() > 0) {+    recorder->RecordMemoryUtilizationMetric(request_metrics.mem_utilization());+  }+  if (request_metrics.rps_fractional() > 0) {+    recorder->RecordQpsMetric(request_metrics.rps_fractional());+  }+  for (const auto& p : request_metrics.request_cost()) {+    recorder->RecordRequestCostMetric(p.first.c_str(), p.second);","Are you sure this works correctly?  This is storing `absl::string_view` keys in the `CallMetricRecorder` that point to storage in the request proto, but I don't think that request proto is guaranteed to live until the ORCA metadata is serialized to be sent back to the client, so it seems like this could leave pointers dangling into unsafe memory.In our e2e tests, we deal with this by arena-allocating a copy of these strings:https://github.com/grpc/grpc/blob/c5213ceff9edc723cbf56a5f917083ff4a025bf0/test/cpp/end2end/client_lb_end2end_test.cc#L141",
287917,eugeneo,https://api.github.com/repos/grpc/grpc/pulls/32524,1125163668,2023-03-04T00:27:15Z,test/core/util/test_lb_policies.h,"@@ -62,7 +65,9 @@ using InterceptRecvTrailingMetadataCallback = // invokes cb when trailing metadata is received for each call. void RegisterInterceptRecvTrailingMetadataLoadBalancingPolicy(     CoreConfiguration::Builder* builder,-    InterceptRecvTrailingMetadataCallback cb);+    InterceptRecvTrailingMetadataCallback cb,+    absl::string_view factory_name =+        kInterceptRecvTrailingMetadataLbPolicyName);","This policy is referred by name [here](https://github.com/grpc/grpc/blob/master/doc/interop-test-descriptions.md#orca_per_rpc) - I am assuming this config will be provided from outside. I did entertain a though of changing the default name for the policy, lmk if you'd rather have that.",
287917,eugeneo,https://api.github.com/repos/grpc/grpc/pulls/32524,1125165729,2023-03-04T00:30:28Z,test/cpp/interop/client_helper.cc,"@@ -87,7 +87,12 @@ std::shared_ptr<Channel> CreateChannelForTestCase(     const std::string& test_case,     std::vector<         std::unique_ptr<experimental::ClientInterceptorFactoryInterface>>-        interceptor_creators) {+        interceptor_creators,+    absl::optional<std::string> service_config_json) {","It would require `ABSL_FLAG` in each client, that would make this PR much bigger. Another option would be to have that declaration in `client_helper.cc` which seems to be discouraged.",
972790,akshayjshah,https://api.github.com/repos/grpc/grpc/pulls/32364,1128246100,2023-03-07T17:14:24Z,doc/PROTOCOL-WEB.md,"@@ -48,8 +48,14 @@ Content-Type HTTP wire protocols  1. support any HTTP/*, with no dependency on HTTP/2 specific framing-2. use lower-case header/trailer names","I believe the current language is referring to the block of trailers encoded in the last length-prefixed message in the stream, not HTTP trailers. Those trailers aren't visible to any generic HTTP systems (proxies, middleware, etc.) so I think it's fine to mandate lower-case field names on the wire.I've pushed a commit that's closer to your suggestion. What do you think?",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32359,1128306719,2023-03-07T17:50:08Z,src/core/lib/channel/connected_channel.cc,"@@ -745,95 +563,116 @@ ArenaPromise<ServerMetadataHandle> MakeServerCallPromise(   };   auto* call_data = GetContext<Arena>()->ManagedNew<CallData>(); +  auto server_to_client_empty =+      call_data->server_to_client.receiver.AwaitEmpty();+   // Create a promise that will receive client initial metadata, and then run   // the main stem of the call (calling next_promise_factory up through the   // filters).   // Race the main call with failure_latch, allowing us to forcefully complete   // the call in the case of a failure.-  auto recv_initial_metadata_then_run_promise = TrySeq(-      stream->PushBatchToTransport(-          ""recv_initial_metadata"",-          [](grpc_transport_stream_op_batch* batch, grpc_closure* on_done) {-            auto client_initial_metadata =-                GetContext<Arena>()->MakePooled<ClientMetadata>(-                    GetContext<Arena>());-            batch->recv_initial_metadata = true;-            batch->payload->recv_initial_metadata.recv_initial_metadata =-                client_initial_metadata.get();-            batch->payload->recv_initial_metadata.recv_initial_metadata_ready =-                on_done;-            return client_initial_metadata;-          }),-      [next_promise_factory = std::move(next_promise_factory),-       call_data](ClientMetadataHandle client_initial_metadata) {-        return Race(call_data->failure_latch.Wait(),-                    next_promise_factory(CallArgs{-                        std::move(client_initial_metadata),-                        ClientInitialMetadataOutstandingToken::Empty(),-                        &call_data->server_initial_metadata.sender,-                        &call_data->client_to_server.receiver,-                        &call_data->server_to_client.sender,-                    }));-      });+  auto recv_initial_metadata_then_run_promise =+      TrySeq(GetContext<BatchBuilder>()->ReceiveClientInitialMetadata(+                 stream->batch_target()),+             [next_promise_factory = std::move(next_promise_factory),+              server_to_client_empty = std::move(server_to_client_empty),+              call_data](ClientMetadataHandle client_initial_metadata) {+               auto call_promise = next_promise_factory(CallArgs{+                   std::move(client_initial_metadata),+                   ClientInitialMetadataOutstandingToken::Empty(),+                   &call_data->server_initial_metadata.sender,+                   &call_data->client_to_server.receiver,+                   &call_data->server_to_client.sender,+               });+               return Race(call_data->failure_latch.Wait(),+                           [call_promise = std::move(call_promise),+                            server_to_client_empty =+                                std::move(server_to_client_empty)]() mutable+                           -> Poll<ServerMetadataHandle> {+                             // TODO(ctiller): this is deeply weird and we need+                             // to clean this up.+                             //+                             // The following few lines check to ensure that+                             // there's no message currently pending in the+                             // outgoing message queue, and if (and only if)+                             // that's true decides to poll the main promise to+                             // see if there's a result.+                             //+                             // This essentially introduces a polling priority+                             // scheme that makes the current promise structure+                             // work out the way we want when talking to+                             // transports.+                             //+                             // The problem is that transports are going to need+                             // to replicate this structure when they convert to+                             // promises, and that becomes troubling as we'll be+                             // replicating weird throughout the stack.+                             //+                             // Instead we likely need to change the way we're+                             // composing promises through the stack.+                             //+                             // Proposed is to change filters from a promise+                             // that takes ClientInitialMetadata and returns+                             // ServerTrailingMetadata with three pipes for+                             // ServerInitialMetadata and+                             // ClientToServerMessages, ServerToClientMessages.+                             // Instead we'll have five pipes, moving+                             // ClientInitialMetadata and ServerTrailingMetadata","If server trailing metadata is a pipe, doesn't that eliminate one of the big advantages of the promise stack, which is that the promise always resolves to the call's status?  And doesn't it reintroduce the possibility that client initial metadata is not immediately available when the call starts?",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32524,1128409203,2023-03-07T18:58:25Z,test/cpp/interop/client_helper.cc,"@@ -87,7 +87,12 @@ std::shared_ptr<Channel> CreateChannelForTestCase(     const std::string& test_case,     std::vector<         std::unique_ptr<experimental::ClientInterceptorFactoryInterface>>-        interceptor_creators) {+        interceptor_creators,+    absl::optional<std::string> service_config_json) {","I think it would be okay to have the flag right here in client_helper.cc.  But if you want to stay similar to the existing code, it looks like there are only 3 client files that would need the flag defined, so it doesn't seem like it would add a lot to this PR.  Either way is fine.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32524,1128414006,2023-03-07T19:01:43Z,test/cpp/interop/interop_client.h,"@@ -39,11 +39,17 @@ typedef std::function<std::shared_ptr<Channel>(void)> ChannelCreationFunc;  class InteropClient {  public:+  using LoadReportsFromLbPolicy =+      std::shared_ptr<std::vector<xds::data::orca::v3::OrcaLoadReport>>;++  static LoadReportsFromLbPolicy InitializeCustomLbPolicy();","Thanks, I like this a lot better, since the ugliness is now hidden inside the client code.In the long run, I think we should probably change this LB policy to get the address of the callback from a channel arg instead of it being globally set at LB policy registration time.  But that doesn't need to block this PR.",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/32359,1128974674,2023-03-08T04:52:24Z,src/core/lib/surface/call.cc,"@@ -2244,13 +2297,24 @@ class PromiseBasedCall : public Call,   grpc_call_stats final_stats_{};   CallFinalization finalization_;   // Current deadline.-  Timestamp deadline_ = Timestamp::InfFuture();-  grpc_event_engine::experimental::EventEngine::TaskHandle deadline_task_;+  Mutex deadline_mu_;+  Timestamp deadline_ ABSL_GUARDED_BY(deadline_mu_) = Timestamp::InfFuture();+  grpc_event_engine::experimental::EventEngine::TaskHandle ABSL_GUARDED_BY(+      deadline_mu_) deadline_task_;+  // finished_ & completed_ represent the same state: is the call all done.+  // finished_ is used for the promise returned by finished(), and can be+  // awaited in a promise.+  // completed_ is used for observing this state from outside of the activity+  // (and hence outside the activity provided mutual exclusion).   Latch<void> finished_;",yeah... for a minute it wasn't going to be possible (completed_ was in a base class); fixed,
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32550,1129924758,2023-03-08T19:20:52Z,examples/cpp/helloworld/cocoapods/HelloWorldCpp/ViewController.mm,"@@ -51,32 +51,32 @@ - (void)viewDidLoad {    grpc::ClientContext cli_ctx;   std::unique_ptr<grpc::GenericClientAsyncReaderWriter> call =-      generic_stub_->Call(&cli_ctx, kMethodName, &cq_, tag(1));+      generic_stub_->Call(&cli_ctx, kMethodName, &cq_, grpc_core::CqVerifier::tag(1));","I assume this means we can remove the `tag()` function on line 25 above?Actually, this particular file is example code, not test code -- do we really want this using the `CqVerifier` library?",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32550,1129939907,2023-03-08T19:37:37Z,test/core/end2end/fixtures/secure_fixture.h,"@@ -0,0 +1,91 @@+// Copyright 2023 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++#ifndef GRPC_TEST_CORE_END2END_FIXTURES_SECURE_FIXTURE_H+#define GRPC_TEST_CORE_END2END_FIXTURES_SECURE_FIXTURE_H++#include <string>+#include <utility>++#include <grpc/grpc.h>+#include <grpc/grpc_security.h>+#include <grpc/support/log.h>++#include ""src/core/lib/channel/channel_args.h""+#include ""src/core/lib/gprpp/host_port.h""+#include ""test/core/end2end/end2end_tests.h""+#include ""test/core/util/port.h""++// Base class for a fixture that just needs to select cred types (or mutate+// client/server channel args).+class SecureFixture : public CoreTestFixture {+ public:+  explicit SecureFixture(std::string localaddr = grpc_core::JoinHostPort(+                             ""localhost"", grpc_pick_unused_port_or_die()))+      : localaddr_(std::move(localaddr)) {}++ protected:+  const std::string& localaddr() const { return localaddr_; }++ private:+  virtual grpc_channel_credentials* MakeClientCreds(+      const grpc_core::ChannelArgs& args) = 0;+  virtual grpc_server_credentials* MakeServerCreds(+      const grpc_core::ChannelArgs& args) = 0;+  virtual grpc_core::ChannelArgs MutateClientArgs(grpc_core::ChannelArgs args) {","Would it be useful to move this args-mutation pattern into the base class?  It looks like we're using it in a lot of places, even for the non-secure fixture.",X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32550,1129945035,2023-03-08T19:43:16Z,src/objective-c/tests/CronetTests/CoreCronetEnd2EndTests.mm,"@@ -52,100 +53,44 @@  #import ""../ConfigureCronet.h"" -struct fullstack_secure_fixture_data {-  std::string localaddr;-};--static grpc_end2end_test_fixture chttp2_create_fixture_secure_fullstack(-    const grpc_channel_args *client_args, const grpc_channel_args *server_args) {-  grpc_end2end_test_fixture f;-  int port = grpc_pick_unused_port_or_die();-  fullstack_secure_fixture_data *ffd = new fullstack_secure_fixture_data();-  memset(&f, 0, sizeof(f));--  ffd->localaddr = grpc_core::JoinHostPort(""127.0.0.1"", port);--  f.fixture_data = ffd;-  f.cq = grpc_completion_queue_create_for_next(NULL);--  return f;-}- static void process_auth_failure(void *state, grpc_auth_context *ctx, const grpc_metadata *md,",This function seems to exist in a bunch of places.  Might be a good idea to just move it to some common place to avoid the duplication.,X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32550,1129956441,2023-03-08T19:56:01Z,test/core/end2end/fixtures/h2_http_proxy.cc,"@@ -34,88 +37,67 @@ #include ""test/core/util/port.h"" #include ""test/core/util/test_config.h"" -struct fullstack_fixture_data {-  ~fullstack_fixture_data() { grpc_end2end_http_proxy_destroy(proxy); }-  std::string server_addr;-  grpc_end2end_http_proxy* proxy = nullptr;-};--static grpc_end2end_test_fixture chttp2_create_fixture_fullstack(-    const grpc_channel_args* client_args,-    const grpc_channel_args* /*server_args*/) {-  grpc_end2end_test_fixture f;-  memset(&f, 0, sizeof(f));-  fullstack_fixture_data* ffd = new fullstack_fixture_data();-  const int server_port = grpc_pick_unused_port_or_die();-  ffd->server_addr = grpc_core::JoinHostPort(""localhost"", server_port);--  // Passing client_args to proxy_create for the case of checking for proxy auth-  //-  ffd->proxy = grpc_end2end_http_proxy_create(client_args);--  f.fixture_data = ffd;-  f.cq = grpc_completion_queue_create_for_next(nullptr);--  return f;-}+class HttpProxyFilter : public CoreTestFixture {+ public:+  explicit HttpProxyFilter(const grpc_core::ChannelArgs& client_args)+      : proxy_(grpc_end2end_http_proxy_create(client_args.ToC().get())) {}+  ~HttpProxyFilter() override {+    ShutdownClient();",Don't `ShutdownClient()` and `ShutdownServer()` already get called from the base class dtor?  Or is there an ordering reason why they need to be called here?,
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32550,1129959033,2023-03-08T19:58:53Z,test/core/end2end/fixtures/h2_local_abstract_uds_percent_encoded.cc,"@@ -16,54 +16,41 @@ #include <unistd.h>  #include <atomic>+#include <functional> #include <initializer_list>-#include <string>+#include <memory>  #include ""absl/strings/str_format.h""  #include <grpc/grpc.h> #include <grpc/grpc_security_constants.h> #include <grpc/support/time.h> +#include ""src/core/lib/channel/channel_args.h"" #include ""test/core/end2end/end2end_tests.h"" #include ""test/core/end2end/fixtures/local_util.h"" #include ""test/core/util/test_config.h""  static std::atomic<int> unique{0}; -static grpc_end2end_test_fixture chttp2_create_fixture_fullstack_uds(-    const grpc_channel_args* /*client_args*/,-    const grpc_channel_args* /*server_args*/) {-  grpc_end2end_test_fixture f =-      grpc_end2end_local_chttp2_create_fixture_fullstack();-  gpr_timespec now = gpr_now(GPR_CLOCK_MONOTONIC);-  static_cast<grpc_end2end_local_fullstack_fixture_data*>(f.fixture_data)-      ->localaddr = absl::StrFormat(-      ""unix-abstract:grpc_fullstack_test.%%00.%d.%"" PRId64 "".%"" PRId32 "".%d"",-      getpid(), now.tv_sec, now.tv_nsec, ++unique);-  return f;-}--static void chttp2_init_client_fullstack_uds(-    grpc_end2end_test_fixture* f, const grpc_channel_args* client_args) {-  grpc_end2end_local_chttp2_init_client_fullstack(f, client_args, UDS);-}--static void chttp2_init_server_fullstack_uds(-    grpc_end2end_test_fixture* f, const grpc_channel_args* client_args) {-  grpc_end2end_local_chttp2_init_server_fullstack(f, client_args, UDS);-}- // All test configurations-static grpc_end2end_test_config configs[] = {+static CoreTestConfiguration configs[] = {     {""chttp2/fullstack_local_abstract_uds_percent_encoded"",      FEATURE_MASK_SUPPORTS_DELAYED_CONNECTION |          FEATURE_MASK_SUPPORTS_CLIENT_CHANNEL |          FEATURE_MASK_SUPPORTS_AUTHORITY_HEADER |          FEATURE_MASK_SUPPORTS_PER_CALL_CREDENTIALS,-     nullptr, chttp2_create_fixture_fullstack_uds,-     chttp2_init_client_fullstack_uds, chttp2_init_server_fullstack_uds,-     grpc_end2end_local_chttp2_tear_down_fullstack}};+     nullptr,+     [](const grpc_core::ChannelArgs& /*client_args*/,+        const grpc_core::ChannelArgs& /*server_args*/) {+       gpr_timespec now = gpr_now(GPR_CLOCK_MONOTONIC);+       return std::make_unique<LocalTestFixture>(+           absl::StrFormat(""unix-abstract:grpc_fullstack_test.%%00.%d.%"" PRId64","Not directly related to this PR, but it seems like it doesn't really buy us anything to run the whole set of tests against this fixture.  Maybe this should be a standalone test instead, similar to `h2_ssl_cert_test`?",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/32550,1130072060,2023-03-08T21:52:49Z,examples/cpp/helloworld/cocoapods/HelloWorldCpp/ViewController.mm,"@@ -51,32 +51,32 @@ - (void)viewDidLoad {    grpc::ClientContext cli_ctx;   std::unique_ptr<grpc::GenericClientAsyncReaderWriter> call =-      generic_stub_->Call(&cli_ctx, kMethodName, &cq_, tag(1));+      generic_stub_->Call(&cli_ctx, kMethodName, &cq_, grpc_core::CqVerifier::tag(1));","Yeah we don't want CqVerifier showing up there. Not clear to me we want to be encouraging this pattern in real code either (it's been great for readability of tests with cq though...), but discussion for a different day.",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/32550,1130073446,2023-03-08T21:53:36Z,test/core/end2end/BUILD,"@@ -200,22 +228,6 @@ grpc_cc_test(     ], ) -grpc_cc_test(-    name = ""inproc_callback_test"",","It's using the same fixtures as the rest of the suites, but not with the same cq stuff so ends up very incompatible. It's either rewrite the thing or delete it, and the incremental coverage it gives us over the C++ tests is not large.",
1644595,gnossen,https://api.github.com/repos/grpc/grpc/pulls/32583,1131436665,2023-03-09T18:28:21Z,tools/distrib/python/make_grpcio_tools.py,"@@ -125,8 +127,8 @@ def get_deps():     ]     commit_hash = protobuf_submodule_commit_hash()     deps_file_content = DEPS_FILE_CONTENT.format(-        cc_files=cc_files,-        proto_files=proto_files,+        cc_files=json.dumps(sorted(cc_files), indent=4),","Nit: [`pprint`](https://docs.python.org/3/library/pprint.html) is guaranteed to produce valid Python. This should be okay for lists, but if there's a bug before this, the error could be a bit confusing.",
287917,eugeneo,https://api.github.com/repos/grpc/grpc/pulls/32524,1131503430,2023-03-09T19:32:53Z,test/cpp/interop/client_helper.cc,"@@ -87,7 +87,12 @@ std::shared_ptr<Channel> CreateChannelForTestCase(     const std::string& test_case,     std::vector<         std::unique_ptr<experimental::ClientInterceptorFactoryInterface>>-        interceptor_creators) {+        interceptor_creators,+    absl::optional<std::string> service_config_json) {",No longer needed. Clients need to configure all args.,X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32524,1131525029,2023-03-09T19:55:28Z,test/cpp/interop/backend_metrics_lb_policy.h,"@@ -0,0 +1,54 @@+//+//+// Copyright 2023 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+//+//++#ifndef GRPC_TEST_CPP_INTEROP_BACKEND_METRICS_LB_POLICY_H+#define GRPC_TEST_CPP_INTEROP_BACKEND_METRICS_LB_POLICY_H++#include <grpc/support/port_platform.h>++#include <grpcpp/support/channel_arguments.h>++#include ""src/core/lib/config/core_configuration.h""+#include ""src/proto/grpc/testing/xds/v3/orca_load_report.pb.h""++namespace grpc {+namespace testing {+class OrcaMetricsProcessor {};++class LoadReportTracker {+ public:+  void SetupOnChannel(ChannelArguments* arguments);+  void RecordPerRpcLoadReport(+      const grpc_core::BackendMetricData* backend_metric_data);++  void ClearPerRpcLoadReports() { per_rpc_load_reports_.clear(); }++  void AssertHasSinglePerRpcLoadReport(","Suggest replacing this with a method to just get the most recent entry from the queue.  That way, there's a clean separation between the mechanism to get the data from the LB policy and the logic that checks that we see the expected value.",X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32524,1131536416,2023-03-09T20:08:13Z,test/cpp/interop/backend_metrics_lb_policy.cc,"@@ -0,0 +1,240 @@+//+//+// Copyright 2023 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+//+//++#include <grpc/support/port_platform.h>++#include ""test/cpp/interop/backend_metrics_lb_policy.h""++#include ""google/protobuf/util/message_differencer.h""++#include ""src/core/lib/iomgr/pollset_set.h""++namespace grpc {+namespace testing {++namespace {++using grpc_core::CoreConfiguration;+using grpc_core::LoadBalancingPolicy;+using grpc_core::MakeRefCounted;+using grpc_core::OrphanablePtr;+using grpc_core::RefCountedPtr;++constexpr absl::string_view kBackendMetricsLbPolicyName =+    ""test_backend_metrics_load_balancer"";++const std::string kMetricsTrackerAttribute = ""orca_metrics_tracker"";++absl::optional<xds::data::orca::v3::OrcaLoadReport>+BackendMetricDataToOrcaLoadReport(+    const grpc_core::BackendMetricData* backend_metric_data) {+  if (backend_metric_data == nullptr) {+    return absl::nullopt;+  }+  xds::data::orca::v3::OrcaLoadReport load_report;+  load_report.set_cpu_utilization(backend_metric_data->cpu_utilization);+  load_report.set_mem_utilization(backend_metric_data->mem_utilization);+  load_report.set_rps_fractional(backend_metric_data->qps);+  for (const auto& p : backend_metric_data->request_cost) {+    std::string name(p.first);+    (*load_report.mutable_request_cost())[name] = p.second;+  }+  for (const auto& p : backend_metric_data->utilization) {+    std::string name(p.first);+    (*load_report.mutable_utilization())[name] = p.second;+  }+  return load_report;+}++class BackendMetricsLbPolicy : public LoadBalancingPolicy {+ public:+  explicit BackendMetricsLbPolicy(Args args)+      : LoadBalancingPolicy(std::move(args), /*initial_refcount=*/2) {+    Args delegate_args;+    delegate_args.work_serializer = work_serializer();+    delegate_args.args = channel_args();+    delegate_args.channel_control_helper =+        std::make_unique<Helper>(RefCountedPtr<BackendMetricsLbPolicy>(this));+    load_report_tracker_ = delegate_args.args.GetPointer<LoadReportTracker>(+        kMetricsTrackerAttribute);+    delegate_ =+        CoreConfiguration::Get().lb_policy_registry().CreateLoadBalancingPolicy(+            ""pick_first"", std::move(delegate_args));+    grpc_pollset_set_add_pollset_set(delegate_->interested_parties(),+                                     interested_parties());+  }++  ~BackendMetricsLbPolicy() override = default;++  absl::string_view name() const override {+    return kBackendMetricsLbPolicyName;+  }++  absl::Status UpdateLocked(UpdateArgs args) override {+    return delegate_->UpdateLocked(std::move(args));+  }++  void ExitIdleLocked() override { delegate_->ExitIdleLocked(); }++  void ResetBackoffLocked() override { delegate_->ResetBackoffLocked(); }++ private:+  class Picker : public SubchannelPicker {+   public:+    Picker(RefCountedPtr<SubchannelPicker> delegate_picker,+           LoadReportTracker* load_report_tracker)+        : delegate_picker_(std::move(delegate_picker)),+          load_report_tracker_(load_report_tracker) {}++    PickResult Pick(PickArgs args) override {+      // Do pick.+      PickResult result = delegate_picker_->Pick(args);+      // Intercept trailing metadata.+      auto* complete_pick = absl::get_if<PickResult::Complete>(&result.result);+      if (complete_pick != nullptr) {+        complete_pick->subchannel_call_tracker =+            std::make_unique<SubchannelCallTracker>(load_report_tracker_);+      }+      return result;+    }++   private:+    RefCountedPtr<SubchannelPicker> delegate_picker_;+    LoadReportTracker* load_report_tracker_;+  };++  class Helper : public ChannelControlHelper {+   public:+    explicit Helper(RefCountedPtr<BackendMetricsLbPolicy> parent)+        : parent_(std::move(parent)) {}++    RefCountedPtr<grpc_core::SubchannelInterface> CreateSubchannel(+        grpc_core::ServerAddress address,+        const grpc_core::ChannelArgs& args) override {+      return parent_->channel_control_helper()->CreateSubchannel(+          std::move(address), args);+    }++    void UpdateState(grpc_connectivity_state state, const absl::Status& status,+                     RefCountedPtr<SubchannelPicker> picker) override {+      parent_->channel_control_helper()->UpdateState(+          state, status,+          MakeRefCounted<Picker>(std::move(picker),+                                 parent_->load_report_tracker_));+    }++    void RequestReresolution() override {+      parent_->channel_control_helper()->RequestReresolution();+    }++    absl::string_view GetAuthority() override {+      return parent_->channel_control_helper()->GetAuthority();+    }++    grpc_event_engine::experimental::EventEngine* GetEventEngine() override {+      return parent_->channel_control_helper()->GetEventEngine();+    }++    void AddTraceEvent(TraceSeverity severity,+                       absl::string_view message) override {+      parent_->channel_control_helper()->AddTraceEvent(severity, message);+    }++   private:+    RefCountedPtr<BackendMetricsLbPolicy> parent_;+  };++  class SubchannelCallTracker : public SubchannelCallTrackerInterface {+   public:+    explicit SubchannelCallTracker(LoadReportTracker* load_report_tracker)+        : load_report_tracker_(load_report_tracker) {}++    void Start() override {}++    void Finish(FinishArgs args) override {+      load_report_tracker_->RecordPerRpcLoadReport(+          args.backend_metric_accessor->GetBackendMetricData());+    }++   private:+    LoadReportTracker* load_report_tracker_;+  };++  void ShutdownLocked() override { delegate_.reset(); }++  OrphanablePtr<LoadBalancingPolicy> delegate_;+  LoadReportTracker* load_report_tracker_;+};++class BackendMetricsLbPolicyFactory+    : public grpc_core::LoadBalancingPolicyFactory {+ private:+  class BackendMetricsLbPolicyFactoryConfig+      : public LoadBalancingPolicy::Config {+   private:+    absl::string_view name() const override {+      return kBackendMetricsLbPolicyName;+    }+  };++  absl::string_view name() const override {+    return kBackendMetricsLbPolicyName;+  }++  OrphanablePtr<LoadBalancingPolicy> CreateLoadBalancingPolicy(+      LoadBalancingPolicy::Args args) const override {+    return grpc_core::MakeOrphanable<BackendMetricsLbPolicy>(std::move(args));+  }++  absl::StatusOr<RefCountedPtr<LoadBalancingPolicy::Config>>+  ParseLoadBalancingConfig(const grpc_core::Json& /*json*/) const override {+    return MakeRefCounted<BackendMetricsLbPolicyFactoryConfig>();+  }+};+}  // namespace++void RegisterBackendMetricsLbPolicy(CoreConfiguration::Builder* builder) {+  builder->lb_policy_registry()->RegisterLoadBalancingPolicyFactory(+      std::make_unique<BackendMetricsLbPolicyFactory>());+}++void LoadReportTracker::SetupOnChannel(ChannelArguments* arguments) {+  arguments->SetPointer(kMetricsTrackerAttribute, this);+}++void LoadReportTracker::RecordPerRpcLoadReport(+    const grpc_core::BackendMetricData* backend_metric_data) {+  if (backend_metric_data != nullptr) {","I don't think we need to check whether it's null here, because `BackendMetricDataToOrcaLoadReport()` will return nullopt in that case.  I think we can just unconditionally add the result of `BackendMetricDataToOrcaLoadReport()` to the queue.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32524,1131552919,2023-03-09T20:24:46Z,test/cpp/interop/interop_client.h,"@@ -35,17 +38,25 @@ typedef std::function<void(const InteropClientContextInspector&,                            const SimpleRequest*, const SimpleResponse*)>     CheckerFn; -typedef std::function<std::shared_ptr<Channel>(void)> ChannelCreationFunc;+typedef std::function<std::shared_ptr<Channel>()> ChannelCreationFunc;++typedef std::function<std::shared_ptr<Channel>(","Instead of using a function that takes another function as a parameter, I think it would be simpler to just pass in the channel args from the caller, like this:```typedef std::function<std::shared_ptr<Channel>(ChannelArguments)>    ChannelCreationFuncWithCustomArgs;```Then the new `InteropClient` ctor can look like this:```InteropClient::InteropClient(    ChannelCreationFuncWithCustomArgs channel_creation_func,    bool new_stub_every_test_case, bool do_not_abort_on_transient_failures)    : serviceStub_(          [&]() {            InitializeCustomLbPolicyIfNeeded();            ChannelArguments args;            load_report_tracker_->SetupOnChannel(&args);            return channel_creation_func(std::move(args));          },          new_stub_every_test_case),      do_not_abort_on_transient_failures_(do_not_abort_on_transient_failures) {}```And the lambdas in client.cc can just add their own args to the passed-in args.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32524,1131572570,2023-03-09T20:43:46Z,test/cpp/interop/interop_client.h,"@@ -35,17 +38,25 @@ typedef std::function<void(const InteropClientContextInspector&,                            const SimpleRequest*, const SimpleResponse*)>     CheckerFn; -typedef std::function<std::shared_ptr<Channel>(void)> ChannelCreationFunc;+typedef std::function<std::shared_ptr<Channel>()> ChannelCreationFunc;++typedef std::function<std::shared_ptr<Channel>(+    std::function<void(ChannelArguments*)>)>+    ChannelCreationFuncWithCustomArgs;  class InteropClient {  public:   /// If new_stub_every_test_case is true, a new TestService::Stub object is   /// created for every test case-  /// If do_not_abort_on_transient_failures is true, abort() is not called in-  /// case of transient failures (like connection failures)+  /// If do_not_abort_on_transient_failures is true, abort() is not called+  /// in case of transient failures (like connection failures)   explicit InteropClient(ChannelCreationFunc channel_creation_func,                          bool new_stub_every_test_case,                          bool do_not_abort_on_transient_failures);+  /// Same as ctor above, allows customizing channel arguments+  explicit InteropClient(","Instead of adding a second ctor, why not just change the existing callers to use the new parameter?",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32524,1131824800,2023-03-10T01:04:58Z,test/cpp/interop/interop_client.h,"@@ -35,17 +38,25 @@ typedef std::function<void(const InteropClientContextInspector&,                            const SimpleRequest*, const SimpleResponse*)>     CheckerFn; -typedef std::function<std::shared_ptr<Channel>(void)> ChannelCreationFunc;+typedef std::function<std::shared_ptr<Channel>()> ChannelCreationFunc;++typedef std::function<std::shared_ptr<Channel>(",I don't understand what you mean about not wanting to bury the service config flag.  The approach I proposed here would not require changing where the flag is handled; that would still happen in the lambdas that are created in client.cc.,
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32524,1131830481,2023-03-10T01:12:15Z,test/cpp/interop/interop_client.h,"@@ -35,17 +38,25 @@ typedef std::function<void(const InteropClientContextInspector&,                            const SimpleRequest*, const SimpleResponse*)>     CheckerFn; -typedef std::function<std::shared_ptr<Channel>(void)> ChannelCreationFunc;+typedef std::function<std::shared_ptr<Channel>()> ChannelCreationFunc;++typedef std::function<std::shared_ptr<Channel>(+    std::function<void(ChannelArguments*)>)>+    ChannelCreationFuncWithCustomArgs;  class InteropClient {  public:   /// If new_stub_every_test_case is true, a new TestService::Stub object is   /// created for every test case-  /// If do_not_abort_on_transient_failures is true, abort() is not called in-  /// case of transient failures (like connection failures)+  /// If do_not_abort_on_transient_failures is true, abort() is not called+  /// in case of transient failures (like connection failures)   explicit InteropClient(ChannelCreationFunc channel_creation_func,                          bool new_stub_every_test_case,                          bool do_not_abort_on_transient_failures);+  /// Same as ctor above, allows customizing channel arguments+  explicit InteropClient(","I only see 3 other callers, and they look trivial to change.  Avoiding this doesn't seem to save much time.  And unless you plan to write a subsequent PR to clean this up, this is just leaving unnecessary technical debt.The down-side of this approach is that any caller that uses the old interface will not get the `LoadReportTracker` channel arg.",
5663878,yijiem,https://api.github.com/repos/grpc/grpc/pulls/32563,1131846028,2023-03-10T01:32:06Z,src/core/lib/event_engine/windows/windows_endpoint.cc,"@@ -68,76 +76,79 @@ WindowsEndpoint::~WindowsEndpoint() {   GRPC_EVENT_ENGINE_ENDPOINT_TRACE(""WindowsEndpoint::%p destroyed"", this); } -bool WindowsEndpoint::Read(absl::AnyInvocable<void(absl::Status)> on_read,-                           SliceBuffer* buffer, const ReadArgs* /* args */) {+absl::Status WindowsEndpoint::DoTcpRead(SliceBuffer* buffer) {   GRPC_EVENT_ENGINE_ENDPOINT_TRACE(""WindowsEndpoint::%p reading"", this);   if (io_state_->socket->IsShutdown()) {-    executor_->Run([on_read = std::move(on_read)]() mutable {-      on_read(absl::UnavailableError(""Socket is shutting down.""));-    });-    return false;+    return absl::UnavailableError(""Socket is shutting down."");   }   // Prepare the WSABUF struct-  WSABUF wsa_buffers[kMaxWSABUFCount];-  // TODO(hork): introduce a last_read_buffer to save unused sliced.-  buffer->Clear();-  // TODO(hork): sometimes args->read_hint_bytes is 1, which is not useful.-  // Choose an appropriate size.-  size_t min_read_size = kDefaultTargetReadSize;-  if (buffer->Length() < min_read_size && buffer->Count() < kMaxWSABUFCount) {-    buffer->AppendIndexed(Slice(allocator_.MakeSlice(min_read_size)));-  }   GPR_ASSERT(buffer->Count() <= kMaxWSABUFCount);+  WSABUF wsa_buffers[kMaxWSABUFCount];   for (size_t i = 0; i < buffer->Count(); i++) {     auto& slice = buffer->MutableSliceAt(i);     wsa_buffers[i].buf = (char*)slice.begin();     wsa_buffers[i].len = slice.size();   }   DWORD bytes_read = 0;   DWORD flags = 0;-  // First let's try a synchronous, non-blocking read.+  // First try a synchronous, non-blocking read.   int status =       WSARecv(io_state_->socket->raw_socket(), wsa_buffers,               (DWORD)buffer->Count(), &bytes_read, &flags, nullptr, nullptr);   int wsa_error = status == 0 ? 0 : WSAGetLastError();-  // Did we get data immediately ? Yay.   if (wsa_error != WSAEWOULDBLOCK) {+    // Data or some error was returned immediately.     io_state_->socket->read_info()->SetResult(         {/*wsa_error=*/wsa_error, /*bytes_read=*/bytes_read});-    absl::Status result;-    if (bytes_read == 0) {-      result = absl::UnavailableError(""End of TCP stream"");-      grpc_core::StatusSetInt(&result, grpc_core::StatusIntProperty::kRpcStatus,-                              GRPC_STATUS_UNAVAILABLE);-      buffer->Clear();-    } else {-      result = absl::OkStatus();-      // prune slicebuffer-      if (bytes_read != buffer->Length()) {-        buffer->RemoveLastNBytes(buffer->Length() - bytes_read);-      }-    }-    executor_->Run(-        [result, on_read = std::move(on_read)]() mutable { on_read(result); });-    return false;+    executor_->Run(&io_state_->handle_read_event);+    return absl::OkStatus();+  }+  // If the endpoint has already received some data, and the next call would+  // block, return the data in case that is all the data the reader expects.+  if (io_state_->handle_read_event.MaybeFinishIfDataHasAlreadyBeenRead(+          absl::OkStatus())) {+    return absl::OkStatus();   }   // Otherwise, let's retry, by queuing a read.-  memset(io_state_->socket->read_info()->overlapped(), 0, sizeof(OVERLAPPED));   status = WSARecv(io_state_->socket->raw_socket(), wsa_buffers,                    (DWORD)buffer->Count(), &bytes_read, &flags,                    io_state_->socket->read_info()->overlapped(), nullptr);   wsa_error = status == 0 ? 0 : WSAGetLastError();   if (wsa_error != 0 && wsa_error != WSA_IO_PENDING) {     // Async read returned immediately with an error-    executor_->Run([this, on_read = std::move(on_read), wsa_error]() mutable {-      on_read(GRPC_WSA_ERROR(-          wsa_error,-          absl::StrFormat(""WindowsEndpont::%p Read failed"", this).c_str()));+    return GRPC_WSA_ERROR(+        wsa_error,+        absl::StrFormat(""WindowsEndpont::%p Read failed"", this).c_str());+  }+  io_state_->socket->NotifyOnRead(&io_state_->handle_read_event);+  return absl::OkStatus();+}++bool WindowsEndpoint::Read(absl::AnyInvocable<void(absl::Status)> on_read,+                           SliceBuffer* buffer, const ReadArgs* /* args */) {+  GRPC_EVENT_ENGINE_ENDPOINT_TRACE(""WindowsEndpoint::%p reading"", this);+  if (io_state_->socket->IsShutdown()) {+    executor_->Run([on_read = std::move(on_read)]() mutable {+      on_read(absl::UnavailableError(""Socket is shutting down.""));     });     return false;   }+  buffer->Clear();+  io_state_->handle_read_event.DonateSpareSlices(buffer);+  // TODO(hork): sometimes args->read_hint_bytes is 1, which is not useful.+  // Choose an appropriate size.+  size_t min_read_size = kDefaultTargetReadSize;+  if (buffer->Length() < min_read_size && buffer->Count() < kMaxWSABUFCount) {+    buffer->AppendIndexed(Slice(allocator_.MakeSlice(min_read_size)));",pedantic: should this be `allocator_.MakeSlice(min_read_size - buffer->Length())` ?,
5663878,yijiem,https://api.github.com/repos/grpc/grpc/pulls/32563,1131862132,2023-03-10T01:52:38Z,src/core/lib/event_engine/windows/windows_endpoint.cc,"@@ -68,76 +76,79 @@ WindowsEndpoint::~WindowsEndpoint() {   GRPC_EVENT_ENGINE_ENDPOINT_TRACE(""WindowsEndpoint::%p destroyed"", this); } -bool WindowsEndpoint::Read(absl::AnyInvocable<void(absl::Status)> on_read,-                           SliceBuffer* buffer, const ReadArgs* /* args */) {+absl::Status WindowsEndpoint::DoTcpRead(SliceBuffer* buffer) {   GRPC_EVENT_ENGINE_ENDPOINT_TRACE(""WindowsEndpoint::%p reading"", this);   if (io_state_->socket->IsShutdown()) {-    executor_->Run([on_read = std::move(on_read)]() mutable {-      on_read(absl::UnavailableError(""Socket is shutting down.""));-    });-    return false;+    return absl::UnavailableError(""Socket is shutting down."");   }   // Prepare the WSABUF struct-  WSABUF wsa_buffers[kMaxWSABUFCount];-  // TODO(hork): introduce a last_read_buffer to save unused sliced.-  buffer->Clear();-  // TODO(hork): sometimes args->read_hint_bytes is 1, which is not useful.-  // Choose an appropriate size.-  size_t min_read_size = kDefaultTargetReadSize;-  if (buffer->Length() < min_read_size && buffer->Count() < kMaxWSABUFCount) {-    buffer->AppendIndexed(Slice(allocator_.MakeSlice(min_read_size)));-  }   GPR_ASSERT(buffer->Count() <= kMaxWSABUFCount);+  WSABUF wsa_buffers[kMaxWSABUFCount];   for (size_t i = 0; i < buffer->Count(); i++) {     auto& slice = buffer->MutableSliceAt(i);     wsa_buffers[i].buf = (char*)slice.begin();     wsa_buffers[i].len = slice.size();   }   DWORD bytes_read = 0;   DWORD flags = 0;-  // First let's try a synchronous, non-blocking read.+  // First try a synchronous, non-blocking read.   int status =       WSARecv(io_state_->socket->raw_socket(), wsa_buffers,               (DWORD)buffer->Count(), &bytes_read, &flags, nullptr, nullptr);   int wsa_error = status == 0 ? 0 : WSAGetLastError();-  // Did we get data immediately ? Yay.   if (wsa_error != WSAEWOULDBLOCK) {+    // Data or some error was returned immediately.     io_state_->socket->read_info()->SetResult(         {/*wsa_error=*/wsa_error, /*bytes_read=*/bytes_read});-    absl::Status result;-    if (bytes_read == 0) {-      result = absl::UnavailableError(""End of TCP stream"");-      grpc_core::StatusSetInt(&result, grpc_core::StatusIntProperty::kRpcStatus,-                              GRPC_STATUS_UNAVAILABLE);-      buffer->Clear();-    } else {-      result = absl::OkStatus();-      // prune slicebuffer-      if (bytes_read != buffer->Length()) {-        buffer->RemoveLastNBytes(buffer->Length() - bytes_read);-      }-    }-    executor_->Run(-        [result, on_read = std::move(on_read)]() mutable { on_read(result); });-    return false;+    executor_->Run(&io_state_->handle_read_event);+    return absl::OkStatus();+  }+  // If the endpoint has already received some data, and the next call would+  // block, return the data in case that is all the data the reader expects.+  if (io_state_->handle_read_event.MaybeFinishIfDataHasAlreadyBeenRead(+          absl::OkStatus())) {+    return absl::OkStatus();   }   // Otherwise, let's retry, by queuing a read.-  memset(io_state_->socket->read_info()->overlapped(), 0, sizeof(OVERLAPPED));   status = WSARecv(io_state_->socket->raw_socket(), wsa_buffers,                    (DWORD)buffer->Count(), &bytes_read, &flags,                    io_state_->socket->read_info()->overlapped(), nullptr);   wsa_error = status == 0 ? 0 : WSAGetLastError();   if (wsa_error != 0 && wsa_error != WSA_IO_PENDING) {     // Async read returned immediately with an error-    executor_->Run([this, on_read = std::move(on_read), wsa_error]() mutable {-      on_read(GRPC_WSA_ERROR(-          wsa_error,-          absl::StrFormat(""WindowsEndpont::%p Read failed"", this).c_str()));+    return GRPC_WSA_ERROR(+        wsa_error,+        absl::StrFormat(""WindowsEndpont::%p Read failed"", this).c_str());+  }+  io_state_->socket->NotifyOnRead(&io_state_->handle_read_event);+  return absl::OkStatus();+}++bool WindowsEndpoint::Read(absl::AnyInvocable<void(absl::Status)> on_read,+                           SliceBuffer* buffer, const ReadArgs* /* args */) {+  GRPC_EVENT_ENGINE_ENDPOINT_TRACE(""WindowsEndpoint::%p reading"", this);+  if (io_state_->socket->IsShutdown()) {+    executor_->Run([on_read = std::move(on_read)]() mutable {+      on_read(absl::UnavailableError(""Socket is shutting down.""));     });     return false;   }+  buffer->Clear();+  io_state_->handle_read_event.DonateSpareSlices(buffer);+  // TODO(hork): sometimes args->read_hint_bytes is 1, which is not useful.+  // Choose an appropriate size.+  size_t min_read_size = kDefaultTargetReadSize;+  if (buffer->Length() < min_read_size && buffer->Count() < kMaxWSABUFCount) {+    buffer->AppendIndexed(Slice(allocator_.MakeSlice(min_read_size)));+  }   io_state_->handle_read_event.Prime(io_state_, buffer, std::move(on_read));-  io_state_->socket->NotifyOnRead(&io_state_->handle_read_event);+  auto status = DoTcpRead(buffer);+  if (!status.ok()) {+    // The read could not be completed.+    io_state_->endpoint->executor_->Run([this, status]() {+      io_state_->handle_read_event.ExecuteCallbackAndReset(status);+    });+  }   return false;",No action require: seems like `Read` always return `false` and this change makes the API async in all cases and now it seems to match with the spec: https://github.com/grpc/grpc/blob/97ba9871324cb68b93f22fd1860934392cd476ee/include/grpc/event_engine/event_engine.h#L184-L185.,
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/32563,1131901464,2023-03-10T03:01:19Z,src/core/lib/event_engine/windows/windows_endpoint.cc,"@@ -68,76 +76,79 @@ WindowsEndpoint::~WindowsEndpoint() {   GRPC_EVENT_ENGINE_ENDPOINT_TRACE(""WindowsEndpoint::%p destroyed"", this); } -bool WindowsEndpoint::Read(absl::AnyInvocable<void(absl::Status)> on_read,-                           SliceBuffer* buffer, const ReadArgs* /* args */) {+absl::Status WindowsEndpoint::DoTcpRead(SliceBuffer* buffer) {   GRPC_EVENT_ENGINE_ENDPOINT_TRACE(""WindowsEndpoint::%p reading"", this);   if (io_state_->socket->IsShutdown()) {-    executor_->Run([on_read = std::move(on_read)]() mutable {-      on_read(absl::UnavailableError(""Socket is shutting down.""));-    });-    return false;+    return absl::UnavailableError(""Socket is shutting down."");   }   // Prepare the WSABUF struct-  WSABUF wsa_buffers[kMaxWSABUFCount];-  // TODO(hork): introduce a last_read_buffer to save unused sliced.-  buffer->Clear();-  // TODO(hork): sometimes args->read_hint_bytes is 1, which is not useful.-  // Choose an appropriate size.-  size_t min_read_size = kDefaultTargetReadSize;-  if (buffer->Length() < min_read_size && buffer->Count() < kMaxWSABUFCount) {-    buffer->AppendIndexed(Slice(allocator_.MakeSlice(min_read_size)));-  }   GPR_ASSERT(buffer->Count() <= kMaxWSABUFCount);+  WSABUF wsa_buffers[kMaxWSABUFCount];   for (size_t i = 0; i < buffer->Count(); i++) {     auto& slice = buffer->MutableSliceAt(i);     wsa_buffers[i].buf = (char*)slice.begin();     wsa_buffers[i].len = slice.size();   }   DWORD bytes_read = 0;   DWORD flags = 0;-  // First let's try a synchronous, non-blocking read.+  // First try a synchronous, non-blocking read.   int status =       WSARecv(io_state_->socket->raw_socket(), wsa_buffers,               (DWORD)buffer->Count(), &bytes_read, &flags, nullptr, nullptr);   int wsa_error = status == 0 ? 0 : WSAGetLastError();-  // Did we get data immediately ? Yay.   if (wsa_error != WSAEWOULDBLOCK) {+    // Data or some error was returned immediately.     io_state_->socket->read_info()->SetResult(         {/*wsa_error=*/wsa_error, /*bytes_read=*/bytes_read});-    absl::Status result;-    if (bytes_read == 0) {-      result = absl::UnavailableError(""End of TCP stream"");-      grpc_core::StatusSetInt(&result, grpc_core::StatusIntProperty::kRpcStatus,-                              GRPC_STATUS_UNAVAILABLE);-      buffer->Clear();-    } else {-      result = absl::OkStatus();-      // prune slicebuffer-      if (bytes_read != buffer->Length()) {-        buffer->RemoveLastNBytes(buffer->Length() - bytes_read);-      }-    }-    executor_->Run(-        [result, on_read = std::move(on_read)]() mutable { on_read(result); });-    return false;+    executor_->Run(&io_state_->handle_read_event);+    return absl::OkStatus();+  }+  // If the endpoint has already received some data, and the next call would+  // block, return the data in case that is all the data the reader expects.+  if (io_state_->handle_read_event.MaybeFinishIfDataHasAlreadyBeenRead(+          absl::OkStatus())) {+    return absl::OkStatus();   }   // Otherwise, let's retry, by queuing a read.-  memset(io_state_->socket->read_info()->overlapped(), 0, sizeof(OVERLAPPED));   status = WSARecv(io_state_->socket->raw_socket(), wsa_buffers,                    (DWORD)buffer->Count(), &bytes_read, &flags,                    io_state_->socket->read_info()->overlapped(), nullptr);   wsa_error = status == 0 ? 0 : WSAGetLastError();   if (wsa_error != 0 && wsa_error != WSA_IO_PENDING) {     // Async read returned immediately with an error-    executor_->Run([this, on_read = std::move(on_read), wsa_error]() mutable {-      on_read(GRPC_WSA_ERROR(-          wsa_error,-          absl::StrFormat(""WindowsEndpont::%p Read failed"", this).c_str()));+    return GRPC_WSA_ERROR(+        wsa_error,+        absl::StrFormat(""WindowsEndpont::%p Read failed"", this).c_str());+  }+  io_state_->socket->NotifyOnRead(&io_state_->handle_read_event);+  return absl::OkStatus();+}++bool WindowsEndpoint::Read(absl::AnyInvocable<void(absl::Status)> on_read,+                           SliceBuffer* buffer, const ReadArgs* /* args */) {+  GRPC_EVENT_ENGINE_ENDPOINT_TRACE(""WindowsEndpoint::%p reading"", this);+  if (io_state_->socket->IsShutdown()) {+    executor_->Run([on_read = std::move(on_read)]() mutable {+      on_read(absl::UnavailableError(""Socket is shutting down.""));     });     return false;   }+  buffer->Clear();+  io_state_->handle_read_event.DonateSpareSlices(buffer);+  // TODO(hork): sometimes args->read_hint_bytes is 1, which is not useful.+  // Choose an appropriate size.+  size_t min_read_size = kDefaultTargetReadSize;+  if (buffer->Length() < min_read_size && buffer->Count() < kMaxWSABUFCount) {+    buffer->AppendIndexed(Slice(allocator_.MakeSlice(min_read_size)));","I'm not sure if it should, honestly. As it's currently written, the buffer size could end up being between `min_read_size` and `(2 * min_read_size) - 1`. If we only allocate up to `min_read_size`, we may end up doing more allocations over the life of the process because we've only allocated the minimum. It is a tradeoff between memory and cpu utilization, especially in applications with a lot of open endpoints. I'd wager that there aren't many low-memory Windows systems that gRPC is running on, so I'd opt for a larger memory footprint here.",
287917,eugeneo,https://api.github.com/repos/grpc/grpc/pulls/32524,1132702385,2023-03-10T18:03:19Z,test/cpp/interop/interop_client.h,"@@ -35,17 +38,25 @@ typedef std::function<void(const InteropClientContextInspector&,                            const SimpleRequest*, const SimpleResponse*)>     CheckerFn; -typedef std::function<std::shared_ptr<Channel>(void)> ChannelCreationFunc;+typedef std::function<std::shared_ptr<Channel>()> ChannelCreationFunc;++typedef std::function<std::shared_ptr<Channel>(+    std::function<void(ChannelArguments*)>)>+    ChannelCreationFuncWithCustomArgs;  class InteropClient {  public:   /// If new_stub_every_test_case is true, a new TestService::Stub object is   /// created for every test case-  /// If do_not_abort_on_transient_failures is true, abort() is not called in-  /// case of transient failures (like connection failures)+  /// If do_not_abort_on_transient_failures is true, abort() is not called+  /// in case of transient failures (like connection failures)   explicit InteropClient(ChannelCreationFunc channel_creation_func,                          bool new_stub_every_test_case,                          bool do_not_abort_on_transient_failures);+  /// Same as ctor above, allows customizing channel arguments+  explicit InteropClient(",Every caller also needs to be retrofitted with the JSON command line arg and such. I understand this is not necessary for current pull request and figuring out all the build dependencies and such delays this pull request.I removed the second ctor but would add JSON config flag in a separate PR if needed. I feel like some refactoring effort is needed to reduce code duplication.,X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32524,1132830832,2023-03-10T20:11:22Z,test/cpp/interop/backend_metrics_lb_policy.h,"@@ -29,23 +29,19 @@ namespace grpc { namespace testing { -constexpr absl::string_view kMetricsTrackerArgument = ""orca_metrics_tracker"";+using xds::data::orca::v3::OrcaLoadReport;  class LoadReportTracker {  public:-  std::map<std::string, void*> channel_arguments() {-    return {{std::string(kMetricsTrackerArgument), this}};-  }-+  ChannelArguments GetChannelArguments();+  void ResetCollectedLoadReports();   void RecordPerRpcLoadReport(       const grpc_core::BackendMetricData* backend_metric_data);--  std::deque<absl::optional<xds::data::orca::v3::OrcaLoadReport>>-  GetCollectedPerRpcLoadReports();+  absl::StatusOr<absl::optional<OrcaLoadReport>> GetFirstLoadReport();","I don't think we need a `StatusOr<>` here, just an `optional<>`.  I realize that makes two levels of optionals, which is a little awkward, but I think you can make it clearer with a typedef:```// A load report, or nullopt if the call had no load report.using LoadReportEntry = absl::optional<xds::data::orca::v3::OrcaLoadReport>;// Returns the next load report, or nullopt if the queue is empty.absl::optional<LoadReportEntry> GetNextLoadReport();```",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/30788,1134735824,2023-03-14T00:05:48Z,src/core/ext/filters/client_channel/backup_poller.cc,"@@ -61,19 +61,10 @@ static backup_poller* g_poller = nullptr;  // guarded by g_poller_mu static grpc_core::Duration g_poll_interval =     grpc_core::Duration::Milliseconds(DEFAULT_POLL_INTERVAL_MS); -GPR_GLOBAL_CONFIG_DEFINE_INT32(","One drawback of centralizing the definition of these config params is that it will be less obvious when there are no longer any users of a given parameter and it can be removed.  Just as one example, prior to this PR, when we eventually remove this backup poller, this parameter would have been removed at the same time; with this PR, it might be easier to forget.  Is there a reasonable way we can have some automated check for this kind of thing?This isn't a blocker, but would be good to add some check for this if we have a reasonable way to do so.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/30788,1134742098,2023-03-14T00:18:36Z,test/cpp/end2end/rls_end2end_test.cc,"@@ -158,7 +159,10 @@ class FakeResolverResponseGeneratorWrapper { class RlsEnd2endTest : public ::testing::Test {  protected:   static void SetUpTestSuite() {-    GPR_GLOBAL_CONFIG_SET(grpc_client_channel_backup_poll_interval_ms, 1);+    grpc_core::SetEnv(""GRPC_EXPERIMENTAL_ENABLE_RLS_LB_POLICY"", ""true"");",I don't think this is needed.  We removed this env var long ago.  (I assume this is left over from some older code?),X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32599,1136258629,2023-03-14T21:55:09Z,test/cpp/interop/interop_server.cc,"@@ -349,6 +358,32 @@ class TestServiceImpl : public TestService::Service {       return Status(grpc::StatusCode::INTERNAL, ""Error writing response."");     }   }++ private:+  void RecordServerMetrics(+      const xds::data::orca::v3::OrcaLoadReport& request_metrics) {+    // Do not record when zero since it indicates no test per-call report.+    if (request_metrics.cpu_utilization() > 0) {+      server_metric_recorder_->SetCpuUtilization(+          request_metrics.cpu_utilization());+    }+    if (request_metrics.mem_utilization() > 0) {+      server_metric_recorder_->SetMemoryUtilization(+          request_metrics.mem_utilization());+    }+    if (request_metrics.rps_fractional() > 0) {+      server_metric_recorder_->SetQps(request_metrics.rps_fractional());+    }+    std::map<grpc::string_ref, double> named_utilizations;+    for (const auto& p : request_metrics.utilization()) {+      const auto& key = *retained_utilization_names_.insert(p.first).first;+      named_utilizations.emplace(key, p.second);+    }+    server_metric_recorder_->SetAllNamedUtilization(named_utilizations);+  }++  grpc::experimental::ServerMetricRecorder* server_metric_recorder_;+  std::set<std::string> retained_utilization_names_;","Just to be safe, I think this needs to be guarded by a mutex, since there could be multiple RPCs in parallel.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32618,1137406247,2023-03-15T16:30:11Z,src/core/lib/channel/call_tracer.h,"@@ -35,48 +33,74 @@  namespace grpc_core { +// The interface heirarchy is as follows -+//                 CallTracerInterface+//                      /          \+//               CallTracer       RpcTracerInterface+//                                /             \+//                      CallAttemptTracer    ServerCallTracer++// The base class for all tracer implementations.+class CallTracerInterface {+ public:+  virtual ~CallTracerInterface() {}+  // Records an annotation on the call attempt.+  // TODO(yashykt): If needed, extend this to attach attributes with+  // annotations.+  virtual void RecordAnnotation(absl::string_view annotation) = 0;+};++// The base class for CallAttemptTracer and ServerCallTracer.+// TODO(yashykt): What's a better name for this?+class RpcTracerInterface : public CallTracerInterface {+ public:+  ~RpcTracerInterface() override {}+  // Please refer to `grpc_transport_stream_op_batch_payload` for details on+  // arguments.+  virtual void RecordSendInitialMetadata(","I am raising the following idea just to make sure that we've considered alternatives -- my guess is that we don't actually want to do this.Since we're now going to be using this same interface on both the client and server side, would it make sense to phrase these methods in terms of client and server rather than send and recv?  For example, we could have a method like `RecordClientInitialMetadata()`, which would be called for send_initial_metadata on the client side and recv_initial_metadata on the server side.The motivation for this idea is that a lot of the promise code is phrased this way, so I'm wondering if this approach would be more consistent in the long run.When evaluating this idea, please consider both (a) how the tracer implementations will work and (b) how the `RpcTracerInterface` API will be called in various parts of the code (e.g., filters, transport, etc).  The overall goal here should be minimizing `if (is_client)` throughout the code base.  (Looking at the compression filter, it looks like the send/recv pattern is actually better than the client/server pattern would be.  But I don't know if that's also the case for the other call sites that we'll have in the future.)One other factor to consider is that I think there are cases where the mutability of the parameters will want to be different on the client and server side.  For example, client initial metadata needs to be mutable on the client side but can be const on the server side, whereas server trailing(?) metadata needs to be mutable on the server side but can be const on the client side.  If we use the same interface for both sides, then we need to make the parameter mutable even on the side where we don't really want to support mutation.  However, if we stick with the current send/recv interface, then I think we can make the parameters mutable only for the send operations.I'd like to get @ctiller's input on this as well.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32618,1137420300,2023-03-15T16:39:16Z,src/core/lib/channel/call_tracer.h,"@@ -35,48 +33,74 @@  namespace grpc_core { +// The interface heirarchy is as follows -+//                 CallTracerInterface+//                      /          \+//               CallTracer       RpcTracerInterface+//                                /             \+//                      CallAttemptTracer    ServerCallTracer++// The base class for all tracer implementations.+class CallTracerInterface {+ public:+  virtual ~CallTracerInterface() {}+  // Records an annotation on the call attempt.+  // TODO(yashykt): If needed, extend this to attach attributes with+  // annotations.+  virtual void RecordAnnotation(absl::string_view annotation) = 0;+};++// The base class for CallAttemptTracer and ServerCallTracer.+// TODO(yashykt): What's a better name for this?",I suggest renaming `CallTracerInterface` to something like `CallTracerAnnotationInterface` and then renaming `RpcTracerInterface` to `CallTracerInterface`.,X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32618,1137425231,2023-03-15T16:42:24Z,src/core/lib/channel/context.h,"@@ -36,9 +36,16 @@ typedef enum {   /// Value is a \a census_context.   GRPC_CONTEXT_TRACING, -  /// Value is a CallTracer object.+  /// Value is a CallTracer object. (Only valid on the client-side call, or+  /// ServerCallTracer on the server-side.)   GRPC_CONTEXT_CALL_TRACER, +  /// Value is a RpcTracerInterface (ServerCallTracer on the server-side,+  /// CallAttemptTracer on a subchannel call.)+  /// TODO(yashykt): Maybe come up with a better name. This will go away in the",Suggest renaming `GRPC_CONTEXT_CALL_TRACER` to `GRPC_CONTEXT_CALL_ATTRIBUTE_TRACER` and then using `GRPC_CONTEXT_CALL_TRACER` for this new one.,X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32618,1137446300,2023-03-15T16:56:16Z,src/core/ext/filters/client_channel/client_channel.cc,"@@ -2525,7 +2527,7 @@ ClientChannel::LoadBalancedCall::LoadBalancedCall(       chand_(chand),       call_dispatch_controller_(call_dispatch_controller),       call_attempt_tracer_(","Now that we're storing this in the call context, I don't think we need this data member anymore.  Instead, we can get it from `call_context()[GRPC_CONTEXT_RPC_TRACER]`.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32618,1137465172,2023-03-15T17:07:52Z,src/cpp/ext/filters/census/grpc_plugin.cc,"@@ -51,13 +54,6 @@ void RegisterOpenCensusPlugin() {                   &grpc::internal::OpenCensusClientFilter::kFilter);               return true;             });-        builder->channel_init()->RegisterStage(",Why do we no longer need the server side to be a filter but we still need the client side to be a filter?,
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32618,1137467918,2023-03-15T17:09:39Z,src/cpp/ext/filters/census/server_filter.h,,"This file should be renamed, since it's no longer a filter.Same for the .cc file.",X
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/32600,1137689938,2023-03-15T19:44:47Z,src/core/ext/transport/chttp2/transport/hpack_parser.h,"@@ -121,7 +124,7 @@ class HPackParser {   uint8_t dynamic_table_updates_allowed_;   // Length of frame so far.   uint32_t frame_length_;-  uint32_t metadata_size_limit_;+  std::unique_ptr<RandomEarlyDetection> metadata_early_detection_ = nullptr;",(like... `RandomEarlyDetection metadata_early_detection_;`),
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32618,1137821380,2023-03-15T22:04:32Z,src/core/lib/channel/call_tracer.h,"@@ -80,13 +84,13 @@ class RpcTracerInterface : public CallTracerInterface { // Interface for a tracer that records activities on a call. Actual attempts for // this call are traced with CallAttemptTracer after invoking RecordNewAttempt() // on the CallTracer object.-class CallTracer : public CallTracerInterface {+class CallTracer : public CallTracerAnnotationInterface {",Suggest renaming this to `ClientCallTracer` for clarity.,X
16962414,gtcooke94,https://api.github.com/repos/grpc/grpc/pulls/32544,1139244676,2023-03-16T19:04:35Z,test/core/tsi/crl_ssl_transport_security_test.cc,"@@ -185,12 +238,27 @@ class CrlSslTransportSecurityTest       // For OpenSSL versions < 1.1, TLS 1.3 is not supported, so the       // client-side handshake should succeed precisely when the server-side       // handshake succeeds.+      //+      // For the intermediate cases, we have a CA -> Intermediate CA -> Leaf+      // Cert chain in which the Intermediate CA cert is revoked by the CA. We+      // test 3 cases. Note: A CRL not existing should not make the handshake+      // fail+      // 1. CRL Directory with CA's CRL and Intermediate CA's CRL -> Handshake+      // fails due to revoked cert+      // 2. CRL Directory with CA's CRL but missing Intermediate CA's CRL ->+      // Handshake fails due to revoked cert+      // 3. CRL Directory without CA's CRL with but Intermediate CA's CRL ->+      // Handshake succeeds because the CRL that revokes the cert is not+      // present.       bool expect_server_success =-          !(use_revoked_server_cert_ || use_revoked_client_cert_);+          !(use_revoked_server_cert_ || use_revoked_client_cert_ ||","I think it's just a personal preference - the way I read it I see something like""expect server success = NOT any of the revoked bools being true"" So if anything bool flag is true in all of those ORs it'll be an expected failure.IMO I like the way it is a little more because I don't have the think about and negate every individual conditionOverall, I'd rather pull some of this shared logic out and hard code it in each individual test since it's the known expected result, I think it would make it a lot cleaner, but that's a refactor for later.",X
1644595,gnossen,https://api.github.com/repos/grpc/grpc/pulls/32641,1139402796,2023-03-16T22:05:33Z,src/python/grpcio/grpc/aio/_interceptor.py,"@@ -599,16 +599,14 @@ async def _invoke(         """"""Run the RPC call wrapped in interceptors""""""          async def _run_interceptor(-                interceptors: Iterator[UnaryUnaryClientInterceptor],+                interceptors: List[UnaryUnaryClientInterceptor],                 client_call_details: ClientCallDetails,                 request: RequestType) -> _base_call.UnaryUnaryCall: -            interceptor = next(interceptors, None)--            if interceptor:-                continuation = functools.partial(_run_interceptor, interceptors)--                call_or_response = await interceptor.intercept_unary_unary(+            if len(interceptors) > 0:","Nit: According to the style guide (which I know we don't technically follow), this should be `if interceptors:`",
1644595,gnossen,https://api.github.com/repos/grpc/grpc/pulls/32641,1139406228,2023-03-16T22:08:49Z,src/python/grpcio/grpc/aio/_interceptor.py,"@@ -571,7 +571,7 @@ class InterceptedUnaryUnaryCall(_InterceptedUnaryResponseMixin, InterceptedCall,     _channel: cygrpc.AioChannel      # pylint: disable=too-many-arguments-    def __init__(self, interceptors: Sequence[UnaryUnaryClientInterceptor],","This `__init__` is part of our public interface, so we can't change the type. Instead, we'll want to convert the argument to a `list` within the method.",
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/32622,1140439189,2023-03-17T16:17:47Z,src/core/lib/iomgr/socket_windows.cc,"@@ -140,19 +197,19 @@ void grpc_socket_notify_on_read(grpc_winsocket* socket, grpc_closure* closure) {   socket_notify_on_iocp(socket, closure, &socket->read_info); } -void grpc_socket_become_ready(grpc_winsocket* socket,+bool grpc_socket_become_ready(grpc_winsocket* socket,                               grpc_winsocket_callback_info* info) {-  GPR_ASSERT(!info->has_pending_iocp);","If the read/write state already had a pending iocp registered, there is something very wrong here. Only one read/write should ever be left outstanding, and crashing is probably better than mysterious data loss. This check should remain.",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/32578,1142459002,2023-03-20T17:19:09Z,bazel/grpc_deps.bzl,"@@ -100,6 +100,16 @@ def grpc_deps():         actual = ""@com_google_googletest//:gtest"",     ) +    native.bind(",Does someone have an AI to remove external_deps from our build system then?Just saying it's deprecated and not doing the cleanup seems not great.,
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32657,1143711073,2023-03-21T16:49:27Z,src/core/ext/filters/client_channel/lb_policy/weighted_round_robin/weighted_round_robin.cc,"@@ -381,16 +386,23 @@ WeightedRoundRobin::AddressWeight::~AddressWeight() { }  void WeightedRoundRobin::AddressWeight::MaybeUpdateWeight(-    double qps, double cpu_utilization) {+    double qps, double eps, double cpu_utilization) {   // Compute weight.   float weight = 0;-  if (qps > 0 && cpu_utilization > 0) weight = qps / cpu_utilization;+  if (qps > 0 && cpu_utilization > 0) {+    double penalty = 0.0;+    if (eps > 0 && wrr_->config_->error_utilization_penalty() > 0) {","It's not safe to access `wrr_->config_` from here, because that field can be updated in another thread within the `WorkSerializer` at the same time that this thread is executing this code.Instead, I suggest changing both `Picker` and `OobWatcher` to store their own copies of `error_utilization_penalty`, which will be initialized from the current config when those objects are instantiated.  We can then pass that value into `MaybeUpdateWeight()` when we call it from those objects.  (Note that this is the way I was originally handling the blackout period before we moved that code from `MaybeUpdateWeight()` to `GetWeight()`; see https://github.com/grpc/grpc/pull/31904/commits/c3f4b67c4a50f6a96bafa32950c582e81dad4fce.)",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32657,1143766969,2023-03-21T17:28:17Z,src/core/ext/filters/client_channel/lb_policy/xds/xds_cluster_impl.cc,"@@ -332,7 +333,13 @@ class XdsClusterImplLb::Picker::SubchannelCallTracker     }     // Record call completion for load reporting.     if (locality_stats_ != nullptr) {-      locality_stats_->AddCallFinished(!args.status.ok());+      const std::map<absl::string_view, double>* named_metrics = nullptr;+      if (args.backend_metric_accessor != nullptr &&","`args.backend_metric_accessor` will never be null.  Also, it seems cleaner to not call `GetBackendMetricData()` multiple times.I suggest writing this as:```auto* backend_metric_data = args.backend_metric_accessor->GetBackendMetricData();if (backend_metric_data != nullptr) {  named_metrics = backend_metric_data->named_metrics;}```",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32657,1143769524,2023-03-21T17:30:21Z,src/core/ext/xds/xds_client_stats.h,"@@ -215,27 +216,32 @@ class XdsClusterLocalityStats : public RefCounted<XdsClusterLocalityStats> {   Snapshot GetSnapshotAndReset();    void AddCallStarted();-  void AddCallFinished(bool fail = false);+  void AddCallFinished(const std::map<absl::string_view, double>* named_metrics,",Suggest making this parameter a reference instead of a pointer.,
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32657,1143814427,2023-03-21T18:08:27Z,test/cpp/end2end/client_lb_end2end_test.cc,"@@ -408,7 +418,7 @@ class ClientLbEnd2endTest : public ::testing::Test {   void SendRpcsUntil(       const grpc_core::DebugLocation& debug_location,       const std::unique_ptr<grpc::testing::EchoTestService::Stub>& stub,-      std::function<bool(const Status&)> continue_predicate,+      const std::function<bool(const Status&)>& continue_predicate,","I don't think it makes sense to use a const reference for `std::function<>` parameters, since basically everywhere that we call them, we pass in a literal (a lambda) instead of an external `std::function<>` variable.Same thing for `WaitForServer()` and `WaitForServers()`.  Note that `WaitForServer()` can use `std::move()` to pass the function to `WaitForServers()`.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32657,1143818077,2023-03-21T18:11:52Z,test/cpp/end2end/client_lb_end2end_test.cc,"@@ -1323,7 +1333,7 @@ TEST_F(PickFirstTest, FailsEmptyResolverUpdate) {   grpc_core::Notification notification;   grpc_core::Resolver::Result result;   result.addresses.emplace();-  result.result_health_callback = [&](absl::Status status) {+  result.result_health_callback = [&](const absl::Status& status) {","It doesn't make sense for the result health callback parameter to be a const reference, since the client channel explicitly passes ownership of the argument with `std::move()`:https://github.com/grpc/grpc/blob/91d64a3774bfe83f1e3efb51fef2409fcff45b5b/src/core/ext/filters/client_channel/client_channel.cc#L1346",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32657,1143850487,2023-03-21T18:40:47Z,test/cpp/end2end/xds/xds_end2end_test_lib.h,"@@ -769,6 +781,12 @@ class XdsEnd2endTest : public ::testing::TestWithParam<XdsTestType> {       return *this;     } +    RpcOptions& set_request_modifier(","I think this approach is inconsistent with the existing API pattern here, which is to have a separate option for each field that we need to set in the request message (e.g., `server_sleep_us` or `server_expected_error`).  Using a callback here is unnecessary generalization that makes tests harder to read and introduces the possibility of conflicts between what the callback will do and the other existing fields here.Instead, please do something like this:```absl::optional<xds::data::orca::v3::OrcaLoadReport> orca_load_report;RpcOptions& set_orca_load_report(    absl::optional<xds::data::orca::v3::OrcaLoadReport> load_report) {  orca_load_report = std::move(load_report);  return *this;}```Then have `SetupRpc()` check whether `orca_load_report.has_value()` is true, and if so set this field in the proto the same way it's doing with the others.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/31119,1143920224,2023-03-21T19:50:29Z,src/core/ext/filters/client_channel/http_proxy.cc,"@@ -52,6 +57,30 @@ namespace grpc_core { namespace { +bool ServerInCIDRRange(std::string server_host,",This parameter should be `absl::string_view` to avoid an unnecessary string copy.,
12451183,temawi,https://api.github.com/repos/grpc/grpc/pulls/32686,1145459923,2023-03-22T22:11:05Z,doc/xds-test-descriptions.md,"@@ -779,4 +779,50 @@ that during some 10-second interval, all traffic goes to the other four backends and all requests end with the `OK` status. 3.  The test driver removes the client configuration to send metadata. The driver asserts that during some 10-second interval, traffic is equally-distributed among the five backends, and all requests end with the `OK` status.\ No newline at end of file+distributed among the five backends, and all requests end with the `OK` status.++### custom_lb+This test verifies that a custom load balancer policy can be configured in the+client. It also verifies that when given a list of policies the client can+ignore a bad one and try the next one on the list until it finds a good one.++Client parameters:++1.  --num_channels=1+2.  --qps=100++Load balancer configuration:++One MIG with a single backend.","MIG = Managed Instance Group, used to manage multiple VMs as a grouphttps://cloud.google.com/compute/docs/instance-groupsIt's used elsewhere in this file so I just followed the pattern.",
12451183,temawi,https://api.github.com/repos/grpc/grpc/pulls/32686,1145468095,2023-03-22T22:22:57Z,doc/xds-test-descriptions.md,"@@ -779,4 +779,50 @@ that during some 10-second interval, all traffic goes to the other four backends and all requests end with the `OK` status. 3.  The test driver removes the client configuration to send metadata. The driver asserts that during some 10-second interval, traffic is equally-distributed among the five backends, and all requests end with the `OK` status.\ No newline at end of file+distributed among the five backends, and all requests end with the `OK` status.++### custom_lb+This test verifies that a custom load balancer policy can be configured in the+client. It also verifies that when given a list of policies the client can+ignore a bad one and try the next one on the list until it finds a good one.++Client parameters:++1.  --num_channels=1+2.  --qps=100++Load balancer configuration:++One MIG with a single backend.++The `backendService` will have the following `localityLbPolicies` entry:",I added language that explains what the LB should do. For reference you can look at the Java implementation here: https://github.com/grpc/grpc-java/blob/master/interop-testing/src/main/java/io/grpc/testing/integration/RpcBehaviorLoadBalancerProvider.javaWe can't use service config directly like this because the idea is to test things end to end with Traffic Director. The test will set up the GCP backendService with this custom LB config and TD passes it down to the client that will read it and set up load balancing accordingly. The test itself is here: https://github.com/grpc/grpc/blob/master/tools/run_tests/xds_k8s_test_driver/tests/custom_lb_test.py,
85715732,yousukseung,https://api.github.com/repos/grpc/grpc/pulls/32657,1145533584,2023-03-22T23:55:26Z,test/cpp/end2end/client_lb_end2end_test.cc,"@@ -2607,28 +2645,112 @@ TEST_F(ClientLbInterceptTrailingMetadataTest, BackendMetricData) {     CheckRpcSendOk(DEBUG_LOCATION, stub, false, &load_report);     auto actual = backend_load_report();     ASSERT_TRUE(actual.has_value());-    // TODO(roth): Change this to use EqualsProto() once that becomes-    // available in OSS.-    EXPECT_EQ(actual->cpu_utilization(), expected.cpu_utilization());-    EXPECT_EQ(actual->mem_utilization(), expected.mem_utilization());-    EXPECT_EQ(actual->rps_fractional(), expected.rps_fractional());-    EXPECT_EQ(actual->request_cost().size(), expected.request_cost().size());-    for (const auto& p : actual->request_cost()) {-      auto it = expected.request_cost().find(p.first);-      ASSERT_NE(it, expected.request_cost().end());-      EXPECT_EQ(it->second, p.second);+    CheckLoadReportAsExpected(*actual, expected);+  }+  // Check LB policy name for the channel.+  EXPECT_EQ(""intercept_trailing_metadata_lb"",+            channel->GetLoadBalancingPolicyName());+  EXPECT_EQ(kNumRpcs, num_trailers_intercepted());+}++TEST_F(ClientLbInterceptTrailingMetadataTest, BackendMetricDataMerge) {+  const int kNumServers = 1;+  const int kNumRpcs = 10;+  StartServers(kNumServers);+  servers_[0]->server_metric_recorder_->SetCpuUtilization(0.99);+  servers_[0]->server_metric_recorder_->SetMemoryUtilization(0.99);+  servers_[0]->server_metric_recorder_->SetQps(0.99);+  servers_[0]->server_metric_recorder_->SetEps(0.99);+  servers_[0]->server_metric_recorder_->SetNamedUtilization(""foo"", 0.99);+  servers_[0]->server_metric_recorder_->SetNamedUtilization(""bar"", 0.1);+  xds::data::orca::v3::OrcaLoadReport per_server_load;+  per_server_load.set_cpu_utilization(0.99);+  per_server_load.set_mem_utilization(0.99);+  per_server_load.set_rps_fractional(0.99);+  per_server_load.set_eps(0.99);+  (*per_server_load.mutable_utilization())[""foo""] = 0.99;+  (*per_server_load.mutable_utilization())[""bar""] = 0.1;+  auto response_generator = BuildResolverResponseGenerator();+  auto channel =+      BuildChannel(""intercept_trailing_metadata_lb"", response_generator);+  auto stub = BuildStub(channel);+  response_generator.SetNextResolution(GetServersPorts());+  size_t total_num_rpcs = 0;+  {+    xds::data::orca::v3::OrcaLoadReport load_report;+    load_report.set_cpu_utilization(0.5);+    auto expected = per_server_load;+    expected.set_cpu_utilization(0.5);+    for (size_t i = 0; i < kNumRpcs; ++i) {+      CheckRpcSendOk(DEBUG_LOCATION, stub, false, &load_report);+      auto actual = backend_load_report();+      ASSERT_TRUE(actual.has_value());+      CheckLoadReportAsExpected(*actual, expected);+      ++total_num_rpcs;+    }+  }+  {+    xds::data::orca::v3::OrcaLoadReport load_report;+    load_report.set_mem_utilization(0.5);+    auto expected = per_server_load;+    expected.set_mem_utilization(0.5);+    for (size_t i = 0; i < kNumRpcs; ++i) {+      CheckRpcSendOk(DEBUG_LOCATION, stub, false, &load_report);+      auto actual = backend_load_report();+      ASSERT_TRUE(actual.has_value());+      CheckLoadReportAsExpected(*actual, expected);+      ++total_num_rpcs;+    }+  }+  {+    xds::data::orca::v3::OrcaLoadReport load_report;+    load_report.set_rps_fractional(0.5);+    auto expected = per_server_load;+    expected.set_rps_fractional(0.5);+    for (size_t i = 0; i < kNumRpcs; ++i) {+      CheckRpcSendOk(DEBUG_LOCATION, stub, false, &load_report);+      auto actual = backend_load_report();+      ASSERT_TRUE(actual.has_value());+      CheckLoadReportAsExpected(*actual, expected);+      ++total_num_rpcs;     }-    EXPECT_EQ(actual->utilization().size(), expected.utilization().size());-    for (const auto& p : actual->utilization()) {-      auto it = expected.utilization().find(p.first);-      ASSERT_NE(it, expected.utilization().end());-      EXPECT_EQ(it->second, p.second);+  }+  {+    xds::data::orca::v3::OrcaLoadReport load_report;+    load_report.set_eps(0.5);+    auto expected = per_server_load;+    expected.set_eps(0.5);+    for (size_t i = 0; i < kNumRpcs; ++i) {+      CheckRpcSendOk(DEBUG_LOCATION, stub, false, &load_report);+      auto actual = backend_load_report();+      ASSERT_TRUE(actual.has_value());+      CheckLoadReportAsExpected(*actual, expected);+      ++total_num_rpcs;     }   }+  {+    xds::data::orca::v3::OrcaLoadReport load_report;+    auto& utilization = *load_report.mutable_utilization();","This test is for merge precedence but we only have the (named) utilization in ServerMetricRecorder to check, along with top-level scalars.",
85715732,yousukseung,https://api.github.com/repos/grpc/grpc/pulls/32690,1145659990,2023-03-23T04:11:14Z,src/core/ext/xds/xds_client_stats.h,"@@ -215,27 +216,32 @@ class XdsClusterLocalityStats : public RefCounted<XdsClusterLocalityStats> {   Snapshot GetSnapshotAndReset();    void AddCallStarted();-  void AddCallFinished(bool fail = false);+  void AddCallFinished(const std::map<absl::string_view, double>* named_metrics,","> Suggest making this parameter a reference instead of a pointer.I switched to a pointer to make it nullable so that I can avoid allocating an empty map when there's no load report, which I think is worth it here. From what I read GetBackendMetricData() wil return null if ""endpoint-load-metrics-bin"" trailing metadata is missing.",
85715732,yousukseung,https://api.github.com/repos/grpc/grpc/pulls/32690,1145661580,2023-03-23T04:15:25Z,test/cpp/end2end/xds/xds_end2end_test_lib.h,"@@ -769,6 +783,12 @@ class XdsEnd2endTest : public ::testing::TestWithParam<XdsTestType> {       return *this;     } +    RpcOptions& set_backend_metrics(",> I think this approach is inconsistent with the existing API pattern here...Updated,
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/32676,1146370922,2023-03-23T15:25:03Z,tools/internal_ci/linux/pull_request/grpc_bazel_rbe_fuzztest.cfg,"@@ -0,0 +1,47 @@+# Copyright 2023 The gRPC Authors","I assume you've tested the config by e.g. temporarily renaming this file to e.g. tools/internal_ci/linux/pull_request/grpc_bazel_rbe_asan.cfg (""hijack"" ASAN job) and then checking that the ""ASAN"" tests on a PR are green (and then removing the hijacking commit in the final version of the PR).",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32657,1146400630,2023-03-23T15:45:56Z,src/core/ext/filters/client_channel/lb_policy/weighted_round_robin/weighted_round_robin.cc,"@@ -121,10 +121,13 @@ class WeightedRoundRobinConfig : public LoadBalancingPolicy::Config {     return loader;   } -  void JsonPostLoad(const Json&, const JsonArgs&, ValidationErrors*) {+  void JsonPostLoad(const Json&, const JsonArgs&, ValidationErrors* error) {     // Impose lower bound of 100ms on weightUpdatePeriod.     weight_update_period_ =         std::max(weight_update_period_, Duration::Milliseconds(100));+    if (error_utilization_penalty() < 0) {",Please directly use the `error_utilization_penalty_` data member instead of calling the public accessor method.,
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32657,1146402630,2023-03-23T15:47:23Z,src/core/ext/filters/client_channel/lb_policy/weighted_round_robin/weighted_round_robin.cc,"@@ -121,10 +121,13 @@ class WeightedRoundRobinConfig : public LoadBalancingPolicy::Config {     return loader;   } -  void JsonPostLoad(const Json&, const JsonArgs&, ValidationErrors*) {+  void JsonPostLoad(const Json&, const JsonArgs&, ValidationErrors* error) {",Please call this parameter `errors` (plural).,
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32657,1146409013,2023-03-23T15:51:55Z,src/core/ext/filters/client_channel/lb_policy/weighted_round_robin/weighted_round_robin.cc,"@@ -412,9 +424,8 @@ void WeightedRoundRobin::AddressWeight::MaybeUpdateWeight(   if (GRPC_TRACE_FLAG_ENABLED(grpc_lb_wrr_trace)) {     gpr_log(GPR_INFO,             ""[WRR %p] subchannel %s: qps=%f, eps=%f, cpu_utilization=%f ""-            ""error_util_penalty=%f : setting ""-            ""weight=%f old_weight_=%f now=%s last_update_time_=%s ""-            ""non_empty_since_=%s"",+            ""error_util_penalty=%f : setting weight=%f old_weight=%f now=%s ""","Please re-add the trailing underscores on the data member fields, to make it clear that they are existing state.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32690,1146453658,2023-03-23T16:23:58Z,src/core/ext/xds/xds_client_stats.h,"@@ -215,27 +216,32 @@ class XdsClusterLocalityStats : public RefCounted<XdsClusterLocalityStats> {   Snapshot GetSnapshotAndReset();    void AddCallStarted();-  void AddCallFinished(bool fail = false);+  void AddCallFinished(const std::map<absl::string_view, double>* named_metrics,+                       bool fail = false);   private:+  struct Stats {+    std::atomic<uint64_t> total_successful_requests{0};+    std::atomic<uint64_t> total_requests_in_progress{0};+    std::atomic<uint64_t> total_error_requests{0};+    std::atomic<uint64_t> total_issued_requests{0};++    // Protects backend_metrics. A mutex is necessary because the length of+    // backend_metrics_ can be accessed by both the callback intercepting the+    // call's recv_trailing_metadata (not from the control plane work","Please remove both of the parentheticals here about the control plane work serializer.  The threading model has changed a bit since this comment was written, and it no longer makes sense to talk about the work serializer here.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32690,1146467939,2023-03-23T16:34:55Z,test/cpp/end2end/xds/xds_end2end_test_lib.h,"@@ -769,6 +783,12 @@ class XdsEnd2endTest : public ::testing::TestWithParam<XdsTestType> {       return *this;     } +    RpcOptions& set_backend_metrics(+        const xds::data::orca::v3::OrcaLoadReport& metrics) {","The parameter should be of type `absl::optional<xds::data::orca::v3::OrcaLoadReport>`, so that it's possible to reset the value to nullopt once it's been set.",
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/32689,1146529769,2023-03-23T17:20:55Z,test/core/event_engine/fuzzing_event_engine/fuzzing_event_engine.h,"@@ -48,62 +57,196 @@ class FuzzingEventEngine : public EventEngine {   };   explicit FuzzingEventEngine(Options options,                               const fuzzing_event_engine::Actions& actions);-  ~FuzzingEventEngine() override = default;+  ~FuzzingEventEngine() override { UnsetGlobalHooks(); } -  void FuzzingDone();-  void Tick();+  // Once the fuzzing work is completed, this method should be called to speed+  // quiescence.+  void FuzzingDone() ABSL_LOCKS_EXCLUDED(mu_);+  // Increment time once and perform any scheduled work.+  void Tick() ABSL_LOCKS_EXCLUDED(mu_);    absl::StatusOr<std::unique_ptr<Listener>> CreateListener(       Listener::AcceptCallback on_accept,       absl::AnyInvocable<void(absl::Status)> on_shutdown,       const EndpointConfig& config,       std::unique_ptr<MemoryAllocatorFactory> memory_allocator_factory)-      override;+      ABSL_LOCKS_EXCLUDED(mu_) override;    ConnectionHandle Connect(OnConnectCallback on_connect,                            const ResolvedAddress& addr,                            const EndpointConfig& args,-                           MemoryAllocator memory_allocator,-                           Duration timeout) override;+                           MemoryAllocator memory_allocator, Duration timeout)+      ABSL_LOCKS_EXCLUDED(mu_) override; -  bool CancelConnect(ConnectionHandle handle) override;+  bool CancelConnect(ConnectionHandle handle) ABSL_LOCKS_EXCLUDED(mu_) override;    bool IsWorkerThread() override;    std::unique_ptr<DNSResolver> GetDNSResolver(       const DNSResolver::ResolverOptions& options) override; -  void Run(Closure* closure) override;-  void Run(absl::AnyInvocable<void()> closure) override;-  TaskHandle RunAfter(Duration when, Closure* closure) override;-  TaskHandle RunAfter(Duration when,-                      absl::AnyInvocable<void()> closure) override;-  bool Cancel(TaskHandle handle) override;+  void Run(Closure* closure) ABSL_LOCKS_EXCLUDED(mu_) override;+  void Run(absl::AnyInvocable<void()> closure)+      ABSL_LOCKS_EXCLUDED(mu_) override;+  TaskHandle RunAfter(Duration when, Closure* closure)+      ABSL_LOCKS_EXCLUDED(mu_) override;+  TaskHandle RunAfter(Duration when, absl::AnyInvocable<void()> closure)+      ABSL_LOCKS_EXCLUDED(mu_) override;+  bool Cancel(TaskHandle handle) ABSL_LOCKS_EXCLUDED(mu_) override;    using Time = std::chrono::time_point<FuzzingEventEngine, Duration>;    Time Now() ABSL_LOCKS_EXCLUDED(mu_); -  static void SetGlobalNowImplEngine(FuzzingEventEngine* engine)-      ABSL_LOCKS_EXCLUDED(mu_);-  static void UnsetGlobalNowImplEngine(FuzzingEventEngine* engine)-      ABSL_LOCKS_EXCLUDED(mu_);+  // Clear any global hooks installed by this event engine. Call prior to+  // destruction to ensure no overlap between tests if constructing/destructing+  // each test.+  void UnsetGlobalHooks() ABSL_LOCKS_EXCLUDED(mu_);   private:+  // One pending task to be run.   struct Task {     Task(intptr_t id, absl::AnyInvocable<void()> closure)         : id(id), closure(std::move(closure)) {}     intptr_t id;     absl::AnyInvocable<void()> closure;   }; +  // Per listener information.+  // We keep a shared_ptr to this, one reference held by the FuzzingListener+  // Listener implementation, and one reference in the event engine state, so it+  // may be iterated through and inspected - principally to discover the ports+  // on which this listener is listening.+  struct ListenerInfo {+    ListenerInfo(+        Listener::AcceptCallback on_accept,+        absl::AnyInvocable<void(absl::Status)> on_shutdown,+        std::unique_ptr<MemoryAllocatorFactory> memory_allocator_factory)+        : on_accept(std::move(on_accept)),+          on_shutdown(std::move(on_shutdown)),+          memory_allocator_factory(std::move(memory_allocator_factory)),+          started(false) {}+    ~ListenerInfo() ABSL_LOCKS_EXCLUDED(mu_);+    // The callback to invoke when a new connection is accepted.+    Listener::AcceptCallback on_accept;+    // The callback to invoke when the listener is shut down.+    absl::AnyInvocable<void(absl::Status)> on_shutdown;+    // The memory allocator factory to use for this listener.+    const std::unique_ptr<MemoryAllocatorFactory> memory_allocator_factory;+    // The ports on which this listener is listening.+    std::vector<int> ports ABSL_GUARDED_BY(mu_);+    // Has start been called on the listener?+    // Used to emulate the Bind/Start semantics demanded by the API.+    bool started ABSL_GUARDED_BY(mu_);+    // The status to return via on_shutdown.+    absl::Status shutdown_status ABSL_GUARDED_BY(mu_) = absl::OkStatus();+  };++  // Implementation of Listener.+  class FuzzingListener final : public Listener {+   public:+    explicit FuzzingListener(std::shared_ptr<ListenerInfo> info)+        : info_(std::move(info)) {}+    ~FuzzingListener() override;+    absl::StatusOr<int> Bind(const ResolvedAddress& addr) override;+    absl::Status Start() override;++   private:+    std::shared_ptr<ListenerInfo> info_;+  };++  // One read that's outstanding.+  struct PendingRead {+    // Callback to invoke when the read completes.+    absl::AnyInvocable<void(absl::Status)> on_read;+    // The buffer to read into.+    SliceBuffer* buffer;+  };++  // The join between two Endpoint instances.+  struct EndpointMiddle {+    EndpointMiddle(int listener_port, int client_port)+        ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu_);+    // Address of each side of the endpoint.+    const ResolvedAddress addrs[2];+    // Is the endpoint closed?+    bool closed ABSL_GUARDED_BY(mu_) = false;+    // Bytes written into each endpoint and awaiting a read.+    std::vector<uint8_t> pending[2] ABSL_GUARDED_BY(mu_){+        std::vector<uint8_t>(), std::vector<uint8_t>()};+    // The sizes of each accepted write, as determined by the fuzzer actions.+    std::queue<size_t> write_sizes[2] ABSL_GUARDED_BY(mu_);+    // The next read that's pending (or nullopt).+    absl::optional<PendingRead> pending_read[2] ABSL_GUARDED_BY(mu_);++    // Helper to take some bytes from data and queue them into pending[index].+    // Returns true if all bytes were consumed, false if more writes are needed.+    bool Write(SliceBuffer* data, int index) ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu_);+  };++  // Implementation of Endpoint.+  // When a connection is formed, we create two of these - one with index 0, the+  // other index 1, both pointing to the same EndpointMiddle.+  class FuzzingEndpoint final : public Endpoint {+   public:+    FuzzingEndpoint(std::shared_ptr<EndpointMiddle> middle, int index)+        : middle_(std::move(middle)), index_(index) {}+    ~FuzzingEndpoint() override;++    bool Read(absl::AnyInvocable<void(absl::Status)> on_read,+              SliceBuffer* buffer, const ReadArgs* args) override;+    bool Write(absl::AnyInvocable<void(absl::Status)> on_writable,+               SliceBuffer* data, const WriteArgs* args) override;+    const ResolvedAddress& GetPeerAddress() const override {+      return middle_->addrs[peer_index()];+    }+    const ResolvedAddress& GetLocalAddress() const override {+      return middle_->addrs[my_index()];+    }++   private:+    int my_index() const { return index_; }+    int peer_index() const { return 1 - index_; }+    // Schedule additional writes to be performed later.+    // Takes a ref to middle instead of holding this, so that should the+    // endpoint be destroyed we don't have to worry about use-after-free.+    // Instead that scheduled callback will see the middle is closed and finally+    // report completion to the caller.+    // Since there is no timeliness contract for the completion of writes after+    // endpoint shutdown, it's believed this is a legal implementation.+    static void ScheduleDelayedWrite(+        std::shared_ptr<EndpointMiddle> middle, int index,+        absl::AnyInvocable<void(absl::Status)> on_writable, SliceBuffer* data)+        ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu_);+    std::shared_ptr<EndpointMiddle> middle_;+    int index_;+  };++  void RunLocked(absl::AnyInvocable<void()> closure)+      ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu_) {+    RunAfterLocked(Duration::zero(), std::move(closure));+  }++  TaskHandle RunAfterLocked(Duration when, absl::AnyInvocable<void()> closure)+      ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu_);++  // Allocate a port. Considered fuzzer selected port orderings first, and then+  // falls back to an exhaustive incremental search from port #1.+  int AllocatePort() ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu_);+  // Is the given port in use by any listener?+  bool IsPortUsed(int port) ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu_);+  // For the next connection being built, query the list of fuzzer selected+  // write size limits.+  std::queue<size_t> WriteSizesForConnection()+      ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu_);+   gpr_timespec NowAsTimespec(gpr_clock_type clock_type)       ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu_);   static gpr_timespec GlobalNowImpl(gpr_clock_type clock_type)       ABSL_LOCKS_EXCLUDED(mu_);   const Duration final_tick_length_; -  grpc_core::Mutex mu_;+  static grpc_core::NoDestruct<grpc_core::Mutex> mu_;","This should come with a big warning at the top that says there can only be exactly one FuzzingEventEngine alive at any given time. I know that's how it's intended to be used today, but I this class might get used more widely.",
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/32610,1146572007,2023-03-23T17:45:50Z,src/core/ext/filters/client_channel/retry_filter.cc,"@@ -548,8 +551,9 @@ class RetryFilter::CallData {   // If server_pushback is nullopt, retry_backoff_ is used.   void StartRetryTimer(absl::optional<Duration> server_pushback); -  static void OnRetryTimer(void* arg, grpc_error_handle error);-  static void OnRetryTimerLocked(void* arg, grpc_error_handle error);+  void OnRetryTimer();+  static void OnRetryTimerLocked(void* arg,+                                 GRPC_UNUSED grpc_error_handle error);","`GRPC_UNUSED` isn't portable, right? I suspect that MSVC builds might complain if unused variable warnings were enabled.https://github.com/grpc/grpc/blob/43c3d1f932da02c334e71dc5a9cd998755be5ff7/include/grpc/support/port_platform.h#L589-L595",X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32610,1146625375,2023-03-23T18:08:10Z,src/core/ext/filters/client_channel/retry_filter.cc,"@@ -1241,68 +1244,67 @@ void RetryFilter::CallData::CallAttempt::Abandon() {   on_complete_deferred_batches_.clear(); } -void RetryFilter::CallData::CallAttempt::OnPerAttemptRecvTimer(-    void* arg, grpc_error_handle error) {-  auto* call_attempt = static_cast<CallAttempt*>(arg);-  GRPC_CLOSURE_INIT(&call_attempt->on_per_attempt_recv_timer_,-                    OnPerAttemptRecvTimerLocked, call_attempt, nullptr);-  GRPC_CALL_COMBINER_START(call_attempt->calld_->call_combiner_,-                           &call_attempt->on_per_attempt_recv_timer_, error,-                           ""per-attempt timer fired"");+void RetryFilter::CallData::CallAttempt::OnPerAttemptRecvTimer() {+  GRPC_CLOSURE_INIT(&on_per_attempt_recv_timer_, OnPerAttemptRecvTimerLocked,+                    this, nullptr);+  GRPC_CALL_COMBINER_START(calld_->call_combiner_, &on_per_attempt_recv_timer_,+                           absl::OkStatus(), ""per-attempt timer fired""); }  void RetryFilter::CallData::CallAttempt::OnPerAttemptRecvTimerLocked(-    void* arg, grpc_error_handle error) {+    void* arg, GRPC_UNUSED grpc_error_handle error) {+  GPR_DEBUG_ASSERT(error.ok());   auto* call_attempt = static_cast<CallAttempt*>(arg);   auto* calld = call_attempt->calld_;   if (GRPC_TRACE_FLAG_ENABLED(grpc_retry_trace)) {     gpr_log(GPR_INFO,             ""chand=%p calld=%p attempt=%p: perAttemptRecvTimeout timer fired: ""-            ""error=%s, per_attempt_recv_timer_pending_=%d"",-            calld->chand_, calld, call_attempt, StatusToString(error).c_str(),-            call_attempt->per_attempt_recv_timer_pending_);+            ""error=%s"",","Since we no longer have `per_attempt_recv_timer_pending_`, let's instead log `per_attempt_recv_timer_handle_.has_value()`.",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/32689,1146688085,2023-03-23T18:56:49Z,test/core/event_engine/fuzzing_event_engine/fuzzing_event_engine.h,"@@ -48,62 +57,196 @@ class FuzzingEventEngine : public EventEngine {   };   explicit FuzzingEventEngine(Options options,                               const fuzzing_event_engine::Actions& actions);-  ~FuzzingEventEngine() override = default;+  ~FuzzingEventEngine() override { UnsetGlobalHooks(); } -  void FuzzingDone();-  void Tick();+  // Once the fuzzing work is completed, this method should be called to speed+  // quiescence.+  void FuzzingDone() ABSL_LOCKS_EXCLUDED(mu_);+  // Increment time once and perform any scheduled work.+  void Tick() ABSL_LOCKS_EXCLUDED(mu_);    absl::StatusOr<std::unique_ptr<Listener>> CreateListener(       Listener::AcceptCallback on_accept,       absl::AnyInvocable<void(absl::Status)> on_shutdown,       const EndpointConfig& config,       std::unique_ptr<MemoryAllocatorFactory> memory_allocator_factory)-      override;+      ABSL_LOCKS_EXCLUDED(mu_) override;    ConnectionHandle Connect(OnConnectCallback on_connect,                            const ResolvedAddress& addr,                            const EndpointConfig& args,-                           MemoryAllocator memory_allocator,-                           Duration timeout) override;+                           MemoryAllocator memory_allocator, Duration timeout)+      ABSL_LOCKS_EXCLUDED(mu_) override; -  bool CancelConnect(ConnectionHandle handle) override;+  bool CancelConnect(ConnectionHandle handle) ABSL_LOCKS_EXCLUDED(mu_) override;    bool IsWorkerThread() override;    std::unique_ptr<DNSResolver> GetDNSResolver(       const DNSResolver::ResolverOptions& options) override; -  void Run(Closure* closure) override;-  void Run(absl::AnyInvocable<void()> closure) override;-  TaskHandle RunAfter(Duration when, Closure* closure) override;-  TaskHandle RunAfter(Duration when,-                      absl::AnyInvocable<void()> closure) override;-  bool Cancel(TaskHandle handle) override;+  void Run(Closure* closure) ABSL_LOCKS_EXCLUDED(mu_) override;+  void Run(absl::AnyInvocable<void()> closure)+      ABSL_LOCKS_EXCLUDED(mu_) override;+  TaskHandle RunAfter(Duration when, Closure* closure)+      ABSL_LOCKS_EXCLUDED(mu_) override;+  TaskHandle RunAfter(Duration when, absl::AnyInvocable<void()> closure)+      ABSL_LOCKS_EXCLUDED(mu_) override;+  bool Cancel(TaskHandle handle) ABSL_LOCKS_EXCLUDED(mu_) override;    using Time = std::chrono::time_point<FuzzingEventEngine, Duration>;    Time Now() ABSL_LOCKS_EXCLUDED(mu_); -  static void SetGlobalNowImplEngine(FuzzingEventEngine* engine)-      ABSL_LOCKS_EXCLUDED(mu_);-  static void UnsetGlobalNowImplEngine(FuzzingEventEngine* engine)-      ABSL_LOCKS_EXCLUDED(mu_);+  // Clear any global hooks installed by this event engine. Call prior to+  // destruction to ensure no overlap between tests if constructing/destructing+  // each test.+  void UnsetGlobalHooks() ABSL_LOCKS_EXCLUDED(mu_);   private:+  // One pending task to be run.   struct Task {     Task(intptr_t id, absl::AnyInvocable<void()> closure)         : id(id), closure(std::move(closure)) {}     intptr_t id;     absl::AnyInvocable<void()> closure;   }; +  // Per listener information.+  // We keep a shared_ptr to this, one reference held by the FuzzingListener+  // Listener implementation, and one reference in the event engine state, so it+  // may be iterated through and inspected - principally to discover the ports+  // on which this listener is listening.+  struct ListenerInfo {+    ListenerInfo(+        Listener::AcceptCallback on_accept,+        absl::AnyInvocable<void(absl::Status)> on_shutdown,+        std::unique_ptr<MemoryAllocatorFactory> memory_allocator_factory)+        : on_accept(std::move(on_accept)),+          on_shutdown(std::move(on_shutdown)),+          memory_allocator_factory(std::move(memory_allocator_factory)),+          started(false) {}+    ~ListenerInfo() ABSL_LOCKS_EXCLUDED(mu_);+    // The callback to invoke when a new connection is accepted.+    Listener::AcceptCallback on_accept;+    // The callback to invoke when the listener is shut down.+    absl::AnyInvocable<void(absl::Status)> on_shutdown;+    // The memory allocator factory to use for this listener.+    const std::unique_ptr<MemoryAllocatorFactory> memory_allocator_factory;+    // The ports on which this listener is listening.+    std::vector<int> ports ABSL_GUARDED_BY(mu_);+    // Has start been called on the listener?+    // Used to emulate the Bind/Start semantics demanded by the API.+    bool started ABSL_GUARDED_BY(mu_);+    // The status to return via on_shutdown.+    absl::Status shutdown_status ABSL_GUARDED_BY(mu_) = absl::OkStatus();+  };++  // Implementation of Listener.+  class FuzzingListener final : public Listener {+   public:+    explicit FuzzingListener(std::shared_ptr<ListenerInfo> info)+        : info_(std::move(info)) {}+    ~FuzzingListener() override;+    absl::StatusOr<int> Bind(const ResolvedAddress& addr) override;+    absl::Status Start() override;++   private:+    std::shared_ptr<ListenerInfo> info_;+  };++  // One read that's outstanding.+  struct PendingRead {+    // Callback to invoke when the read completes.+    absl::AnyInvocable<void(absl::Status)> on_read;+    // The buffer to read into.+    SliceBuffer* buffer;+  };++  // The join between two Endpoint instances.+  struct EndpointMiddle {+    EndpointMiddle(int listener_port, int client_port)+        ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu_);+    // Address of each side of the endpoint.+    const ResolvedAddress addrs[2];+    // Is the endpoint closed?+    bool closed ABSL_GUARDED_BY(mu_) = false;+    // Bytes written into each endpoint and awaiting a read.+    std::vector<uint8_t> pending[2] ABSL_GUARDED_BY(mu_){+        std::vector<uint8_t>(), std::vector<uint8_t>()};+    // The sizes of each accepted write, as determined by the fuzzer actions.+    std::queue<size_t> write_sizes[2] ABSL_GUARDED_BY(mu_);+    // The next read that's pending (or nullopt).+    absl::optional<PendingRead> pending_read[2] ABSL_GUARDED_BY(mu_);++    // Helper to take some bytes from data and queue them into pending[index].+    // Returns true if all bytes were consumed, false if more writes are needed.+    bool Write(SliceBuffer* data, int index) ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu_);+  };++  // Implementation of Endpoint.+  // When a connection is formed, we create two of these - one with index 0, the+  // other index 1, both pointing to the same EndpointMiddle.+  class FuzzingEndpoint final : public Endpoint {+   public:+    FuzzingEndpoint(std::shared_ptr<EndpointMiddle> middle, int index)+        : middle_(std::move(middle)), index_(index) {}+    ~FuzzingEndpoint() override;++    bool Read(absl::AnyInvocable<void(absl::Status)> on_read,+              SliceBuffer* buffer, const ReadArgs* args) override;+    bool Write(absl::AnyInvocable<void(absl::Status)> on_writable,+               SliceBuffer* data, const WriteArgs* args) override;+    const ResolvedAddress& GetPeerAddress() const override {+      return middle_->addrs[peer_index()];+    }+    const ResolvedAddress& GetLocalAddress() const override {+      return middle_->addrs[my_index()];+    }++   private:+    int my_index() const { return index_; }+    int peer_index() const { return 1 - index_; }+    // Schedule additional writes to be performed later.+    // Takes a ref to middle instead of holding this, so that should the+    // endpoint be destroyed we don't have to worry about use-after-free.+    // Instead that scheduled callback will see the middle is closed and finally+    // report completion to the caller.+    // Since there is no timeliness contract for the completion of writes after+    // endpoint shutdown, it's believed this is a legal implementation.+    static void ScheduleDelayedWrite(+        std::shared_ptr<EndpointMiddle> middle, int index,+        absl::AnyInvocable<void(absl::Status)> on_writable, SliceBuffer* data)+        ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu_);+    std::shared_ptr<EndpointMiddle> middle_;+    int index_;+  };++  void RunLocked(absl::AnyInvocable<void()> closure)+      ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu_) {+    RunAfterLocked(Duration::zero(), std::move(closure));+  }++  TaskHandle RunAfterLocked(Duration when, absl::AnyInvocable<void()> closure)+      ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu_);++  // Allocate a port. Considered fuzzer selected port orderings first, and then+  // falls back to an exhaustive incremental search from port #1.+  int AllocatePort() ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu_);+  // Is the given port in use by any listener?+  bool IsPortUsed(int port) ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu_);+  // For the next connection being built, query the list of fuzzer selected+  // write size limits.+  std::queue<size_t> WriteSizesForConnection()+      ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu_);+   gpr_timespec NowAsTimespec(gpr_clock_type clock_type)       ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu_);   static gpr_timespec GlobalNowImpl(gpr_clock_type clock_type)       ABSL_LOCKS_EXCLUDED(mu_);   const Duration final_tick_length_; -  grpc_core::Mutex mu_;+  static grpc_core::NoDestruct<grpc_core::Mutex> mu_;",added a comment: I think we need the constraint.The only other viable design moves the singleton parts out and has multiple FuzzingEventEngine's reaching in - but I'm not sure that that's better.,
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/32689,1146689844,2023-03-23T18:58:08Z,test/core/event_engine/test_suite/tests/client_test.cc,"@@ -96,7 +96,6 @@ TEST_F(EventEngineClientTest, ConnectToNonExistentListenerTest) {       *URIToResolvedAddress(target_addr), config,       memory_quota->CreateMemoryAllocator(""conn-1""), 24h);   signal.WaitForNotification();-  WaitForSingleOwner(std::move(test_ee));","With it we can't share oracle_ee and the event engine under test being the same object, which means (like above) a large change here to have a singleton body around a large shared state object. It's doable, but unwieldy.",
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/32689,1146736056,2023-03-23T19:40:27Z,test/core/util/port_isolated_runtime_environment.cc,"@@ -67,6 +67,10 @@ int grpc_pick_unused_port_or_die(void) {   } } -void grpc_recycle_unused_port(int port) { (void)port; }+static void isolated_recycle_unused_port(int port) { (void)port; }++const auto grpc_isolated_port_picker_prev_fns =","I despise Github's refusal to render ""large"" diffs. It was folded. Reviewing that code now.",
85715732,yousukseung,https://api.github.com/repos/grpc/grpc/pulls/32690,1146864529,2023-03-23T21:13:48Z,src/core/ext/xds/xds_client_stats.h,"@@ -215,27 +216,32 @@ class XdsClusterLocalityStats : public RefCounted<XdsClusterLocalityStats> {   Snapshot GetSnapshotAndReset();    void AddCallStarted();-  void AddCallFinished(bool fail = false);+  void AddCallFinished(const std::map<absl::string_view, double>* named_metrics,","But it requires allocating an empty string unnecessarily unless we make this nullable in some way.In XdsClusterImplLb::Picker::SubchannelCallTracker::Finish() where we call AddCallFinished():```auto* backend_metric_data = args.backend_metric_accessor->GetBackendMetricData();const std::map<absl::string_view, double>* named_metrics = nullptr;if (backend_metric_data != nullptr) {  named_metrics = &backend_metric_data->named_metrics;}locality_stats_->AddCallFinished(named_metrics, !args.status.ok());```vs. Something like (pseudo-code)```auto* backend_metric_data = args.backend_metric_accessor->GetBackendMetricData();std::map<absl::string_view, double> named_metricsif (backend_metric_data == nullptr) {  locality_stats_->AddCallFinished(std::map<..>(), !args.status.ok());} else {  locality_stats_->AddCallFinished(    backend_metric_data->named_metrics, !args.status.ok());}```",
85715732,yousukseung,https://api.github.com/repos/grpc/grpc/pulls/32690,1146864586,2023-03-23T21:13:51Z,src/core/ext/filters/client_channel/lb_policy/weighted_round_robin/weighted_round_robin.cc,,"Yes, will merge after #32657. For future PRs, what's the best practice to chain PRs in github, or do we discourage it? ",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32696,1147782008,2023-03-24T16:00:29Z,src/core/ext/filters/client_channel/subchannel.cc,"@@ -920,7 +920,8 @@ bool Subchannel::PublishTransportLocked() {   // Construct channel stack.   ChannelStackBuilderImpl builder(""subchannel"", GRPC_CLIENT_SUBCHANNEL,                                   connecting_result_.channel_args);-  builder.SetTransport(connecting_result_.transport);+  // Builder takes ownership of transport.+  builder.SetTransport(std::exchange(connecting_result_.transport, nullptr));","With this change, I think we no longer need to set `connecting_result_.transport` to null below (lines 937-939).",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32690,1148023658,2023-03-24T20:27:39Z,test/cpp/end2end/xds/xds_cluster_end2end_test.cc,"@@ -1375,6 +1375,17 @@ INSTANTIATE_TEST_SUITE_P(     ::testing::Values(XdsTestType().set_enable_load_reporting()),     &XdsTestType::Name); +MATCHER_P(LoadMetricEq, other, ""equals LoadMetric"") {","I suggest having this take the num_requests and total_value fields as independent parameters, so that callers don't need to construct a LoadMetric struct in order to call this.  In other words, callers should be able to say `LoadMetricEq(num_requests, total_value)` instead of having to say `LoadMetricEq(ClientStats::LocalityStats::LoadMetric{num_requests, total_value})`.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32690,1148044466,2023-03-24T20:53:05Z,src/core/ext/xds/xds_client_stats.h,"@@ -215,27 +216,32 @@ class XdsClusterLocalityStats : public RefCounted<XdsClusterLocalityStats> {   Snapshot GetSnapshotAndReset();    void AddCallStarted();-  void AddCallFinished(bool fail = false);+  void AddCallFinished(const std::map<absl::string_view, double>* named_metrics,","I don't actually see any new allocation here.  I think it could be written like this:```auto* backend_metric_data = args.backend_metric_accessor->GetBackendMetricData();std::map<absl::string_view, double> empty_map;const auto& named_metrics =    backend_metric_data != nullptr        ? backend_metric_data->named_metrics        : empty_map;locality_stats_->AddCallFinished(named_metrics, !args.status.ok());```I don't believe that declaring a `std::map<>` as a local variable actually does any dynamic allocation if we don't add any entries into the map.That having been said, you're right that this isn't really that much better than the current approach, so I'll leave it up to you.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32690,1148048507,2023-03-24T20:57:37Z,src/core/ext/filters/client_channel/lb_policy/weighted_round_robin/weighted_round_robin.cc,,"In this particular case, I don't think this PR needed to be based on the other one in the first place, since they were really two almost totally unrelated changes.  The only common part was updating the xDS protos, and that could have been done either as an isolated PR that could have been merged before either of the other two PRs, or you could have just included that change in both PRs, knowing that the duplicate changes would go away after the first PR was merged.More generally, when you actually do have one change based on another one, it's fine to base one PR off of another for pipelining purposes.  However, because github doesn't provide an easy way to view the diff relative to the previous in-flight PR, I generally would not expect a reviewer to look at the second PR until the first PR has been merged and then master has been merged into the second PR.",
5663878,yijiem,https://api.github.com/repos/grpc/grpc/pulls/32610,1148078556,2023-03-24T21:33:39Z,src/core/ext/filters/client_channel/retry_filter.cc,"@@ -548,8 +551,9 @@ class RetryFilter::CallData {   // If server_pushback is nullopt, retry_backoff_ is used.   void StartRetryTimer(absl::optional<Duration> server_pushback); -  static void OnRetryTimer(void* arg, grpc_error_handle error);-  static void OnRetryTimerLocked(void* arg, grpc_error_handle error);+  void OnRetryTimer();+  static void OnRetryTimerLocked(void* arg,+                                 GRPC_UNUSED grpc_error_handle error);",Thanks for catching it! `GRPC_UNUSED` is not portable and I couldn't find an equivalent for MSVC easily. There is the `[[maybe_unused]]` C++ attribute but it needs C++17.So I went with this for now (based on our discussion):```GPR_DEBUG_ASSERT(error.ok());#ifdef NDEBUG  (void)error;#endif```,
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32690,1148102156,2023-03-24T22:13:23Z,test/cpp/end2end/xds/xds_end2end_test_lib.h,"@@ -769,6 +783,12 @@ class XdsEnd2endTest : public ::testing::TestWithParam<XdsTestType> {       return *this;     } +    RpcOptions& set_backend_metrics(+        const xds::data::orca::v3::OrcaLoadReport& metrics) {","I don't understand the benefit of using a const reference here.There are two possible cases for the caller:1. They want to retain their own copy of the data they pass in.2. They do not need to retain their own copy of the data they pass in.In case 1, it does not matter if we use a const reference or not, because either way we will make our own copy.  If we use a const reference, we make the copy inside of the method where we assign to the data member; if we take the parameter by value, the copy is made when the method is invoked, and the method's body can use `std::move()` to move that copy to the data member.In case 2, if we take the argument by value, then the caller can use `std::move()` when they invoke the method, and we can still use `std::move()` inside the method, so there is no copy at all.  However, if we use a const reference, then we always make a copy, even though we don't actually need one.This isn't a big deal either way in this case, but it seems strictly better to pass it by value.  I'll leave it up to you.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32610,1148120521,2023-03-24T22:37:39Z,src/core/ext/filters/client_channel/retry_filter.cc,"@@ -548,8 +551,9 @@ class RetryFilter::CallData {   // If server_pushback is nullopt, retry_backoff_ is used.   void StartRetryTimer(absl::optional<Duration> server_pushback); -  static void OnRetryTimer(void* arg, grpc_error_handle error);-  static void OnRetryTimerLocked(void* arg, grpc_error_handle error);+  void OnRetryTimer();+  static void OnRetryTimerLocked(void* arg,+                                 GRPC_UNUSED grpc_error_handle error);","The way we normally deal with this is to just comment out the parameter name, like this:```static void OnRetryTimerLocked(void* arg, grpc_error_handle /*error*/);```",
4181124,yashykt,https://api.github.com/repos/grpc/grpc/pulls/32710,1148134392,2023-03-24T23:08:35Z,examples/cpp/gcp_observability/helloworld/greeter_server.cc,"@@ -0,0 +1,95 @@+//+//+// Copyright 2023 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+//+//++#include <iostream>+#include <memory>+#include <string>++#include ""absl/flags/flag.h""+#include ""absl/flags/parse.h""+#include ""absl/strings/str_format.h""++#include <grpcpp/ext/gcp_observability.h>+#include <grpcpp/ext/proto_server_reflection_plugin.h>+#include <grpcpp/grpcpp.h>+#include <grpcpp/health_check_service_interface.h>++#ifdef BAZEL_BUILD+#include ""examples/protos/helloworld.grpc.pb.h""+#else+#include ""helloworld.grpc.pb.h""+#endif++using grpc::Server;+using grpc::ServerBuilder;+using grpc::ServerContext;+using grpc::Status;+using helloworld::Greeter;+using helloworld::HelloReply;+using helloworld::HelloRequest;++ABSL_FLAG(uint16_t, port, 50051, ""Server port for the service"");++// Logic and data behind the server's behavior.+class GreeterServiceImpl final : public Greeter::Service {+  Status SayHello(ServerContext* context, const HelloRequest* request,+                  HelloReply* reply) override {+    std::string prefix(""Hello "");+    reply->set_message(prefix + request->name());+    return Status::OK;+  }+};++void RunServer(uint16_t port) {+  std::string server_address = absl::StrFormat(""0.0.0.0:%d"", port);+  GreeterServiceImpl service;+  grpc::EnableDefaultHealthCheckService(true);+  grpc::reflection::InitProtoReflectionServerBuilderPlugin();+  ServerBuilder builder;+  // Listen on the given address without any authentication mechanism.+  builder.AddListeningPort(server_address, grpc::InsecureServerCredentials());+  // Register ""service"" as the instance through which we'll communicate with+  // clients. In this case it corresponds to an *synchronous* service.+  builder.RegisterService(&service);+  // Finally assemble the server.+  std::unique_ptr<Server> server(builder.BuildAndStart());+  std::cout << ""Server listening on "" << server_address << std::endl;++  // Wait for the server to shutdown. Note that some other thread must be+  // responsible for shutting down the server for this call to ever return.+  server->Wait();+}++int main(int argc, char** argv) {+  absl::ParseCommandLine(argc, argv);+  // Turn on GCP Observability for the whole binary. Note that this should be+  // done before any other gRPC operation.+  auto status = grpc::experimental::GcpObservabilityInit();+  if (!status.ok()) {+    std::cerr << ""GcpObservabilityInit() failed: "" << status.ToString()+              << std::endl;+    return static_cast<int>(status.code());+  }+  std::cout << ""Initialized GCP Observability"" << std::endl;+  RunServer(absl::GetFlag(FLAGS_port));+  // Note that RunServer() never returns and hence there is no need for a+  // GcpObservabilityClose() here, but as on the client side, we need to wait+  // atleast 25seconds after the last RPC to make sure that stats and tracing+  // are flushed.","Alright, I'll take your comment.. was feeling lazy earlier.",
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/32636,1148359817,2023-03-25T12:13:43Z,src/compiler/csharp_generator_helpers.h,"@@ -22,13 +22,30 @@ #include ""src/compiler/config.h"" #include ""src/compiler/generator_helpers.h"" +using google::protobuf::compiler::csharp::GetOutputFile;+ namespace grpc_csharp_generator {  inline bool ServicesFilename(const grpc::protobuf::FileDescriptor* file,                              const std::string& file_suffix,-                             std::string& out_file_name_or_error) {-  out_file_name_or_error =-      grpc_generator::FileNameInUpperCamel(file, false) + file_suffix;+                             const std::string& base_namespace,+                             std::string& out_file, std::string* error) {+  // Support for base_namespace option is **experimental**.+  //+  // If base_namespace is provided then slightly different name mangling+  // is used to generate the service file name. This is because this+  // uses common code with protoc. For most file names this will not+  // make a difference (only files with punctuation or numbers in the+  // name.)+  // Otherwise the behavor remains the same as before.+  if (base_namespace.empty()) {+    out_file = grpc_generator::FileNameInUpperCamel(file, false) + file_suffix;+  } else {+    out_file = GetOutputFile(file, file_suffix, true, base_namespace, error);",note to self: https://github.com/protocolbuffers/protobuf/blob/5184022a17031c62d3c2e0bd44f2324752812485/src/google/protobuf/compiler/csharp/names.cc#L125,
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/32636,1148360058,2023-03-25T12:15:57Z,src/compiler/csharp_generator_helpers.h,"@@ -22,13 +22,30 @@ #include ""src/compiler/config.h"" #include ""src/compiler/generator_helpers.h"" +using google::protobuf::compiler::csharp::GetOutputFile;+ namespace grpc_csharp_generator {  inline bool ServicesFilename(const grpc::protobuf::FileDescriptor* file,                              const std::string& file_suffix,-                             std::string& out_file_name_or_error) {-  out_file_name_or_error =-      grpc_generator::FileNameInUpperCamel(file, false) + file_suffix;+                             const std::string& base_namespace,+                             std::string& out_file, std::string* error) {+  // Support for base_namespace option is **experimental**.+  //+  // If base_namespace is provided then slightly different name mangling+  // is used to generate the service file name. This is because this+  // uses common code with protoc. For most file names this will not+  // make a difference (only files with punctuation or numbers in the+  // name.)+  // Otherwise the behavor remains the same as before.+  if (base_namespace.empty()) {+    out_file = grpc_generator::FileNameInUpperCamel(file, false) + file_suffix;","wondering why we haven't always been using protobuf's GetOutputFile implementation? It would be good to do a quick check (e.g. take a closer look at history of implementations for grpc and protobuf) to find out the reason just to make sure we didn't forget about anything.Also, looks like at this point we could probably switch to ""GetOutputFile"" implementation for the default case as well, after which file names produces by grpc_csharp_plugin and protoc would be 100% consistent in handling corner cases in file naming. But I think to avoid issues with backward compatibility of the Grpc.Tools msbuild stack (which needs to know the file names exactly) we'd rather not do this.But it's good to know this is an option for future debates.",
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/32636,1148360272,2023-03-25T12:17:43Z,src/compiler/csharp_plugin.cc,"@@ -43,6 +43,8 @@ class CSharpGrpcGenerator : public grpc::protobuf::compiler::CodeGenerator {     bool generate_client = true;     bool generate_server = true;     bool internal_access = false;+    std::string base_namespace = """";","we'll probably need to introduce a bazel test for the grpc_csharp_plugin, that does something similar to the C++ golden file test https://github.com/grpc/grpc/blob/8038d2d87860feecc279346460c7e223fdde7bd9/test/cpp/codegen/BUILD#L93at least having a golden file for C# would be a good way of making the diff in the generated code visible in PR reviews. Also, we could have different variants of the test generate code with different options.",
133680,sampajano,https://api.github.com/repos/grpc/grpc/pulls/32077,1148506530,2023-03-26T08:35:52Z,src/core/lib/event_engine/cf_engine/cf_engine.cc,"@@ -72,14 +76,76 @@ CFEventEngine::CreateListener( }  CFEventEngine::ConnectionHandle CFEventEngine::Connect(-    OnConnectCallback /* on_connect */, const ResolvedAddress& /* addr */,-    const EndpointConfig& /* args */, MemoryAllocator /* memory_allocator */,-    Duration /* timeout */) {-  grpc_core::Crash(""unimplemented"");+    OnConnectCallback on_connect, const ResolvedAddress& addr,+    const EndpointConfig& /* args */, MemoryAllocator memory_allocator,+    Duration timeout) {+  auto endpoint_ptr = new CFStreamEndpoint(+      std::static_pointer_cast<CFEventEngine>(shared_from_this()),+      std::move(memory_allocator));++  ConnectionHandle handle{reinterpret_cast<intptr_t>(endpoint_ptr), 0};+  {+    grpc_core::MutexLock lock(&conn_mu_);+    conn_handles_.insert(handle);+  }++  auto deadline_timer =+      RunAfter(timeout, [handle, that = std::static_pointer_cast<CFEventEngine>(+                                     shared_from_this())]() {+        that->CancelConnectInternal(+            handle, absl::DeadlineExceededError(""Connect timed out""));+      });++  auto on_connect2 =+      [that = std::static_pointer_cast<CFEventEngine>(shared_from_this()),+       deadline_timer = std::move(deadline_timer), handle,+       on_connect = std::move(on_connect)](absl::Status status) mutable {+        // best effort canceling deadline timer+        that->Cancel(deadline_timer);++        {+          grpc_core::MutexLock lock(&that->conn_mu_);+          that->conn_handles_.erase(handle);+        }++        auto endpoint_ptr = reinterpret_cast<CFStreamEndpoint*>(handle.keys[0]);++        if (!status.ok()) {+          on_connect(std::move(status));","Likewise, the absl::Status seems to have specifically make move-from states ""unspecified"". I'm not really sure what that means but would it work as intended here?https://github.com/abseil/abseil-cpp/blob/b6a1039bfcd6163b923c84e23e11439f42c98bc7/absl/status/status.h#L446-L448",
133680,sampajano,https://api.github.com/repos/grpc/grpc/pulls/32077,1148517045,2023-03-26T09:39:43Z,src/core/lib/event_engine/cf_engine/cfstream_endpoint.cc,"@@ -0,0 +1,343 @@+// Copyright 2022 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++#include <grpc/support/port_platform.h>++#ifdef GPR_APPLE++#include ""src/core/lib/event_engine/cf_engine/cfstream_endpoint.h""+#include ""src/core/lib/event_engine/trace.h""+#include ""src/core/lib/gprpp/strerror.h""++namespace grpc_event_engine {+namespace experimental {++namespace {++absl::Status CFErrorToStatus(CFTypeUniqueRef<CFErrorRef> cf_error) {+  CFErrorDomain cf_domain = CFErrorGetDomain((cf_error));+  CFIndex code = CFErrorGetCode((cf_error));+  CFTypeUniqueRef<CFStringRef> cf_desc = CFErrorCopyDescription((cf_error));+  char domain_buf[256];+  char desc_buf[256];+  CFStringGetCString(cf_domain, domain_buf, 256, kCFStringEncodingUTF8);+  CFStringGetCString(cf_desc, desc_buf, 256, kCFStringEncodingUTF8);+  return absl::Status(absl::StatusCode::kUnknown,+                      absl::StrFormat(""(domain:%s, code:%ld, description:%s)"",+                                      domain_buf, code, desc_buf));+}++absl::StatusOr<EventEngine::ResolvedAddress> CFReadStreamLocallAddress(+    CFReadStreamRef stream) {+  CFTypeUniqueRef<CFDataRef> cf_native_handle = static_cast<CFDataRef>(+      CFReadStreamCopyProperty(stream, kCFStreamPropertySocketNativeHandle));+  CFSocketNativeHandle socket;+  CFDataGetBytes(cf_native_handle, CFRangeMake(0, sizeof(CFSocketNativeHandle)),+                 (UInt8*)&socket);+  EventEngine::ResolvedAddress addr;+  socklen_t len = EventEngine::ResolvedAddress::MAX_SIZE_BYTES;+  if (getsockname(socket, const_cast<sockaddr*>(addr.address()), &len) < 0) {+    return absl::InternalError(+        absl::StrCat(""getsockname:"", grpc_core::StrError(errno)));+  }+  return EventEngine::ResolvedAddress(addr.address(), len);+}++}  // namespace++bool CFStreamEndpoint::CancelConnect(absl::Status status) {+  return open_event_.SetShutdown(std::move(status));+}++void CFStreamEndpoint::Connect(+    absl::AnyInvocable<void(absl::Status)> on_connect,+    EventEngine::ResolvedAddress addr) {+  auto addr_uri = ResolvedAddressToURI(addr);++  if (!addr_uri.ok()) {+    on_connect(std::move(addr_uri).status());+    return;+  }++  GRPC_EVENT_ENGINE_ENDPOINT_TRACE(""CFStreamEndpoint::Connect: %s"",+                                   addr_uri.value().c_str());++  peer_address_ = std::move(addr);+  auto host_port = ResolvedAddressToNormalizedString(peer_address_);+  if (!host_port.ok()) {+    on_connect(std::move(host_port).status());+    return;+  }++  peer_address_string_ = host_port.value();+  GRPC_EVENT_ENGINE_ENDPOINT_TRACE(""CFStreamEndpoint::Connect, host_port: %s"",+                                   host_port->c_str());++  std::string host_string;+  std::string port_string;+  grpc_core::SplitHostPort(host_port.value(), &host_string, &port_string);+  CFStringRef host = CFStringCreateWithCString(NULL, host_string.c_str(),+                                               kCFStringEncodingUTF8);+  int port = ResolvedAddressGetPort(peer_address_);+  CFStreamCreatePairWithSocketToHost(NULL, host, port, &cf_read_stream_,+                                     &cf_write_stream_);++  CFStreamClientContext cf_context = {0, static_cast<void*>(this), nullptr,+                                      nullptr, nullptr};+  CFReadStreamSetClient(+      cf_read_stream_,+      kCFStreamEventOpenCompleted | kCFStreamEventHasBytesAvailable |+          kCFStreamEventErrorOccurred | kCFStreamEventEndEncountered,+      ReadCallback, &cf_context);+  CFWriteStreamSetClient(+      cf_write_stream_,+      kCFStreamEventOpenCompleted | kCFStreamEventCanAcceptBytes |+          kCFStreamEventErrorOccurred | kCFStreamEventEndEncountered,+      WriteCallback, &cf_context);+  CFReadStreamSetDispatchQueue(cf_read_stream_,+                               dispatch_get_global_queue(QOS_CLASS_DEFAULT, 0));+  CFWriteStreamSetDispatchQueue(+      cf_write_stream_, dispatch_get_global_queue(QOS_CLASS_DEFAULT, 0));++  if (!CFReadStreamOpen(cf_read_stream_)) {+    auto status = CFErrorToStatus(CFReadStreamCopyError(cf_read_stream_));+    on_connect(std::move(status));+    return;+  }++  if (!CFWriteStreamOpen(cf_write_stream_)) {+    auto status = CFErrorToStatus(CFWriteStreamCopyError(cf_write_stream_));+    on_connect(std::move(status));+    return;+  }++  open_event_.NotifyOn(new PosixEngineClosure(+      [this, on_connect = std::move(on_connect)](absl::Status status) mutable {+        if (!status.ok()) {+          on_connect(std::move(status));+          return;+        }++        auto local_addr = CFReadStreamLocallAddress(cf_read_stream_);+        if (!local_addr.ok()) {+          on_connect(std::move(local_addr).status());+          return;+        }++        local_address_ = local_addr.value();+        local_address_string_ = *ResolvedAddressToURI(local_address_);+        on_connect(absl::OkStatus());+      },+      false /* is_permanent */));+}++/* static */ void CFStreamEndpoint::ReadCallback(CFReadStreamRef stream,+                                                 CFStreamEventType type,+                                                 void* client_callback_info) {+  auto self = static_cast<CFStreamEndpoint*>(client_callback_info);++  GRPC_EVENT_ENGINE_ENDPOINT_TRACE(+      ""CFStreamEndpoint::ReadCallback, type: %lu, this: %p"", type, self);++  switch (type) {+    case kCFStreamEventOpenCompleted:+      break;+    case kCFStreamEventHasBytesAvailable:+      ABSL_FALLTHROUGH_INTENDED;+    case kCFStreamEventEndEncountered:+      self->read_event_.SetReady();+      break;+    case kCFStreamEventErrorOccurred: {+      auto status = CFErrorToStatus(CFReadStreamCopyError(stream));+      GRPC_EVENT_ENGINE_ENDPOINT_TRACE(""CFStream Read error: %s"",+                                       status.ToString().c_str());++      self->open_event_.SetShutdown(status);+      self->read_event_.SetShutdown(status);+      self->write_event_.SetShutdown(status);+    } break;+    default:+      GPR_UNREACHABLE_CODE(return);+  }+}++/* static */+void CFStreamEndpoint::WriteCallback(CFWriteStreamRef stream,+                                     CFStreamEventType type,+                                     void* client_callback_info) {+  auto self = static_cast<CFStreamEndpoint*>(client_callback_info);+  GRPC_EVENT_ENGINE_ENDPOINT_TRACE(+      ""CFStreamEndpoint::WriteCallback, type: %lu, this: %p"", type, self);++  switch (type) {+    case kCFStreamEventOpenCompleted:+      self->open_event_.SetReady();","It seems that this `open_event_` is dispatched when write stream opens, but `cf_read_stream_` is referred to in the event handler. Is this the expected behavior? Could there be a race condition where write stream is ready but the read stream is not?Maybe you could clarify a bit further on what exactly ""open_event"" means (e.g. through documentation) it would make it clearer :)",
133680,sampajano,https://api.github.com/repos/grpc/grpc/pulls/32077,1148519440,2023-03-26T09:56:26Z,src/core/lib/event_engine/cf_engine/cfstream_endpoint.cc,"@@ -0,0 +1,343 @@+// Copyright 2022 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++#include <grpc/support/port_platform.h>++#ifdef GPR_APPLE++#include ""src/core/lib/event_engine/cf_engine/cfstream_endpoint.h""+#include ""src/core/lib/event_engine/trace.h""+#include ""src/core/lib/gprpp/strerror.h""++namespace grpc_event_engine {+namespace experimental {++namespace {++absl::Status CFErrorToStatus(CFTypeUniqueRef<CFErrorRef> cf_error) {+  CFErrorDomain cf_domain = CFErrorGetDomain((cf_error));+  CFIndex code = CFErrorGetCode((cf_error));+  CFTypeUniqueRef<CFStringRef> cf_desc = CFErrorCopyDescription((cf_error));+  char domain_buf[256];+  char desc_buf[256];+  CFStringGetCString(cf_domain, domain_buf, 256, kCFStringEncodingUTF8);+  CFStringGetCString(cf_desc, desc_buf, 256, kCFStringEncodingUTF8);+  return absl::Status(absl::StatusCode::kUnknown,+                      absl::StrFormat(""(domain:%s, code:%ld, description:%s)"",+                                      domain_buf, code, desc_buf));+}++absl::StatusOr<EventEngine::ResolvedAddress> CFReadStreamLocallAddress(+    CFReadStreamRef stream) {+  CFTypeUniqueRef<CFDataRef> cf_native_handle = static_cast<CFDataRef>(+      CFReadStreamCopyProperty(stream, kCFStreamPropertySocketNativeHandle));+  CFSocketNativeHandle socket;+  CFDataGetBytes(cf_native_handle, CFRangeMake(0, sizeof(CFSocketNativeHandle)),+                 (UInt8*)&socket);+  EventEngine::ResolvedAddress addr;+  socklen_t len = EventEngine::ResolvedAddress::MAX_SIZE_BYTES;+  if (getsockname(socket, const_cast<sockaddr*>(addr.address()), &len) < 0) {+    return absl::InternalError(+        absl::StrCat(""getsockname:"", grpc_core::StrError(errno)));+  }+  return EventEngine::ResolvedAddress(addr.address(), len);+}++}  // namespace++bool CFStreamEndpoint::CancelConnect(absl::Status status) {+  return open_event_.SetShutdown(std::move(status));+}++void CFStreamEndpoint::Connect(+    absl::AnyInvocable<void(absl::Status)> on_connect,+    EventEngine::ResolvedAddress addr) {+  auto addr_uri = ResolvedAddressToURI(addr);++  if (!addr_uri.ok()) {+    on_connect(std::move(addr_uri).status());+    return;+  }++  GRPC_EVENT_ENGINE_ENDPOINT_TRACE(""CFStreamEndpoint::Connect: %s"",+                                   addr_uri.value().c_str());++  peer_address_ = std::move(addr);+  auto host_port = ResolvedAddressToNormalizedString(peer_address_);+  if (!host_port.ok()) {+    on_connect(std::move(host_port).status());+    return;+  }++  peer_address_string_ = host_port.value();+  GRPC_EVENT_ENGINE_ENDPOINT_TRACE(""CFStreamEndpoint::Connect, host_port: %s"",+                                   host_port->c_str());++  std::string host_string;+  std::string port_string;+  grpc_core::SplitHostPort(host_port.value(), &host_string, &port_string);+  CFStringRef host = CFStringCreateWithCString(NULL, host_string.c_str(),+                                               kCFStringEncodingUTF8);+  int port = ResolvedAddressGetPort(peer_address_);+  CFStreamCreatePairWithSocketToHost(NULL, host, port, &cf_read_stream_,+                                     &cf_write_stream_);++  CFStreamClientContext cf_context = {0, static_cast<void*>(this), nullptr,+                                      nullptr, nullptr};+  CFReadStreamSetClient(+      cf_read_stream_,+      kCFStreamEventOpenCompleted | kCFStreamEventHasBytesAvailable |+          kCFStreamEventErrorOccurred | kCFStreamEventEndEncountered,+      ReadCallback, &cf_context);+  CFWriteStreamSetClient(+      cf_write_stream_,+      kCFStreamEventOpenCompleted | kCFStreamEventCanAcceptBytes |+          kCFStreamEventErrorOccurred | kCFStreamEventEndEncountered,+      WriteCallback, &cf_context);+  CFReadStreamSetDispatchQueue(cf_read_stream_,+                               dispatch_get_global_queue(QOS_CLASS_DEFAULT, 0));+  CFWriteStreamSetDispatchQueue(+      cf_write_stream_, dispatch_get_global_queue(QOS_CLASS_DEFAULT, 0));++  if (!CFReadStreamOpen(cf_read_stream_)) {+    auto status = CFErrorToStatus(CFReadStreamCopyError(cf_read_stream_));+    on_connect(std::move(status));+    return;+  }++  if (!CFWriteStreamOpen(cf_write_stream_)) {+    auto status = CFErrorToStatus(CFWriteStreamCopyError(cf_write_stream_));+    on_connect(std::move(status));+    return;+  }++  open_event_.NotifyOn(new PosixEngineClosure(+      [this, on_connect = std::move(on_connect)](absl::Status status) mutable {+        if (!status.ok()) {+          on_connect(std::move(status));+          return;+        }++        auto local_addr = CFReadStreamLocallAddress(cf_read_stream_);+        if (!local_addr.ok()) {+          on_connect(std::move(local_addr).status());+          return;+        }++        local_address_ = local_addr.value();+        local_address_string_ = *ResolvedAddressToURI(local_address_);+        on_connect(absl::OkStatus());+      },+      false /* is_permanent */));+}++/* static */ void CFStreamEndpoint::ReadCallback(CFReadStreamRef stream,+                                                 CFStreamEventType type,+                                                 void* client_callback_info) {+  auto self = static_cast<CFStreamEndpoint*>(client_callback_info);++  GRPC_EVENT_ENGINE_ENDPOINT_TRACE(+      ""CFStreamEndpoint::ReadCallback, type: %lu, this: %p"", type, self);++  switch (type) {+    case kCFStreamEventOpenCompleted:+      break;+    case kCFStreamEventHasBytesAvailable:+      ABSL_FALLTHROUGH_INTENDED;+    case kCFStreamEventEndEncountered:+      self->read_event_.SetReady();+      break;+    case kCFStreamEventErrorOccurred: {+      auto status = CFErrorToStatus(CFReadStreamCopyError(stream));+      GRPC_EVENT_ENGINE_ENDPOINT_TRACE(""CFStream Read error: %s"",+                                       status.ToString().c_str());++      self->open_event_.SetShutdown(status);+      self->read_event_.SetShutdown(status);+      self->write_event_.SetShutdown(status);+    } break;+    default:+      GPR_UNREACHABLE_CODE(return);+  }+}++/* static */+void CFStreamEndpoint::WriteCallback(CFWriteStreamRef stream,+                                     CFStreamEventType type,+                                     void* client_callback_info) {+  auto self = static_cast<CFStreamEndpoint*>(client_callback_info);+  GRPC_EVENT_ENGINE_ENDPOINT_TRACE(+      ""CFStreamEndpoint::WriteCallback, type: %lu, this: %p"", type, self);++  switch (type) {+    case kCFStreamEventOpenCompleted:+      self->open_event_.SetReady();+      break;+    case kCFStreamEventCanAcceptBytes:+      ABSL_FALLTHROUGH_INTENDED;+    case kCFStreamEventEndEncountered:+      self->write_event_.SetReady();+      break;+    case kCFStreamEventErrorOccurred: {+      auto status = CFErrorToStatus(CFWriteStreamCopyError(stream));+      GRPC_EVENT_ENGINE_ENDPOINT_TRACE(""CFStream Write error: %s"",+                                       status.ToString().c_str());++      self->open_event_.SetShutdown(status);+      self->read_event_.SetShutdown(status);+      self->write_event_.SetShutdown(status);+    } break;+    default:+      GPR_UNREACHABLE_CODE(return);+  }+}++CFStreamEndpoint::CFStreamEndpoint(std::shared_ptr<CFEventEngine> engine,+                                   MemoryAllocator memory_allocator)+    : engine_(std::move(engine)),+      memory_allocator_(std::move(memory_allocator)),+      open_event_(engine_.get()),+      read_event_(engine_.get()),+      write_event_(engine_.get()) {+  open_event_.InitEvent();+  read_event_.InitEvent();+  write_event_.InitEvent();+}++CFStreamEndpoint::~CFStreamEndpoint() {+  CFReadStreamClose(cf_read_stream_);+  CFWriteStreamClose(cf_write_stream_);++  auto shutdownStatus =+      absl::Status(absl::StatusCode::kUnknown,+                   absl::StrFormat(""Shutting down CFStreamEndpoint""));+  open_event_.SetShutdown(shutdownStatus);+  read_event_.SetShutdown(shutdownStatus);+  write_event_.SetShutdown(shutdownStatus);+  open_event_.DestroyEvent();+  read_event_.DestroyEvent();+  write_event_.DestroyEvent();+}++bool CFStreamEndpoint::Read(absl::AnyInvocable<void(absl::Status)> on_read,+                            SliceBuffer* buffer, const ReadArgs* /* args */) {+  read_event_.NotifyOn(new PosixEngineClosure(+      [this, on_read = std::move(on_read),+       buffer](absl::Status status) mutable {+        if (status.ok()) {+          DoRead(std::move(on_read), buffer);+        } else {+          on_read(status);+        }+      },+      false /* is_permanent*/));++  return false;+}++void CFStreamEndpoint::DoRead(absl::AnyInvocable<void(absl::Status)> on_read,+                              SliceBuffer* buffer) {+  GRPC_EVENT_ENGINE_ENDPOINT_TRACE(""CFStreamEndpoint::DoRead, this: %p"", this);++  int buffer_size = 8192;+  auto buffer_index =+      buffer->AppendIndexed(Slice(memory_allocator_.MakeSlice(buffer_size)));++  CFIndex read_size = CFReadStreamRead(+      cf_read_stream_,+      internal::SliceCast<MutableSlice>(buffer->MutableSliceAt(buffer_index))+          .begin(),+      buffer_size);++  if (read_size < 0) {+    auto status = CFErrorToStatus(CFReadStreamCopyError(cf_read_stream_));+    GRPC_EVENT_ENGINE_ENDPOINT_TRACE(""CFStream read error: %s"",+                                     status.ToString().c_str());+    on_read(status);+    return;+  }++  buffer->RemoveLastNBytes(buffer->Length() - read_size);++  if (grpc_event_engine_endpoint_data_trace.enabled()) {","@drfloob Hi AJ, is `grpc_event_engine_endpoint_data_trace` logic necessary on iOS? This seems to be only used on Windows but not Posix from what i can tell.",
133680,sampajano,https://api.github.com/repos/grpc/grpc/pulls/32077,1148521188,2023-03-26T10:08:18Z,src/core/lib/event_engine/cf_engine/cfstream_endpoint.cc,"@@ -0,0 +1,343 @@+// Copyright 2022 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++#include <grpc/support/port_platform.h>++#ifdef GPR_APPLE++#include ""src/core/lib/event_engine/cf_engine/cfstream_endpoint.h""+#include ""src/core/lib/event_engine/trace.h""+#include ""src/core/lib/gprpp/strerror.h""++namespace grpc_event_engine {+namespace experimental {++namespace {++absl::Status CFErrorToStatus(CFTypeUniqueRef<CFErrorRef> cf_error) {+  CFErrorDomain cf_domain = CFErrorGetDomain((cf_error));+  CFIndex code = CFErrorGetCode((cf_error));+  CFTypeUniqueRef<CFStringRef> cf_desc = CFErrorCopyDescription((cf_error));+  char domain_buf[256];+  char desc_buf[256];+  CFStringGetCString(cf_domain, domain_buf, 256, kCFStringEncodingUTF8);+  CFStringGetCString(cf_desc, desc_buf, 256, kCFStringEncodingUTF8);+  return absl::Status(absl::StatusCode::kUnknown,+                      absl::StrFormat(""(domain:%s, code:%ld, description:%s)"",+                                      domain_buf, code, desc_buf));+}++absl::StatusOr<EventEngine::ResolvedAddress> CFReadStreamLocallAddress(+    CFReadStreamRef stream) {+  CFTypeUniqueRef<CFDataRef> cf_native_handle = static_cast<CFDataRef>(+      CFReadStreamCopyProperty(stream, kCFStreamPropertySocketNativeHandle));+  CFSocketNativeHandle socket;+  CFDataGetBytes(cf_native_handle, CFRangeMake(0, sizeof(CFSocketNativeHandle)),+                 (UInt8*)&socket);+  EventEngine::ResolvedAddress addr;+  socklen_t len = EventEngine::ResolvedAddress::MAX_SIZE_BYTES;+  if (getsockname(socket, const_cast<sockaddr*>(addr.address()), &len) < 0) {+    return absl::InternalError(+        absl::StrCat(""getsockname:"", grpc_core::StrError(errno)));+  }+  return EventEngine::ResolvedAddress(addr.address(), len);+}++}  // namespace++bool CFStreamEndpoint::CancelConnect(absl::Status status) {+  return open_event_.SetShutdown(std::move(status));+}++void CFStreamEndpoint::Connect(+    absl::AnyInvocable<void(absl::Status)> on_connect,+    EventEngine::ResolvedAddress addr) {+  auto addr_uri = ResolvedAddressToURI(addr);++  if (!addr_uri.ok()) {+    on_connect(std::move(addr_uri).status());+    return;+  }++  GRPC_EVENT_ENGINE_ENDPOINT_TRACE(""CFStreamEndpoint::Connect: %s"",+                                   addr_uri.value().c_str());++  peer_address_ = std::move(addr);+  auto host_port = ResolvedAddressToNormalizedString(peer_address_);+  if (!host_port.ok()) {+    on_connect(std::move(host_port).status());+    return;+  }++  peer_address_string_ = host_port.value();+  GRPC_EVENT_ENGINE_ENDPOINT_TRACE(""CFStreamEndpoint::Connect, host_port: %s"",+                                   host_port->c_str());++  std::string host_string;+  std::string port_string;+  grpc_core::SplitHostPort(host_port.value(), &host_string, &port_string);+  CFStringRef host = CFStringCreateWithCString(NULL, host_string.c_str(),+                                               kCFStringEncodingUTF8);+  int port = ResolvedAddressGetPort(peer_address_);+  CFStreamCreatePairWithSocketToHost(NULL, host, port, &cf_read_stream_,+                                     &cf_write_stream_);++  CFStreamClientContext cf_context = {0, static_cast<void*>(this), nullptr,+                                      nullptr, nullptr};+  CFReadStreamSetClient(+      cf_read_stream_,+      kCFStreamEventOpenCompleted | kCFStreamEventHasBytesAvailable |+          kCFStreamEventErrorOccurred | kCFStreamEventEndEncountered,+      ReadCallback, &cf_context);+  CFWriteStreamSetClient(+      cf_write_stream_,+      kCFStreamEventOpenCompleted | kCFStreamEventCanAcceptBytes |+          kCFStreamEventErrorOccurred | kCFStreamEventEndEncountered,+      WriteCallback, &cf_context);+  CFReadStreamSetDispatchQueue(cf_read_stream_,+                               dispatch_get_global_queue(QOS_CLASS_DEFAULT, 0));+  CFWriteStreamSetDispatchQueue(+      cf_write_stream_, dispatch_get_global_queue(QOS_CLASS_DEFAULT, 0));++  if (!CFReadStreamOpen(cf_read_stream_)) {+    auto status = CFErrorToStatus(CFReadStreamCopyError(cf_read_stream_));+    on_connect(std::move(status));+    return;+  }++  if (!CFWriteStreamOpen(cf_write_stream_)) {+    auto status = CFErrorToStatus(CFWriteStreamCopyError(cf_write_stream_));+    on_connect(std::move(status));+    return;+  }++  open_event_.NotifyOn(new PosixEngineClosure(+      [this, on_connect = std::move(on_connect)](absl::Status status) mutable {+        if (!status.ok()) {+          on_connect(std::move(status));+          return;+        }++        auto local_addr = CFReadStreamLocallAddress(cf_read_stream_);+        if (!local_addr.ok()) {+          on_connect(std::move(local_addr).status());+          return;+        }++        local_address_ = local_addr.value();+        local_address_string_ = *ResolvedAddressToURI(local_address_);+        on_connect(absl::OkStatus());+      },+      false /* is_permanent */));+}++/* static */ void CFStreamEndpoint::ReadCallback(CFReadStreamRef stream,+                                                 CFStreamEventType type,+                                                 void* client_callback_info) {+  auto self = static_cast<CFStreamEndpoint*>(client_callback_info);++  GRPC_EVENT_ENGINE_ENDPOINT_TRACE(+      ""CFStreamEndpoint::ReadCallback, type: %lu, this: %p"", type, self);++  switch (type) {+    case kCFStreamEventOpenCompleted:+      break;+    case kCFStreamEventHasBytesAvailable:+      ABSL_FALLTHROUGH_INTENDED;+    case kCFStreamEventEndEncountered:+      self->read_event_.SetReady();+      break;+    case kCFStreamEventErrorOccurred: {+      auto status = CFErrorToStatus(CFReadStreamCopyError(stream));+      GRPC_EVENT_ENGINE_ENDPOINT_TRACE(""CFStream Read error: %s"",+                                       status.ToString().c_str());++      self->open_event_.SetShutdown(status);+      self->read_event_.SetShutdown(status);+      self->write_event_.SetShutdown(status);+    } break;+    default:+      GPR_UNREACHABLE_CODE(return);+  }+}++/* static */+void CFStreamEndpoint::WriteCallback(CFWriteStreamRef stream,+                                     CFStreamEventType type,+                                     void* client_callback_info) {+  auto self = static_cast<CFStreamEndpoint*>(client_callback_info);+  GRPC_EVENT_ENGINE_ENDPOINT_TRACE(+      ""CFStreamEndpoint::WriteCallback, type: %lu, this: %p"", type, self);++  switch (type) {+    case kCFStreamEventOpenCompleted:+      self->open_event_.SetReady();+      break;+    case kCFStreamEventCanAcceptBytes:+      ABSL_FALLTHROUGH_INTENDED;+    case kCFStreamEventEndEncountered:+      self->write_event_.SetReady();+      break;+    case kCFStreamEventErrorOccurred: {+      auto status = CFErrorToStatus(CFWriteStreamCopyError(stream));+      GRPC_EVENT_ENGINE_ENDPOINT_TRACE(""CFStream Write error: %s"",+                                       status.ToString().c_str());++      self->open_event_.SetShutdown(status);+      self->read_event_.SetShutdown(status);+      self->write_event_.SetShutdown(status);+    } break;+    default:+      GPR_UNREACHABLE_CODE(return);+  }+}++CFStreamEndpoint::CFStreamEndpoint(std::shared_ptr<CFEventEngine> engine,+                                   MemoryAllocator memory_allocator)+    : engine_(std::move(engine)),+      memory_allocator_(std::move(memory_allocator)),+      open_event_(engine_.get()),+      read_event_(engine_.get()),+      write_event_(engine_.get()) {+  open_event_.InitEvent();+  read_event_.InitEvent();+  write_event_.InitEvent();+}++CFStreamEndpoint::~CFStreamEndpoint() {+  CFReadStreamClose(cf_read_stream_);+  CFWriteStreamClose(cf_write_stream_);++  auto shutdownStatus =+      absl::Status(absl::StatusCode::kUnknown,+                   absl::StrFormat(""Shutting down CFStreamEndpoint""));+  open_event_.SetShutdown(shutdownStatus);+  read_event_.SetShutdown(shutdownStatus);+  write_event_.SetShutdown(shutdownStatus);+  open_event_.DestroyEvent();+  read_event_.DestroyEvent();+  write_event_.DestroyEvent();+}++bool CFStreamEndpoint::Read(absl::AnyInvocable<void(absl::Status)> on_read,+                            SliceBuffer* buffer, const ReadArgs* /* args */) {+  read_event_.NotifyOn(new PosixEngineClosure(+      [this, on_read = std::move(on_read),+       buffer](absl::Status status) mutable {+        if (status.ok()) {+          DoRead(std::move(on_read), buffer);+        } else {+          on_read(status);+        }+      },+      false /* is_permanent*/));++  return false;+}++void CFStreamEndpoint::DoRead(absl::AnyInvocable<void(absl::Status)> on_read,+                              SliceBuffer* buffer) {+  GRPC_EVENT_ENGINE_ENDPOINT_TRACE(""CFStreamEndpoint::DoRead, this: %p"", this);++  int buffer_size = 8192;+  auto buffer_index =+      buffer->AppendIndexed(Slice(memory_allocator_.MakeSlice(buffer_size)));++  CFIndex read_size = CFReadStreamRead(+      cf_read_stream_,+      internal::SliceCast<MutableSlice>(buffer->MutableSliceAt(buffer_index))+          .begin(),+      buffer_size);++  if (read_size < 0) {+    auto status = CFErrorToStatus(CFReadStreamCopyError(cf_read_stream_));+    GRPC_EVENT_ENGINE_ENDPOINT_TRACE(""CFStream read error: %s"",+                                     status.ToString().c_str());+    on_read(status);+    return;+  }++  buffer->RemoveLastNBytes(buffer->Length() - read_size);++  if (grpc_event_engine_endpoint_data_trace.enabled()) {+    for (size_t i = 0; i < buffer->Count(); i++) {+      auto str = buffer->RefSlice(i).as_string_view();+      gpr_log(GPR_INFO, ""CFStreamEndpoint::DoRead, this: %p (peer=%s): %.*s"",+              this, peer_address_string_.c_str(),+              static_cast<int>(str.length()), str.data());+    }+  }++  on_read(absl::OkStatus());+}++bool CFStreamEndpoint::Write(absl::AnyInvocable<void(absl::Status)> on_writable,+                             SliceBuffer* data, const WriteArgs* /* args */) {+  write_event_.NotifyOn(new PosixEngineClosure(+      [this, on_writable = std::move(on_writable),+       data](absl::Status status) mutable {+        if (status.ok()) {+          DoWrite(std::move(on_writable), data);+        } else {+          on_writable(status);+        }+      },+      false /* is_permanent*/));++  return false;+}++void CFStreamEndpoint::DoWrite(+    absl::AnyInvocable<void(absl::Status)> on_writable, SliceBuffer* data) {+  GRPC_EVENT_ENGINE_ENDPOINT_TRACE(""CFStreamEndpoint::DoWrite, this: %p"", this);+  if (grpc_event_engine_endpoint_data_trace.enabled()) {+    for (size_t i = 0; i < data->Count(); i++) {+      auto str = data->RefSlice(i).as_string_view();+      gpr_log(GPR_INFO, ""CFStreamEndpoint::DoWrite, this: %p (peer=%s): %.*s"",+              this, peer_address_string_.c_str(),+              static_cast<int>(str.length()), str.data());+    }+  }++  size_t total_written_size = 0;+  for (size_t i = 0; i < data->Count(); i++) {+    auto slice = data->RefSlice(i);+    size_t written_size =+        CFWriteStreamWrite(cf_write_stream_, slice.begin(), slice.size());++    total_written_size += written_size;+    if (written_size < slice.size()) {+      SliceBuffer written;+      data->MoveFirstNBytesIntoSliceBuffer(total_written_size, written);++      write_event_.NotifyOn(new PosixEngineClosure(","Am I reading it correctly, that this is recursively scheduling a write, if it cannot finish in one `CFWriteStreamWrite` call?I wonder if this is susceptible to a race condition if `CFStreamEndpoint::Write` is called again and now there are 2 scheduled writes?",
133680,sampajano,https://api.github.com/repos/grpc/grpc/pulls/32077,1148523997,2023-03-26T10:23:51Z,src/core/lib/event_engine/cf_engine/cftype_unique_ref.h,"@@ -0,0 +1,76 @@+// Copyright 2022 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+#ifndef GRPC_SRC_CORE_LIB_EVENT_ENGINE_CF_ENGINE_CFTYPE_UNIQUE_REF_H+#define GRPC_SRC_CORE_LIB_EVENT_ENGINE_CF_ENGINE_CFTYPE_UNIQUE_REF_H+#include <grpc/support/port_platform.h>++#ifdef GPR_APPLE++#include <CoreFoundation/CoreFoundation.h>++namespace grpc_event_engine {+namespace experimental {++template <typename T>+class CFTypeUniqueRef {+  static_assert(std::is_convertible<T, CFTypeRef>::value,+                ""T should be `CFXxxRef` type"");++ public:+  /* implicit */+  CFTypeUniqueRef(T cf_type_ref = nullptr) : cf_type_ref_(cf_type_ref) {}+  ~CFTypeUniqueRef() { reset(); }++  CFTypeUniqueRef(CFTypeUniqueRef const&) = delete;+  CFTypeUniqueRef& operator=(CFTypeUniqueRef const&) = delete;++  CFTypeUniqueRef(CFTypeUniqueRef&& other) : cf_type_ref_(other.release()){};+  CFTypeUniqueRef& operator=(CFTypeUniqueRef&& other) {+    reset(other.release());+    return *this;+  }++  operator T() { return cf_type_ref_; }++  // Note: this is for passing a CFTypeRef as output parameter to a CF API, the+  // current ref is released (if any) regardless of whether new value is set+  T* operator&() {+    reset();+    return &cf_type_ref_;+  }++  T release() {+    T old = cf_type_ref_;+    cf_type_ref_ = nullptr;+    return old;+  }++  void reset(T other = nullptr) {+    T old = cf_type_ref_;+    cf_type_ref_ = other;+    if (old) {+      CFRelease(old);+    }+  }",I asked ChatGPT(3.5) if there's any bug in this class (i have to say i love i can just do that ) and it says if you add a `if (cf_type_ref_ != other)` check it could prevent a potential issue if both are the same.. i don't know if it truly matters but FYI.. ,
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/32636,1148861835,2023-03-27T07:00:07Z,src/compiler/csharp_generator_helpers.h,"@@ -22,13 +22,30 @@ #include ""src/compiler/config.h"" #include ""src/compiler/generator_helpers.h"" +using google::protobuf::compiler::csharp::GetOutputFile;+ namespace grpc_csharp_generator {  inline bool ServicesFilename(const grpc::protobuf::FileDescriptor* file,                              const std::string& file_suffix,-                             std::string& out_file_name_or_error) {-  out_file_name_or_error =-      grpc_generator::FileNameInUpperCamel(file, false) + file_suffix;+                             const std::string& base_namespace,+                             std::string& out_file, std::string* error) {+  // Support for base_namespace option is **experimental**.+  //+  // If base_namespace is provided then slightly different name mangling+  // is used to generate the service file name. This is because this+  // uses common code with protoc. For most file names this will not+  // make a difference (only files with punctuation or numbers in the+  // name.)+  // Otherwise the behavor remains the same as before.+  if (base_namespace.empty()) {+    out_file = grpc_generator::FileNameInUpperCamel(file, false) + file_suffix;+  } else {+    out_file = GetOutputFile(file, file_suffix, true, base_namespace, error);","Also, will using GetOutputFile be still usable in protobuf 22.x (which we are going to upgrade to soon)?Looks like it would? https://github.com/protocolbuffers/protobuf/blob/3a871acca05ca4cdf79fc14ea9b701be6fe745f1/src/google/protobuf/compiler/csharp/names.h#L121https://github.com/protocolbuffers/protobuf/blob/3a871acca05ca4cdf79fc14ea9b701be6fe745f1/src/google/protobuf/compiler/csharp/BUILD.bazel#L15",
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/32636,1148880636,2023-03-27T07:15:00Z,src/csharp/BUILD-INTEGRATION.md,"@@ -170,12 +170,21 @@ to perform code generation. Here is an overview of the available `grpc_csharp_pl | no_client       | off       | Don't generate the client stub                           | | no_server       | off       | Don't generate the server-side stub                      | | internal_access | off       | Generate classes with ""internal"" visibility              |+| file_suffix     | Grpc.cs   | The suffix that will get appended to the name of the generated file. **Can only be used on the command line.** |+| base_namespace | none       | *Experimental - may change or be removed.* Same as `base_namespace` for `protoc` C# options.  **Can only be used on the command line.** | -Note that the protocol buffer compiler has a special commandline syntax for plugin options.-Example:-```-protoc --plugin=protoc-gen-grpc=grpc_csharp_plugin --csharp_out=OUT_DIR \-    --grpc_out=OUT_DIR --grpc_opt=lite_client,no_server \+To use these options with `Grpc.Tools` specify them in the __GrpcOutputOptions__+metadata in the `<Protobuf>` item.+- Note: `file_suffix` and `base_namespace` should not be used with `Grpc.Tools`. Using them will break the build.++To use these options on the command line specify them using the `--grpc_opt`","Unless that's mentioned somewhere, also mention that the ""csharp"" codegen itself (for protobuf messages), uses --csharp_opt flag.Also, probably add --csharp_opt to the example, since it's more realistic that actual users will want to set base_namespace for both --grpc_opt and --csharp_opt shall they use the `base_namespace` option.",
394885,soheilhy,https://api.github.com/repos/grpc/grpc/pulls/32653,1149635523,2023-03-27T18:20:45Z,src/core/lib/promise/party.cc,"@@ -246,136 +220,55 @@ void Party::RunLocked() { bool Party::RunParty() {   ScopedActivity activity(this);   promise_detail::Context<Arena> arena_ctx(arena_);-  uint64_t prev_state;-  do {-    // Grab the current state, and clear the wakeup bits & add flag.-    prev_state = state_.fetch_and(kRefMask | kLocked | kAllocatedMask,-                                  std::memory_order_acquire);-    if (grpc_trace_promise_primitives.enabled()) {-      gpr_log(GPR_DEBUG, ""%s[party] Run prev_state=%s"", DebugTag().c_str(),-              StateToString(prev_state).c_str());-    }-    GPR_ASSERT(prev_state & kLocked);-    if (prev_state & kDestroying) return true;-    // From the previous state, extract which participants we're to wakeup.-    uint64_t wakeups = prev_state & kWakeupMask;-    // Now update prev_state to be what we want the CAS to see below.-    prev_state &= kRefMask | kLocked | kAllocatedMask;-    // For each wakeup bit...-    for (size_t i = 0; wakeups != 0; i++, wakeups >>= 1) {-      // If the bit is not set, skip.-      if ((wakeups & 1) == 0) continue;-      // If the participant is null, skip.-      // This allows participants to complete whilst wakers still exist-      // somewhere.-      auto* participant = participants_[i].load(std::memory_order_acquire);-      if (participant == nullptr) {-        if (grpc_trace_promise_primitives.enabled()) {-          gpr_log(GPR_DEBUG, ""%s[party] wakeup %"" PRIdPTR "" already complete"",-                  DebugTag().c_str(), i);-        }-        continue;-      }-      absl::string_view name;+  return sync_.RunParty([this](int i) {+    // If the participant is null, skip.+    // This allows participants to complete whilst wakers still exist+    // somewhere.+    auto* participant = participants_[i].load(std::memory_order_acquire);+    if (participant == nullptr) {       if (grpc_trace_promise_primitives.enabled()) {-        name = participant->name();-        gpr_log(GPR_DEBUG, ""%s[%s] begin job %"" PRIdPTR, DebugTag().c_str(),-                std::string(name).c_str(), i);+        gpr_log(GPR_DEBUG, ""%s[party] wakeup %d already complete"",+                DebugTag().c_str(), i);       }-      // Poll the participant.-      currently_polling_ = i;-      if (participant->Poll()) {-        if (!name.empty()) {-          gpr_log(GPR_DEBUG, ""%s[%s] end poll and finish job %"" PRIdPTR,-                  DebugTag().c_str(), std::string(name).c_str(), i);-        }-        participants_[i] = nullptr;-        const uint64_t allocated_bit = (1u << i << kAllocatedShift);-        prev_state &= ~allocated_bit;-        state_.fetch_and(~allocated_bit, std::memory_order_release);-      } else if (!name.empty()) {-        gpr_log(GPR_DEBUG, ""%s[%s] end poll"", DebugTag().c_str(),-                std::string(name).c_str());+      return false;+    }+    absl::string_view name;+    if (grpc_trace_promise_primitives.enabled()) {+      name = participant->name();+      gpr_log(GPR_DEBUG, ""%s[%s] begin job %d"", DebugTag().c_str(),+              std::string(name).c_str(), i);",nit: can we use `name.data()` or is this because you have to have it null terminated?,
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32632,1149895206,2023-03-28T00:00:02Z,src/core/ext/filters/client_channel/resolver/dns/event_engine/event_engine_client_channel_resolver.cc,"@@ -0,0 +1,535 @@+// Copyright 2023 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+#include <grpc/support/port_platform.h>++#include ""src/core/ext/filters/client_channel/resolver/dns/event_engine/event_engine_client_channel_resolver.h""++#include <stddef.h>+#include <stdint.h>++#include <algorithm>+#include <chrono>+#include <initializer_list>+#include <memory>+#include <string>+#include <utility>+#include <vector>++#include ""absl/base/thread_annotations.h""+#include ""absl/container/flat_hash_set.h""+#include ""absl/functional/bind_front.h""+#include ""absl/status/status.h""+#include ""absl/status/statusor.h""+#include ""absl/strings/str_cat.h""+#include ""absl/strings/str_format.h""+#include ""absl/strings/strip.h""+#include ""absl/types/optional.h""++#include <grpc/event_engine/event_engine.h>+#include <grpc/grpc.h>+#include <grpc/support/log.h>++#include ""src/core/ext/filters/client_channel/lb_policy/grpclb/grpclb_balancer_addresses.h""+#include ""src/core/ext/filters/client_channel/resolver/dns/event_engine/service_config_helper.h""+#include ""src/core/ext/filters/client_channel/resolver/polling_resolver.h""+#include ""src/core/lib/backoff/backoff.h""+#include ""src/core/lib/channel/channel_args.h""+#include ""src/core/lib/debug/trace.h""+#include ""src/core/lib/event_engine/handle_containers.h""+#include ""src/core/lib/event_engine/resolved_address_internal.h""+#include ""src/core/lib/event_engine/trace.h""+#include ""src/core/lib/event_engine/utils.h""+#include ""src/core/lib/gprpp/debug_location.h""+#include ""src/core/lib/gprpp/ref_counted_ptr.h""+#include ""src/core/lib/gprpp/status_helper.h""+#include ""src/core/lib/gprpp/sync.h""+#include ""src/core/lib/gprpp/time.h""+#include ""src/core/lib/iomgr/resolve_address.h""+#include ""src/core/lib/resolver/resolver.h""+#include ""src/core/lib/resolver/resolver_factory.h""+#include ""src/core/lib/resolver/server_address.h""+#include ""src/core/lib/service_config/service_config.h""+#include ""src/core/lib/service_config/service_config_impl.h""++// IWYU pragma: no_include <ratio>++namespace grpc_event_engine {+namespace experimental {++namespace {++#define GRPC_DNS_INITIAL_CONNECT_BACKOFF_SECONDS 1+#define GRPC_DNS_RECONNECT_BACKOFF_MULTIPLIER 1.6+#define GRPC_DNS_RECONNECT_MAX_BACKOFF_SECONDS 120+#define GRPC_DNS_RECONNECT_JITTER 0.2+#define GRPC_DNS_DEFAULT_QUERY_TIMEOUT_MS 120000++using grpc_core::BackOff;+using grpc_core::Duration;+using grpc_core::InternallyRefCounted;+using grpc_core::MakeOrphanable;+using grpc_core::Mutex;+using grpc_core::MutexLock;+using grpc_core::Orphanable;+using grpc_core::OrphanablePtr;+using grpc_core::RefCountedPtr;+using grpc_core::ResolverArgs;++// ----------------------------------------------------------------------------+// EventEngineDNSRequestWrapper declaration+// ----------------------------------------------------------------------------+class EventEngineClientChannelDNSResolver;++class EventEngineDNSRequestWrapper","Please nest this inside of `EventEngineClientChannelDNSResolver`.  This is purely an implementation detail of that class, so it does not need to be visible outside of it.  And this will eliminate the need for the `friend` declaration.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32632,1149897840,2023-03-28T00:06:06Z,src/core/ext/filters/client_channel/resolver/dns/native/dns_resolver.cc,"@@ -181,18 +180,13 @@ class NativeClientChannelDNSResolverFactory : public ResolverFactory { }  // namespace  void RegisterNativeDnsResolver(CoreConfiguration::Builder* builder) {-  static const char* const resolver =+  static absl::string_view resolver =",Why are we re-checking these conditions here if we're expecting this to now be called only from the centralized selection logic?,
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32632,1149898788,2023-03-28T00:08:21Z,src/core/ext/filters/client_channel/resolver/dns/event_engine/service_config_helper.cc,"@@ -0,0 +1,132 @@+// Copyright 2023 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+#include <grpc/support/port_platform.h>++#include ""src/core/ext/filters/client_channel/resolver/dns/event_engine/service_config_helper.h""++#include <stdio.h>+#include <stdlib.h>++#include <algorithm>+#include <map>+#include <utility>+#include <vector>++#include ""absl/status/status.h""+#include ""absl/status/statusor.h""+#include ""absl/strings/string_view.h""++#include ""src/core/lib/gprpp/debug_location.h""+#include ""src/core/lib/gprpp/status_helper.h""+#include ""src/core/lib/iomgr/gethostname.h""+#include ""src/core/lib/json/json.h""++namespace grpc_event_engine {+namespace experimental {++namespace {+using ::grpc_core::Json;++bool ValueInJsonArray(const Json::Array& array, const char* value) {+  for (const Json& entry : array) {+    if (entry.type() == Json::Type::STRING && entry.string_value() == value) {+      return true;+    }+  }+  return false;+}++}  // namespace++absl::StatusOr<std::string> ChooseServiceConfig(","Isn't this logic basically the same as what currently exists in the c-ares resolver implementation?  If so, how about removing the duplicate logic and having both implementations call this common module.",X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32632,1149907838,2023-03-28T00:28:21Z,src/core/ext/filters/client_channel/resolver/dns/event_engine/event_engine_client_channel_resolver.cc,"@@ -0,0 +1,535 @@+// Copyright 2023 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+#include <grpc/support/port_platform.h>++#include ""src/core/ext/filters/client_channel/resolver/dns/event_engine/event_engine_client_channel_resolver.h""++#include <stddef.h>+#include <stdint.h>++#include <algorithm>+#include <chrono>+#include <initializer_list>+#include <memory>+#include <string>+#include <utility>+#include <vector>++#include ""absl/base/thread_annotations.h""+#include ""absl/container/flat_hash_set.h""+#include ""absl/functional/bind_front.h""+#include ""absl/status/status.h""+#include ""absl/status/statusor.h""+#include ""absl/strings/str_cat.h""+#include ""absl/strings/str_format.h""+#include ""absl/strings/strip.h""+#include ""absl/types/optional.h""++#include <grpc/event_engine/event_engine.h>+#include <grpc/grpc.h>+#include <grpc/support/log.h>++#include ""src/core/ext/filters/client_channel/lb_policy/grpclb/grpclb_balancer_addresses.h""+#include ""src/core/ext/filters/client_channel/resolver/dns/event_engine/service_config_helper.h""+#include ""src/core/ext/filters/client_channel/resolver/polling_resolver.h""+#include ""src/core/lib/backoff/backoff.h""+#include ""src/core/lib/channel/channel_args.h""+#include ""src/core/lib/debug/trace.h""+#include ""src/core/lib/event_engine/handle_containers.h""+#include ""src/core/lib/event_engine/resolved_address_internal.h""+#include ""src/core/lib/event_engine/trace.h""+#include ""src/core/lib/event_engine/utils.h""+#include ""src/core/lib/gprpp/debug_location.h""+#include ""src/core/lib/gprpp/ref_counted_ptr.h""+#include ""src/core/lib/gprpp/status_helper.h""+#include ""src/core/lib/gprpp/sync.h""+#include ""src/core/lib/gprpp/time.h""+#include ""src/core/lib/iomgr/resolve_address.h""+#include ""src/core/lib/resolver/resolver.h""+#include ""src/core/lib/resolver/resolver_factory.h""+#include ""src/core/lib/resolver/server_address.h""+#include ""src/core/lib/service_config/service_config.h""+#include ""src/core/lib/service_config/service_config_impl.h""++// IWYU pragma: no_include <ratio>++namespace grpc_event_engine {+namespace experimental {++namespace {++#define GRPC_DNS_INITIAL_CONNECT_BACKOFF_SECONDS 1+#define GRPC_DNS_RECONNECT_BACKOFF_MULTIPLIER 1.6+#define GRPC_DNS_RECONNECT_MAX_BACKOFF_SECONDS 120+#define GRPC_DNS_RECONNECT_JITTER 0.2+#define GRPC_DNS_DEFAULT_QUERY_TIMEOUT_MS 120000++using grpc_core::BackOff;+using grpc_core::Duration;+using grpc_core::InternallyRefCounted;+using grpc_core::MakeOrphanable;+using grpc_core::Mutex;+using grpc_core::MutexLock;+using grpc_core::Orphanable;+using grpc_core::OrphanablePtr;+using grpc_core::RefCountedPtr;+using grpc_core::ResolverArgs;++// ----------------------------------------------------------------------------+// EventEngineDNSRequestWrapper declaration+// ----------------------------------------------------------------------------+class EventEngineClientChannelDNSResolver;++class EventEngineDNSRequestWrapper+    : public InternallyRefCounted<EventEngineDNSRequestWrapper> {+ public:+  EventEngineDNSRequestWrapper(+      RefCountedPtr<EventEngineClientChannelDNSResolver> resolver,+      std::unique_ptr<EventEngine::DNSResolver> event_engine_resolver);+  ~EventEngineDNSRequestWrapper() override;++  // Note that thread safety cannot be analyzed due to this being invoked from+  // OrphanablePtr<>, and there's no way to pass the lock annotation through+  // there.+  void Orphan() override ABSL_NO_THREAD_SAFETY_ANALYSIS;++  void OnHostnameResolved(+      absl::StatusOr<std::vector<EventEngine::ResolvedAddress>> addresses);+  void OnSRVResolved(+      std::string srv_host,+      absl::StatusOr<std::vector<EventEngine::DNSResolver::SRVRecord>>+          srv_records);+  void OnBalancerHostnamesResolved(+      std::string authority,+      absl::StatusOr<std::vector<EventEngine::ResolvedAddress>> addresses);+  void OnTXTResolved(absl::StatusOr<std::string> service_config);++  // Returns a Result if resolution is complete.+  // callers must release the lock and call OnRequestComplete if a Result is+  // returned. This is because OnRequestComplete may Orphan the resolver, which+  // requires taking the lock.+  absl::optional<grpc_core::Resolver::Result> OnResolvedLocked()+      ABSL_EXCLUSIVE_LOCKS_REQUIRED(on_resolved_mu_);++ private:+  // Helper method for generating the combined resolution status error+  absl::Status GetResolutionFailureErrorMessageLocked()+      ABSL_EXCLUSIVE_LOCKS_REQUIRED(on_resolved_mu_);+  // Helper method to populate server addresses on resolver result.+  void MaybePopulateAddressesLocked(grpc_core::Resolver::Result& result)+      ABSL_EXCLUSIVE_LOCKS_REQUIRED(on_resolved_mu_);+  // Helper method to populate balancer addresses on resolver result.+  void MaybePopulateBalancerAddressesLocked(grpc_core::Resolver::Result& result)+      ABSL_EXCLUSIVE_LOCKS_REQUIRED(on_resolved_mu_);+  // Helper method to populate service config on resolver result.+  void MaybePopulateServiceConfigLocked(grpc_core::Resolver::Result& result)+      ABSL_EXCLUSIVE_LOCKS_REQUIRED(on_resolved_mu_);+  // Convert empty results into resolution errors.+  //+  // TODO(roth): We should someday separate empty results (NXDOMAIN) from actual+  // DNS resolution errors. For now, they are treated the same so this resolver+  // behaves similarly to the old c-ares resolver.+  void NormalizeEmptyResultsToErrorsLocked()+      ABSL_EXCLUSIVE_LOCKS_REQUIRED(on_resolved_mu_);++  RefCountedPtr<EventEngineClientChannelDNSResolver> resolver_;+  Mutex on_resolved_mu_;+  // Lookup callbacks+  absl::optional<EventEngine::DNSResolver::LookupTaskHandle> hostname_handle_+      ABSL_GUARDED_BY(on_resolved_mu_);+  absl::optional<EventEngine::DNSResolver::LookupTaskHandle> srv_handle_+      ABSL_GUARDED_BY(on_resolved_mu_);+  absl::optional<EventEngine::DNSResolver::LookupTaskHandle> txt_handle_+      ABSL_GUARDED_BY(on_resolved_mu_);+  LookupTaskHandleSet balancer_hostname_handles_+      ABSL_GUARDED_BY(on_resolved_mu_);+  // Output fields from requests.+  absl::StatusOr<std::vector<EventEngine::ResolvedAddress>> addresses_+      ABSL_GUARDED_BY(on_resolved_mu_);+  absl::StatusOr<grpc_core::ServerAddressList> balancer_addresses_+      ABSL_GUARDED_BY(on_resolved_mu_);+  absl::StatusOr<std::string> service_config_json_+      ABSL_GUARDED_BY(on_resolved_mu_);+  // Other internal state+  size_t number_of_balancer_hostnames_resolved_+      ABSL_GUARDED_BY(on_resolved_mu_) = 0;+  bool orphaned_ ABSL_GUARDED_BY(on_resolved_mu_) = false;+  std::unique_ptr<EventEngine::DNSResolver> event_engine_resolver_;+};++// ----------------------------------------------------------------------------+// EventEngineClientChannelDNSResolver+// ----------------------------------------------------------------------------+class EventEngineClientChannelDNSResolver : public grpc_core::PollingResolver {+ public:+  EventEngineClientChannelDNSResolver(ResolverArgs args,+                                      Duration min_time_between_resolutions);+  OrphanablePtr<Orphanable> StartRequest() override;++ private:+  friend class EventEngineDNSRequestWrapper;++  /// whether to request the service config+  const bool request_service_config_;+  // whether or not to enable SRV DNS queries+  const bool enable_srv_queries_;+  // timeout in milliseconds for active DNS queries+  EventEngine::Duration query_timeout_ms_;+  std::shared_ptr<EventEngine> event_engine_;+};++EventEngineClientChannelDNSResolver::EventEngineClientChannelDNSResolver(+    ResolverArgs args, Duration min_time_between_resolutions)+    : PollingResolver(std::move(args), min_time_between_resolutions,+                      BackOff::Options()+                          .set_initial_backoff(Duration::Milliseconds(+                              GRPC_DNS_INITIAL_CONNECT_BACKOFF_SECONDS * 1000))+                          .set_multiplier(GRPC_DNS_RECONNECT_BACKOFF_MULTIPLIER)+                          .set_jitter(GRPC_DNS_RECONNECT_JITTER)+                          .set_max_backoff(Duration::Milliseconds(+                              GRPC_DNS_RECONNECT_MAX_BACKOFF_SECONDS * 1000)),+                      &grpc_event_engine_dns_trace),+      request_service_config_(+          !channel_args()+               .GetBool(GRPC_ARG_SERVICE_CONFIG_DISABLE_RESOLUTION)+               .value_or(true)),+      enable_srv_queries_(channel_args()+                              .GetBool(GRPC_ARG_DNS_ENABLE_SRV_QUERIES)+                              .value_or(false)),+      // TODO(yijiem): decide if the ares channel arg timeout should be reused.+      query_timeout_ms_(std::chrono::milliseconds(+          std::max(0, channel_args()+                          .GetInt(GRPC_ARG_DNS_ARES_QUERY_TIMEOUT_MS)+                          .value_or(GRPC_DNS_DEFAULT_QUERY_TIMEOUT_MS)))),+      event_engine_(channel_args().GetObjectRef<EventEngine>()) {}++OrphanablePtr<Orphanable> EventEngineClientChannelDNSResolver::StartRequest() {+  return MakeOrphanable<EventEngineDNSRequestWrapper>(+      Ref(DEBUG_LOCATION, ""dns-resolving""),+      event_engine_->GetDNSResolver({/*dns_server=*/authority()}));+}++// ----------------------------------------------------------------------------+// EventEngineDNSRequestWrapper definition+// ----------------------------------------------------------------------------++EventEngineDNSRequestWrapper::EventEngineDNSRequestWrapper(+    RefCountedPtr<EventEngineClientChannelDNSResolver> resolver,+    std::unique_ptr<EventEngine::DNSResolver> event_engine_resolver)+    : resolver_(std::move(resolver)),+      event_engine_resolver_(std::move(event_engine_resolver)) {+  // Locking to prevent completion before all records are queried+  MutexLock lock(&on_resolved_mu_);+  hostname_handle_ = event_engine_resolver_->LookupHostname(+      absl::bind_front(&EventEngineDNSRequestWrapper::OnHostnameResolved,+                       Ref(DEBUG_LOCATION, ""OnHostnameResolved"")),+      resolver_->name_to_resolve(), grpc_core::kDefaultSecurePort,+      resolver_->query_timeout_ms_);+  GRPC_EVENT_ENGINE_DNS_TRACE(+      ""DNSResolver::%p Started resolving hostname. Handle::%s"", resolver_.get(),+      HandleToString(*hostname_handle_).c_str());+  if (resolver_->enable_srv_queries_) {+    srv_handle_ = event_engine_resolver_->LookupSRV(+        absl::bind_front(&EventEngineDNSRequestWrapper::OnSRVResolved,+                         Ref(DEBUG_LOCATION, ""OnSRVResolved""),+                         resolver_->name_to_resolve()),+        resolver_->name_to_resolve(), resolver_->query_timeout_ms_);+    GRPC_EVENT_ENGINE_DNS_TRACE(+        ""DNSResolver::%p Started resolving SRV. Handle::%s"", resolver_.get(),+        HandleToString(*srv_handle_).c_str());+  }+  if (resolver_->request_service_config_) {+    txt_handle_ = event_engine_resolver_->LookupTXT(+        absl::bind_front(&EventEngineDNSRequestWrapper::OnTXTResolved,+                         Ref(DEBUG_LOCATION, ""OnTXTResolved"")),+        resolver_->name_to_resolve(), resolver_->query_timeout_ms_);+    GRPC_EVENT_ENGINE_DNS_TRACE(+        ""DNSResolver::%p Started resolving TXT. Handle::%s"", resolver_.get(),+        HandleToString(*txt_handle_).c_str());+  }+}++EventEngineDNSRequestWrapper::~EventEngineDNSRequestWrapper() {+  resolver_.reset(DEBUG_LOCATION, ""dns-resolving"");+}++void EventEngineDNSRequestWrapper::Orphan() {+  {+    MutexLock lock(&on_resolved_mu_);+    orphaned_ = true;+    // Event if cancellation fails here, OnResolvedLocked will return early, and+    // the resolver will never see a completed request.+    if (hostname_handle_.has_value()) {+      event_engine_resolver_->CancelLookup(*hostname_handle_);+    }+    if (srv_handle_.has_value()) {+      event_engine_resolver_->CancelLookup(*srv_handle_);+    }+    for (const auto& handle : balancer_hostname_handles_) {+      event_engine_resolver_->CancelLookup(handle);+    }+    if (txt_handle_.has_value()) {+      event_engine_resolver_->CancelLookup(*txt_handle_);+    }+  }+  Unref(DEBUG_LOCATION, ""Orphan"");+}++void EventEngineDNSRequestWrapper::OnHostnameResolved(+    absl::StatusOr<std::vector<EventEngine::ResolvedAddress>> addresses) {+  absl::optional<grpc_core::Resolver::Result> result;+  {+    MutexLock lock(&on_resolved_mu_);+    if (orphaned_) return;+    hostname_handle_.reset();+    addresses_ = addresses;+    result = OnResolvedLocked();+  }+  if (result.has_value()) {+    resolver_->OnRequestComplete(std::move(*result));+  }+}++void EventEngineDNSRequestWrapper::OnSRVResolved(+    std::string srv_host,","I don't think this parameter is needed.  As per my comment below, I think we actually want to pass a different value to `OnBalancerHostnamesResolved()`, and that's the only place this value was being used.  But even if this was needed, I think we could access the same value via `resolver_->name_to_resolve()`.",X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32632,1150785684,2023-03-28T15:17:05Z,src/core/ext/filters/client_channel/resolver/dns/event_engine/event_engine_client_channel_resolver.cc,"@@ -0,0 +1,535 @@+// Copyright 2023 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+#include <grpc/support/port_platform.h>++#include ""src/core/ext/filters/client_channel/resolver/dns/event_engine/event_engine_client_channel_resolver.h""++#include <stddef.h>+#include <stdint.h>++#include <algorithm>+#include <chrono>+#include <initializer_list>+#include <memory>+#include <string>+#include <utility>+#include <vector>++#include ""absl/base/thread_annotations.h""+#include ""absl/container/flat_hash_set.h""+#include ""absl/functional/bind_front.h""+#include ""absl/status/status.h""+#include ""absl/status/statusor.h""+#include ""absl/strings/str_cat.h""+#include ""absl/strings/str_format.h""+#include ""absl/strings/strip.h""+#include ""absl/types/optional.h""++#include <grpc/event_engine/event_engine.h>+#include <grpc/grpc.h>+#include <grpc/support/log.h>++#include ""src/core/ext/filters/client_channel/lb_policy/grpclb/grpclb_balancer_addresses.h""+#include ""src/core/ext/filters/client_channel/resolver/dns/event_engine/service_config_helper.h""+#include ""src/core/ext/filters/client_channel/resolver/polling_resolver.h""+#include ""src/core/lib/backoff/backoff.h""+#include ""src/core/lib/channel/channel_args.h""+#include ""src/core/lib/debug/trace.h""+#include ""src/core/lib/event_engine/handle_containers.h""+#include ""src/core/lib/event_engine/resolved_address_internal.h""+#include ""src/core/lib/event_engine/trace.h""+#include ""src/core/lib/event_engine/utils.h""+#include ""src/core/lib/gprpp/debug_location.h""+#include ""src/core/lib/gprpp/ref_counted_ptr.h""+#include ""src/core/lib/gprpp/status_helper.h""+#include ""src/core/lib/gprpp/sync.h""+#include ""src/core/lib/gprpp/time.h""+#include ""src/core/lib/iomgr/resolve_address.h""+#include ""src/core/lib/resolver/resolver.h""+#include ""src/core/lib/resolver/resolver_factory.h""+#include ""src/core/lib/resolver/server_address.h""+#include ""src/core/lib/service_config/service_config.h""+#include ""src/core/lib/service_config/service_config_impl.h""++// IWYU pragma: no_include <ratio>++namespace grpc_event_engine {+namespace experimental {++namespace {++#define GRPC_DNS_INITIAL_CONNECT_BACKOFF_SECONDS 1+#define GRPC_DNS_RECONNECT_BACKOFF_MULTIPLIER 1.6+#define GRPC_DNS_RECONNECT_MAX_BACKOFF_SECONDS 120+#define GRPC_DNS_RECONNECT_JITTER 0.2+#define GRPC_DNS_DEFAULT_QUERY_TIMEOUT_MS 120000++using grpc_core::BackOff;+using grpc_core::Duration;+using grpc_core::InternallyRefCounted;+using grpc_core::MakeOrphanable;+using grpc_core::Mutex;+using grpc_core::MutexLock;+using grpc_core::Orphanable;+using grpc_core::OrphanablePtr;+using grpc_core::RefCountedPtr;+using grpc_core::ResolverArgs;++// ----------------------------------------------------------------------------+// EventEngineDNSRequestWrapper declaration+// ----------------------------------------------------------------------------+class EventEngineClientChannelDNSResolver;++class EventEngineDNSRequestWrapper+    : public InternallyRefCounted<EventEngineDNSRequestWrapper> {+ public:+  EventEngineDNSRequestWrapper(+      RefCountedPtr<EventEngineClientChannelDNSResolver> resolver,+      std::unique_ptr<EventEngine::DNSResolver> event_engine_resolver);+  ~EventEngineDNSRequestWrapper() override;++  // Note that thread safety cannot be analyzed due to this being invoked from+  // OrphanablePtr<>, and there's no way to pass the lock annotation through+  // there.+  void Orphan() override ABSL_NO_THREAD_SAFETY_ANALYSIS;++  void OnHostnameResolved(+      absl::StatusOr<std::vector<EventEngine::ResolvedAddress>> addresses);+  void OnSRVResolved(+      std::string srv_host,+      absl::StatusOr<std::vector<EventEngine::DNSResolver::SRVRecord>>+          srv_records);+  void OnBalancerHostnamesResolved(+      std::string authority,+      absl::StatusOr<std::vector<EventEngine::ResolvedAddress>> addresses);+  void OnTXTResolved(absl::StatusOr<std::string> service_config);++  // Returns a Result if resolution is complete.+  // callers must release the lock and call OnRequestComplete if a Result is+  // returned. This is because OnRequestComplete may Orphan the resolver, which+  // requires taking the lock.+  absl::optional<grpc_core::Resolver::Result> OnResolvedLocked()+      ABSL_EXCLUSIVE_LOCKS_REQUIRED(on_resolved_mu_);++ private:+  // Helper method for generating the combined resolution status error+  absl::Status GetResolutionFailureErrorMessageLocked()+      ABSL_EXCLUSIVE_LOCKS_REQUIRED(on_resolved_mu_);+  // Helper method to populate server addresses on resolver result.+  void MaybePopulateAddressesLocked(grpc_core::Resolver::Result& result)+      ABSL_EXCLUSIVE_LOCKS_REQUIRED(on_resolved_mu_);+  // Helper method to populate balancer addresses on resolver result.+  void MaybePopulateBalancerAddressesLocked(grpc_core::Resolver::Result& result)+      ABSL_EXCLUSIVE_LOCKS_REQUIRED(on_resolved_mu_);+  // Helper method to populate service config on resolver result.+  void MaybePopulateServiceConfigLocked(grpc_core::Resolver::Result& result)+      ABSL_EXCLUSIVE_LOCKS_REQUIRED(on_resolved_mu_);+  // Convert empty results into resolution errors.+  //+  // TODO(roth): We should someday separate empty results (NXDOMAIN) from actual+  // DNS resolution errors. For now, they are treated the same so this resolver+  // behaves similarly to the old c-ares resolver.+  void NormalizeEmptyResultsToErrorsLocked()+      ABSL_EXCLUSIVE_LOCKS_REQUIRED(on_resolved_mu_);++  RefCountedPtr<EventEngineClientChannelDNSResolver> resolver_;+  Mutex on_resolved_mu_;+  // Lookup callbacks+  absl::optional<EventEngine::DNSResolver::LookupTaskHandle> hostname_handle_+      ABSL_GUARDED_BY(on_resolved_mu_);+  absl::optional<EventEngine::DNSResolver::LookupTaskHandle> srv_handle_+      ABSL_GUARDED_BY(on_resolved_mu_);+  absl::optional<EventEngine::DNSResolver::LookupTaskHandle> txt_handle_+      ABSL_GUARDED_BY(on_resolved_mu_);+  LookupTaskHandleSet balancer_hostname_handles_+      ABSL_GUARDED_BY(on_resolved_mu_);+  // Output fields from requests.+  absl::StatusOr<std::vector<EventEngine::ResolvedAddress>> addresses_+      ABSL_GUARDED_BY(on_resolved_mu_);+  absl::StatusOr<grpc_core::ServerAddressList> balancer_addresses_+      ABSL_GUARDED_BY(on_resolved_mu_);+  absl::StatusOr<std::string> service_config_json_+      ABSL_GUARDED_BY(on_resolved_mu_);+  // Other internal state+  size_t number_of_balancer_hostnames_resolved_+      ABSL_GUARDED_BY(on_resolved_mu_) = 0;+  bool orphaned_ ABSL_GUARDED_BY(on_resolved_mu_) = false;+  std::unique_ptr<EventEngine::DNSResolver> event_engine_resolver_;+};++// ----------------------------------------------------------------------------+// EventEngineClientChannelDNSResolver+// ----------------------------------------------------------------------------+class EventEngineClientChannelDNSResolver : public grpc_core::PollingResolver {+ public:+  EventEngineClientChannelDNSResolver(ResolverArgs args,+                                      Duration min_time_between_resolutions);+  OrphanablePtr<Orphanable> StartRequest() override;++ private:+  friend class EventEngineDNSRequestWrapper;++  /// whether to request the service config+  const bool request_service_config_;+  // whether or not to enable SRV DNS queries+  const bool enable_srv_queries_;+  // timeout in milliseconds for active DNS queries+  EventEngine::Duration query_timeout_ms_;+  std::shared_ptr<EventEngine> event_engine_;+};++EventEngineClientChannelDNSResolver::EventEngineClientChannelDNSResolver(+    ResolverArgs args, Duration min_time_between_resolutions)+    : PollingResolver(std::move(args), min_time_between_resolutions,+                      BackOff::Options()+                          .set_initial_backoff(Duration::Milliseconds(+                              GRPC_DNS_INITIAL_CONNECT_BACKOFF_SECONDS * 1000))+                          .set_multiplier(GRPC_DNS_RECONNECT_BACKOFF_MULTIPLIER)+                          .set_jitter(GRPC_DNS_RECONNECT_JITTER)+                          .set_max_backoff(Duration::Milliseconds(+                              GRPC_DNS_RECONNECT_MAX_BACKOFF_SECONDS * 1000)),+                      &grpc_event_engine_dns_trace),+      request_service_config_(+          !channel_args()+               .GetBool(GRPC_ARG_SERVICE_CONFIG_DISABLE_RESOLUTION)+               .value_or(true)),+      enable_srv_queries_(channel_args()+                              .GetBool(GRPC_ARG_DNS_ENABLE_SRV_QUERIES)+                              .value_or(false)),+      // TODO(yijiem): decide if the ares channel arg timeout should be reused.+      query_timeout_ms_(std::chrono::milliseconds(+          std::max(0, channel_args()+                          .GetInt(GRPC_ARG_DNS_ARES_QUERY_TIMEOUT_MS)+                          .value_or(GRPC_DNS_DEFAULT_QUERY_TIMEOUT_MS)))),+      event_engine_(channel_args().GetObjectRef<EventEngine>()) {}++OrphanablePtr<Orphanable> EventEngineClientChannelDNSResolver::StartRequest() {+  return MakeOrphanable<EventEngineDNSRequestWrapper>(+      Ref(DEBUG_LOCATION, ""dns-resolving""),+      event_engine_->GetDNSResolver({/*dns_server=*/authority()}));+}++// ----------------------------------------------------------------------------+// EventEngineDNSRequestWrapper definition+// ----------------------------------------------------------------------------++EventEngineDNSRequestWrapper::EventEngineDNSRequestWrapper(+    RefCountedPtr<EventEngineClientChannelDNSResolver> resolver,+    std::unique_ptr<EventEngine::DNSResolver> event_engine_resolver)+    : resolver_(std::move(resolver)),+      event_engine_resolver_(std::move(event_engine_resolver)) {+  // Locking to prevent completion before all records are queried+  MutexLock lock(&on_resolved_mu_);+  hostname_handle_ = event_engine_resolver_->LookupHostname(+      absl::bind_front(&EventEngineDNSRequestWrapper::OnHostnameResolved,+                       Ref(DEBUG_LOCATION, ""OnHostnameResolved"")),+      resolver_->name_to_resolve(), grpc_core::kDefaultSecurePort,+      resolver_->query_timeout_ms_);+  GRPC_EVENT_ENGINE_DNS_TRACE(+      ""DNSResolver::%p Started resolving hostname. Handle::%s"", resolver_.get(),+      HandleToString(*hostname_handle_).c_str());+  if (resolver_->enable_srv_queries_) {+    srv_handle_ = event_engine_resolver_->LookupSRV(+        absl::bind_front(&EventEngineDNSRequestWrapper::OnSRVResolved,+                         Ref(DEBUG_LOCATION, ""OnSRVResolved""),+                         resolver_->name_to_resolve()),+        resolver_->name_to_resolve(), resolver_->query_timeout_ms_);+    GRPC_EVENT_ENGINE_DNS_TRACE(+        ""DNSResolver::%p Started resolving SRV. Handle::%s"", resolver_.get(),+        HandleToString(*srv_handle_).c_str());+  }+  if (resolver_->request_service_config_) {+    txt_handle_ = event_engine_resolver_->LookupTXT(+        absl::bind_front(&EventEngineDNSRequestWrapper::OnTXTResolved,+                         Ref(DEBUG_LOCATION, ""OnTXTResolved"")),+        resolver_->name_to_resolve(), resolver_->query_timeout_ms_);+    GRPC_EVENT_ENGINE_DNS_TRACE(+        ""DNSResolver::%p Started resolving TXT. Handle::%s"", resolver_.get(),+        HandleToString(*txt_handle_).c_str());+  }+}++EventEngineDNSRequestWrapper::~EventEngineDNSRequestWrapper() {+  resolver_.reset(DEBUG_LOCATION, ""dns-resolving"");+}++void EventEngineDNSRequestWrapper::Orphan() {+  {+    MutexLock lock(&on_resolved_mu_);+    orphaned_ = true;+    // Event if cancellation fails here, OnResolvedLocked will return early, and+    // the resolver will never see a completed request.+    if (hostname_handle_.has_value()) {+      event_engine_resolver_->CancelLookup(*hostname_handle_);+    }+    if (srv_handle_.has_value()) {+      event_engine_resolver_->CancelLookup(*srv_handle_);+    }+    for (const auto& handle : balancer_hostname_handles_) {+      event_engine_resolver_->CancelLookup(handle);+    }+    if (txt_handle_.has_value()) {+      event_engine_resolver_->CancelLookup(*txt_handle_);+    }+  }+  Unref(DEBUG_LOCATION, ""Orphan"");+}++void EventEngineDNSRequestWrapper::OnHostnameResolved(+    absl::StatusOr<std::vector<EventEngine::ResolvedAddress>> addresses) {+  absl::optional<grpc_core::Resolver::Result> result;+  {+    MutexLock lock(&on_resolved_mu_);+    if (orphaned_) return;+    hostname_handle_.reset();+    addresses_ = addresses;+    result = OnResolvedLocked();+  }+  if (result.has_value()) {+    resolver_->OnRequestComplete(std::move(*result));+  }+}++void EventEngineDNSRequestWrapper::OnSRVResolved(+    std::string srv_host,+    absl::StatusOr<std::vector<EventEngine::DNSResolver::SRVRecord>>+        srv_records) {+  absl::optional<grpc_core::Resolver::Result> result;+  {+    MutexLock lock(&on_resolved_mu_);+    if (orphaned_) return;+    srv_handle_.reset();+    if (srv_records.ok()) {+      balancer_addresses_ = grpc_core::ServerAddressList();+      // Do a subsequent hostname query if SRV records were returned+      for (const auto& srv_record : *srv_records) {+        balancer_hostname_handles_.insert(+            event_engine_resolver_->LookupHostname(+                absl::bind_front(+                    &EventEngineDNSRequestWrapper::OnBalancerHostnamesResolved,+                    Ref(DEBUG_LOCATION, ""OnBalancerHostnamesResolved""),+                    srv_host),+                srv_record.host, std::to_string(srv_record.port),+                resolver_->query_timeout_ms_));+        GRPC_EVENT_ENGINE_DNS_TRACE(+            ""DNSResolver::%p Started resolving balancer hostname %s:%d"",+            resolver_.get(), srv_record.host.c_str(), srv_record.port);+      }+      return;+    }+    // An error has occurred, finish resolving.+    balancer_addresses_ = srv_records.status();+    result = OnResolvedLocked();+  }+  if (result.has_value()) {+    resolver_->OnRequestComplete(std::move(*result));+  }+}++void EventEngineDNSRequestWrapper::OnBalancerHostnamesResolved(+    std::string authority,+    absl::StatusOr<std::vector<EventEngine::ResolvedAddress>>+        new_balancer_addresses) {+  absl::optional<grpc_core::Resolver::Result> result;+  {+    MutexLock lock(&on_resolved_mu_);+    if (orphaned_) return;+    ++number_of_balancer_hostnames_resolved_;+    if (new_balancer_addresses.ok()) {+      if (!balancer_addresses_.ok()) {+        GRPC_EVENT_ENGINE_DNS_TRACE(+            ""DNSResolver::%p previous balancer hostname lookup error, ignoring ""+            ""%zu found hostnames."",+            this, new_balancer_addresses->size());+      }+      balancer_addresses_->reserve(balancer_addresses_->size() ++                                   new_balancer_addresses->size());+      auto srv_channel_args =+          resolver_->channel_args().Set(GRPC_ARG_DEFAULT_AUTHORITY, authority);+      for (const auto& addr : *new_balancer_addresses) {+        balancer_addresses_->emplace_back(CreateGRPCResolvedAddress(addr),+                                          srv_channel_args);+      }+    } else {+      auto tmp_status = balancer_addresses_.status();+      grpc_core::StatusAddChild(&tmp_status, new_balancer_addresses.status());","Let's not use the deprecated child-error mechanism.  Instead, let's just concatenate the error messages into a single string, so that it looks something like this:""""""Errors looking up balancer addresses: [authority1: error message 1; authority2: error message 2; ...]""""""That will yield much more useful error messages for users.I think it's fine to hard-code the status code to UNAVAILABLE rather than trying to figure out how to merge different codes returned from the EE impl.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32632,1150790730,2023-03-28T15:20:36Z,src/core/ext/filters/client_channel/resolver/dns/event_engine/event_engine_client_channel_resolver.cc,"@@ -0,0 +1,535 @@+// Copyright 2023 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+#include <grpc/support/port_platform.h>++#include ""src/core/ext/filters/client_channel/resolver/dns/event_engine/event_engine_client_channel_resolver.h""++#include <stddef.h>+#include <stdint.h>++#include <algorithm>+#include <chrono>+#include <initializer_list>+#include <memory>+#include <string>+#include <utility>+#include <vector>++#include ""absl/base/thread_annotations.h""+#include ""absl/container/flat_hash_set.h""+#include ""absl/functional/bind_front.h""+#include ""absl/status/status.h""+#include ""absl/status/statusor.h""+#include ""absl/strings/str_cat.h""+#include ""absl/strings/str_format.h""+#include ""absl/strings/strip.h""+#include ""absl/types/optional.h""++#include <grpc/event_engine/event_engine.h>+#include <grpc/grpc.h>+#include <grpc/support/log.h>++#include ""src/core/ext/filters/client_channel/lb_policy/grpclb/grpclb_balancer_addresses.h""+#include ""src/core/ext/filters/client_channel/resolver/dns/event_engine/service_config_helper.h""+#include ""src/core/ext/filters/client_channel/resolver/polling_resolver.h""+#include ""src/core/lib/backoff/backoff.h""+#include ""src/core/lib/channel/channel_args.h""+#include ""src/core/lib/debug/trace.h""+#include ""src/core/lib/event_engine/handle_containers.h""+#include ""src/core/lib/event_engine/resolved_address_internal.h""+#include ""src/core/lib/event_engine/trace.h""+#include ""src/core/lib/event_engine/utils.h""+#include ""src/core/lib/gprpp/debug_location.h""+#include ""src/core/lib/gprpp/ref_counted_ptr.h""+#include ""src/core/lib/gprpp/status_helper.h""+#include ""src/core/lib/gprpp/sync.h""+#include ""src/core/lib/gprpp/time.h""+#include ""src/core/lib/iomgr/resolve_address.h""+#include ""src/core/lib/resolver/resolver.h""+#include ""src/core/lib/resolver/resolver_factory.h""+#include ""src/core/lib/resolver/server_address.h""+#include ""src/core/lib/service_config/service_config.h""+#include ""src/core/lib/service_config/service_config_impl.h""++// IWYU pragma: no_include <ratio>++namespace grpc_event_engine {+namespace experimental {++namespace {++#define GRPC_DNS_INITIAL_CONNECT_BACKOFF_SECONDS 1+#define GRPC_DNS_RECONNECT_BACKOFF_MULTIPLIER 1.6+#define GRPC_DNS_RECONNECT_MAX_BACKOFF_SECONDS 120+#define GRPC_DNS_RECONNECT_JITTER 0.2+#define GRPC_DNS_DEFAULT_QUERY_TIMEOUT_MS 120000++using grpc_core::BackOff;+using grpc_core::Duration;+using grpc_core::InternallyRefCounted;+using grpc_core::MakeOrphanable;+using grpc_core::Mutex;+using grpc_core::MutexLock;+using grpc_core::Orphanable;+using grpc_core::OrphanablePtr;+using grpc_core::RefCountedPtr;+using grpc_core::ResolverArgs;++// ----------------------------------------------------------------------------+// EventEngineDNSRequestWrapper declaration+// ----------------------------------------------------------------------------+class EventEngineClientChannelDNSResolver;++class EventEngineDNSRequestWrapper+    : public InternallyRefCounted<EventEngineDNSRequestWrapper> {+ public:+  EventEngineDNSRequestWrapper(+      RefCountedPtr<EventEngineClientChannelDNSResolver> resolver,+      std::unique_ptr<EventEngine::DNSResolver> event_engine_resolver);+  ~EventEngineDNSRequestWrapper() override;++  // Note that thread safety cannot be analyzed due to this being invoked from+  // OrphanablePtr<>, and there's no way to pass the lock annotation through+  // there.+  void Orphan() override ABSL_NO_THREAD_SAFETY_ANALYSIS;++  void OnHostnameResolved(+      absl::StatusOr<std::vector<EventEngine::ResolvedAddress>> addresses);+  void OnSRVResolved(+      std::string srv_host,+      absl::StatusOr<std::vector<EventEngine::DNSResolver::SRVRecord>>+          srv_records);+  void OnBalancerHostnamesResolved(+      std::string authority,+      absl::StatusOr<std::vector<EventEngine::ResolvedAddress>> addresses);+  void OnTXTResolved(absl::StatusOr<std::string> service_config);++  // Returns a Result if resolution is complete.+  // callers must release the lock and call OnRequestComplete if a Result is+  // returned. This is because OnRequestComplete may Orphan the resolver, which+  // requires taking the lock.+  absl::optional<grpc_core::Resolver::Result> OnResolvedLocked()+      ABSL_EXCLUSIVE_LOCKS_REQUIRED(on_resolved_mu_);++ private:+  // Helper method for generating the combined resolution status error+  absl::Status GetResolutionFailureErrorMessageLocked()+      ABSL_EXCLUSIVE_LOCKS_REQUIRED(on_resolved_mu_);+  // Helper method to populate server addresses on resolver result.+  void MaybePopulateAddressesLocked(grpc_core::Resolver::Result& result)+      ABSL_EXCLUSIVE_LOCKS_REQUIRED(on_resolved_mu_);+  // Helper method to populate balancer addresses on resolver result.+  void MaybePopulateBalancerAddressesLocked(grpc_core::Resolver::Result& result)+      ABSL_EXCLUSIVE_LOCKS_REQUIRED(on_resolved_mu_);+  // Helper method to populate service config on resolver result.+  void MaybePopulateServiceConfigLocked(grpc_core::Resolver::Result& result)+      ABSL_EXCLUSIVE_LOCKS_REQUIRED(on_resolved_mu_);+  // Convert empty results into resolution errors.+  //+  // TODO(roth): We should someday separate empty results (NXDOMAIN) from actual+  // DNS resolution errors. For now, they are treated the same so this resolver+  // behaves similarly to the old c-ares resolver.+  void NormalizeEmptyResultsToErrorsLocked()+      ABSL_EXCLUSIVE_LOCKS_REQUIRED(on_resolved_mu_);++  RefCountedPtr<EventEngineClientChannelDNSResolver> resolver_;+  Mutex on_resolved_mu_;+  // Lookup callbacks+  absl::optional<EventEngine::DNSResolver::LookupTaskHandle> hostname_handle_+      ABSL_GUARDED_BY(on_resolved_mu_);+  absl::optional<EventEngine::DNSResolver::LookupTaskHandle> srv_handle_+      ABSL_GUARDED_BY(on_resolved_mu_);+  absl::optional<EventEngine::DNSResolver::LookupTaskHandle> txt_handle_+      ABSL_GUARDED_BY(on_resolved_mu_);+  LookupTaskHandleSet balancer_hostname_handles_+      ABSL_GUARDED_BY(on_resolved_mu_);+  // Output fields from requests.+  absl::StatusOr<std::vector<EventEngine::ResolvedAddress>> addresses_+      ABSL_GUARDED_BY(on_resolved_mu_);+  absl::StatusOr<grpc_core::ServerAddressList> balancer_addresses_+      ABSL_GUARDED_BY(on_resolved_mu_);+  absl::StatusOr<std::string> service_config_json_+      ABSL_GUARDED_BY(on_resolved_mu_);+  // Other internal state+  size_t number_of_balancer_hostnames_resolved_+      ABSL_GUARDED_BY(on_resolved_mu_) = 0;+  bool orphaned_ ABSL_GUARDED_BY(on_resolved_mu_) = false;+  std::unique_ptr<EventEngine::DNSResolver> event_engine_resolver_;+};++// ----------------------------------------------------------------------------+// EventEngineClientChannelDNSResolver+// ----------------------------------------------------------------------------+class EventEngineClientChannelDNSResolver : public grpc_core::PollingResolver {+ public:+  EventEngineClientChannelDNSResolver(ResolverArgs args,+                                      Duration min_time_between_resolutions);+  OrphanablePtr<Orphanable> StartRequest() override;++ private:+  friend class EventEngineDNSRequestWrapper;++  /// whether to request the service config+  const bool request_service_config_;+  // whether or not to enable SRV DNS queries+  const bool enable_srv_queries_;+  // timeout in milliseconds for active DNS queries+  EventEngine::Duration query_timeout_ms_;+  std::shared_ptr<EventEngine> event_engine_;+};++EventEngineClientChannelDNSResolver::EventEngineClientChannelDNSResolver(+    ResolverArgs args, Duration min_time_between_resolutions)+    : PollingResolver(std::move(args), min_time_between_resolutions,+                      BackOff::Options()+                          .set_initial_backoff(Duration::Milliseconds(+                              GRPC_DNS_INITIAL_CONNECT_BACKOFF_SECONDS * 1000))+                          .set_multiplier(GRPC_DNS_RECONNECT_BACKOFF_MULTIPLIER)+                          .set_jitter(GRPC_DNS_RECONNECT_JITTER)+                          .set_max_backoff(Duration::Milliseconds(+                              GRPC_DNS_RECONNECT_MAX_BACKOFF_SECONDS * 1000)),+                      &grpc_event_engine_dns_trace),+      request_service_config_(+          !channel_args()+               .GetBool(GRPC_ARG_SERVICE_CONFIG_DISABLE_RESOLUTION)+               .value_or(true)),+      enable_srv_queries_(channel_args()+                              .GetBool(GRPC_ARG_DNS_ENABLE_SRV_QUERIES)+                              .value_or(false)),+      // TODO(yijiem): decide if the ares channel arg timeout should be reused.+      query_timeout_ms_(std::chrono::milliseconds(+          std::max(0, channel_args()+                          .GetInt(GRPC_ARG_DNS_ARES_QUERY_TIMEOUT_MS)+                          .value_or(GRPC_DNS_DEFAULT_QUERY_TIMEOUT_MS)))),+      event_engine_(channel_args().GetObjectRef<EventEngine>()) {}++OrphanablePtr<Orphanable> EventEngineClientChannelDNSResolver::StartRequest() {+  return MakeOrphanable<EventEngineDNSRequestWrapper>(+      Ref(DEBUG_LOCATION, ""dns-resolving""),+      event_engine_->GetDNSResolver({/*dns_server=*/authority()}));+}++// ----------------------------------------------------------------------------+// EventEngineDNSRequestWrapper definition+// ----------------------------------------------------------------------------++EventEngineDNSRequestWrapper::EventEngineDNSRequestWrapper(+    RefCountedPtr<EventEngineClientChannelDNSResolver> resolver,+    std::unique_ptr<EventEngine::DNSResolver> event_engine_resolver)+    : resolver_(std::move(resolver)),+      event_engine_resolver_(std::move(event_engine_resolver)) {+  // Locking to prevent completion before all records are queried+  MutexLock lock(&on_resolved_mu_);+  hostname_handle_ = event_engine_resolver_->LookupHostname(+      absl::bind_front(&EventEngineDNSRequestWrapper::OnHostnameResolved,+                       Ref(DEBUG_LOCATION, ""OnHostnameResolved"")),+      resolver_->name_to_resolve(), grpc_core::kDefaultSecurePort,+      resolver_->query_timeout_ms_);+  GRPC_EVENT_ENGINE_DNS_TRACE(+      ""DNSResolver::%p Started resolving hostname. Handle::%s"", resolver_.get(),+      HandleToString(*hostname_handle_).c_str());+  if (resolver_->enable_srv_queries_) {+    srv_handle_ = event_engine_resolver_->LookupSRV(+        absl::bind_front(&EventEngineDNSRequestWrapper::OnSRVResolved,+                         Ref(DEBUG_LOCATION, ""OnSRVResolved""),+                         resolver_->name_to_resolve()),+        resolver_->name_to_resolve(), resolver_->query_timeout_ms_);+    GRPC_EVENT_ENGINE_DNS_TRACE(+        ""DNSResolver::%p Started resolving SRV. Handle::%s"", resolver_.get(),+        HandleToString(*srv_handle_).c_str());+  }+  if (resolver_->request_service_config_) {+    txt_handle_ = event_engine_resolver_->LookupTXT(+        absl::bind_front(&EventEngineDNSRequestWrapper::OnTXTResolved,+                         Ref(DEBUG_LOCATION, ""OnTXTResolved"")),+        resolver_->name_to_resolve(), resolver_->query_timeout_ms_);+    GRPC_EVENT_ENGINE_DNS_TRACE(+        ""DNSResolver::%p Started resolving TXT. Handle::%s"", resolver_.get(),+        HandleToString(*txt_handle_).c_str());+  }+}++EventEngineDNSRequestWrapper::~EventEngineDNSRequestWrapper() {+  resolver_.reset(DEBUG_LOCATION, ""dns-resolving"");+}++void EventEngineDNSRequestWrapper::Orphan() {+  {+    MutexLock lock(&on_resolved_mu_);+    orphaned_ = true;+    // Event if cancellation fails here, OnResolvedLocked will return early, and+    // the resolver will never see a completed request.+    if (hostname_handle_.has_value()) {+      event_engine_resolver_->CancelLookup(*hostname_handle_);+    }+    if (srv_handle_.has_value()) {+      event_engine_resolver_->CancelLookup(*srv_handle_);+    }+    for (const auto& handle : balancer_hostname_handles_) {+      event_engine_resolver_->CancelLookup(handle);+    }+    if (txt_handle_.has_value()) {+      event_engine_resolver_->CancelLookup(*txt_handle_);+    }+  }+  Unref(DEBUG_LOCATION, ""Orphan"");+}++void EventEngineDNSRequestWrapper::OnHostnameResolved(+    absl::StatusOr<std::vector<EventEngine::ResolvedAddress>> addresses) {+  absl::optional<grpc_core::Resolver::Result> result;+  {+    MutexLock lock(&on_resolved_mu_);+    if (orphaned_) return;+    hostname_handle_.reset();+    addresses_ = addresses;+    result = OnResolvedLocked();+  }+  if (result.has_value()) {+    resolver_->OnRequestComplete(std::move(*result));+  }+}++void EventEngineDNSRequestWrapper::OnSRVResolved(+    std::string srv_host,+    absl::StatusOr<std::vector<EventEngine::DNSResolver::SRVRecord>>+        srv_records) {+  absl::optional<grpc_core::Resolver::Result> result;+  {+    MutexLock lock(&on_resolved_mu_);+    if (orphaned_) return;+    srv_handle_.reset();+    if (srv_records.ok()) {+      balancer_addresses_ = grpc_core::ServerAddressList();+      // Do a subsequent hostname query if SRV records were returned+      for (const auto& srv_record : *srv_records) {+        balancer_hostname_handles_.insert(+            event_engine_resolver_->LookupHostname(+                absl::bind_front(+                    &EventEngineDNSRequestWrapper::OnBalancerHostnamesResolved,+                    Ref(DEBUG_LOCATION, ""OnBalancerHostnamesResolved""),+                    srv_host),+                srv_record.host, std::to_string(srv_record.port),+                resolver_->query_timeout_ms_));+        GRPC_EVENT_ENGINE_DNS_TRACE(+            ""DNSResolver::%p Started resolving balancer hostname %s:%d"",+            resolver_.get(), srv_record.host.c_str(), srv_record.port);+      }+      return;+    }+    // An error has occurred, finish resolving.+    balancer_addresses_ = srv_records.status();+    result = OnResolvedLocked();+  }+  if (result.has_value()) {+    resolver_->OnRequestComplete(std::move(*result));+  }+}++void EventEngineDNSRequestWrapper::OnBalancerHostnamesResolved(+    std::string authority,+    absl::StatusOr<std::vector<EventEngine::ResolvedAddress>>+        new_balancer_addresses) {+  absl::optional<grpc_core::Resolver::Result> result;+  {+    MutexLock lock(&on_resolved_mu_);+    if (orphaned_) return;+    ++number_of_balancer_hostnames_resolved_;+    if (new_balancer_addresses.ok()) {+      if (!balancer_addresses_.ok()) {+        GRPC_EVENT_ENGINE_DNS_TRACE(+            ""DNSResolver::%p previous balancer hostname lookup error, ignoring ""+            ""%zu found hostnames."",+            this, new_balancer_addresses->size());+      }+      balancer_addresses_->reserve(balancer_addresses_->size() ++                                   new_balancer_addresses->size());+      auto srv_channel_args =+          resolver_->channel_args().Set(GRPC_ARG_DEFAULT_AUTHORITY, authority);+      for (const auto& addr : *new_balancer_addresses) {+        balancer_addresses_->emplace_back(CreateGRPCResolvedAddress(addr),+                                          srv_channel_args);+      }+    } else {+      auto tmp_status = balancer_addresses_.status();+      grpc_core::StatusAddChild(&tmp_status, new_balancer_addresses.status());+      balancer_addresses_ = tmp_status;+    }+    result = OnResolvedLocked();+  }+  if (result.has_value()) {+    resolver_->OnRequestComplete(std::move(*result));+  }+}++void EventEngineDNSRequestWrapper::OnTXTResolved(+    absl::StatusOr<std::string> service_config) {+  absl::optional<grpc_core::Resolver::Result> result;+  {+    MutexLock lock(&on_resolved_mu_);+    if (orphaned_) return;+    GPR_ASSERT(txt_handle_.has_value());+    txt_handle_.reset();+    service_config_json_ = service_config;+    result = OnResolvedLocked();+  }+  if (result.has_value()) {+    resolver_->OnRequestComplete(std::move(*result));+  }+}++absl::Status+EventEngineDNSRequestWrapper::GetResolutionFailureErrorMessageLocked() {+  std::string error_msg =+      absl::StrFormat(""resolver:%p dns resolution failed."", this);+  if (!addresses_.ok()) {+    absl::StrAppend(&error_msg, "" Hostname lookup error: "",+                    grpc_core::StatusToString(addresses_.status()));+  }+  if (!balancer_addresses_.ok()) {+    absl::StrAppend(&error_msg, "" SRV lookup error: "",+                    grpc_core::StatusToString(balancer_addresses_.status()));+  }+  if (!service_config_json_.ok()) {+    absl::StrAppend(&error_msg, "" TXT lookup error: "",+                    grpc_core::StatusToString(service_config_json_.status()));+  }+  auto status = grpc_core::StatusCreate(","As mentioned above, let's not use the deprecated child-error mechanism.  Instead, let's just concatenate the error strings into a single string in a useful way.  This will yield better error messages for users.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32632,1150812909,2023-03-28T15:35:22Z,src/core/ext/filters/client_channel/resolver/dns/event_engine/event_engine_client_channel_resolver.cc,"@@ -0,0 +1,535 @@+// Copyright 2023 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+#include <grpc/support/port_platform.h>++#include ""src/core/ext/filters/client_channel/resolver/dns/event_engine/event_engine_client_channel_resolver.h""++#include <stddef.h>+#include <stdint.h>++#include <algorithm>+#include <chrono>+#include <initializer_list>+#include <memory>+#include <string>+#include <utility>+#include <vector>++#include ""absl/base/thread_annotations.h""+#include ""absl/container/flat_hash_set.h""+#include ""absl/functional/bind_front.h""+#include ""absl/status/status.h""+#include ""absl/status/statusor.h""+#include ""absl/strings/str_cat.h""+#include ""absl/strings/str_format.h""+#include ""absl/strings/strip.h""+#include ""absl/types/optional.h""++#include <grpc/event_engine/event_engine.h>+#include <grpc/grpc.h>+#include <grpc/support/log.h>++#include ""src/core/ext/filters/client_channel/lb_policy/grpclb/grpclb_balancer_addresses.h""+#include ""src/core/ext/filters/client_channel/resolver/dns/event_engine/service_config_helper.h""+#include ""src/core/ext/filters/client_channel/resolver/polling_resolver.h""+#include ""src/core/lib/backoff/backoff.h""+#include ""src/core/lib/channel/channel_args.h""+#include ""src/core/lib/debug/trace.h""+#include ""src/core/lib/event_engine/handle_containers.h""+#include ""src/core/lib/event_engine/resolved_address_internal.h""+#include ""src/core/lib/event_engine/trace.h""+#include ""src/core/lib/event_engine/utils.h""+#include ""src/core/lib/gprpp/debug_location.h""+#include ""src/core/lib/gprpp/ref_counted_ptr.h""+#include ""src/core/lib/gprpp/status_helper.h""+#include ""src/core/lib/gprpp/sync.h""+#include ""src/core/lib/gprpp/time.h""+#include ""src/core/lib/iomgr/resolve_address.h""+#include ""src/core/lib/resolver/resolver.h""+#include ""src/core/lib/resolver/resolver_factory.h""+#include ""src/core/lib/resolver/server_address.h""+#include ""src/core/lib/service_config/service_config.h""+#include ""src/core/lib/service_config/service_config_impl.h""++// IWYU pragma: no_include <ratio>++namespace grpc_event_engine {+namespace experimental {++namespace {++#define GRPC_DNS_INITIAL_CONNECT_BACKOFF_SECONDS 1+#define GRPC_DNS_RECONNECT_BACKOFF_MULTIPLIER 1.6+#define GRPC_DNS_RECONNECT_MAX_BACKOFF_SECONDS 120+#define GRPC_DNS_RECONNECT_JITTER 0.2+#define GRPC_DNS_DEFAULT_QUERY_TIMEOUT_MS 120000++using grpc_core::BackOff;+using grpc_core::Duration;+using grpc_core::InternallyRefCounted;+using grpc_core::MakeOrphanable;+using grpc_core::Mutex;+using grpc_core::MutexLock;+using grpc_core::Orphanable;+using grpc_core::OrphanablePtr;+using grpc_core::RefCountedPtr;+using grpc_core::ResolverArgs;++// ----------------------------------------------------------------------------+// EventEngineDNSRequestWrapper declaration+// ----------------------------------------------------------------------------+class EventEngineClientChannelDNSResolver;++class EventEngineDNSRequestWrapper+    : public InternallyRefCounted<EventEngineDNSRequestWrapper> {+ public:+  EventEngineDNSRequestWrapper(+      RefCountedPtr<EventEngineClientChannelDNSResolver> resolver,+      std::unique_ptr<EventEngine::DNSResolver> event_engine_resolver);+  ~EventEngineDNSRequestWrapper() override;++  // Note that thread safety cannot be analyzed due to this being invoked from+  // OrphanablePtr<>, and there's no way to pass the lock annotation through+  // there.+  void Orphan() override ABSL_NO_THREAD_SAFETY_ANALYSIS;++  void OnHostnameResolved(+      absl::StatusOr<std::vector<EventEngine::ResolvedAddress>> addresses);+  void OnSRVResolved(+      std::string srv_host,+      absl::StatusOr<std::vector<EventEngine::DNSResolver::SRVRecord>>+          srv_records);+  void OnBalancerHostnamesResolved(+      std::string authority,+      absl::StatusOr<std::vector<EventEngine::ResolvedAddress>> addresses);+  void OnTXTResolved(absl::StatusOr<std::string> service_config);++  // Returns a Result if resolution is complete.+  // callers must release the lock and call OnRequestComplete if a Result is+  // returned. This is because OnRequestComplete may Orphan the resolver, which+  // requires taking the lock.+  absl::optional<grpc_core::Resolver::Result> OnResolvedLocked()+      ABSL_EXCLUSIVE_LOCKS_REQUIRED(on_resolved_mu_);++ private:+  // Helper method for generating the combined resolution status error+  absl::Status GetResolutionFailureErrorMessageLocked()+      ABSL_EXCLUSIVE_LOCKS_REQUIRED(on_resolved_mu_);+  // Helper method to populate server addresses on resolver result.+  void MaybePopulateAddressesLocked(grpc_core::Resolver::Result& result)+      ABSL_EXCLUSIVE_LOCKS_REQUIRED(on_resolved_mu_);+  // Helper method to populate balancer addresses on resolver result.+  void MaybePopulateBalancerAddressesLocked(grpc_core::Resolver::Result& result)+      ABSL_EXCLUSIVE_LOCKS_REQUIRED(on_resolved_mu_);+  // Helper method to populate service config on resolver result.+  void MaybePopulateServiceConfigLocked(grpc_core::Resolver::Result& result)+      ABSL_EXCLUSIVE_LOCKS_REQUIRED(on_resolved_mu_);+  // Convert empty results into resolution errors.+  //+  // TODO(roth): We should someday separate empty results (NXDOMAIN) from actual+  // DNS resolution errors. For now, they are treated the same so this resolver+  // behaves similarly to the old c-ares resolver.+  void NormalizeEmptyResultsToErrorsLocked()+      ABSL_EXCLUSIVE_LOCKS_REQUIRED(on_resolved_mu_);++  RefCountedPtr<EventEngineClientChannelDNSResolver> resolver_;+  Mutex on_resolved_mu_;+  // Lookup callbacks+  absl::optional<EventEngine::DNSResolver::LookupTaskHandle> hostname_handle_+      ABSL_GUARDED_BY(on_resolved_mu_);+  absl::optional<EventEngine::DNSResolver::LookupTaskHandle> srv_handle_+      ABSL_GUARDED_BY(on_resolved_mu_);+  absl::optional<EventEngine::DNSResolver::LookupTaskHandle> txt_handle_+      ABSL_GUARDED_BY(on_resolved_mu_);+  LookupTaskHandleSet balancer_hostname_handles_+      ABSL_GUARDED_BY(on_resolved_mu_);+  // Output fields from requests.+  absl::StatusOr<std::vector<EventEngine::ResolvedAddress>> addresses_+      ABSL_GUARDED_BY(on_resolved_mu_);+  absl::StatusOr<grpc_core::ServerAddressList> balancer_addresses_+      ABSL_GUARDED_BY(on_resolved_mu_);+  absl::StatusOr<std::string> service_config_json_+      ABSL_GUARDED_BY(on_resolved_mu_);+  // Other internal state+  size_t number_of_balancer_hostnames_resolved_+      ABSL_GUARDED_BY(on_resolved_mu_) = 0;+  bool orphaned_ ABSL_GUARDED_BY(on_resolved_mu_) = false;+  std::unique_ptr<EventEngine::DNSResolver> event_engine_resolver_;+};++// ----------------------------------------------------------------------------+// EventEngineClientChannelDNSResolver+// ----------------------------------------------------------------------------+class EventEngineClientChannelDNSResolver : public grpc_core::PollingResolver {+ public:+  EventEngineClientChannelDNSResolver(ResolverArgs args,+                                      Duration min_time_between_resolutions);+  OrphanablePtr<Orphanable> StartRequest() override;++ private:+  friend class EventEngineDNSRequestWrapper;++  /// whether to request the service config+  const bool request_service_config_;+  // whether or not to enable SRV DNS queries+  const bool enable_srv_queries_;+  // timeout in milliseconds for active DNS queries+  EventEngine::Duration query_timeout_ms_;+  std::shared_ptr<EventEngine> event_engine_;+};++EventEngineClientChannelDNSResolver::EventEngineClientChannelDNSResolver(+    ResolverArgs args, Duration min_time_between_resolutions)+    : PollingResolver(std::move(args), min_time_between_resolutions,+                      BackOff::Options()+                          .set_initial_backoff(Duration::Milliseconds(+                              GRPC_DNS_INITIAL_CONNECT_BACKOFF_SECONDS * 1000))+                          .set_multiplier(GRPC_DNS_RECONNECT_BACKOFF_MULTIPLIER)+                          .set_jitter(GRPC_DNS_RECONNECT_JITTER)+                          .set_max_backoff(Duration::Milliseconds(+                              GRPC_DNS_RECONNECT_MAX_BACKOFF_SECONDS * 1000)),+                      &grpc_event_engine_dns_trace),+      request_service_config_(+          !channel_args()+               .GetBool(GRPC_ARG_SERVICE_CONFIG_DISABLE_RESOLUTION)+               .value_or(true)),+      enable_srv_queries_(channel_args()+                              .GetBool(GRPC_ARG_DNS_ENABLE_SRV_QUERIES)+                              .value_or(false)),+      // TODO(yijiem): decide if the ares channel arg timeout should be reused.+      query_timeout_ms_(std::chrono::milliseconds(+          std::max(0, channel_args()+                          .GetInt(GRPC_ARG_DNS_ARES_QUERY_TIMEOUT_MS)+                          .value_or(GRPC_DNS_DEFAULT_QUERY_TIMEOUT_MS)))),+      event_engine_(channel_args().GetObjectRef<EventEngine>()) {}++OrphanablePtr<Orphanable> EventEngineClientChannelDNSResolver::StartRequest() {+  return MakeOrphanable<EventEngineDNSRequestWrapper>(+      Ref(DEBUG_LOCATION, ""dns-resolving""),+      event_engine_->GetDNSResolver({/*dns_server=*/authority()}));+}++// ----------------------------------------------------------------------------+// EventEngineDNSRequestWrapper definition+// ----------------------------------------------------------------------------++EventEngineDNSRequestWrapper::EventEngineDNSRequestWrapper(+    RefCountedPtr<EventEngineClientChannelDNSResolver> resolver,+    std::unique_ptr<EventEngine::DNSResolver> event_engine_resolver)+    : resolver_(std::move(resolver)),+      event_engine_resolver_(std::move(event_engine_resolver)) {+  // Locking to prevent completion before all records are queried+  MutexLock lock(&on_resolved_mu_);+  hostname_handle_ = event_engine_resolver_->LookupHostname(+      absl::bind_front(&EventEngineDNSRequestWrapper::OnHostnameResolved,+                       Ref(DEBUG_LOCATION, ""OnHostnameResolved"")),+      resolver_->name_to_resolve(), grpc_core::kDefaultSecurePort,+      resolver_->query_timeout_ms_);+  GRPC_EVENT_ENGINE_DNS_TRACE(+      ""DNSResolver::%p Started resolving hostname. Handle::%s"", resolver_.get(),+      HandleToString(*hostname_handle_).c_str());+  if (resolver_->enable_srv_queries_) {+    srv_handle_ = event_engine_resolver_->LookupSRV(+        absl::bind_front(&EventEngineDNSRequestWrapper::OnSRVResolved,+                         Ref(DEBUG_LOCATION, ""OnSRVResolved""),+                         resolver_->name_to_resolve()),+        resolver_->name_to_resolve(), resolver_->query_timeout_ms_);+    GRPC_EVENT_ENGINE_DNS_TRACE(+        ""DNSResolver::%p Started resolving SRV. Handle::%s"", resolver_.get(),+        HandleToString(*srv_handle_).c_str());+  }+  if (resolver_->request_service_config_) {+    txt_handle_ = event_engine_resolver_->LookupTXT(+        absl::bind_front(&EventEngineDNSRequestWrapper::OnTXTResolved,+                         Ref(DEBUG_LOCATION, ""OnTXTResolved"")),+        resolver_->name_to_resolve(), resolver_->query_timeout_ms_);+    GRPC_EVENT_ENGINE_DNS_TRACE(+        ""DNSResolver::%p Started resolving TXT. Handle::%s"", resolver_.get(),+        HandleToString(*txt_handle_).c_str());+  }+}++EventEngineDNSRequestWrapper::~EventEngineDNSRequestWrapper() {+  resolver_.reset(DEBUG_LOCATION, ""dns-resolving"");+}++void EventEngineDNSRequestWrapper::Orphan() {+  {+    MutexLock lock(&on_resolved_mu_);+    orphaned_ = true;+    // Event if cancellation fails here, OnResolvedLocked will return early, and+    // the resolver will never see a completed request.+    if (hostname_handle_.has_value()) {+      event_engine_resolver_->CancelLookup(*hostname_handle_);+    }+    if (srv_handle_.has_value()) {+      event_engine_resolver_->CancelLookup(*srv_handle_);+    }+    for (const auto& handle : balancer_hostname_handles_) {+      event_engine_resolver_->CancelLookup(handle);+    }+    if (txt_handle_.has_value()) {+      event_engine_resolver_->CancelLookup(*txt_handle_);+    }+  }+  Unref(DEBUG_LOCATION, ""Orphan"");+}++void EventEngineDNSRequestWrapper::OnHostnameResolved(+    absl::StatusOr<std::vector<EventEngine::ResolvedAddress>> addresses) {+  absl::optional<grpc_core::Resolver::Result> result;+  {+    MutexLock lock(&on_resolved_mu_);+    if (orphaned_) return;+    hostname_handle_.reset();+    addresses_ = addresses;+    result = OnResolvedLocked();+  }+  if (result.has_value()) {+    resolver_->OnRequestComplete(std::move(*result));+  }+}++void EventEngineDNSRequestWrapper::OnSRVResolved(+    std::string srv_host,+    absl::StatusOr<std::vector<EventEngine::DNSResolver::SRVRecord>>+        srv_records) {+  absl::optional<grpc_core::Resolver::Result> result;+  {+    MutexLock lock(&on_resolved_mu_);+    if (orphaned_) return;+    srv_handle_.reset();+    if (srv_records.ok()) {+      balancer_addresses_ = grpc_core::ServerAddressList();+      // Do a subsequent hostname query if SRV records were returned+      for (const auto& srv_record : *srv_records) {+        balancer_hostname_handles_.insert(+            event_engine_resolver_->LookupHostname(+                absl::bind_front(+                    &EventEngineDNSRequestWrapper::OnBalancerHostnamesResolved,+                    Ref(DEBUG_LOCATION, ""OnBalancerHostnamesResolved""),+                    srv_host),+                srv_record.host, std::to_string(srv_record.port),+                resolver_->query_timeout_ms_));+        GRPC_EVENT_ENGINE_DNS_TRACE(+            ""DNSResolver::%p Started resolving balancer hostname %s:%d"",+            resolver_.get(), srv_record.host.c_str(), srv_record.port);+      }+      return;+    }+    // An error has occurred, finish resolving.+    balancer_addresses_ = srv_records.status();+    result = OnResolvedLocked();+  }+  if (result.has_value()) {+    resolver_->OnRequestComplete(std::move(*result));+  }+}++void EventEngineDNSRequestWrapper::OnBalancerHostnamesResolved(+    std::string authority,+    absl::StatusOr<std::vector<EventEngine::ResolvedAddress>>+        new_balancer_addresses) {+  absl::optional<grpc_core::Resolver::Result> result;+  {+    MutexLock lock(&on_resolved_mu_);+    if (orphaned_) return;+    ++number_of_balancer_hostnames_resolved_;+    if (new_balancer_addresses.ok()) {+      if (!balancer_addresses_.ok()) {+        GRPC_EVENT_ENGINE_DNS_TRACE(+            ""DNSResolver::%p previous balancer hostname lookup error, ignoring ""+            ""%zu found hostnames."",+            this, new_balancer_addresses->size());+      }+      balancer_addresses_->reserve(balancer_addresses_->size() ++                                   new_balancer_addresses->size());+      auto srv_channel_args =+          resolver_->channel_args().Set(GRPC_ARG_DEFAULT_AUTHORITY, authority);+      for (const auto& addr : *new_balancer_addresses) {+        balancer_addresses_->emplace_back(CreateGRPCResolvedAddress(addr),+                                          srv_channel_args);+      }+    } else {+      auto tmp_status = balancer_addresses_.status();+      grpc_core::StatusAddChild(&tmp_status, new_balancer_addresses.status());+      balancer_addresses_ = tmp_status;+    }+    result = OnResolvedLocked();+  }+  if (result.has_value()) {+    resolver_->OnRequestComplete(std::move(*result));+  }+}++void EventEngineDNSRequestWrapper::OnTXTResolved(+    absl::StatusOr<std::string> service_config) {+  absl::optional<grpc_core::Resolver::Result> result;+  {+    MutexLock lock(&on_resolved_mu_);+    if (orphaned_) return;+    GPR_ASSERT(txt_handle_.has_value());+    txt_handle_.reset();+    service_config_json_ = service_config;+    result = OnResolvedLocked();+  }+  if (result.has_value()) {+    resolver_->OnRequestComplete(std::move(*result));+  }+}++absl::Status+EventEngineDNSRequestWrapper::GetResolutionFailureErrorMessageLocked() {+  std::string error_msg =+      absl::StrFormat(""resolver:%p dns resolution failed."", this);+  if (!addresses_.ok()) {+    absl::StrAppend(&error_msg, "" Hostname lookup error: "",+                    grpc_core::StatusToString(addresses_.status()));+  }+  if (!balancer_addresses_.ok()) {+    absl::StrAppend(&error_msg, "" SRV lookup error: "",+                    grpc_core::StatusToString(balancer_addresses_.status()));+  }+  if (!service_config_json_.ok()) {+    absl::StrAppend(&error_msg, "" TXT lookup error: "",+                    grpc_core::StatusToString(service_config_json_.status()));+  }+  auto status = grpc_core::StatusCreate(+      absl::StatusCode::kUnavailable, error_msg, DEBUG_LOCATION, /*children=*/+      {addresses_.status(), balancer_addresses_.status(),+       service_config_json_.status()});+  return status;+}++void EventEngineDNSRequestWrapper::MaybePopulateAddressesLocked(+    grpc_core::Resolver::Result& result) {+  result.addresses = grpc_core::ServerAddressList();+  if (addresses_.ok()) {+    result.addresses->reserve(addresses_->size());+    for (const auto& addr : *addresses_) {+      result.addresses->emplace_back(CreateGRPCResolvedAddress(addr),+                                     resolver_->channel_args());+    }+  }+}++void EventEngineDNSRequestWrapper::MaybePopulateBalancerAddressesLocked(+    grpc_core::Resolver::Result& result) {+  if (balancer_addresses_.ok()) {+    result.args = grpc_core::SetGrpcLbBalancerAddresses(result.args,+                                                        *balancer_addresses_);+  }+}++void EventEngineDNSRequestWrapper::MaybePopulateServiceConfigLocked(+    grpc_core::Resolver::Result& result) {+  // TODO(roth): We should not ignore errors here, but instead have users of the+  // resolver handle them appropriately. Some test/cpp/naming tests fail.+  if ((addresses_.ok() || balancer_addresses_.ok()) &&+      service_config_json_.ok() && service_config_json_->empty()) {+    result.service_config = service_config_json_.status();","This code will be executed only if `service_config_json_.ok()` is true, so this will unconditionally set it to an OK status, which I don't think is ever what we want.  If the status is OK, the `StatusOr<>` should have a payload instead of a status.Stepping back, it looks like there are two different things that we're trying to do here:1. If we got an error for the addresses, we also want to return an error for the service config.2. If we did not get an error for the addresses, but we did get an error for the service config, we should return that error.I think we should handle case 1 in `OnResolvedLocked()`, so that the logic for handling address failures is all in one place (see my comment below).  The logic in `OnResolvedLocked()` should call `MaybePopulateServiceConfigLocked()` only in case 2.  So the code here should look something like this:```if (!service_config_json_.ok()) {  result.service_config = service_config_json_.status();  return;}auto service_config = ChooseServiceConfig(*service_config_json_);if (!service_config.ok()) {  result.service_config = absl::UnavailableError(          absl::StrCat(""failed to parse service config: "",                       grpc_core::StatusToString(service_config.status())));  return;}if (!service_config->empty()) {  // ...}```",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32632,1150833770,2023-03-28T15:51:03Z,src/core/ext/filters/client_channel/resolver/dns/event_engine/service_config_helper.cc,"@@ -0,0 +1,132 @@+// Copyright 2023 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+#include <grpc/support/port_platform.h>++#include ""src/core/ext/filters/client_channel/resolver/dns/event_engine/service_config_helper.h""++#include <stdio.h>+#include <stdlib.h>++#include <algorithm>+#include <map>+#include <utility>+#include <vector>++#include ""absl/status/status.h""+#include ""absl/status/statusor.h""+#include ""absl/strings/string_view.h""++#include ""src/core/lib/gprpp/debug_location.h""+#include ""src/core/lib/gprpp/status_helper.h""+#include ""src/core/lib/iomgr/gethostname.h""+#include ""src/core/lib/json/json.h""++namespace grpc_event_engine {+namespace experimental {++namespace {+using ::grpc_core::Json;++bool ValueInJsonArray(const Json::Array& array, const char* value) {+  for (const Json& entry : array) {+    if (entry.type() == Json::Type::STRING && entry.string_value() == value) {+      return true;+    }+  }+  return false;+}++}  // namespace++absl::StatusOr<std::string> ChooseServiceConfig(+    absl::string_view service_config_json) {+  auto json = Json::Parse(service_config_json);+  GRPC_RETURN_IF_ERROR(json.status());+  if (json->type() != Json::Type::ARRAY) {+    return absl::FailedPreconditionError(+        ""Service Config Choices, error: should be of type array"");+  }+  const Json* service_config = nullptr;+  std::vector<absl::Status> error_list;",Suggest using the [`validation_errors`](https://github.com/grpc/grpc/blob/master/src/core/lib/gprpp/validation_errors.h) library instead.,
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32632,1150835860,2023-03-28T15:52:27Z,src/core/ext/filters/client_channel/resolver/dns/event_engine/service_config_helper.cc,"@@ -0,0 +1,132 @@+// Copyright 2023 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+#include <grpc/support/port_platform.h>++#include ""src/core/ext/filters/client_channel/resolver/dns/event_engine/service_config_helper.h""++#include <stdio.h>+#include <stdlib.h>++#include <algorithm>+#include <map>+#include <utility>+#include <vector>++#include ""absl/status/status.h""+#include ""absl/status/statusor.h""+#include ""absl/strings/string_view.h""++#include ""src/core/lib/gprpp/debug_location.h""+#include ""src/core/lib/gprpp/status_helper.h""+#include ""src/core/lib/iomgr/gethostname.h""+#include ""src/core/lib/json/json.h""++namespace grpc_event_engine {+namespace experimental {++namespace {+using ::grpc_core::Json;++bool ValueInJsonArray(const Json::Array& array, const char* value) {+  for (const Json& entry : array) {+    if (entry.type() == Json::Type::STRING && entry.string_value() == value) {+      return true;+    }+  }+  return false;+}++}  // namespace++absl::StatusOr<std::string> ChooseServiceConfig(+    absl::string_view service_config_json) {+  auto json = Json::Parse(service_config_json);+  GRPC_RETURN_IF_ERROR(json.status());+  if (json->type() != Json::Type::ARRAY) {+    return absl::FailedPreconditionError(+        ""Service Config Choices, error: should be of type array"");+  }+  const Json* service_config = nullptr;+  std::vector<absl::Status> error_list;+  for (const Json& choice : json->array_value()) {+    if (choice.type() != Json::Type::OBJECT) {+      error_list.push_back(absl::FailedPreconditionError(+          ""Service Config Choice, error: should be of type object""));+      continue;+    }+    // Check client language, if specified.+    auto it = choice.object_value().find(""clientLanguage"");+    if (it != choice.object_value().end()) {+      if (it->second.type() != Json::Type::ARRAY) {+        error_list.push_back(absl::FailedPreconditionError(+            ""field:clientLanguage error:should be of type array""));+      } else if (!ValueInJsonArray(it->second.array_value(), ""c++"")) {+        continue;+      }+    }+    // Check client hostname, if specified.+    it = choice.object_value().find(""clientHostname"");+    if (it != choice.object_value().end()) {+      if (it->second.type() != Json::Type::ARRAY) {+        error_list.push_back(absl::FailedPreconditionError(+            ""field:clientHostname error:should be of type array""));+      } else {+        // TODO(hork): replace with something non-iomgr+        char* hostname = grpc_gethostname();+        if (hostname == nullptr ||+            !ValueInJsonArray(it->second.array_value(), hostname)) {+          continue;+        }+      }+    }+    // Check percentage, if specified.+    it = choice.object_value().find(""percentage"");+    if (it != choice.object_value().end()) {+      if (it->second.type() != Json::Type::NUMBER) {+        error_list.push_back(absl::FailedPreconditionError(+            ""field:percentage error:should be of type number""));+      } else {+        int random_pct = rand() % 100;+        int percentage;+        if (sscanf(it->second.string_value().c_str(), ""%d"", &percentage) != 1) {+          error_list.push_back(absl::FailedPreconditionError(+              ""field:percentage error:should be of type integer""));+        } else if (random_pct > percentage || percentage == 0) {+          continue;+        }+      }+    }+    // Found service config.+    it = choice.object_value().find(""serviceConfig"");+    if (it == choice.object_value().end()) {+      error_list.push_back(absl::FailedPreconditionError(+          ""field:serviceConfig error:required field missing""));+    } else if (it->second.type() != Json::Type::OBJECT) {+      error_list.push_back(absl::FailedPreconditionError(+          ""field:serviceConfig error:should be of type object""));+    } else if (service_config == nullptr) {+      service_config = &it->second;+    }+  }+  if (!error_list.empty()) {+    return grpc_core::StatusCreate(absl::StatusCode::kFailedPrecondition,","As mentioned elsewhere, instead of using the deprecated child-error mechanism, let's just construct a single string that includes all relevant error messages.  That will yield better error messages for users.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32632,1150836945,2023-03-28T15:53:18Z,src/core/ext/filters/client_channel/resolver/dns/event_engine/service_config_helper.cc,"@@ -0,0 +1,132 @@+// Copyright 2023 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+#include <grpc/support/port_platform.h>++#include ""src/core/ext/filters/client_channel/resolver/dns/event_engine/service_config_helper.h""++#include <stdio.h>+#include <stdlib.h>++#include <algorithm>+#include <map>+#include <utility>+#include <vector>++#include ""absl/status/status.h""+#include ""absl/status/statusor.h""+#include ""absl/strings/string_view.h""++#include ""src/core/lib/gprpp/debug_location.h""+#include ""src/core/lib/gprpp/status_helper.h""+#include ""src/core/lib/iomgr/gethostname.h""+#include ""src/core/lib/json/json.h""++namespace grpc_event_engine {+namespace experimental {++namespace {+using ::grpc_core::Json;++bool ValueInJsonArray(const Json::Array& array, const char* value) {+  for (const Json& entry : array) {+    if (entry.type() == Json::Type::STRING && entry.string_value() == value) {+      return true;+    }+  }+  return false;+}++}  // namespace++absl::StatusOr<std::string> ChooseServiceConfig(+    absl::string_view service_config_json) {+  auto json = Json::Parse(service_config_json);+  GRPC_RETURN_IF_ERROR(json.status());+  if (json->type() != Json::Type::ARRAY) {",Consider changing this validation code to use the [`json_object_loader`](https://github.com/grpc/grpc/blob/master/src/core/lib/json/json_object_loader.h) library.,
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32632,1150850264,2023-03-28T16:02:56Z,src/core/ext/filters/client_channel/resolver/dns/event_engine/event_engine_client_channel_resolver.cc,"@@ -0,0 +1,535 @@+// Copyright 2023 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+#include <grpc/support/port_platform.h>++#include ""src/core/ext/filters/client_channel/resolver/dns/event_engine/event_engine_client_channel_resolver.h""++#include <stddef.h>+#include <stdint.h>++#include <algorithm>+#include <chrono>+#include <initializer_list>+#include <memory>+#include <string>+#include <utility>+#include <vector>++#include ""absl/base/thread_annotations.h""+#include ""absl/container/flat_hash_set.h""+#include ""absl/functional/bind_front.h""+#include ""absl/status/status.h""+#include ""absl/status/statusor.h""+#include ""absl/strings/str_cat.h""+#include ""absl/strings/str_format.h""+#include ""absl/strings/strip.h""+#include ""absl/types/optional.h""++#include <grpc/event_engine/event_engine.h>+#include <grpc/grpc.h>+#include <grpc/support/log.h>++#include ""src/core/ext/filters/client_channel/lb_policy/grpclb/grpclb_balancer_addresses.h""+#include ""src/core/ext/filters/client_channel/resolver/dns/event_engine/service_config_helper.h""+#include ""src/core/ext/filters/client_channel/resolver/polling_resolver.h""+#include ""src/core/lib/backoff/backoff.h""+#include ""src/core/lib/channel/channel_args.h""+#include ""src/core/lib/debug/trace.h""+#include ""src/core/lib/event_engine/handle_containers.h""+#include ""src/core/lib/event_engine/resolved_address_internal.h""+#include ""src/core/lib/event_engine/trace.h""+#include ""src/core/lib/event_engine/utils.h""+#include ""src/core/lib/gprpp/debug_location.h""+#include ""src/core/lib/gprpp/ref_counted_ptr.h""+#include ""src/core/lib/gprpp/status_helper.h""+#include ""src/core/lib/gprpp/sync.h""+#include ""src/core/lib/gprpp/time.h""+#include ""src/core/lib/iomgr/resolve_address.h""+#include ""src/core/lib/resolver/resolver.h""+#include ""src/core/lib/resolver/resolver_factory.h""+#include ""src/core/lib/resolver/server_address.h""+#include ""src/core/lib/service_config/service_config.h""+#include ""src/core/lib/service_config/service_config_impl.h""++// IWYU pragma: no_include <ratio>++namespace grpc_event_engine {+namespace experimental {++namespace {++#define GRPC_DNS_INITIAL_CONNECT_BACKOFF_SECONDS 1+#define GRPC_DNS_RECONNECT_BACKOFF_MULTIPLIER 1.6+#define GRPC_DNS_RECONNECT_MAX_BACKOFF_SECONDS 120+#define GRPC_DNS_RECONNECT_JITTER 0.2+#define GRPC_DNS_DEFAULT_QUERY_TIMEOUT_MS 120000++using grpc_core::BackOff;+using grpc_core::Duration;+using grpc_core::InternallyRefCounted;+using grpc_core::MakeOrphanable;+using grpc_core::Mutex;+using grpc_core::MutexLock;+using grpc_core::Orphanable;+using grpc_core::OrphanablePtr;+using grpc_core::RefCountedPtr;+using grpc_core::ResolverArgs;++// ----------------------------------------------------------------------------+// EventEngineDNSRequestWrapper declaration+// ----------------------------------------------------------------------------+class EventEngineClientChannelDNSResolver;++class EventEngineDNSRequestWrapper+    : public InternallyRefCounted<EventEngineDNSRequestWrapper> {+ public:+  EventEngineDNSRequestWrapper(+      RefCountedPtr<EventEngineClientChannelDNSResolver> resolver,+      std::unique_ptr<EventEngine::DNSResolver> event_engine_resolver);+  ~EventEngineDNSRequestWrapper() override;++  // Note that thread safety cannot be analyzed due to this being invoked from+  // OrphanablePtr<>, and there's no way to pass the lock annotation through+  // there.+  void Orphan() override ABSL_NO_THREAD_SAFETY_ANALYSIS;++  void OnHostnameResolved(+      absl::StatusOr<std::vector<EventEngine::ResolvedAddress>> addresses);+  void OnSRVResolved(+      std::string srv_host,+      absl::StatusOr<std::vector<EventEngine::DNSResolver::SRVRecord>>+          srv_records);+  void OnBalancerHostnamesResolved(+      std::string authority,+      absl::StatusOr<std::vector<EventEngine::ResolvedAddress>> addresses);+  void OnTXTResolved(absl::StatusOr<std::string> service_config);++  // Returns a Result if resolution is complete.+  // callers must release the lock and call OnRequestComplete if a Result is+  // returned. This is because OnRequestComplete may Orphan the resolver, which+  // requires taking the lock.+  absl::optional<grpc_core::Resolver::Result> OnResolvedLocked()+      ABSL_EXCLUSIVE_LOCKS_REQUIRED(on_resolved_mu_);++ private:+  // Helper method for generating the combined resolution status error+  absl::Status GetResolutionFailureErrorMessageLocked()+      ABSL_EXCLUSIVE_LOCKS_REQUIRED(on_resolved_mu_);+  // Helper method to populate server addresses on resolver result.+  void MaybePopulateAddressesLocked(grpc_core::Resolver::Result& result)+      ABSL_EXCLUSIVE_LOCKS_REQUIRED(on_resolved_mu_);+  // Helper method to populate balancer addresses on resolver result.+  void MaybePopulateBalancerAddressesLocked(grpc_core::Resolver::Result& result)+      ABSL_EXCLUSIVE_LOCKS_REQUIRED(on_resolved_mu_);+  // Helper method to populate service config on resolver result.+  void MaybePopulateServiceConfigLocked(grpc_core::Resolver::Result& result)+      ABSL_EXCLUSIVE_LOCKS_REQUIRED(on_resolved_mu_);+  // Convert empty results into resolution errors.+  //+  // TODO(roth): We should someday separate empty results (NXDOMAIN) from actual+  // DNS resolution errors. For now, they are treated the same so this resolver+  // behaves similarly to the old c-ares resolver.+  void NormalizeEmptyResultsToErrorsLocked()+      ABSL_EXCLUSIVE_LOCKS_REQUIRED(on_resolved_mu_);++  RefCountedPtr<EventEngineClientChannelDNSResolver> resolver_;+  Mutex on_resolved_mu_;+  // Lookup callbacks+  absl::optional<EventEngine::DNSResolver::LookupTaskHandle> hostname_handle_+      ABSL_GUARDED_BY(on_resolved_mu_);+  absl::optional<EventEngine::DNSResolver::LookupTaskHandle> srv_handle_+      ABSL_GUARDED_BY(on_resolved_mu_);+  absl::optional<EventEngine::DNSResolver::LookupTaskHandle> txt_handle_+      ABSL_GUARDED_BY(on_resolved_mu_);+  LookupTaskHandleSet balancer_hostname_handles_+      ABSL_GUARDED_BY(on_resolved_mu_);+  // Output fields from requests.+  absl::StatusOr<std::vector<EventEngine::ResolvedAddress>> addresses_+      ABSL_GUARDED_BY(on_resolved_mu_);+  absl::StatusOr<grpc_core::ServerAddressList> balancer_addresses_+      ABSL_GUARDED_BY(on_resolved_mu_);+  absl::StatusOr<std::string> service_config_json_+      ABSL_GUARDED_BY(on_resolved_mu_);+  // Other internal state+  size_t number_of_balancer_hostnames_resolved_+      ABSL_GUARDED_BY(on_resolved_mu_) = 0;+  bool orphaned_ ABSL_GUARDED_BY(on_resolved_mu_) = false;+  std::unique_ptr<EventEngine::DNSResolver> event_engine_resolver_;+};++// ----------------------------------------------------------------------------+// EventEngineClientChannelDNSResolver+// ----------------------------------------------------------------------------+class EventEngineClientChannelDNSResolver : public grpc_core::PollingResolver {+ public:+  EventEngineClientChannelDNSResolver(ResolverArgs args,+                                      Duration min_time_between_resolutions);+  OrphanablePtr<Orphanable> StartRequest() override;++ private:+  friend class EventEngineDNSRequestWrapper;++  /// whether to request the service config+  const bool request_service_config_;+  // whether or not to enable SRV DNS queries+  const bool enable_srv_queries_;+  // timeout in milliseconds for active DNS queries+  EventEngine::Duration query_timeout_ms_;+  std::shared_ptr<EventEngine> event_engine_;+};++EventEngineClientChannelDNSResolver::EventEngineClientChannelDNSResolver(+    ResolverArgs args, Duration min_time_between_resolutions)+    : PollingResolver(std::move(args), min_time_between_resolutions,+                      BackOff::Options()+                          .set_initial_backoff(Duration::Milliseconds(+                              GRPC_DNS_INITIAL_CONNECT_BACKOFF_SECONDS * 1000))+                          .set_multiplier(GRPC_DNS_RECONNECT_BACKOFF_MULTIPLIER)+                          .set_jitter(GRPC_DNS_RECONNECT_JITTER)+                          .set_max_backoff(Duration::Milliseconds(+                              GRPC_DNS_RECONNECT_MAX_BACKOFF_SECONDS * 1000)),+                      &grpc_event_engine_dns_trace),+      request_service_config_(+          !channel_args()+               .GetBool(GRPC_ARG_SERVICE_CONFIG_DISABLE_RESOLUTION)+               .value_or(true)),+      enable_srv_queries_(channel_args()+                              .GetBool(GRPC_ARG_DNS_ENABLE_SRV_QUERIES)+                              .value_or(false)),+      // TODO(yijiem): decide if the ares channel arg timeout should be reused.+      query_timeout_ms_(std::chrono::milliseconds(+          std::max(0, channel_args()+                          .GetInt(GRPC_ARG_DNS_ARES_QUERY_TIMEOUT_MS)+                          .value_or(GRPC_DNS_DEFAULT_QUERY_TIMEOUT_MS)))),+      event_engine_(channel_args().GetObjectRef<EventEngine>()) {}++OrphanablePtr<Orphanable> EventEngineClientChannelDNSResolver::StartRequest() {+  return MakeOrphanable<EventEngineDNSRequestWrapper>(+      Ref(DEBUG_LOCATION, ""dns-resolving""),+      event_engine_->GetDNSResolver({/*dns_server=*/authority()}));+}++// ----------------------------------------------------------------------------+// EventEngineDNSRequestWrapper definition+// ----------------------------------------------------------------------------++EventEngineDNSRequestWrapper::EventEngineDNSRequestWrapper(+    RefCountedPtr<EventEngineClientChannelDNSResolver> resolver,+    std::unique_ptr<EventEngine::DNSResolver> event_engine_resolver)+    : resolver_(std::move(resolver)),+      event_engine_resolver_(std::move(event_engine_resolver)) {+  // Locking to prevent completion before all records are queried+  MutexLock lock(&on_resolved_mu_);+  hostname_handle_ = event_engine_resolver_->LookupHostname(+      absl::bind_front(&EventEngineDNSRequestWrapper::OnHostnameResolved,+                       Ref(DEBUG_LOCATION, ""OnHostnameResolved"")),+      resolver_->name_to_resolve(), grpc_core::kDefaultSecurePort,+      resolver_->query_timeout_ms_);+  GRPC_EVENT_ENGINE_DNS_TRACE(+      ""DNSResolver::%p Started resolving hostname. Handle::%s"", resolver_.get(),+      HandleToString(*hostname_handle_).c_str());+  if (resolver_->enable_srv_queries_) {+    srv_handle_ = event_engine_resolver_->LookupSRV(+        absl::bind_front(&EventEngineDNSRequestWrapper::OnSRVResolved,+                         Ref(DEBUG_LOCATION, ""OnSRVResolved""),+                         resolver_->name_to_resolve()),+        resolver_->name_to_resolve(), resolver_->query_timeout_ms_);+    GRPC_EVENT_ENGINE_DNS_TRACE(+        ""DNSResolver::%p Started resolving SRV. Handle::%s"", resolver_.get(),+        HandleToString(*srv_handle_).c_str());+  }+  if (resolver_->request_service_config_) {+    txt_handle_ = event_engine_resolver_->LookupTXT(+        absl::bind_front(&EventEngineDNSRequestWrapper::OnTXTResolved,+                         Ref(DEBUG_LOCATION, ""OnTXTResolved"")),+        resolver_->name_to_resolve(), resolver_->query_timeout_ms_);+    GRPC_EVENT_ENGINE_DNS_TRACE(+        ""DNSResolver::%p Started resolving TXT. Handle::%s"", resolver_.get(),+        HandleToString(*txt_handle_).c_str());+  }+}++EventEngineDNSRequestWrapper::~EventEngineDNSRequestWrapper() {+  resolver_.reset(DEBUG_LOCATION, ""dns-resolving"");+}++void EventEngineDNSRequestWrapper::Orphan() {+  {+    MutexLock lock(&on_resolved_mu_);+    orphaned_ = true;+    // Event if cancellation fails here, OnResolvedLocked will return early, and+    // the resolver will never see a completed request.+    if (hostname_handle_.has_value()) {+      event_engine_resolver_->CancelLookup(*hostname_handle_);+    }+    if (srv_handle_.has_value()) {+      event_engine_resolver_->CancelLookup(*srv_handle_);+    }+    for (const auto& handle : balancer_hostname_handles_) {+      event_engine_resolver_->CancelLookup(handle);+    }+    if (txt_handle_.has_value()) {+      event_engine_resolver_->CancelLookup(*txt_handle_);+    }+  }+  Unref(DEBUG_LOCATION, ""Orphan"");+}++void EventEngineDNSRequestWrapper::OnHostnameResolved(+    absl::StatusOr<std::vector<EventEngine::ResolvedAddress>> addresses) {+  absl::optional<grpc_core::Resolver::Result> result;+  {+    MutexLock lock(&on_resolved_mu_);+    if (orphaned_) return;+    hostname_handle_.reset();+    addresses_ = addresses;+    result = OnResolvedLocked();+  }+  if (result.has_value()) {+    resolver_->OnRequestComplete(std::move(*result));+  }+}++void EventEngineDNSRequestWrapper::OnSRVResolved(+    std::string srv_host,+    absl::StatusOr<std::vector<EventEngine::DNSResolver::SRVRecord>>+        srv_records) {+  absl::optional<grpc_core::Resolver::Result> result;+  {+    MutexLock lock(&on_resolved_mu_);+    if (orphaned_) return;+    srv_handle_.reset();+    if (srv_records.ok()) {+      balancer_addresses_ = grpc_core::ServerAddressList();+      // Do a subsequent hostname query if SRV records were returned+      for (const auto& srv_record : *srv_records) {+        balancer_hostname_handles_.insert(+            event_engine_resolver_->LookupHostname(+                absl::bind_front(+                    &EventEngineDNSRequestWrapper::OnBalancerHostnamesResolved,+                    Ref(DEBUG_LOCATION, ""OnBalancerHostnamesResolved""),+                    srv_host),+                srv_record.host, std::to_string(srv_record.port),+                resolver_->query_timeout_ms_));+        GRPC_EVENT_ENGINE_DNS_TRACE(+            ""DNSResolver::%p Started resolving balancer hostname %s:%d"",+            resolver_.get(), srv_record.host.c_str(), srv_record.port);+      }+      return;+    }+    // An error has occurred, finish resolving.+    balancer_addresses_ = srv_records.status();+    result = OnResolvedLocked();+  }+  if (result.has_value()) {+    resolver_->OnRequestComplete(std::move(*result));+  }+}++void EventEngineDNSRequestWrapper::OnBalancerHostnamesResolved(+    std::string authority,+    absl::StatusOr<std::vector<EventEngine::ResolvedAddress>>+        new_balancer_addresses) {+  absl::optional<grpc_core::Resolver::Result> result;+  {+    MutexLock lock(&on_resolved_mu_);+    if (orphaned_) return;+    ++number_of_balancer_hostnames_resolved_;+    if (new_balancer_addresses.ok()) {+      if (!balancer_addresses_.ok()) {+        GRPC_EVENT_ENGINE_DNS_TRACE(+            ""DNSResolver::%p previous balancer hostname lookup error, ignoring ""+            ""%zu found hostnames."",+            this, new_balancer_addresses->size());+      }+      balancer_addresses_->reserve(balancer_addresses_->size() ++                                   new_balancer_addresses->size());+      auto srv_channel_args =+          resolver_->channel_args().Set(GRPC_ARG_DEFAULT_AUTHORITY, authority);+      for (const auto& addr : *new_balancer_addresses) {+        balancer_addresses_->emplace_back(CreateGRPCResolvedAddress(addr),+                                          srv_channel_args);+      }+    } else {+      auto tmp_status = balancer_addresses_.status();+      grpc_core::StatusAddChild(&tmp_status, new_balancer_addresses.status());+      balancer_addresses_ = tmp_status;+    }+    result = OnResolvedLocked();+  }+  if (result.has_value()) {+    resolver_->OnRequestComplete(std::move(*result));+  }+}++void EventEngineDNSRequestWrapper::OnTXTResolved(+    absl::StatusOr<std::string> service_config) {+  absl::optional<grpc_core::Resolver::Result> result;+  {+    MutexLock lock(&on_resolved_mu_);+    if (orphaned_) return;+    GPR_ASSERT(txt_handle_.has_value());+    txt_handle_.reset();+    service_config_json_ = service_config;+    result = OnResolvedLocked();+  }+  if (result.has_value()) {+    resolver_->OnRequestComplete(std::move(*result));+  }+}++absl::Status+EventEngineDNSRequestWrapper::GetResolutionFailureErrorMessageLocked() {+  std::string error_msg =+      absl::StrFormat(""resolver:%p dns resolution failed."", this);+  if (!addresses_.ok()) {+    absl::StrAppend(&error_msg, "" Hostname lookup error: "",+                    grpc_core::StatusToString(addresses_.status()));+  }+  if (!balancer_addresses_.ok()) {+    absl::StrAppend(&error_msg, "" SRV lookup error: "",+                    grpc_core::StatusToString(balancer_addresses_.status()));+  }+  if (!service_config_json_.ok()) {+    absl::StrAppend(&error_msg, "" TXT lookup error: "",+                    grpc_core::StatusToString(service_config_json_.status()));+  }+  auto status = grpc_core::StatusCreate(+      absl::StatusCode::kUnavailable, error_msg, DEBUG_LOCATION, /*children=*/+      {addresses_.status(), balancer_addresses_.status(),+       service_config_json_.status()});+  return status;+}++void EventEngineDNSRequestWrapper::MaybePopulateAddressesLocked(+    grpc_core::Resolver::Result& result) {",Please pass in mutable parameters as pointers instead of references.Same thing throughout.,
28025951,HannahShiSFB,https://api.github.com/repos/grpc/grpc/pulls/32077,1152129818,2023-03-29T15:29:27Z,src/core/lib/event_engine/cf_engine/cf_engine.cc,"@@ -72,14 +76,76 @@ CFEventEngine::CreateListener( }  CFEventEngine::ConnectionHandle CFEventEngine::Connect(-    OnConnectCallback /* on_connect */, const ResolvedAddress& /* addr */,-    const EndpointConfig& /* args */, MemoryAllocator /* memory_allocator */,-    Duration /* timeout */) {-  grpc_core::Crash(""unimplemented"");+    OnConnectCallback on_connect, const ResolvedAddress& addr,+    const EndpointConfig& /* args */, MemoryAllocator memory_allocator,+    Duration timeout) {+  auto endpoint_ptr = new CFStreamEndpoint(+      std::static_pointer_cast<CFEventEngine>(shared_from_this()),+      std::move(memory_allocator));++  ConnectionHandle handle{reinterpret_cast<intptr_t>(endpoint_ptr), 0};+  {+    grpc_core::MutexLock lock(&conn_mu_);+    conn_handles_.insert(handle);+  }++  auto deadline_timer =+      RunAfter(timeout, [handle, that = std::static_pointer_cast<CFEventEngine>(+                                     shared_from_this())]() {+        that->CancelConnectInternal(+            handle, absl::DeadlineExceededError(""Connect timed out""));+      });++  auto on_connect2 =+      [that = std::static_pointer_cast<CFEventEngine>(shared_from_this()),+       deadline_timer = std::move(deadline_timer), handle,","Not really as deadline_timer is a plain struct, copy and move are the same. So I guess it's more like a documentation of moving the ownership into the lambda then.",
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/32632,1152283038,2023-03-29T17:35:29Z,src/core/ext/filters/client_channel/resolver/dns/event_engine/service_config_helper.cc,"@@ -0,0 +1,132 @@+// Copyright 2023 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+#include <grpc/support/port_platform.h>++#include ""src/core/ext/filters/client_channel/resolver/dns/event_engine/service_config_helper.h""++#include <stdio.h>+#include <stdlib.h>++#include <algorithm>+#include <map>+#include <utility>+#include <vector>++#include ""absl/status/status.h""+#include ""absl/status/statusor.h""+#include ""absl/strings/string_view.h""++#include ""src/core/lib/gprpp/debug_location.h""+#include ""src/core/lib/gprpp/status_helper.h""+#include ""src/core/lib/iomgr/gethostname.h""+#include ""src/core/lib/json/json.h""++namespace grpc_event_engine {+namespace experimental {++namespace {+using ::grpc_core::Json;++bool ValueInJsonArray(const Json::Array& array, const char* value) {+  for (const Json& entry : array) {+    if (entry.type() == Json::Type::STRING && entry.string_value() == value) {+      return true;+    }+  }+  return false;+}++}  // namespace++absl::StatusOr<std::string> ChooseServiceConfig(+    absl::string_view service_config_json) {+  auto json = Json::Parse(service_config_json);+  GRPC_RETURN_IF_ERROR(json.status());+  if (json->type() != Json::Type::ARRAY) {+    return absl::FailedPreconditionError(+        ""Service Config Choices, error: should be of type array"");+  }+  const Json* service_config = nullptr;+  std::vector<absl::Status> error_list;+  for (const Json& choice : json->array_value()) {+    if (choice.type() != Json::Type::OBJECT) {+      error_list.push_back(absl::FailedPreconditionError(+          ""Service Config Choice, error: should be of type object""));+      continue;+    }+    // Check client language, if specified.+    auto it = choice.object_value().find(""clientLanguage"");+    if (it != choice.object_value().end()) {+      if (it->second.type() != Json::Type::ARRAY) {+        error_list.push_back(absl::FailedPreconditionError(+            ""field:clientLanguage error:should be of type array""));+      } else if (!ValueInJsonArray(it->second.array_value(), ""c++"")) {+        continue;+      }+    }+    // Check client hostname, if specified.+    it = choice.object_value().find(""clientHostname"");+    if (it != choice.object_value().end()) {+      if (it->second.type() != Json::Type::ARRAY) {+        error_list.push_back(absl::FailedPreconditionError(+            ""field:clientHostname error:should be of type array""));+      } else {+        // TODO(hork): replace with something non-iomgr+        char* hostname = grpc_gethostname();+        if (hostname == nullptr ||+            !ValueInJsonArray(it->second.array_value(), hostname)) {+          continue;+        }+      }+    }+    // Check percentage, if specified.+    it = choice.object_value().find(""percentage"");+    if (it != choice.object_value().end()) {+      if (it->second.type() != Json::Type::NUMBER) {+        error_list.push_back(absl::FailedPreconditionError(+            ""field:percentage error:should be of type number""));+      } else {+        int random_pct = rand() % 100;+        int percentage;+        if (sscanf(it->second.string_value().c_str(), ""%d"", &percentage) != 1) {+          error_list.push_back(absl::FailedPreconditionError(+              ""field:percentage error:should be of type integer""));+        } else if (random_pct > percentage || percentage == 0) {+          continue;+        }+      }+    }+    // Found service config.+    it = choice.object_value().find(""serviceConfig"");+    if (it == choice.object_value().end()) {+      error_list.push_back(absl::FailedPreconditionError(+          ""field:serviceConfig error:required field missing""));+    } else if (it->second.type() != Json::Type::OBJECT) {+      error_list.push_back(absl::FailedPreconditionError(+          ""field:serviceConfig error:should be of type object""));+    } else if (service_config == nullptr) {+      service_config = &it->second;+    }+  }+  if (!error_list.empty()) {+    return grpc_core::StatusCreate(absl::StatusCode::kFailedPrecondition,","I wasn't aware that was deprecated, was that announced? We still rely on it at the lower levels, it's used in EventEngine implementations to propagate up system errors.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32603,1152307996,2023-03-29T18:00:22Z,test/core/end2end/end2end_test_main.cc,"@@ -0,0 +1,1044 @@+// Copyright 2022 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++#include <inttypes.h>++#include <algorithm>+#include <atomic>+#include <functional>+#include <initializer_list>+#include <map>+#include <memory>+#include <regex>+#include <string>+#include <utility>+#include <vector>++#include ""absl/status/status.h""+#include ""absl/strings/str_format.h""+#include ""absl/types/optional.h""+#include ""gtest/gtest.h""++#include <grpc/compression.h>+#include <grpc/grpc.h>+#include <grpc/grpc_posix.h>+#include <grpc/grpc_security.h>+#include <grpc/grpc_security_constants.h>+#include <grpc/slice.h>+#include <grpc/status.h>+#include <grpc/support/log.h>+#include <grpc/support/time.h>++#include ""src/core/lib/channel/channel_args.h""+#include ""src/core/lib/config/config_vars.h""+#include ""src/core/lib/debug/trace.h""+#include ""src/core/lib/gprpp/host_port.h""+#include ""src/core/lib/gprpp/no_destruct.h""+#include ""src/core/lib/iomgr/error.h""+#include ""src/core/lib/iomgr/exec_ctx.h""+#include ""src/core/lib/iomgr/load_file.h""+#include ""src/core/lib/iomgr/port.h""+#include ""src/core/lib/security/credentials/fake/fake_credentials.h""+#include ""test/core/end2end/end2end_tests.h""+#include ""test/core/end2end/fixtures/h2_oauth2_common.h""+#include ""test/core/end2end/fixtures/h2_ssl_cred_reload_fixture.h""+#include ""test/core/end2end/fixtures/h2_ssl_tls_common.h""+#include ""test/core/end2end/fixtures/h2_tls_common.h""+#include ""test/core/end2end/fixtures/http_proxy_fixture.h""+#include ""test/core/end2end/fixtures/inproc_fixture.h""+#include ""test/core/end2end/fixtures/local_util.h""+#include ""test/core/end2end/fixtures/proxy.h""+#include ""test/core/end2end/fixtures/secure_fixture.h""+#include ""test/core/end2end/fixtures/sockpair_fixture.h""+#include ""test/core/util/port.h""+#include ""test/core/util/test_config.h""++// IWYU pragma: no_include <unistd.h>++#ifdef GRPC_POSIX_SOCKET+#include <fcntl.h>++#include ""src/core/lib/iomgr/socket_utils_posix.h""+#include ""src/core/lib/iomgr/unix_sockets_posix.h""+#endif++#ifdef GRPC_POSIX_WAKEUP_FD+#include ""src/core/lib/iomgr/wakeup_fd_posix.h""+#endif++#define CA_CERT_PATH ""src/core/tsi/test_creds/ca.pem""+#define SERVER_CERT_PATH ""src/core/tsi/test_creds/server1.pem""+#define SERVER_KEY_PATH ""src/core/tsi/test_creds/server1.key""++namespace grpc_core {++namespace {++std::atomic<int> unique{0};++void ProcessAuthFailure(void* state, grpc_auth_context* /*ctx*/,+                        const grpc_metadata* /*md*/, size_t /*md_count*/,+                        grpc_process_auth_metadata_done_cb cb,+                        void* user_data) {+  GPR_ASSERT(state == nullptr);+  cb(user_data, nullptr, 0, nullptr, 0, GRPC_STATUS_UNAUTHENTICATED, nullptr);+}++void AddFailAuthCheckIfNeeded(const ChannelArgs& args,+                              grpc_server_credentials* creds) {+  if (args.Contains(FAIL_AUTH_CHECK_SERVER_ARG_NAME)) {+    grpc_auth_metadata_processor processor = {ProcessAuthFailure, nullptr,+                                              nullptr};+    grpc_server_credentials_set_auth_metadata_processor(creds, processor);+  }+}++}  // namespace++class CensusFixture : public CoreTestFixture {+ private:+  grpc_server* MakeServer(const ChannelArgs& args) override {+    grpc_server_credentials* server_creds =+        grpc_insecure_server_credentials_create();+    auto* server = grpc_server_create(+        args.Set(GRPC_ARG_ENABLE_CENSUS, true).ToC().get(), nullptr);+    grpc_server_register_completion_queue(server, cq(), nullptr);+    GPR_ASSERT(+        grpc_server_add_http2_port(server, localaddr_.c_str(), server_creds));+    grpc_server_credentials_release(server_creds);+    grpc_server_start(server);+    return server;+  }+  grpc_channel* MakeClient(const ChannelArgs& args) override {+    auto* creds = grpc_insecure_credentials_create();+    auto* client =+        grpc_channel_create(localaddr_.c_str(), creds,+                            args.Set(GRPC_ARG_ENABLE_CENSUS, true).ToC().get());+    grpc_channel_credentials_release(creds);+    return client;+  }+  const std::string localaddr_ =+      JoinHostPort(""localhost"", grpc_pick_unused_port_or_die());+};++class CompressionFixture : public CoreTestFixture {+ private:+  grpc_server* MakeServer(const ChannelArgs& args) override {+    auto* server = grpc_server_create(+        args.SetIfUnset(GRPC_COMPRESSION_CHANNEL_DEFAULT_ALGORITHM,+                        GRPC_COMPRESS_GZIP)+            .ToC()+            .get(),+        nullptr);+    grpc_server_register_completion_queue(server, cq(), nullptr);+    grpc_server_credentials* server_creds =+        grpc_insecure_server_credentials_create();+    GPR_ASSERT(+        grpc_server_add_http2_port(server, localaddr_.c_str(), server_creds));+    grpc_server_credentials_release(server_creds);+    grpc_server_start(server);+    return server;+  }+  grpc_channel* MakeClient(const ChannelArgs& args) override {+    grpc_channel_credentials* creds = grpc_insecure_credentials_create();+    auto* client = grpc_channel_create(+        localaddr_.c_str(), creds,+        args.SetIfUnset(GRPC_COMPRESSION_CHANNEL_DEFAULT_ALGORITHM,+                        GRPC_COMPRESS_GZIP)+            .ToC()+            .get());+    grpc_channel_credentials_release(creds);+    return client;+  }++  std::string localaddr_ =+      JoinHostPort(""localhost"", grpc_pick_unused_port_or_die());+};++class FakesecFixture : public SecureFixture {+ private:+  grpc_channel_credentials* MakeClientCreds(const ChannelArgs&) override {+    return grpc_fake_transport_security_credentials_create();+  }+  grpc_server_credentials* MakeServerCreds(const ChannelArgs& args) override {+    grpc_server_credentials* fake_ts_creds =+        grpc_fake_transport_security_server_credentials_create();+    AddFailAuthCheckIfNeeded(args, fake_ts_creds);+    return fake_ts_creds;+  }+};++class InsecureCredsFixture : public InsecureFixture {+ private:+  grpc_server_credentials* MakeServerCreds(const ChannelArgs& args) override {+    auto* creds = grpc_insecure_server_credentials_create();+    AddFailAuthCheckIfNeeded(args, creds);+    return creds;+  }+};++class SockpairWithMinstackFixture : public SockpairFixture {+ public:+  using SockpairFixture::SockpairFixture;++ private:+  ChannelArgs MutateClientArgs(ChannelArgs args) override {+    return args.Set(GRPC_ARG_MINIMAL_STACK, true);+  }+  ChannelArgs MutateServerArgs(ChannelArgs args) override {+    return args.Set(GRPC_ARG_MINIMAL_STACK, true);+  }+};++class Sockpair1Byte : public SockpairFixture {+ public:+  Sockpair1Byte()+      : SockpairFixture(ChannelArgs()+                            .Set(GRPC_ARG_TCP_READ_CHUNK_SIZE, 1)+                            .Set(GRPC_ARG_TCP_MIN_READ_CHUNK_SIZE, 1)+                            .Set(GRPC_ARG_TCP_MAX_READ_CHUNK_SIZE, 1)) {+    g_fixture_slowdown_factor = 2;+  }+  ~Sockpair1Byte() override { g_fixture_slowdown_factor = 1; }++ private:+  ChannelArgs MutateClientArgs(ChannelArgs args) override {+    return args.Set(GRPC_ARG_MINIMAL_STACK, true);+  }+  ChannelArgs MutateServerArgs(ChannelArgs args) override {+    return args.Set(GRPC_ARG_MINIMAL_STACK, true);+  }+};++#ifdef GRPC_POSIX_SOCKET++class FdFixture : public CoreTestFixture {+ public:+  FdFixture() { create_sockets(fd_pair_); }++ private:+  grpc_server* MakeServer(const ChannelArgs& args) override {+    ExecCtx exec_ctx;+    auto* server = grpc_server_create(args.ToC().get(), nullptr);+    grpc_server_register_completion_queue(server, cq(), nullptr);+    grpc_server_start(server);+    grpc_server_credentials* creds = grpc_insecure_server_credentials_create();+    grpc_server_add_channel_from_fd(server, fd_pair_[1], creds);+    grpc_server_credentials_release(creds);+    return server;+  }+  grpc_channel* MakeClient(const ChannelArgs& args) override {+    ExecCtx exec_ctx;+    grpc_channel_credentials* creds = grpc_insecure_credentials_create();+    auto* client = grpc_channel_create_from_fd(""fixture_client"", fd_pair_[0],+                                               creds, args.ToC().get());+    grpc_channel_credentials_release(creds);+    return client;+  }++  static void create_sockets(int sv[2]) {+    int flags;+    grpc_create_socketpair_if_unix(sv);+    flags = fcntl(sv[0], F_GETFL, 0);+    GPR_ASSERT(fcntl(sv[0], F_SETFL, flags | O_NONBLOCK) == 0);+    flags = fcntl(sv[1], F_GETFL, 0);+    GPR_ASSERT(fcntl(sv[1], F_SETFL, flags | O_NONBLOCK) == 0);+    GPR_ASSERT(grpc_set_socket_no_sigpipe_if_possible(sv[0]) ==+               absl::OkStatus());+    GPR_ASSERT(grpc_set_socket_no_sigpipe_if_possible(sv[1]) ==+               absl::OkStatus());+  }++  int fd_pair_[2];+};+#endif++class NoRetryFixture : public InsecureFixture {+ private:+  ChannelArgs MutateClientArgs(ChannelArgs args) override {+    return args.Set(GRPC_ARG_ENABLE_RETRIES, false);+  }+};++class HttpProxyFilter : public CoreTestFixture {+ public:+  explicit HttpProxyFilter(const ChannelArgs& client_args)+      : proxy_(grpc_end2end_http_proxy_create(client_args.ToC().get())) {}+  ~HttpProxyFilter() override {+    // Need to shut down the proxy users before closing the proxy (otherwise we+    // become stuck).+    ShutdownClient();+    ShutdownServer();+    grpc_end2end_http_proxy_destroy(proxy_);+  }++ private:+  grpc_server* MakeServer(const ChannelArgs& args) override {+    auto* server = grpc_server_create(args.ToC().get(), nullptr);+    grpc_server_register_completion_queue(server, cq(), nullptr);+    grpc_server_credentials* server_creds =+        grpc_insecure_server_credentials_create();+    GPR_ASSERT(+        grpc_server_add_http2_port(server, server_addr_.c_str(), server_creds));+    grpc_server_credentials_release(server_creds);+    grpc_server_start(server);+    return server;+  }++  grpc_channel* MakeClient(const ChannelArgs& args) override {+    // If testing for proxy auth, add credentials to proxy uri+    absl::optional<std::string> proxy_auth_str =+        args.GetOwnedString(GRPC_ARG_HTTP_PROXY_AUTH_CREDS);+    std::string proxy_uri;+    if (!proxy_auth_str.has_value()) {+      proxy_uri = absl::StrFormat(+          ""http://%s"", grpc_end2end_http_proxy_get_proxy_name(proxy_));+    } else {+      proxy_uri =+          absl::StrFormat(""http://%s@%s"", proxy_auth_str->c_str(),+                          grpc_end2end_http_proxy_get_proxy_name(proxy_));+    }+    grpc_channel_credentials* creds = grpc_insecure_credentials_create();+    auto* client = grpc_channel_create(+        server_addr_.c_str(), creds,+        args.Set(GRPC_ARG_HTTP_PROXY, proxy_uri).ToC().get());+    grpc_channel_credentials_release(creds);+    GPR_ASSERT(client);+    return client;+  }++  std::string server_addr_ =+      JoinHostPort(""localhost"", grpc_pick_unused_port_or_die());+  grpc_end2end_http_proxy* proxy_;+};++class ProxyFixture : public CoreTestFixture {+ public:+  ProxyFixture(const ChannelArgs& client_args, const ChannelArgs& server_args)+      : proxy_(grpc_end2end_proxy_create(&proxy_def_, client_args.ToC().get(),+                                         server_args.ToC().get())) {}+  ~ProxyFixture() override { grpc_end2end_proxy_destroy(proxy_); }++ private:+  static grpc_server* CreateProxyServer(const char* port,+                                        const grpc_channel_args* server_args) {+    grpc_server* s = grpc_server_create(server_args, nullptr);+    grpc_server_credentials* server_creds =+        grpc_insecure_server_credentials_create();+    GPR_ASSERT(grpc_server_add_http2_port(s, port, server_creds));+    grpc_server_credentials_release(server_creds);+    return s;+  }++  static grpc_channel* CreateProxyClient(const char* target,+                                         const grpc_channel_args* client_args) {+    grpc_channel_credentials* creds = grpc_insecure_credentials_create();+    grpc_channel* channel = grpc_channel_create(target, creds, client_args);+    grpc_channel_credentials_release(creds);+    return channel;+  }++  grpc_server* MakeServer(const ChannelArgs& args) override {+    auto* server = grpc_server_create(args.ToC().get(), nullptr);+    grpc_server_register_completion_queue(server, cq(), nullptr);+    grpc_server_credentials* server_creds =+        grpc_insecure_server_credentials_create();+    GPR_ASSERT(grpc_server_add_http2_port(+        server, grpc_end2end_proxy_get_server_port(proxy_), server_creds));+    grpc_server_credentials_release(server_creds);+    grpc_server_start(server);+    return server;+  }++  grpc_channel* MakeClient(const ChannelArgs& args) override {+    grpc_channel_credentials* creds = grpc_insecure_credentials_create();+    auto* client = grpc_channel_create(+        grpc_end2end_proxy_get_client_target(proxy_), creds, args.ToC().get());+    grpc_channel_credentials_release(creds);+    GPR_ASSERT(client);+    return client;+  }+  const grpc_end2end_proxy_def proxy_def_ = {CreateProxyServer,+                                             CreateProxyClient};+  grpc_end2end_proxy* proxy_;+};++class SslProxyFixture : public CoreTestFixture {+ public:+  SslProxyFixture(const ChannelArgs& client_args,+                  const ChannelArgs& server_args)+      : proxy_(grpc_end2end_proxy_create(&proxy_def_, client_args.ToC().get(),+                                         server_args.ToC().get())) {}+  ~SslProxyFixture() override { grpc_end2end_proxy_destroy(proxy_); }++ private:+  static grpc_server* CreateProxyServer(const char* port,+                                        const grpc_channel_args* server_args) {+    grpc_server* s = grpc_server_create(server_args, nullptr);+    grpc_slice cert_slice, key_slice;+    GPR_ASSERT(GRPC_LOG_IF_ERROR(+        ""load_file"", grpc_load_file(SERVER_CERT_PATH, 1, &cert_slice)));+    GPR_ASSERT(GRPC_LOG_IF_ERROR(+        ""load_file"", grpc_load_file(SERVER_KEY_PATH, 1, &key_slice)));+    const char* server_cert =+        reinterpret_cast<const char*> GRPC_SLICE_START_PTR(cert_slice);+    const char* server_key =+        reinterpret_cast<const char*> GRPC_SLICE_START_PTR(key_slice);+    grpc_ssl_pem_key_cert_pair pem_key_cert_pair = {server_key, server_cert};+    grpc_server_credentials* ssl_creds = grpc_ssl_server_credentials_create(+        nullptr, &pem_key_cert_pair, 1, 0, nullptr);+    grpc_slice_unref(cert_slice);+    grpc_slice_unref(key_slice);+    GPR_ASSERT(grpc_server_add_http2_port(s, port, ssl_creds));+    grpc_server_credentials_release(ssl_creds);+    return s;+  }++  static grpc_channel* CreateProxyClient(const char* target,+                                         const grpc_channel_args* client_args) {+    grpc_channel* channel;+    grpc_channel_credentials* ssl_creds =+        grpc_ssl_credentials_create(nullptr, nullptr, nullptr, nullptr);+    grpc_arg ssl_name_override = {+        GRPC_ARG_STRING,+        const_cast<char*>(GRPC_SSL_TARGET_NAME_OVERRIDE_ARG),+        {const_cast<char*>(""foo.test.google.fr"")}};+    const grpc_channel_args* new_client_args =+        grpc_channel_args_copy_and_add(client_args, &ssl_name_override, 1);+    channel = grpc_channel_create(target, ssl_creds, new_client_args);+    grpc_channel_credentials_release(ssl_creds);+    {+      ExecCtx exec_ctx;+      grpc_channel_args_destroy(new_client_args);+    }+    return channel;+  }++  grpc_server* MakeServer(const ChannelArgs& args) override {+    grpc_slice cert_slice, key_slice;+    GPR_ASSERT(GRPC_LOG_IF_ERROR(+        ""load_file"", grpc_load_file(SERVER_CERT_PATH, 1, &cert_slice)));+    GPR_ASSERT(GRPC_LOG_IF_ERROR(+        ""load_file"", grpc_load_file(SERVER_KEY_PATH, 1, &key_slice)));+    const char* server_cert =+        reinterpret_cast<const char*> GRPC_SLICE_START_PTR(cert_slice);+    const char* server_key =+        reinterpret_cast<const char*> GRPC_SLICE_START_PTR(key_slice);+    grpc_ssl_pem_key_cert_pair pem_key_cert_pair = {server_key, server_cert};+    grpc_server_credentials* ssl_creds = grpc_ssl_server_credentials_create(+        nullptr, &pem_key_cert_pair, 1, 0, nullptr);+    grpc_slice_unref(cert_slice);+    grpc_slice_unref(key_slice);+    if (args.Contains(FAIL_AUTH_CHECK_SERVER_ARG_NAME)) {+      grpc_auth_metadata_processor processor = {ProcessAuthFailure, nullptr,+                                                nullptr};+      grpc_server_credentials_set_auth_metadata_processor(ssl_creds, processor);+    }++    auto* server = grpc_server_create(args.ToC().get(), nullptr);+    grpc_server_register_completion_queue(server, cq(), nullptr);+    GPR_ASSERT(grpc_server_add_http2_port(+        server, grpc_end2end_proxy_get_server_port(proxy_), ssl_creds));+    grpc_server_credentials_release(ssl_creds);+    grpc_server_start(server);+    return server;+  }++  grpc_channel* MakeClient(const ChannelArgs& args) override {+    grpc_channel_credentials* ssl_creds =+        grpc_ssl_credentials_create(nullptr, nullptr, nullptr, nullptr);+    auto* client = grpc_channel_create(+        grpc_end2end_proxy_get_client_target(proxy_), ssl_creds,+        args.Set(GRPC_SSL_TARGET_NAME_OVERRIDE_ARG, ""foo.test.google.fr"")+            .ToC()+            .get());+    GPR_ASSERT(client != nullptr);+    grpc_channel_credentials_release(ssl_creds);+    return client;+  }+  const grpc_end2end_proxy_def proxy_def_ = {CreateProxyServer,+                                             CreateProxyClient};+  grpc_end2end_proxy* proxy_;+};++class FixtureWithTracing final : public CoreTestFixture {+ public:+  explicit FixtureWithTracing(std::unique_ptr<CoreTestFixture> fixture)+      : fixture_(std::move(fixture)) {+    // g_fixture_slowdown_factor = 10;+    EXPECT_FALSE(grpc_tracer_set_enabled(""doesnt-exist"", 0));+    EXPECT_TRUE(grpc_tracer_set_enabled(""http"", 1));+    EXPECT_TRUE(grpc_tracer_set_enabled(""all"", 1));+  }+  ~FixtureWithTracing() override {+    saved_trace_flags_.Restore();+    // g_fixture_slowdown_factor = 1;+  }++  grpc_server* MakeServer(const ChannelArgs& args) override {+    return fixture_->MakeServer(args);+  }++  grpc_channel* MakeClient(const ChannelArgs& args) override {+    return fixture_->MakeClient(args);+  }++ private:+  SavedTraceFlags saved_trace_flags_;+  std::unique_ptr<CoreTestFixture> fixture_;+};++#ifdef GRPC_POSIX_WAKEUP_FD+class InsecureFixtureWithPipeForWakeupFd : public InsecureFixture {+ public:+  InsecureFixtureWithPipeForWakeupFd()+      : old_value_(std::exchange(grpc_allow_specialized_wakeup_fd, 0)) {}++  ~InsecureFixtureWithPipeForWakeupFd() override {+    grpc_allow_specialized_wakeup_fd = old_value_;+  }++ private:+  const int old_value_;+};+#endif++const char* NameFromConfig(+    const ::testing::TestParamInfo<const CoreTestConfiguration*>& config) {+  return config.param->name;+}++const NoDestruct<std::vector<CoreTestConfiguration>> all_configs{std::vector<","Please dump out the full matrix of fixtures x tests with both the old and new code, and make sure we're not accidentally missing anything.",
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/32632,1152392461,2023-03-29T19:28:14Z,src/core/ext/filters/client_channel/resolver/dns/event_engine/event_engine_client_channel_resolver.cc,"@@ -0,0 +1,535 @@+// Copyright 2023 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+#include <grpc/support/port_platform.h>++#include ""src/core/ext/filters/client_channel/resolver/dns/event_engine/event_engine_client_channel_resolver.h""++#include <stddef.h>+#include <stdint.h>++#include <algorithm>+#include <chrono>+#include <initializer_list>+#include <memory>+#include <string>+#include <utility>+#include <vector>++#include ""absl/base/thread_annotations.h""+#include ""absl/container/flat_hash_set.h""+#include ""absl/functional/bind_front.h""+#include ""absl/status/status.h""+#include ""absl/status/statusor.h""+#include ""absl/strings/str_cat.h""+#include ""absl/strings/str_format.h""+#include ""absl/strings/strip.h""+#include ""absl/types/optional.h""++#include <grpc/event_engine/event_engine.h>+#include <grpc/grpc.h>+#include <grpc/support/log.h>++#include ""src/core/ext/filters/client_channel/lb_policy/grpclb/grpclb_balancer_addresses.h""+#include ""src/core/ext/filters/client_channel/resolver/dns/event_engine/service_config_helper.h""+#include ""src/core/ext/filters/client_channel/resolver/polling_resolver.h""+#include ""src/core/lib/backoff/backoff.h""+#include ""src/core/lib/channel/channel_args.h""+#include ""src/core/lib/debug/trace.h""+#include ""src/core/lib/event_engine/handle_containers.h""+#include ""src/core/lib/event_engine/resolved_address_internal.h""+#include ""src/core/lib/event_engine/trace.h""+#include ""src/core/lib/event_engine/utils.h""+#include ""src/core/lib/gprpp/debug_location.h""+#include ""src/core/lib/gprpp/ref_counted_ptr.h""+#include ""src/core/lib/gprpp/status_helper.h""+#include ""src/core/lib/gprpp/sync.h""+#include ""src/core/lib/gprpp/time.h""+#include ""src/core/lib/iomgr/resolve_address.h""+#include ""src/core/lib/resolver/resolver.h""+#include ""src/core/lib/resolver/resolver_factory.h""+#include ""src/core/lib/resolver/server_address.h""+#include ""src/core/lib/service_config/service_config.h""+#include ""src/core/lib/service_config/service_config_impl.h""++// IWYU pragma: no_include <ratio>++namespace grpc_event_engine {+namespace experimental {++namespace {++#define GRPC_DNS_INITIAL_CONNECT_BACKOFF_SECONDS 1+#define GRPC_DNS_RECONNECT_BACKOFF_MULTIPLIER 1.6+#define GRPC_DNS_RECONNECT_MAX_BACKOFF_SECONDS 120+#define GRPC_DNS_RECONNECT_JITTER 0.2+#define GRPC_DNS_DEFAULT_QUERY_TIMEOUT_MS 120000++using grpc_core::BackOff;+using grpc_core::Duration;+using grpc_core::InternallyRefCounted;+using grpc_core::MakeOrphanable;+using grpc_core::Mutex;+using grpc_core::MutexLock;+using grpc_core::Orphanable;+using grpc_core::OrphanablePtr;+using grpc_core::RefCountedPtr;+using grpc_core::ResolverArgs;++// ----------------------------------------------------------------------------+// EventEngineDNSRequestWrapper declaration+// ----------------------------------------------------------------------------+class EventEngineClientChannelDNSResolver;++class EventEngineDNSRequestWrapper+    : public InternallyRefCounted<EventEngineDNSRequestWrapper> {+ public:+  EventEngineDNSRequestWrapper(+      RefCountedPtr<EventEngineClientChannelDNSResolver> resolver,+      std::unique_ptr<EventEngine::DNSResolver> event_engine_resolver);+  ~EventEngineDNSRequestWrapper() override;++  // Note that thread safety cannot be analyzed due to this being invoked from+  // OrphanablePtr<>, and there's no way to pass the lock annotation through+  // there.+  void Orphan() override ABSL_NO_THREAD_SAFETY_ANALYSIS;++  void OnHostnameResolved(+      absl::StatusOr<std::vector<EventEngine::ResolvedAddress>> addresses);+  void OnSRVResolved(+      std::string srv_host,+      absl::StatusOr<std::vector<EventEngine::DNSResolver::SRVRecord>>+          srv_records);+  void OnBalancerHostnamesResolved(+      std::string authority,+      absl::StatusOr<std::vector<EventEngine::ResolvedAddress>> addresses);+  void OnTXTResolved(absl::StatusOr<std::string> service_config);++  // Returns a Result if resolution is complete.+  // callers must release the lock and call OnRequestComplete if a Result is+  // returned. This is because OnRequestComplete may Orphan the resolver, which+  // requires taking the lock.+  absl::optional<grpc_core::Resolver::Result> OnResolvedLocked()+      ABSL_EXCLUSIVE_LOCKS_REQUIRED(on_resolved_mu_);++ private:+  // Helper method for generating the combined resolution status error+  absl::Status GetResolutionFailureErrorMessageLocked()+      ABSL_EXCLUSIVE_LOCKS_REQUIRED(on_resolved_mu_);+  // Helper method to populate server addresses on resolver result.+  void MaybePopulateAddressesLocked(grpc_core::Resolver::Result& result)+      ABSL_EXCLUSIVE_LOCKS_REQUIRED(on_resolved_mu_);+  // Helper method to populate balancer addresses on resolver result.+  void MaybePopulateBalancerAddressesLocked(grpc_core::Resolver::Result& result)+      ABSL_EXCLUSIVE_LOCKS_REQUIRED(on_resolved_mu_);+  // Helper method to populate service config on resolver result.+  void MaybePopulateServiceConfigLocked(grpc_core::Resolver::Result& result)+      ABSL_EXCLUSIVE_LOCKS_REQUIRED(on_resolved_mu_);+  // Convert empty results into resolution errors.+  //+  // TODO(roth): We should someday separate empty results (NXDOMAIN) from actual+  // DNS resolution errors. For now, they are treated the same so this resolver+  // behaves similarly to the old c-ares resolver.+  void NormalizeEmptyResultsToErrorsLocked()+      ABSL_EXCLUSIVE_LOCKS_REQUIRED(on_resolved_mu_);++  RefCountedPtr<EventEngineClientChannelDNSResolver> resolver_;+  Mutex on_resolved_mu_;+  // Lookup callbacks+  absl::optional<EventEngine::DNSResolver::LookupTaskHandle> hostname_handle_+      ABSL_GUARDED_BY(on_resolved_mu_);+  absl::optional<EventEngine::DNSResolver::LookupTaskHandle> srv_handle_+      ABSL_GUARDED_BY(on_resolved_mu_);+  absl::optional<EventEngine::DNSResolver::LookupTaskHandle> txt_handle_+      ABSL_GUARDED_BY(on_resolved_mu_);+  LookupTaskHandleSet balancer_hostname_handles_+      ABSL_GUARDED_BY(on_resolved_mu_);+  // Output fields from requests.+  absl::StatusOr<std::vector<EventEngine::ResolvedAddress>> addresses_+      ABSL_GUARDED_BY(on_resolved_mu_);+  absl::StatusOr<grpc_core::ServerAddressList> balancer_addresses_+      ABSL_GUARDED_BY(on_resolved_mu_);+  absl::StatusOr<std::string> service_config_json_+      ABSL_GUARDED_BY(on_resolved_mu_);+  // Other internal state+  size_t number_of_balancer_hostnames_resolved_+      ABSL_GUARDED_BY(on_resolved_mu_) = 0;+  bool orphaned_ ABSL_GUARDED_BY(on_resolved_mu_) = false;+  std::unique_ptr<EventEngine::DNSResolver> event_engine_resolver_;+};++// ----------------------------------------------------------------------------+// EventEngineClientChannelDNSResolver+// ----------------------------------------------------------------------------+class EventEngineClientChannelDNSResolver : public grpc_core::PollingResolver {+ public:+  EventEngineClientChannelDNSResolver(ResolverArgs args,+                                      Duration min_time_between_resolutions);+  OrphanablePtr<Orphanable> StartRequest() override;++ private:+  friend class EventEngineDNSRequestWrapper;++  /// whether to request the service config+  const bool request_service_config_;+  // whether or not to enable SRV DNS queries+  const bool enable_srv_queries_;+  // timeout in milliseconds for active DNS queries+  EventEngine::Duration query_timeout_ms_;+  std::shared_ptr<EventEngine> event_engine_;+};++EventEngineClientChannelDNSResolver::EventEngineClientChannelDNSResolver(+    ResolverArgs args, Duration min_time_between_resolutions)+    : PollingResolver(std::move(args), min_time_between_resolutions,+                      BackOff::Options()+                          .set_initial_backoff(Duration::Milliseconds(+                              GRPC_DNS_INITIAL_CONNECT_BACKOFF_SECONDS * 1000))+                          .set_multiplier(GRPC_DNS_RECONNECT_BACKOFF_MULTIPLIER)+                          .set_jitter(GRPC_DNS_RECONNECT_JITTER)+                          .set_max_backoff(Duration::Milliseconds(+                              GRPC_DNS_RECONNECT_MAX_BACKOFF_SECONDS * 1000)),+                      &grpc_event_engine_dns_trace),+      request_service_config_(+          !channel_args()+               .GetBool(GRPC_ARG_SERVICE_CONFIG_DISABLE_RESOLUTION)+               .value_or(true)),+      enable_srv_queries_(channel_args()+                              .GetBool(GRPC_ARG_DNS_ENABLE_SRV_QUERIES)+                              .value_or(false)),+      // TODO(yijiem): decide if the ares channel arg timeout should be reused.+      query_timeout_ms_(std::chrono::milliseconds(+          std::max(0, channel_args()+                          .GetInt(GRPC_ARG_DNS_ARES_QUERY_TIMEOUT_MS)+                          .value_or(GRPC_DNS_DEFAULT_QUERY_TIMEOUT_MS)))),+      event_engine_(channel_args().GetObjectRef<EventEngine>()) {}++OrphanablePtr<Orphanable> EventEngineClientChannelDNSResolver::StartRequest() {+  return MakeOrphanable<EventEngineDNSRequestWrapper>(+      Ref(DEBUG_LOCATION, ""dns-resolving""),+      event_engine_->GetDNSResolver({/*dns_server=*/authority()}));+}++// ----------------------------------------------------------------------------+// EventEngineDNSRequestWrapper definition+// ----------------------------------------------------------------------------++EventEngineDNSRequestWrapper::EventEngineDNSRequestWrapper(+    RefCountedPtr<EventEngineClientChannelDNSResolver> resolver,+    std::unique_ptr<EventEngine::DNSResolver> event_engine_resolver)+    : resolver_(std::move(resolver)),+      event_engine_resolver_(std::move(event_engine_resolver)) {+  // Locking to prevent completion before all records are queried+  MutexLock lock(&on_resolved_mu_);+  hostname_handle_ = event_engine_resolver_->LookupHostname(+      absl::bind_front(&EventEngineDNSRequestWrapper::OnHostnameResolved,+                       Ref(DEBUG_LOCATION, ""OnHostnameResolved"")),+      resolver_->name_to_resolve(), grpc_core::kDefaultSecurePort,+      resolver_->query_timeout_ms_);+  GRPC_EVENT_ENGINE_DNS_TRACE(+      ""DNSResolver::%p Started resolving hostname. Handle::%s"", resolver_.get(),+      HandleToString(*hostname_handle_).c_str());+  if (resolver_->enable_srv_queries_) {+    srv_handle_ = event_engine_resolver_->LookupSRV(+        absl::bind_front(&EventEngineDNSRequestWrapper::OnSRVResolved,+                         Ref(DEBUG_LOCATION, ""OnSRVResolved""),+                         resolver_->name_to_resolve()),+        resolver_->name_to_resolve(), resolver_->query_timeout_ms_);+    GRPC_EVENT_ENGINE_DNS_TRACE(+        ""DNSResolver::%p Started resolving SRV. Handle::%s"", resolver_.get(),+        HandleToString(*srv_handle_).c_str());+  }+  if (resolver_->request_service_config_) {+    txt_handle_ = event_engine_resolver_->LookupTXT(+        absl::bind_front(&EventEngineDNSRequestWrapper::OnTXTResolved,+                         Ref(DEBUG_LOCATION, ""OnTXTResolved"")),+        resolver_->name_to_resolve(), resolver_->query_timeout_ms_);+    GRPC_EVENT_ENGINE_DNS_TRACE(+        ""DNSResolver::%p Started resolving TXT. Handle::%s"", resolver_.get(),+        HandleToString(*txt_handle_).c_str());+  }+}++EventEngineDNSRequestWrapper::~EventEngineDNSRequestWrapper() {+  resolver_.reset(DEBUG_LOCATION, ""dns-resolving"");+}++void EventEngineDNSRequestWrapper::Orphan() {+  {+    MutexLock lock(&on_resolved_mu_);+    orphaned_ = true;+    // Event if cancellation fails here, OnResolvedLocked will return early, and+    // the resolver will never see a completed request.+    if (hostname_handle_.has_value()) {+      event_engine_resolver_->CancelLookup(*hostname_handle_);+    }+    if (srv_handle_.has_value()) {+      event_engine_resolver_->CancelLookup(*srv_handle_);+    }+    for (const auto& handle : balancer_hostname_handles_) {+      event_engine_resolver_->CancelLookup(handle);+    }+    if (txt_handle_.has_value()) {+      event_engine_resolver_->CancelLookup(*txt_handle_);+    }+  }+  Unref(DEBUG_LOCATION, ""Orphan"");+}++void EventEngineDNSRequestWrapper::OnHostnameResolved(+    absl::StatusOr<std::vector<EventEngine::ResolvedAddress>> addresses) {+  absl::optional<grpc_core::Resolver::Result> result;+  {+    MutexLock lock(&on_resolved_mu_);+    if (orphaned_) return;+    hostname_handle_.reset();+    addresses_ = addresses;+    result = OnResolvedLocked();+  }+  if (result.has_value()) {+    resolver_->OnRequestComplete(std::move(*result));+  }+}++void EventEngineDNSRequestWrapper::OnSRVResolved(+    std::string srv_host,+    absl::StatusOr<std::vector<EventEngine::DNSResolver::SRVRecord>>+        srv_records) {+  absl::optional<grpc_core::Resolver::Result> result;+  {+    MutexLock lock(&on_resolved_mu_);+    if (orphaned_) return;+    srv_handle_.reset();+    if (srv_records.ok()) {+      balancer_addresses_ = grpc_core::ServerAddressList();+      // Do a subsequent hostname query if SRV records were returned+      for (const auto& srv_record : *srv_records) {+        balancer_hostname_handles_.insert(+            event_engine_resolver_->LookupHostname(+                absl::bind_front(+                    &EventEngineDNSRequestWrapper::OnBalancerHostnamesResolved,+                    Ref(DEBUG_LOCATION, ""OnBalancerHostnamesResolved""),+                    srv_host),+                srv_record.host, std::to_string(srv_record.port),+                resolver_->query_timeout_ms_));+        GRPC_EVENT_ENGINE_DNS_TRACE(+            ""DNSResolver::%p Started resolving balancer hostname %s:%d"",+            resolver_.get(), srv_record.host.c_str(), srv_record.port);+      }+      return;+    }+    // An error has occurred, finish resolving.+    balancer_addresses_ = srv_records.status();+    result = OnResolvedLocked();+  }+  if (result.has_value()) {+    resolver_->OnRequestComplete(std::move(*result));+  }+}++void EventEngineDNSRequestWrapper::OnBalancerHostnamesResolved(+    std::string authority,+    absl::StatusOr<std::vector<EventEngine::ResolvedAddress>>+        new_balancer_addresses) {+  absl::optional<grpc_core::Resolver::Result> result;+  {+    MutexLock lock(&on_resolved_mu_);+    if (orphaned_) return;+    ++number_of_balancer_hostnames_resolved_;+    if (new_balancer_addresses.ok()) {+      if (!balancer_addresses_.ok()) {+        GRPC_EVENT_ENGINE_DNS_TRACE(+            ""DNSResolver::%p previous balancer hostname lookup error, ignoring ""","This is fixed, and the errors are appended to the resolution_note. You're right, it would have crashed ... either our naming tests don't cover that, or we haven't tested them properly yet. More of that will be done with the EventEngine DNS Resolver integration that Yijie is working on.",
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/32632,1152431167,2023-03-29T20:10:09Z,src/core/ext/filters/client_channel/resolver/dns/native/dns_resolver.cc,"@@ -181,18 +180,13 @@ class NativeClientChannelDNSResolverFactory : public ResolverFactory { }  // namespace  void RegisterNativeDnsResolver(CoreConfiguration::Builder* builder) {-  static const char* const resolver =+  static absl::string_view resolver =       GPR_GLOBAL_CONFIG_GET(grpc_dns_resolver).release();-  if (gpr_stricmp(resolver, ""native"") == 0) {+  if (resolver == ""native"" ||+      !builder->resolver_registry()->HasResolverFactory(""dns"")) {     gpr_log(GPR_DEBUG, ""Using native dns resolver"");",Done. I've added similar logs for the other resolvers.,
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32632,1152519695,2023-03-29T21:52:02Z,src/core/ext/filters/client_channel/resolver/dns/event_engine/event_engine_client_channel_resolver.cc,"@@ -75,110 +74,108 @@ namespace { #define GRPC_DNS_RECONNECT_JITTER 0.2 #define GRPC_DNS_DEFAULT_QUERY_TIMEOUT_MS 120000 -using grpc_core::BackOff;-using grpc_core::Duration;-using grpc_core::InternallyRefCounted;-using grpc_core::MakeOrphanable;-using grpc_core::Mutex;-using grpc_core::MutexLock;-using grpc_core::Orphanable;-using grpc_core::OrphanablePtr;-using grpc_core::RefCountedPtr;-using grpc_core::ResolverArgs;+using grpc_event_engine::experimental::EventEngine;+using grpc_event_engine::experimental::LookupTaskHandleSet; -// -----------------------------------------------------------------------------// EventEngineDNSRequestWrapper declaration-// -----------------------------------------------------------------------------class EventEngineClientChannelDNSResolver;+TraceFlag grpc_event_engine_client_channel_resolver_trace(","Please add a TODO about eventually renaming this to just ""dns_resolver"" once the other two DNS resolver impls go away.",X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32632,1152566975,2023-03-29T22:57:47Z,src/core/ext/filters/client_channel/resolver/dns/event_engine/event_engine_client_channel_resolver.cc,"@@ -0,0 +1,535 @@+// Copyright 2023 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+#include <grpc/support/port_platform.h>++#include ""src/core/ext/filters/client_channel/resolver/dns/event_engine/event_engine_client_channel_resolver.h""++#include <stddef.h>+#include <stdint.h>++#include <algorithm>+#include <chrono>+#include <initializer_list>+#include <memory>+#include <string>+#include <utility>+#include <vector>++#include ""absl/base/thread_annotations.h""+#include ""absl/container/flat_hash_set.h""+#include ""absl/functional/bind_front.h""+#include ""absl/status/status.h""+#include ""absl/status/statusor.h""+#include ""absl/strings/str_cat.h""+#include ""absl/strings/str_format.h""+#include ""absl/strings/strip.h""+#include ""absl/types/optional.h""++#include <grpc/event_engine/event_engine.h>+#include <grpc/grpc.h>+#include <grpc/support/log.h>++#include ""src/core/ext/filters/client_channel/lb_policy/grpclb/grpclb_balancer_addresses.h""+#include ""src/core/ext/filters/client_channel/resolver/dns/event_engine/service_config_helper.h""+#include ""src/core/ext/filters/client_channel/resolver/polling_resolver.h""+#include ""src/core/lib/backoff/backoff.h""+#include ""src/core/lib/channel/channel_args.h""+#include ""src/core/lib/debug/trace.h""+#include ""src/core/lib/event_engine/handle_containers.h""+#include ""src/core/lib/event_engine/resolved_address_internal.h""+#include ""src/core/lib/event_engine/trace.h""+#include ""src/core/lib/event_engine/utils.h""+#include ""src/core/lib/gprpp/debug_location.h""+#include ""src/core/lib/gprpp/ref_counted_ptr.h""+#include ""src/core/lib/gprpp/status_helper.h""+#include ""src/core/lib/gprpp/sync.h""+#include ""src/core/lib/gprpp/time.h""+#include ""src/core/lib/iomgr/resolve_address.h""+#include ""src/core/lib/resolver/resolver.h""+#include ""src/core/lib/resolver/resolver_factory.h""+#include ""src/core/lib/resolver/server_address.h""+#include ""src/core/lib/service_config/service_config.h""+#include ""src/core/lib/service_config/service_config_impl.h""++// IWYU pragma: no_include <ratio>++namespace grpc_event_engine {+namespace experimental {++namespace {++#define GRPC_DNS_INITIAL_CONNECT_BACKOFF_SECONDS 1+#define GRPC_DNS_RECONNECT_BACKOFF_MULTIPLIER 1.6+#define GRPC_DNS_RECONNECT_MAX_BACKOFF_SECONDS 120+#define GRPC_DNS_RECONNECT_JITTER 0.2+#define GRPC_DNS_DEFAULT_QUERY_TIMEOUT_MS 120000++using grpc_core::BackOff;+using grpc_core::Duration;+using grpc_core::InternallyRefCounted;+using grpc_core::MakeOrphanable;+using grpc_core::Mutex;+using grpc_core::MutexLock;+using grpc_core::Orphanable;+using grpc_core::OrphanablePtr;+using grpc_core::RefCountedPtr;+using grpc_core::ResolverArgs;++// ----------------------------------------------------------------------------+// EventEngineDNSRequestWrapper declaration+// ----------------------------------------------------------------------------+class EventEngineClientChannelDNSResolver;++class EventEngineDNSRequestWrapper+    : public InternallyRefCounted<EventEngineDNSRequestWrapper> {+ public:+  EventEngineDNSRequestWrapper(+      RefCountedPtr<EventEngineClientChannelDNSResolver> resolver,+      std::unique_ptr<EventEngine::DNSResolver> event_engine_resolver);+  ~EventEngineDNSRequestWrapper() override;++  // Note that thread safety cannot be analyzed due to this being invoked from+  // OrphanablePtr<>, and there's no way to pass the lock annotation through+  // there.+  void Orphan() override ABSL_NO_THREAD_SAFETY_ANALYSIS;++  void OnHostnameResolved(+      absl::StatusOr<std::vector<EventEngine::ResolvedAddress>> addresses);+  void OnSRVResolved(+      std::string srv_host,+      absl::StatusOr<std::vector<EventEngine::DNSResolver::SRVRecord>>+          srv_records);+  void OnBalancerHostnamesResolved(+      std::string authority,+      absl::StatusOr<std::vector<EventEngine::ResolvedAddress>> addresses);+  void OnTXTResolved(absl::StatusOr<std::string> service_config);++  // Returns a Result if resolution is complete.+  // callers must release the lock and call OnRequestComplete if a Result is+  // returned. This is because OnRequestComplete may Orphan the resolver, which+  // requires taking the lock.+  absl::optional<grpc_core::Resolver::Result> OnResolvedLocked()+      ABSL_EXCLUSIVE_LOCKS_REQUIRED(on_resolved_mu_);++ private:+  // Helper method for generating the combined resolution status error+  absl::Status GetResolutionFailureErrorMessageLocked()+      ABSL_EXCLUSIVE_LOCKS_REQUIRED(on_resolved_mu_);+  // Helper method to populate server addresses on resolver result.+  void MaybePopulateAddressesLocked(grpc_core::Resolver::Result& result)+      ABSL_EXCLUSIVE_LOCKS_REQUIRED(on_resolved_mu_);+  // Helper method to populate balancer addresses on resolver result.+  void MaybePopulateBalancerAddressesLocked(grpc_core::Resolver::Result& result)+      ABSL_EXCLUSIVE_LOCKS_REQUIRED(on_resolved_mu_);+  // Helper method to populate service config on resolver result.+  void MaybePopulateServiceConfigLocked(grpc_core::Resolver::Result& result)+      ABSL_EXCLUSIVE_LOCKS_REQUIRED(on_resolved_mu_);+  // Convert empty results into resolution errors.+  //+  // TODO(roth): We should someday separate empty results (NXDOMAIN) from actual+  // DNS resolution errors. For now, they are treated the same so this resolver+  // behaves similarly to the old c-ares resolver.+  void NormalizeEmptyResultsToErrorsLocked()+      ABSL_EXCLUSIVE_LOCKS_REQUIRED(on_resolved_mu_);++  RefCountedPtr<EventEngineClientChannelDNSResolver> resolver_;+  Mutex on_resolved_mu_;+  // Lookup callbacks+  absl::optional<EventEngine::DNSResolver::LookupTaskHandle> hostname_handle_+      ABSL_GUARDED_BY(on_resolved_mu_);+  absl::optional<EventEngine::DNSResolver::LookupTaskHandle> srv_handle_+      ABSL_GUARDED_BY(on_resolved_mu_);+  absl::optional<EventEngine::DNSResolver::LookupTaskHandle> txt_handle_+      ABSL_GUARDED_BY(on_resolved_mu_);+  LookupTaskHandleSet balancer_hostname_handles_+      ABSL_GUARDED_BY(on_resolved_mu_);+  // Output fields from requests.+  absl::StatusOr<std::vector<EventEngine::ResolvedAddress>> addresses_+      ABSL_GUARDED_BY(on_resolved_mu_);+  absl::StatusOr<grpc_core::ServerAddressList> balancer_addresses_+      ABSL_GUARDED_BY(on_resolved_mu_);+  absl::StatusOr<std::string> service_config_json_+      ABSL_GUARDED_BY(on_resolved_mu_);+  // Other internal state+  size_t number_of_balancer_hostnames_resolved_+      ABSL_GUARDED_BY(on_resolved_mu_) = 0;+  bool orphaned_ ABSL_GUARDED_BY(on_resolved_mu_) = false;+  std::unique_ptr<EventEngine::DNSResolver> event_engine_resolver_;+};++// ----------------------------------------------------------------------------+// EventEngineClientChannelDNSResolver+// ----------------------------------------------------------------------------+class EventEngineClientChannelDNSResolver : public grpc_core::PollingResolver {+ public:+  EventEngineClientChannelDNSResolver(ResolverArgs args,+                                      Duration min_time_between_resolutions);+  OrphanablePtr<Orphanable> StartRequest() override;++ private:+  friend class EventEngineDNSRequestWrapper;++  /// whether to request the service config+  const bool request_service_config_;+  // whether or not to enable SRV DNS queries+  const bool enable_srv_queries_;+  // timeout in milliseconds for active DNS queries+  EventEngine::Duration query_timeout_ms_;+  std::shared_ptr<EventEngine> event_engine_;+};++EventEngineClientChannelDNSResolver::EventEngineClientChannelDNSResolver(+    ResolverArgs args, Duration min_time_between_resolutions)+    : PollingResolver(std::move(args), min_time_between_resolutions,+                      BackOff::Options()+                          .set_initial_backoff(Duration::Milliseconds(+                              GRPC_DNS_INITIAL_CONNECT_BACKOFF_SECONDS * 1000))+                          .set_multiplier(GRPC_DNS_RECONNECT_BACKOFF_MULTIPLIER)+                          .set_jitter(GRPC_DNS_RECONNECT_JITTER)+                          .set_max_backoff(Duration::Milliseconds(+                              GRPC_DNS_RECONNECT_MAX_BACKOFF_SECONDS * 1000)),+                      &grpc_event_engine_dns_trace),+      request_service_config_(+          !channel_args()+               .GetBool(GRPC_ARG_SERVICE_CONFIG_DISABLE_RESOLUTION)+               .value_or(true)),+      enable_srv_queries_(channel_args()+                              .GetBool(GRPC_ARG_DNS_ENABLE_SRV_QUERIES)+                              .value_or(false)),+      // TODO(yijiem): decide if the ares channel arg timeout should be reused.+      query_timeout_ms_(std::chrono::milliseconds(+          std::max(0, channel_args()+                          .GetInt(GRPC_ARG_DNS_ARES_QUERY_TIMEOUT_MS)+                          .value_or(GRPC_DNS_DEFAULT_QUERY_TIMEOUT_MS)))),+      event_engine_(channel_args().GetObjectRef<EventEngine>()) {}++OrphanablePtr<Orphanable> EventEngineClientChannelDNSResolver::StartRequest() {+  return MakeOrphanable<EventEngineDNSRequestWrapper>(+      Ref(DEBUG_LOCATION, ""dns-resolving""),+      event_engine_->GetDNSResolver({/*dns_server=*/authority()}));+}++// ----------------------------------------------------------------------------+// EventEngineDNSRequestWrapper definition+// ----------------------------------------------------------------------------++EventEngineDNSRequestWrapper::EventEngineDNSRequestWrapper(+    RefCountedPtr<EventEngineClientChannelDNSResolver> resolver,+    std::unique_ptr<EventEngine::DNSResolver> event_engine_resolver)+    : resolver_(std::move(resolver)),+      event_engine_resolver_(std::move(event_engine_resolver)) {+  // Locking to prevent completion before all records are queried+  MutexLock lock(&on_resolved_mu_);+  hostname_handle_ = event_engine_resolver_->LookupHostname(+      absl::bind_front(&EventEngineDNSRequestWrapper::OnHostnameResolved,+                       Ref(DEBUG_LOCATION, ""OnHostnameResolved"")),+      resolver_->name_to_resolve(), grpc_core::kDefaultSecurePort,+      resolver_->query_timeout_ms_);+  GRPC_EVENT_ENGINE_DNS_TRACE(+      ""DNSResolver::%p Started resolving hostname. Handle::%s"", resolver_.get(),+      HandleToString(*hostname_handle_).c_str());+  if (resolver_->enable_srv_queries_) {+    srv_handle_ = event_engine_resolver_->LookupSRV(+        absl::bind_front(&EventEngineDNSRequestWrapper::OnSRVResolved,+                         Ref(DEBUG_LOCATION, ""OnSRVResolved""),+                         resolver_->name_to_resolve()),+        resolver_->name_to_resolve(), resolver_->query_timeout_ms_);+    GRPC_EVENT_ENGINE_DNS_TRACE(+        ""DNSResolver::%p Started resolving SRV. Handle::%s"", resolver_.get(),+        HandleToString(*srv_handle_).c_str());+  }+  if (resolver_->request_service_config_) {+    txt_handle_ = event_engine_resolver_->LookupTXT(+        absl::bind_front(&EventEngineDNSRequestWrapper::OnTXTResolved,+                         Ref(DEBUG_LOCATION, ""OnTXTResolved"")),+        resolver_->name_to_resolve(), resolver_->query_timeout_ms_);+    GRPC_EVENT_ENGINE_DNS_TRACE(+        ""DNSResolver::%p Started resolving TXT. Handle::%s"", resolver_.get(),+        HandleToString(*txt_handle_).c_str());+  }+}++EventEngineDNSRequestWrapper::~EventEngineDNSRequestWrapper() {+  resolver_.reset(DEBUG_LOCATION, ""dns-resolving"");+}++void EventEngineDNSRequestWrapper::Orphan() {+  {+    MutexLock lock(&on_resolved_mu_);+    orphaned_ = true;+    // Event if cancellation fails here, OnResolvedLocked will return early, and+    // the resolver will never see a completed request.+    if (hostname_handle_.has_value()) {+      event_engine_resolver_->CancelLookup(*hostname_handle_);+    }+    if (srv_handle_.has_value()) {+      event_engine_resolver_->CancelLookup(*srv_handle_);+    }+    for (const auto& handle : balancer_hostname_handles_) {+      event_engine_resolver_->CancelLookup(handle);+    }+    if (txt_handle_.has_value()) {+      event_engine_resolver_->CancelLookup(*txt_handle_);+    }+  }+  Unref(DEBUG_LOCATION, ""Orphan"");+}++void EventEngineDNSRequestWrapper::OnHostnameResolved(+    absl::StatusOr<std::vector<EventEngine::ResolvedAddress>> addresses) {+  absl::optional<grpc_core::Resolver::Result> result;+  {+    MutexLock lock(&on_resolved_mu_);+    if (orphaned_) return;+    hostname_handle_.reset();+    addresses_ = addresses;+    result = OnResolvedLocked();+  }+  if (result.has_value()) {+    resolver_->OnRequestComplete(std::move(*result));+  }+}++void EventEngineDNSRequestWrapper::OnSRVResolved(+    std::string srv_host,+    absl::StatusOr<std::vector<EventEngine::DNSResolver::SRVRecord>>+        srv_records) {+  absl::optional<grpc_core::Resolver::Result> result;+  {+    MutexLock lock(&on_resolved_mu_);+    if (orphaned_) return;+    srv_handle_.reset();+    if (srv_records.ok()) {+      balancer_addresses_ = grpc_core::ServerAddressList();+      // Do a subsequent hostname query if SRV records were returned+      for (const auto& srv_record : *srv_records) {+        balancer_hostname_handles_.insert(+            event_engine_resolver_->LookupHostname(+                absl::bind_front(+                    &EventEngineDNSRequestWrapper::OnBalancerHostnamesResolved,+                    Ref(DEBUG_LOCATION, ""OnBalancerHostnamesResolved""),+                    srv_host),+                srv_record.host, std::to_string(srv_record.port),+                resolver_->query_timeout_ms_));+        GRPC_EVENT_ENGINE_DNS_TRACE(+            ""DNSResolver::%p Started resolving balancer hostname %s:%d"",+            resolver_.get(), srv_record.host.c_str(), srv_record.port);+      }+      return;+    }+    // An error has occurred, finish resolving.+    balancer_addresses_ = srv_records.status();+    result = OnResolvedLocked();+  }+  if (result.has_value()) {+    resolver_->OnRequestComplete(std::move(*result));+  }+}++void EventEngineDNSRequestWrapper::OnBalancerHostnamesResolved(+    std::string authority,+    absl::StatusOr<std::vector<EventEngine::ResolvedAddress>>+        new_balancer_addresses) {+  absl::optional<grpc_core::Resolver::Result> result;+  {+    MutexLock lock(&on_resolved_mu_);+    if (orphaned_) return;+    ++number_of_balancer_hostnames_resolved_;+    if (new_balancer_addresses.ok()) {+      if (!balancer_addresses_.ok()) {+        GRPC_EVENT_ENGINE_DNS_TRACE(+            ""DNSResolver::%p previous balancer hostname lookup error, ignoring ""+            ""%zu found hostnames."",+            this, new_balancer_addresses->size());+      }+      balancer_addresses_->reserve(balancer_addresses_->size() ++                                   new_balancer_addresses->size());+      auto srv_channel_args =+          resolver_->channel_args().Set(GRPC_ARG_DEFAULT_AUTHORITY, authority);+      for (const auto& addr : *new_balancer_addresses) {+        balancer_addresses_->emplace_back(CreateGRPCResolvedAddress(addr),+                                          srv_channel_args);+      }+    } else {+      auto tmp_status = balancer_addresses_.status();+      grpc_core::StatusAddChild(&tmp_status, new_balancer_addresses.status());+      balancer_addresses_ = tmp_status;+    }+    result = OnResolvedLocked();+  }+  if (result.has_value()) {+    resolver_->OnRequestComplete(std::move(*result));+  }+}++void EventEngineDNSRequestWrapper::OnTXTResolved(+    absl::StatusOr<std::string> service_config) {+  absl::optional<grpc_core::Resolver::Result> result;+  {+    MutexLock lock(&on_resolved_mu_);+    if (orphaned_) return;+    GPR_ASSERT(txt_handle_.has_value());+    txt_handle_.reset();+    service_config_json_ = service_config;+    result = OnResolvedLocked();+  }+  if (result.has_value()) {+    resolver_->OnRequestComplete(std::move(*result));+  }+}++absl::Status+EventEngineDNSRequestWrapper::GetResolutionFailureErrorMessageLocked() {+  std::string error_msg =+      absl::StrFormat(""resolver:%p dns resolution failed."", this);+  if (!addresses_.ok()) {+    absl::StrAppend(&error_msg, "" Hostname lookup error: "",+                    grpc_core::StatusToString(addresses_.status()));+  }+  if (!balancer_addresses_.ok()) {+    absl::StrAppend(&error_msg, "" SRV lookup error: "",+                    grpc_core::StatusToString(balancer_addresses_.status()));+  }+  if (!service_config_json_.ok()) {+    absl::StrAppend(&error_msg, "" TXT lookup error: "",+                    grpc_core::StatusToString(service_config_json_.status()));+  }+  auto status = grpc_core::StatusCreate(+      absl::StatusCode::kUnavailable, error_msg, DEBUG_LOCATION, /*children=*/+      {addresses_.status(), balancer_addresses_.status(),+       service_config_json_.status()});+  return status;+}++void EventEngineDNSRequestWrapper::MaybePopulateAddressesLocked(+    grpc_core::Resolver::Result& result) {+  result.addresses = grpc_core::ServerAddressList();+  if (addresses_.ok()) {+    result.addresses->reserve(addresses_->size());+    for (const auto& addr : *addresses_) {+      result.addresses->emplace_back(CreateGRPCResolvedAddress(addr),+                                     resolver_->channel_args());+    }+  }+}++void EventEngineDNSRequestWrapper::MaybePopulateBalancerAddressesLocked(+    grpc_core::Resolver::Result& result) {+  if (balancer_addresses_.ok()) {+    result.args = grpc_core::SetGrpcLbBalancerAddresses(result.args,+                                                        *balancer_addresses_);+  }+}++void EventEngineDNSRequestWrapper::MaybePopulateServiceConfigLocked(+    grpc_core::Resolver::Result& result) {+  // TODO(roth): We should not ignore errors here, but instead have users of the+  // resolver handle them appropriately. Some test/cpp/naming tests fail.+  if ((addresses_.ok() || balancer_addresses_.ok()) &&+      service_config_json_.ok() && service_config_json_->empty()) {+    result.service_config = service_config_json_.status();","Sorry, I was conflating two cases:1. The TXT lookup failed.2. The TXT lookup succeeded, but `ChooseServiceConfig()` failed.I was thinking that we return a service config failure in both cases, but I forgot that for bug-for-bug compatibility, we will actually ignore the error in case 1 if we have addresses.  Given that, I think the logic here should be:```// This function is called only if we are returning addresses.  In that case,// we currently ignore TXT lookup failures.// TODO(roth): Consider differentiating between NXDOMAIN and other failures,// so that we can return an error in the non-NXDOMAIN case.if (!service_config_json_.ok()) return;// TXT lookup succeeded, so parse the config.auto service_config = ChooseServiceConfig(*service_config_json_);if (!service_config.ok()) {  result.service_config = absl::UnavailableError(          absl::StrCat(""failed to parse service config: "",                       grpc_core::StatusToString(service_config.status())));  return;}if (!service_config->empty()) {  // ...}```Independently of any of the above, though, I'm pretty sure the current code here is wrong.  The condition on the previous line requires that `service_config_json_.ok()` be true, which means that `service_config_json_.status()` will always be an OK status, and we are then assigning `result.service_config` to that status.  However, I don't think it makes sense to set a `StatusOr<>` to OK status explicitly, because in that case, the `StatusOr<>` is supposed to have a payload instead.Note that the default value for `result.service_config` is nullptr, meaning that the resolver is not returning any service config.  I think we want to leave the value that way if we're not returning a config.",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/32603,1152572465,2023-03-29T23:03:42Z,src/objective-c/tests/BUILD,"@@ -188,7 +185,7 @@ grpc_objc_testing_library(     deps = [         ""InteropTests-lib"",         ""//src/objective-c:grpc_objc_client_core_cronet_testing"",-        ""//test/core/end2end:end2end_tests"",",`//test/core/end2end:end2end_tests` prior to this PR was a library that exported about 100 end2end tests for gRPC.Here they were being instantiated with a fixture supplied by CoreCronetEnd2EndTests.mm (also deleted) to test Cronet in a variety of situations against a gRPC chttp2 backend.I think other testing of Objective-C is using other frameworks.`cq_verifier` here is a utility class that aids in writing tests against the C-core framework.,
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32632,1152587123,2023-03-29T23:30:51Z,src/core/ext/filters/client_channel/resolver/dns/event_engine/event_engine_client_channel_resolver.cc,"@@ -389,32 +387,29 @@ void EventEngineDNSRequestWrapper::OnTXTResolved(   } } -absl::Status-EventEngineDNSRequestWrapper::GetResolutionFailureErrorMessageLocked() {-  std::string error_msg =-      absl::StrFormat(""resolver:%p dns resolution failed."", this);+absl::Status EventEngineClientChannelDNSResolver::EventEngineDNSRequestWrapper::+    GetResolutionFailureErrorMessageLocked() {","In principle, it should not be necessary to use interim `absl::Status` values or to add the result from one `ValidationErrors` object into another.  Instead, you generally want to use `ValidationErrors::ScopedField` to indicate the nesting.Consider the following approach:- Have a single `ValidationErrors errors_` data member.- Change `addresses_` to not use `StatusOr<>`.- In each callback, start a local scope using something like `ValidationErrors::ScopedField field(&errors_, ""address lookup"");`.  That way, when you call `errors_.AddError()`, you get the right scope automatically associated with each error message.- In `OnTXTResolved()`, if we get a non-OK status, add an error to `errors_` in addition to setting `service_config_json_` to a non-OK status.  (As an alternative, we could actually change `service_config_json_` to use `absl::optional<>` instead of `absl::StatusOr<>`, since we're not currently going to use `service_config_json_` if it's a non-OK status.  But I think it's better to keep this using `StatusOr<>`, since we're eventually going to want to use that status in non-NXDOMAIN cases, as per the TODO I've suggested elsewhere.)- There will no longer be a need for this `GetResolutionFailureErrorMessageLocked()` method; instead, you can get the whole error status from `errors_.status()`.- In `OnResolvedLocked()`, you can do something like this:  ```  if (addresses_.empty() && balancer_addresses_.empty()) {    absl::Status status =        errors_.status(absl::StrCat(""errors resolving "", resolver_->name_to_resolve()),                                    absl::StatusCode::kUnavailable);    result.addresses = status;    result.service_config = status;    return std::move(result);  }  if (!errors_.ok()) {    result.resolution_note = std::string(          errors_.status(absl::StrCat(""errors resolving "", resolver_->name_to_resolve()),                                      absl::StatusCode::kUnavailable).message());  }  result.addresses.emplace();  MaybePopulateAddressesLocked(result);  MaybePopulateServiceConfigLocked(result);  MaybePopulateBalancerAddressesLocked(result);  return std::move(result);  ```",
133680,sampajano,https://api.github.com/repos/grpc/grpc/pulls/32077,1152595095,2023-03-29T23:47:20Z,src/core/lib/event_engine/cf_engine/cf_engine.cc,"@@ -72,14 +76,76 @@ CFEventEngine::CreateListener( }  CFEventEngine::ConnectionHandle CFEventEngine::Connect(-    OnConnectCallback /* on_connect */, const ResolvedAddress& /* addr */,-    const EndpointConfig& /* args */, MemoryAllocator /* memory_allocator */,-    Duration /* timeout */) {-  grpc_core::Crash(""unimplemented"");+    OnConnectCallback on_connect, const ResolvedAddress& addr,+    const EndpointConfig& /* args */, MemoryAllocator memory_allocator,+    Duration timeout) {+  auto endpoint_ptr = new CFStreamEndpoint(+      std::static_pointer_cast<CFEventEngine>(shared_from_this()),+      std::move(memory_allocator));++  ConnectionHandle handle{reinterpret_cast<intptr_t>(endpoint_ptr), 0};+  {+    grpc_core::MutexLock lock(&conn_mu_);+    conn_handles_.insert(handle);+  }++  auto deadline_timer =+      RunAfter(timeout, [handle, that = std::static_pointer_cast<CFEventEngine>(+                                     shared_from_this())]() {+        that->CancelConnectInternal(+            handle, absl::DeadlineExceededError(""Connect timed out""));+      });++  auto on_connect2 =+      [that = std::static_pointer_cast<CFEventEngine>(shared_from_this()),+       deadline_timer = std::move(deadline_timer), handle,+       on_connect = std::move(on_connect)](absl::Status status) mutable {+        // best effort canceling deadline timer+        that->Cancel(deadline_timer);++        {+          grpc_core::MutexLock lock(&that->conn_mu_);+          that->conn_handles_.erase(handle);+        }++        auto endpoint_ptr = reinterpret_cast<CFStreamEndpoint*>(handle.keys[0]);++        if (!status.ok()) {+          on_connect(std::move(status));",aha ok! i guess this is fine.. (i've seen this used in other classes too so i assume this is how it's typically used.. :)),
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32632,1152599598,2023-03-29T23:57:23Z,src/core/ext/filters/client_channel/resolver/dns/event_engine/event_engine_client_channel_resolver.cc,"@@ -0,0 +1,535 @@+// Copyright 2023 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+#include <grpc/support/port_platform.h>++#include ""src/core/ext/filters/client_channel/resolver/dns/event_engine/event_engine_client_channel_resolver.h""++#include <stddef.h>+#include <stdint.h>++#include <algorithm>+#include <chrono>+#include <initializer_list>+#include <memory>+#include <string>+#include <utility>+#include <vector>++#include ""absl/base/thread_annotations.h""+#include ""absl/container/flat_hash_set.h""+#include ""absl/functional/bind_front.h""+#include ""absl/status/status.h""+#include ""absl/status/statusor.h""+#include ""absl/strings/str_cat.h""+#include ""absl/strings/str_format.h""+#include ""absl/strings/strip.h""+#include ""absl/types/optional.h""++#include <grpc/event_engine/event_engine.h>+#include <grpc/grpc.h>+#include <grpc/support/log.h>++#include ""src/core/ext/filters/client_channel/lb_policy/grpclb/grpclb_balancer_addresses.h""+#include ""src/core/ext/filters/client_channel/resolver/dns/event_engine/service_config_helper.h""+#include ""src/core/ext/filters/client_channel/resolver/polling_resolver.h""+#include ""src/core/lib/backoff/backoff.h""+#include ""src/core/lib/channel/channel_args.h""+#include ""src/core/lib/debug/trace.h""+#include ""src/core/lib/event_engine/handle_containers.h""+#include ""src/core/lib/event_engine/resolved_address_internal.h""+#include ""src/core/lib/event_engine/trace.h""+#include ""src/core/lib/event_engine/utils.h""+#include ""src/core/lib/gprpp/debug_location.h""+#include ""src/core/lib/gprpp/ref_counted_ptr.h""+#include ""src/core/lib/gprpp/status_helper.h""+#include ""src/core/lib/gprpp/sync.h""+#include ""src/core/lib/gprpp/time.h""+#include ""src/core/lib/iomgr/resolve_address.h""+#include ""src/core/lib/resolver/resolver.h""+#include ""src/core/lib/resolver/resolver_factory.h""+#include ""src/core/lib/resolver/server_address.h""+#include ""src/core/lib/service_config/service_config.h""+#include ""src/core/lib/service_config/service_config_impl.h""++// IWYU pragma: no_include <ratio>++namespace grpc_event_engine {+namespace experimental {++namespace {++#define GRPC_DNS_INITIAL_CONNECT_BACKOFF_SECONDS 1+#define GRPC_DNS_RECONNECT_BACKOFF_MULTIPLIER 1.6+#define GRPC_DNS_RECONNECT_MAX_BACKOFF_SECONDS 120+#define GRPC_DNS_RECONNECT_JITTER 0.2+#define GRPC_DNS_DEFAULT_QUERY_TIMEOUT_MS 120000++using grpc_core::BackOff;+using grpc_core::Duration;+using grpc_core::InternallyRefCounted;+using grpc_core::MakeOrphanable;+using grpc_core::Mutex;+using grpc_core::MutexLock;+using grpc_core::Orphanable;+using grpc_core::OrphanablePtr;+using grpc_core::RefCountedPtr;+using grpc_core::ResolverArgs;++// ----------------------------------------------------------------------------+// EventEngineDNSRequestWrapper declaration+// ----------------------------------------------------------------------------+class EventEngineClientChannelDNSResolver;++class EventEngineDNSRequestWrapper+    : public InternallyRefCounted<EventEngineDNSRequestWrapper> {+ public:+  EventEngineDNSRequestWrapper(+      RefCountedPtr<EventEngineClientChannelDNSResolver> resolver,+      std::unique_ptr<EventEngine::DNSResolver> event_engine_resolver);+  ~EventEngineDNSRequestWrapper() override;++  // Note that thread safety cannot be analyzed due to this being invoked from+  // OrphanablePtr<>, and there's no way to pass the lock annotation through+  // there.+  void Orphan() override ABSL_NO_THREAD_SAFETY_ANALYSIS;++  void OnHostnameResolved(+      absl::StatusOr<std::vector<EventEngine::ResolvedAddress>> addresses);+  void OnSRVResolved(+      std::string srv_host,+      absl::StatusOr<std::vector<EventEngine::DNSResolver::SRVRecord>>+          srv_records);+  void OnBalancerHostnamesResolved(+      std::string authority,+      absl::StatusOr<std::vector<EventEngine::ResolvedAddress>> addresses);+  void OnTXTResolved(absl::StatusOr<std::string> service_config);++  // Returns a Result if resolution is complete.+  // callers must release the lock and call OnRequestComplete if a Result is+  // returned. This is because OnRequestComplete may Orphan the resolver, which+  // requires taking the lock.+  absl::optional<grpc_core::Resolver::Result> OnResolvedLocked()+      ABSL_EXCLUSIVE_LOCKS_REQUIRED(on_resolved_mu_);++ private:+  // Helper method for generating the combined resolution status error+  absl::Status GetResolutionFailureErrorMessageLocked()+      ABSL_EXCLUSIVE_LOCKS_REQUIRED(on_resolved_mu_);+  // Helper method to populate server addresses on resolver result.+  void MaybePopulateAddressesLocked(grpc_core::Resolver::Result& result)+      ABSL_EXCLUSIVE_LOCKS_REQUIRED(on_resolved_mu_);+  // Helper method to populate balancer addresses on resolver result.+  void MaybePopulateBalancerAddressesLocked(grpc_core::Resolver::Result& result)+      ABSL_EXCLUSIVE_LOCKS_REQUIRED(on_resolved_mu_);+  // Helper method to populate service config on resolver result.+  void MaybePopulateServiceConfigLocked(grpc_core::Resolver::Result& result)+      ABSL_EXCLUSIVE_LOCKS_REQUIRED(on_resolved_mu_);+  // Convert empty results into resolution errors.+  //+  // TODO(roth): We should someday separate empty results (NXDOMAIN) from actual+  // DNS resolution errors. For now, they are treated the same so this resolver+  // behaves similarly to the old c-ares resolver.+  void NormalizeEmptyResultsToErrorsLocked()+      ABSL_EXCLUSIVE_LOCKS_REQUIRED(on_resolved_mu_);++  RefCountedPtr<EventEngineClientChannelDNSResolver> resolver_;+  Mutex on_resolved_mu_;+  // Lookup callbacks+  absl::optional<EventEngine::DNSResolver::LookupTaskHandle> hostname_handle_+      ABSL_GUARDED_BY(on_resolved_mu_);+  absl::optional<EventEngine::DNSResolver::LookupTaskHandle> srv_handle_+      ABSL_GUARDED_BY(on_resolved_mu_);+  absl::optional<EventEngine::DNSResolver::LookupTaskHandle> txt_handle_+      ABSL_GUARDED_BY(on_resolved_mu_);+  LookupTaskHandleSet balancer_hostname_handles_+      ABSL_GUARDED_BY(on_resolved_mu_);+  // Output fields from requests.+  absl::StatusOr<std::vector<EventEngine::ResolvedAddress>> addresses_+      ABSL_GUARDED_BY(on_resolved_mu_);+  absl::StatusOr<grpc_core::ServerAddressList> balancer_addresses_+      ABSL_GUARDED_BY(on_resolved_mu_);+  absl::StatusOr<std::string> service_config_json_+      ABSL_GUARDED_BY(on_resolved_mu_);+  // Other internal state+  size_t number_of_balancer_hostnames_resolved_+      ABSL_GUARDED_BY(on_resolved_mu_) = 0;+  bool orphaned_ ABSL_GUARDED_BY(on_resolved_mu_) = false;+  std::unique_ptr<EventEngine::DNSResolver> event_engine_resolver_;+};++// ----------------------------------------------------------------------------+// EventEngineClientChannelDNSResolver+// ----------------------------------------------------------------------------+class EventEngineClientChannelDNSResolver : public grpc_core::PollingResolver {+ public:+  EventEngineClientChannelDNSResolver(ResolverArgs args,+                                      Duration min_time_between_resolutions);+  OrphanablePtr<Orphanable> StartRequest() override;++ private:+  friend class EventEngineDNSRequestWrapper;++  /// whether to request the service config+  const bool request_service_config_;+  // whether or not to enable SRV DNS queries+  const bool enable_srv_queries_;+  // timeout in milliseconds for active DNS queries+  EventEngine::Duration query_timeout_ms_;+  std::shared_ptr<EventEngine> event_engine_;+};++EventEngineClientChannelDNSResolver::EventEngineClientChannelDNSResolver(+    ResolverArgs args, Duration min_time_between_resolutions)+    : PollingResolver(std::move(args), min_time_between_resolutions,+                      BackOff::Options()+                          .set_initial_backoff(Duration::Milliseconds(+                              GRPC_DNS_INITIAL_CONNECT_BACKOFF_SECONDS * 1000))+                          .set_multiplier(GRPC_DNS_RECONNECT_BACKOFF_MULTIPLIER)+                          .set_jitter(GRPC_DNS_RECONNECT_JITTER)+                          .set_max_backoff(Duration::Milliseconds(+                              GRPC_DNS_RECONNECT_MAX_BACKOFF_SECONDS * 1000)),+                      &grpc_event_engine_dns_trace),+      request_service_config_(+          !channel_args()+               .GetBool(GRPC_ARG_SERVICE_CONFIG_DISABLE_RESOLUTION)+               .value_or(true)),+      enable_srv_queries_(channel_args()+                              .GetBool(GRPC_ARG_DNS_ENABLE_SRV_QUERIES)+                              .value_or(false)),+      // TODO(yijiem): decide if the ares channel arg timeout should be reused.+      query_timeout_ms_(std::chrono::milliseconds(+          std::max(0, channel_args()+                          .GetInt(GRPC_ARG_DNS_ARES_QUERY_TIMEOUT_MS)+                          .value_or(GRPC_DNS_DEFAULT_QUERY_TIMEOUT_MS)))),+      event_engine_(channel_args().GetObjectRef<EventEngine>()) {}++OrphanablePtr<Orphanable> EventEngineClientChannelDNSResolver::StartRequest() {+  return MakeOrphanable<EventEngineDNSRequestWrapper>(+      Ref(DEBUG_LOCATION, ""dns-resolving""),+      event_engine_->GetDNSResolver({/*dns_server=*/authority()}));+}++// ----------------------------------------------------------------------------+// EventEngineDNSRequestWrapper definition+// ----------------------------------------------------------------------------++EventEngineDNSRequestWrapper::EventEngineDNSRequestWrapper(+    RefCountedPtr<EventEngineClientChannelDNSResolver> resolver,+    std::unique_ptr<EventEngine::DNSResolver> event_engine_resolver)+    : resolver_(std::move(resolver)),+      event_engine_resolver_(std::move(event_engine_resolver)) {+  // Locking to prevent completion before all records are queried+  MutexLock lock(&on_resolved_mu_);+  hostname_handle_ = event_engine_resolver_->LookupHostname(+      absl::bind_front(&EventEngineDNSRequestWrapper::OnHostnameResolved,+                       Ref(DEBUG_LOCATION, ""OnHostnameResolved"")),+      resolver_->name_to_resolve(), grpc_core::kDefaultSecurePort,+      resolver_->query_timeout_ms_);+  GRPC_EVENT_ENGINE_DNS_TRACE(+      ""DNSResolver::%p Started resolving hostname. Handle::%s"", resolver_.get(),+      HandleToString(*hostname_handle_).c_str());+  if (resolver_->enable_srv_queries_) {+    srv_handle_ = event_engine_resolver_->LookupSRV(+        absl::bind_front(&EventEngineDNSRequestWrapper::OnSRVResolved,+                         Ref(DEBUG_LOCATION, ""OnSRVResolved""),+                         resolver_->name_to_resolve()),+        resolver_->name_to_resolve(), resolver_->query_timeout_ms_);+    GRPC_EVENT_ENGINE_DNS_TRACE(+        ""DNSResolver::%p Started resolving SRV. Handle::%s"", resolver_.get(),+        HandleToString(*srv_handle_).c_str());+  }+  if (resolver_->request_service_config_) {+    txt_handle_ = event_engine_resolver_->LookupTXT(+        absl::bind_front(&EventEngineDNSRequestWrapper::OnTXTResolved,+                         Ref(DEBUG_LOCATION, ""OnTXTResolved"")),+        resolver_->name_to_resolve(), resolver_->query_timeout_ms_);+    GRPC_EVENT_ENGINE_DNS_TRACE(+        ""DNSResolver::%p Started resolving TXT. Handle::%s"", resolver_.get(),+        HandleToString(*txt_handle_).c_str());+  }+}++EventEngineDNSRequestWrapper::~EventEngineDNSRequestWrapper() {+  resolver_.reset(DEBUG_LOCATION, ""dns-resolving"");+}++void EventEngineDNSRequestWrapper::Orphan() {+  {+    MutexLock lock(&on_resolved_mu_);+    orphaned_ = true;+    // Event if cancellation fails here, OnResolvedLocked will return early, and+    // the resolver will never see a completed request.+    if (hostname_handle_.has_value()) {+      event_engine_resolver_->CancelLookup(*hostname_handle_);+    }+    if (srv_handle_.has_value()) {+      event_engine_resolver_->CancelLookup(*srv_handle_);+    }+    for (const auto& handle : balancer_hostname_handles_) {+      event_engine_resolver_->CancelLookup(handle);+    }+    if (txt_handle_.has_value()) {+      event_engine_resolver_->CancelLookup(*txt_handle_);+    }+  }+  Unref(DEBUG_LOCATION, ""Orphan"");+}++void EventEngineDNSRequestWrapper::OnHostnameResolved(+    absl::StatusOr<std::vector<EventEngine::ResolvedAddress>> addresses) {+  absl::optional<grpc_core::Resolver::Result> result;+  {+    MutexLock lock(&on_resolved_mu_);+    if (orphaned_) return;+    hostname_handle_.reset();+    addresses_ = addresses;+    result = OnResolvedLocked();+  }+  if (result.has_value()) {+    resolver_->OnRequestComplete(std::move(*result));+  }+}++void EventEngineDNSRequestWrapper::OnSRVResolved(+    std::string srv_host,+    absl::StatusOr<std::vector<EventEngine::DNSResolver::SRVRecord>>+        srv_records) {+  absl::optional<grpc_core::Resolver::Result> result;+  {+    MutexLock lock(&on_resolved_mu_);+    if (orphaned_) return;+    srv_handle_.reset();+    if (srv_records.ok()) {+      balancer_addresses_ = grpc_core::ServerAddressList();+      // Do a subsequent hostname query if SRV records were returned+      for (const auto& srv_record : *srv_records) {+        balancer_hostname_handles_.insert(+            event_engine_resolver_->LookupHostname(+                absl::bind_front(+                    &EventEngineDNSRequestWrapper::OnBalancerHostnamesResolved,+                    Ref(DEBUG_LOCATION, ""OnBalancerHostnamesResolved""),+                    srv_host),+                srv_record.host, std::to_string(srv_record.port),+                resolver_->query_timeout_ms_));+        GRPC_EVENT_ENGINE_DNS_TRACE(+            ""DNSResolver::%p Started resolving balancer hostname %s:%d"",+            resolver_.get(), srv_record.host.c_str(), srv_record.port);+      }+      return;+    }+    // An error has occurred, finish resolving.+    balancer_addresses_ = srv_records.status();+    result = OnResolvedLocked();+  }+  if (result.has_value()) {+    resolver_->OnRequestComplete(std::move(*result));+  }+}++void EventEngineDNSRequestWrapper::OnBalancerHostnamesResolved(+    std::string authority,+    absl::StatusOr<std::vector<EventEngine::ResolvedAddress>>+        new_balancer_addresses) {+  absl::optional<grpc_core::Resolver::Result> result;+  {+    MutexLock lock(&on_resolved_mu_);+    if (orphaned_) return;+    ++number_of_balancer_hostnames_resolved_;+    if (new_balancer_addresses.ok()) {+      if (!balancer_addresses_.ok()) {+        GRPC_EVENT_ENGINE_DNS_TRACE(+            ""DNSResolver::%p previous balancer hostname lookup error, ignoring ""+            ""%zu found hostnames."",+            this, new_balancer_addresses->size());+      }+      balancer_addresses_->reserve(balancer_addresses_->size() ++                                   new_balancer_addresses->size());+      auto srv_channel_args =+          resolver_->channel_args().Set(GRPC_ARG_DEFAULT_AUTHORITY, authority);+      for (const auto& addr : *new_balancer_addresses) {+        balancer_addresses_->emplace_back(CreateGRPCResolvedAddress(addr),+                                          srv_channel_args);+      }+    } else {+      auto tmp_status = balancer_addresses_.status();+      grpc_core::StatusAddChild(&tmp_status, new_balancer_addresses.status());+      balancer_addresses_ = tmp_status;+    }+    result = OnResolvedLocked();+  }+  if (result.has_value()) {+    resolver_->OnRequestComplete(std::move(*result));+  }+}++void EventEngineDNSRequestWrapper::OnTXTResolved(+    absl::StatusOr<std::string> service_config) {+  absl::optional<grpc_core::Resolver::Result> result;+  {+    MutexLock lock(&on_resolved_mu_);+    if (orphaned_) return;+    GPR_ASSERT(txt_handle_.has_value());+    txt_handle_.reset();+    service_config_json_ = service_config;+    result = OnResolvedLocked();+  }+  if (result.has_value()) {+    resolver_->OnRequestComplete(std::move(*result));+  }+}++absl::Status+EventEngineDNSRequestWrapper::GetResolutionFailureErrorMessageLocked() {+  std::string error_msg =+      absl::StrFormat(""resolver:%p dns resolution failed."", this);+  if (!addresses_.ok()) {+    absl::StrAppend(&error_msg, "" Hostname lookup error: "",+                    grpc_core::StatusToString(addresses_.status()));+  }+  if (!balancer_addresses_.ok()) {+    absl::StrAppend(&error_msg, "" SRV lookup error: "",+                    grpc_core::StatusToString(balancer_addresses_.status()));+  }+  if (!service_config_json_.ok()) {+    absl::StrAppend(&error_msg, "" TXT lookup error: "",+                    grpc_core::StatusToString(service_config_json_.status()));+  }+  auto status = grpc_core::StatusCreate(+      absl::StatusCode::kUnavailable, error_msg, DEBUG_LOCATION, /*children=*/+      {addresses_.status(), balancer_addresses_.status(),+       service_config_json_.status()});+  return status;+}++void EventEngineDNSRequestWrapper::MaybePopulateAddressesLocked(+    grpc_core::Resolver::Result& result) {","That guidance is a bit controversial, and I'm personally not a fan.  I think it's very useful to be able to tell from the call site whether a parameter may be modified by whether it's a pointer or not, and that's the convention we use in the most of the gRPC codebase.  But I won't insist.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32632,1152601499,2023-03-30T00:01:29Z,src/core/ext/filters/client_channel/resolver/dns/event_engine/service_config_helper.cc,"@@ -0,0 +1,132 @@+// Copyright 2023 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+#include <grpc/support/port_platform.h>++#include ""src/core/ext/filters/client_channel/resolver/dns/event_engine/service_config_helper.h""++#include <stdio.h>+#include <stdlib.h>++#include <algorithm>+#include <map>+#include <utility>+#include <vector>++#include ""absl/status/status.h""+#include ""absl/status/statusor.h""+#include ""absl/strings/string_view.h""++#include ""src/core/lib/gprpp/debug_location.h""+#include ""src/core/lib/gprpp/status_helper.h""+#include ""src/core/lib/iomgr/gethostname.h""+#include ""src/core/lib/json/json.h""++namespace grpc_event_engine {+namespace experimental {++namespace {+using ::grpc_core::Json;++bool ValueInJsonArray(const Json::Array& array, const char* value) {+  for (const Json& entry : array) {+    if (entry.type() == Json::Type::STRING && entry.string_value() == value) {+      return true;+    }+  }+  return false;+}++}  // namespace++absl::StatusOr<std::string> ChooseServiceConfig(",What refactoring would be required here?  It seems like it's basically a drop-in replacement.  The only real difference is that it returns a `StatusOr<>` instead of having a `grpc_error_handle` output parameter.,X
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/32632,1152611964,2023-03-30T00:18:26Z,src/core/ext/filters/client_channel/resolver/dns/event_engine/service_config_helper.cc,"@@ -0,0 +1,132 @@+// Copyright 2023 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+#include <grpc/support/port_platform.h>++#include ""src/core/ext/filters/client_channel/resolver/dns/event_engine/service_config_helper.h""++#include <stdio.h>+#include <stdlib.h>++#include <algorithm>+#include <map>+#include <utility>+#include <vector>++#include ""absl/status/status.h""+#include ""absl/status/statusor.h""+#include ""absl/strings/string_view.h""++#include ""src/core/lib/gprpp/debug_location.h""+#include ""src/core/lib/gprpp/status_helper.h""+#include ""src/core/lib/iomgr/gethostname.h""+#include ""src/core/lib/json/json.h""++namespace grpc_event_engine {+namespace experimental {++namespace {+using ::grpc_core::Json;++bool ValueInJsonArray(const Json::Array& array, const char* value) {+  for (const Json& entry : array) {+    if (entry.type() == Json::Type::STRING && entry.string_value() == value) {+      return true;+    }+  }+  return false;+}++}  // namespace++absl::StatusOr<std::string> ChooseServiceConfig(","The naming tests require changes as well, since the Json Object Loader treats ints-in-strings differently. However, since we will want to run the same tests with the EventEngine resolver, I went ahead and reused the same implementation in both resolvers and updated the tests.",
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/32632,1152613250,2023-03-30T00:21:37Z,src/core/ext/filters/client_channel/resolver/dns/event_engine/event_engine_client_channel_resolver.cc,"@@ -0,0 +1,535 @@+// Copyright 2023 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+#include <grpc/support/port_platform.h>++#include ""src/core/ext/filters/client_channel/resolver/dns/event_engine/event_engine_client_channel_resolver.h""++#include <stddef.h>+#include <stdint.h>++#include <algorithm>+#include <chrono>+#include <initializer_list>+#include <memory>+#include <string>+#include <utility>+#include <vector>++#include ""absl/base/thread_annotations.h""+#include ""absl/container/flat_hash_set.h""+#include ""absl/functional/bind_front.h""+#include ""absl/status/status.h""+#include ""absl/status/statusor.h""+#include ""absl/strings/str_cat.h""+#include ""absl/strings/str_format.h""+#include ""absl/strings/strip.h""+#include ""absl/types/optional.h""++#include <grpc/event_engine/event_engine.h>+#include <grpc/grpc.h>+#include <grpc/support/log.h>++#include ""src/core/ext/filters/client_channel/lb_policy/grpclb/grpclb_balancer_addresses.h""+#include ""src/core/ext/filters/client_channel/resolver/dns/event_engine/service_config_helper.h""+#include ""src/core/ext/filters/client_channel/resolver/polling_resolver.h""+#include ""src/core/lib/backoff/backoff.h""+#include ""src/core/lib/channel/channel_args.h""+#include ""src/core/lib/debug/trace.h""+#include ""src/core/lib/event_engine/handle_containers.h""+#include ""src/core/lib/event_engine/resolved_address_internal.h""+#include ""src/core/lib/event_engine/trace.h""+#include ""src/core/lib/event_engine/utils.h""+#include ""src/core/lib/gprpp/debug_location.h""+#include ""src/core/lib/gprpp/ref_counted_ptr.h""+#include ""src/core/lib/gprpp/status_helper.h""+#include ""src/core/lib/gprpp/sync.h""+#include ""src/core/lib/gprpp/time.h""+#include ""src/core/lib/iomgr/resolve_address.h""+#include ""src/core/lib/resolver/resolver.h""+#include ""src/core/lib/resolver/resolver_factory.h""+#include ""src/core/lib/resolver/server_address.h""+#include ""src/core/lib/service_config/service_config.h""+#include ""src/core/lib/service_config/service_config_impl.h""++// IWYU pragma: no_include <ratio>++namespace grpc_event_engine {+namespace experimental {++namespace {++#define GRPC_DNS_INITIAL_CONNECT_BACKOFF_SECONDS 1+#define GRPC_DNS_RECONNECT_BACKOFF_MULTIPLIER 1.6+#define GRPC_DNS_RECONNECT_MAX_BACKOFF_SECONDS 120+#define GRPC_DNS_RECONNECT_JITTER 0.2+#define GRPC_DNS_DEFAULT_QUERY_TIMEOUT_MS 120000++using grpc_core::BackOff;+using grpc_core::Duration;+using grpc_core::InternallyRefCounted;+using grpc_core::MakeOrphanable;+using grpc_core::Mutex;+using grpc_core::MutexLock;+using grpc_core::Orphanable;+using grpc_core::OrphanablePtr;+using grpc_core::RefCountedPtr;+using grpc_core::ResolverArgs;++// ----------------------------------------------------------------------------+// EventEngineDNSRequestWrapper declaration+// ----------------------------------------------------------------------------+class EventEngineClientChannelDNSResolver;++class EventEngineDNSRequestWrapper+    : public InternallyRefCounted<EventEngineDNSRequestWrapper> {+ public:+  EventEngineDNSRequestWrapper(+      RefCountedPtr<EventEngineClientChannelDNSResolver> resolver,+      std::unique_ptr<EventEngine::DNSResolver> event_engine_resolver);+  ~EventEngineDNSRequestWrapper() override;++  // Note that thread safety cannot be analyzed due to this being invoked from+  // OrphanablePtr<>, and there's no way to pass the lock annotation through+  // there.+  void Orphan() override ABSL_NO_THREAD_SAFETY_ANALYSIS;++  void OnHostnameResolved(+      absl::StatusOr<std::vector<EventEngine::ResolvedAddress>> addresses);+  void OnSRVResolved(+      std::string srv_host,+      absl::StatusOr<std::vector<EventEngine::DNSResolver::SRVRecord>>+          srv_records);+  void OnBalancerHostnamesResolved(+      std::string authority,+      absl::StatusOr<std::vector<EventEngine::ResolvedAddress>> addresses);+  void OnTXTResolved(absl::StatusOr<std::string> service_config);++  // Returns a Result if resolution is complete.+  // callers must release the lock and call OnRequestComplete if a Result is+  // returned. This is because OnRequestComplete may Orphan the resolver, which+  // requires taking the lock.+  absl::optional<grpc_core::Resolver::Result> OnResolvedLocked()+      ABSL_EXCLUSIVE_LOCKS_REQUIRED(on_resolved_mu_);++ private:+  // Helper method for generating the combined resolution status error+  absl::Status GetResolutionFailureErrorMessageLocked()+      ABSL_EXCLUSIVE_LOCKS_REQUIRED(on_resolved_mu_);+  // Helper method to populate server addresses on resolver result.+  void MaybePopulateAddressesLocked(grpc_core::Resolver::Result& result)+      ABSL_EXCLUSIVE_LOCKS_REQUIRED(on_resolved_mu_);+  // Helper method to populate balancer addresses on resolver result.+  void MaybePopulateBalancerAddressesLocked(grpc_core::Resolver::Result& result)+      ABSL_EXCLUSIVE_LOCKS_REQUIRED(on_resolved_mu_);+  // Helper method to populate service config on resolver result.+  void MaybePopulateServiceConfigLocked(grpc_core::Resolver::Result& result)+      ABSL_EXCLUSIVE_LOCKS_REQUIRED(on_resolved_mu_);+  // Convert empty results into resolution errors.+  //+  // TODO(roth): We should someday separate empty results (NXDOMAIN) from actual+  // DNS resolution errors. For now, they are treated the same so this resolver+  // behaves similarly to the old c-ares resolver.+  void NormalizeEmptyResultsToErrorsLocked()+      ABSL_EXCLUSIVE_LOCKS_REQUIRED(on_resolved_mu_);++  RefCountedPtr<EventEngineClientChannelDNSResolver> resolver_;+  Mutex on_resolved_mu_;+  // Lookup callbacks+  absl::optional<EventEngine::DNSResolver::LookupTaskHandle> hostname_handle_+      ABSL_GUARDED_BY(on_resolved_mu_);+  absl::optional<EventEngine::DNSResolver::LookupTaskHandle> srv_handle_+      ABSL_GUARDED_BY(on_resolved_mu_);+  absl::optional<EventEngine::DNSResolver::LookupTaskHandle> txt_handle_+      ABSL_GUARDED_BY(on_resolved_mu_);+  LookupTaskHandleSet balancer_hostname_handles_+      ABSL_GUARDED_BY(on_resolved_mu_);+  // Output fields from requests.+  absl::StatusOr<std::vector<EventEngine::ResolvedAddress>> addresses_+      ABSL_GUARDED_BY(on_resolved_mu_);+  absl::StatusOr<grpc_core::ServerAddressList> balancer_addresses_+      ABSL_GUARDED_BY(on_resolved_mu_);+  absl::StatusOr<std::string> service_config_json_+      ABSL_GUARDED_BY(on_resolved_mu_);+  // Other internal state+  size_t number_of_balancer_hostnames_resolved_+      ABSL_GUARDED_BY(on_resolved_mu_) = 0;+  bool orphaned_ ABSL_GUARDED_BY(on_resolved_mu_) = false;+  std::unique_ptr<EventEngine::DNSResolver> event_engine_resolver_;+};++// ----------------------------------------------------------------------------+// EventEngineClientChannelDNSResolver+// ----------------------------------------------------------------------------+class EventEngineClientChannelDNSResolver : public grpc_core::PollingResolver {+ public:+  EventEngineClientChannelDNSResolver(ResolverArgs args,+                                      Duration min_time_between_resolutions);+  OrphanablePtr<Orphanable> StartRequest() override;++ private:+  friend class EventEngineDNSRequestWrapper;++  /// whether to request the service config+  const bool request_service_config_;+  // whether or not to enable SRV DNS queries+  const bool enable_srv_queries_;+  // timeout in milliseconds for active DNS queries+  EventEngine::Duration query_timeout_ms_;+  std::shared_ptr<EventEngine> event_engine_;+};++EventEngineClientChannelDNSResolver::EventEngineClientChannelDNSResolver(+    ResolverArgs args, Duration min_time_between_resolutions)+    : PollingResolver(std::move(args), min_time_between_resolutions,+                      BackOff::Options()+                          .set_initial_backoff(Duration::Milliseconds(+                              GRPC_DNS_INITIAL_CONNECT_BACKOFF_SECONDS * 1000))+                          .set_multiplier(GRPC_DNS_RECONNECT_BACKOFF_MULTIPLIER)+                          .set_jitter(GRPC_DNS_RECONNECT_JITTER)+                          .set_max_backoff(Duration::Milliseconds(+                              GRPC_DNS_RECONNECT_MAX_BACKOFF_SECONDS * 1000)),+                      &grpc_event_engine_dns_trace),+      request_service_config_(+          !channel_args()+               .GetBool(GRPC_ARG_SERVICE_CONFIG_DISABLE_RESOLUTION)+               .value_or(true)),+      enable_srv_queries_(channel_args()+                              .GetBool(GRPC_ARG_DNS_ENABLE_SRV_QUERIES)+                              .value_or(false)),+      // TODO(yijiem): decide if the ares channel arg timeout should be reused.+      query_timeout_ms_(std::chrono::milliseconds(+          std::max(0, channel_args()+                          .GetInt(GRPC_ARG_DNS_ARES_QUERY_TIMEOUT_MS)+                          .value_or(GRPC_DNS_DEFAULT_QUERY_TIMEOUT_MS)))),+      event_engine_(channel_args().GetObjectRef<EventEngine>()) {}++OrphanablePtr<Orphanable> EventEngineClientChannelDNSResolver::StartRequest() {+  return MakeOrphanable<EventEngineDNSRequestWrapper>(+      Ref(DEBUG_LOCATION, ""dns-resolving""),+      event_engine_->GetDNSResolver({/*dns_server=*/authority()}));+}++// ----------------------------------------------------------------------------+// EventEngineDNSRequestWrapper definition+// ----------------------------------------------------------------------------++EventEngineDNSRequestWrapper::EventEngineDNSRequestWrapper(+    RefCountedPtr<EventEngineClientChannelDNSResolver> resolver,+    std::unique_ptr<EventEngine::DNSResolver> event_engine_resolver)+    : resolver_(std::move(resolver)),+      event_engine_resolver_(std::move(event_engine_resolver)) {+  // Locking to prevent completion before all records are queried+  MutexLock lock(&on_resolved_mu_);+  hostname_handle_ = event_engine_resolver_->LookupHostname(+      absl::bind_front(&EventEngineDNSRequestWrapper::OnHostnameResolved,+                       Ref(DEBUG_LOCATION, ""OnHostnameResolved"")),+      resolver_->name_to_resolve(), grpc_core::kDefaultSecurePort,+      resolver_->query_timeout_ms_);+  GRPC_EVENT_ENGINE_DNS_TRACE(+      ""DNSResolver::%p Started resolving hostname. Handle::%s"", resolver_.get(),+      HandleToString(*hostname_handle_).c_str());+  if (resolver_->enable_srv_queries_) {+    srv_handle_ = event_engine_resolver_->LookupSRV(+        absl::bind_front(&EventEngineDNSRequestWrapper::OnSRVResolved,+                         Ref(DEBUG_LOCATION, ""OnSRVResolved""),+                         resolver_->name_to_resolve()),+        resolver_->name_to_resolve(), resolver_->query_timeout_ms_);+    GRPC_EVENT_ENGINE_DNS_TRACE(+        ""DNSResolver::%p Started resolving SRV. Handle::%s"", resolver_.get(),+        HandleToString(*srv_handle_).c_str());+  }+  if (resolver_->request_service_config_) {+    txt_handle_ = event_engine_resolver_->LookupTXT(+        absl::bind_front(&EventEngineDNSRequestWrapper::OnTXTResolved,+                         Ref(DEBUG_LOCATION, ""OnTXTResolved"")),+        resolver_->name_to_resolve(), resolver_->query_timeout_ms_);+    GRPC_EVENT_ENGINE_DNS_TRACE(+        ""DNSResolver::%p Started resolving TXT. Handle::%s"", resolver_.get(),+        HandleToString(*txt_handle_).c_str());+  }+}++EventEngineDNSRequestWrapper::~EventEngineDNSRequestWrapper() {+  resolver_.reset(DEBUG_LOCATION, ""dns-resolving"");+}++void EventEngineDNSRequestWrapper::Orphan() {+  {+    MutexLock lock(&on_resolved_mu_);+    orphaned_ = true;+    // Event if cancellation fails here, OnResolvedLocked will return early, and+    // the resolver will never see a completed request.+    if (hostname_handle_.has_value()) {+      event_engine_resolver_->CancelLookup(*hostname_handle_);+    }+    if (srv_handle_.has_value()) {+      event_engine_resolver_->CancelLookup(*srv_handle_);+    }+    for (const auto& handle : balancer_hostname_handles_) {+      event_engine_resolver_->CancelLookup(handle);+    }+    if (txt_handle_.has_value()) {+      event_engine_resolver_->CancelLookup(*txt_handle_);+    }+  }+  Unref(DEBUG_LOCATION, ""Orphan"");+}++void EventEngineDNSRequestWrapper::OnHostnameResolved(+    absl::StatusOr<std::vector<EventEngine::ResolvedAddress>> addresses) {+  absl::optional<grpc_core::Resolver::Result> result;+  {+    MutexLock lock(&on_resolved_mu_);+    if (orphaned_) return;+    hostname_handle_.reset();+    addresses_ = addresses;+    result = OnResolvedLocked();+  }+  if (result.has_value()) {+    resolver_->OnRequestComplete(std::move(*result));+  }+}++void EventEngineDNSRequestWrapper::OnSRVResolved(+    std::string srv_host,+    absl::StatusOr<std::vector<EventEngine::DNSResolver::SRVRecord>>+        srv_records) {+  absl::optional<grpc_core::Resolver::Result> result;+  {+    MutexLock lock(&on_resolved_mu_);+    if (orphaned_) return;+    srv_handle_.reset();+    if (srv_records.ok()) {+      balancer_addresses_ = grpc_core::ServerAddressList();+      // Do a subsequent hostname query if SRV records were returned+      for (const auto& srv_record : *srv_records) {+        balancer_hostname_handles_.insert(+            event_engine_resolver_->LookupHostname(+                absl::bind_front(+                    &EventEngineDNSRequestWrapper::OnBalancerHostnamesResolved,+                    Ref(DEBUG_LOCATION, ""OnBalancerHostnamesResolved""),+                    srv_host),","The `tests/cpp/naming` tests are not. I chatted with @yijiem about that today, we have a blind spot here, and we should resolve it after this client channel resolver lands since he'll be integrating his lower-level resolver implementation against it. Similarly, we do not appear to test the case when resolving multiple SRV records, the first query fails, but some subsequent query gets results. That may be harder to control for in a test, but it is a blind spot.",
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/32632,1152632364,2023-03-30T01:08:39Z,src/core/ext/filters/client_channel/resolver/dns/event_engine/event_engine_client_channel_resolver.cc,"@@ -0,0 +1,535 @@+// Copyright 2023 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+#include <grpc/support/port_platform.h>++#include ""src/core/ext/filters/client_channel/resolver/dns/event_engine/event_engine_client_channel_resolver.h""++#include <stddef.h>+#include <stdint.h>++#include <algorithm>+#include <chrono>+#include <initializer_list>+#include <memory>+#include <string>+#include <utility>+#include <vector>++#include ""absl/base/thread_annotations.h""+#include ""absl/container/flat_hash_set.h""+#include ""absl/functional/bind_front.h""+#include ""absl/status/status.h""+#include ""absl/status/statusor.h""+#include ""absl/strings/str_cat.h""+#include ""absl/strings/str_format.h""+#include ""absl/strings/strip.h""+#include ""absl/types/optional.h""++#include <grpc/event_engine/event_engine.h>+#include <grpc/grpc.h>+#include <grpc/support/log.h>++#include ""src/core/ext/filters/client_channel/lb_policy/grpclb/grpclb_balancer_addresses.h""+#include ""src/core/ext/filters/client_channel/resolver/dns/event_engine/service_config_helper.h""+#include ""src/core/ext/filters/client_channel/resolver/polling_resolver.h""+#include ""src/core/lib/backoff/backoff.h""+#include ""src/core/lib/channel/channel_args.h""+#include ""src/core/lib/debug/trace.h""+#include ""src/core/lib/event_engine/handle_containers.h""+#include ""src/core/lib/event_engine/resolved_address_internal.h""+#include ""src/core/lib/event_engine/trace.h""+#include ""src/core/lib/event_engine/utils.h""+#include ""src/core/lib/gprpp/debug_location.h""+#include ""src/core/lib/gprpp/ref_counted_ptr.h""+#include ""src/core/lib/gprpp/status_helper.h""+#include ""src/core/lib/gprpp/sync.h""+#include ""src/core/lib/gprpp/time.h""+#include ""src/core/lib/iomgr/resolve_address.h""+#include ""src/core/lib/resolver/resolver.h""+#include ""src/core/lib/resolver/resolver_factory.h""+#include ""src/core/lib/resolver/server_address.h""+#include ""src/core/lib/service_config/service_config.h""+#include ""src/core/lib/service_config/service_config_impl.h""++// IWYU pragma: no_include <ratio>++namespace grpc_event_engine {+namespace experimental {++namespace {++#define GRPC_DNS_INITIAL_CONNECT_BACKOFF_SECONDS 1+#define GRPC_DNS_RECONNECT_BACKOFF_MULTIPLIER 1.6+#define GRPC_DNS_RECONNECT_MAX_BACKOFF_SECONDS 120+#define GRPC_DNS_RECONNECT_JITTER 0.2+#define GRPC_DNS_DEFAULT_QUERY_TIMEOUT_MS 120000++using grpc_core::BackOff;+using grpc_core::Duration;+using grpc_core::InternallyRefCounted;+using grpc_core::MakeOrphanable;+using grpc_core::Mutex;+using grpc_core::MutexLock;+using grpc_core::Orphanable;+using grpc_core::OrphanablePtr;+using grpc_core::RefCountedPtr;+using grpc_core::ResolverArgs;++// ----------------------------------------------------------------------------+// EventEngineDNSRequestWrapper declaration+// ----------------------------------------------------------------------------+class EventEngineClientChannelDNSResolver;++class EventEngineDNSRequestWrapper+    : public InternallyRefCounted<EventEngineDNSRequestWrapper> {+ public:+  EventEngineDNSRequestWrapper(+      RefCountedPtr<EventEngineClientChannelDNSResolver> resolver,+      std::unique_ptr<EventEngine::DNSResolver> event_engine_resolver);+  ~EventEngineDNSRequestWrapper() override;++  // Note that thread safety cannot be analyzed due to this being invoked from+  // OrphanablePtr<>, and there's no way to pass the lock annotation through+  // there.+  void Orphan() override ABSL_NO_THREAD_SAFETY_ANALYSIS;++  void OnHostnameResolved(+      absl::StatusOr<std::vector<EventEngine::ResolvedAddress>> addresses);+  void OnSRVResolved(+      std::string srv_host,+      absl::StatusOr<std::vector<EventEngine::DNSResolver::SRVRecord>>+          srv_records);+  void OnBalancerHostnamesResolved(+      std::string authority,+      absl::StatusOr<std::vector<EventEngine::ResolvedAddress>> addresses);+  void OnTXTResolved(absl::StatusOr<std::string> service_config);++  // Returns a Result if resolution is complete.+  // callers must release the lock and call OnRequestComplete if a Result is+  // returned. This is because OnRequestComplete may Orphan the resolver, which+  // requires taking the lock.+  absl::optional<grpc_core::Resolver::Result> OnResolvedLocked()+      ABSL_EXCLUSIVE_LOCKS_REQUIRED(on_resolved_mu_);++ private:+  // Helper method for generating the combined resolution status error+  absl::Status GetResolutionFailureErrorMessageLocked()+      ABSL_EXCLUSIVE_LOCKS_REQUIRED(on_resolved_mu_);+  // Helper method to populate server addresses on resolver result.+  void MaybePopulateAddressesLocked(grpc_core::Resolver::Result& result)+      ABSL_EXCLUSIVE_LOCKS_REQUIRED(on_resolved_mu_);+  // Helper method to populate balancer addresses on resolver result.+  void MaybePopulateBalancerAddressesLocked(grpc_core::Resolver::Result& result)+      ABSL_EXCLUSIVE_LOCKS_REQUIRED(on_resolved_mu_);+  // Helper method to populate service config on resolver result.+  void MaybePopulateServiceConfigLocked(grpc_core::Resolver::Result& result)+      ABSL_EXCLUSIVE_LOCKS_REQUIRED(on_resolved_mu_);+  // Convert empty results into resolution errors.+  //+  // TODO(roth): We should someday separate empty results (NXDOMAIN) from actual+  // DNS resolution errors. For now, they are treated the same so this resolver+  // behaves similarly to the old c-ares resolver.+  void NormalizeEmptyResultsToErrorsLocked()+      ABSL_EXCLUSIVE_LOCKS_REQUIRED(on_resolved_mu_);++  RefCountedPtr<EventEngineClientChannelDNSResolver> resolver_;+  Mutex on_resolved_mu_;+  // Lookup callbacks+  absl::optional<EventEngine::DNSResolver::LookupTaskHandle> hostname_handle_+      ABSL_GUARDED_BY(on_resolved_mu_);+  absl::optional<EventEngine::DNSResolver::LookupTaskHandle> srv_handle_+      ABSL_GUARDED_BY(on_resolved_mu_);+  absl::optional<EventEngine::DNSResolver::LookupTaskHandle> txt_handle_+      ABSL_GUARDED_BY(on_resolved_mu_);+  LookupTaskHandleSet balancer_hostname_handles_+      ABSL_GUARDED_BY(on_resolved_mu_);+  // Output fields from requests.+  absl::StatusOr<std::vector<EventEngine::ResolvedAddress>> addresses_+      ABSL_GUARDED_BY(on_resolved_mu_);+  absl::StatusOr<grpc_core::ServerAddressList> balancer_addresses_+      ABSL_GUARDED_BY(on_resolved_mu_);+  absl::StatusOr<std::string> service_config_json_+      ABSL_GUARDED_BY(on_resolved_mu_);+  // Other internal state+  size_t number_of_balancer_hostnames_resolved_+      ABSL_GUARDED_BY(on_resolved_mu_) = 0;+  bool orphaned_ ABSL_GUARDED_BY(on_resolved_mu_) = false;+  std::unique_ptr<EventEngine::DNSResolver> event_engine_resolver_;+};++// ----------------------------------------------------------------------------+// EventEngineClientChannelDNSResolver+// ----------------------------------------------------------------------------+class EventEngineClientChannelDNSResolver : public grpc_core::PollingResolver {+ public:+  EventEngineClientChannelDNSResolver(ResolverArgs args,+                                      Duration min_time_between_resolutions);+  OrphanablePtr<Orphanable> StartRequest() override;++ private:+  friend class EventEngineDNSRequestWrapper;++  /// whether to request the service config+  const bool request_service_config_;+  // whether or not to enable SRV DNS queries+  const bool enable_srv_queries_;+  // timeout in milliseconds for active DNS queries+  EventEngine::Duration query_timeout_ms_;+  std::shared_ptr<EventEngine> event_engine_;+};++EventEngineClientChannelDNSResolver::EventEngineClientChannelDNSResolver(+    ResolverArgs args, Duration min_time_between_resolutions)+    : PollingResolver(std::move(args), min_time_between_resolutions,+                      BackOff::Options()+                          .set_initial_backoff(Duration::Milliseconds(+                              GRPC_DNS_INITIAL_CONNECT_BACKOFF_SECONDS * 1000))+                          .set_multiplier(GRPC_DNS_RECONNECT_BACKOFF_MULTIPLIER)+                          .set_jitter(GRPC_DNS_RECONNECT_JITTER)+                          .set_max_backoff(Duration::Milliseconds(+                              GRPC_DNS_RECONNECT_MAX_BACKOFF_SECONDS * 1000)),+                      &grpc_event_engine_dns_trace),+      request_service_config_(+          !channel_args()+               .GetBool(GRPC_ARG_SERVICE_CONFIG_DISABLE_RESOLUTION)+               .value_or(true)),+      enable_srv_queries_(channel_args()+                              .GetBool(GRPC_ARG_DNS_ENABLE_SRV_QUERIES)+                              .value_or(false)),+      // TODO(yijiem): decide if the ares channel arg timeout should be reused.+      query_timeout_ms_(std::chrono::milliseconds(+          std::max(0, channel_args()+                          .GetInt(GRPC_ARG_DNS_ARES_QUERY_TIMEOUT_MS)+                          .value_or(GRPC_DNS_DEFAULT_QUERY_TIMEOUT_MS)))),+      event_engine_(channel_args().GetObjectRef<EventEngine>()) {}++OrphanablePtr<Orphanable> EventEngineClientChannelDNSResolver::StartRequest() {+  return MakeOrphanable<EventEngineDNSRequestWrapper>(+      Ref(DEBUG_LOCATION, ""dns-resolving""),+      event_engine_->GetDNSResolver({/*dns_server=*/authority()}));+}++// ----------------------------------------------------------------------------+// EventEngineDNSRequestWrapper definition+// ----------------------------------------------------------------------------++EventEngineDNSRequestWrapper::EventEngineDNSRequestWrapper(+    RefCountedPtr<EventEngineClientChannelDNSResolver> resolver,+    std::unique_ptr<EventEngine::DNSResolver> event_engine_resolver)+    : resolver_(std::move(resolver)),+      event_engine_resolver_(std::move(event_engine_resolver)) {+  // Locking to prevent completion before all records are queried+  MutexLock lock(&on_resolved_mu_);+  hostname_handle_ = event_engine_resolver_->LookupHostname(+      absl::bind_front(&EventEngineDNSRequestWrapper::OnHostnameResolved,+                       Ref(DEBUG_LOCATION, ""OnHostnameResolved"")),+      resolver_->name_to_resolve(), grpc_core::kDefaultSecurePort,+      resolver_->query_timeout_ms_);+  GRPC_EVENT_ENGINE_DNS_TRACE(+      ""DNSResolver::%p Started resolving hostname. Handle::%s"", resolver_.get(),+      HandleToString(*hostname_handle_).c_str());+  if (resolver_->enable_srv_queries_) {+    srv_handle_ = event_engine_resolver_->LookupSRV(+        absl::bind_front(&EventEngineDNSRequestWrapper::OnSRVResolved,+                         Ref(DEBUG_LOCATION, ""OnSRVResolved""),+                         resolver_->name_to_resolve()),+        resolver_->name_to_resolve(), resolver_->query_timeout_ms_);+    GRPC_EVENT_ENGINE_DNS_TRACE(+        ""DNSResolver::%p Started resolving SRV. Handle::%s"", resolver_.get(),+        HandleToString(*srv_handle_).c_str());+  }+  if (resolver_->request_service_config_) {+    txt_handle_ = event_engine_resolver_->LookupTXT(+        absl::bind_front(&EventEngineDNSRequestWrapper::OnTXTResolved,+                         Ref(DEBUG_LOCATION, ""OnTXTResolved"")),+        resolver_->name_to_resolve(), resolver_->query_timeout_ms_);+    GRPC_EVENT_ENGINE_DNS_TRACE(+        ""DNSResolver::%p Started resolving TXT. Handle::%s"", resolver_.get(),+        HandleToString(*txt_handle_).c_str());+  }+}++EventEngineDNSRequestWrapper::~EventEngineDNSRequestWrapper() {+  resolver_.reset(DEBUG_LOCATION, ""dns-resolving"");+}++void EventEngineDNSRequestWrapper::Orphan() {+  {+    MutexLock lock(&on_resolved_mu_);+    orphaned_ = true;+    // Event if cancellation fails here, OnResolvedLocked will return early, and+    // the resolver will never see a completed request.+    if (hostname_handle_.has_value()) {+      event_engine_resolver_->CancelLookup(*hostname_handle_);+    }+    if (srv_handle_.has_value()) {+      event_engine_resolver_->CancelLookup(*srv_handle_);+    }+    for (const auto& handle : balancer_hostname_handles_) {+      event_engine_resolver_->CancelLookup(handle);+    }+    if (txt_handle_.has_value()) {+      event_engine_resolver_->CancelLookup(*txt_handle_);+    }+  }+  Unref(DEBUG_LOCATION, ""Orphan"");+}++void EventEngineDNSRequestWrapper::OnHostnameResolved(+    absl::StatusOr<std::vector<EventEngine::ResolvedAddress>> addresses) {+  absl::optional<grpc_core::Resolver::Result> result;+  {+    MutexLock lock(&on_resolved_mu_);+    if (orphaned_) return;+    hostname_handle_.reset();+    addresses_ = addresses;+    result = OnResolvedLocked();+  }+  if (result.has_value()) {+    resolver_->OnRequestComplete(std::move(*result));+  }+}++void EventEngineDNSRequestWrapper::OnSRVResolved(+    std::string srv_host,+    absl::StatusOr<std::vector<EventEngine::DNSResolver::SRVRecord>>+        srv_records) {+  absl::optional<grpc_core::Resolver::Result> result;+  {+    MutexLock lock(&on_resolved_mu_);+    if (orphaned_) return;+    srv_handle_.reset();+    if (srv_records.ok()) {+      balancer_addresses_ = grpc_core::ServerAddressList();+      // Do a subsequent hostname query if SRV records were returned+      for (const auto& srv_record : *srv_records) {+        balancer_hostname_handles_.insert(+            event_engine_resolver_->LookupHostname(+                absl::bind_front(+                    &EventEngineDNSRequestWrapper::OnBalancerHostnamesResolved,+                    Ref(DEBUG_LOCATION, ""OnBalancerHostnamesResolved""),+                    srv_host),+                srv_record.host, std::to_string(srv_record.port),+                resolver_->query_timeout_ms_));+        GRPC_EVENT_ENGINE_DNS_TRACE(+            ""DNSResolver::%p Started resolving balancer hostname %s:%d"",+            resolver_.get(), srv_record.host.c_str(), srv_record.port);+      }+      return;+    }+    // An error has occurred, finish resolving.+    balancer_addresses_ = srv_records.status();+    result = OnResolvedLocked();+  }+  if (result.has_value()) {+    resolver_->OnRequestComplete(std::move(*result));+  }+}++void EventEngineDNSRequestWrapper::OnBalancerHostnamesResolved(+    std::string authority,+    absl::StatusOr<std::vector<EventEngine::ResolvedAddress>>+        new_balancer_addresses) {+  absl::optional<grpc_core::Resolver::Result> result;+  {+    MutexLock lock(&on_resolved_mu_);+    if (orphaned_) return;+    ++number_of_balancer_hostnames_resolved_;+    if (new_balancer_addresses.ok()) {+      if (!balancer_addresses_.ok()) {+        GRPC_EVENT_ENGINE_DNS_TRACE(+            ""DNSResolver::%p previous balancer hostname lookup error, ignoring ""+            ""%zu found hostnames."",+            this, new_balancer_addresses->size());+      }+      balancer_addresses_->reserve(balancer_addresses_->size() ++                                   new_balancer_addresses->size());+      auto srv_channel_args =+          resolver_->channel_args().Set(GRPC_ARG_DEFAULT_AUTHORITY, authority);+      for (const auto& addr : *new_balancer_addresses) {+        balancer_addresses_->emplace_back(CreateGRPCResolvedAddress(addr),+                                          srv_channel_args);+      }+    } else {+      auto tmp_status = balancer_addresses_.status();+      grpc_core::StatusAddChild(&tmp_status, new_balancer_addresses.status());+      balancer_addresses_ = tmp_status;+    }+    result = OnResolvedLocked();+  }+  if (result.has_value()) {+    resolver_->OnRequestComplete(std::move(*result));+  }+}++void EventEngineDNSRequestWrapper::OnTXTResolved(+    absl::StatusOr<std::string> service_config) {+  absl::optional<grpc_core::Resolver::Result> result;+  {+    MutexLock lock(&on_resolved_mu_);+    if (orphaned_) return;+    GPR_ASSERT(txt_handle_.has_value());+    txt_handle_.reset();+    service_config_json_ = service_config;+    result = OnResolvedLocked();+  }+  if (result.has_value()) {+    resolver_->OnRequestComplete(std::move(*result));+  }+}++absl::Status+EventEngineDNSRequestWrapper::GetResolutionFailureErrorMessageLocked() {+  std::string error_msg =+      absl::StrFormat(""resolver:%p dns resolution failed."", this);+  if (!addresses_.ok()) {+    absl::StrAppend(&error_msg, "" Hostname lookup error: "",+                    grpc_core::StatusToString(addresses_.status()));+  }+  if (!balancer_addresses_.ok()) {+    absl::StrAppend(&error_msg, "" SRV lookup error: "",+                    grpc_core::StatusToString(balancer_addresses_.status()));+  }+  if (!service_config_json_.ok()) {+    absl::StrAppend(&error_msg, "" TXT lookup error: "",+                    grpc_core::StatusToString(service_config_json_.status()));+  }+  auto status = grpc_core::StatusCreate(+      absl::StatusCode::kUnavailable, error_msg, DEBUG_LOCATION, /*children=*/+      {addresses_.status(), balancer_addresses_.status(),+       service_config_json_.status()});+  return status;+}++void EventEngineDNSRequestWrapper::MaybePopulateAddressesLocked(+    grpc_core::Resolver::Result& result) {","Done, I could go either way. TIL this advice made it into the style guide as the preferred input/output parameter technique: https://google.github.io/styleguide/cppguide.html#Inputs_and_Outputs:~:text=non%2Doptional%20output%20and%20input/output%20parameters%20should%20usually%20be%20references%20(which%20cannot%20be%20null).",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/32603,1152677749,2023-03-30T02:56:15Z,test/core/end2end/end2end_test_main.cc,"@@ -0,0 +1,1044 @@+// Copyright 2022 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++#include <inttypes.h>++#include <algorithm>+#include <atomic>+#include <functional>+#include <initializer_list>+#include <map>+#include <memory>+#include <regex>+#include <string>+#include <utility>+#include <vector>++#include ""absl/status/status.h""+#include ""absl/strings/str_format.h""+#include ""absl/types/optional.h""+#include ""gtest/gtest.h""++#include <grpc/compression.h>+#include <grpc/grpc.h>+#include <grpc/grpc_posix.h>+#include <grpc/grpc_security.h>+#include <grpc/grpc_security_constants.h>+#include <grpc/slice.h>+#include <grpc/status.h>+#include <grpc/support/log.h>+#include <grpc/support/time.h>++#include ""src/core/lib/channel/channel_args.h""+#include ""src/core/lib/config/config_vars.h""+#include ""src/core/lib/debug/trace.h""+#include ""src/core/lib/gprpp/host_port.h""+#include ""src/core/lib/gprpp/no_destruct.h""+#include ""src/core/lib/iomgr/error.h""+#include ""src/core/lib/iomgr/exec_ctx.h""+#include ""src/core/lib/iomgr/load_file.h""+#include ""src/core/lib/iomgr/port.h""+#include ""src/core/lib/security/credentials/fake/fake_credentials.h""+#include ""test/core/end2end/end2end_tests.h""+#include ""test/core/end2end/fixtures/h2_oauth2_common.h""+#include ""test/core/end2end/fixtures/h2_ssl_cred_reload_fixture.h""+#include ""test/core/end2end/fixtures/h2_ssl_tls_common.h""+#include ""test/core/end2end/fixtures/h2_tls_common.h""+#include ""test/core/end2end/fixtures/http_proxy_fixture.h""+#include ""test/core/end2end/fixtures/inproc_fixture.h""+#include ""test/core/end2end/fixtures/local_util.h""+#include ""test/core/end2end/fixtures/proxy.h""+#include ""test/core/end2end/fixtures/secure_fixture.h""+#include ""test/core/end2end/fixtures/sockpair_fixture.h""+#include ""test/core/util/port.h""+#include ""test/core/util/test_config.h""++// IWYU pragma: no_include <unistd.h>++#ifdef GRPC_POSIX_SOCKET+#include <fcntl.h>++#include ""src/core/lib/iomgr/socket_utils_posix.h""+#include ""src/core/lib/iomgr/unix_sockets_posix.h""+#endif++#ifdef GRPC_POSIX_WAKEUP_FD+#include ""src/core/lib/iomgr/wakeup_fd_posix.h""+#endif++#define CA_CERT_PATH ""src/core/tsi/test_creds/ca.pem""+#define SERVER_CERT_PATH ""src/core/tsi/test_creds/server1.pem""+#define SERVER_KEY_PATH ""src/core/tsi/test_creds/server1.key""++namespace grpc_core {++namespace {++std::atomic<int> unique{0};++void ProcessAuthFailure(void* state, grpc_auth_context* /*ctx*/,+                        const grpc_metadata* /*md*/, size_t /*md_count*/,+                        grpc_process_auth_metadata_done_cb cb,+                        void* user_data) {+  GPR_ASSERT(state == nullptr);+  cb(user_data, nullptr, 0, nullptr, 0, GRPC_STATUS_UNAUTHENTICATED, nullptr);+}++void AddFailAuthCheckIfNeeded(const ChannelArgs& args,+                              grpc_server_credentials* creds) {+  if (args.Contains(FAIL_AUTH_CHECK_SERVER_ARG_NAME)) {+    grpc_auth_metadata_processor processor = {ProcessAuthFailure, nullptr,+                                              nullptr};+    grpc_server_credentials_set_auth_metadata_processor(creds, processor);+  }+}++}  // namespace++class CensusFixture : public CoreTestFixture {+ private:+  grpc_server* MakeServer(const ChannelArgs& args) override {+    grpc_server_credentials* server_creds =+        grpc_insecure_server_credentials_create();+    auto* server = grpc_server_create(+        args.Set(GRPC_ARG_ENABLE_CENSUS, true).ToC().get(), nullptr);+    grpc_server_register_completion_queue(server, cq(), nullptr);+    GPR_ASSERT(+        grpc_server_add_http2_port(server, localaddr_.c_str(), server_creds));+    grpc_server_credentials_release(server_creds);+    grpc_server_start(server);+    return server;+  }+  grpc_channel* MakeClient(const ChannelArgs& args) override {+    auto* creds = grpc_insecure_credentials_create();+    auto* client =+        grpc_channel_create(localaddr_.c_str(), creds,+                            args.Set(GRPC_ARG_ENABLE_CENSUS, true).ToC().get());+    grpc_channel_credentials_release(creds);+    return client;+  }+  const std::string localaddr_ =+      JoinHostPort(""localhost"", grpc_pick_unused_port_or_die());+};++class CompressionFixture : public CoreTestFixture {+ private:+  grpc_server* MakeServer(const ChannelArgs& args) override {+    auto* server = grpc_server_create(+        args.SetIfUnset(GRPC_COMPRESSION_CHANNEL_DEFAULT_ALGORITHM,+                        GRPC_COMPRESS_GZIP)+            .ToC()+            .get(),+        nullptr);+    grpc_server_register_completion_queue(server, cq(), nullptr);+    grpc_server_credentials* server_creds =+        grpc_insecure_server_credentials_create();+    GPR_ASSERT(+        grpc_server_add_http2_port(server, localaddr_.c_str(), server_creds));+    grpc_server_credentials_release(server_creds);+    grpc_server_start(server);+    return server;+  }+  grpc_channel* MakeClient(const ChannelArgs& args) override {+    grpc_channel_credentials* creds = grpc_insecure_credentials_create();+    auto* client = grpc_channel_create(+        localaddr_.c_str(), creds,+        args.SetIfUnset(GRPC_COMPRESSION_CHANNEL_DEFAULT_ALGORITHM,+                        GRPC_COMPRESS_GZIP)+            .ToC()+            .get());+    grpc_channel_credentials_release(creds);+    return client;+  }++  std::string localaddr_ =+      JoinHostPort(""localhost"", grpc_pick_unused_port_or_die());+};++class FakesecFixture : public SecureFixture {+ private:+  grpc_channel_credentials* MakeClientCreds(const ChannelArgs&) override {+    return grpc_fake_transport_security_credentials_create();+  }+  grpc_server_credentials* MakeServerCreds(const ChannelArgs& args) override {+    grpc_server_credentials* fake_ts_creds =+        grpc_fake_transport_security_server_credentials_create();+    AddFailAuthCheckIfNeeded(args, fake_ts_creds);+    return fake_ts_creds;+  }+};++class InsecureCredsFixture : public InsecureFixture {+ private:+  grpc_server_credentials* MakeServerCreds(const ChannelArgs& args) override {+    auto* creds = grpc_insecure_server_credentials_create();+    AddFailAuthCheckIfNeeded(args, creds);+    return creds;+  }+};++class SockpairWithMinstackFixture : public SockpairFixture {+ public:+  using SockpairFixture::SockpairFixture;++ private:+  ChannelArgs MutateClientArgs(ChannelArgs args) override {+    return args.Set(GRPC_ARG_MINIMAL_STACK, true);+  }+  ChannelArgs MutateServerArgs(ChannelArgs args) override {+    return args.Set(GRPC_ARG_MINIMAL_STACK, true);+  }+};++class Sockpair1Byte : public SockpairFixture {+ public:+  Sockpair1Byte()+      : SockpairFixture(ChannelArgs()+                            .Set(GRPC_ARG_TCP_READ_CHUNK_SIZE, 1)+                            .Set(GRPC_ARG_TCP_MIN_READ_CHUNK_SIZE, 1)+                            .Set(GRPC_ARG_TCP_MAX_READ_CHUNK_SIZE, 1)) {+    g_fixture_slowdown_factor = 2;+  }+  ~Sockpair1Byte() override { g_fixture_slowdown_factor = 1; }++ private:+  ChannelArgs MutateClientArgs(ChannelArgs args) override {+    return args.Set(GRPC_ARG_MINIMAL_STACK, true);+  }+  ChannelArgs MutateServerArgs(ChannelArgs args) override {+    return args.Set(GRPC_ARG_MINIMAL_STACK, true);+  }+};++#ifdef GRPC_POSIX_SOCKET++class FdFixture : public CoreTestFixture {+ public:+  FdFixture() { create_sockets(fd_pair_); }++ private:+  grpc_server* MakeServer(const ChannelArgs& args) override {+    ExecCtx exec_ctx;+    auto* server = grpc_server_create(args.ToC().get(), nullptr);+    grpc_server_register_completion_queue(server, cq(), nullptr);+    grpc_server_start(server);+    grpc_server_credentials* creds = grpc_insecure_server_credentials_create();+    grpc_server_add_channel_from_fd(server, fd_pair_[1], creds);+    grpc_server_credentials_release(creds);+    return server;+  }+  grpc_channel* MakeClient(const ChannelArgs& args) override {+    ExecCtx exec_ctx;+    grpc_channel_credentials* creds = grpc_insecure_credentials_create();+    auto* client = grpc_channel_create_from_fd(""fixture_client"", fd_pair_[0],+                                               creds, args.ToC().get());+    grpc_channel_credentials_release(creds);+    return client;+  }++  static void create_sockets(int sv[2]) {+    int flags;+    grpc_create_socketpair_if_unix(sv);+    flags = fcntl(sv[0], F_GETFL, 0);+    GPR_ASSERT(fcntl(sv[0], F_SETFL, flags | O_NONBLOCK) == 0);+    flags = fcntl(sv[1], F_GETFL, 0);+    GPR_ASSERT(fcntl(sv[1], F_SETFL, flags | O_NONBLOCK) == 0);+    GPR_ASSERT(grpc_set_socket_no_sigpipe_if_possible(sv[0]) ==+               absl::OkStatus());+    GPR_ASSERT(grpc_set_socket_no_sigpipe_if_possible(sv[1]) ==+               absl::OkStatus());+  }++  int fd_pair_[2];+};+#endif++class NoRetryFixture : public InsecureFixture {+ private:+  ChannelArgs MutateClientArgs(ChannelArgs args) override {+    return args.Set(GRPC_ARG_ENABLE_RETRIES, false);+  }+};++class HttpProxyFilter : public CoreTestFixture {+ public:+  explicit HttpProxyFilter(const ChannelArgs& client_args)+      : proxy_(grpc_end2end_http_proxy_create(client_args.ToC().get())) {}+  ~HttpProxyFilter() override {+    // Need to shut down the proxy users before closing the proxy (otherwise we+    // become stuck).+    ShutdownClient();+    ShutdownServer();+    grpc_end2end_http_proxy_destroy(proxy_);+  }++ private:+  grpc_server* MakeServer(const ChannelArgs& args) override {+    auto* server = grpc_server_create(args.ToC().get(), nullptr);+    grpc_server_register_completion_queue(server, cq(), nullptr);+    grpc_server_credentials* server_creds =+        grpc_insecure_server_credentials_create();+    GPR_ASSERT(+        grpc_server_add_http2_port(server, server_addr_.c_str(), server_creds));+    grpc_server_credentials_release(server_creds);+    grpc_server_start(server);+    return server;+  }++  grpc_channel* MakeClient(const ChannelArgs& args) override {+    // If testing for proxy auth, add credentials to proxy uri+    absl::optional<std::string> proxy_auth_str =+        args.GetOwnedString(GRPC_ARG_HTTP_PROXY_AUTH_CREDS);+    std::string proxy_uri;+    if (!proxy_auth_str.has_value()) {+      proxy_uri = absl::StrFormat(+          ""http://%s"", grpc_end2end_http_proxy_get_proxy_name(proxy_));+    } else {+      proxy_uri =+          absl::StrFormat(""http://%s@%s"", proxy_auth_str->c_str(),+                          grpc_end2end_http_proxy_get_proxy_name(proxy_));+    }+    grpc_channel_credentials* creds = grpc_insecure_credentials_create();+    auto* client = grpc_channel_create(+        server_addr_.c_str(), creds,+        args.Set(GRPC_ARG_HTTP_PROXY, proxy_uri).ToC().get());+    grpc_channel_credentials_release(creds);+    GPR_ASSERT(client);+    return client;+  }++  std::string server_addr_ =+      JoinHostPort(""localhost"", grpc_pick_unused_port_or_die());+  grpc_end2end_http_proxy* proxy_;+};++class ProxyFixture : public CoreTestFixture {+ public:+  ProxyFixture(const ChannelArgs& client_args, const ChannelArgs& server_args)+      : proxy_(grpc_end2end_proxy_create(&proxy_def_, client_args.ToC().get(),+                                         server_args.ToC().get())) {}+  ~ProxyFixture() override { grpc_end2end_proxy_destroy(proxy_); }++ private:+  static grpc_server* CreateProxyServer(const char* port,+                                        const grpc_channel_args* server_args) {+    grpc_server* s = grpc_server_create(server_args, nullptr);+    grpc_server_credentials* server_creds =+        grpc_insecure_server_credentials_create();+    GPR_ASSERT(grpc_server_add_http2_port(s, port, server_creds));+    grpc_server_credentials_release(server_creds);+    return s;+  }++  static grpc_channel* CreateProxyClient(const char* target,+                                         const grpc_channel_args* client_args) {+    grpc_channel_credentials* creds = grpc_insecure_credentials_create();+    grpc_channel* channel = grpc_channel_create(target, creds, client_args);+    grpc_channel_credentials_release(creds);+    return channel;+  }++  grpc_server* MakeServer(const ChannelArgs& args) override {+    auto* server = grpc_server_create(args.ToC().get(), nullptr);+    grpc_server_register_completion_queue(server, cq(), nullptr);+    grpc_server_credentials* server_creds =+        grpc_insecure_server_credentials_create();+    GPR_ASSERT(grpc_server_add_http2_port(+        server, grpc_end2end_proxy_get_server_port(proxy_), server_creds));+    grpc_server_credentials_release(server_creds);+    grpc_server_start(server);+    return server;+  }++  grpc_channel* MakeClient(const ChannelArgs& args) override {+    grpc_channel_credentials* creds = grpc_insecure_credentials_create();+    auto* client = grpc_channel_create(+        grpc_end2end_proxy_get_client_target(proxy_), creds, args.ToC().get());+    grpc_channel_credentials_release(creds);+    GPR_ASSERT(client);+    return client;+  }+  const grpc_end2end_proxy_def proxy_def_ = {CreateProxyServer,+                                             CreateProxyClient};+  grpc_end2end_proxy* proxy_;+};++class SslProxyFixture : public CoreTestFixture {+ public:+  SslProxyFixture(const ChannelArgs& client_args,+                  const ChannelArgs& server_args)+      : proxy_(grpc_end2end_proxy_create(&proxy_def_, client_args.ToC().get(),+                                         server_args.ToC().get())) {}+  ~SslProxyFixture() override { grpc_end2end_proxy_destroy(proxy_); }++ private:+  static grpc_server* CreateProxyServer(const char* port,+                                        const grpc_channel_args* server_args) {+    grpc_server* s = grpc_server_create(server_args, nullptr);+    grpc_slice cert_slice, key_slice;+    GPR_ASSERT(GRPC_LOG_IF_ERROR(+        ""load_file"", grpc_load_file(SERVER_CERT_PATH, 1, &cert_slice)));+    GPR_ASSERT(GRPC_LOG_IF_ERROR(+        ""load_file"", grpc_load_file(SERVER_KEY_PATH, 1, &key_slice)));+    const char* server_cert =+        reinterpret_cast<const char*> GRPC_SLICE_START_PTR(cert_slice);+    const char* server_key =+        reinterpret_cast<const char*> GRPC_SLICE_START_PTR(key_slice);+    grpc_ssl_pem_key_cert_pair pem_key_cert_pair = {server_key, server_cert};+    grpc_server_credentials* ssl_creds = grpc_ssl_server_credentials_create(+        nullptr, &pem_key_cert_pair, 1, 0, nullptr);+    grpc_slice_unref(cert_slice);+    grpc_slice_unref(key_slice);+    GPR_ASSERT(grpc_server_add_http2_port(s, port, ssl_creds));+    grpc_server_credentials_release(ssl_creds);+    return s;+  }++  static grpc_channel* CreateProxyClient(const char* target,+                                         const grpc_channel_args* client_args) {+    grpc_channel* channel;+    grpc_channel_credentials* ssl_creds =+        grpc_ssl_credentials_create(nullptr, nullptr, nullptr, nullptr);+    grpc_arg ssl_name_override = {+        GRPC_ARG_STRING,+        const_cast<char*>(GRPC_SSL_TARGET_NAME_OVERRIDE_ARG),+        {const_cast<char*>(""foo.test.google.fr"")}};+    const grpc_channel_args* new_client_args =+        grpc_channel_args_copy_and_add(client_args, &ssl_name_override, 1);+    channel = grpc_channel_create(target, ssl_creds, new_client_args);+    grpc_channel_credentials_release(ssl_creds);+    {+      ExecCtx exec_ctx;+      grpc_channel_args_destroy(new_client_args);+    }+    return channel;+  }++  grpc_server* MakeServer(const ChannelArgs& args) override {+    grpc_slice cert_slice, key_slice;+    GPR_ASSERT(GRPC_LOG_IF_ERROR(+        ""load_file"", grpc_load_file(SERVER_CERT_PATH, 1, &cert_slice)));+    GPR_ASSERT(GRPC_LOG_IF_ERROR(+        ""load_file"", grpc_load_file(SERVER_KEY_PATH, 1, &key_slice)));+    const char* server_cert =+        reinterpret_cast<const char*> GRPC_SLICE_START_PTR(cert_slice);+    const char* server_key =+        reinterpret_cast<const char*> GRPC_SLICE_START_PTR(key_slice);+    grpc_ssl_pem_key_cert_pair pem_key_cert_pair = {server_key, server_cert};+    grpc_server_credentials* ssl_creds = grpc_ssl_server_credentials_create(+        nullptr, &pem_key_cert_pair, 1, 0, nullptr);+    grpc_slice_unref(cert_slice);+    grpc_slice_unref(key_slice);+    if (args.Contains(FAIL_AUTH_CHECK_SERVER_ARG_NAME)) {+      grpc_auth_metadata_processor processor = {ProcessAuthFailure, nullptr,+                                                nullptr};+      grpc_server_credentials_set_auth_metadata_processor(ssl_creds, processor);+    }++    auto* server = grpc_server_create(args.ToC().get(), nullptr);+    grpc_server_register_completion_queue(server, cq(), nullptr);+    GPR_ASSERT(grpc_server_add_http2_port(+        server, grpc_end2end_proxy_get_server_port(proxy_), ssl_creds));+    grpc_server_credentials_release(ssl_creds);+    grpc_server_start(server);+    return server;+  }++  grpc_channel* MakeClient(const ChannelArgs& args) override {+    grpc_channel_credentials* ssl_creds =+        grpc_ssl_credentials_create(nullptr, nullptr, nullptr, nullptr);+    auto* client = grpc_channel_create(+        grpc_end2end_proxy_get_client_target(proxy_), ssl_creds,+        args.Set(GRPC_SSL_TARGET_NAME_OVERRIDE_ARG, ""foo.test.google.fr"")+            .ToC()+            .get());+    GPR_ASSERT(client != nullptr);+    grpc_channel_credentials_release(ssl_creds);+    return client;+  }+  const grpc_end2end_proxy_def proxy_def_ = {CreateProxyServer,+                                             CreateProxyClient};+  grpc_end2end_proxy* proxy_;+};++class FixtureWithTracing final : public CoreTestFixture {+ public:+  explicit FixtureWithTracing(std::unique_ptr<CoreTestFixture> fixture)+      : fixture_(std::move(fixture)) {+    // g_fixture_slowdown_factor = 10;+    EXPECT_FALSE(grpc_tracer_set_enabled(""doesnt-exist"", 0));+    EXPECT_TRUE(grpc_tracer_set_enabled(""http"", 1));+    EXPECT_TRUE(grpc_tracer_set_enabled(""all"", 1));+  }+  ~FixtureWithTracing() override {+    saved_trace_flags_.Restore();+    // g_fixture_slowdown_factor = 1;+  }++  grpc_server* MakeServer(const ChannelArgs& args) override {+    return fixture_->MakeServer(args);+  }++  grpc_channel* MakeClient(const ChannelArgs& args) override {+    return fixture_->MakeClient(args);+  }++ private:+  SavedTraceFlags saved_trace_flags_;+  std::unique_ptr<CoreTestFixture> fixture_;+};++#ifdef GRPC_POSIX_WAKEUP_FD+class InsecureFixtureWithPipeForWakeupFd : public InsecureFixture {+ public:+  InsecureFixtureWithPipeForWakeupFd()+      : old_value_(std::exchange(grpc_allow_specialized_wakeup_fd, 0)) {}++  ~InsecureFixtureWithPipeForWakeupFd() override {+    grpc_allow_specialized_wakeup_fd = old_value_;+  }++ private:+  const int old_value_;+};+#endif++const char* NameFromConfig(+    const ::testing::TestParamInfo<const CoreTestConfiguration*>& config) {+  return config.param->name;+}++const NoDestruct<std::vector<CoreTestConfiguration>> all_configs{std::vector<","https://gist.github.com/ctiller/919a358a71c6b0371bfc828a9a445f76I'll try to do some data processing on this, but it's non trivial (a lot of tests in the old system become N individual tests in the new)",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/32750,1152684575,2023-03-30T03:11:34Z,include/grpc/grpc_audit_logging.h,"@@ -0,0 +1,71 @@+//+//+// Copyright 2023 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+//+//++#ifndef GRPC_GRPC_AUDIT_LOGGING_H+#define GRPC_GRPC_AUDIT_LOGGING_H++#include ""absl/status/status.h""+#include ""absl/status/statusor.h""+#include ""absl/strings/string_view.h""++namespace grpc_core {+namespace experimental {++// The base struct for audit context.+typedef struct CoreAuditContext {",`class AuditContext {` -- no need for a typedef,
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/32750,1152685210,2023-03-30T03:13:10Z,include/grpcpp/security/audit_logging.h,"@@ -0,0 +1,106 @@+//+//+// Copyright 2023 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+//+//++#ifndef GRPCPP_SECURITY_AUDIT_LOGGING_H+#define GRPCPP_SECURITY_AUDIT_LOGGING_H++#include <grpc/grpc_audit_logging.h>+#include <grpcpp/support/string_ref.h>++namespace grpc {+namespace experimental {++// This class contains useful information to be consumed in an audit logging+// event.+class AuditContext {+ public:+  // Does not take the ownership of core_context. Callers have to ensure it+  // outlives this class.+  explicit AuditContext(+      const grpc_core::experimental::CoreAuditContext* core_context)+      : core_context_(core_context) {}++  grpc::string_ref rpc_method() const;+  grpc::string_ref principal() const;+  grpc::string_ref policy_name() const;+  grpc::string_ref matched_rule() const;+  bool authorized() const;++ private:+  const grpc_core::experimental::CoreAuditContext* core_context_;+};++// The base class for audit logger implementations.+// Users are expected to inherit this class and implement the Log() function.+class AuditLogger : public grpc_core::experimental::CoreAuditLogger {",I don't think we need inheritance here: this should be its own type.,X
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/32750,1152685257,2023-03-30T03:13:18Z,include/grpcpp/security/audit_logging.h,"@@ -0,0 +1,106 @@+//+//+// Copyright 2023 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+//+//++#ifndef GRPCPP_SECURITY_AUDIT_LOGGING_H+#define GRPCPP_SECURITY_AUDIT_LOGGING_H++#include <grpc/grpc_audit_logging.h>+#include <grpcpp/support/string_ref.h>++namespace grpc {+namespace experimental {++// This class contains useful information to be consumed in an audit logging+// event.+class AuditContext {+ public:+  // Does not take the ownership of core_context. Callers have to ensure it+  // outlives this class.+  explicit AuditContext(+      const grpc_core::experimental::CoreAuditContext* core_context)+      : core_context_(core_context) {}++  grpc::string_ref rpc_method() const;+  grpc::string_ref principal() const;+  grpc::string_ref policy_name() const;+  grpc::string_ref matched_rule() const;+  bool authorized() const;++ private:+  const grpc_core::experimental::CoreAuditContext* core_context_;+};++// The base class for audit logger implementations.+// Users are expected to inherit this class and implement the Log() function.+class AuditLogger : public grpc_core::experimental::CoreAuditLogger {+ public:+  // This function will be invoked synchronously when applicable during the+  // RBAC-based authorization process. It does not return anything and thus will+  // not impact whether the RPC will be rejected or not.+  virtual void Log(const AuditContext& audit_context) = 0;++  void CoreLog(const grpc_core::experimental::CoreAuditContext&) final;+};++// The base class for audit logger factory implementations.+// Users should inherit this class and implement those declared virtual+// funcitons.+class AuditLoggerFactory+    : public grpc_core::experimental::CoreAuditLoggerFactory {",No inheritance here.,X
7221003,rockspore,https://api.github.com/repos/grpc/grpc/pulls/32750,1152687002,2023-03-30T03:17:44Z,include/grpc/grpc_audit_logging.h,"@@ -0,0 +1,71 @@+//+//+// Copyright 2023 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+//+//++#ifndef GRPC_GRPC_AUDIT_LOGGING_H+#define GRPC_GRPC_AUDIT_LOGGING_H++#include ""absl/status/status.h""+#include ""absl/status/statusor.h""+#include ""absl/strings/string_view.h""++namespace grpc_core {+namespace experimental {++// The base struct for audit context.+typedef struct CoreAuditContext {+ public:+  absl::string_view rpc_method() const;+  absl::string_view principal() const;+  absl::string_view policy_name() const;+  absl::string_view matched_rule() const;+  bool authorized() const;+} AuditContext;++// This base class for audit logger implementations.+class CoreAuditLogger {+ public:+  virtual void CoreLog(const CoreAuditContext& audit_context) = 0;","So it means this class defined in C-Core can have a dependence on the C++ class, right? I initially was about to do this but wasn't sure if it's fine to have such a reversed dependency.",
7221003,rockspore,https://api.github.com/repos/grpc/grpc/pulls/32750,1152689730,2023-03-30T03:24:34Z,include/grpc/grpc_audit_logging.h,"@@ -0,0 +1,71 @@+//+//+// Copyright 2023 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+//+//++#ifndef GRPC_GRPC_AUDIT_LOGGING_H+#define GRPC_GRPC_AUDIT_LOGGING_H++#include ""absl/status/status.h""+#include ""absl/status/statusor.h""+#include ""absl/strings/string_view.h""++namespace grpc_core {+namespace experimental {++// The base struct for audit context.+typedef struct CoreAuditContext {+ public:+  absl::string_view rpc_method() const;+  absl::string_view principal() const;+  absl::string_view policy_name() const;+  absl::string_view matched_rule() const;+  bool authorized() const;+} AuditContext;++// This base class for audit logger implementations.+class CoreAuditLogger {+ public:+  virtual void CoreLog(const CoreAuditContext& audit_context) = 0;",Oh. is the following flow correct?```C++// C-Coreclass AuditLogger { public:  virtual void Log() = 0;};``````C++// C++class AuditLogger { public:  virtual void Log() = 0;};class AuditLoggerFactory { public:  virtual std::unique_ptr<AuditLogger> CreateAuditLogger() = 0;  std::unique_ptr<CoreLogger> CreateCoreLogger() {    return std::make_unique<CoreLogger>(CreateAuditLogger());  }};// non-public APIclass CoreLogger : public grpc_core::AuditLogger { public:  CoreLogger(std::unique_ptr<AuditLogger> logger) : logger_(logger) {}  void Log() { logger_->Log(); } private:  std::unique_ptr<AuditLogger> logger_;};```,
5663878,yijiem,https://api.github.com/repos/grpc/grpc/pulls/32632,1152726610,2023-03-30T04:44:48Z,src/core/ext/filters/client_channel/resolver/dns/event_engine/event_engine_client_channel_resolver.cc,"@@ -0,0 +1,535 @@+// Copyright 2023 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+#include <grpc/support/port_platform.h>++#include ""src/core/ext/filters/client_channel/resolver/dns/event_engine/event_engine_client_channel_resolver.h""++#include <stddef.h>+#include <stdint.h>++#include <algorithm>+#include <chrono>+#include <initializer_list>+#include <memory>+#include <string>+#include <utility>+#include <vector>++#include ""absl/base/thread_annotations.h""+#include ""absl/container/flat_hash_set.h""+#include ""absl/functional/bind_front.h""+#include ""absl/status/status.h""+#include ""absl/status/statusor.h""+#include ""absl/strings/str_cat.h""+#include ""absl/strings/str_format.h""+#include ""absl/strings/strip.h""+#include ""absl/types/optional.h""++#include <grpc/event_engine/event_engine.h>+#include <grpc/grpc.h>+#include <grpc/support/log.h>++#include ""src/core/ext/filters/client_channel/lb_policy/grpclb/grpclb_balancer_addresses.h""+#include ""src/core/ext/filters/client_channel/resolver/dns/event_engine/service_config_helper.h""+#include ""src/core/ext/filters/client_channel/resolver/polling_resolver.h""+#include ""src/core/lib/backoff/backoff.h""+#include ""src/core/lib/channel/channel_args.h""+#include ""src/core/lib/debug/trace.h""+#include ""src/core/lib/event_engine/handle_containers.h""+#include ""src/core/lib/event_engine/resolved_address_internal.h""+#include ""src/core/lib/event_engine/trace.h""+#include ""src/core/lib/event_engine/utils.h""+#include ""src/core/lib/gprpp/debug_location.h""+#include ""src/core/lib/gprpp/ref_counted_ptr.h""+#include ""src/core/lib/gprpp/status_helper.h""+#include ""src/core/lib/gprpp/sync.h""+#include ""src/core/lib/gprpp/time.h""+#include ""src/core/lib/iomgr/resolve_address.h""+#include ""src/core/lib/resolver/resolver.h""+#include ""src/core/lib/resolver/resolver_factory.h""+#include ""src/core/lib/resolver/server_address.h""+#include ""src/core/lib/service_config/service_config.h""+#include ""src/core/lib/service_config/service_config_impl.h""++// IWYU pragma: no_include <ratio>++namespace grpc_event_engine {+namespace experimental {++namespace {++#define GRPC_DNS_INITIAL_CONNECT_BACKOFF_SECONDS 1+#define GRPC_DNS_RECONNECT_BACKOFF_MULTIPLIER 1.6+#define GRPC_DNS_RECONNECT_MAX_BACKOFF_SECONDS 120+#define GRPC_DNS_RECONNECT_JITTER 0.2+#define GRPC_DNS_DEFAULT_QUERY_TIMEOUT_MS 120000++using grpc_core::BackOff;+using grpc_core::Duration;+using grpc_core::InternallyRefCounted;+using grpc_core::MakeOrphanable;+using grpc_core::Mutex;+using grpc_core::MutexLock;+using grpc_core::Orphanable;+using grpc_core::OrphanablePtr;+using grpc_core::RefCountedPtr;+using grpc_core::ResolverArgs;++// ----------------------------------------------------------------------------+// EventEngineDNSRequestWrapper declaration+// ----------------------------------------------------------------------------+class EventEngineClientChannelDNSResolver;++class EventEngineDNSRequestWrapper+    : public InternallyRefCounted<EventEngineDNSRequestWrapper> {+ public:+  EventEngineDNSRequestWrapper(+      RefCountedPtr<EventEngineClientChannelDNSResolver> resolver,+      std::unique_ptr<EventEngine::DNSResolver> event_engine_resolver);+  ~EventEngineDNSRequestWrapper() override;++  // Note that thread safety cannot be analyzed due to this being invoked from+  // OrphanablePtr<>, and there's no way to pass the lock annotation through+  // there.+  void Orphan() override ABSL_NO_THREAD_SAFETY_ANALYSIS;++  void OnHostnameResolved(+      absl::StatusOr<std::vector<EventEngine::ResolvedAddress>> addresses);+  void OnSRVResolved(+      std::string srv_host,+      absl::StatusOr<std::vector<EventEngine::DNSResolver::SRVRecord>>+          srv_records);+  void OnBalancerHostnamesResolved(+      std::string authority,+      absl::StatusOr<std::vector<EventEngine::ResolvedAddress>> addresses);+  void OnTXTResolved(absl::StatusOr<std::string> service_config);++  // Returns a Result if resolution is complete.+  // callers must release the lock and call OnRequestComplete if a Result is+  // returned. This is because OnRequestComplete may Orphan the resolver, which+  // requires taking the lock.+  absl::optional<grpc_core::Resolver::Result> OnResolvedLocked()+      ABSL_EXCLUSIVE_LOCKS_REQUIRED(on_resolved_mu_);++ private:+  // Helper method for generating the combined resolution status error+  absl::Status GetResolutionFailureErrorMessageLocked()+      ABSL_EXCLUSIVE_LOCKS_REQUIRED(on_resolved_mu_);+  // Helper method to populate server addresses on resolver result.+  void MaybePopulateAddressesLocked(grpc_core::Resolver::Result& result)+      ABSL_EXCLUSIVE_LOCKS_REQUIRED(on_resolved_mu_);+  // Helper method to populate balancer addresses on resolver result.+  void MaybePopulateBalancerAddressesLocked(grpc_core::Resolver::Result& result)+      ABSL_EXCLUSIVE_LOCKS_REQUIRED(on_resolved_mu_);+  // Helper method to populate service config on resolver result.+  void MaybePopulateServiceConfigLocked(grpc_core::Resolver::Result& result)+      ABSL_EXCLUSIVE_LOCKS_REQUIRED(on_resolved_mu_);+  // Convert empty results into resolution errors.+  //+  // TODO(roth): We should someday separate empty results (NXDOMAIN) from actual+  // DNS resolution errors. For now, they are treated the same so this resolver+  // behaves similarly to the old c-ares resolver.+  void NormalizeEmptyResultsToErrorsLocked()+      ABSL_EXCLUSIVE_LOCKS_REQUIRED(on_resolved_mu_);++  RefCountedPtr<EventEngineClientChannelDNSResolver> resolver_;+  Mutex on_resolved_mu_;+  // Lookup callbacks+  absl::optional<EventEngine::DNSResolver::LookupTaskHandle> hostname_handle_+      ABSL_GUARDED_BY(on_resolved_mu_);+  absl::optional<EventEngine::DNSResolver::LookupTaskHandle> srv_handle_+      ABSL_GUARDED_BY(on_resolved_mu_);+  absl::optional<EventEngine::DNSResolver::LookupTaskHandle> txt_handle_+      ABSL_GUARDED_BY(on_resolved_mu_);+  LookupTaskHandleSet balancer_hostname_handles_+      ABSL_GUARDED_BY(on_resolved_mu_);+  // Output fields from requests.+  absl::StatusOr<std::vector<EventEngine::ResolvedAddress>> addresses_+      ABSL_GUARDED_BY(on_resolved_mu_);+  absl::StatusOr<grpc_core::ServerAddressList> balancer_addresses_+      ABSL_GUARDED_BY(on_resolved_mu_);+  absl::StatusOr<std::string> service_config_json_+      ABSL_GUARDED_BY(on_resolved_mu_);+  // Other internal state+  size_t number_of_balancer_hostnames_resolved_+      ABSL_GUARDED_BY(on_resolved_mu_) = 0;+  bool orphaned_ ABSL_GUARDED_BY(on_resolved_mu_) = false;+  std::unique_ptr<EventEngine::DNSResolver> event_engine_resolver_;+};++// ----------------------------------------------------------------------------+// EventEngineClientChannelDNSResolver+// ----------------------------------------------------------------------------+class EventEngineClientChannelDNSResolver : public grpc_core::PollingResolver {+ public:+  EventEngineClientChannelDNSResolver(ResolverArgs args,+                                      Duration min_time_between_resolutions);+  OrphanablePtr<Orphanable> StartRequest() override;++ private:+  friend class EventEngineDNSRequestWrapper;++  /// whether to request the service config+  const bool request_service_config_;+  // whether or not to enable SRV DNS queries+  const bool enable_srv_queries_;+  // timeout in milliseconds for active DNS queries+  EventEngine::Duration query_timeout_ms_;+  std::shared_ptr<EventEngine> event_engine_;+};++EventEngineClientChannelDNSResolver::EventEngineClientChannelDNSResolver(+    ResolverArgs args, Duration min_time_between_resolutions)+    : PollingResolver(std::move(args), min_time_between_resolutions,+                      BackOff::Options()+                          .set_initial_backoff(Duration::Milliseconds(+                              GRPC_DNS_INITIAL_CONNECT_BACKOFF_SECONDS * 1000))+                          .set_multiplier(GRPC_DNS_RECONNECT_BACKOFF_MULTIPLIER)+                          .set_jitter(GRPC_DNS_RECONNECT_JITTER)+                          .set_max_backoff(Duration::Milliseconds(+                              GRPC_DNS_RECONNECT_MAX_BACKOFF_SECONDS * 1000)),+                      &grpc_event_engine_dns_trace),+      request_service_config_(+          !channel_args()+               .GetBool(GRPC_ARG_SERVICE_CONFIG_DISABLE_RESOLUTION)+               .value_or(true)),+      enable_srv_queries_(channel_args()+                              .GetBool(GRPC_ARG_DNS_ENABLE_SRV_QUERIES)+                              .value_or(false)),+      // TODO(yijiem): decide if the ares channel arg timeout should be reused.+      query_timeout_ms_(std::chrono::milliseconds(+          std::max(0, channel_args()+                          .GetInt(GRPC_ARG_DNS_ARES_QUERY_TIMEOUT_MS)+                          .value_or(GRPC_DNS_DEFAULT_QUERY_TIMEOUT_MS)))),+      event_engine_(channel_args().GetObjectRef<EventEngine>()) {}++OrphanablePtr<Orphanable> EventEngineClientChannelDNSResolver::StartRequest() {+  return MakeOrphanable<EventEngineDNSRequestWrapper>(+      Ref(DEBUG_LOCATION, ""dns-resolving""),+      event_engine_->GetDNSResolver({/*dns_server=*/authority()}));+}++// ----------------------------------------------------------------------------+// EventEngineDNSRequestWrapper definition+// ----------------------------------------------------------------------------++EventEngineDNSRequestWrapper::EventEngineDNSRequestWrapper(+    RefCountedPtr<EventEngineClientChannelDNSResolver> resolver,+    std::unique_ptr<EventEngine::DNSResolver> event_engine_resolver)+    : resolver_(std::move(resolver)),+      event_engine_resolver_(std::move(event_engine_resolver)) {+  // Locking to prevent completion before all records are queried+  MutexLock lock(&on_resolved_mu_);+  hostname_handle_ = event_engine_resolver_->LookupHostname(+      absl::bind_front(&EventEngineDNSRequestWrapper::OnHostnameResolved,+                       Ref(DEBUG_LOCATION, ""OnHostnameResolved"")),+      resolver_->name_to_resolve(), grpc_core::kDefaultSecurePort,+      resolver_->query_timeout_ms_);+  GRPC_EVENT_ENGINE_DNS_TRACE(+      ""DNSResolver::%p Started resolving hostname. Handle::%s"", resolver_.get(),+      HandleToString(*hostname_handle_).c_str());+  if (resolver_->enable_srv_queries_) {+    srv_handle_ = event_engine_resolver_->LookupSRV(+        absl::bind_front(&EventEngineDNSRequestWrapper::OnSRVResolved,+                         Ref(DEBUG_LOCATION, ""OnSRVResolved""),+                         resolver_->name_to_resolve()),+        resolver_->name_to_resolve(), resolver_->query_timeout_ms_);+    GRPC_EVENT_ENGINE_DNS_TRACE(+        ""DNSResolver::%p Started resolving SRV. Handle::%s"", resolver_.get(),+        HandleToString(*srv_handle_).c_str());+  }+  if (resolver_->request_service_config_) {+    txt_handle_ = event_engine_resolver_->LookupTXT(+        absl::bind_front(&EventEngineDNSRequestWrapper::OnTXTResolved,+                         Ref(DEBUG_LOCATION, ""OnTXTResolved"")),+        resolver_->name_to_resolve(), resolver_->query_timeout_ms_);+    GRPC_EVENT_ENGINE_DNS_TRACE(+        ""DNSResolver::%p Started resolving TXT. Handle::%s"", resolver_.get(),+        HandleToString(*txt_handle_).c_str());+  }+}++EventEngineDNSRequestWrapper::~EventEngineDNSRequestWrapper() {+  resolver_.reset(DEBUG_LOCATION, ""dns-resolving"");+}++void EventEngineDNSRequestWrapper::Orphan() {+  {+    MutexLock lock(&on_resolved_mu_);+    orphaned_ = true;+    // Event if cancellation fails here, OnResolvedLocked will return early, and+    // the resolver will never see a completed request.+    if (hostname_handle_.has_value()) {+      event_engine_resolver_->CancelLookup(*hostname_handle_);+    }+    if (srv_handle_.has_value()) {+      event_engine_resolver_->CancelLookup(*srv_handle_);+    }+    for (const auto& handle : balancer_hostname_handles_) {+      event_engine_resolver_->CancelLookup(handle);+    }+    if (txt_handle_.has_value()) {+      event_engine_resolver_->CancelLookup(*txt_handle_);+    }+  }+  Unref(DEBUG_LOCATION, ""Orphan"");+}++void EventEngineDNSRequestWrapper::OnHostnameResolved(+    absl::StatusOr<std::vector<EventEngine::ResolvedAddress>> addresses) {+  absl::optional<grpc_core::Resolver::Result> result;+  {+    MutexLock lock(&on_resolved_mu_);+    if (orphaned_) return;+    hostname_handle_.reset();+    addresses_ = addresses;+    result = OnResolvedLocked();+  }+  if (result.has_value()) {+    resolver_->OnRequestComplete(std::move(*result));+  }+}++void EventEngineDNSRequestWrapper::OnSRVResolved(+    std::string srv_host,+    absl::StatusOr<std::vector<EventEngine::DNSResolver::SRVRecord>>+        srv_records) {+  absl::optional<grpc_core::Resolver::Result> result;+  {+    MutexLock lock(&on_resolved_mu_);+    if (orphaned_) return;+    srv_handle_.reset();+    if (srv_records.ok()) {+      balancer_addresses_ = grpc_core::ServerAddressList();+      // Do a subsequent hostname query if SRV records were returned+      for (const auto& srv_record : *srv_records) {+        balancer_hostname_handles_.insert(+            event_engine_resolver_->LookupHostname(+                absl::bind_front(+                    &EventEngineDNSRequestWrapper::OnBalancerHostnamesResolved,+                    Ref(DEBUG_LOCATION, ""OnBalancerHostnamesResolved""),+                    srv_host),+                srv_record.host, std::to_string(srv_record.port),+                resolver_->query_timeout_ms_));+        GRPC_EVENT_ENGINE_DNS_TRACE(+            ""DNSResolver::%p Started resolving balancer hostname %s:%d"",+            resolver_.get(), srv_record.host.c_str(), srv_record.port);+      }+      return;+    }+    // An error has occurred, finish resolving.+    balancer_addresses_ = srv_records.status();+    result = OnResolvedLocked();+  }+  if (result.has_value()) {+    resolver_->OnRequestComplete(std::move(*result));+  }+}++void EventEngineDNSRequestWrapper::OnBalancerHostnamesResolved(+    std::string authority,+    absl::StatusOr<std::vector<EventEngine::ResolvedAddress>>+        new_balancer_addresses) {+  absl::optional<grpc_core::Resolver::Result> result;+  {+    MutexLock lock(&on_resolved_mu_);+    if (orphaned_) return;+    ++number_of_balancer_hostnames_resolved_;+    if (new_balancer_addresses.ok()) {+      if (!balancer_addresses_.ok()) {+        GRPC_EVENT_ENGINE_DNS_TRACE(+            ""DNSResolver::%p previous balancer hostname lookup error, ignoring """,Add a TODO sounds good. Seems like in general the naming test does not have the dataset of multiple SRV records. And for this specific case the first balancer address lookup failed while the second one succeeded?,
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32632,1153777392,2023-03-30T20:53:41Z,src/core/ext/filters/client_channel/resolver/dns/event_engine/event_engine_client_channel_resolver.cc,"@@ -343,128 +345,97 @@ void EventEngineClientChannelDNSResolver::EventEngineDNSRequestWrapper::         std::string authority,         absl::StatusOr<std::vector<EventEngine::ResolvedAddress>>             new_balancer_addresses) {+  ValidationErrors::ScopedField field(&errors_, ""balancer hostname lookup"");   absl::optional<Resolver::Result> result;   auto cleanup = absl::MakeCleanup([&]() {     if (result.has_value()) {       resolver_->OnRequestComplete(std::move(*result));     }-    Unref(DEBUG_LOCATION, ""OnBalancerHostnamesResolved"");   });-  {-    MutexLock lock(&on_resolved_mu_);-    if (orphaned_) return;-    ++number_of_balancer_hostnames_resolved_;-    if (!new_balancer_addresses.ok()) {-      // An error has occurred, finish resolving.-      balancer_address_lookup_errors_.AddError(absl::StrCat(-          authority, "": "", new_balancer_addresses.status().ToString()));-    } else {-      // Capture the addresses and finish resolving.-      balancer_addresses_.reserve(balancer_addresses_.size() +-                                  new_balancer_addresses->size());-      auto srv_channel_args =-          resolver_->channel_args().Set(GRPC_ARG_DEFAULT_AUTHORITY, authority);-      for (const auto& addr : *new_balancer_addresses) {-        balancer_addresses_.emplace_back(CreateGRPCResolvedAddress(addr),-                                         srv_channel_args);-      }+  MutexLock lock(&on_resolved_mu_);+  if (orphaned_) return;+  ++number_of_balancer_hostnames_resolved_;+  if (!new_balancer_addresses.ok()) {+    // An error has occurred, finish resolving.+    errors_.AddError(absl::StrCat(authority, "": "",+                                  new_balancer_addresses.status().message()));+  } else {+    // Capture the addresses and finish resolving.+    balancer_addresses_.reserve(balancer_addresses_.size() ++                                new_balancer_addresses->size());+    auto srv_channel_args =+        resolver_->channel_args().Set(GRPC_ARG_DEFAULT_AUTHORITY, authority);+    for (const auto& addr : *new_balancer_addresses) {+      balancer_addresses_.emplace_back(CreateGRPCResolvedAddress(addr),+                                       srv_channel_args);     }-    result = OnResolvedLocked();   }+  result = OnResolvedLocked(); }  void EventEngineClientChannelDNSResolver::EventEngineDNSRequestWrapper::     OnTXTResolved(absl::StatusOr<std::string> service_config) {+  ValidationErrors::ScopedField field(&errors_, ""txt lookup"");   absl::optional<Resolver::Result> result;   {     MutexLock lock(&on_resolved_mu_);     if (orphaned_) return;     GPR_ASSERT(txt_handle_.has_value());     txt_handle_.reset();-    service_config_json_ = service_config;+    if (!service_config.ok()) {+      errors_.AddError(service_config.status().message());+    }+    service_config_json_ = std::move(service_config);     result = OnResolvedLocked();   }   if (result.has_value()) {     resolver_->OnRequestComplete(std::move(*result));   }-  Unref(DEBUG_LOCATION, ""OnTXTResolved"");-}--absl::Status EventEngineClientChannelDNSResolver::EventEngineDNSRequestWrapper::-    GetResolutionFailureErrorMessageLocked() {-  ValidationErrors all_errors;-  if (!addresses_.ok()) {-    all_errors.AddError(absl::StrCat(""Error resolving hostname: "",-                                     addresses_.status().message()));-  }-  if (balancer_address_lookup_errors_.FieldHasErrors()) {-    all_errors.AddError(balancer_address_lookup_errors_-                            .status(""Errors looking up balancer addresses"")-                            .message());-  }-  if (!service_config_json_.ok()) {-    all_errors.AddError(absl::StrCat(""Error resolving TXT records: "",-                                     service_config_json_.status().message()));-  }-  return all_errors.status(-      absl::StrFormat(""resolver:%p dns resolution failed."", this),-      absl::StatusCode::kUnavailable); }  void EventEngineClientChannelDNSResolver::EventEngineDNSRequestWrapper::-    MaybePopulateAddressesLocked(Resolver::Result& result) {-  if (addresses_.ok()) {-    result.addresses->reserve(addresses_->size());-    for (const auto& addr : *addresses_) {-      result.addresses->emplace_back(CreateGRPCResolvedAddress(addr),-                                     resolver_->channel_args());-    }+    MaybePopulateAddressesLocked(Resolver::Result* result) {+  if (addresses_.empty()) return;+  result->addresses->reserve(addresses_.size());+  for (const auto& addr : addresses_) {+    result->addresses->emplace_back(CreateGRPCResolvedAddress(addr),+                                    resolver_->channel_args());   } }  void EventEngineClientChannelDNSResolver::EventEngineDNSRequestWrapper::-    MaybePopulateBalancerAddressesLocked(Resolver::Result& result) {+    MaybePopulateBalancerAddressesLocked(Resolver::Result* result) {   if (!balancer_addresses_.empty()) {-    result.args = SetGrpcLbBalancerAddresses(result.args, balancer_addresses_);+    result->args =+        SetGrpcLbBalancerAddresses(result->args, balancer_addresses_);   } }  void EventEngineClientChannelDNSResolver::EventEngineDNSRequestWrapper::-    MaybePopulateServiceConfigLocked(Resolver::Result& result) {-  // TODO(roth): We should not ignore errors here, but instead have users of the-  // resolver handle them appropriately. Some test/cpp/naming tests fail.-  if (service_config_json_.ok() && service_config_json_->empty()) {-    result.service_config = service_config_json_.status();-  }-  if (service_config_json_.ok() && !service_config_json_->empty()) {-    auto service_config = ChooseServiceConfig(*service_config_json_);-    if (!service_config.ok()) {-      result.service_config = absl::UnavailableError(-          absl::StrCat(""failed to parse service config: "",-                       service_config.status().message()));-    } else if (!service_config->empty()) {-      GRPC_EVENT_ENGINE_RESOLVER_TRACE(-          ""resolver:%p selected service config choice: %s"", this,-          service_config->c_str());-      result.service_config =-          ServiceConfigImpl::Create(resolver_->channel_args(), *service_config);-      if (!result.service_config.ok()) {-        result.service_config = absl::UnavailableError(-            absl::StrCat(""failed to parse service config: "",-                         result.service_config.status().message()));-      }-    }-  }-  if (balancer_address_lookup_errors_.FieldHasErrors()) {-    result.resolution_note = std::string(-        balancer_address_lookup_errors_.status(""SRV Lookup error"").message());+    MaybePopulateServiceConfigLocked(Resolver::Result* result) {+  // This function is called only if we are returning addresses.  In that case,+  // we currently ignore TXT lookup failures.+  if (!service_config_json_.ok()) return;+  // TODO(roth): Consider differentiating between NXDOMAIN and other failures,","This TODO belongs above the previous line, because it's currently being bundled by the `!service_config_json_.ok()` case, not the `service_config_json_->empty()` case.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32632,1153781555,2023-03-30T20:58:58Z,src/core/ext/filters/client_channel/resolver/dns/event_engine/event_engine_client_channel_resolver.cc,"@@ -492,22 +463,31 @@ absl::optional<Resolver::Result> EventEngineClientChannelDNSResolver::                                    this);   Resolver::Result result;   result.args = resolver_->channel_args();-  NormalizeEmptyResultsToErrorsLocked();-  // If both addresses and balancer addresses failed, return an error for //-  // both addresses and service config.-  if (!addresses_.ok() && balancer_addresses_.empty()) {-    absl::Status status = GetResolutionFailureErrorMessageLocked();-    GRPC_EVENT_ENGINE_RESOLVER_TRACE(""%s"", status.ToString().c_str());+  // If both addresses and balancer addresses failed, return an error for both+  // addresses and service config.+  if (addresses_.empty() && balancer_addresses_.empty()) {+    absl::Status status = errors_.status(+        absl::StrCat(""errors resolving "", resolver_->name_to_resolve()),+        absl::StatusCode::kUnavailable);+    GRPC_EVENT_ENGINE_RESOLVER_TRACE(""%s"", status.message().data());     result.addresses = status;     result.service_config = status;     return std::move(result);   }+  if (!errors_.ok()) {+    result.resolution_note =+        std::string(errors_",This case is probably a good example of where it might be useful for `ValidationErrors` to be able to produce a string instead of a status.  I'd be fine with adding such a method on that class if you'd like.,
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32632,1153784589,2023-03-30T21:02:58Z,src/core/ext/filters/client_channel/resolver/dns/event_engine/service_config_helper.cc,"@@ -57,8 +55,8 @@ struct ServiceConfigChoice {   } }; -template <typename T>-bool vector_contains(const std::vector<T> v, const T& value) {+bool vector_contains(const std::vector<std::string> v,",This parameter should be a reference to avoid an unnecessary copy.,
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32632,1153797905,2023-03-30T21:19:21Z,src/core/ext/filters/client_channel/resolver/dns/event_engine/event_engine_client_channel_resolver.cc,"@@ -0,0 +1,517 @@+// Copyright 2023 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+#include <grpc/support/port_platform.h>++#include ""src/core/ext/filters/client_channel/resolver/dns/event_engine/event_engine_client_channel_resolver.h""++#include <inttypes.h>+#include <stddef.h>++#include <algorithm>+#include <chrono>+#include <initializer_list>+#include <memory>+#include <string>+#include <utility>+#include <vector>++#include ""absl/base/thread_annotations.h""+#include ""absl/cleanup/cleanup.h""+#include ""absl/container/flat_hash_set.h""+#include ""absl/status/status.h""+#include ""absl/status/statusor.h""+#include ""absl/strings/str_cat.h""+#include ""absl/strings/str_format.h""+#include ""absl/strings/strip.h""+#include ""absl/types/optional.h""++#include <grpc/event_engine/event_engine.h>+#include <grpc/grpc.h>+#include <grpc/support/log.h>++#include ""src/core/ext/filters/client_channel/lb_policy/grpclb/grpclb_balancer_addresses.h""+#include ""src/core/ext/filters/client_channel/resolver/dns/event_engine/service_config_helper.h""+#include ""src/core/ext/filters/client_channel/resolver/polling_resolver.h""+#include ""src/core/lib/backoff/backoff.h""+#include ""src/core/lib/channel/channel_args.h""+#include ""src/core/lib/debug/trace.h""+#include ""src/core/lib/event_engine/handle_containers.h""+#include ""src/core/lib/event_engine/resolved_address_internal.h""+#include ""src/core/lib/event_engine/utils.h""+#include ""src/core/lib/gprpp/debug_location.h""+#include ""src/core/lib/gprpp/ref_counted_ptr.h""+#include ""src/core/lib/gprpp/sync.h""+#include ""src/core/lib/gprpp/time.h""+#include ""src/core/lib/gprpp/validation_errors.h""+#include ""src/core/lib/iomgr/resolve_address.h""+#include ""src/core/lib/resolver/resolver.h""+#include ""src/core/lib/resolver/resolver_factory.h""+#include ""src/core/lib/resolver/server_address.h""+#include ""src/core/lib/service_config/service_config.h""+#include ""src/core/lib/service_config/service_config_impl.h""++// IWYU pragma: no_include <ratio>++namespace grpc_core {+namespace {++#define GRPC_DNS_INITIAL_CONNECT_BACKOFF_SECONDS 1+#define GRPC_DNS_RECONNECT_BACKOFF_MULTIPLIER 1.6+#define GRPC_DNS_RECONNECT_MAX_BACKOFF_SECONDS 120+#define GRPC_DNS_RECONNECT_JITTER 0.2+#define GRPC_DNS_DEFAULT_QUERY_TIMEOUT_MS 120000++using grpc_event_engine::experimental::EventEngine;+using grpc_event_engine::experimental::LookupTaskHandleSet;++// TODO(yijiem): Investigate adding a resolver test scenario where the first+// balancer hostname lookup result is an error, and the second contains valid+// addresses.++// TODO(hork): replace this with `dns_resolver` when all other resolver+// implementations are removed.+TraceFlag grpc_event_engine_client_channel_resolver_trace(+    false, ""event_engine_client_channel_resolver"");++#define GRPC_EVENT_ENGINE_RESOLVER_TRACE(format, ...)                    \+  if (GRPC_TRACE_FLAG_ENABLED(                                           \+          grpc_event_engine_client_channel_resolver_trace)) {            \+    gpr_log(GPR_DEBUG, ""(event_engine client channel resolver) "" format, \+            __VA_ARGS__);                                                \+  }++// ----------------------------------------------------------------------------+// EventEngineClientChannelDNSResolver+// ----------------------------------------------------------------------------+class EventEngineClientChannelDNSResolver : public PollingResolver {+ public:+  EventEngineClientChannelDNSResolver(ResolverArgs args,+                                      Duration min_time_between_resolutions);+  OrphanablePtr<Orphanable> StartRequest() override;++ private:+  // ----------------------------------------------------------------------------+  // EventEngineDNSRequestWrapper declaration+  // ----------------------------------------------------------------------------+  class EventEngineDNSRequestWrapper+      : public InternallyRefCounted<EventEngineDNSRequestWrapper> {+   public:+    EventEngineDNSRequestWrapper(+        RefCountedPtr<EventEngineClientChannelDNSResolver> resolver,+        std::unique_ptr<EventEngine::DNSResolver> event_engine_resolver);+    ~EventEngineDNSRequestWrapper() override;++    // Note that thread safety cannot be analyzed due to this being invoked from+    // OrphanablePtr<>, and there's no way to pass the lock annotation through+    // there.+    void Orphan() override ABSL_NO_THREAD_SAFETY_ANALYSIS;++   private:+    void OnHostnameResolved(+        absl::StatusOr<std::vector<EventEngine::ResolvedAddress>> addresses);+    void OnSRVResolved(+        absl::StatusOr<std::vector<EventEngine::DNSResolver::SRVRecord>>+            srv_records);+    void OnBalancerHostnamesResolved(+        std::string authority,+        absl::StatusOr<std::vector<EventEngine::ResolvedAddress>> addresses);+    void OnTXTResolved(absl::StatusOr<std::string> service_config);+    // Returns a Result if resolution is complete.+    // callers must release the lock and call OnRequestComplete if a Result is+    // returned. This is because OnRequestComplete may Orphan the resolver,+    // which requires taking the lock.+    absl::optional<Resolver::Result> OnResolvedLocked()+        ABSL_EXCLUSIVE_LOCKS_REQUIRED(on_resolved_mu_);+    // Helper method to populate server addresses on resolver result.+    void MaybePopulateAddressesLocked(Resolver::Result* result)+        ABSL_EXCLUSIVE_LOCKS_REQUIRED(on_resolved_mu_);+    // Helper method to populate balancer addresses on resolver result.+    void MaybePopulateBalancerAddressesLocked(Resolver::Result* result)+        ABSL_EXCLUSIVE_LOCKS_REQUIRED(on_resolved_mu_);+    // Helper method to populate service config on resolver result.+    void MaybePopulateServiceConfigLocked(Resolver::Result* result)+        ABSL_EXCLUSIVE_LOCKS_REQUIRED(on_resolved_mu_);++    RefCountedPtr<EventEngineClientChannelDNSResolver> resolver_;+    Mutex on_resolved_mu_;+    // Lookup callbacks+    absl::optional<EventEngine::DNSResolver::LookupTaskHandle> hostname_handle_+        ABSL_GUARDED_BY(on_resolved_mu_);+    absl::optional<EventEngine::DNSResolver::LookupTaskHandle> srv_handle_+        ABSL_GUARDED_BY(on_resolved_mu_);+    absl::optional<EventEngine::DNSResolver::LookupTaskHandle> txt_handle_+        ABSL_GUARDED_BY(on_resolved_mu_);+    LookupTaskHandleSet balancer_hostname_handles_+        ABSL_GUARDED_BY(on_resolved_mu_);+    // Output fields from requests.+    std::vector<EventEngine::ResolvedAddress> addresses_+        ABSL_GUARDED_BY(on_resolved_mu_);+    ServerAddressList balancer_addresses_ ABSL_GUARDED_BY(on_resolved_mu_);+    ValidationErrors errors_ ABSL_GUARDED_BY(on_resolved_mu_);+    absl::StatusOr<std::string> service_config_json_+        ABSL_GUARDED_BY(on_resolved_mu_);+    // Other internal state+    size_t number_of_balancer_hostnames_resolved_+        ABSL_GUARDED_BY(on_resolved_mu_) = 0;+    bool orphaned_ ABSL_GUARDED_BY(on_resolved_mu_) = false;+    std::unique_ptr<EventEngine::DNSResolver> event_engine_resolver_;+  };++  /// whether to request the service config+  const bool request_service_config_;+  // whether or not to enable SRV DNS queries+  const bool enable_srv_queries_;+  // timeout in milliseconds for active DNS queries+  EventEngine::Duration query_timeout_ms_;+  std::shared_ptr<EventEngine> event_engine_;+};++EventEngineClientChannelDNSResolver::EventEngineClientChannelDNSResolver(+    ResolverArgs args, Duration min_time_between_resolutions)+    : PollingResolver(std::move(args), min_time_between_resolutions,+                      BackOff::Options()+                          .set_initial_backoff(Duration::Milliseconds(+                              GRPC_DNS_INITIAL_CONNECT_BACKOFF_SECONDS * 1000))+                          .set_multiplier(GRPC_DNS_RECONNECT_BACKOFF_MULTIPLIER)+                          .set_jitter(GRPC_DNS_RECONNECT_JITTER)+                          .set_max_backoff(Duration::Milliseconds(+                              GRPC_DNS_RECONNECT_MAX_BACKOFF_SECONDS * 1000)),+                      &grpc_event_engine_client_channel_resolver_trace),+      request_service_config_(+          !channel_args()+               .GetBool(GRPC_ARG_SERVICE_CONFIG_DISABLE_RESOLUTION)+               .value_or(true)),+      enable_srv_queries_(channel_args()+                              .GetBool(GRPC_ARG_DNS_ENABLE_SRV_QUERIES)+                              .value_or(false)),+      // TODO(yijiem): decide if the ares channel arg timeout should be reused.+      query_timeout_ms_(std::chrono::milliseconds(+          std::max(0, channel_args()+                          .GetInt(GRPC_ARG_DNS_ARES_QUERY_TIMEOUT_MS)+                          .value_or(GRPC_DNS_DEFAULT_QUERY_TIMEOUT_MS)))),+      event_engine_(channel_args().GetObjectRef<EventEngine>()) {}++OrphanablePtr<Orphanable> EventEngineClientChannelDNSResolver::StartRequest() {+  return MakeOrphanable<EventEngineDNSRequestWrapper>(+      Ref(DEBUG_LOCATION, ""dns-resolving""),+      event_engine_->GetDNSResolver({/*dns_server=*/authority()}));+}++// ----------------------------------------------------------------------------+// EventEngineDNSRequestWrapper definition+// ----------------------------------------------------------------------------++EventEngineClientChannelDNSResolver::EventEngineDNSRequestWrapper::+    EventEngineDNSRequestWrapper(+        RefCountedPtr<EventEngineClientChannelDNSResolver> resolver,+        std::unique_ptr<EventEngine::DNSResolver> event_engine_resolver)+    : resolver_(std::move(resolver)),+      event_engine_resolver_(std::move(event_engine_resolver)) {+  // Locking to prevent completion before all records are queried+  MutexLock lock(&on_resolved_mu_);+  hostname_handle_ = event_engine_resolver_->LookupHostname(+      [self = Ref(DEBUG_LOCATION, ""OnHostnameResolved"")](+          absl::StatusOr<std::vector<EventEngine::ResolvedAddress>> addresses) {+        self->OnHostnameResolved(std::move(addresses));+      },+      resolver_->name_to_resolve(), kDefaultSecurePort,+      resolver_->query_timeout_ms_);+  GRPC_EVENT_ENGINE_RESOLVER_TRACE(+      ""DNSResolver::%p Started resolving hostname. Handle::%s"", resolver_.get(),+      HandleToString(*hostname_handle_).c_str());+  if (resolver_->enable_srv_queries_) {+    srv_handle_ = event_engine_resolver_->LookupSRV(+        [self = Ref(DEBUG_LOCATION, ""OnSRVResolved"")](+            absl::StatusOr<std::vector<EventEngine::DNSResolver::SRVRecord>>+                srv_records) { self->OnSRVResolved(std::move(srv_records)); },+        resolver_->name_to_resolve(), resolver_->query_timeout_ms_);+    GRPC_EVENT_ENGINE_RESOLVER_TRACE(+        ""DNSResolver::%p Started resolving SRV. Handle::%s"", resolver_.get(),+        HandleToString(*srv_handle_).c_str());+  }+  if (resolver_->request_service_config_) {+    txt_handle_ = event_engine_resolver_->LookupTXT(+        [self = Ref(DEBUG_LOCATION, ""OnTXTResolved"")](+            absl::StatusOr<std::string> service_config) {+          self->OnTXTResolved(std::move(service_config));+        },+        resolver_->name_to_resolve(), resolver_->query_timeout_ms_);","I just noticed an issue here in terms of the EE API semantics for TXT record lookups.  [gRFC A2](https://github.com/grpc/proposal/blob/master/A2-service-configs-in-dns.md#encoding-in-dns-txt-records) says that we encode the service config in a TXT record whose name is the same as the hostname but that has a `_grpc_config.` prefix.  We're not passing in that prefix here, which implies that we're assuming that the EE impl will add this prefix.  However, I think we should actually add the prefix here instead of in the EE impl, because the EE TXT lookup API is intended to be a generic mechanism for DNS TXT lookups, not something specific to gRPC service config.CC @yijiem ",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32632,1153800215,2023-03-30T21:22:30Z,src/core/ext/filters/client_channel/resolver/dns/event_engine/event_engine_client_channel_resolver.cc,"@@ -0,0 +1,517 @@+// Copyright 2023 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+#include <grpc/support/port_platform.h>++#include ""src/core/ext/filters/client_channel/resolver/dns/event_engine/event_engine_client_channel_resolver.h""++#include <inttypes.h>+#include <stddef.h>++#include <algorithm>+#include <chrono>+#include <initializer_list>+#include <memory>+#include <string>+#include <utility>+#include <vector>++#include ""absl/base/thread_annotations.h""+#include ""absl/cleanup/cleanup.h""+#include ""absl/container/flat_hash_set.h""+#include ""absl/status/status.h""+#include ""absl/status/statusor.h""+#include ""absl/strings/str_cat.h""+#include ""absl/strings/str_format.h""+#include ""absl/strings/strip.h""+#include ""absl/types/optional.h""++#include <grpc/event_engine/event_engine.h>+#include <grpc/grpc.h>+#include <grpc/support/log.h>++#include ""src/core/ext/filters/client_channel/lb_policy/grpclb/grpclb_balancer_addresses.h""+#include ""src/core/ext/filters/client_channel/resolver/dns/event_engine/service_config_helper.h""+#include ""src/core/ext/filters/client_channel/resolver/polling_resolver.h""+#include ""src/core/lib/backoff/backoff.h""+#include ""src/core/lib/channel/channel_args.h""+#include ""src/core/lib/debug/trace.h""+#include ""src/core/lib/event_engine/handle_containers.h""+#include ""src/core/lib/event_engine/resolved_address_internal.h""+#include ""src/core/lib/event_engine/utils.h""+#include ""src/core/lib/gprpp/debug_location.h""+#include ""src/core/lib/gprpp/ref_counted_ptr.h""+#include ""src/core/lib/gprpp/sync.h""+#include ""src/core/lib/gprpp/time.h""+#include ""src/core/lib/gprpp/validation_errors.h""+#include ""src/core/lib/iomgr/resolve_address.h""+#include ""src/core/lib/resolver/resolver.h""+#include ""src/core/lib/resolver/resolver_factory.h""+#include ""src/core/lib/resolver/server_address.h""+#include ""src/core/lib/service_config/service_config.h""+#include ""src/core/lib/service_config/service_config_impl.h""++// IWYU pragma: no_include <ratio>++namespace grpc_core {+namespace {++#define GRPC_DNS_INITIAL_CONNECT_BACKOFF_SECONDS 1+#define GRPC_DNS_RECONNECT_BACKOFF_MULTIPLIER 1.6+#define GRPC_DNS_RECONNECT_MAX_BACKOFF_SECONDS 120+#define GRPC_DNS_RECONNECT_JITTER 0.2+#define GRPC_DNS_DEFAULT_QUERY_TIMEOUT_MS 120000++using grpc_event_engine::experimental::EventEngine;+using grpc_event_engine::experimental::LookupTaskHandleSet;++// TODO(yijiem): Investigate adding a resolver test scenario where the first+// balancer hostname lookup result is an error, and the second contains valid+// addresses.++// TODO(hork): replace this with `dns_resolver` when all other resolver+// implementations are removed.+TraceFlag grpc_event_engine_client_channel_resolver_trace(+    false, ""event_engine_client_channel_resolver"");++#define GRPC_EVENT_ENGINE_RESOLVER_TRACE(format, ...)                    \+  if (GRPC_TRACE_FLAG_ENABLED(                                           \+          grpc_event_engine_client_channel_resolver_trace)) {            \+    gpr_log(GPR_DEBUG, ""(event_engine client channel resolver) "" format, \+            __VA_ARGS__);                                                \+  }++// ----------------------------------------------------------------------------+// EventEngineClientChannelDNSResolver+// ----------------------------------------------------------------------------+class EventEngineClientChannelDNSResolver : public PollingResolver {+ public:+  EventEngineClientChannelDNSResolver(ResolverArgs args,+                                      Duration min_time_between_resolutions);+  OrphanablePtr<Orphanable> StartRequest() override;++ private:+  // ----------------------------------------------------------------------------+  // EventEngineDNSRequestWrapper declaration+  // ----------------------------------------------------------------------------+  class EventEngineDNSRequestWrapper+      : public InternallyRefCounted<EventEngineDNSRequestWrapper> {+   public:+    EventEngineDNSRequestWrapper(+        RefCountedPtr<EventEngineClientChannelDNSResolver> resolver,+        std::unique_ptr<EventEngine::DNSResolver> event_engine_resolver);+    ~EventEngineDNSRequestWrapper() override;++    // Note that thread safety cannot be analyzed due to this being invoked from+    // OrphanablePtr<>, and there's no way to pass the lock annotation through+    // there.+    void Orphan() override ABSL_NO_THREAD_SAFETY_ANALYSIS;++   private:+    void OnHostnameResolved(+        absl::StatusOr<std::vector<EventEngine::ResolvedAddress>> addresses);+    void OnSRVResolved(+        absl::StatusOr<std::vector<EventEngine::DNSResolver::SRVRecord>>+            srv_records);+    void OnBalancerHostnamesResolved(+        std::string authority,+        absl::StatusOr<std::vector<EventEngine::ResolvedAddress>> addresses);+    void OnTXTResolved(absl::StatusOr<std::string> service_config);+    // Returns a Result if resolution is complete.+    // callers must release the lock and call OnRequestComplete if a Result is+    // returned. This is because OnRequestComplete may Orphan the resolver,+    // which requires taking the lock.+    absl::optional<Resolver::Result> OnResolvedLocked()+        ABSL_EXCLUSIVE_LOCKS_REQUIRED(on_resolved_mu_);+    // Helper method to populate server addresses on resolver result.+    void MaybePopulateAddressesLocked(Resolver::Result* result)+        ABSL_EXCLUSIVE_LOCKS_REQUIRED(on_resolved_mu_);+    // Helper method to populate balancer addresses on resolver result.+    void MaybePopulateBalancerAddressesLocked(Resolver::Result* result)+        ABSL_EXCLUSIVE_LOCKS_REQUIRED(on_resolved_mu_);+    // Helper method to populate service config on resolver result.+    void MaybePopulateServiceConfigLocked(Resolver::Result* result)+        ABSL_EXCLUSIVE_LOCKS_REQUIRED(on_resolved_mu_);++    RefCountedPtr<EventEngineClientChannelDNSResolver> resolver_;+    Mutex on_resolved_mu_;+    // Lookup callbacks+    absl::optional<EventEngine::DNSResolver::LookupTaskHandle> hostname_handle_+        ABSL_GUARDED_BY(on_resolved_mu_);+    absl::optional<EventEngine::DNSResolver::LookupTaskHandle> srv_handle_+        ABSL_GUARDED_BY(on_resolved_mu_);+    absl::optional<EventEngine::DNSResolver::LookupTaskHandle> txt_handle_+        ABSL_GUARDED_BY(on_resolved_mu_);+    LookupTaskHandleSet balancer_hostname_handles_+        ABSL_GUARDED_BY(on_resolved_mu_);+    // Output fields from requests.+    std::vector<EventEngine::ResolvedAddress> addresses_+        ABSL_GUARDED_BY(on_resolved_mu_);+    ServerAddressList balancer_addresses_ ABSL_GUARDED_BY(on_resolved_mu_);+    ValidationErrors errors_ ABSL_GUARDED_BY(on_resolved_mu_);+    absl::StatusOr<std::string> service_config_json_+        ABSL_GUARDED_BY(on_resolved_mu_);+    // Other internal state+    size_t number_of_balancer_hostnames_resolved_+        ABSL_GUARDED_BY(on_resolved_mu_) = 0;+    bool orphaned_ ABSL_GUARDED_BY(on_resolved_mu_) = false;+    std::unique_ptr<EventEngine::DNSResolver> event_engine_resolver_;+  };++  /// whether to request the service config+  const bool request_service_config_;+  // whether or not to enable SRV DNS queries+  const bool enable_srv_queries_;+  // timeout in milliseconds for active DNS queries+  EventEngine::Duration query_timeout_ms_;+  std::shared_ptr<EventEngine> event_engine_;+};++EventEngineClientChannelDNSResolver::EventEngineClientChannelDNSResolver(+    ResolverArgs args, Duration min_time_between_resolutions)+    : PollingResolver(std::move(args), min_time_between_resolutions,+                      BackOff::Options()+                          .set_initial_backoff(Duration::Milliseconds(+                              GRPC_DNS_INITIAL_CONNECT_BACKOFF_SECONDS * 1000))+                          .set_multiplier(GRPC_DNS_RECONNECT_BACKOFF_MULTIPLIER)+                          .set_jitter(GRPC_DNS_RECONNECT_JITTER)+                          .set_max_backoff(Duration::Milliseconds(+                              GRPC_DNS_RECONNECT_MAX_BACKOFF_SECONDS * 1000)),+                      &grpc_event_engine_client_channel_resolver_trace),+      request_service_config_(+          !channel_args()+               .GetBool(GRPC_ARG_SERVICE_CONFIG_DISABLE_RESOLUTION)+               .value_or(true)),+      enable_srv_queries_(channel_args()+                              .GetBool(GRPC_ARG_DNS_ENABLE_SRV_QUERIES)+                              .value_or(false)),+      // TODO(yijiem): decide if the ares channel arg timeout should be reused.+      query_timeout_ms_(std::chrono::milliseconds(+          std::max(0, channel_args()+                          .GetInt(GRPC_ARG_DNS_ARES_QUERY_TIMEOUT_MS)+                          .value_or(GRPC_DNS_DEFAULT_QUERY_TIMEOUT_MS)))),+      event_engine_(channel_args().GetObjectRef<EventEngine>()) {}++OrphanablePtr<Orphanable> EventEngineClientChannelDNSResolver::StartRequest() {+  return MakeOrphanable<EventEngineDNSRequestWrapper>(+      Ref(DEBUG_LOCATION, ""dns-resolving""),+      event_engine_->GetDNSResolver({/*dns_server=*/authority()}));+}++// ----------------------------------------------------------------------------+// EventEngineDNSRequestWrapper definition+// ----------------------------------------------------------------------------++EventEngineClientChannelDNSResolver::EventEngineDNSRequestWrapper::+    EventEngineDNSRequestWrapper(+        RefCountedPtr<EventEngineClientChannelDNSResolver> resolver,+        std::unique_ptr<EventEngine::DNSResolver> event_engine_resolver)+    : resolver_(std::move(resolver)),+      event_engine_resolver_(std::move(event_engine_resolver)) {+  // Locking to prevent completion before all records are queried+  MutexLock lock(&on_resolved_mu_);+  hostname_handle_ = event_engine_resolver_->LookupHostname(+      [self = Ref(DEBUG_LOCATION, ""OnHostnameResolved"")](+          absl::StatusOr<std::vector<EventEngine::ResolvedAddress>> addresses) {+        self->OnHostnameResolved(std::move(addresses));+      },+      resolver_->name_to_resolve(), kDefaultSecurePort,+      resolver_->query_timeout_ms_);+  GRPC_EVENT_ENGINE_RESOLVER_TRACE(+      ""DNSResolver::%p Started resolving hostname. Handle::%s"", resolver_.get(),+      HandleToString(*hostname_handle_).c_str());+  if (resolver_->enable_srv_queries_) {+    srv_handle_ = event_engine_resolver_->LookupSRV(+        [self = Ref(DEBUG_LOCATION, ""OnSRVResolved"")](+            absl::StatusOr<std::vector<EventEngine::DNSResolver::SRVRecord>>+                srv_records) { self->OnSRVResolved(std::move(srv_records)); },+        resolver_->name_to_resolve(), resolver_->query_timeout_ms_);+    GRPC_EVENT_ENGINE_RESOLVER_TRACE(+        ""DNSResolver::%p Started resolving SRV. Handle::%s"", resolver_.get(),+        HandleToString(*srv_handle_).c_str());+  }+  if (resolver_->request_service_config_) {+    txt_handle_ = event_engine_resolver_->LookupTXT(+        [self = Ref(DEBUG_LOCATION, ""OnTXTResolved"")](+            absl::StatusOr<std::string> service_config) {+          self->OnTXTResolved(std::move(service_config));+        },+        resolver_->name_to_resolve(), resolver_->query_timeout_ms_);+    GRPC_EVENT_ENGINE_RESOLVER_TRACE(+        ""DNSResolver::%p Started resolving TXT. Handle::%s"", resolver_.get(),+        HandleToString(*txt_handle_).c_str());+  }+}++EventEngineClientChannelDNSResolver::EventEngineDNSRequestWrapper::+    ~EventEngineDNSRequestWrapper() {+  resolver_.reset(DEBUG_LOCATION, ""dns-resolving"");+}++void EventEngineClientChannelDNSResolver::EventEngineDNSRequestWrapper::+    Orphan() {+  {+    MutexLock lock(&on_resolved_mu_);+    orphaned_ = true;+    // Event if cancellation fails here, OnResolvedLocked will return early, and+    // the resolver will never see a completed request.+    if (hostname_handle_.has_value()) {+      event_engine_resolver_->CancelLookup(*hostname_handle_);+    }+    if (srv_handle_.has_value()) {+      event_engine_resolver_->CancelLookup(*srv_handle_);+    }+    for (const auto& handle : balancer_hostname_handles_) {+      event_engine_resolver_->CancelLookup(handle);+    }+    if (txt_handle_.has_value()) {+      event_engine_resolver_->CancelLookup(*txt_handle_);+    }+  }+  Unref(DEBUG_LOCATION, ""Orphan"");+}++void EventEngineClientChannelDNSResolver::EventEngineDNSRequestWrapper::+    OnHostnameResolved(+        absl::StatusOr<std::vector<EventEngine::ResolvedAddress>> addresses) {+  ValidationErrors::ScopedField field(&errors_, ""hostname lookup"");+  absl::optional<Resolver::Result> result;+  {+    MutexLock lock(&on_resolved_mu_);+    if (orphaned_) return;+    hostname_handle_.reset();+    if (!addresses.ok()) {+      errors_.AddError(addresses.status().message());+    } else {+      addresses_ = std::move(*addresses);+    }+    result = OnResolvedLocked();+  }+  if (result.has_value()) {+    resolver_->OnRequestComplete(std::move(*result));+  }+}++void EventEngineClientChannelDNSResolver::EventEngineDNSRequestWrapper::+    OnSRVResolved(+        absl::StatusOr<std::vector<EventEngine::DNSResolver::SRVRecord>>+            srv_records) {+  ValidationErrors::ScopedField field(&errors_, ""srv lookup"");+  absl::optional<Resolver::Result> result;+  auto cleanup = absl::MakeCleanup([&]() {+    if (result.has_value()) {+      resolver_->OnRequestComplete(std::move(*result));+    }+  });+  MutexLock lock(&on_resolved_mu_);+  if (orphaned_) return;+  srv_handle_.reset();+  if (!srv_records.ok()) {+    // An error has occurred, finish resolving.+    errors_.AddError(srv_records.status().message());+    result = OnResolvedLocked();+    return;+  }+  // Do a subsequent hostname query since SRV records were returned+  for (const auto& srv_record : *srv_records) {+    balancer_hostname_handles_.insert(event_engine_resolver_->LookupHostname(+        [host = srv_record.host,+         self = Ref(DEBUG_LOCATION, ""OnBalancerHostnamesResolved"")](+            absl::StatusOr<std::vector<EventEngine::ResolvedAddress>>+                new_balancer_addresses) {+          self->OnBalancerHostnamesResolved(host,+                                            std::move(new_balancer_addresses));+        },+        srv_record.host, std::to_string(srv_record.port),+        resolver_->query_timeout_ms_));+    GRPC_EVENT_ENGINE_RESOLVER_TRACE(+        ""DNSResolver::%p Started resolving balancer hostname %s:%d"",+        resolver_.get(), srv_record.host.c_str(), srv_record.port);+  }+}++void EventEngineClientChannelDNSResolver::EventEngineDNSRequestWrapper::+    OnBalancerHostnamesResolved(+        std::string authority,+        absl::StatusOr<std::vector<EventEngine::ResolvedAddress>>+            new_balancer_addresses) {+  ValidationErrors::ScopedField field(&errors_, ""balancer hostname lookup"");+  absl::optional<Resolver::Result> result;+  auto cleanup = absl::MakeCleanup([&]() {+    if (result.has_value()) {+      resolver_->OnRequestComplete(std::move(*result));+    }+  });+  MutexLock lock(&on_resolved_mu_);+  if (orphaned_) return;+  ++number_of_balancer_hostnames_resolved_;+  if (!new_balancer_addresses.ok()) {+    // An error has occurred, finish resolving.+    errors_.AddError(absl::StrCat(authority, "": "",+                                  new_balancer_addresses.status().message()));+  } else {+    // Capture the addresses and finish resolving.+    balancer_addresses_.reserve(balancer_addresses_.size() ++                                new_balancer_addresses->size());+    auto srv_channel_args =+        resolver_->channel_args().Set(GRPC_ARG_DEFAULT_AUTHORITY, authority);+    for (const auto& addr : *new_balancer_addresses) {+      balancer_addresses_.emplace_back(CreateGRPCResolvedAddress(addr),+                                       srv_channel_args);+    }+  }+  result = OnResolvedLocked();+}++void EventEngineClientChannelDNSResolver::EventEngineDNSRequestWrapper::+    OnTXTResolved(absl::StatusOr<std::string> service_config) {+  ValidationErrors::ScopedField field(&errors_, ""txt lookup"");+  absl::optional<Resolver::Result> result;+  {+    MutexLock lock(&on_resolved_mu_);+    if (orphaned_) return;+    GPR_ASSERT(txt_handle_.has_value());+    txt_handle_.reset();+    if (!service_config.ok()) {+      errors_.AddError(service_config.status().message());+    }+    service_config_json_ = std::move(service_config);","Similar to my comment above, [gRFC A2](https://github.com/grpc/proposal/blob/master/A2-service-configs-in-dns.md#encoding-in-dns-txt-records) says that the content of the TXT record will start with `grpc_config=`.  We're not stripping off that prefix here, which implies that we're assuming that this will be stripped off by the EE impl before returning.  However, since the EE API is supposed to be a generic mechanism for TXT record lookups, not something specific to gRPC service config, I think the EE impl should instead return that prefix as part of the result, and we should strip it off here.CC @yijiem ",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32603,1153808678,2023-03-30T21:33:32Z,test/core/end2end/end2end_tests.cc,,"Please remove this file from the .gitattributes file, since it's no longer automatically generated and should therefore not be skipped in diffs.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32603,1153830160,2023-03-30T22:00:50Z,test/core/end2end/tests/retry_disabled.cc,"@@ -16,193 +16,75 @@ // // -#include <string.h>+#include ""absl/types/optional.h""+#include ""gtest/gtest.h"" -#include <functional>-#include <memory>--#include <grpc/byte_buffer.h> #include <grpc/grpc.h>-#include <grpc/impl/propagation_bits.h>-#include <grpc/slice.h> #include <grpc/status.h>-#include <grpc/support/alloc.h>-#include <grpc/support/log.h>-#include <grpc/support/time.h>  #include ""src/core/lib/channel/channel_args.h""-#include ""src/core/lib/gpr/useful.h""-#include ""test/core/end2end/cq_verifier.h""+#include ""src/core/lib/gprpp/time.h"" #include ""test/core/end2end/end2end_tests.h""-#include ""test/core/util/test_config.h"" -static std::unique_ptr<CoreTestFixture> begin_test(-    const CoreTestConfiguration& config, const char* test_name,-    grpc_channel_args* client_args, grpc_channel_args* server_args) {-  gpr_log(GPR_INFO, ""Running test: %s/%s"", test_name, config.name);-  auto f = config.create_fixture(grpc_core::ChannelArgs::FromC(client_args),-                                 grpc_core::ChannelArgs::FromC(server_args));-  f->InitServer(grpc_core::ChannelArgs::FromC(server_args));-  f->InitClient(grpc_core::ChannelArgs::FromC(client_args));-  return f;-}+namespace grpc_core {+namespace {  // Tests that we don't retry when retries are disabled via the // GRPC_ARG_ENABLE_RETRIES channel arg, even when there is retry // configuration in the service config. // - 1 retry allowed for ABORTED status // - first attempt returns ABORTED but does not retry-static void test_retry_disabled(const CoreTestConfiguration& config) {-  grpc_call* c;-  grpc_call* s;-  grpc_op ops[6];-  grpc_op* op;-  grpc_metadata_array initial_metadata_recv;-  grpc_metadata_array trailing_metadata_recv;-  grpc_metadata_array request_metadata_recv;-  grpc_call_details call_details;-  grpc_slice request_payload_slice = grpc_slice_from_static_string(""foo"");-  grpc_slice response_payload_slice = grpc_slice_from_static_string(""bar"");-  grpc_byte_buffer* request_payload =-      grpc_raw_byte_buffer_create(&request_payload_slice, 1);-  grpc_byte_buffer* response_payload =-      grpc_raw_byte_buffer_create(&response_payload_slice, 1);-  grpc_byte_buffer* request_payload_recv = nullptr;-  grpc_byte_buffer* response_payload_recv = nullptr;-  grpc_status_code status;-  grpc_call_error error;-  grpc_slice details;-  int was_cancelled = 2;-  char* peer;--  grpc_arg args[] = {-      grpc_channel_arg_integer_create(-          const_cast<char*>(GRPC_ARG_ENABLE_RETRIES), 0),-      grpc_channel_arg_string_create(-          const_cast<char*>(GRPC_ARG_SERVICE_CONFIG),-          const_cast<char*>(-              ""{\n""-              ""  \""methodConfig\"": [ {\n""-              ""    \""name\"": [\n""-              ""      { \""service\"": \""service\"", \""method\"": \""method\"" }\n""-              ""    ],\n""-              ""    \""retryPolicy\"": {\n""-              ""      \""maxAttempts\"": 2,\n""-              ""      \""initialBackoff\"": \""1s\"",\n""-              ""      \""maxBackoff\"": \""120s\"",\n""-              ""      \""backoffMultiplier\"": 1.6,\n""-              ""      \""retryableStatusCodes\"": [ \""ABORTED\"" ]\n""-              ""    }\n""-              ""  } ]\n""-              ""}"")),-  };-  grpc_channel_args client_args = {GPR_ARRAY_SIZE(args), args};-  auto f = begin_test(config, ""retry_disabled"", &client_args, nullptr);--  grpc_core::CqVerifier cqv(f->cq());--  gpr_timespec deadline = grpc_timeout_seconds_to_deadline(5);-  c = grpc_channel_create_call(f->client(), nullptr, GRPC_PROPAGATE_DEFAULTS,-                               f->cq(),-                               grpc_slice_from_static_string(""/service/method""),-                               nullptr, deadline, nullptr);-  GPR_ASSERT(c);--  peer = grpc_call_get_peer(c);-  GPR_ASSERT(peer != nullptr);-  gpr_log(GPR_DEBUG, ""client_peer_before_call=%s"", peer);-  gpr_free(peer);--  grpc_metadata_array_init(&initial_metadata_recv);-  grpc_metadata_array_init(&trailing_metadata_recv);-  grpc_metadata_array_init(&request_metadata_recv);-  grpc_call_details_init(&call_details);-  grpc_slice status_details = grpc_slice_from_static_string(""xyz"");--  memset(ops, 0, sizeof(ops));-  op = ops;-  op->op = GRPC_OP_SEND_INITIAL_METADATA;-  op->data.send_initial_metadata.count = 0;-  op++;-  op->op = GRPC_OP_SEND_MESSAGE;-  op->data.send_message.send_message = request_payload;-  op++;-  op->op = GRPC_OP_RECV_MESSAGE;-  op->data.recv_message.recv_message = &response_payload_recv;-  op++;-  op->op = GRPC_OP_SEND_CLOSE_FROM_CLIENT;-  op++;-  op->op = GRPC_OP_RECV_INITIAL_METADATA;-  op->data.recv_initial_metadata.recv_initial_metadata = &initial_metadata_recv;-  op++;-  op->op = GRPC_OP_RECV_STATUS_ON_CLIENT;-  op->data.recv_status_on_client.trailing_metadata = &trailing_metadata_recv;-  op->data.recv_status_on_client.status = &status;-  op->data.recv_status_on_client.status_details = &details;-  op++;-  error = grpc_call_start_batch(c, ops, static_cast<size_t>(op - ops),-                                grpc_core::CqVerifier::tag(1), nullptr);-  GPR_ASSERT(GRPC_CALL_OK == error);--  error = grpc_server_request_call(f->server(), &s, &call_details,-                                   &request_metadata_recv, f->cq(), f->cq(),-                                   grpc_core::CqVerifier::tag(101));-  GPR_ASSERT(GRPC_CALL_OK == error);-  cqv.Expect(grpc_core::CqVerifier::tag(101), true);-  cqv.Verify();--  peer = grpc_call_get_peer(s);-  GPR_ASSERT(peer != nullptr);-  gpr_log(GPR_DEBUG, ""server_peer=%s"", peer);-  gpr_free(peer);-  peer = grpc_call_get_peer(c);-  GPR_ASSERT(peer != nullptr);-  gpr_log(GPR_DEBUG, ""client_peer=%s"", peer);-  gpr_free(peer);--  memset(ops, 0, sizeof(ops));-  op = ops;-  op->op = GRPC_OP_SEND_INITIAL_METADATA;-  op->data.send_initial_metadata.count = 0;-  op++;-  op->op = GRPC_OP_SEND_STATUS_FROM_SERVER;-  op->data.send_status_from_server.trailing_metadata_count = 0;-  op->data.send_status_from_server.status = GRPC_STATUS_ABORTED;-  op->data.send_status_from_server.status_details = &status_details;-  op++;-  op->op = GRPC_OP_RECV_CLOSE_ON_SERVER;-  op->data.recv_close_on_server.cancelled = &was_cancelled;-  op++;-  error = grpc_call_start_batch(s, ops, static_cast<size_t>(op - ops),-                                grpc_core::CqVerifier::tag(102), nullptr);-  GPR_ASSERT(GRPC_CALL_OK == error);--  cqv.Expect(grpc_core::CqVerifier::tag(102), true);-  cqv.Expect(grpc_core::CqVerifier::tag(1), true);-  cqv.Verify();--  GPR_ASSERT(status == GRPC_STATUS_ABORTED);-  GPR_ASSERT(0 == grpc_slice_str_cmp(details, ""xyz""));-  GPR_ASSERT(0 == grpc_slice_str_cmp(call_details.method, ""/service/method""));-  GPR_ASSERT(was_cancelled == 0);--  grpc_slice_unref(details);-  grpc_metadata_array_destroy(&initial_metadata_recv);-  grpc_metadata_array_destroy(&trailing_metadata_recv);-  grpc_metadata_array_destroy(&request_metadata_recv);-  grpc_call_details_destroy(&call_details);-  grpc_byte_buffer_destroy(request_payload);-  grpc_byte_buffer_destroy(response_payload);-  grpc_byte_buffer_destroy(request_payload_recv);-  grpc_byte_buffer_destroy(response_payload_recv);--  grpc_call_unref(c);-  grpc_call_unref(s);-}--void retry_disabled(const CoreTestConfiguration& config) {-  GPR_ASSERT(config.feature_mask & FEATURE_MASK_SUPPORTS_CLIENT_CHANNEL);-  test_retry_disabled(config);+TEST_P(RetryTest, RetryDisabled) {+  InitServer(ChannelArgs());+  InitClient(+      ChannelArgs()+          .Set(GRPC_ARG_ENABLE_RETRIES, false)+          .Set(GRPC_ARG_SERVICE_CONFIG,+               ""{\n""+               ""  \""methodConfig\"": [ {\n""+               ""    \""name\"": [\n""+               ""      { \""service\"": \""service\"", \""method\"": \""method\"" }\n""+               ""    ],\n""+               ""    \""retryPolicy\"": {\n""+               ""      \""maxAttempts\"": 2,\n""+               ""      \""initialBackoff\"": \""1s\"",\n""+               ""      \""maxBackoff\"": \""120s\"",\n""+               ""      \""backoffMultiplier\"": 1.6,\n""+               ""      \""retryableStatusCodes\"": [ \""ABORTED\"" ]\n""+               ""    }\n""+               ""  } ]\n""+               ""}""));+  auto c =+      NewClientCall(""/service/method"").Timeout(Duration::Seconds(5)).Create();+  EXPECT_NE(c.GetPeer(), absl::nullopt);+  IncomingMetadata server_initial_metadata;+  IncomingMessage server_message;+  IncomingStatusOnClient server_status;+  c.NewBatch(1)+      .SendInitialMetadata({})+      .SendMessage(""foo"")+      .RecvMessage(server_message)+      .RecvInitialMetadata(server_initial_metadata)","Not sure if it matters, but the original code had recv_initial_metadata after send_close_from_server, and here it's before it.",
672669,sergiitk,https://api.github.com/repos/grpc/grpc/pulls/32753,1153834290,2023-03-30T22:05:24Z,.github/pr_title_checker_config.json,"@@ -1,6 +1,6 @@ {     ""LABEL"": {-        ""name"": ""title needs formatting"",+        ""name"": ""[pr-title] Should be like this"",","```suggestion        ""name"": ""PR title is missing [component]"",```Maybe something like this?",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32603,1153843316,2023-03-30T22:17:04Z,test/core/end2end/tests/retry_exceeds_buffer_size_in_initial_batch.cc,"@@ -16,197 +16,76 @@ // // -#include <string.h>+#include ""absl/types/optional.h""+#include ""gtest/gtest.h"" -#include <functional>-#include <memory>--#include <grpc/byte_buffer.h> #include <grpc/grpc.h>-#include <grpc/impl/propagation_bits.h>-#include <grpc/slice.h> #include <grpc/status.h>-#include <grpc/support/alloc.h>-#include <grpc/support/log.h>-#include <grpc/support/time.h>  #include ""src/core/lib/channel/channel_args.h""-#include ""src/core/lib/gpr/useful.h""-#include ""test/core/end2end/cq_verifier.h""+#include ""src/core/lib/gprpp/time.h"" #include ""test/core/end2end/end2end_tests.h""-#include ""test/core/util/test_config.h"" -static std::unique_ptr<CoreTestFixture> begin_test(-    const CoreTestConfiguration& config, const char* test_name,-    grpc_channel_args* client_args, grpc_channel_args* server_args) {-  gpr_log(GPR_INFO, ""Running test: %s/%s"", test_name, config.name);-  auto f = config.create_fixture(grpc_core::ChannelArgs::FromC(client_args),-                                 grpc_core::ChannelArgs::FromC(server_args));-  f->InitServer(grpc_core::ChannelArgs::FromC(server_args));-  f->InitClient(grpc_core::ChannelArgs::FromC(client_args));-  return f;-}+namespace grpc_core {+namespace {  // Tests that we don't make any further attempts after we exceed the // max buffer size. // - 1 retry allowed for ABORTED status // - buffer size set to 2 bytes // - client sends a 3-byte message // - first attempt gets ABORTED but is not retried-static void test_retry_exceeds_buffer_size_in_initial_batch(-    const CoreTestConfiguration& config) {-  grpc_call* c;-  grpc_call* s;-  grpc_op ops[6];-  grpc_op* op;-  grpc_metadata_array initial_metadata_recv;-  grpc_metadata_array trailing_metadata_recv;-  grpc_metadata_array request_metadata_recv;-  grpc_call_details call_details;-  grpc_slice request_payload_slice = grpc_slice_from_static_string(""foo"");-  grpc_slice response_payload_slice = grpc_slice_from_static_string(""bar"");-  grpc_byte_buffer* request_payload =-      grpc_raw_byte_buffer_create(&request_payload_slice, 1);-  grpc_byte_buffer* response_payload =-      grpc_raw_byte_buffer_create(&response_payload_slice, 1);-  grpc_byte_buffer* request_payload_recv = nullptr;-  grpc_byte_buffer* response_payload_recv = nullptr;-  grpc_status_code status;-  grpc_call_error error;-  grpc_slice details;-  int was_cancelled = 2;-  char* peer;--  grpc_arg args[] = {-      grpc_channel_arg_string_create(-          const_cast<char*>(GRPC_ARG_SERVICE_CONFIG),-          const_cast<char*>(-              ""{\n""-              ""  \""methodConfig\"": [ {\n""-              ""    \""name\"": [\n""-              ""      { \""service\"": \""service\"", \""method\"": \""method\"" }\n""-              ""    ],\n""-              ""    \""retryPolicy\"": {\n""-              ""      \""maxAttempts\"": 2,\n""-              ""      \""initialBackoff\"": \""1s\"",\n""-              ""      \""maxBackoff\"": \""120s\"",\n""-              ""      \""backoffMultiplier\"": 1.6,\n""-              ""      \""retryableStatusCodes\"": [ \""ABORTED\"" ]\n""-              ""    }\n""-              ""  } ]\n""-              ""}"")),-      grpc_channel_arg_integer_create(-          const_cast<char*>(GRPC_ARG_PER_RPC_RETRY_BUFFER_SIZE), 2),-  };-  grpc_channel_args client_args = {GPR_ARRAY_SIZE(args), args};-  auto f = begin_test(config, ""retry_exceeds_buffer_size_in_initial_batch"",-                      &client_args, nullptr);--  grpc_core::CqVerifier cqv(f->cq());--  gpr_timespec deadline = grpc_timeout_seconds_to_deadline(5);-  c = grpc_channel_create_call(f->client(), nullptr, GRPC_PROPAGATE_DEFAULTS,-                               f->cq(),-                               grpc_slice_from_static_string(""/service/method""),-                               nullptr, deadline, nullptr);-  GPR_ASSERT(c);--  peer = grpc_call_get_peer(c);-  GPR_ASSERT(peer != nullptr);-  gpr_log(GPR_DEBUG, ""client_peer_before_call=%s"", peer);-  gpr_free(peer);--  grpc_metadata_array_init(&initial_metadata_recv);-  grpc_metadata_array_init(&trailing_metadata_recv);-  grpc_metadata_array_init(&request_metadata_recv);-  grpc_call_details_init(&call_details);-  grpc_slice status_details = grpc_slice_from_static_string(""xyz"");--  memset(ops, 0, sizeof(ops));-  op = ops;-  op->op = GRPC_OP_SEND_INITIAL_METADATA;-  op->data.send_initial_metadata.count = 0;-  op++;-  op->op = GRPC_OP_SEND_MESSAGE;-  op->data.send_message.send_message = request_payload;-  op++;-  op->op = GRPC_OP_RECV_MESSAGE;-  op->data.recv_message.recv_message = &response_payload_recv;-  op++;-  op->op = GRPC_OP_SEND_CLOSE_FROM_CLIENT;-  op++;-  op->op = GRPC_OP_RECV_INITIAL_METADATA;-  op->data.recv_initial_metadata.recv_initial_metadata = &initial_metadata_recv;-  op++;-  op->op = GRPC_OP_RECV_STATUS_ON_CLIENT;-  op->data.recv_status_on_client.trailing_metadata = &trailing_metadata_recv;-  op->data.recv_status_on_client.status = &status;-  op->data.recv_status_on_client.status_details = &details;-  op++;-  error = grpc_call_start_batch(c, ops, static_cast<size_t>(op - ops),-                                grpc_core::CqVerifier::tag(1), nullptr);-  GPR_ASSERT(GRPC_CALL_OK == error);--  error = grpc_server_request_call(f->server(), &s, &call_details,-                                   &request_metadata_recv, f->cq(), f->cq(),-                                   grpc_core::CqVerifier::tag(101));-  GPR_ASSERT(GRPC_CALL_OK == error);-  cqv.Expect(grpc_core::CqVerifier::tag(101), true);-  cqv.Verify();--  peer = grpc_call_get_peer(s);-  GPR_ASSERT(peer != nullptr);-  gpr_log(GPR_DEBUG, ""server_peer=%s"", peer);-  gpr_free(peer);-  peer = grpc_call_get_peer(c);-  GPR_ASSERT(peer != nullptr);-  gpr_log(GPR_DEBUG, ""client_peer=%s"", peer);-  gpr_free(peer);--  memset(ops, 0, sizeof(ops));-  op = ops;-  op->op = GRPC_OP_SEND_INITIAL_METADATA;-  op->data.send_initial_metadata.count = 0;-  op++;-  op->op = GRPC_OP_SEND_STATUS_FROM_SERVER;-  op->data.send_status_from_server.trailing_metadata_count = 0;-  op->data.send_status_from_server.status = GRPC_STATUS_ABORTED;-  op->data.send_status_from_server.status_details = &status_details;-  op++;-  op->op = GRPC_OP_RECV_CLOSE_ON_SERVER;-  op->data.recv_close_on_server.cancelled = &was_cancelled;-  op++;-  error = grpc_call_start_batch(s, ops, static_cast<size_t>(op - ops),-                                grpc_core::CqVerifier::tag(102), nullptr);-  GPR_ASSERT(GRPC_CALL_OK == error);--  cqv.Expect(grpc_core::CqVerifier::tag(102), true);-  cqv.Expect(grpc_core::CqVerifier::tag(1), true);-  cqv.Verify();--  GPR_ASSERT(status == GRPC_STATUS_ABORTED);-  GPR_ASSERT(0 == grpc_slice_str_cmp(details, ""xyz""));-  GPR_ASSERT(0 == grpc_slice_str_cmp(call_details.method, ""/service/method""));-  GPR_ASSERT(was_cancelled == 0);--  grpc_slice_unref(details);-  grpc_metadata_array_destroy(&initial_metadata_recv);-  grpc_metadata_array_destroy(&trailing_metadata_recv);-  grpc_metadata_array_destroy(&request_metadata_recv);-  grpc_call_details_destroy(&call_details);-  grpc_byte_buffer_destroy(request_payload);-  grpc_byte_buffer_destroy(response_payload);-  grpc_byte_buffer_destroy(request_payload_recv);-  grpc_byte_buffer_destroy(response_payload_recv);--  grpc_call_unref(c);-  grpc_call_unref(s);-}--void retry_exceeds_buffer_size_in_initial_batch(-    const CoreTestConfiguration& config) {-  GPR_ASSERT(config.feature_mask & FEATURE_MASK_SUPPORTS_CLIENT_CHANNEL);-  test_retry_exceeds_buffer_size_in_initial_batch(config);+TEST_P(RetryTest, RetryExceedsBufferSizeInInitialBatch) {+  InitServer(ChannelArgs());+  InitClient(+      ChannelArgs()+          .Set(GRPC_ARG_SERVICE_CONFIG,+               ""{\n""+               ""  \""methodConfig\"": [ {\n""+               ""    \""name\"": [\n""+               ""      { \""service\"": \""service\"", \""method\"": \""method\"" }\n""+               ""    ],\n""+               ""    \""retryPolicy\"": {\n""+               ""      \""maxAttempts\"": 2,\n""+               ""      \""initialBackoff\"": \""1s\"",\n""+               ""      \""maxBackoff\"": \""120s\"",\n""+               ""      \""backoffMultiplier\"": 1.6,\n""+               ""      \""retryableStatusCodes\"": [ \""ABORTED\"" ]\n""+               ""    }\n""+               ""  } ]\n""+               ""}"")+          .Set(GRPC_ARG_PER_RPC_RETRY_BUFFER_SIZE, 2));+  auto c =+      NewClientCall(""/service/method"").Timeout(Duration::Seconds(5)).Create();+  EXPECT_NE(c.GetPeer(), absl::nullopt);+  IncomingMessage server_message;+  IncomingStatusOnClient server_status;+  IncomingMetadata server_initial_metadata;+  c.NewBatch(1)+      .SendInitialMetadata({})+      .SendMessage(""foo"")+      .RecvMessage(server_message)+      .RecvInitialMetadata(server_initial_metadata)","In the original code, the order of the ops was SendCloseFromClient, RecvInitialMetadata, then RecvStatusOnClient.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32603,1153860922,2023-03-30T22:47:32Z,test/core/end2end/tests/retry_send_initial_metadata_refs.cc,"@@ -16,303 +16,110 @@ // // -#include <string.h>--#include <functional>-#include <memory> #include <string> -#include <grpc/byte_buffer.h>+#include ""absl/strings/string_view.h""+#include ""absl/types/optional.h""+#include ""gtest/gtest.h""+ #include <grpc/grpc.h>-#include <grpc/impl/propagation_bits.h> #include <grpc/slice.h> #include <grpc/status.h>-#include <grpc/support/alloc.h>-#include <grpc/support/log.h>-#include <grpc/support/time.h>  #include ""src/core/lib/channel/channel_args.h""-#include ""src/core/lib/gpr/useful.h""-#include ""test/core/end2end/cq_verifier.h""+#include ""src/core/lib/gprpp/time.h"" #include ""test/core/end2end/end2end_tests.h""-#include ""test/core/util/test_config.h"" -static std::unique_ptr<CoreTestFixture> begin_test(-    const CoreTestConfiguration& config, const char* test_name,-    grpc_channel_args* client_args, grpc_channel_args* server_args) {-  gpr_log(GPR_INFO, ""Running test: %s/%s"", test_name, config.name);-  auto f = config.create_fixture(grpc_core::ChannelArgs::FromC(client_args),-                                 grpc_core::ChannelArgs::FromC(server_args));-  f->InitServer(grpc_core::ChannelArgs::FromC(server_args));-  f->InitClient(grpc_core::ChannelArgs::FromC(client_args));-  return f;-}+namespace grpc_core {+namespace {  // Tests that we hold refs to send_initial_metadata payload while // cached, even after the caller has released its refs: // - 2 retries allowed for ABORTED status // - first attempt returns ABORTED // - second attempt returns OK-static void test_retry_send_initial_metadata_refs(-    const CoreTestConfiguration& config) {-  grpc_call* c;-  grpc_call* s;-  grpc_op ops[6];-  grpc_op* op;-  grpc_metadata_array client_send_initial_metadata;-  grpc_metadata_array initial_metadata_recv;-  grpc_metadata_array trailing_metadata_recv;-  grpc_metadata_array request_metadata_recv;-  grpc_call_details call_details;-  grpc_slice request_payload_slice = grpc_slice_from_static_string(""foo"");-  grpc_slice response_payload_slice = grpc_slice_from_static_string(""bar"");-  grpc_byte_buffer* request_payload =-      grpc_raw_byte_buffer_create(&request_payload_slice, 1);-  grpc_byte_buffer* response_payload =-      grpc_raw_byte_buffer_create(&response_payload_slice, 1);-  grpc_byte_buffer* request_payload_recv = nullptr;-  grpc_byte_buffer* response_payload_recv = nullptr;-  grpc_status_code status;-  grpc_call_error error;-  grpc_slice details;-  int was_cancelled = 2;-  char* peer;--  grpc_arg args[] = {-      grpc_channel_arg_string_create(-          const_cast<char*>(GRPC_ARG_SERVICE_CONFIG),-          const_cast<char*>(-              ""{\n""-              ""  \""methodConfig\"": [ {\n""-              ""    \""name\"": [\n""-              ""      { \""service\"": \""service\"", \""method\"": \""method\"" }\n""-              ""    ],\n""-              ""    \""retryPolicy\"": {\n""-              ""      \""maxAttempts\"": 3,\n""-              ""      \""initialBackoff\"": \""1s\"",\n""-              ""      \""maxBackoff\"": \""120s\"",\n""-              ""      \""backoffMultiplier\"": 1.6,\n""-              ""      \""retryableStatusCodes\"": [ \""ABORTED\"" ]\n""-              ""    }\n""-              ""  } ]\n""-              ""}"")),-  };-  grpc_channel_args client_args = {GPR_ARRAY_SIZE(args), args};-  auto f = begin_test(config, ""retry_send_initial_metadata_refs"", &client_args,-                      nullptr);--  grpc_core::CqVerifier cqv(f->cq());--  gpr_timespec deadline = grpc_timeout_seconds_to_deadline(5);-  c = grpc_channel_create_call(f->client(), nullptr, GRPC_PROPAGATE_DEFAULTS,-                               f->cq(),-                               grpc_slice_from_static_string(""/service/method""),-                               nullptr, deadline, nullptr);-  GPR_ASSERT(c);--  peer = grpc_call_get_peer(c);-  GPR_ASSERT(peer != nullptr);-  gpr_log(GPR_DEBUG, ""client_peer_before_call=%s"", peer);-  gpr_free(peer);--  grpc_metadata_array_init(&client_send_initial_metadata);-  client_send_initial_metadata.count = 2;-  client_send_initial_metadata.metadata = static_cast<grpc_metadata*>(-      gpr_malloc(client_send_initial_metadata.count * sizeof(grpc_metadata)));-  // First element is short enough for slices to be inlined.-  client_send_initial_metadata.metadata[0].key =-      grpc_slice_from_copied_string(std::string(""foo"").c_str());-  client_send_initial_metadata.metadata[0].value =-      grpc_slice_from_copied_string(std::string(""bar"").c_str());-  // Second element requires slice allocation.-  client_send_initial_metadata.metadata[1].key = grpc_slice_from_copied_string(-      std::string(GRPC_SLICE_INLINED_SIZE + 1, 'x').c_str());-  client_send_initial_metadata.metadata[1].value =-      grpc_slice_from_copied_string(-          std::string(GRPC_SLICE_INLINED_SIZE + 1, 'y').c_str());--  grpc_metadata_array_init(&initial_metadata_recv);-  grpc_metadata_array_init(&trailing_metadata_recv);-  grpc_metadata_array_init(&request_metadata_recv);-  grpc_call_details_init(&call_details);-  grpc_slice status_details = grpc_slice_from_static_string(""xyz"");--  memset(ops, 0, sizeof(ops));-  op = ops;-  op->op = GRPC_OP_SEND_INITIAL_METADATA;-  op->data.send_initial_metadata.count = client_send_initial_metadata.count;-  op->data.send_initial_metadata.metadata =-      client_send_initial_metadata.metadata;-  op++;-  op->op = GRPC_OP_SEND_MESSAGE;-  op->data.send_message.send_message = request_payload;-  op++;-  op->op = GRPC_OP_SEND_CLOSE_FROM_CLIENT;-  op++;-  error = grpc_call_start_batch(c, ops, static_cast<size_t>(op - ops),-                                grpc_core::CqVerifier::tag(1), nullptr);-  GPR_ASSERT(GRPC_CALL_OK == error);-  cqv.Expect(grpc_core::CqVerifier::tag(1), true);-  cqv.Verify();--  for (size_t i = 0; i < client_send_initial_metadata.count; ++i) {-    grpc_slice_unref(client_send_initial_metadata.metadata[i].key);-    grpc_slice_unref(client_send_initial_metadata.metadata[i].value);-  }-  grpc_metadata_array_destroy(&client_send_initial_metadata);--  memset(ops, 0, sizeof(ops));-  op = ops;-  op->op = GRPC_OP_RECV_MESSAGE;-  op->data.recv_message.recv_message = &response_payload_recv;-  op++;-  op->op = GRPC_OP_RECV_INITIAL_METADATA;-  op->data.recv_initial_metadata.recv_initial_metadata = &initial_metadata_recv;-  op++;-  op->op = GRPC_OP_RECV_STATUS_ON_CLIENT;-  op->data.recv_status_on_client.trailing_metadata = &trailing_metadata_recv;-  op->data.recv_status_on_client.status = &status;-  op->data.recv_status_on_client.status_details = &details;-  op++;-  error = grpc_call_start_batch(c, ops, static_cast<size_t>(op - ops),-                                grpc_core::CqVerifier::tag(2), nullptr);-  GPR_ASSERT(GRPC_CALL_OK == error);--  error = grpc_server_request_call(f->server(), &s, &call_details,-                                   &request_metadata_recv, f->cq(), f->cq(),-                                   grpc_core::CqVerifier::tag(101));-  GPR_ASSERT(GRPC_CALL_OK == error);-  cqv.Expect(grpc_core::CqVerifier::tag(101), true);-  cqv.Verify();-+TEST_P(RetryTest, RetrySendInitialMetadataRefs) {+  InitServer(ChannelArgs());+  InitClient(ChannelArgs().Set(+      GRPC_ARG_SERVICE_CONFIG,+      ""{\n""+      ""  \""methodConfig\"": [ {\n""+      ""    \""name\"": [\n""+      ""      { \""service\"": \""service\"", \""method\"": \""method\"" }\n""+      ""    ],\n""+      ""    \""retryPolicy\"": {\n""+      ""      \""maxAttempts\"": 3,\n""+      ""      \""initialBackoff\"": \""1s\"",\n""+      ""      \""maxBackoff\"": \""120s\"",\n""+      ""      \""backoffMultiplier\"": 1.6,\n""+      ""      \""retryableStatusCodes\"": [ \""ABORTED\"" ]\n""+      ""    }\n""+      ""  } ]\n""+      ""}""));+  auto c =+      NewClientCall(""/service/method"").Timeout(Duration::Seconds(5)).Create();+  EXPECT_NE(c.GetPeer(), absl::nullopt);+  c.NewBatch(1)+      .SendInitialMetadata(+          {// First element is short enough for slices to be inlined.+           {""foo"", ""bar""},+           // Second element requires slice allocation.+           {std::string(GRPC_SLICE_INLINED_SIZE + 1, 'x'),+            std::string(GRPC_SLICE_INLINED_SIZE + 1, 'y')}})+      .SendMessage(""foo"")+      .SendCloseFromClient();+  Expect(1, true);+  Step();+  IncomingMessage server_message;+  IncomingMetadata server_initial_metadata;+  IncomingStatusOnClient server_status;+  c.NewBatch(2)+      .RecvMessage(server_message)+      .RecvInitialMetadata(server_initial_metadata)+      .RecvStatusOnClient(server_status);+  auto s = RequestCall(101);+  Expect(101, true);+  Step();   // Make sure the ""grpc-previous-rpc-attempts"" header was not sent in the   // initial attempt.-  for (size_t i = 0; i < request_metadata_recv.count; ++i) {-    GPR_ASSERT(!grpc_slice_eq(-        request_metadata_recv.metadata[i].key,-        grpc_slice_from_static_string(""grpc-previous-rpc-attempts"")));-  }--  peer = grpc_call_get_peer(s);-  GPR_ASSERT(peer != nullptr);-  gpr_log(GPR_DEBUG, ""server_peer=%s"", peer);-  gpr_free(peer);-  peer = grpc_call_get_peer(c);-  GPR_ASSERT(peer != nullptr);-  gpr_log(GPR_DEBUG, ""client_peer=%s"", peer);-  gpr_free(peer);--  memset(ops, 0, sizeof(ops));-  op = ops;-  op->op = GRPC_OP_SEND_INITIAL_METADATA;-  op->data.send_initial_metadata.count = 0;-  op++;-  op->op = GRPC_OP_SEND_STATUS_FROM_SERVER;-  op->data.send_status_from_server.trailing_metadata_count = 0;-  op->data.send_status_from_server.status = GRPC_STATUS_ABORTED;-  op->data.send_status_from_server.status_details = &status_details;-  op++;-  op->op = GRPC_OP_RECV_CLOSE_ON_SERVER;-  op->data.recv_close_on_server.cancelled = &was_cancelled;-  op++;-  error = grpc_call_start_batch(s, ops, static_cast<size_t>(op - ops),-                                grpc_core::CqVerifier::tag(102), nullptr);-  GPR_ASSERT(GRPC_CALL_OK == error);--  cqv.Expect(grpc_core::CqVerifier::tag(102), true);-  cqv.Verify();--  grpc_call_unref(s);-  grpc_metadata_array_destroy(&request_metadata_recv);-  grpc_metadata_array_init(&request_metadata_recv);-  grpc_call_details_destroy(&call_details);-  grpc_call_details_init(&call_details);--  error = grpc_server_request_call(f->server(), &s, &call_details,-                                   &request_metadata_recv, f->cq(), f->cq(),-                                   grpc_core::CqVerifier::tag(201));-  GPR_ASSERT(GRPC_CALL_OK == error);-  cqv.Expect(grpc_core::CqVerifier::tag(201), true);-  cqv.Verify();-+  EXPECT_EQ(s.GetInitialMetadata(""grpc-previous-rpc-attempts""), absl::nullopt);+  EXPECT_NE(s.GetPeer(), absl::nullopt);+  EXPECT_NE(c.GetPeer(), absl::nullopt);+  IncomingCloseOnServer client_close;+  s.NewBatch(102)+      .SendInitialMetadata({})+      .SendStatusFromServer(GRPC_STATUS_ABORTED, ""xyz"", {})+      .RecvCloseOnServer(client_close);+  Expect(102, true);+  Step();+  auto s2 = RequestCall(201);+  Expect(201, true);+  Step();   // Make sure the ""grpc-previous-rpc-attempts"" header was sent in the retry.-  GPR_ASSERT(contains_metadata_slices(-      &request_metadata_recv,-      grpc_slice_from_static_string(""grpc-previous-rpc-attempts""),-      grpc_slice_from_static_string(""1"")));+  EXPECT_EQ(s2.GetInitialMetadata(""grpc-previous-rpc-attempts""), ""1"");   // It should also contain the initial metadata, even though the client   // freed it already.-  GPR_ASSERT(contains_metadata(&request_metadata_recv, ""foo"", ""bar""));-  GPR_ASSERT(-      contains_metadata(&request_metadata_recv,-                        std::string(GRPC_SLICE_INLINED_SIZE + 1, 'x').c_str(),-                        std::string(GRPC_SLICE_INLINED_SIZE + 1, 'y').c_str()));--  peer = grpc_call_get_peer(s);-  GPR_ASSERT(peer != nullptr);-  gpr_log(GPR_DEBUG, ""server_peer=%s"", peer);-  gpr_free(peer);-  peer = grpc_call_get_peer(c);-  GPR_ASSERT(peer != nullptr);-  gpr_log(GPR_DEBUG, ""client_peer=%s"", peer);-  gpr_free(peer);--  memset(ops, 0, sizeof(ops));-  op = ops;-  op->op = GRPC_OP_RECV_MESSAGE;-  op->data.recv_message.recv_message = &request_payload_recv;-  op++;-  error = grpc_call_start_batch(s, ops, static_cast<size_t>(op - ops),-                                grpc_core::CqVerifier::tag(202), nullptr);-  GPR_ASSERT(GRPC_CALL_OK == error);--  memset(ops, 0, sizeof(ops));-  op = ops;-  op->op = GRPC_OP_SEND_INITIAL_METADATA;-  op->data.send_initial_metadata.count = 0;-  op++;-  op->op = GRPC_OP_SEND_MESSAGE;-  op->data.send_message.send_message = response_payload;-  op++;-  op->op = GRPC_OP_SEND_STATUS_FROM_SERVER;-  op->data.send_status_from_server.trailing_metadata_count = 0;-  op->data.send_status_from_server.status = GRPC_STATUS_OK;-  op->data.send_status_from_server.status_details = &status_details;-  op++;-  op->op = GRPC_OP_RECV_CLOSE_ON_SERVER;-  op->data.recv_close_on_server.cancelled = &was_cancelled;-  op++;-  error = grpc_call_start_batch(s, ops, static_cast<size_t>(op - ops),-                                grpc_core::CqVerifier::tag(203), nullptr);-  GPR_ASSERT(GRPC_CALL_OK == error);--  cqv.Expect(grpc_core::CqVerifier::tag(202), true);-  cqv.Expect(grpc_core::CqVerifier::tag(203), true);-  cqv.Expect(grpc_core::CqVerifier::tag(2), true);-  cqv.Verify();--  GPR_ASSERT(status == GRPC_STATUS_OK);-  GPR_ASSERT(0 == grpc_slice_str_cmp(details, ""xyz""));-  GPR_ASSERT(0 == grpc_slice_str_cmp(call_details.method, ""/service/method""));-  GPR_ASSERT(was_cancelled == 0);--  grpc_slice_unref(details);-  grpc_metadata_array_destroy(&initial_metadata_recv);-  grpc_metadata_array_destroy(&trailing_metadata_recv);-  grpc_metadata_array_destroy(&request_metadata_recv);-  grpc_call_details_destroy(&call_details);-  grpc_byte_buffer_destroy(request_payload);-  grpc_byte_buffer_destroy(response_payload);-  grpc_byte_buffer_destroy(request_payload_recv);-  grpc_byte_buffer_destroy(response_payload_recv);--  grpc_call_unref(c);-  grpc_call_unref(s);-}--void retry_send_initial_metadata_refs(const CoreTestConfiguration& config) {-  GPR_ASSERT(config.feature_mask & FEATURE_MASK_SUPPORTS_CLIENT_CHANNEL);-  test_retry_send_initial_metadata_refs(config);+  EXPECT_EQ(s2.GetInitialMetadata(""foo""), ""bar"");+  EXPECT_EQ(+      s2.GetInitialMetadata(std::string(GRPC_SLICE_INLINED_SIZE + 1, 'x')),+      std::string(GRPC_SLICE_INLINED_SIZE + 1, 'y'));+  EXPECT_NE(s.GetPeer(), absl::nullopt);+  EXPECT_NE(c.GetPeer(), absl::nullopt);+  IncomingMessage client_message;+  s2.NewBatch(202).RecvMessage(client_message);+  s2.NewBatch(203)+      .SendMessage(""bar"")",This should go after SendInitialMetadata.,
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/32701,1153884295,2023-03-30T23:35:06Z,src/core/lib/event_engine/posix_engine/posix_engine.cc,"@@ -482,9 +485,139 @@ EventEngine::TaskHandle PosixEventEngine::RunAfterInternal(   return handle; } +PosixEventEngine::PosixDNSResolver::PosixDNSResolver(+    ResolverOptions const& options, PosixEnginePollerManager* poller_manager,+    PosixEventEngine* event_engine)+    : options_(options),+      poller_manager_(poller_manager),+      event_engine_(event_engine) {}++PosixEventEngine::PosixDNSResolver::~PosixDNSResolver() {}++using LookupTaskHandle = PosixEventEngine::PosixDNSResolver::LookupTaskHandle;++LookupTaskHandle PosixEventEngine::PosixDNSResolver::LookupHostname(+    LookupHostnameCallback on_resolve, absl::string_view name,+    absl::string_view default_port, Duration timeout) {+  GrpcAresHostnameRequest* request = new GrpcAresHostnameRequest(+      name, default_port, timeout,+      absl::bind_front(&PosixEventEngine::PosixDNSResolver::CreateEventHandle,+                       this),+      event_engine_);+  const absl::Status status =+      request->Initialize(options_.dns_server, /*check_port=*/true);+  if (!status.ok()) {+    // Report back initialization failure through on_resolve.+    on_resolve(status);","This needs to be run asynchronously. Otherwise, we can expect a deadlock here in the client channel resolver attempts to resolve balancer hostnames.```event_engine_->Run([cb = std::move(on_resolved), status]() mutable {  cb(status);});```",
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/32701,1153887063,2023-03-30T23:41:29Z,src/core/lib/event_engine/ares_driver.cc,"@@ -0,0 +1,952 @@+// Copyright 2023 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++#include ""src/core/lib/event_engine/ares_driver.h""++#include <arpa/nameser.h>","Did you mean `#include ""src/core/lib/event_engine/nameser.h""`?For future reference, this won't work on Windows. Same for `netdb.h`. But I think this case is covered by [`include/grpc/event_engine/port.h` ](https://github.com/grpc/grpc/blob/450196ae3f3457b8dfbef7d3c2f332b3d5ad5305/include/grpc/event_engine/port.h)I'll leave it up to you whether you want to identify these platform-specific dependencies now or in a few months when the Windows implementation gets underway. You could for example wrap these in `#ifdef GRPC_POSIX_SOCKET_TCP` or some such. I image there will be many similar things for now, totally expected, so I won't call them out further. ",
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/32701,1153887615,2023-03-30T23:42:35Z,src/core/lib/event_engine/ares_driver.cc,"@@ -0,0 +1,952 @@+// Copyright 2023 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++#include ""src/core/lib/event_engine/ares_driver.h""++#include <arpa/nameser.h>+#include <inttypes.h>+#include <netdb.h>+#include <string.h>++#include <algorithm>+#include <chrono>+#include <initializer_list>+#include <ratio>",I believe this is banned. There are a number of spots where we include `// IWYU pragma: no_include <ratio>` because our version of IWYU recommends it inappropriately.,
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/32701,1153893889,2023-03-30T23:57:41Z,src/core/lib/event_engine/ares_driver.h,"@@ -0,0 +1,208 @@+// Copyright 2023 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+#ifndef GRPC_SRC_CORE_LIB_EVENT_ENGINE_ARES_DRIVER_H+#define GRPC_SRC_CORE_LIB_EVENT_ENGINE_ARES_DRIVER_H++#include <grpc/support/port_platform.h>++#include <arpa/inet.h>+#include <stddef.h>+#include <stdint.h>++#include <algorithm>+#include <memory>+#include <sstream>+#include <string>+#include <vector>++#include <ares.h>++#include ""absl/base/thread_annotations.h""+#include ""absl/functional/any_invocable.h""+#include ""absl/status/status.h""+#include ""absl/status/statusor.h""+#include ""absl/strings/string_view.h""+#include ""absl/synchronization/mutex.h""+#include ""absl/types/optional.h""++#include ""include/grpc/event_engine/event_engine.h""++#include ""src/core/lib/gprpp/ref_counted.h""++namespace grpc_event_engine {+namespace experimental {++#ifdef _WIN32+class WinSocket;+using PollerHandle = std::unique_ptr<WinSocket>;+#else+class EventHandle;+using PollerHandle = EventHandle*;+#endif+using RegisterAresSocketWithPollerCallback =+    absl::AnyInvocable<PollerHandle(ares_socket_t)>;++class GrpcPolledFd;+class GrpcPolledFdFactory;++// An inflight name service lookup request+class GrpcAresRequest : public grpc_core::RefCounted<GrpcAresRequest> {+ public:+  ~GrpcAresRequest() override;","Given that `GrpcAresRequest` is meant to be a base class, I believe this should be a virtual destructor.",
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/32701,1153895591,2023-03-31T00:01:54Z,src/core/lib/event_engine/ares_driver.h,"@@ -0,0 +1,208 @@+// Copyright 2023 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+#ifndef GRPC_SRC_CORE_LIB_EVENT_ENGINE_ARES_DRIVER_H+#define GRPC_SRC_CORE_LIB_EVENT_ENGINE_ARES_DRIVER_H++#include <grpc/support/port_platform.h>++#include <arpa/inet.h>+#include <stddef.h>+#include <stdint.h>++#include <algorithm>+#include <memory>+#include <sstream>+#include <string>+#include <vector>++#include <ares.h>++#include ""absl/base/thread_annotations.h""+#include ""absl/functional/any_invocable.h""+#include ""absl/status/status.h""+#include ""absl/status/statusor.h""+#include ""absl/strings/string_view.h""+#include ""absl/synchronization/mutex.h""+#include ""absl/types/optional.h""++#include ""include/grpc/event_engine/event_engine.h""++#include ""src/core/lib/gprpp/ref_counted.h""++namespace grpc_event_engine {+namespace experimental {++#ifdef _WIN32+class WinSocket;+using PollerHandle = std::unique_ptr<WinSocket>;+#else+class EventHandle;+using PollerHandle = EventHandle*;+#endif+using RegisterAresSocketWithPollerCallback =+    absl::AnyInvocable<PollerHandle(ares_socket_t)>;++class GrpcPolledFd;+class GrpcPolledFdFactory;++// An inflight name service lookup request+class GrpcAresRequest : public grpc_core::RefCounted<GrpcAresRequest> {+ public:+  ~GrpcAresRequest() override;++  absl::Status Initialize(absl::string_view dns_server, bool check_port)+      ABSL_LOCKS_EXCLUDED(mu_);+  void Cancel() ABSL_LOCKS_EXCLUDED(mu_);+  absl::string_view host() const ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu_) {+    return host_;+  }+  uint16_t port() const ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu_) { return port_; }++ protected:+  explicit GrpcAresRequest(absl::string_view name,","`explicit` is meaningful when the compiler could use this constructor for an implicit type conversion. Since this constructor has more than one parameter, it's not meaningful.",
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/32701,1153898459,2023-03-31T00:08:31Z,src/core/lib/event_engine/posix_engine/posix_engine.cc,"@@ -67,7 +70,7 @@ namespace grpc_event_engine { namespace experimental {  bool NeedPosixEngine() {-  return UseEventEngineClient() || UseEventEngineListener();+  return true || UseEventEngineClient() || UseEventEngineListener();",Consider adding `// DO NOT SUBMIT: remove the short-circuit` here. This will prevent merging it accidentally. See https://github.com/grpc/grpc/blob/450196ae3f3457b8dfbef7d3c2f332b3d5ad5305/tools/run_tests/sanity/check_do_not_submit.sh,
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/32701,1153903869,2023-03-31T00:23:10Z,src/core/lib/event_engine/posix_engine/posix_engine.cc,"@@ -482,9 +485,139 @@ EventEngine::TaskHandle PosixEventEngine::RunAfterInternal(   return handle; } +PosixEventEngine::PosixDNSResolver::PosixDNSResolver(+    ResolverOptions const& options, PosixEnginePollerManager* poller_manager,+    PosixEventEngine* event_engine)+    : options_(options),+      poller_manager_(poller_manager),+      event_engine_(event_engine) {}++PosixEventEngine::PosixDNSResolver::~PosixDNSResolver() {}++using LookupTaskHandle = PosixEventEngine::PosixDNSResolver::LookupTaskHandle;++LookupTaskHandle PosixEventEngine::PosixDNSResolver::LookupHostname(+    LookupHostnameCallback on_resolve, absl::string_view name,+    absl::string_view default_port, Duration timeout) {+  GrpcAresHostnameRequest* request = new GrpcAresHostnameRequest(+      name, default_port, timeout,+      absl::bind_front(&PosixEventEngine::PosixDNSResolver::CreateEventHandle,+                       this),+      event_engine_);+  const absl::Status status =+      request->Initialize(options_.dns_server, /*check_port=*/true);+  if (!status.ok()) {+    // Report back initialization failure through on_resolve.+    on_resolve(status);+    return LookupTaskHandle{};+  }+  LookupTaskHandle handle{reinterpret_cast<intptr_t>(request),+                          aba_token_.fetch_add(1)};+  {+    absl::MutexLock lock(&mu_);+    inflight_requests_.insert(handle);+  }+  request->Start([on_resolve = std::move(on_resolve), handle, this](+                     absl::StatusOr<std::vector<EventEngine::ResolvedAddress>>+                         result) mutable {+    {+      absl::MutexLock lock(&mu_);+      // on_resolved called, no longer inflight.+      GPR_ASSERT(inflight_requests_.erase(handle) == 1);+    }+    on_resolve(std::move(result));+  });+  return handle;+}++LookupTaskHandle PosixEventEngine::PosixDNSResolver::LookupSRV(+    LookupSRVCallback on_resolve, absl::string_view name, Duration timeout) {+  GrpcAresSRVRequest* request = new GrpcAresSRVRequest(+      name, timeout,+      absl::bind_front(&PosixEventEngine::PosixDNSResolver::CreateEventHandle,+                       this),+      event_engine_);+  const absl::Status status =+      request->Initialize(options_.dns_server, /*check_port=*/false);+  if (!status.ok()) {+    // Report back initialization failure through on_resolve.+    on_resolve(status);+    return LookupTaskHandle{};+  }+  LookupTaskHandle handle{reinterpret_cast<intptr_t>(request),+                          aba_token_.fetch_add(1)};+  {+    absl::MutexLock lock(&mu_);+    inflight_requests_.insert(handle);+  }+  request->Start(+      [on_resolve = std::move(on_resolve), handle,+       this](absl::StatusOr<std::vector<EventEngine::DNSResolver::SRVRecord>>+                 result) mutable {+        {+          absl::MutexLock lock(&mu_);+          // on_resolved called, no longer inflight.+          GPR_ASSERT(inflight_requests_.erase(handle) == 1);+        }+        on_resolve(std::move(result));+      });+  return handle;+}++LookupTaskHandle PosixEventEngine::PosixDNSResolver::LookupTXT(+    LookupTXTCallback on_resolve, absl::string_view name, Duration timeout) {+  GrpcAresTXTRequest* request = new GrpcAresTXTRequest(+      name, timeout,+      absl::bind_front(&PosixEventEngine::PosixDNSResolver::CreateEventHandle,+                       this),+      event_engine_);+  const absl::Status status =+      request->Initialize(options_.dns_server, /*check_port=*/false);+  if (!status.ok()) {+    // Report back initialization failure through on_resolve.+    on_resolve(status);","This needs to be run asynchronously. Otherwise, we can expect a deadlock here in the client channel resolver attempts to resolve balancer hostnames.```event_engine_->Run([cb = std::move(on_resolved), status]() mutable {  cb(status);});```",
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/32701,1153914719,2023-03-31T00:49:30Z,src/core/lib/event_engine/ares_driver.cc,"@@ -0,0 +1,952 @@+// Copyright 2023 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++#include ""src/core/lib/event_engine/ares_driver.h""++#include <arpa/nameser.h>+#include <inttypes.h>+#include <netdb.h>+#include <string.h>++#include <algorithm>+#include <chrono>+#include <initializer_list>+#include <ratio>+#include <type_traits>+#include <utility>++#include <address_sorting/address_sorting.h>++#include ""absl/strings/str_cat.h""+#include ""absl/strings/str_format.h""+#include ""absl/types/optional.h""++#include <grpc/event_engine/event_engine.h>+#include <grpc/support/alloc.h>+#include <grpc/support/log.h>++#include ""src/core/lib/address_utils/parse_address.h""+#include ""src/core/lib/address_utils/sockaddr_utils.h""+#include ""src/core/lib/debug/trace.h""+#include ""src/core/lib/event_engine/grpc_polled_fd.h""+#include ""src/core/lib/event_engine/nameser.h""  // IWYU pragma: keep+#include ""src/core/lib/event_engine/tcp_socket_utils.h""+#include ""src/core/lib/gpr/string.h""+#include ""src/core/lib/gprpp/debug_location.h""+#include ""src/core/lib/gprpp/examine_stack.h""+#include ""src/core/lib/gprpp/host_port.h""+#include ""src/core/lib/gprpp/ref_counted_ptr.h""+#include ""src/core/lib/gprpp/status_helper.h""+#include ""src/core/lib/iomgr/error.h""+#include ""src/core/lib/iomgr/exec_ctx.h""+#include ""src/core/lib/iomgr/resolved_address.h""+#include ""src/core/lib/iomgr/sockaddr.h""+#ifdef _WIN32+#else+#include ""src/core/lib/event_engine/posix_engine/tcp_socket_utils.h""+#endif++namespace grpc_event_engine {+namespace experimental {++grpc_core::TraceFlag grpc_trace_ares_driver_address_sorting(+    false, ""ares_driver_address_sorting"");++grpc_core::TraceFlag grpc_trace_ares_driver_stacktrace(+    false, ""ares_driver_stacktrace"");++#define GRPC_ARES_DRIVER_STACK_TRACE()                                \+  do {                                                                \+    if (GRPC_TRACE_FLAG_ENABLED(grpc_trace_ares_driver_stacktrace)) { \+      absl::optional<std::string> stacktrace =                        \+          grpc_core::GetCurrentStackTrace();                          \+      if (stacktrace.has_value()) {                                   \+        gpr_log(GPR_DEBUG, ""%s"", stacktrace->c_str());                \+      } else {                                                        \+        gpr_log(GPR_DEBUG, ""stacktrace unavailable"");                 \+      }                                                               \+    }                                                                 \+  } while (0)++grpc_core::TraceFlag grpc_trace_ares_driver(false, ""ares_driver"");++#define GRPC_ARES_DRIVER_TRACE_LOG(format, ...)                 \+  do {                                                          \+    if (GRPC_TRACE_FLAG_ENABLED(grpc_trace_ares_driver)) {      \+      gpr_log(GPR_DEBUG, ""(ares driver) "" format, __VA_ARGS__); \+    }                                                           \+  } while (0)++namespace {++struct HostbynameArg {+  GrpcAresHostnameRequest* request;+  const char* qtype;+};++void on_hostbyname_done_locked(void* arg, int status, int /*timeouts*/,+                               struct hostent* hostent)+    ABSL_NO_THREAD_SAFETY_ANALYSIS {+  // This callback is invoked from the c-ares library, so disable thread safety+  // analysis. Note that we are guaranteed to be holding r->mu, though.+  std::unique_ptr<HostbynameArg> harg(static_cast<HostbynameArg*>(arg));+  GrpcAresHostnameRequest* request = harg->request;+  if (status != ARES_SUCCESS) {+    std::string error_msg = absl::StrFormat(+        ""C-ares status is not ARES_SUCCESS qtype=%s name=%s: %s"", harg->qtype,+        request->host(), ares_strerror(status));+    GRPC_ARES_DRIVER_TRACE_LOG(""request:%p on_hostbyname_done_locked: %s"",+                               request, error_msg.c_str());+    GRPC_ARES_DRIVER_STACK_TRACE();+    absl::Status error = GRPC_ERROR_CREATE(error_msg);+    request->OnResolve(error);+    return;+  }+  GRPC_ARES_DRIVER_TRACE_LOG(+      ""request:%p on_hostbyname_done_locked qtype=%s host=%s ARES_SUCCESS"",+      request, harg->qtype, std::string(request->host()).c_str());+  GRPC_ARES_DRIVER_STACK_TRACE();++  std::vector<EventEngine::ResolvedAddress> resolved_addresses;+  for (size_t i = 0; hostent->h_addr_list[i] != nullptr; i++) {+    switch (hostent->h_addrtype) {+      case AF_INET6: {+        size_t addr_len = sizeof(struct sockaddr_in6);+        struct sockaddr_in6 addr;+        memset(&addr, 0, addr_len);+        memcpy(&addr.sin6_addr, hostent->h_addr_list[i],+               sizeof(struct in6_addr));+        addr.sin6_family = static_cast<unsigned char>(hostent->h_addrtype);+        addr.sin6_port = request->port();+        resolved_addresses.emplace_back(+            reinterpret_cast<const sockaddr*>(&addr), addr_len);+        char output[INET6_ADDRSTRLEN];+        ares_inet_ntop(AF_INET6, &addr.sin6_addr, output, INET6_ADDRSTRLEN);+        GRPC_ARES_DRIVER_TRACE_LOG(+            ""request:%p c-ares resolver gets a AF_INET6 result: \n""+            ""  addr: %s\n  port: %d\n  sin6_scope_id: %d\n"",+            request, output, ntohs(request->port()), addr.sin6_scope_id);+        break;+      }+      case AF_INET: {+        size_t addr_len = sizeof(struct sockaddr_in);+        struct sockaddr_in addr;+        memset(&addr, 0, addr_len);+        memcpy(&addr.sin_addr, hostent->h_addr_list[i], sizeof(struct in_addr));+        addr.sin_family = static_cast<unsigned char>(hostent->h_addrtype);+        addr.sin_port = request->port();+        resolved_addresses.emplace_back(+            reinterpret_cast<const sockaddr*>(&addr), addr_len);+        char output[INET_ADDRSTRLEN];+        ares_inet_ntop(AF_INET, &addr.sin_addr, output, INET_ADDRSTRLEN);+        GRPC_ARES_DRIVER_TRACE_LOG(+            ""request:%p c-ares resolver gets a AF_INET result: \n""+            ""  addr: %s\n  port: %d\n"",+            request, output, ntohs(request->port()));+        break;+      }+    }+  }+  request->OnResolve(std::move(resolved_addresses));+}++void on_srv_query_done_locked(void* arg, int status, int /*timeouts*/,+                              unsigned char* abuf,+                              int alen) ABSL_NO_THREAD_SAFETY_ANALYSIS {+  // This callback is invoked from the c-ares library, so disable thread safety+  // analysis. Note that we are guaranteed to be holding r->mu, though.+  GrpcAresSRVRequest* r = static_cast<GrpcAresSRVRequest*>(arg);+  if (status != ARES_SUCCESS) {+    std::string error_msg = absl::StrFormat(+        ""C-ares status is not ARES_SUCCESS qtype=SRV name=%s: %s"",+        r->service_name(), ares_strerror(status));+    GRPC_ARES_DRIVER_TRACE_LOG(""request:%p on_srv_query_done_locked: %s"", r,+                               error_msg.c_str());+    grpc_error_handle error = GRPC_ERROR_CREATE(error_msg);+    r->OnResolve(error);+    return;+  }+  GRPC_ARES_DRIVER_TRACE_LOG(+      ""request:%p on_srv_query_done_locked name=%s ARES_SUCCESS"", r,+      r->service_name());+  struct ares_srv_reply* reply = nullptr;+  const int parse_status = ares_parse_srv_reply(abuf, alen, &reply);+  GRPC_ARES_DRIVER_TRACE_LOG(""request:%p ares_parse_srv_reply: %d"", r,+                             parse_status);+  std::vector<EventEngine::DNSResolver::SRVRecord> result;+  if (parse_status == ARES_SUCCESS) {+    for (struct ares_srv_reply* srv_it = reply; srv_it != nullptr;+         srv_it = srv_it->next) {+      result.push_back({.host = srv_it->host,+                        .port = srv_it->port,+                        .priority = srv_it->priority,+                        .weight = srv_it->weight});+    }+  }+  if (reply != nullptr) {+    ares_free_data(reply);+  }+  r->OnResolve(std::move(result));+}++constexpr char g_service_config_attribute_prefix[] = ""grpc_config="";+constexpr size_t g_prefix_len = sizeof(g_service_config_attribute_prefix) - 1;++void on_txt_done_locked(void* arg, int status, int /*timeouts*/,+                        unsigned char* buf,+                        int len) ABSL_NO_THREAD_SAFETY_ANALYSIS {+  // This callback is invoked from the c-ares library, so disable thread safety+  // analysis. Note that we are guaranteed to be holding r->mu, though.+  GrpcAresTXTRequest* r = static_cast<GrpcAresTXTRequest*>(arg);+  struct ares_txt_ext* reply = nullptr;+  int parse_status = ARES_SUCCESS;+  if (status == ARES_SUCCESS) {+    GRPC_ARES_DRIVER_TRACE_LOG(+        ""request:%p on_txt_done_locked name=%s ARES_SUCCESS"", r,+        r->config_name());+    parse_status = ares_parse_txt_reply_ext(buf, len, &reply);+  }+  if (status != ARES_SUCCESS || parse_status != ARES_SUCCESS) {+    grpc_error_handle error;+    std::string error_msg = absl::StrFormat(+        ""C-ares status is not ARES_SUCCESS qtype=TXT name=%s: %s"",+        r->config_name(), ares_strerror(status));+    GRPC_ARES_DRIVER_TRACE_LOG(""request:%p on_txt_done_locked %s"", r,+                               error_msg.c_str());+    error = GRPC_ERROR_CREATE(error_msg);+    r->OnResolve(error);+    return;+  }+  // Find service config in TXT record.+  struct ares_txt_ext* result = nullptr;+  for (result = reply; result != nullptr; result = result->next) {+    if (result->record_start &&+        memcmp(result->txt, g_service_config_attribute_prefix, g_prefix_len) ==+            0) {+      break;+    }+  }+  std::string service_config_json_out;+  // Found a service config record.+  if (result != nullptr) {+    size_t service_config_len = result->length - g_prefix_len;+    service_config_json_out.append(+        reinterpret_cast<char*>(result->txt) + g_prefix_len,+        service_config_len);+    for (result = result->next; result != nullptr && !result->record_start;+         result = result->next) {+      service_config_json_out.append(reinterpret_cast<char*>(result->txt),+                                     result->length);+    }+    GRPC_ARES_DRIVER_TRACE_LOG(""request:%p found service config: %s"", r,+                               service_config_json_out.c_str());+  }+  // Clean up.+  ares_free_data(reply);+  r->OnResolve(std::move(service_config_json_out));+}++EventEngine::Duration calculate_next_ares_backup_poll_alarm_duration() {+  // An alternative here could be to use ares_timeout to try to be more+  // accurate, but that would require using ""struct timeval""'s, which just makes+  // things a bit more complicated. So just poll every second, as suggested+  // by the c-ares code comments.+  return std::chrono::seconds(1);+}++bool IsIpv6LoopbackAvailable() {+#ifdef _WIN32+  // TODO(yijiem): (debt) move pieces for Windows+#else+  return PosixSocketWrapper::IsIpv6LoopbackAvailable();+#endif+}++}  // namespace++struct GrpcAresRequest::FdNode {+  FdNode() = default;+  explicit FdNode(ares_socket_t as, GrpcPolledFd* polled_fd)+      : as(as), polled_fd(polled_fd) {}+  ares_socket_t as;+  std::unique_ptr<GrpcPolledFd> polled_fd;+  // next fd node+  FdNode* next = nullptr;+  /// if the readable closure has been registered+  bool readable_registered = false;+  /// if the writable closure has been registered+  bool writable_registered = false;+  bool already_shutdown = false;+};++// TODO(yijiem): see if we can use std::list+// per ares-channel linked-list of FdNodes+class GrpcAresRequest::FdNodeList {+ public:+  class FdNodeListIterator {+   public:+    bool operator!=(const FdNodeListIterator& other) {+      return node_ != other.node_;+    }+    bool operator==(const FdNodeListIterator& other) {+      return node_ == other.node_;+    }+    FdNodeListIterator& operator++(int) {+      node_ = node_->next;+      return *this;+    }+    FdNode* operator*() { return node_; }+    static FdNodeListIterator universal_end() {+      return FdNodeListIterator(nullptr);+    }++   private:+    friend class FdNodeList;+    explicit FdNodeListIterator(FdNode* node) : node_(node) {}+    FdNode* node_;+  };+  using Iterator = FdNodeListIterator;++  FdNodeList() = default;+  ~FdNodeList() { GPR_ASSERT(IsEmpty()); }++  Iterator begin() { return Iterator(head_); }+  Iterator end() { return Iterator::universal_end(); }++  bool IsEmpty() const { return head_ == nullptr; }++  void PushFdNode(FdNode* fd_node)+      ABSL_EXCLUSIVE_LOCKS_REQUIRED(&GrpcAresRequest::mu_) {+    fd_node->next = head_;+    head_ = fd_node;+  }++  FdNode* PopFdNode() ABSL_EXCLUSIVE_LOCKS_REQUIRED(&GrpcAresRequest::mu_) {+    GPR_ASSERT(!IsEmpty());+    FdNode* ret = head_;+    head_ = head_->next;+    return ret;+  }++  // Search for as in the FdNode list. This is an O(n) search, the max+  // possible value of n is ARES_GETSOCK_MAXNUM (16). n is typically 1 - 2+  // in our tests.+  FdNode* PopFdNode(ares_socket_t as)+      ABSL_EXCLUSIVE_LOCKS_REQUIRED(&GrpcAresRequest::mu_) {+    FdNode phony_head;+    phony_head.next = head_;+    FdNode* node = &phony_head;+    while (node->next != nullptr) {+      if (node->next->polled_fd->GetWrappedAresSocketLocked() == as) {+        FdNode* ret = node->next;+        node->next = node->next->next;+        head_ = phony_head.next;+        return ret;+      }+      node = node->next;+    }+    return nullptr;+  }++ private:+  FdNode* head_ = nullptr;+};++GrpcAresRequest::GrpcAresRequest(+    absl::string_view name, absl::optional<absl::string_view> default_port,+    EventEngine::Duration timeout,+    RegisterAresSocketWithPollerCallback register_cb, EventEngine* event_engine)+    : grpc_core::RefCounted<GrpcAresRequest>(+          GRPC_TRACE_FLAG_ENABLED(grpc_trace_ares_driver) ? ""GrpcAresRequest""+                                                          : nullptr),+      name_(name),+      default_port_(default_port.has_value() ? *default_port : """"),+      timeout_(timeout),+      fd_node_list_(std::make_unique<FdNodeList>()),+      event_engine_(event_engine),+      polled_fd_factory_(NewGrpcPolledFdFactory(std::move(register_cb), &mu_)) {+}++GrpcAresRequest::~GrpcAresRequest() {+  if (initialized_) {+    ares_destroy(channel_);+    GRPC_ARES_DRIVER_TRACE_LOG(""request:%p destructor"", this);+    GRPC_ARES_DRIVER_STACK_TRACE();+  }+}++absl::Status GrpcAresRequest::Initialize(absl::string_view dns_server,+                                         bool check_port) {+  absl::MutexLock lock(&mu_);+  GPR_DEBUG_ASSERT(!initialized_);+  absl::string_view port;+  GPR_ASSERT(grpc_core::SplitHostPort(name_, &host_, &port));","I believe the assert is wrong here, it was crashing on the naming resolver tests when I patched your PR in.",
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/32701,1153915748,2023-03-31T00:52:51Z,src/core/lib/event_engine/ares_driver.cc,"@@ -0,0 +1,952 @@+// Copyright 2023 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++#include ""src/core/lib/event_engine/ares_driver.h""++#include <arpa/nameser.h>+#include <inttypes.h>+#include <netdb.h>+#include <string.h>++#include <algorithm>+#include <chrono>+#include <initializer_list>+#include <ratio>+#include <type_traits>+#include <utility>++#include <address_sorting/address_sorting.h>++#include ""absl/strings/str_cat.h""+#include ""absl/strings/str_format.h""+#include ""absl/types/optional.h""++#include <grpc/event_engine/event_engine.h>+#include <grpc/support/alloc.h>+#include <grpc/support/log.h>++#include ""src/core/lib/address_utils/parse_address.h""+#include ""src/core/lib/address_utils/sockaddr_utils.h""+#include ""src/core/lib/debug/trace.h""+#include ""src/core/lib/event_engine/grpc_polled_fd.h""+#include ""src/core/lib/event_engine/nameser.h""  // IWYU pragma: keep+#include ""src/core/lib/event_engine/tcp_socket_utils.h""+#include ""src/core/lib/gpr/string.h""+#include ""src/core/lib/gprpp/debug_location.h""+#include ""src/core/lib/gprpp/examine_stack.h""+#include ""src/core/lib/gprpp/host_port.h""+#include ""src/core/lib/gprpp/ref_counted_ptr.h""+#include ""src/core/lib/gprpp/status_helper.h""+#include ""src/core/lib/iomgr/error.h""+#include ""src/core/lib/iomgr/exec_ctx.h""+#include ""src/core/lib/iomgr/resolved_address.h""+#include ""src/core/lib/iomgr/sockaddr.h""+#ifdef _WIN32+#else+#include ""src/core/lib/event_engine/posix_engine/tcp_socket_utils.h""+#endif++namespace grpc_event_engine {+namespace experimental {++grpc_core::TraceFlag grpc_trace_ares_driver_address_sorting(+    false, ""ares_driver_address_sorting"");++grpc_core::TraceFlag grpc_trace_ares_driver_stacktrace(+    false, ""ares_driver_stacktrace"");++#define GRPC_ARES_DRIVER_STACK_TRACE()                                \+  do {                                                                \+    if (GRPC_TRACE_FLAG_ENABLED(grpc_trace_ares_driver_stacktrace)) { \+      absl::optional<std::string> stacktrace =                        \+          grpc_core::GetCurrentStackTrace();                          \+      if (stacktrace.has_value()) {                                   \+        gpr_log(GPR_DEBUG, ""%s"", stacktrace->c_str());                \+      } else {                                                        \+        gpr_log(GPR_DEBUG, ""stacktrace unavailable"");                 \+      }                                                               \+    }                                                                 \+  } while (0)++grpc_core::TraceFlag grpc_trace_ares_driver(false, ""ares_driver"");++#define GRPC_ARES_DRIVER_TRACE_LOG(format, ...)                 \+  do {                                                          \+    if (GRPC_TRACE_FLAG_ENABLED(grpc_trace_ares_driver)) {      \+      gpr_log(GPR_DEBUG, ""(ares driver) "" format, __VA_ARGS__); \+    }                                                           \+  } while (0)++namespace {++struct HostbynameArg {+  GrpcAresHostnameRequest* request;+  const char* qtype;+};++void on_hostbyname_done_locked(void* arg, int status, int /*timeouts*/,+                               struct hostent* hostent)+    ABSL_NO_THREAD_SAFETY_ANALYSIS {+  // This callback is invoked from the c-ares library, so disable thread safety+  // analysis. Note that we are guaranteed to be holding r->mu, though.+  std::unique_ptr<HostbynameArg> harg(static_cast<HostbynameArg*>(arg));+  GrpcAresHostnameRequest* request = harg->request;+  if (status != ARES_SUCCESS) {+    std::string error_msg = absl::StrFormat(+        ""C-ares status is not ARES_SUCCESS qtype=%s name=%s: %s"", harg->qtype,+        request->host(), ares_strerror(status));+    GRPC_ARES_DRIVER_TRACE_LOG(""request:%p on_hostbyname_done_locked: %s"",+                               request, error_msg.c_str());+    GRPC_ARES_DRIVER_STACK_TRACE();+    absl::Status error = GRPC_ERROR_CREATE(error_msg);+    request->OnResolve(error);+    return;+  }+  GRPC_ARES_DRIVER_TRACE_LOG(+      ""request:%p on_hostbyname_done_locked qtype=%s host=%s ARES_SUCCESS"",+      request, harg->qtype, std::string(request->host()).c_str());+  GRPC_ARES_DRIVER_STACK_TRACE();++  std::vector<EventEngine::ResolvedAddress> resolved_addresses;+  for (size_t i = 0; hostent->h_addr_list[i] != nullptr; i++) {+    switch (hostent->h_addrtype) {+      case AF_INET6: {+        size_t addr_len = sizeof(struct sockaddr_in6);+        struct sockaddr_in6 addr;+        memset(&addr, 0, addr_len);+        memcpy(&addr.sin6_addr, hostent->h_addr_list[i],+               sizeof(struct in6_addr));+        addr.sin6_family = static_cast<unsigned char>(hostent->h_addrtype);+        addr.sin6_port = request->port();+        resolved_addresses.emplace_back(+            reinterpret_cast<const sockaddr*>(&addr), addr_len);+        char output[INET6_ADDRSTRLEN];+        ares_inet_ntop(AF_INET6, &addr.sin6_addr, output, INET6_ADDRSTRLEN);+        GRPC_ARES_DRIVER_TRACE_LOG(+            ""request:%p c-ares resolver gets a AF_INET6 result: \n""+            ""  addr: %s\n  port: %d\n  sin6_scope_id: %d\n"",+            request, output, ntohs(request->port()), addr.sin6_scope_id);+        break;+      }+      case AF_INET: {+        size_t addr_len = sizeof(struct sockaddr_in);+        struct sockaddr_in addr;+        memset(&addr, 0, addr_len);+        memcpy(&addr.sin_addr, hostent->h_addr_list[i], sizeof(struct in_addr));+        addr.sin_family = static_cast<unsigned char>(hostent->h_addrtype);+        addr.sin_port = request->port();+        resolved_addresses.emplace_back(+            reinterpret_cast<const sockaddr*>(&addr), addr_len);+        char output[INET_ADDRSTRLEN];+        ares_inet_ntop(AF_INET, &addr.sin_addr, output, INET_ADDRSTRLEN);+        GRPC_ARES_DRIVER_TRACE_LOG(+            ""request:%p c-ares resolver gets a AF_INET result: \n""+            ""  addr: %s\n  port: %d\n"",+            request, output, ntohs(request->port()));+        break;+      }+    }+  }+  request->OnResolve(std::move(resolved_addresses));+}++void on_srv_query_done_locked(void* arg, int status, int /*timeouts*/,+                              unsigned char* abuf,+                              int alen) ABSL_NO_THREAD_SAFETY_ANALYSIS {+  // This callback is invoked from the c-ares library, so disable thread safety+  // analysis. Note that we are guaranteed to be holding r->mu, though.+  GrpcAresSRVRequest* r = static_cast<GrpcAresSRVRequest*>(arg);+  if (status != ARES_SUCCESS) {+    std::string error_msg = absl::StrFormat(+        ""C-ares status is not ARES_SUCCESS qtype=SRV name=%s: %s"",+        r->service_name(), ares_strerror(status));+    GRPC_ARES_DRIVER_TRACE_LOG(""request:%p on_srv_query_done_locked: %s"", r,+                               error_msg.c_str());+    grpc_error_handle error = GRPC_ERROR_CREATE(error_msg);+    r->OnResolve(error);+    return;+  }+  GRPC_ARES_DRIVER_TRACE_LOG(+      ""request:%p on_srv_query_done_locked name=%s ARES_SUCCESS"", r,+      r->service_name());+  struct ares_srv_reply* reply = nullptr;+  const int parse_status = ares_parse_srv_reply(abuf, alen, &reply);+  GRPC_ARES_DRIVER_TRACE_LOG(""request:%p ares_parse_srv_reply: %d"", r,+                             parse_status);+  std::vector<EventEngine::DNSResolver::SRVRecord> result;+  if (parse_status == ARES_SUCCESS) {+    for (struct ares_srv_reply* srv_it = reply; srv_it != nullptr;+         srv_it = srv_it->next) {+      result.push_back({.host = srv_it->host,+                        .port = srv_it->port,+                        .priority = srv_it->priority,+                        .weight = srv_it->weight});+    }+  }+  if (reply != nullptr) {+    ares_free_data(reply);+  }+  r->OnResolve(std::move(result));+}++constexpr char g_service_config_attribute_prefix[] = ""grpc_config="";+constexpr size_t g_prefix_len = sizeof(g_service_config_attribute_prefix) - 1;++void on_txt_done_locked(void* arg, int status, int /*timeouts*/,+                        unsigned char* buf,+                        int len) ABSL_NO_THREAD_SAFETY_ANALYSIS {+  // This callback is invoked from the c-ares library, so disable thread safety+  // analysis. Note that we are guaranteed to be holding r->mu, though.+  GrpcAresTXTRequest* r = static_cast<GrpcAresTXTRequest*>(arg);+  struct ares_txt_ext* reply = nullptr;+  int parse_status = ARES_SUCCESS;+  if (status == ARES_SUCCESS) {+    GRPC_ARES_DRIVER_TRACE_LOG(+        ""request:%p on_txt_done_locked name=%s ARES_SUCCESS"", r,+        r->config_name());+    parse_status = ares_parse_txt_reply_ext(buf, len, &reply);+  }+  if (status != ARES_SUCCESS || parse_status != ARES_SUCCESS) {+    grpc_error_handle error;+    std::string error_msg = absl::StrFormat(+        ""C-ares status is not ARES_SUCCESS qtype=TXT name=%s: %s"",+        r->config_name(), ares_strerror(status));+    GRPC_ARES_DRIVER_TRACE_LOG(""request:%p on_txt_done_locked %s"", r,+                               error_msg.c_str());+    error = GRPC_ERROR_CREATE(error_msg);+    r->OnResolve(error);+    return;+  }+  // Find service config in TXT record.+  struct ares_txt_ext* result = nullptr;+  for (result = reply; result != nullptr; result = result->next) {+    if (result->record_start &&+        memcmp(result->txt, g_service_config_attribute_prefix, g_prefix_len) ==+            0) {+      break;+    }+  }+  std::string service_config_json_out;+  // Found a service config record.+  if (result != nullptr) {+    size_t service_config_len = result->length - g_prefix_len;+    service_config_json_out.append(+        reinterpret_cast<char*>(result->txt) + g_prefix_len,+        service_config_len);+    for (result = result->next; result != nullptr && !result->record_start;+         result = result->next) {+      service_config_json_out.append(reinterpret_cast<char*>(result->txt),+                                     result->length);+    }+    GRPC_ARES_DRIVER_TRACE_LOG(""request:%p found service config: %s"", r,+                               service_config_json_out.c_str());+  }+  // Clean up.+  ares_free_data(reply);+  r->OnResolve(std::move(service_config_json_out));+}++EventEngine::Duration calculate_next_ares_backup_poll_alarm_duration() {+  // An alternative here could be to use ares_timeout to try to be more+  // accurate, but that would require using ""struct timeval""'s, which just makes+  // things a bit more complicated. So just poll every second, as suggested+  // by the c-ares code comments.+  return std::chrono::seconds(1);+}++bool IsIpv6LoopbackAvailable() {+#ifdef _WIN32+  // TODO(yijiem): (debt) move pieces for Windows+#else+  return PosixSocketWrapper::IsIpv6LoopbackAvailable();+#endif+}++}  // namespace++struct GrpcAresRequest::FdNode {+  FdNode() = default;+  explicit FdNode(ares_socket_t as, GrpcPolledFd* polled_fd)+      : as(as), polled_fd(polled_fd) {}+  ares_socket_t as;+  std::unique_ptr<GrpcPolledFd> polled_fd;+  // next fd node+  FdNode* next = nullptr;+  /// if the readable closure has been registered+  bool readable_registered = false;+  /// if the writable closure has been registered+  bool writable_registered = false;+  bool already_shutdown = false;+};++// TODO(yijiem): see if we can use std::list+// per ares-channel linked-list of FdNodes+class GrpcAresRequest::FdNodeList {+ public:+  class FdNodeListIterator {+   public:+    bool operator!=(const FdNodeListIterator& other) {+      return node_ != other.node_;+    }+    bool operator==(const FdNodeListIterator& other) {+      return node_ == other.node_;+    }+    FdNodeListIterator& operator++(int) {+      node_ = node_->next;+      return *this;+    }+    FdNode* operator*() { return node_; }+    static FdNodeListIterator universal_end() {+      return FdNodeListIterator(nullptr);+    }++   private:+    friend class FdNodeList;+    explicit FdNodeListIterator(FdNode* node) : node_(node) {}+    FdNode* node_;+  };+  using Iterator = FdNodeListIterator;++  FdNodeList() = default;+  ~FdNodeList() { GPR_ASSERT(IsEmpty()); }++  Iterator begin() { return Iterator(head_); }+  Iterator end() { return Iterator::universal_end(); }++  bool IsEmpty() const { return head_ == nullptr; }++  void PushFdNode(FdNode* fd_node)+      ABSL_EXCLUSIVE_LOCKS_REQUIRED(&GrpcAresRequest::mu_) {+    fd_node->next = head_;+    head_ = fd_node;+  }++  FdNode* PopFdNode() ABSL_EXCLUSIVE_LOCKS_REQUIRED(&GrpcAresRequest::mu_) {+    GPR_ASSERT(!IsEmpty());+    FdNode* ret = head_;+    head_ = head_->next;+    return ret;+  }++  // Search for as in the FdNode list. This is an O(n) search, the max+  // possible value of n is ARES_GETSOCK_MAXNUM (16). n is typically 1 - 2+  // in our tests.+  FdNode* PopFdNode(ares_socket_t as)+      ABSL_EXCLUSIVE_LOCKS_REQUIRED(&GrpcAresRequest::mu_) {+    FdNode phony_head;+    phony_head.next = head_;+    FdNode* node = &phony_head;+    while (node->next != nullptr) {+      if (node->next->polled_fd->GetWrappedAresSocketLocked() == as) {+        FdNode* ret = node->next;+        node->next = node->next->next;+        head_ = phony_head.next;+        return ret;+      }+      node = node->next;+    }+    return nullptr;+  }++ private:+  FdNode* head_ = nullptr;+};++GrpcAresRequest::GrpcAresRequest(+    absl::string_view name, absl::optional<absl::string_view> default_port,+    EventEngine::Duration timeout,+    RegisterAresSocketWithPollerCallback register_cb, EventEngine* event_engine)+    : grpc_core::RefCounted<GrpcAresRequest>(+          GRPC_TRACE_FLAG_ENABLED(grpc_trace_ares_driver) ? ""GrpcAresRequest""+                                                          : nullptr),+      name_(name),+      default_port_(default_port.has_value() ? *default_port : """"),+      timeout_(timeout),+      fd_node_list_(std::make_unique<FdNodeList>()),+      event_engine_(event_engine),+      polled_fd_factory_(NewGrpcPolledFdFactory(std::move(register_cb), &mu_)) {+}++GrpcAresRequest::~GrpcAresRequest() {+  if (initialized_) {+    ares_destroy(channel_);+    GRPC_ARES_DRIVER_TRACE_LOG(""request:%p destructor"", this);+    GRPC_ARES_DRIVER_STACK_TRACE();+  }+}++absl::Status GrpcAresRequest::Initialize(absl::string_view dns_server,+                                         bool check_port) {+  absl::MutexLock lock(&mu_);+  GPR_DEBUG_ASSERT(!initialized_);+  absl::string_view port;+  GPR_ASSERT(grpc_core::SplitHostPort(name_, &host_, &port));+  absl::Status error;+  if (host_.empty()) {+    error =+        grpc_error_set_str(GRPC_ERROR_CREATE(""unparseable host:port""),+                           grpc_core::StatusStrProperty::kTargetAddress, name_);+    return error;+  } else if (check_port && port.empty()) {+    if (default_port_.empty()) {+      error = grpc_error_set_str(GRPC_ERROR_CREATE(""no port in name""),+                                 grpc_core::StatusStrProperty::kTargetAddress,+                                 name_);+      return error;+    }+    port = default_port_;+  }+  if (!port.empty()) {+    port_ = grpc_strhtons(std::string(port).c_str());+  }+  ares_options opts = {};+  opts.flags |= ARES_FLAG_STAYOPEN;+  int status = ares_init_options(&channel_, &opts, ARES_OPT_FLAGS);+  if (status != ARES_SUCCESS) {+    gpr_log(GPR_ERROR, ""ares_init_options failed, status: %d"", status);+    return GRPC_ERROR_CREATE(absl::StrCat(+        ""Failed to init ares channel. C-ares error: "", ares_strerror(status)));+  }+  ares_driver_test_only_inject_config(channel_);+  error = SetRequestDNSServer(dns_server);+  if (!error.ok()) {+    return error;+  }+  initialized_ = true;+  return absl::OkStatus();+}++void GrpcAresRequest::Cancel() {+  absl::MutexLock lock(&mu_);+  if (!shutting_down_) {+    shutting_down_ = true;+    cancelled_ = true;+    ShutdownPollerHandles();+  }+}++void GrpcAresRequest::Work() {+  std::unique_ptr<FdNodeList> new_list = std::make_unique<FdNodeList>();+  ares_socket_t socks[ARES_GETSOCK_MAXNUM];+  int socks_bitmask = ares_getsock(channel_, socks, ARES_GETSOCK_MAXNUM);+  for (size_t i = 0; i < ARES_GETSOCK_MAXNUM; i++) {+    if (ARES_GETSOCK_READABLE(socks_bitmask, i) ||+        ARES_GETSOCK_WRITABLE(socks_bitmask, i)) {+      FdNode* fd_node = fd_node_list_->PopFdNode(socks[i]);+      if (fd_node == nullptr) {+        fd_node = new FdNode(+            socks[i], polled_fd_factory_->NewGrpcPolledFdLocked(socks[i]));+        GRPC_ARES_DRIVER_TRACE_LOG(""request:%p new fd: %d"", this, fd_node->as);+      }+      new_list->PushFdNode(fd_node);+      // Register read_closure if the socket is readable and read_closure has+      // not been registered with this socket.+      if (ARES_GETSOCK_READABLE(socks_bitmask, i) &&+          !fd_node->readable_registered) {+        GRPC_ARES_DRIVER_TRACE_LOG(""request:%p notify read on: %d"", this,+                                   fd_node->as);+        fd_node->polled_fd->RegisterForOnReadableLocked(+            [self = Ref(DEBUG_LOCATION, ""Work""), fd_node](absl::Status status) {+              self->OnReadable(fd_node, status);+            });+        fd_node->readable_registered = true;+      }+      // Register write_closure if the socket is writable and write_closure+      // has not been registered with this socket.+      if (ARES_GETSOCK_WRITABLE(socks_bitmask, i) &&+          !fd_node->writable_registered) {+        GRPC_ARES_DRIVER_TRACE_LOG(""request:%p notify write on: %d"", this,+                                   fd_node->as);+        fd_node->polled_fd->RegisterForOnWriteableLocked(+            [self = Ref(DEBUG_LOCATION, ""Work""), fd_node](absl::Status status) {+              self->OnWritable(fd_node, status);+            });+        fd_node->writable_registered = true;+      }+    }+  }+  // Any remaining fds in ev_driver->fds were not returned by ares_getsock()+  // and are therefore no longer in use, so they can be shut down and removed+  // from the list.+  while (!fd_node_list_->IsEmpty()) {+    FdNode* fd_node = fd_node_list_->PopFdNode();+    if (!fd_node->already_shutdown) {+      fd_node->polled_fd->ShutdownLocked(absl::OkStatus());+      fd_node->already_shutdown = true;+    }+    if (!fd_node->readable_registered && !fd_node->writable_registered) {+      GRPC_ARES_DRIVER_TRACE_LOG(""request: %p delete fd: %s"", this,+                                 fd_node->polled_fd->GetName());+      delete fd_node;+    } else {+      new_list->PushFdNode(fd_node);+    }+  }+  fd_node_list_.swap(new_list);+}++void GrpcAresRequest::StartTimers() {+#define ToMillis(duration) \+  std::chrono::duration_cast<std::chrono::milliseconds>(duration).count()++  // Initialize overall DNS resolution timeout alarm+  EventEngine::Duration timeout =+      timeout_.count() == 0 ? EventEngine::Duration::max() : timeout_;+  GRPC_ARES_DRIVER_TRACE_LOG(""request:%p StartTimers timeout in %"" PRId64 "" ms"",+                             this, ToMillis(timeout));++  Ref(DEBUG_LOCATION, ""StartTimers"").release();+  query_timeout_handle_ = event_engine_->RunAfter(timeout, [this] {+    grpc_core::ApplicationCallbackExecCtx callback_exec_ctx;+    grpc_core::ExecCtx exec_ctx;+    OnQueryTimeout();+  });++  // Initialize the backup poll alarm+  EventEngine::Duration next_ares_backup_poll_alarm_duration =+      calculate_next_ares_backup_poll_alarm_duration();+  GRPC_ARES_DRIVER_TRACE_LOG(+      ""request:%p StartTimers next ares process poll time in %"" PRId64 "" ms"",+      this, ToMillis(next_ares_backup_poll_alarm_duration));++  Ref(DEBUG_LOCATION, ""StartTimers"").release();+  ares_backup_poll_alarm_handle_ =+      event_engine_->RunAfter(next_ares_backup_poll_alarm_duration, [this] {+        grpc_core::ApplicationCallbackExecCtx callback_exec_ctx;+        grpc_core::ExecCtx exec_ctx;+        OnAresBackupPollAlarm();+      });+}++void GrpcAresRequest::CancelTimers() {+  if (query_timeout_handle_.has_value()) {+    if (event_engine_->Cancel(*query_timeout_handle_)) {+      Unref(DEBUG_LOCATION, ""CancelTimers"");+    }+    query_timeout_handle_.reset();+  }+  if (ares_backup_poll_alarm_handle_.has_value()) {+    if (event_engine_->Cancel(*ares_backup_poll_alarm_handle_)) {+      Unref(DEBUG_LOCATION, ""CancelTimers"");+    }+    ares_backup_poll_alarm_handle_.reset();+  }+}++absl::Status GrpcAresRequest::SetRequestDNSServer(+    absl::string_view dns_server) {+  if (!dns_server.empty()) {+    GRPC_ARES_DRIVER_TRACE_LOG(""request:%p Using DNS server %s"", this,+                               dns_server.data());+    grpc_resolved_address addr;+    struct ares_addr_port_node dns_server_addr;+    if (grpc_parse_ipv4_hostport(dns_server, &addr, /*log_errors=*/false)) {+      dns_server_addr.family = AF_INET;+      struct sockaddr_in* in = reinterpret_cast<struct sockaddr_in*>(addr.addr);+      memcpy(&dns_server_addr.addr.addr4, &in->sin_addr,+             sizeof(struct in_addr));+      dns_server_addr.tcp_port = grpc_sockaddr_get_port(&addr);+      dns_server_addr.udp_port = grpc_sockaddr_get_port(&addr);+    } else if (grpc_parse_ipv6_hostport(dns_server, &addr,+                                        /*log_errors=*/false)) {+      dns_server_addr.family = AF_INET6;+      struct sockaddr_in6* in6 =+          reinterpret_cast<struct sockaddr_in6*>(addr.addr);+      memcpy(&dns_server_addr.addr.addr6, &in6->sin6_addr,+             sizeof(struct in6_addr));+      dns_server_addr.tcp_port = grpc_sockaddr_get_port(&addr);+      dns_server_addr.udp_port = grpc_sockaddr_get_port(&addr);+    } else {+      return GRPC_ERROR_CREATE(+          absl::StrCat(""cannot parse authority "", dns_server));+    }+    // Prevent an uninitialized variable.+    dns_server_addr.next = nullptr;+    int status = ares_set_servers_ports(channel_, &dns_server_addr);+    if (status != ARES_SUCCESS) {+      return GRPC_ERROR_CREATE(absl::StrCat(+          ""C-ares status is not ARES_SUCCESS: "", ares_strerror(status)));+    }+  }+  return absl::OkStatus();+}++void GrpcAresRequest::OnReadable(FdNode* fd_node, absl::Status status) {+  absl::MutexLock lock(&mu_);+  GPR_ASSERT(fd_node->readable_registered);+  fd_node->readable_registered = false;+  GRPC_ARES_DRIVER_TRACE_LOG(""OnReadable: request: %p; fd: %d; status: %s"",+                             this, fd_node->as, status.ToString().c_str());+  GRPC_ARES_DRIVER_STACK_TRACE();+  if (status.ok() && !shutting_down_) {+    do {+      ares_process_fd(channel_, static_cast<ares_socket_t>(fd_node->as),+                      ARES_SOCKET_BAD);+    } while (fd_node->polled_fd->IsFdStillReadableLocked());+  } else {+    // If error is not absl::OkStatus() or the resolution was cancelled, it+    // means the fd has been shutdown or timed out. The pending lookups made+    // on this ev_driver will be cancelled by the following ares_cancel() and+    // the on_done callbacks will be invoked with a status of ARES_ECANCELLED.+    // The remaining file descriptors in this ev_driver will be cleaned up in+    // the follwing grpc_ares_notify_on_event_locked().+    ares_cancel(channel_);+  }+  Work();+}++void GrpcAresRequest::OnWritable(FdNode* fd_node, absl::Status status) {+  absl::MutexLock lock(&mu_);+  GPR_ASSERT(fd_node->writable_registered);+  fd_node->writable_registered = false;+  GRPC_ARES_DRIVER_TRACE_LOG(""OnWritable: fd: %d; request:%p; status: %s"",+                             fd_node->as, this, status.ToString().c_str());+  if (status.ok() && !shutting_down_) {+    ares_process_fd(channel_, ARES_SOCKET_BAD,+                    static_cast<ares_socket_t>(fd_node->as));+  } else {+    // If error is not absl::OkStatus() or the resolution was cancelled, it+    // means the fd has been shutdown or timed out. The pending lookups made+    // on this ev_driver will be cancelled by the following ares_cancel() and+    // the on_done callbacks will be invoked with a status of ARES_ECANCELLED.+    // The remaining file descriptors in this ev_driver will be cleaned up in+    // the follwing grpc_ares_notify_on_event_locked().+    ares_cancel(channel_);+  }+  Work();+}++void GrpcAresRequest::OnQueryTimeout() {+  absl::MutexLock lock(&mu_);+  query_timeout_handle_.reset();+  GRPC_ARES_DRIVER_TRACE_LOG(""request:%p OnQueryTimeout. shutting_down_=%d"",+                             this, shutting_down_);+  if (!shutting_down_) {+    shutting_down_ = true;+    ShutdownPollerHandles();+  }+  Unref(DEBUG_LOCATION, ""OnQueryTimeout"");+}++// In case of non-responsive DNS servers, dropped packets, etc., c-ares has+// intelligent timeout and retry logic, which we can take advantage of by+// polling ares_process_fd on time intervals. Overall, the c-ares library is+// meant to be called into and given a chance to proceed name resolution:+//   a) when fd events happen+//   b) when some time has passed without fd events having happened+// For the latter, we use this backup poller. Also see+// https://github.com/grpc/grpc/pull/17688 description for more details.+void GrpcAresRequest::OnAresBackupPollAlarm() {+  absl::MutexLock lock(&mu_);+  ares_backup_poll_alarm_handle_.reset();+  GRPC_ARES_DRIVER_TRACE_LOG(+      ""request:%p OnAresBackupPollAlarm shutting_down=%d."", this,+      shutting_down_);+  if (!shutting_down_) {+    for (auto it = fd_node_list_->begin(); it != fd_node_list_->end(); it++) {+      if (!(*it)->already_shutdown) {+        GRPC_ARES_DRIVER_TRACE_LOG(+            ""request:%p OnAresBackupPollAlarm; ares_process_fd. fd=%s"", this,+            (*it)->polled_fd->GetName());+        ares_socket_t as = (*it)->polled_fd->GetWrappedAresSocketLocked();+        ares_process_fd(channel_, as, as);+      }+    }+    if (!shutting_down_) {+      EventEngine::Duration next_ares_backup_poll_alarm_duration =+          calculate_next_ares_backup_poll_alarm_duration();+      Ref(DEBUG_LOCATION, ""OnAresBackupPollAlarm"").release();+      ares_backup_poll_alarm_handle_ =+          event_engine_->RunAfter(next_ares_backup_poll_alarm_duration, [this] {+            grpc_core::ApplicationCallbackExecCtx callback_exec_ctx;+            grpc_core::ExecCtx exec_ctx;+            OnAresBackupPollAlarm();+          });+    }+    Work();+  }+  Unref(DEBUG_LOCATION, ""OnAresBackupPollAlarm"");+}++void GrpcAresRequest::ShutdownPollerHandles() {",Consider renaming to `ShutdownPollerHandlesLocked`,X
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/32701,1153915984,2023-03-31T00:53:37Z,src/core/lib/event_engine/ares_driver.cc,"@@ -0,0 +1,952 @@+// Copyright 2023 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++#include ""src/core/lib/event_engine/ares_driver.h""++#include <arpa/nameser.h>+#include <inttypes.h>+#include <netdb.h>+#include <string.h>++#include <algorithm>+#include <chrono>+#include <initializer_list>+#include <ratio>+#include <type_traits>+#include <utility>++#include <address_sorting/address_sorting.h>++#include ""absl/strings/str_cat.h""+#include ""absl/strings/str_format.h""+#include ""absl/types/optional.h""++#include <grpc/event_engine/event_engine.h>+#include <grpc/support/alloc.h>+#include <grpc/support/log.h>++#include ""src/core/lib/address_utils/parse_address.h""+#include ""src/core/lib/address_utils/sockaddr_utils.h""+#include ""src/core/lib/debug/trace.h""+#include ""src/core/lib/event_engine/grpc_polled_fd.h""+#include ""src/core/lib/event_engine/nameser.h""  // IWYU pragma: keep+#include ""src/core/lib/event_engine/tcp_socket_utils.h""+#include ""src/core/lib/gpr/string.h""+#include ""src/core/lib/gprpp/debug_location.h""+#include ""src/core/lib/gprpp/examine_stack.h""+#include ""src/core/lib/gprpp/host_port.h""+#include ""src/core/lib/gprpp/ref_counted_ptr.h""+#include ""src/core/lib/gprpp/status_helper.h""+#include ""src/core/lib/iomgr/error.h""+#include ""src/core/lib/iomgr/exec_ctx.h""+#include ""src/core/lib/iomgr/resolved_address.h""+#include ""src/core/lib/iomgr/sockaddr.h""+#ifdef _WIN32+#else+#include ""src/core/lib/event_engine/posix_engine/tcp_socket_utils.h""+#endif++namespace grpc_event_engine {+namespace experimental {++grpc_core::TraceFlag grpc_trace_ares_driver_address_sorting(+    false, ""ares_driver_address_sorting"");++grpc_core::TraceFlag grpc_trace_ares_driver_stacktrace(+    false, ""ares_driver_stacktrace"");++#define GRPC_ARES_DRIVER_STACK_TRACE()                                \+  do {                                                                \+    if (GRPC_TRACE_FLAG_ENABLED(grpc_trace_ares_driver_stacktrace)) { \+      absl::optional<std::string> stacktrace =                        \+          grpc_core::GetCurrentStackTrace();                          \+      if (stacktrace.has_value()) {                                   \+        gpr_log(GPR_DEBUG, ""%s"", stacktrace->c_str());                \+      } else {                                                        \+        gpr_log(GPR_DEBUG, ""stacktrace unavailable"");                 \+      }                                                               \+    }                                                                 \+  } while (0)++grpc_core::TraceFlag grpc_trace_ares_driver(false, ""ares_driver"");++#define GRPC_ARES_DRIVER_TRACE_LOG(format, ...)                 \+  do {                                                          \+    if (GRPC_TRACE_FLAG_ENABLED(grpc_trace_ares_driver)) {      \+      gpr_log(GPR_DEBUG, ""(ares driver) "" format, __VA_ARGS__); \+    }                                                           \+  } while (0)++namespace {++struct HostbynameArg {+  GrpcAresHostnameRequest* request;+  const char* qtype;+};++void on_hostbyname_done_locked(void* arg, int status, int /*timeouts*/,+                               struct hostent* hostent)+    ABSL_NO_THREAD_SAFETY_ANALYSIS {+  // This callback is invoked from the c-ares library, so disable thread safety+  // analysis. Note that we are guaranteed to be holding r->mu, though.+  std::unique_ptr<HostbynameArg> harg(static_cast<HostbynameArg*>(arg));+  GrpcAresHostnameRequest* request = harg->request;+  if (status != ARES_SUCCESS) {+    std::string error_msg = absl::StrFormat(+        ""C-ares status is not ARES_SUCCESS qtype=%s name=%s: %s"", harg->qtype,+        request->host(), ares_strerror(status));+    GRPC_ARES_DRIVER_TRACE_LOG(""request:%p on_hostbyname_done_locked: %s"",+                               request, error_msg.c_str());+    GRPC_ARES_DRIVER_STACK_TRACE();+    absl::Status error = GRPC_ERROR_CREATE(error_msg);+    request->OnResolve(error);+    return;+  }+  GRPC_ARES_DRIVER_TRACE_LOG(+      ""request:%p on_hostbyname_done_locked qtype=%s host=%s ARES_SUCCESS"",+      request, harg->qtype, std::string(request->host()).c_str());+  GRPC_ARES_DRIVER_STACK_TRACE();++  std::vector<EventEngine::ResolvedAddress> resolved_addresses;+  for (size_t i = 0; hostent->h_addr_list[i] != nullptr; i++) {+    switch (hostent->h_addrtype) {+      case AF_INET6: {+        size_t addr_len = sizeof(struct sockaddr_in6);+        struct sockaddr_in6 addr;+        memset(&addr, 0, addr_len);+        memcpy(&addr.sin6_addr, hostent->h_addr_list[i],+               sizeof(struct in6_addr));+        addr.sin6_family = static_cast<unsigned char>(hostent->h_addrtype);+        addr.sin6_port = request->port();+        resolved_addresses.emplace_back(+            reinterpret_cast<const sockaddr*>(&addr), addr_len);+        char output[INET6_ADDRSTRLEN];+        ares_inet_ntop(AF_INET6, &addr.sin6_addr, output, INET6_ADDRSTRLEN);+        GRPC_ARES_DRIVER_TRACE_LOG(+            ""request:%p c-ares resolver gets a AF_INET6 result: \n""+            ""  addr: %s\n  port: %d\n  sin6_scope_id: %d\n"",+            request, output, ntohs(request->port()), addr.sin6_scope_id);+        break;+      }+      case AF_INET: {+        size_t addr_len = sizeof(struct sockaddr_in);+        struct sockaddr_in addr;+        memset(&addr, 0, addr_len);+        memcpy(&addr.sin_addr, hostent->h_addr_list[i], sizeof(struct in_addr));+        addr.sin_family = static_cast<unsigned char>(hostent->h_addrtype);+        addr.sin_port = request->port();+        resolved_addresses.emplace_back(+            reinterpret_cast<const sockaddr*>(&addr), addr_len);+        char output[INET_ADDRSTRLEN];+        ares_inet_ntop(AF_INET, &addr.sin_addr, output, INET_ADDRSTRLEN);+        GRPC_ARES_DRIVER_TRACE_LOG(+            ""request:%p c-ares resolver gets a AF_INET result: \n""+            ""  addr: %s\n  port: %d\n"",+            request, output, ntohs(request->port()));+        break;+      }+    }+  }+  request->OnResolve(std::move(resolved_addresses));+}++void on_srv_query_done_locked(void* arg, int status, int /*timeouts*/,+                              unsigned char* abuf,+                              int alen) ABSL_NO_THREAD_SAFETY_ANALYSIS {+  // This callback is invoked from the c-ares library, so disable thread safety+  // analysis. Note that we are guaranteed to be holding r->mu, though.+  GrpcAresSRVRequest* r = static_cast<GrpcAresSRVRequest*>(arg);+  if (status != ARES_SUCCESS) {+    std::string error_msg = absl::StrFormat(+        ""C-ares status is not ARES_SUCCESS qtype=SRV name=%s: %s"",+        r->service_name(), ares_strerror(status));+    GRPC_ARES_DRIVER_TRACE_LOG(""request:%p on_srv_query_done_locked: %s"", r,+                               error_msg.c_str());+    grpc_error_handle error = GRPC_ERROR_CREATE(error_msg);+    r->OnResolve(error);+    return;+  }+  GRPC_ARES_DRIVER_TRACE_LOG(+      ""request:%p on_srv_query_done_locked name=%s ARES_SUCCESS"", r,+      r->service_name());+  struct ares_srv_reply* reply = nullptr;+  const int parse_status = ares_parse_srv_reply(abuf, alen, &reply);+  GRPC_ARES_DRIVER_TRACE_LOG(""request:%p ares_parse_srv_reply: %d"", r,+                             parse_status);+  std::vector<EventEngine::DNSResolver::SRVRecord> result;+  if (parse_status == ARES_SUCCESS) {+    for (struct ares_srv_reply* srv_it = reply; srv_it != nullptr;+         srv_it = srv_it->next) {+      result.push_back({.host = srv_it->host,+                        .port = srv_it->port,+                        .priority = srv_it->priority,+                        .weight = srv_it->weight});+    }+  }+  if (reply != nullptr) {+    ares_free_data(reply);+  }+  r->OnResolve(std::move(result));+}++constexpr char g_service_config_attribute_prefix[] = ""grpc_config="";+constexpr size_t g_prefix_len = sizeof(g_service_config_attribute_prefix) - 1;++void on_txt_done_locked(void* arg, int status, int /*timeouts*/,+                        unsigned char* buf,+                        int len) ABSL_NO_THREAD_SAFETY_ANALYSIS {+  // This callback is invoked from the c-ares library, so disable thread safety+  // analysis. Note that we are guaranteed to be holding r->mu, though.+  GrpcAresTXTRequest* r = static_cast<GrpcAresTXTRequest*>(arg);+  struct ares_txt_ext* reply = nullptr;+  int parse_status = ARES_SUCCESS;+  if (status == ARES_SUCCESS) {+    GRPC_ARES_DRIVER_TRACE_LOG(+        ""request:%p on_txt_done_locked name=%s ARES_SUCCESS"", r,+        r->config_name());+    parse_status = ares_parse_txt_reply_ext(buf, len, &reply);+  }+  if (status != ARES_SUCCESS || parse_status != ARES_SUCCESS) {+    grpc_error_handle error;+    std::string error_msg = absl::StrFormat(+        ""C-ares status is not ARES_SUCCESS qtype=TXT name=%s: %s"",+        r->config_name(), ares_strerror(status));+    GRPC_ARES_DRIVER_TRACE_LOG(""request:%p on_txt_done_locked %s"", r,+                               error_msg.c_str());+    error = GRPC_ERROR_CREATE(error_msg);+    r->OnResolve(error);+    return;+  }+  // Find service config in TXT record.+  struct ares_txt_ext* result = nullptr;+  for (result = reply; result != nullptr; result = result->next) {+    if (result->record_start &&+        memcmp(result->txt, g_service_config_attribute_prefix, g_prefix_len) ==+            0) {+      break;+    }+  }+  std::string service_config_json_out;+  // Found a service config record.+  if (result != nullptr) {+    size_t service_config_len = result->length - g_prefix_len;+    service_config_json_out.append(+        reinterpret_cast<char*>(result->txt) + g_prefix_len,+        service_config_len);+    for (result = result->next; result != nullptr && !result->record_start;+         result = result->next) {+      service_config_json_out.append(reinterpret_cast<char*>(result->txt),+                                     result->length);+    }+    GRPC_ARES_DRIVER_TRACE_LOG(""request:%p found service config: %s"", r,+                               service_config_json_out.c_str());+  }+  // Clean up.+  ares_free_data(reply);+  r->OnResolve(std::move(service_config_json_out));+}++EventEngine::Duration calculate_next_ares_backup_poll_alarm_duration() {+  // An alternative here could be to use ares_timeout to try to be more+  // accurate, but that would require using ""struct timeval""'s, which just makes+  // things a bit more complicated. So just poll every second, as suggested+  // by the c-ares code comments.+  return std::chrono::seconds(1);+}++bool IsIpv6LoopbackAvailable() {+#ifdef _WIN32+  // TODO(yijiem): (debt) move pieces for Windows+#else+  return PosixSocketWrapper::IsIpv6LoopbackAvailable();+#endif+}++}  // namespace++struct GrpcAresRequest::FdNode {+  FdNode() = default;+  explicit FdNode(ares_socket_t as, GrpcPolledFd* polled_fd)+      : as(as), polled_fd(polled_fd) {}+  ares_socket_t as;+  std::unique_ptr<GrpcPolledFd> polled_fd;+  // next fd node+  FdNode* next = nullptr;+  /// if the readable closure has been registered+  bool readable_registered = false;+  /// if the writable closure has been registered+  bool writable_registered = false;+  bool already_shutdown = false;+};++// TODO(yijiem): see if we can use std::list+// per ares-channel linked-list of FdNodes+class GrpcAresRequest::FdNodeList {+ public:+  class FdNodeListIterator {+   public:+    bool operator!=(const FdNodeListIterator& other) {+      return node_ != other.node_;+    }+    bool operator==(const FdNodeListIterator& other) {+      return node_ == other.node_;+    }+    FdNodeListIterator& operator++(int) {+      node_ = node_->next;+      return *this;+    }+    FdNode* operator*() { return node_; }+    static FdNodeListIterator universal_end() {+      return FdNodeListIterator(nullptr);+    }++   private:+    friend class FdNodeList;+    explicit FdNodeListIterator(FdNode* node) : node_(node) {}+    FdNode* node_;+  };+  using Iterator = FdNodeListIterator;++  FdNodeList() = default;+  ~FdNodeList() { GPR_ASSERT(IsEmpty()); }++  Iterator begin() { return Iterator(head_); }+  Iterator end() { return Iterator::universal_end(); }++  bool IsEmpty() const { return head_ == nullptr; }++  void PushFdNode(FdNode* fd_node)+      ABSL_EXCLUSIVE_LOCKS_REQUIRED(&GrpcAresRequest::mu_) {+    fd_node->next = head_;+    head_ = fd_node;+  }++  FdNode* PopFdNode() ABSL_EXCLUSIVE_LOCKS_REQUIRED(&GrpcAresRequest::mu_) {+    GPR_ASSERT(!IsEmpty());+    FdNode* ret = head_;+    head_ = head_->next;+    return ret;+  }++  // Search for as in the FdNode list. This is an O(n) search, the max+  // possible value of n is ARES_GETSOCK_MAXNUM (16). n is typically 1 - 2+  // in our tests.+  FdNode* PopFdNode(ares_socket_t as)+      ABSL_EXCLUSIVE_LOCKS_REQUIRED(&GrpcAresRequest::mu_) {+    FdNode phony_head;+    phony_head.next = head_;+    FdNode* node = &phony_head;+    while (node->next != nullptr) {+      if (node->next->polled_fd->GetWrappedAresSocketLocked() == as) {+        FdNode* ret = node->next;+        node->next = node->next->next;+        head_ = phony_head.next;+        return ret;+      }+      node = node->next;+    }+    return nullptr;+  }++ private:+  FdNode* head_ = nullptr;+};++GrpcAresRequest::GrpcAresRequest(+    absl::string_view name, absl::optional<absl::string_view> default_port,+    EventEngine::Duration timeout,+    RegisterAresSocketWithPollerCallback register_cb, EventEngine* event_engine)+    : grpc_core::RefCounted<GrpcAresRequest>(+          GRPC_TRACE_FLAG_ENABLED(grpc_trace_ares_driver) ? ""GrpcAresRequest""+                                                          : nullptr),+      name_(name),+      default_port_(default_port.has_value() ? *default_port : """"),+      timeout_(timeout),+      fd_node_list_(std::make_unique<FdNodeList>()),+      event_engine_(event_engine),+      polled_fd_factory_(NewGrpcPolledFdFactory(std::move(register_cb), &mu_)) {+}++GrpcAresRequest::~GrpcAresRequest() {+  if (initialized_) {+    ares_destroy(channel_);+    GRPC_ARES_DRIVER_TRACE_LOG(""request:%p destructor"", this);+    GRPC_ARES_DRIVER_STACK_TRACE();+  }+}++absl::Status GrpcAresRequest::Initialize(absl::string_view dns_server,+                                         bool check_port) {+  absl::MutexLock lock(&mu_);+  GPR_DEBUG_ASSERT(!initialized_);+  absl::string_view port;+  GPR_ASSERT(grpc_core::SplitHostPort(name_, &host_, &port));+  absl::Status error;+  if (host_.empty()) {+    error =+        grpc_error_set_str(GRPC_ERROR_CREATE(""unparseable host:port""),+                           grpc_core::StatusStrProperty::kTargetAddress, name_);+    return error;+  } else if (check_port && port.empty()) {+    if (default_port_.empty()) {+      error = grpc_error_set_str(GRPC_ERROR_CREATE(""no port in name""),+                                 grpc_core::StatusStrProperty::kTargetAddress,+                                 name_);+      return error;+    }+    port = default_port_;+  }+  if (!port.empty()) {+    port_ = grpc_strhtons(std::string(port).c_str());+  }+  ares_options opts = {};+  opts.flags |= ARES_FLAG_STAYOPEN;+  int status = ares_init_options(&channel_, &opts, ARES_OPT_FLAGS);+  if (status != ARES_SUCCESS) {+    gpr_log(GPR_ERROR, ""ares_init_options failed, status: %d"", status);+    return GRPC_ERROR_CREATE(absl::StrCat(+        ""Failed to init ares channel. C-ares error: "", ares_strerror(status)));+  }+  ares_driver_test_only_inject_config(channel_);+  error = SetRequestDNSServer(dns_server);+  if (!error.ok()) {+    return error;+  }+  initialized_ = true;+  return absl::OkStatus();+}++void GrpcAresRequest::Cancel() {+  absl::MutexLock lock(&mu_);+  if (!shutting_down_) {+    shutting_down_ = true;+    cancelled_ = true;+    ShutdownPollerHandles();+  }+}++void GrpcAresRequest::Work() {+  std::unique_ptr<FdNodeList> new_list = std::make_unique<FdNodeList>();",nit: `auto new_list = std::make_unique<FdNodeList>();` is sufficiently self-descriptive for `std::make_*` calls.,
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/32701,1153918053,2023-03-31T00:59:35Z,src/core/lib/event_engine/ares_driver.cc,"@@ -0,0 +1,952 @@+// Copyright 2023 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++#include ""src/core/lib/event_engine/ares_driver.h""++#include <arpa/nameser.h>+#include <inttypes.h>+#include <netdb.h>+#include <string.h>++#include <algorithm>+#include <chrono>+#include <initializer_list>+#include <ratio>+#include <type_traits>+#include <utility>++#include <address_sorting/address_sorting.h>++#include ""absl/strings/str_cat.h""+#include ""absl/strings/str_format.h""+#include ""absl/types/optional.h""++#include <grpc/event_engine/event_engine.h>+#include <grpc/support/alloc.h>+#include <grpc/support/log.h>++#include ""src/core/lib/address_utils/parse_address.h""+#include ""src/core/lib/address_utils/sockaddr_utils.h""+#include ""src/core/lib/debug/trace.h""+#include ""src/core/lib/event_engine/grpc_polled_fd.h""+#include ""src/core/lib/event_engine/nameser.h""  // IWYU pragma: keep+#include ""src/core/lib/event_engine/tcp_socket_utils.h""+#include ""src/core/lib/gpr/string.h""+#include ""src/core/lib/gprpp/debug_location.h""+#include ""src/core/lib/gprpp/examine_stack.h""+#include ""src/core/lib/gprpp/host_port.h""+#include ""src/core/lib/gprpp/ref_counted_ptr.h""+#include ""src/core/lib/gprpp/status_helper.h""+#include ""src/core/lib/iomgr/error.h""+#include ""src/core/lib/iomgr/exec_ctx.h""+#include ""src/core/lib/iomgr/resolved_address.h""+#include ""src/core/lib/iomgr/sockaddr.h""+#ifdef _WIN32+#else+#include ""src/core/lib/event_engine/posix_engine/tcp_socket_utils.h""+#endif++namespace grpc_event_engine {+namespace experimental {++grpc_core::TraceFlag grpc_trace_ares_driver_address_sorting(+    false, ""ares_driver_address_sorting"");++grpc_core::TraceFlag grpc_trace_ares_driver_stacktrace(+    false, ""ares_driver_stacktrace"");++#define GRPC_ARES_DRIVER_STACK_TRACE()                                \+  do {                                                                \+    if (GRPC_TRACE_FLAG_ENABLED(grpc_trace_ares_driver_stacktrace)) { \+      absl::optional<std::string> stacktrace =                        \+          grpc_core::GetCurrentStackTrace();                          \+      if (stacktrace.has_value()) {                                   \+        gpr_log(GPR_DEBUG, ""%s"", stacktrace->c_str());                \+      } else {                                                        \+        gpr_log(GPR_DEBUG, ""stacktrace unavailable"");                 \+      }                                                               \+    }                                                                 \+  } while (0)++grpc_core::TraceFlag grpc_trace_ares_driver(false, ""ares_driver"");++#define GRPC_ARES_DRIVER_TRACE_LOG(format, ...)                 \+  do {                                                          \+    if (GRPC_TRACE_FLAG_ENABLED(grpc_trace_ares_driver)) {      \+      gpr_log(GPR_DEBUG, ""(ares driver) "" format, __VA_ARGS__); \+    }                                                           \+  } while (0)++namespace {++struct HostbynameArg {+  GrpcAresHostnameRequest* request;+  const char* qtype;+};++void on_hostbyname_done_locked(void* arg, int status, int /*timeouts*/,+                               struct hostent* hostent)+    ABSL_NO_THREAD_SAFETY_ANALYSIS {+  // This callback is invoked from the c-ares library, so disable thread safety+  // analysis. Note that we are guaranteed to be holding r->mu, though.+  std::unique_ptr<HostbynameArg> harg(static_cast<HostbynameArg*>(arg));+  GrpcAresHostnameRequest* request = harg->request;+  if (status != ARES_SUCCESS) {+    std::string error_msg = absl::StrFormat(+        ""C-ares status is not ARES_SUCCESS qtype=%s name=%s: %s"", harg->qtype,+        request->host(), ares_strerror(status));+    GRPC_ARES_DRIVER_TRACE_LOG(""request:%p on_hostbyname_done_locked: %s"",+                               request, error_msg.c_str());+    GRPC_ARES_DRIVER_STACK_TRACE();+    absl::Status error = GRPC_ERROR_CREATE(error_msg);+    request->OnResolve(error);+    return;+  }+  GRPC_ARES_DRIVER_TRACE_LOG(+      ""request:%p on_hostbyname_done_locked qtype=%s host=%s ARES_SUCCESS"",+      request, harg->qtype, std::string(request->host()).c_str());+  GRPC_ARES_DRIVER_STACK_TRACE();++  std::vector<EventEngine::ResolvedAddress> resolved_addresses;+  for (size_t i = 0; hostent->h_addr_list[i] != nullptr; i++) {+    switch (hostent->h_addrtype) {+      case AF_INET6: {+        size_t addr_len = sizeof(struct sockaddr_in6);+        struct sockaddr_in6 addr;+        memset(&addr, 0, addr_len);+        memcpy(&addr.sin6_addr, hostent->h_addr_list[i],+               sizeof(struct in6_addr));+        addr.sin6_family = static_cast<unsigned char>(hostent->h_addrtype);+        addr.sin6_port = request->port();+        resolved_addresses.emplace_back(+            reinterpret_cast<const sockaddr*>(&addr), addr_len);+        char output[INET6_ADDRSTRLEN];+        ares_inet_ntop(AF_INET6, &addr.sin6_addr, output, INET6_ADDRSTRLEN);+        GRPC_ARES_DRIVER_TRACE_LOG(+            ""request:%p c-ares resolver gets a AF_INET6 result: \n""+            ""  addr: %s\n  port: %d\n  sin6_scope_id: %d\n"",+            request, output, ntohs(request->port()), addr.sin6_scope_id);+        break;+      }+      case AF_INET: {+        size_t addr_len = sizeof(struct sockaddr_in);+        struct sockaddr_in addr;+        memset(&addr, 0, addr_len);+        memcpy(&addr.sin_addr, hostent->h_addr_list[i], sizeof(struct in_addr));+        addr.sin_family = static_cast<unsigned char>(hostent->h_addrtype);+        addr.sin_port = request->port();+        resolved_addresses.emplace_back(+            reinterpret_cast<const sockaddr*>(&addr), addr_len);+        char output[INET_ADDRSTRLEN];+        ares_inet_ntop(AF_INET, &addr.sin_addr, output, INET_ADDRSTRLEN);+        GRPC_ARES_DRIVER_TRACE_LOG(+            ""request:%p c-ares resolver gets a AF_INET result: \n""+            ""  addr: %s\n  port: %d\n"",+            request, output, ntohs(request->port()));+        break;+      }+    }+  }+  request->OnResolve(std::move(resolved_addresses));+}++void on_srv_query_done_locked(void* arg, int status, int /*timeouts*/,+                              unsigned char* abuf,+                              int alen) ABSL_NO_THREAD_SAFETY_ANALYSIS {+  // This callback is invoked from the c-ares library, so disable thread safety+  // analysis. Note that we are guaranteed to be holding r->mu, though.+  GrpcAresSRVRequest* r = static_cast<GrpcAresSRVRequest*>(arg);+  if (status != ARES_SUCCESS) {+    std::string error_msg = absl::StrFormat(+        ""C-ares status is not ARES_SUCCESS qtype=SRV name=%s: %s"",+        r->service_name(), ares_strerror(status));+    GRPC_ARES_DRIVER_TRACE_LOG(""request:%p on_srv_query_done_locked: %s"", r,+                               error_msg.c_str());+    grpc_error_handle error = GRPC_ERROR_CREATE(error_msg);+    r->OnResolve(error);+    return;+  }+  GRPC_ARES_DRIVER_TRACE_LOG(+      ""request:%p on_srv_query_done_locked name=%s ARES_SUCCESS"", r,+      r->service_name());+  struct ares_srv_reply* reply = nullptr;+  const int parse_status = ares_parse_srv_reply(abuf, alen, &reply);+  GRPC_ARES_DRIVER_TRACE_LOG(""request:%p ares_parse_srv_reply: %d"", r,+                             parse_status);+  std::vector<EventEngine::DNSResolver::SRVRecord> result;+  if (parse_status == ARES_SUCCESS) {+    for (struct ares_srv_reply* srv_it = reply; srv_it != nullptr;+         srv_it = srv_it->next) {+      result.push_back({.host = srv_it->host,+                        .port = srv_it->port,+                        .priority = srv_it->priority,+                        .weight = srv_it->weight});+    }+  }+  if (reply != nullptr) {+    ares_free_data(reply);+  }+  r->OnResolve(std::move(result));+}++constexpr char g_service_config_attribute_prefix[] = ""grpc_config="";+constexpr size_t g_prefix_len = sizeof(g_service_config_attribute_prefix) - 1;++void on_txt_done_locked(void* arg, int status, int /*timeouts*/,+                        unsigned char* buf,+                        int len) ABSL_NO_THREAD_SAFETY_ANALYSIS {+  // This callback is invoked from the c-ares library, so disable thread safety+  // analysis. Note that we are guaranteed to be holding r->mu, though.+  GrpcAresTXTRequest* r = static_cast<GrpcAresTXTRequest*>(arg);+  struct ares_txt_ext* reply = nullptr;+  int parse_status = ARES_SUCCESS;+  if (status == ARES_SUCCESS) {+    GRPC_ARES_DRIVER_TRACE_LOG(+        ""request:%p on_txt_done_locked name=%s ARES_SUCCESS"", r,+        r->config_name());+    parse_status = ares_parse_txt_reply_ext(buf, len, &reply);+  }+  if (status != ARES_SUCCESS || parse_status != ARES_SUCCESS) {+    grpc_error_handle error;+    std::string error_msg = absl::StrFormat(+        ""C-ares status is not ARES_SUCCESS qtype=TXT name=%s: %s"",+        r->config_name(), ares_strerror(status));+    GRPC_ARES_DRIVER_TRACE_LOG(""request:%p on_txt_done_locked %s"", r,+                               error_msg.c_str());+    error = GRPC_ERROR_CREATE(error_msg);+    r->OnResolve(error);+    return;+  }+  // Find service config in TXT record.+  struct ares_txt_ext* result = nullptr;+  for (result = reply; result != nullptr; result = result->next) {+    if (result->record_start &&+        memcmp(result->txt, g_service_config_attribute_prefix, g_prefix_len) ==+            0) {+      break;+    }+  }+  std::string service_config_json_out;+  // Found a service config record.+  if (result != nullptr) {+    size_t service_config_len = result->length - g_prefix_len;+    service_config_json_out.append(+        reinterpret_cast<char*>(result->txt) + g_prefix_len,+        service_config_len);+    for (result = result->next; result != nullptr && !result->record_start;+         result = result->next) {+      service_config_json_out.append(reinterpret_cast<char*>(result->txt),+                                     result->length);+    }+    GRPC_ARES_DRIVER_TRACE_LOG(""request:%p found service config: %s"", r,+                               service_config_json_out.c_str());+  }+  // Clean up.+  ares_free_data(reply);+  r->OnResolve(std::move(service_config_json_out));+}++EventEngine::Duration calculate_next_ares_backup_poll_alarm_duration() {+  // An alternative here could be to use ares_timeout to try to be more+  // accurate, but that would require using ""struct timeval""'s, which just makes+  // things a bit more complicated. So just poll every second, as suggested+  // by the c-ares code comments.+  return std::chrono::seconds(1);+}++bool IsIpv6LoopbackAvailable() {+#ifdef _WIN32+  // TODO(yijiem): (debt) move pieces for Windows+#else+  return PosixSocketWrapper::IsIpv6LoopbackAvailable();+#endif+}++}  // namespace++struct GrpcAresRequest::FdNode {+  FdNode() = default;+  explicit FdNode(ares_socket_t as, GrpcPolledFd* polled_fd)+      : as(as), polled_fd(polled_fd) {}+  ares_socket_t as;+  std::unique_ptr<GrpcPolledFd> polled_fd;+  // next fd node+  FdNode* next = nullptr;+  /// if the readable closure has been registered+  bool readable_registered = false;+  /// if the writable closure has been registered+  bool writable_registered = false;+  bool already_shutdown = false;+};++// TODO(yijiem): see if we can use std::list+// per ares-channel linked-list of FdNodes+class GrpcAresRequest::FdNodeList {+ public:+  class FdNodeListIterator {+   public:+    bool operator!=(const FdNodeListIterator& other) {+      return node_ != other.node_;+    }+    bool operator==(const FdNodeListIterator& other) {+      return node_ == other.node_;+    }+    FdNodeListIterator& operator++(int) {+      node_ = node_->next;+      return *this;+    }+    FdNode* operator*() { return node_; }+    static FdNodeListIterator universal_end() {+      return FdNodeListIterator(nullptr);+    }++   private:+    friend class FdNodeList;+    explicit FdNodeListIterator(FdNode* node) : node_(node) {}+    FdNode* node_;+  };+  using Iterator = FdNodeListIterator;++  FdNodeList() = default;+  ~FdNodeList() { GPR_ASSERT(IsEmpty()); }++  Iterator begin() { return Iterator(head_); }+  Iterator end() { return Iterator::universal_end(); }++  bool IsEmpty() const { return head_ == nullptr; }++  void PushFdNode(FdNode* fd_node)+      ABSL_EXCLUSIVE_LOCKS_REQUIRED(&GrpcAresRequest::mu_) {+    fd_node->next = head_;+    head_ = fd_node;+  }++  FdNode* PopFdNode() ABSL_EXCLUSIVE_LOCKS_REQUIRED(&GrpcAresRequest::mu_) {+    GPR_ASSERT(!IsEmpty());+    FdNode* ret = head_;+    head_ = head_->next;+    return ret;+  }++  // Search for as in the FdNode list. This is an O(n) search, the max+  // possible value of n is ARES_GETSOCK_MAXNUM (16). n is typically 1 - 2+  // in our tests.+  FdNode* PopFdNode(ares_socket_t as)+      ABSL_EXCLUSIVE_LOCKS_REQUIRED(&GrpcAresRequest::mu_) {+    FdNode phony_head;+    phony_head.next = head_;+    FdNode* node = &phony_head;+    while (node->next != nullptr) {+      if (node->next->polled_fd->GetWrappedAresSocketLocked() == as) {+        FdNode* ret = node->next;+        node->next = node->next->next;+        head_ = phony_head.next;+        return ret;+      }+      node = node->next;+    }+    return nullptr;+  }++ private:+  FdNode* head_ = nullptr;+};++GrpcAresRequest::GrpcAresRequest(+    absl::string_view name, absl::optional<absl::string_view> default_port,+    EventEngine::Duration timeout,+    RegisterAresSocketWithPollerCallback register_cb, EventEngine* event_engine)+    : grpc_core::RefCounted<GrpcAresRequest>(+          GRPC_TRACE_FLAG_ENABLED(grpc_trace_ares_driver) ? ""GrpcAresRequest""+                                                          : nullptr),+      name_(name),+      default_port_(default_port.has_value() ? *default_port : """"),+      timeout_(timeout),+      fd_node_list_(std::make_unique<FdNodeList>()),+      event_engine_(event_engine),+      polled_fd_factory_(NewGrpcPolledFdFactory(std::move(register_cb), &mu_)) {+}++GrpcAresRequest::~GrpcAresRequest() {+  if (initialized_) {+    ares_destroy(channel_);+    GRPC_ARES_DRIVER_TRACE_LOG(""request:%p destructor"", this);+    GRPC_ARES_DRIVER_STACK_TRACE();+  }+}++absl::Status GrpcAresRequest::Initialize(absl::string_view dns_server,+                                         bool check_port) {+  absl::MutexLock lock(&mu_);+  GPR_DEBUG_ASSERT(!initialized_);+  absl::string_view port;+  GPR_ASSERT(grpc_core::SplitHostPort(name_, &host_, &port));+  absl::Status error;+  if (host_.empty()) {+    error =+        grpc_error_set_str(GRPC_ERROR_CREATE(""unparseable host:port""),+                           grpc_core::StatusStrProperty::kTargetAddress, name_);+    return error;+  } else if (check_port && port.empty()) {+    if (default_port_.empty()) {+      error = grpc_error_set_str(GRPC_ERROR_CREATE(""no port in name""),+                                 grpc_core::StatusStrProperty::kTargetAddress,+                                 name_);+      return error;+    }+    port = default_port_;+  }+  if (!port.empty()) {+    port_ = grpc_strhtons(std::string(port).c_str());+  }+  ares_options opts = {};+  opts.flags |= ARES_FLAG_STAYOPEN;+  int status = ares_init_options(&channel_, &opts, ARES_OPT_FLAGS);+  if (status != ARES_SUCCESS) {+    gpr_log(GPR_ERROR, ""ares_init_options failed, status: %d"", status);+    return GRPC_ERROR_CREATE(absl::StrCat(+        ""Failed to init ares channel. C-ares error: "", ares_strerror(status)));+  }+  ares_driver_test_only_inject_config(channel_);+  error = SetRequestDNSServer(dns_server);+  if (!error.ok()) {+    return error;+  }+  initialized_ = true;+  return absl::OkStatus();+}++void GrpcAresRequest::Cancel() {+  absl::MutexLock lock(&mu_);+  if (!shutting_down_) {+    shutting_down_ = true;+    cancelled_ = true;+    ShutdownPollerHandles();+  }+}++void GrpcAresRequest::Work() {+  std::unique_ptr<FdNodeList> new_list = std::make_unique<FdNodeList>();+  ares_socket_t socks[ARES_GETSOCK_MAXNUM];+  int socks_bitmask = ares_getsock(channel_, socks, ARES_GETSOCK_MAXNUM);+  for (size_t i = 0; i < ARES_GETSOCK_MAXNUM; i++) {+    if (ARES_GETSOCK_READABLE(socks_bitmask, i) ||+        ARES_GETSOCK_WRITABLE(socks_bitmask, i)) {+      FdNode* fd_node = fd_node_list_->PopFdNode(socks[i]);+      if (fd_node == nullptr) {+        fd_node = new FdNode(+            socks[i], polled_fd_factory_->NewGrpcPolledFdLocked(socks[i]));+        GRPC_ARES_DRIVER_TRACE_LOG(""request:%p new fd: %d"", this, fd_node->as);+      }+      new_list->PushFdNode(fd_node);+      // Register read_closure if the socket is readable and read_closure has+      // not been registered with this socket.+      if (ARES_GETSOCK_READABLE(socks_bitmask, i) &&+          !fd_node->readable_registered) {+        GRPC_ARES_DRIVER_TRACE_LOG(""request:%p notify read on: %d"", this,+                                   fd_node->as);+        fd_node->polled_fd->RegisterForOnReadableLocked(+            [self = Ref(DEBUG_LOCATION, ""Work""), fd_node](absl::Status status) {+              self->OnReadable(fd_node, status);+            });+        fd_node->readable_registered = true;+      }+      // Register write_closure if the socket is writable and write_closure+      // has not been registered with this socket.+      if (ARES_GETSOCK_WRITABLE(socks_bitmask, i) &&+          !fd_node->writable_registered) {+        GRPC_ARES_DRIVER_TRACE_LOG(""request:%p notify write on: %d"", this,+                                   fd_node->as);+        fd_node->polled_fd->RegisterForOnWriteableLocked(+            [self = Ref(DEBUG_LOCATION, ""Work""), fd_node](absl::Status status) {+              self->OnWritable(fd_node, status);+            });+        fd_node->writable_registered = true;+      }+    }+  }+  // Any remaining fds in ev_driver->fds were not returned by ares_getsock()+  // and are therefore no longer in use, so they can be shut down and removed+  // from the list.+  while (!fd_node_list_->IsEmpty()) {+    FdNode* fd_node = fd_node_list_->PopFdNode();+    if (!fd_node->already_shutdown) {+      fd_node->polled_fd->ShutdownLocked(absl::OkStatus());+      fd_node->already_shutdown = true;+    }+    if (!fd_node->readable_registered && !fd_node->writable_registered) {+      GRPC_ARES_DRIVER_TRACE_LOG(""request: %p delete fd: %s"", this,+                                 fd_node->polled_fd->GetName());+      delete fd_node;+    } else {+      new_list->PushFdNode(fd_node);+    }+  }+  fd_node_list_.swap(new_list);+}++void GrpcAresRequest::StartTimers() {+#define ToMillis(duration) \",See https://github.com/grpc/grpc/blob/master/src/core/lib/event_engine/time_util.cc#L25,
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/32603,1153951797,2023-03-31T02:29:22Z,test/core/end2end/tests/retry_cancel_during_delay.cc,"@@ -14,232 +14,102 @@ // limitations under the License. // -#include <string.h>--#include <functional> #include <initializer_list> #include <memory>-#include <string> -#include ""absl/strings/str_cat.h"" #include ""absl/strings/str_format.h""-#include ""absl/strings/string_view.h""-#include ""absl/time/time.h""+#include ""absl/types/optional.h""+#include ""gtest/gtest.h"" -#include <grpc/byte_buffer.h> #include <grpc/grpc.h>-#include <grpc/impl/propagation_bits.h>-#include <grpc/slice.h> #include <grpc/status.h>-#include <grpc/support/alloc.h>-#include <grpc/support/log.h>-#include <grpc/support/time.h>  #include ""src/core/lib/channel/channel_args.h""-#include ""src/core/lib/gpr/useful.h""-#include ""src/core/lib/gprpp/time_util.h""-#include ""src/core/lib/slice/slice_internal.h""-#include ""test/core/end2end/cq_verifier.h""+#include ""src/core/lib/gprpp/time.h"" #include ""test/core/end2end/end2end_tests.h"" #include ""test/core/end2end/tests/cancel_test_helpers.h"" #include ""test/core/util/test_config.h"" -static std::unique_ptr<CoreTestFixture> begin_test(-    const CoreTestConfiguration& config, const char* test_name,-    grpc_channel_args* client_args, grpc_channel_args* server_args) {-  gpr_log(GPR_INFO, ""Running test: %s/%s"", test_name, config.name);-  auto f = config.create_fixture(grpc_core::ChannelArgs::FromC(client_args),-                                 grpc_core::ChannelArgs::FromC(server_args));-  f->InitServer(grpc_core::ChannelArgs::FromC(server_args));-  f->InitClient(grpc_core::ChannelArgs::FromC(client_args));-  return f;-}--// Tests retry cancellation during backoff.-static void test_retry_cancel_during_delay(const CoreTestConfiguration& config,-                                           cancellation_mode mode) {-  grpc_call* c;-  grpc_call* s;-  grpc_op ops[6];-  grpc_op* op;-  grpc_metadata_array initial_metadata_recv;-  grpc_metadata_array trailing_metadata_recv;-  grpc_metadata_array request_metadata_recv;-  grpc_call_details call_details;-  grpc_slice request_payload_slice = grpc_slice_from_static_string(""foo"");-  grpc_slice response_payload_slice = grpc_slice_from_static_string(""bar"");-  grpc_byte_buffer* request_payload =-      grpc_raw_byte_buffer_create(&request_payload_slice, 1);-  grpc_byte_buffer* response_payload =-      grpc_raw_byte_buffer_create(&response_payload_slice, 1);-  grpc_byte_buffer* request_payload_recv = nullptr;-  grpc_byte_buffer* response_payload_recv = nullptr;-  grpc_status_code status;-  grpc_call_error error;-  grpc_slice details;-  int was_cancelled = 2;-  char* peer;--  std::string service_config = absl::StrFormat(-      ""{\n""-      ""  \""methodConfig\"": [ {\n""-      ""    \""name\"": [\n""-      ""      { \""service\"": \""service\"", \""method\"": \""method\"" }\n""-      ""    ],\n""-      ""    \""retryPolicy\"": {\n""-      ""      \""maxAttempts\"": 3,\n""-      ""      \""initialBackoff\"": \""%ds\"",\n""-      ""      \""maxBackoff\"": \""120s\"",\n""-      ""      \""backoffMultiplier\"": 1.6,\n""-      ""      \""retryableStatusCodes\"": [ \""ABORTED\"" ]\n""-      ""    }\n""-      ""  } ]\n""-      ""}"",-      10 * grpc_test_slowdown_factor());--  grpc_arg args[] = {-      grpc_channel_arg_string_create(const_cast<char*>(GRPC_ARG_SERVICE_CONFIG),-                                     const_cast<char*>(service_config.c_str())),-  };-  grpc_channel_args client_args = {GPR_ARRAY_SIZE(args), args};-  std::string name = absl::StrCat(""retry_cancel_during_delay/"", mode.name);-  auto f = begin_test(config, name.c_str(), &client_args, nullptr);--  grpc_core::CqVerifier cqv(f->cq());--  gpr_timespec expect_finish_before = grpc_timeout_seconds_to_deadline(10);-  gpr_timespec deadline = grpc_timeout_seconds_to_deadline(5);-  c = grpc_channel_create_call(f->client(), nullptr, GRPC_PROPAGATE_DEFAULTS,-                               f->cq(),-                               grpc_slice_from_static_string(""/service/method""),-                               nullptr, deadline, nullptr);-  GPR_ASSERT(c);--  peer = grpc_call_get_peer(c);-  GPR_ASSERT(peer != nullptr);-  gpr_log(GPR_DEBUG, ""client_peer_before_call=%s"", peer);-  gpr_free(peer);--  grpc_metadata_array_init(&initial_metadata_recv);-  grpc_metadata_array_init(&trailing_metadata_recv);-  grpc_metadata_array_init(&request_metadata_recv);-  grpc_call_details_init(&call_details);-  grpc_slice status_details = grpc_slice_from_static_string(""xyz"");-+namespace grpc_core {+namespace {++void TestRetryCancelDuringDelay(+    CoreEnd2endTest& test,+    std::unique_ptr<CancellationMode> cancellation_mode) {","I guess we could yes - unique_ptr elides some risks of accidentally copying/tearing the object, and my brain is a little wired to think of needing a pointer when I'm doing inheritance stuff (though I know this to be false).",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/32603,1153958801,2023-03-31T02:44:55Z,test/core/end2end/tests/retry_send_initial_metadata_refs.cc,"@@ -16,303 +16,110 @@ // // -#include <string.h>--#include <functional>-#include <memory> #include <string> -#include <grpc/byte_buffer.h>+#include ""absl/strings/string_view.h""+#include ""absl/types/optional.h""+#include ""gtest/gtest.h""+ #include <grpc/grpc.h>-#include <grpc/impl/propagation_bits.h> #include <grpc/slice.h> #include <grpc/status.h>-#include <grpc/support/alloc.h>-#include <grpc/support/log.h>-#include <grpc/support/time.h>  #include ""src/core/lib/channel/channel_args.h""-#include ""src/core/lib/gpr/useful.h""-#include ""test/core/end2end/cq_verifier.h""+#include ""src/core/lib/gprpp/time.h"" #include ""test/core/end2end/end2end_tests.h""-#include ""test/core/util/test_config.h"" -static std::unique_ptr<CoreTestFixture> begin_test(-    const CoreTestConfiguration& config, const char* test_name,-    grpc_channel_args* client_args, grpc_channel_args* server_args) {-  gpr_log(GPR_INFO, ""Running test: %s/%s"", test_name, config.name);-  auto f = config.create_fixture(grpc_core::ChannelArgs::FromC(client_args),-                                 grpc_core::ChannelArgs::FromC(server_args));-  f->InitServer(grpc_core::ChannelArgs::FromC(server_args));-  f->InitClient(grpc_core::ChannelArgs::FromC(client_args));-  return f;-}+namespace grpc_core {+namespace {  // Tests that we hold refs to send_initial_metadata payload while // cached, even after the caller has released its refs: // - 2 retries allowed for ABORTED status // - first attempt returns ABORTED // - second attempt returns OK-static void test_retry_send_initial_metadata_refs(-    const CoreTestConfiguration& config) {-  grpc_call* c;-  grpc_call* s;-  grpc_op ops[6];-  grpc_op* op;-  grpc_metadata_array client_send_initial_metadata;-  grpc_metadata_array initial_metadata_recv;-  grpc_metadata_array trailing_metadata_recv;-  grpc_metadata_array request_metadata_recv;-  grpc_call_details call_details;-  grpc_slice request_payload_slice = grpc_slice_from_static_string(""foo"");-  grpc_slice response_payload_slice = grpc_slice_from_static_string(""bar"");-  grpc_byte_buffer* request_payload =-      grpc_raw_byte_buffer_create(&request_payload_slice, 1);-  grpc_byte_buffer* response_payload =-      grpc_raw_byte_buffer_create(&response_payload_slice, 1);-  grpc_byte_buffer* request_payload_recv = nullptr;-  grpc_byte_buffer* response_payload_recv = nullptr;-  grpc_status_code status;-  grpc_call_error error;-  grpc_slice details;-  int was_cancelled = 2;-  char* peer;--  grpc_arg args[] = {-      grpc_channel_arg_string_create(-          const_cast<char*>(GRPC_ARG_SERVICE_CONFIG),-          const_cast<char*>(-              ""{\n""-              ""  \""methodConfig\"": [ {\n""-              ""    \""name\"": [\n""-              ""      { \""service\"": \""service\"", \""method\"": \""method\"" }\n""-              ""    ],\n""-              ""    \""retryPolicy\"": {\n""-              ""      \""maxAttempts\"": 3,\n""-              ""      \""initialBackoff\"": \""1s\"",\n""-              ""      \""maxBackoff\"": \""120s\"",\n""-              ""      \""backoffMultiplier\"": 1.6,\n""-              ""      \""retryableStatusCodes\"": [ \""ABORTED\"" ]\n""-              ""    }\n""-              ""  } ]\n""-              ""}"")),-  };-  grpc_channel_args client_args = {GPR_ARRAY_SIZE(args), args};-  auto f = begin_test(config, ""retry_send_initial_metadata_refs"", &client_args,-                      nullptr);--  grpc_core::CqVerifier cqv(f->cq());--  gpr_timespec deadline = grpc_timeout_seconds_to_deadline(5);-  c = grpc_channel_create_call(f->client(), nullptr, GRPC_PROPAGATE_DEFAULTS,-                               f->cq(),-                               grpc_slice_from_static_string(""/service/method""),-                               nullptr, deadline, nullptr);-  GPR_ASSERT(c);--  peer = grpc_call_get_peer(c);-  GPR_ASSERT(peer != nullptr);-  gpr_log(GPR_DEBUG, ""client_peer_before_call=%s"", peer);-  gpr_free(peer);--  grpc_metadata_array_init(&client_send_initial_metadata);-  client_send_initial_metadata.count = 2;-  client_send_initial_metadata.metadata = static_cast<grpc_metadata*>(-      gpr_malloc(client_send_initial_metadata.count * sizeof(grpc_metadata)));-  // First element is short enough for slices to be inlined.-  client_send_initial_metadata.metadata[0].key =-      grpc_slice_from_copied_string(std::string(""foo"").c_str());-  client_send_initial_metadata.metadata[0].value =-      grpc_slice_from_copied_string(std::string(""bar"").c_str());-  // Second element requires slice allocation.-  client_send_initial_metadata.metadata[1].key = grpc_slice_from_copied_string(-      std::string(GRPC_SLICE_INLINED_SIZE + 1, 'x').c_str());-  client_send_initial_metadata.metadata[1].value =-      grpc_slice_from_copied_string(-          std::string(GRPC_SLICE_INLINED_SIZE + 1, 'y').c_str());--  grpc_metadata_array_init(&initial_metadata_recv);-  grpc_metadata_array_init(&trailing_metadata_recv);-  grpc_metadata_array_init(&request_metadata_recv);-  grpc_call_details_init(&call_details);-  grpc_slice status_details = grpc_slice_from_static_string(""xyz"");--  memset(ops, 0, sizeof(ops));-  op = ops;-  op->op = GRPC_OP_SEND_INITIAL_METADATA;-  op->data.send_initial_metadata.count = client_send_initial_metadata.count;-  op->data.send_initial_metadata.metadata =-      client_send_initial_metadata.metadata;-  op++;-  op->op = GRPC_OP_SEND_MESSAGE;-  op->data.send_message.send_message = request_payload;-  op++;-  op->op = GRPC_OP_SEND_CLOSE_FROM_CLIENT;-  op++;-  error = grpc_call_start_batch(c, ops, static_cast<size_t>(op - ops),-                                grpc_core::CqVerifier::tag(1), nullptr);-  GPR_ASSERT(GRPC_CALL_OK == error);-  cqv.Expect(grpc_core::CqVerifier::tag(1), true);-  cqv.Verify();--  for (size_t i = 0; i < client_send_initial_metadata.count; ++i) {-    grpc_slice_unref(client_send_initial_metadata.metadata[i].key);-    grpc_slice_unref(client_send_initial_metadata.metadata[i].value);-  }-  grpc_metadata_array_destroy(&client_send_initial_metadata);--  memset(ops, 0, sizeof(ops));-  op = ops;-  op->op = GRPC_OP_RECV_MESSAGE;-  op->data.recv_message.recv_message = &response_payload_recv;-  op++;-  op->op = GRPC_OP_RECV_INITIAL_METADATA;-  op->data.recv_initial_metadata.recv_initial_metadata = &initial_metadata_recv;-  op++;-  op->op = GRPC_OP_RECV_STATUS_ON_CLIENT;-  op->data.recv_status_on_client.trailing_metadata = &trailing_metadata_recv;-  op->data.recv_status_on_client.status = &status;-  op->data.recv_status_on_client.status_details = &details;-  op++;-  error = grpc_call_start_batch(c, ops, static_cast<size_t>(op - ops),-                                grpc_core::CqVerifier::tag(2), nullptr);-  GPR_ASSERT(GRPC_CALL_OK == error);--  error = grpc_server_request_call(f->server(), &s, &call_details,-                                   &request_metadata_recv, f->cq(), f->cq(),-                                   grpc_core::CqVerifier::tag(101));-  GPR_ASSERT(GRPC_CALL_OK == error);-  cqv.Expect(grpc_core::CqVerifier::tag(101), true);-  cqv.Verify();-+TEST_P(RetryTest, RetrySendInitialMetadataRefs) {+  InitServer(ChannelArgs());+  InitClient(ChannelArgs().Set(+      GRPC_ARG_SERVICE_CONFIG,+      ""{\n""+      ""  \""methodConfig\"": [ {\n""+      ""    \""name\"": [\n""+      ""      { \""service\"": \""service\"", \""method\"": \""method\"" }\n""+      ""    ],\n""+      ""    \""retryPolicy\"": {\n""+      ""      \""maxAttempts\"": 3,\n""+      ""      \""initialBackoff\"": \""1s\"",\n""+      ""      \""maxBackoff\"": \""120s\"",\n""+      ""      \""backoffMultiplier\"": 1.6,\n""+      ""      \""retryableStatusCodes\"": [ \""ABORTED\"" ]\n""+      ""    }\n""+      ""  } ]\n""+      ""}""));+  auto c =+      NewClientCall(""/service/method"").Timeout(Duration::Seconds(5)).Create();+  EXPECT_NE(c.GetPeer(), absl::nullopt);+  c.NewBatch(1)+      .SendInitialMetadata(+          {// First element is short enough for slices to be inlined.+           {""foo"", ""bar""},+           // Second element requires slice allocation.+           {std::string(GRPC_SLICE_INLINED_SIZE + 1, 'x'),+            std::string(GRPC_SLICE_INLINED_SIZE + 1, 'y')}})+      .SendMessage(""foo"")+      .SendCloseFromClient();+  Expect(1, true);+  Step();+  IncomingMessage server_message;+  IncomingMetadata server_initial_metadata;+  IncomingStatusOnClient server_status;+  c.NewBatch(2)+      .RecvMessage(server_message)+      .RecvInitialMetadata(server_initial_metadata)+      .RecvStatusOnClient(server_status);+  auto s = RequestCall(101);+  Expect(101, true);+  Step();   // Make sure the ""grpc-previous-rpc-attempts"" header was not sent in the   // initial attempt.-  for (size_t i = 0; i < request_metadata_recv.count; ++i) {-    GPR_ASSERT(!grpc_slice_eq(-        request_metadata_recv.metadata[i].key,-        grpc_slice_from_static_string(""grpc-previous-rpc-attempts"")));-  }--  peer = grpc_call_get_peer(s);-  GPR_ASSERT(peer != nullptr);-  gpr_log(GPR_DEBUG, ""server_peer=%s"", peer);-  gpr_free(peer);-  peer = grpc_call_get_peer(c);-  GPR_ASSERT(peer != nullptr);-  gpr_log(GPR_DEBUG, ""client_peer=%s"", peer);-  gpr_free(peer);--  memset(ops, 0, sizeof(ops));-  op = ops;-  op->op = GRPC_OP_SEND_INITIAL_METADATA;-  op->data.send_initial_metadata.count = 0;-  op++;-  op->op = GRPC_OP_SEND_STATUS_FROM_SERVER;-  op->data.send_status_from_server.trailing_metadata_count = 0;-  op->data.send_status_from_server.status = GRPC_STATUS_ABORTED;-  op->data.send_status_from_server.status_details = &status_details;-  op++;-  op->op = GRPC_OP_RECV_CLOSE_ON_SERVER;-  op->data.recv_close_on_server.cancelled = &was_cancelled;-  op++;-  error = grpc_call_start_batch(s, ops, static_cast<size_t>(op - ops),-                                grpc_core::CqVerifier::tag(102), nullptr);-  GPR_ASSERT(GRPC_CALL_OK == error);--  cqv.Expect(grpc_core::CqVerifier::tag(102), true);-  cqv.Verify();--  grpc_call_unref(s);-  grpc_metadata_array_destroy(&request_metadata_recv);-  grpc_metadata_array_init(&request_metadata_recv);-  grpc_call_details_destroy(&call_details);-  grpc_call_details_init(&call_details);--  error = grpc_server_request_call(f->server(), &s, &call_details,-                                   &request_metadata_recv, f->cq(), f->cq(),-                                   grpc_core::CqVerifier::tag(201));-  GPR_ASSERT(GRPC_CALL_OK == error);-  cqv.Expect(grpc_core::CqVerifier::tag(201), true);-  cqv.Verify();-+  EXPECT_EQ(s.GetInitialMetadata(""grpc-previous-rpc-attempts""), absl::nullopt);+  EXPECT_NE(s.GetPeer(), absl::nullopt);+  EXPECT_NE(c.GetPeer(), absl::nullopt);+  IncomingCloseOnServer client_close;+  s.NewBatch(102)+      .SendInitialMetadata({})+      .SendStatusFromServer(GRPC_STATUS_ABORTED, ""xyz"", {})+      .RecvCloseOnServer(client_close);+  Expect(102, true);+  Step();+  auto s2 = RequestCall(201);+  Expect(201, true);+  Step();   // Make sure the ""grpc-previous-rpc-attempts"" header was sent in the retry.-  GPR_ASSERT(contains_metadata_slices(-      &request_metadata_recv,-      grpc_slice_from_static_string(""grpc-previous-rpc-attempts""),-      grpc_slice_from_static_string(""1"")));+  EXPECT_EQ(s2.GetInitialMetadata(""grpc-previous-rpc-attempts""), ""1"");   // It should also contain the initial metadata, even though the client   // freed it already.","The metadata slices? Yeah they're freed...`BatchBuilder::SendInitialMetadata()` takes `std::initializer_list<std::pair<absl::string_view, absl::string_view>>` which it converts into a bunch of `grpc_core::Slice` objects that it adds to a `grpc_metadata_array`... and then proceeds to delete them upon `BatchBuilder` destruction - and that same destruction is what triggers `grpc_call_start_batch`.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32603,1154579296,2023-03-31T14:54:15Z,test/core/end2end/tests/retry_transparent_max_concurrent_streams.cc,"@@ -107,10 +107,12 @@ TEST_P(RetryHttp2Test, RetryTransparentMaxConcurrentStreams) {   // we don't do that for transparent retries.   EXPECT_EQ(s2.GetInitialMetadata(""grpc-previous-rpc-attempts""), absl::nullopt);   // Server handles the second call.-  CoreEnd2endTest::IncomingMessage client_message2;+  IncomingMessage client_message2;+  IncomingCloseOnServer client_close2;   s2.NewBatch(202).RecvMessage(client_message2);   s2.NewBatch(203)       .SendInitialMetadata({})+      .RecvCloseOnServer(client_close2)",This should be before the SendInitialMetadata op instead of after.,
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32761,1154600369,2023-03-31T15:13:42Z,src/core/lib/gprpp/validation_errors.cc,"@@ -42,8 +43,13 @@ bool ValidationErrors::FieldHasErrors() const {   return field_errors_.find(absl::StrJoin(fields_, """")) != field_errors_.end(); } -absl::Status ValidationErrors::status(absl::string_view prefix) const {+absl::Status ValidationErrors::status(absl::string_view prefix,","I agree, it would probably make sense to make this a mandatory parameter and put it first.  It shouldn't be hard to update the callers.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32632,1154630501,2023-03-31T15:41:33Z,src/core/ext/filters/client_channel/resolver/dns/event_engine/event_engine_client_channel_resolver.cc,"@@ -0,0 +1,535 @@+// Copyright 2023 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+#include <grpc/support/port_platform.h>++#include ""src/core/ext/filters/client_channel/resolver/dns/event_engine/event_engine_client_channel_resolver.h""++#include <stddef.h>+#include <stdint.h>++#include <algorithm>+#include <chrono>+#include <initializer_list>+#include <memory>+#include <string>+#include <utility>+#include <vector>++#include ""absl/base/thread_annotations.h""+#include ""absl/container/flat_hash_set.h""+#include ""absl/functional/bind_front.h""+#include ""absl/status/status.h""+#include ""absl/status/statusor.h""+#include ""absl/strings/str_cat.h""+#include ""absl/strings/str_format.h""+#include ""absl/strings/strip.h""+#include ""absl/types/optional.h""++#include <grpc/event_engine/event_engine.h>+#include <grpc/grpc.h>+#include <grpc/support/log.h>++#include ""src/core/ext/filters/client_channel/lb_policy/grpclb/grpclb_balancer_addresses.h""+#include ""src/core/ext/filters/client_channel/resolver/dns/event_engine/service_config_helper.h""+#include ""src/core/ext/filters/client_channel/resolver/polling_resolver.h""+#include ""src/core/lib/backoff/backoff.h""+#include ""src/core/lib/channel/channel_args.h""+#include ""src/core/lib/debug/trace.h""+#include ""src/core/lib/event_engine/handle_containers.h""+#include ""src/core/lib/event_engine/resolved_address_internal.h""+#include ""src/core/lib/event_engine/trace.h""+#include ""src/core/lib/event_engine/utils.h""+#include ""src/core/lib/gprpp/debug_location.h""+#include ""src/core/lib/gprpp/ref_counted_ptr.h""+#include ""src/core/lib/gprpp/status_helper.h""+#include ""src/core/lib/gprpp/sync.h""+#include ""src/core/lib/gprpp/time.h""+#include ""src/core/lib/iomgr/resolve_address.h""+#include ""src/core/lib/resolver/resolver.h""+#include ""src/core/lib/resolver/resolver_factory.h""+#include ""src/core/lib/resolver/server_address.h""+#include ""src/core/lib/service_config/service_config.h""+#include ""src/core/lib/service_config/service_config_impl.h""++// IWYU pragma: no_include <ratio>++namespace grpc_event_engine {+namespace experimental {++namespace {++#define GRPC_DNS_INITIAL_CONNECT_BACKOFF_SECONDS 1+#define GRPC_DNS_RECONNECT_BACKOFF_MULTIPLIER 1.6+#define GRPC_DNS_RECONNECT_MAX_BACKOFF_SECONDS 120+#define GRPC_DNS_RECONNECT_JITTER 0.2+#define GRPC_DNS_DEFAULT_QUERY_TIMEOUT_MS 120000++using grpc_core::BackOff;+using grpc_core::Duration;+using grpc_core::InternallyRefCounted;+using grpc_core::MakeOrphanable;+using grpc_core::Mutex;+using grpc_core::MutexLock;+using grpc_core::Orphanable;+using grpc_core::OrphanablePtr;+using grpc_core::RefCountedPtr;+using grpc_core::ResolverArgs;++// ----------------------------------------------------------------------------+// EventEngineDNSRequestWrapper declaration+// ----------------------------------------------------------------------------+class EventEngineClientChannelDNSResolver;++class EventEngineDNSRequestWrapper+    : public InternallyRefCounted<EventEngineDNSRequestWrapper> {+ public:+  EventEngineDNSRequestWrapper(+      RefCountedPtr<EventEngineClientChannelDNSResolver> resolver,+      std::unique_ptr<EventEngine::DNSResolver> event_engine_resolver);+  ~EventEngineDNSRequestWrapper() override;++  // Note that thread safety cannot be analyzed due to this being invoked from+  // OrphanablePtr<>, and there's no way to pass the lock annotation through+  // there.+  void Orphan() override ABSL_NO_THREAD_SAFETY_ANALYSIS;++  void OnHostnameResolved(+      absl::StatusOr<std::vector<EventEngine::ResolvedAddress>> addresses);+  void OnSRVResolved(+      std::string srv_host,+      absl::StatusOr<std::vector<EventEngine::DNSResolver::SRVRecord>>+          srv_records);+  void OnBalancerHostnamesResolved(+      std::string authority,+      absl::StatusOr<std::vector<EventEngine::ResolvedAddress>> addresses);+  void OnTXTResolved(absl::StatusOr<std::string> service_config);++  // Returns a Result if resolution is complete.+  // callers must release the lock and call OnRequestComplete if a Result is+  // returned. This is because OnRequestComplete may Orphan the resolver, which+  // requires taking the lock.+  absl::optional<grpc_core::Resolver::Result> OnResolvedLocked()+      ABSL_EXCLUSIVE_LOCKS_REQUIRED(on_resolved_mu_);++ private:+  // Helper method for generating the combined resolution status error+  absl::Status GetResolutionFailureErrorMessageLocked()+      ABSL_EXCLUSIVE_LOCKS_REQUIRED(on_resolved_mu_);+  // Helper method to populate server addresses on resolver result.+  void MaybePopulateAddressesLocked(grpc_core::Resolver::Result& result)+      ABSL_EXCLUSIVE_LOCKS_REQUIRED(on_resolved_mu_);+  // Helper method to populate balancer addresses on resolver result.+  void MaybePopulateBalancerAddressesLocked(grpc_core::Resolver::Result& result)+      ABSL_EXCLUSIVE_LOCKS_REQUIRED(on_resolved_mu_);+  // Helper method to populate service config on resolver result.+  void MaybePopulateServiceConfigLocked(grpc_core::Resolver::Result& result)+      ABSL_EXCLUSIVE_LOCKS_REQUIRED(on_resolved_mu_);+  // Convert empty results into resolution errors.+  //+  // TODO(roth): We should someday separate empty results (NXDOMAIN) from actual+  // DNS resolution errors. For now, they are treated the same so this resolver+  // behaves similarly to the old c-ares resolver.+  void NormalizeEmptyResultsToErrorsLocked()+      ABSL_EXCLUSIVE_LOCKS_REQUIRED(on_resolved_mu_);++  RefCountedPtr<EventEngineClientChannelDNSResolver> resolver_;+  Mutex on_resolved_mu_;+  // Lookup callbacks+  absl::optional<EventEngine::DNSResolver::LookupTaskHandle> hostname_handle_+      ABSL_GUARDED_BY(on_resolved_mu_);+  absl::optional<EventEngine::DNSResolver::LookupTaskHandle> srv_handle_+      ABSL_GUARDED_BY(on_resolved_mu_);+  absl::optional<EventEngine::DNSResolver::LookupTaskHandle> txt_handle_+      ABSL_GUARDED_BY(on_resolved_mu_);+  LookupTaskHandleSet balancer_hostname_handles_+      ABSL_GUARDED_BY(on_resolved_mu_);+  // Output fields from requests.+  absl::StatusOr<std::vector<EventEngine::ResolvedAddress>> addresses_+      ABSL_GUARDED_BY(on_resolved_mu_);+  absl::StatusOr<grpc_core::ServerAddressList> balancer_addresses_+      ABSL_GUARDED_BY(on_resolved_mu_);+  absl::StatusOr<std::string> service_config_json_+      ABSL_GUARDED_BY(on_resolved_mu_);+  // Other internal state+  size_t number_of_balancer_hostnames_resolved_+      ABSL_GUARDED_BY(on_resolved_mu_) = 0;+  bool orphaned_ ABSL_GUARDED_BY(on_resolved_mu_) = false;+  std::unique_ptr<EventEngine::DNSResolver> event_engine_resolver_;+};++// ----------------------------------------------------------------------------+// EventEngineClientChannelDNSResolver+// ----------------------------------------------------------------------------+class EventEngineClientChannelDNSResolver : public grpc_core::PollingResolver {+ public:+  EventEngineClientChannelDNSResolver(ResolverArgs args,+                                      Duration min_time_between_resolutions);+  OrphanablePtr<Orphanable> StartRequest() override;++ private:+  friend class EventEngineDNSRequestWrapper;++  /// whether to request the service config+  const bool request_service_config_;+  // whether or not to enable SRV DNS queries+  const bool enable_srv_queries_;+  // timeout in milliseconds for active DNS queries+  EventEngine::Duration query_timeout_ms_;+  std::shared_ptr<EventEngine> event_engine_;+};++EventEngineClientChannelDNSResolver::EventEngineClientChannelDNSResolver(+    ResolverArgs args, Duration min_time_between_resolutions)+    : PollingResolver(std::move(args), min_time_between_resolutions,+                      BackOff::Options()+                          .set_initial_backoff(Duration::Milliseconds(+                              GRPC_DNS_INITIAL_CONNECT_BACKOFF_SECONDS * 1000))+                          .set_multiplier(GRPC_DNS_RECONNECT_BACKOFF_MULTIPLIER)+                          .set_jitter(GRPC_DNS_RECONNECT_JITTER)+                          .set_max_backoff(Duration::Milliseconds(+                              GRPC_DNS_RECONNECT_MAX_BACKOFF_SECONDS * 1000)),+                      &grpc_event_engine_dns_trace),+      request_service_config_(+          !channel_args()+               .GetBool(GRPC_ARG_SERVICE_CONFIG_DISABLE_RESOLUTION)+               .value_or(true)),+      enable_srv_queries_(channel_args()+                              .GetBool(GRPC_ARG_DNS_ENABLE_SRV_QUERIES)+                              .value_or(false)),+      // TODO(yijiem): decide if the ares channel arg timeout should be reused.+      query_timeout_ms_(std::chrono::milliseconds(+          std::max(0, channel_args()+                          .GetInt(GRPC_ARG_DNS_ARES_QUERY_TIMEOUT_MS)+                          .value_or(GRPC_DNS_DEFAULT_QUERY_TIMEOUT_MS)))),+      event_engine_(channel_args().GetObjectRef<EventEngine>()) {}++OrphanablePtr<Orphanable> EventEngineClientChannelDNSResolver::StartRequest() {+  return MakeOrphanable<EventEngineDNSRequestWrapper>(+      Ref(DEBUG_LOCATION, ""dns-resolving""),+      event_engine_->GetDNSResolver({/*dns_server=*/authority()}));+}++// ----------------------------------------------------------------------------+// EventEngineDNSRequestWrapper definition+// ----------------------------------------------------------------------------++EventEngineDNSRequestWrapper::EventEngineDNSRequestWrapper(+    RefCountedPtr<EventEngineClientChannelDNSResolver> resolver,+    std::unique_ptr<EventEngine::DNSResolver> event_engine_resolver)+    : resolver_(std::move(resolver)),+      event_engine_resolver_(std::move(event_engine_resolver)) {+  // Locking to prevent completion before all records are queried+  MutexLock lock(&on_resolved_mu_);+  hostname_handle_ = event_engine_resolver_->LookupHostname(+      absl::bind_front(&EventEngineDNSRequestWrapper::OnHostnameResolved,+                       Ref(DEBUG_LOCATION, ""OnHostnameResolved"")),+      resolver_->name_to_resolve(), grpc_core::kDefaultSecurePort,+      resolver_->query_timeout_ms_);+  GRPC_EVENT_ENGINE_DNS_TRACE(+      ""DNSResolver::%p Started resolving hostname. Handle::%s"", resolver_.get(),+      HandleToString(*hostname_handle_).c_str());+  if (resolver_->enable_srv_queries_) {+    srv_handle_ = event_engine_resolver_->LookupSRV(+        absl::bind_front(&EventEngineDNSRequestWrapper::OnSRVResolved,+                         Ref(DEBUG_LOCATION, ""OnSRVResolved""),+                         resolver_->name_to_resolve()),+        resolver_->name_to_resolve(), resolver_->query_timeout_ms_);+    GRPC_EVENT_ENGINE_DNS_TRACE(+        ""DNSResolver::%p Started resolving SRV. Handle::%s"", resolver_.get(),+        HandleToString(*srv_handle_).c_str());+  }+  if (resolver_->request_service_config_) {+    txt_handle_ = event_engine_resolver_->LookupTXT(+        absl::bind_front(&EventEngineDNSRequestWrapper::OnTXTResolved,+                         Ref(DEBUG_LOCATION, ""OnTXTResolved"")),+        resolver_->name_to_resolve(), resolver_->query_timeout_ms_);+    GRPC_EVENT_ENGINE_DNS_TRACE(+        ""DNSResolver::%p Started resolving TXT. Handle::%s"", resolver_.get(),+        HandleToString(*txt_handle_).c_str());+  }+}++EventEngineDNSRequestWrapper::~EventEngineDNSRequestWrapper() {+  resolver_.reset(DEBUG_LOCATION, ""dns-resolving"");+}++void EventEngineDNSRequestWrapper::Orphan() {+  {+    MutexLock lock(&on_resolved_mu_);+    orphaned_ = true;+    // Event if cancellation fails here, OnResolvedLocked will return early, and+    // the resolver will never see a completed request.+    if (hostname_handle_.has_value()) {+      event_engine_resolver_->CancelLookup(*hostname_handle_);+    }+    if (srv_handle_.has_value()) {+      event_engine_resolver_->CancelLookup(*srv_handle_);+    }+    for (const auto& handle : balancer_hostname_handles_) {+      event_engine_resolver_->CancelLookup(handle);+    }+    if (txt_handle_.has_value()) {+      event_engine_resolver_->CancelLookup(*txt_handle_);+    }+  }+  Unref(DEBUG_LOCATION, ""Orphan"");+}++void EventEngineDNSRequestWrapper::OnHostnameResolved(+    absl::StatusOr<std::vector<EventEngine::ResolvedAddress>> addresses) {+  absl::optional<grpc_core::Resolver::Result> result;+  {+    MutexLock lock(&on_resolved_mu_);+    if (orphaned_) return;+    hostname_handle_.reset();+    addresses_ = addresses;+    result = OnResolvedLocked();+  }+  if (result.has_value()) {+    resolver_->OnRequestComplete(std::move(*result));+  }+}++void EventEngineDNSRequestWrapper::OnSRVResolved(+    std::string srv_host,+    absl::StatusOr<std::vector<EventEngine::DNSResolver::SRVRecord>>+        srv_records) {+  absl::optional<grpc_core::Resolver::Result> result;+  {+    MutexLock lock(&on_resolved_mu_);+    if (orphaned_) return;+    srv_handle_.reset();+    if (srv_records.ok()) {+      balancer_addresses_ = grpc_core::ServerAddressList();+      // Do a subsequent hostname query if SRV records were returned+      for (const auto& srv_record : *srv_records) {+        balancer_hostname_handles_.insert(+            event_engine_resolver_->LookupHostname(+                absl::bind_front(+                    &EventEngineDNSRequestWrapper::OnBalancerHostnamesResolved,+                    Ref(DEBUG_LOCATION, ""OnBalancerHostnamesResolved""),+                    srv_host),","That fuzzer looks like a great start!  But to address this particular problem, I think it would need to actually validate somehow that the result returned by the resolver matches the data returned by the fuzzing EE impl.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32757,1154673125,2023-03-31T16:22:45Z,test/cpp/interop/rpc_behavior_lb_policy.cc,"@@ -0,0 +1,196 @@+//+//+// Copyright 2023 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+//+//++#include <grpc/support/port_platform.h>++#include ""test/cpp/interop/rpc_behavior_lb_policy.h""++#include ""absl/strings/str_format.h""++#include ""src/core/lib/iomgr/pollset_set.h""+#include ""src/core/lib/json/json_args.h""+#include ""src/core/lib/json/json_object_loader.h""++namespace grpc {+namespace testing {++namespace {++using grpc_core::CoreConfiguration;+using grpc_core::Json;+using grpc_core::JsonArgs;+using grpc_core::JsonLoaderInterface;+using grpc_core::LoadBalancingPolicy;+using grpc_core::OrphanablePtr;+using grpc_core::RefCountedPtr;++constexpr absl::string_view kRpcBehaviorLbPolicyName =+    ""test.RpcBehaviorLoadBalancer"";++constexpr absl::string_view kRpcBehaviorMetadataKey = ""rpc-behavior"";++class RpcBehaviorLbPolicyConfig : public LoadBalancingPolicy::Config {+ public:+  static JsonLoaderInterface* JsonLoader(const JsonArgs&) {+    static const auto kJsonLoader =+        grpc_core::JsonObjectLoader<RpcBehaviorLbPolicyConfig>()+            .Field(""rpcBehavior"", &RpcBehaviorLbPolicyConfig::rpc_behavior_)+            .Finish();+    return kJsonLoader;+  }++  absl::string_view rpc_behavior() const { return rpc_behavior_; }++ private:+  absl::string_view name() const override { return kRpcBehaviorLbPolicyName; }++  std::string rpc_behavior_;+};++class RpcBehaviorLbPolicy : public LoadBalancingPolicy {+ public:+  explicit RpcBehaviorLbPolicy(Args args)+      : LoadBalancingPolicy(std::move(args), /*initial_refcount=*/2) {+    Args delegate_args;+    delegate_args.work_serializer = work_serializer();+    delegate_args.args = channel_args();+    delegate_args.channel_control_helper =+        std::make_unique<Helper>(RefCountedPtr<RpcBehaviorLbPolicy>(this));+    delegate_ =+        CoreConfiguration::Get().lb_policy_registry().CreateLoadBalancingPolicy(+            ""pick_first"", std::move(delegate_args));+    grpc_pollset_set_add_pollset_set(delegate_->interested_parties(),+                                     interested_parties());+  }++  ~RpcBehaviorLbPolicy() override = default;++  absl::string_view name() const override { return kRpcBehaviorLbPolicyName; }++  absl::Status UpdateLocked(UpdateArgs args) override {+    RefCountedPtr<RpcBehaviorLbPolicyConfig> config = std::move(args.config);+    rpc_behavior_ = std::string(config->rpc_behavior());+    return delegate_->UpdateLocked(std::move(args));+  }++  void ExitIdleLocked() override { delegate_->ExitIdleLocked(); }++  void ResetBackoffLocked() override { delegate_->ResetBackoffLocked(); }++ private:+  class Picker : public SubchannelPicker {+   public:+    Picker(RefCountedPtr<SubchannelPicker> delegate_picker,+           RefCountedPtr<RpcBehaviorLbPolicy> parent)+        : delegate_picker_(std::move(delegate_picker)), parent_(parent) {}++    PickResult Pick(PickArgs args) override {+      args.initial_metadata->Add(kRpcBehaviorMetadataKey,+                                 parent_->rpc_behavior_);","It's not safe to directly access `parent_->rpc_behavior_` from within the picker, because the parent policy may see an `UpdateLocked()` call in the `WorkSerializer` that changes `rpc_behavior_` while the picker is running outside of the `WorkSerializer`.  Instead, you'll need to pass a copy of `rpc_behavior_` to the picker when you instantiate it.Even once you've done that, there is no guarantee that the picker won't be destroyed after the pick is returned but before the initial metadata is sent on this call, so you can't just pass in a string_view that points to the `rpc_behavior_` data member of the picker.  Instead, you'll need to allocate a string copy on the call's arena, like this example from the RLS LB policy:https://github.com/grpc/grpc/blob/569d0076b35dd7187a7cb6241c56c9fb3a86b518/src/core/ext/filters/client_channel/lb_policy/rls/rls.cc#L1238",
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/32632,1154686857,2023-03-31T16:38:38Z,src/core/ext/filters/client_channel/resolver/dns/event_engine/event_engine_client_channel_resolver.cc,"@@ -0,0 +1,535 @@+// Copyright 2023 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+#include <grpc/support/port_platform.h>++#include ""src/core/ext/filters/client_channel/resolver/dns/event_engine/event_engine_client_channel_resolver.h""++#include <stddef.h>+#include <stdint.h>++#include <algorithm>+#include <chrono>+#include <initializer_list>+#include <memory>+#include <string>+#include <utility>+#include <vector>++#include ""absl/base/thread_annotations.h""+#include ""absl/container/flat_hash_set.h""+#include ""absl/functional/bind_front.h""+#include ""absl/status/status.h""+#include ""absl/status/statusor.h""+#include ""absl/strings/str_cat.h""+#include ""absl/strings/str_format.h""+#include ""absl/strings/strip.h""+#include ""absl/types/optional.h""++#include <grpc/event_engine/event_engine.h>+#include <grpc/grpc.h>+#include <grpc/support/log.h>++#include ""src/core/ext/filters/client_channel/lb_policy/grpclb/grpclb_balancer_addresses.h""+#include ""src/core/ext/filters/client_channel/resolver/dns/event_engine/service_config_helper.h""+#include ""src/core/ext/filters/client_channel/resolver/polling_resolver.h""+#include ""src/core/lib/backoff/backoff.h""+#include ""src/core/lib/channel/channel_args.h""+#include ""src/core/lib/debug/trace.h""+#include ""src/core/lib/event_engine/handle_containers.h""+#include ""src/core/lib/event_engine/resolved_address_internal.h""+#include ""src/core/lib/event_engine/trace.h""+#include ""src/core/lib/event_engine/utils.h""+#include ""src/core/lib/gprpp/debug_location.h""+#include ""src/core/lib/gprpp/ref_counted_ptr.h""+#include ""src/core/lib/gprpp/status_helper.h""+#include ""src/core/lib/gprpp/sync.h""+#include ""src/core/lib/gprpp/time.h""+#include ""src/core/lib/iomgr/resolve_address.h""+#include ""src/core/lib/resolver/resolver.h""+#include ""src/core/lib/resolver/resolver_factory.h""+#include ""src/core/lib/resolver/server_address.h""+#include ""src/core/lib/service_config/service_config.h""+#include ""src/core/lib/service_config/service_config_impl.h""++// IWYU pragma: no_include <ratio>++namespace grpc_event_engine {+namespace experimental {++namespace {++#define GRPC_DNS_INITIAL_CONNECT_BACKOFF_SECONDS 1+#define GRPC_DNS_RECONNECT_BACKOFF_MULTIPLIER 1.6+#define GRPC_DNS_RECONNECT_MAX_BACKOFF_SECONDS 120+#define GRPC_DNS_RECONNECT_JITTER 0.2+#define GRPC_DNS_DEFAULT_QUERY_TIMEOUT_MS 120000++using grpc_core::BackOff;+using grpc_core::Duration;+using grpc_core::InternallyRefCounted;+using grpc_core::MakeOrphanable;+using grpc_core::Mutex;+using grpc_core::MutexLock;+using grpc_core::Orphanable;+using grpc_core::OrphanablePtr;+using grpc_core::RefCountedPtr;+using grpc_core::ResolverArgs;++// ----------------------------------------------------------------------------+// EventEngineDNSRequestWrapper declaration+// ----------------------------------------------------------------------------+class EventEngineClientChannelDNSResolver;++class EventEngineDNSRequestWrapper+    : public InternallyRefCounted<EventEngineDNSRequestWrapper> {+ public:+  EventEngineDNSRequestWrapper(+      RefCountedPtr<EventEngineClientChannelDNSResolver> resolver,+      std::unique_ptr<EventEngine::DNSResolver> event_engine_resolver);+  ~EventEngineDNSRequestWrapper() override;++  // Note that thread safety cannot be analyzed due to this being invoked from+  // OrphanablePtr<>, and there's no way to pass the lock annotation through+  // there.+  void Orphan() override ABSL_NO_THREAD_SAFETY_ANALYSIS;++  void OnHostnameResolved(+      absl::StatusOr<std::vector<EventEngine::ResolvedAddress>> addresses);+  void OnSRVResolved(+      std::string srv_host,+      absl::StatusOr<std::vector<EventEngine::DNSResolver::SRVRecord>>+          srv_records);+  void OnBalancerHostnamesResolved(+      std::string authority,+      absl::StatusOr<std::vector<EventEngine::ResolvedAddress>> addresses);+  void OnTXTResolved(absl::StatusOr<std::string> service_config);++  // Returns a Result if resolution is complete.+  // callers must release the lock and call OnRequestComplete if a Result is+  // returned. This is because OnRequestComplete may Orphan the resolver, which+  // requires taking the lock.+  absl::optional<grpc_core::Resolver::Result> OnResolvedLocked()+      ABSL_EXCLUSIVE_LOCKS_REQUIRED(on_resolved_mu_);++ private:+  // Helper method for generating the combined resolution status error+  absl::Status GetResolutionFailureErrorMessageLocked()+      ABSL_EXCLUSIVE_LOCKS_REQUIRED(on_resolved_mu_);+  // Helper method to populate server addresses on resolver result.+  void MaybePopulateAddressesLocked(grpc_core::Resolver::Result& result)+      ABSL_EXCLUSIVE_LOCKS_REQUIRED(on_resolved_mu_);+  // Helper method to populate balancer addresses on resolver result.+  void MaybePopulateBalancerAddressesLocked(grpc_core::Resolver::Result& result)+      ABSL_EXCLUSIVE_LOCKS_REQUIRED(on_resolved_mu_);+  // Helper method to populate service config on resolver result.+  void MaybePopulateServiceConfigLocked(grpc_core::Resolver::Result& result)+      ABSL_EXCLUSIVE_LOCKS_REQUIRED(on_resolved_mu_);+  // Convert empty results into resolution errors.+  //+  // TODO(roth): We should someday separate empty results (NXDOMAIN) from actual+  // DNS resolution errors. For now, they are treated the same so this resolver+  // behaves similarly to the old c-ares resolver.+  void NormalizeEmptyResultsToErrorsLocked()+      ABSL_EXCLUSIVE_LOCKS_REQUIRED(on_resolved_mu_);++  RefCountedPtr<EventEngineClientChannelDNSResolver> resolver_;+  Mutex on_resolved_mu_;+  // Lookup callbacks+  absl::optional<EventEngine::DNSResolver::LookupTaskHandle> hostname_handle_+      ABSL_GUARDED_BY(on_resolved_mu_);+  absl::optional<EventEngine::DNSResolver::LookupTaskHandle> srv_handle_+      ABSL_GUARDED_BY(on_resolved_mu_);+  absl::optional<EventEngine::DNSResolver::LookupTaskHandle> txt_handle_+      ABSL_GUARDED_BY(on_resolved_mu_);+  LookupTaskHandleSet balancer_hostname_handles_+      ABSL_GUARDED_BY(on_resolved_mu_);+  // Output fields from requests.+  absl::StatusOr<std::vector<EventEngine::ResolvedAddress>> addresses_+      ABSL_GUARDED_BY(on_resolved_mu_);+  absl::StatusOr<grpc_core::ServerAddressList> balancer_addresses_+      ABSL_GUARDED_BY(on_resolved_mu_);+  absl::StatusOr<std::string> service_config_json_+      ABSL_GUARDED_BY(on_resolved_mu_);+  // Other internal state+  size_t number_of_balancer_hostnames_resolved_+      ABSL_GUARDED_BY(on_resolved_mu_) = 0;+  bool orphaned_ ABSL_GUARDED_BY(on_resolved_mu_) = false;+  std::unique_ptr<EventEngine::DNSResolver> event_engine_resolver_;+};++// ----------------------------------------------------------------------------+// EventEngineClientChannelDNSResolver+// ----------------------------------------------------------------------------+class EventEngineClientChannelDNSResolver : public grpc_core::PollingResolver {+ public:+  EventEngineClientChannelDNSResolver(ResolverArgs args,+                                      Duration min_time_between_resolutions);+  OrphanablePtr<Orphanable> StartRequest() override;++ private:+  friend class EventEngineDNSRequestWrapper;++  /// whether to request the service config+  const bool request_service_config_;+  // whether or not to enable SRV DNS queries+  const bool enable_srv_queries_;+  // timeout in milliseconds for active DNS queries+  EventEngine::Duration query_timeout_ms_;+  std::shared_ptr<EventEngine> event_engine_;+};++EventEngineClientChannelDNSResolver::EventEngineClientChannelDNSResolver(+    ResolverArgs args, Duration min_time_between_resolutions)+    : PollingResolver(std::move(args), min_time_between_resolutions,+                      BackOff::Options()+                          .set_initial_backoff(Duration::Milliseconds(+                              GRPC_DNS_INITIAL_CONNECT_BACKOFF_SECONDS * 1000))+                          .set_multiplier(GRPC_DNS_RECONNECT_BACKOFF_MULTIPLIER)+                          .set_jitter(GRPC_DNS_RECONNECT_JITTER)+                          .set_max_backoff(Duration::Milliseconds(+                              GRPC_DNS_RECONNECT_MAX_BACKOFF_SECONDS * 1000)),+                      &grpc_event_engine_dns_trace),+      request_service_config_(+          !channel_args()+               .GetBool(GRPC_ARG_SERVICE_CONFIG_DISABLE_RESOLUTION)+               .value_or(true)),+      enable_srv_queries_(channel_args()+                              .GetBool(GRPC_ARG_DNS_ENABLE_SRV_QUERIES)+                              .value_or(false)),+      // TODO(yijiem): decide if the ares channel arg timeout should be reused.+      query_timeout_ms_(std::chrono::milliseconds(+          std::max(0, channel_args()+                          .GetInt(GRPC_ARG_DNS_ARES_QUERY_TIMEOUT_MS)+                          .value_or(GRPC_DNS_DEFAULT_QUERY_TIMEOUT_MS)))),+      event_engine_(channel_args().GetObjectRef<EventEngine>()) {}++OrphanablePtr<Orphanable> EventEngineClientChannelDNSResolver::StartRequest() {+  return MakeOrphanable<EventEngineDNSRequestWrapper>(+      Ref(DEBUG_LOCATION, ""dns-resolving""),+      event_engine_->GetDNSResolver({/*dns_server=*/authority()}));+}++// ----------------------------------------------------------------------------+// EventEngineDNSRequestWrapper definition+// ----------------------------------------------------------------------------++EventEngineDNSRequestWrapper::EventEngineDNSRequestWrapper(+    RefCountedPtr<EventEngineClientChannelDNSResolver> resolver,+    std::unique_ptr<EventEngine::DNSResolver> event_engine_resolver)+    : resolver_(std::move(resolver)),+      event_engine_resolver_(std::move(event_engine_resolver)) {+  // Locking to prevent completion before all records are queried+  MutexLock lock(&on_resolved_mu_);+  hostname_handle_ = event_engine_resolver_->LookupHostname(+      absl::bind_front(&EventEngineDNSRequestWrapper::OnHostnameResolved,+                       Ref(DEBUG_LOCATION, ""OnHostnameResolved"")),+      resolver_->name_to_resolve(), grpc_core::kDefaultSecurePort,+      resolver_->query_timeout_ms_);+  GRPC_EVENT_ENGINE_DNS_TRACE(+      ""DNSResolver::%p Started resolving hostname. Handle::%s"", resolver_.get(),+      HandleToString(*hostname_handle_).c_str());+  if (resolver_->enable_srv_queries_) {+    srv_handle_ = event_engine_resolver_->LookupSRV(+        absl::bind_front(&EventEngineDNSRequestWrapper::OnSRVResolved,+                         Ref(DEBUG_LOCATION, ""OnSRVResolved""),+                         resolver_->name_to_resolve()),+        resolver_->name_to_resolve(), resolver_->query_timeout_ms_);+    GRPC_EVENT_ENGINE_DNS_TRACE(+        ""DNSResolver::%p Started resolving SRV. Handle::%s"", resolver_.get(),+        HandleToString(*srv_handle_).c_str());+  }+  if (resolver_->request_service_config_) {+    txt_handle_ = event_engine_resolver_->LookupTXT(+        absl::bind_front(&EventEngineDNSRequestWrapper::OnTXTResolved,+                         Ref(DEBUG_LOCATION, ""OnTXTResolved"")),+        resolver_->name_to_resolve(), resolver_->query_timeout_ms_);+    GRPC_EVENT_ENGINE_DNS_TRACE(+        ""DNSResolver::%p Started resolving TXT. Handle::%s"", resolver_.get(),+        HandleToString(*txt_handle_).c_str());+  }+}++EventEngineDNSRequestWrapper::~EventEngineDNSRequestWrapper() {+  resolver_.reset(DEBUG_LOCATION, ""dns-resolving"");+}++void EventEngineDNSRequestWrapper::Orphan() {+  {+    MutexLock lock(&on_resolved_mu_);+    orphaned_ = true;+    // Event if cancellation fails here, OnResolvedLocked will return early, and+    // the resolver will never see a completed request.+    if (hostname_handle_.has_value()) {+      event_engine_resolver_->CancelLookup(*hostname_handle_);+    }+    if (srv_handle_.has_value()) {+      event_engine_resolver_->CancelLookup(*srv_handle_);+    }+    for (const auto& handle : balancer_hostname_handles_) {+      event_engine_resolver_->CancelLookup(handle);+    }+    if (txt_handle_.has_value()) {+      event_engine_resolver_->CancelLookup(*txt_handle_);+    }+  }+  Unref(DEBUG_LOCATION, ""Orphan"");+}++void EventEngineDNSRequestWrapper::OnHostnameResolved(+    absl::StatusOr<std::vector<EventEngine::ResolvedAddress>> addresses) {+  absl::optional<grpc_core::Resolver::Result> result;+  {+    MutexLock lock(&on_resolved_mu_);+    if (orphaned_) return;+    hostname_handle_.reset();+    addresses_ = addresses;+    result = OnResolvedLocked();+  }+  if (result.has_value()) {+    resolver_->OnRequestComplete(std::move(*result));+  }+}++void EventEngineDNSRequestWrapper::OnSRVResolved(+    std::string srv_host,+    absl::StatusOr<std::vector<EventEngine::DNSResolver::SRVRecord>>+        srv_records) {+  absl::optional<grpc_core::Resolver::Result> result;+  {+    MutexLock lock(&on_resolved_mu_);+    if (orphaned_) return;+    srv_handle_.reset();+    if (srv_records.ok()) {+      balancer_addresses_ = grpc_core::ServerAddressList();+      // Do a subsequent hostname query if SRV records were returned+      for (const auto& srv_record : *srv_records) {+        balancer_hostname_handles_.insert(+            event_engine_resolver_->LookupHostname(+                absl::bind_front(+                    &EventEngineDNSRequestWrapper::OnBalancerHostnamesResolved,+                    Ref(DEBUG_LOCATION, ""OnBalancerHostnamesResolved""),+                    srv_host),","I was speaking of the second case, where SRV resolution results would be an error followed by good data, which we identified as a crashing bug. That's a bit harder to control in a fixed test with a real DNS resolver, but easy to fuzz. The first case, checking the authority for balancer addresses, would probably be better to test directly, but we could add a rudimentary check to the fuzzer.",
287917,eugeneo,https://api.github.com/repos/grpc/grpc/pulls/32757,1154714685,2023-03-31T17:11:58Z,tools/run_tests/xds_k8s_test_driver/tests/custom_lb_test.py,"@@ -40,6 +40,8 @@ class CustomLbTest(xds_k8s_testcase.RegularXdsKubernetesTestCase):     def is_supported(config: skips.TestConfig) -> bool:         if config.client_lang == _Lang.JAVA:             return config.version_gte('v1.47.x')+        if config.client_lang == _Lang.CPP:+            return config.version_gte('v1.54.x')",This is version of Docker images with XDS interop test client. I updated to 1.55 as I don't think we update older images with the new XDS interop test client.Environment variables are set here - [Kubernates config](https://github.com/grpc/grpc/blob/master/tools/run_tests/xds_k8s_test_driver/kubernetes-manifests/client.deployment.yaml#L51),
4181124,yashykt,https://api.github.com/repos/grpc/grpc/pulls/32765,1154802947,2023-03-31T19:03:03Z,test/cpp/interop/xds_interop_server.cc,"@@ -65,13 +66,59 @@ using grpc::testing::SimpleResponse; using grpc::testing::TestService; using grpc::testing::XdsUpdateHealthService; +namespace {+constexpr absl::string_view kRpcBehaviorMetadataKey = ""rpc-behavior"";+constexpr absl::string_view kErrorCodeRpcBehavior = ""error-code-"";++std::set<std::string> GetRpcBehaviorMetadata(ServerContext* context) {+  std::set<std::string> rpc_behaviors;+  auto rpc_behavior_metadata =+      context->client_metadata().equal_range(grpc::string_ref(+          kRpcBehaviorMetadataKey.data(), kRpcBehaviorMetadataKey.length()));+  for (auto metadata = rpc_behavior_metadata.first;+       metadata != rpc_behavior_metadata.second; metadata++) {",prefer ++metadata over metadata++,
2793282,veblush,https://api.github.com/repos/grpc/grpc/pulls/32715,1154885030,2023-03-31T20:52:00Z,include/grpcpp/ext/gcp_observability.h,"@@ -17,25 +17,76 @@ #ifndef GRPCPP_EXT_GCP_OBSERVABILITY_H #define GRPCPP_EXT_GCP_OBSERVABILITY_H +#include <grpc/support/port_platform.h>+ #include ""absl/status/status.h""+#include ""absl/status/statusor.h""  namespace grpc {-namespace experimental {++namespace grpc_gcp {",Craig suggestion might make sense. Either would work.Having a different namespace would be helpful because there is a clear boundary between vanilla gRPC and GCP specific extensions especially those extensions require an additional dependency. I hope that we can also put `GoogleDefaultCredentials` under gcp namespace but we may have to keep this for backward-compatibility issue. (or we can have both),
5663878,yijiem,https://api.github.com/repos/grpc/grpc/pulls/32701,1154892426,2023-03-31T21:02:54Z,src/core/lib/event_engine/posix_engine/posix_engine.h,"@@ -138,6 +139,9 @@ class PosixEventEngine final : public PosixEventEngineWithFdSupport,  public:   class PosixDNSResolver : public EventEngine::DNSResolver {    public:+    explicit PosixDNSResolver(ResolverOptions const& options,+                              PosixEnginePollerManager* poller_manager,+                              PosixEventEngine* event_engine);",I added the following check in the PosixDNSResolver's destructor:```PosixEventEngine::PosixDNSResolver::~PosixDNSResolver() {  grpc_core::MutexLock lock(&mu_);  GPR_ASSERT(GPR_LIKELY(inflight_requests_.empty()));}```And seems like we are cancelling each pending requests in `EventEngineClientChannelDNSResolver`'s `Orphan()`. I think most events in `ares_driver` are triggered by EventEngine's poller or timers and run in the EventEngine's thread pool. So I would bet that the resolver has already been destroyed (all events have happened) before the poller or timers' shutdown. But I will keep testing it since it's a tricky issue and I don't really clear about the shutdown ordering of various components here.,
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/32701,1155014215,2023-04-01T00:03:12Z,src/core/lib/event_engine/ares_driver.cc,"@@ -0,0 +1,1177 @@+// Copyright 2023 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++#include ""src/core/lib/event_engine/ares_driver.h""++#include <arpa/nameser.h>+#include <inttypes.h>+#include <netdb.h>+#include <string.h>++#include <algorithm>+#include <chrono>+#include <initializer_list>+#include <ratio>+#include <type_traits>+#include <utility>++#include <address_sorting/address_sorting.h>++#include ""absl/cleanup/cleanup.h""+#include ""absl/strings/numbers.h""+#include ""absl/strings/str_cat.h""+#include ""absl/strings/str_format.h""+#include ""absl/types/optional.h""++#include <grpc/event_engine/event_engine.h>+#include <grpc/support/alloc.h>+#include <grpc/support/log.h>++#include ""src/core/lib/address_utils/parse_address.h""+#include ""src/core/lib/address_utils/sockaddr_utils.h""+#include ""src/core/lib/event_engine/grpc_polled_fd.h""+#include ""src/core/lib/event_engine/nameser.h""  // IWYU pragma: keep+#include ""src/core/lib/event_engine/tcp_socket_utils.h""+#include ""src/core/lib/event_engine/time_util.h""+#include ""src/core/lib/gpr/string.h""+#include ""src/core/lib/gprpp/debug_location.h""+#include ""src/core/lib/gprpp/examine_stack.h""+#include ""src/core/lib/gprpp/host_port.h""+#include ""src/core/lib/gprpp/ref_counted_ptr.h""+#include ""src/core/lib/gprpp/status_helper.h""+#include ""src/core/lib/gprpp/sync.h""+#include ""src/core/lib/iomgr/error.h""+#include ""src/core/lib/iomgr/exec_ctx.h""+#include ""src/core/lib/iomgr/resolved_address.h""+#include ""src/core/lib/iomgr/sockaddr.h""+#ifdef _WIN32+#else+#include ""src/core/lib/event_engine/posix_engine/tcp_socket_utils.h""+#endif++namespace grpc_event_engine {+namespace experimental {++grpc_core::TraceFlag grpc_trace_ares_driver_address_sorting(+    false, ""ares_driver_address_sorting"");++grpc_core::TraceFlag grpc_trace_ares_driver_stacktrace(+    false, ""ares_driver_stacktrace"");++#define GRPC_ARES_DRIVER_STACK_TRACE()                                \+  do {                                                                \+    if (GRPC_TRACE_FLAG_ENABLED(grpc_trace_ares_driver_stacktrace)) { \+      absl::optional<std::string> stacktrace =                        \+          grpc_core::GetCurrentStackTrace();                          \+      if (stacktrace.has_value()) {                                   \+        gpr_log(GPR_DEBUG, ""%s"", stacktrace->c_str());                \+      } else {                                                        \+        gpr_log(GPR_DEBUG, ""stacktrace unavailable"");                 \+      }                                                               \+    }                                                                 \+  } while (0)++grpc_core::TraceFlag grpc_trace_ares_driver(false, ""ares_driver"");++namespace {++struct FdNode;+class FdNodeList;++class GrpcAresRequestImpl : public grpc_core::RefCounted<GrpcAresRequestImpl> {+ public:+  GrpcAresRequestImpl(absl::string_view name,+                      absl::optional<absl::string_view> default_port,+                      EventEngine::Duration timeout,+                      RegisterAresSocketWithPollerCallback register_cb,+                      EventEngine* event_engine);+  ~GrpcAresRequestImpl() override;++  absl::Status Initialize(absl::string_view dns_server, bool check_port)+      ABSL_LOCKS_EXCLUDED(mu_);+  bool Cancel() ABSL_LOCKS_EXCLUDED(mu_);+  absl::string_view host() const ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu_) {+    return host_;+  }+  int port() const ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu_) { return port_; }++ protected:+  void Work() ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu_);+  void StartTimers() ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu_);+  void CancelTimers() ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu_);++ private:+  friend class GrpcPolledFd;+  friend class GrpcPolledFdFactory;+  friend struct FdNode;+  friend class FdNodeList;++  absl::Status SetRequestDNSServer(absl::string_view dns_server)+      ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu_);+  void OnReadable(FdNode* fd_node, absl::Status status)+      ABSL_LOCKS_EXCLUDED(mu_);+  void OnWritable(FdNode* fd_node, absl::Status status)+      ABSL_LOCKS_EXCLUDED(mu_);+  void OnHandleDestroyed(FdNode* fd_node, absl::Status status)+      ABSL_LOCKS_EXCLUDED(mu_);+  void OnQueryTimeout() ABSL_LOCKS_EXCLUDED(mu_);+  void OnAresBackupPollAlarm() ABSL_LOCKS_EXCLUDED(mu_);+  void ShutdownPollerHandlesLocked(absl::Status status)+      ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu_);++ protected:+  grpc_core::Mutex mu_;+  bool initialized_ ABSL_GUARDED_BY(mu_) = false;+  /// name to resolve+  const std::string name_ ABSL_GUARDED_BY(mu_);+  const std::string default_port_ ABSL_GUARDED_BY(mu_);+  // ares channel+  ares_channel channel_ ABSL_GUARDED_BY(mu_) = nullptr;+  /// host to resolve; parsed from the name to resolve+  absl::string_view host_ ABSL_GUARDED_BY(mu_);+  /// port; parsed from the name to resolve or default_port_+  int port_ ABSL_GUARDED_BY(mu_) = 0;+  const EventEngine::Duration timeout_ ABSL_GUARDED_BY(mu_);+  size_t pending_queries_ ABSL_GUARDED_BY(mu_) = 0;+  bool shutting_down_ ABSL_GUARDED_BY(mu_) = false;+  bool cancelled_ ABSL_GUARDED_BY(mu_) = false;+  absl::Status error_ ABSL_GUARDED_BY(mu_);+  std::unique_ptr<FdNodeList> fd_node_list_ ABSL_GUARDED_BY(mu_);+  EventEngine* event_engine_;+  absl::optional<EventEngine::TaskHandle> query_timeout_handle_+      ABSL_GUARDED_BY(mu_);+  absl::optional<EventEngine::TaskHandle> ares_backup_poll_alarm_handle_+      ABSL_GUARDED_BY(mu_);+  std::unique_ptr<GrpcPolledFdFactory> polled_fd_factory_ ABSL_GUARDED_BY(mu_);+};++class GrpcAresHostnameRequestImpl final : public GrpcAresHostnameRequest,+                                          public GrpcAresRequestImpl {","Both `GrpcAresHostnameRequest` and `GrpcAresRequestImpl` have a `Cancel` method, but I think it's only implemented in `GrpcAresRequestImpl` today (though `GrpcAresRequestImpl` does not implement that interface). Have you considered instead making `GrpcAresHostnameRequestImpl` _have_ a base request, rather than _be_ a base request?Again, I think multiple inheritance of _interfaces_ is usually fine, but any behavior inheritance gets messy. I'd like to see a design without it.",X
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/32701,1155016209,2023-04-01T00:08:12Z,src/core/lib/event_engine/ares_driver.cc,"@@ -0,0 +1,1177 @@+// Copyright 2023 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++#include ""src/core/lib/event_engine/ares_driver.h""++#include <arpa/nameser.h>+#include <inttypes.h>+#include <netdb.h>+#include <string.h>++#include <algorithm>+#include <chrono>+#include <initializer_list>+#include <ratio>+#include <type_traits>+#include <utility>++#include <address_sorting/address_sorting.h>++#include ""absl/cleanup/cleanup.h""+#include ""absl/strings/numbers.h""+#include ""absl/strings/str_cat.h""+#include ""absl/strings/str_format.h""+#include ""absl/types/optional.h""++#include <grpc/event_engine/event_engine.h>+#include <grpc/support/alloc.h>+#include <grpc/support/log.h>++#include ""src/core/lib/address_utils/parse_address.h""+#include ""src/core/lib/address_utils/sockaddr_utils.h""+#include ""src/core/lib/event_engine/grpc_polled_fd.h""+#include ""src/core/lib/event_engine/nameser.h""  // IWYU pragma: keep+#include ""src/core/lib/event_engine/tcp_socket_utils.h""+#include ""src/core/lib/event_engine/time_util.h""+#include ""src/core/lib/gpr/string.h""+#include ""src/core/lib/gprpp/debug_location.h""+#include ""src/core/lib/gprpp/examine_stack.h""+#include ""src/core/lib/gprpp/host_port.h""+#include ""src/core/lib/gprpp/ref_counted_ptr.h""+#include ""src/core/lib/gprpp/status_helper.h""+#include ""src/core/lib/gprpp/sync.h""+#include ""src/core/lib/iomgr/error.h""+#include ""src/core/lib/iomgr/exec_ctx.h""+#include ""src/core/lib/iomgr/resolved_address.h""+#include ""src/core/lib/iomgr/sockaddr.h""+#ifdef _WIN32+#else+#include ""src/core/lib/event_engine/posix_engine/tcp_socket_utils.h""+#endif++namespace grpc_event_engine {+namespace experimental {++grpc_core::TraceFlag grpc_trace_ares_driver_address_sorting(+    false, ""ares_driver_address_sorting"");++grpc_core::TraceFlag grpc_trace_ares_driver_stacktrace(+    false, ""ares_driver_stacktrace"");++#define GRPC_ARES_DRIVER_STACK_TRACE()                                \+  do {                                                                \+    if (GRPC_TRACE_FLAG_ENABLED(grpc_trace_ares_driver_stacktrace)) { \+      absl::optional<std::string> stacktrace =                        \+          grpc_core::GetCurrentStackTrace();                          \+      if (stacktrace.has_value()) {                                   \+        gpr_log(GPR_DEBUG, ""%s"", stacktrace->c_str());                \+      } else {                                                        \+        gpr_log(GPR_DEBUG, ""stacktrace unavailable"");                 \+      }                                                               \+    }                                                                 \+  } while (0)++grpc_core::TraceFlag grpc_trace_ares_driver(false, ""ares_driver"");++namespace {++struct FdNode;+class FdNodeList;++class GrpcAresRequestImpl : public grpc_core::RefCounted<GrpcAresRequestImpl> {+ public:+  GrpcAresRequestImpl(absl::string_view name,+                      absl::optional<absl::string_view> default_port,+                      EventEngine::Duration timeout,+                      RegisterAresSocketWithPollerCallback register_cb,+                      EventEngine* event_engine);+  ~GrpcAresRequestImpl() override;++  absl::Status Initialize(absl::string_view dns_server, bool check_port)+      ABSL_LOCKS_EXCLUDED(mu_);+  bool Cancel() ABSL_LOCKS_EXCLUDED(mu_);+  absl::string_view host() const ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu_) {+    return host_;+  }+  int port() const ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu_) { return port_; }++ protected:+  void Work() ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu_);+  void StartTimers() ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu_);+  void CancelTimers() ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu_);++ private:+  friend class GrpcPolledFd;+  friend class GrpcPolledFdFactory;+  friend struct FdNode;+  friend class FdNodeList;++  absl::Status SetRequestDNSServer(absl::string_view dns_server)+      ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu_);+  void OnReadable(FdNode* fd_node, absl::Status status)+      ABSL_LOCKS_EXCLUDED(mu_);+  void OnWritable(FdNode* fd_node, absl::Status status)+      ABSL_LOCKS_EXCLUDED(mu_);+  void OnHandleDestroyed(FdNode* fd_node, absl::Status status)+      ABSL_LOCKS_EXCLUDED(mu_);+  void OnQueryTimeout() ABSL_LOCKS_EXCLUDED(mu_);+  void OnAresBackupPollAlarm() ABSL_LOCKS_EXCLUDED(mu_);+  void ShutdownPollerHandlesLocked(absl::Status status)+      ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu_);++ protected:+  grpc_core::Mutex mu_;+  bool initialized_ ABSL_GUARDED_BY(mu_) = false;+  /// name to resolve+  const std::string name_ ABSL_GUARDED_BY(mu_);+  const std::string default_port_ ABSL_GUARDED_BY(mu_);+  // ares channel+  ares_channel channel_ ABSL_GUARDED_BY(mu_) = nullptr;+  /// host to resolve; parsed from the name to resolve+  absl::string_view host_ ABSL_GUARDED_BY(mu_);+  /// port; parsed from the name to resolve or default_port_+  int port_ ABSL_GUARDED_BY(mu_) = 0;+  const EventEngine::Duration timeout_ ABSL_GUARDED_BY(mu_);+  size_t pending_queries_ ABSL_GUARDED_BY(mu_) = 0;+  bool shutting_down_ ABSL_GUARDED_BY(mu_) = false;+  bool cancelled_ ABSL_GUARDED_BY(mu_) = false;+  absl::Status error_ ABSL_GUARDED_BY(mu_);+  std::unique_ptr<FdNodeList> fd_node_list_ ABSL_GUARDED_BY(mu_);+  EventEngine* event_engine_;+  absl::optional<EventEngine::TaskHandle> query_timeout_handle_+      ABSL_GUARDED_BY(mu_);+  absl::optional<EventEngine::TaskHandle> ares_backup_poll_alarm_handle_+      ABSL_GUARDED_BY(mu_);+  std::unique_ptr<GrpcPolledFdFactory> polled_fd_factory_ ABSL_GUARDED_BY(mu_);+};++class GrpcAresHostnameRequestImpl final : public GrpcAresHostnameRequest,+                                          public GrpcAresRequestImpl {","It seems to me that the major reason to have the `*Impl` PIMPL classes here is to protect the `EventEngine` implementation from using one internal DNS resolution methods that it should not use, but must be public for other reasons (`OnResolved`). I'm not sure the added complexity is worth it.",
672669,sergiitk,https://api.github.com/repos/grpc/grpc/pulls/32786,1156445218,2023-04-03T20:50:26Z,tools/run_tests/xds_k8s_test_driver/README.md,"@@ -174,7 +174,13 @@ export KUBE_CONTEXT=""$(kubectl config current-context)""  ```shell # Create python virtual environment-python3.7 -m venv venv+python3 -m venv venv++# On some Ubuntu systems previous command may fail with the message saying:","Let's add this to the (""Requirements"")[https://github.com/grpc/grpc/blob/master/tools/run_tests/xds_k8s_test_driver/README.md#requirements] section instead. Just list it below `Python v3.7+`. ",
672669,sergiitk,https://api.github.com/repos/grpc/grpc/pulls/32786,1156445898,2023-04-03T20:51:22Z,tools/run_tests/xds_k8s_test_driver/README.md,"@@ -174,7 +174,13 @@ export KUBE_CONTEXT=""$(kubectl config current-context)""  ```shell # Create python virtual environment-python3.7 -m venv venv+python3 -m venv venv++# On some Ubuntu systems previous command may fail with the message saying:",* it = [python3-venv](https://docs.python.org/3.7/library/venv.html).,
5663878,yijiem,https://api.github.com/repos/grpc/grpc/pulls/32603,1156477513,2023-04-03T21:34:11Z,test/core/end2end/tests/simple_delayed_request.cc,"@@ -16,164 +16,59 @@ // // -#include <string.h>--#include <functional>-#include <memory>+#include ""gtest/gtest.h""  #include <grpc/grpc.h>-#include <grpc/impl/propagation_bits.h>-#include <grpc/slice.h> #include <grpc/status.h>-#include <grpc/support/log.h>-#include <grpc/support/time.h>  #include ""src/core/lib/channel/channel_args.h""-#include ""test/core/end2end/cq_verifier.h""+#include ""src/core/lib/gprpp/time.h"" #include ""test/core/end2end/end2end_tests.h""-#include ""test/core/util/test_config.h""--static void simple_delayed_request_body(CoreTestFixture* f) {-  grpc_call* c;-  grpc_call* s;-  grpc_core::CqVerifier cqv(f->cq());-  grpc_op ops[6];-  grpc_op* op;-  grpc_metadata_array initial_metadata_recv;-  grpc_metadata_array trailing_metadata_recv;-  grpc_metadata_array request_metadata_recv;-  grpc_call_details call_details;-  grpc_status_code status;-  grpc_call_error error;-  grpc_slice details;-  int was_cancelled = 2;--  f->InitClient(grpc_core::ChannelArgs());-  f->InitServer(grpc_core::ChannelArgs());--  gpr_timespec deadline = grpc_timeout_seconds_to_deadline(5);-  c = grpc_channel_create_call(f->client(), nullptr, GRPC_PROPAGATE_DEFAULTS,-                               f->cq(), grpc_slice_from_static_string(""/foo""),-                               nullptr, deadline, nullptr);-  GPR_ASSERT(c);--  grpc_metadata_array_init(&initial_metadata_recv);-  grpc_metadata_array_init(&trailing_metadata_recv);-  grpc_metadata_array_init(&request_metadata_recv);-  grpc_call_details_init(&call_details);--  memset(ops, 0, sizeof(ops));-  op = ops;-  op->op = GRPC_OP_SEND_INITIAL_METADATA;-  op->data.send_initial_metadata.count = 0;-  op->flags = GRPC_INITIAL_METADATA_WAIT_FOR_READY;-  op->reserved = nullptr;-  op++;-  op->op = GRPC_OP_SEND_CLOSE_FROM_CLIENT;-  op->flags = 0;-  op->reserved = nullptr;-  op++;-  op->op = GRPC_OP_RECV_INITIAL_METADATA;-  op->data.recv_initial_metadata.recv_initial_metadata = &initial_metadata_recv;-  op->flags = 0;-  op->reserved = nullptr;-  op++;-  op->op = GRPC_OP_RECV_STATUS_ON_CLIENT;-  op->data.recv_status_on_client.trailing_metadata = &trailing_metadata_recv;-  op->data.recv_status_on_client.status = &status;-  op->data.recv_status_on_client.status_details = &details;-  op->flags = 0;-  op->reserved = nullptr;-  op++;-  error = grpc_call_start_batch(c, ops, static_cast<size_t>(op - ops),-                                grpc_core::CqVerifier::tag(1), nullptr);-  GPR_ASSERT(GRPC_CALL_OK == error);--  error = grpc_server_request_call(f->server(), &s, &call_details,-                                   &request_metadata_recv, f->cq(), f->cq(),-                                   grpc_core::CqVerifier::tag(101));-  GPR_ASSERT(GRPC_CALL_OK == error);-  cqv.Expect(grpc_core::CqVerifier::tag(101), true);-  cqv.Verify();--  memset(ops, 0, sizeof(ops));-  op = ops;-  op->op = GRPC_OP_SEND_INITIAL_METADATA;-  op->data.send_initial_metadata.count = 0;-  op->flags = 0;-  op->reserved = nullptr;-  op++;-  op->op = GRPC_OP_SEND_STATUS_FROM_SERVER;-  op->data.send_status_from_server.trailing_metadata_count = 0;-  op->data.send_status_from_server.status = GRPC_STATUS_UNIMPLEMENTED;-  grpc_slice status_details = grpc_slice_from_static_string(""xyz"");-  op->data.send_status_from_server.status_details = &status_details;-  op->flags = 0;-  op->reserved = nullptr;-  op++;-  op->op = GRPC_OP_RECV_CLOSE_ON_SERVER;-  op->data.recv_close_on_server.cancelled = &was_cancelled;-  op->flags = 0;-  op->reserved = nullptr;-  op++;-  error = grpc_call_start_batch(s, ops, static_cast<size_t>(op - ops),-                                grpc_core::CqVerifier::tag(102), nullptr);-  GPR_ASSERT(GRPC_CALL_OK == error); -  cqv.Expect(grpc_core::CqVerifier::tag(102), true);-  cqv.Expect(grpc_core::CqVerifier::tag(1), true);-  cqv.Verify();--  GPR_ASSERT(status == GRPC_STATUS_UNIMPLEMENTED);-  GPR_ASSERT(0 == grpc_slice_str_cmp(details, ""xyz""));-  GPR_ASSERT(0 == grpc_slice_str_cmp(call_details.method, ""/foo""));-  GPR_ASSERT(was_cancelled == 0);--  grpc_slice_unref(details);-  grpc_metadata_array_destroy(&initial_metadata_recv);-  grpc_metadata_array_destroy(&trailing_metadata_recv);-  grpc_metadata_array_destroy(&request_metadata_recv);-  grpc_call_details_destroy(&call_details);--  grpc_call_unref(c);-  grpc_call_unref(s);-}--static void test_simple_delayed_request_short(-    const CoreTestConfiguration& config) {-  auto client_args = grpc_core::ChannelArgs()-                         .Set(GRPC_ARG_INITIAL_RECONNECT_BACKOFF_MS, 1000)-                         .Set(GRPC_ARG_MAX_RECONNECT_BACKOFF_MS, 1000)-                         .Set(GRPC_ARG_MIN_RECONNECT_BACKOFF_MS, 5000)-                         .ToC();-  gpr_log(GPR_INFO, ""Running test: %s/%s"", ""test_simple_delayed_request_short"",-          config.name);-  auto f =-      config.create_fixture(grpc_core::ChannelArgs(), grpc_core::ChannelArgs());--  simple_delayed_request_body(f.get());+namespace grpc_core {+namespace {++void SimpleDelayedRequestBody(CoreEnd2endTest& test) {+  auto c = test.NewClientCall(""/foo"").Timeout(Duration::Seconds(5)).Create();+  CoreEnd2endTest::IncomingMetadata server_initial_metadata;+  CoreEnd2endTest::IncomingStatusOnClient server_status;+  c.NewBatch(1)+      .SendInitialMetadata({}, GRPC_INITIAL_METADATA_WAIT_FOR_READY)+      .SendCloseFromClient()+      .RecvInitialMetadata(server_initial_metadata)+      .RecvStatusOnClient(server_status);+  test.InitServer(ChannelArgs());+  auto s = test.RequestCall(101);+  test.Expect(101, true);+  test.Step();+  CoreEnd2endTest::IncomingCloseOnServer client_close;+  s.NewBatch(102)+      .SendInitialMetadata({})+      .SendStatusFromServer(GRPC_STATUS_UNIMPLEMENTED, ""xyz"", {})+      .RecvCloseOnServer(client_close);+  test.Expect(102, true);+  test.Expect(1, true);+  test.Step();+  EXPECT_EQ(server_status.status(), GRPC_STATUS_UNIMPLEMENTED);+  EXPECT_EQ(server_status.message(), ""xyz"");+  EXPECT_EQ(s.method(), ""/foo"");+  EXPECT_FALSE(client_close.was_cancelled()); } -static void test_simple_delayed_request_long(-    const CoreTestConfiguration& config) {-  auto client_args = grpc_core::ChannelArgs()-                         .Set(GRPC_ARG_INITIAL_RECONNECT_BACKOFF_MS, 1000)-                         .Set(GRPC_ARG_MAX_RECONNECT_BACKOFF_MS, 1000)-                         .Set(GRPC_ARG_MIN_RECONNECT_BACKOFF_MS, 5000)-                         .ToC();--  gpr_log(GPR_INFO, ""Running test: %s/%s"", ""test_simple_delayed_request_long"",-          config.name);-  auto f =-      config.create_fixture(grpc_core::ChannelArgs(), grpc_core::ChannelArgs());-  // This timeout should be longer than a single retry-  simple_delayed_request_body(f.get());+TEST_P(CoreClientChannelTest, SimpleDelayedRequestShort) {+  InitClient(ChannelArgs()+                 .Set(GRPC_ARG_INITIAL_RECONNECT_BACKOFF_MS, 1000)+                 .Set(GRPC_ARG_MAX_RECONNECT_BACKOFF_MS, 1000)+                 .Set(GRPC_ARG_MIN_RECONNECT_BACKOFF_MS, 5000));+  SimpleDelayedRequestBody(*this); } -void simple_delayed_request(const CoreTestConfiguration& config) {-  GPR_ASSERT(config.feature_mask & FEATURE_MASK_SUPPORTS_DELAYED_CONNECTION);-  test_simple_delayed_request_short(config);-  test_simple_delayed_request_long(config);+TEST_P(CoreClientChannelTest, SimpleDelayedRequestLong) {+  InitClient(ChannelArgs()+                 .Set(GRPC_ARG_INITIAL_RECONNECT_BACKOFF_MS, 1000)+                 .Set(GRPC_ARG_MAX_RECONNECT_BACKOFF_MS, 1000)+                 .Set(GRPC_ARG_MIN_RECONNECT_BACKOFF_MS, 5000));+  SimpleDelayedRequestBody(*this);",Missed a comment `// This timeout should be longer than a single retry`; but aren't these 2 tests exactly the same? Should we remove one?,X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32715,1157848160,2023-04-04T23:02:56Z,include/grpcpp/ext/gcp_observability.h,"@@ -22,15 +22,35 @@ #include ""absl/status/status.h"" #include ""absl/status/statusor.h"" -namespace grpc_gcp {+#include <grpcpp/impl/grpc_library.h> -// Observability objects follow the RAII idiom and help manage the lifetime of-// gRPC Observability data exporting to GCP. It is illegal to directly construct-// objects of this class. `ObservabilityInit()` should be invoked instead to-// return an `Observability` instance. Observability data is flushed at regular-// intervals, and also when this instance goes out of scope and its destructor-// is invoked.-class Observability {+namespace grpc {++namespace internal {+// Helper class that aids in implementing GCP Observability.+// Inheriting from GrpcLibrary makes sure that gRPC is initialized and remains+// initialized for the lifetime of GCP Observability. In the future, when gRPC+// initialization goes away, we might still want to keep gRPC Event Engine+// initialized, just in case, we need to perform some IO operations during+// observability close.+// Note that the lifetime guarantees are only one way, i.e., GcpObservability+// object guarantees that gRPC will not shutdown while the object is still in+// scope, but the other way around does not hold true. Even though that is not+// the expected usage, GCP Observability can shutdown before gRPC shuts down. It+// follows that gRPC should not hold any callbacks from GcpObservability. A+// change in this restriction should go through a design review.+class GcpObservabilityImpl : private GrpcLibrary {",This class can be private within `GcpObservability` rather than being in a separate `internal` namespace.,
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/32734,1158650800,2023-04-05T15:04:00Z,test/csharp/codegen/BUILD,"@@ -0,0 +1,28 @@+# Copyright 2017 gRPC authors.+#+# Licensed under the Apache License, Version 2.0 (the ""License"");+# you may not use this file except in compliance with the License.+# You may obtain a copy of the License at+#+#     http://www.apache.org/licenses/LICENSE-2.0+#+# Unless required by applicable law or agreed to in writing, software+# distributed under the License is distributed on an ""AS IS"" BASIS,+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+# See the License for the specific language governing permissions and+# limitations under the License.++load(""//bazel:grpc_build_system.bzl"", ""grpc_sh_test"")++licenses([""notice""])++grpc_sh_test(+    name = ""csharp_codegen_simple_test"",+    srcs = [""csharp_codegen_simple_test.sh""],+    data = [+        ""//src/compiler:grpc_csharp_plugin"",+        ""@com_google_protobuf//:protoc"",+    ] + glob([""simple/**""]),",I think glob() is considered an antipattern with bazel. It's better to simply list the actual files you'll use.,
5663878,yijiem,https://api.github.com/repos/grpc/grpc/pulls/32701,1158929180,2023-04-05T19:27:59Z,src/core/lib/event_engine/ares_driver.cc,"@@ -273,11 +414,9 @@ bool IsIpv6LoopbackAvailable() { #endif } -}  // namespace--struct GrpcAresRequest::FdNode {+struct FdNode {",`GrpcAresRequestImpl` references `FdNode*` in a few private methods in its class definition. I could define `FdNode` before it in ares_driver.cc but would still need to forward declare it if an equivalent of `GrpcAresRequestImpl` is defined in ares_driver.h (revert the usage of PIMPL).,
5663878,yijiem,https://api.github.com/repos/grpc/grpc/pulls/32701,1159022650,2023-04-05T21:05:00Z,src/core/lib/event_engine/ares_driver.cc,"@@ -327,12 +466,12 @@ class GrpcAresRequest::FdNodeList {   bool IsEmpty() const { return head_ == nullptr; }    void PushFdNode(FdNode* fd_node)-      ABSL_EXCLUSIVE_LOCKS_REQUIRED(&GrpcAresRequest::mu_) {+      ABSL_EXCLUSIVE_LOCKS_REQUIRED(&GrpcAresRequestImpl::mu_) {",You mean doing something like the following?```  explicit FdNodeList(grpc_core::Mutex* mu) : mu_(mu) {}  FdNode* PopFdNode() ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu_) {    ...  } private:  grpc_core::Mutex* mu_;```Seems like clang's thread safety analysis does not support alias analysis right now: https://releases.llvm.org/3.5.0/tools/clang/docs/ThreadSafetyAnalysis.html#no-alias-analysis. But I have made `FdNode` and `FdNodeList` inner classes of `GrpcAresRequest` so we don't have this problem now.,
1644595,gnossen,https://api.github.com/repos/grpc/grpc/pulls/32800,1159088836,2023-04-05T22:33:10Z,src/python/grpcio/grpc/_observability.py,"@@ -0,0 +1,83 @@+# Copyright 2020 The gRPC authors.+#+# Licensed under the Apache License, Version 2.0 (the ""License"");+# you may not use this file except in compliance with the License.+# You may obtain a copy of the License at+#+#     http://www.apache.org/licenses/LICENSE-2.0+#+# Unless required by applicable law or agreed to in writing, software+# distributed under the License is distributed on an ""AS IS"" BASIS,+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+# See the License for the specific language governing permissions and+# limitations under the License.++import types+import logging++from grpc._cython import cygrpc as _cygrpc++_REQUIRED_SYMBOLS = (""_create_client_call_tracer_capsule"",+                     ""_save_span_context"")+_UNINSTALLED_TEMPLATE = ""Install the grpc_observability package (1.xx.xx) to use the {} function.""++_LOGGER = logging.getLogger(__name__)+++def _has_symbols(mod: types.ModuleType) -> bool:+    return all(hasattr(mod, sym) for sym in _REQUIRED_SYMBOLS)+++def _is_grpc_observability_importable() -> bool:+    try:+        import grpc_observability  # pylint: disable=unused-import # pytype: disable=import-error+        return True+    except ImportError as e:+        # NOTE: It's possible that we're encountering a transitive ImportError, so+        # we check for that and re-raise if so.+        if ""grpc_observability"" not in e.args[0]:+            raise+        return False+++def _call_with_lazy_import(fn_name: str, **kwargs) -> types.ModuleType:+    """"""Calls one of the three functions, lazily importing grpc_observability.",Comment is no longer accurate after copy-paste.,
24593237,XuanWang-Amos,https://api.github.com/repos/grpc/grpc/pulls/32475,1159156648,2023-04-06T00:03:24Z,src/python/grpcio/grpc/aio/_call.py,"@@ -265,7 +265,7 @@ def cancel(self) -> bool:         else:             return False -    def __await__(self) -> ResponseType:+    def __await__(self) -> Generator[Any, None, ResponseType]:",Nit: We might need add `Generic` to this class too.,X
5663878,yijiem,https://api.github.com/repos/grpc/grpc/pulls/32701,1159185935,2023-04-06T00:53:24Z,src/core/lib/event_engine/ares_driver.cc,"@@ -0,0 +1,952 @@+// Copyright 2023 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++#include ""src/core/lib/event_engine/ares_driver.h""++#include <arpa/nameser.h>","Sorry for the mess in the include headers. I added back the original `// IWYU pragma: no_include ...`s.I think c-ares uses the values defined in `<arpa/nameser.h>` as parameters in its public API (e.g. [ares_query](https://c-ares.org/ares_query.html)). For platforms that do not have `<arpa/nameser.h>` such as Windows, we manually defined them in `src/core/lib/event_engine/nameser.h` (or `src/core/lib/iomgr/nameser.h` as in its original location).Starting from version `1.18.0`, c-ares provides `ares_nameser.h` in its public include files: https://github.com/c-ares/c-ares/blob/main/include/ares_nameser.h#L68-L73",
5663878,yijiem,https://api.github.com/repos/grpc/grpc/pulls/32701,1160119253,2023-04-06T18:20:45Z,src/core/lib/event_engine/ares_driver.cc,"@@ -0,0 +1,1177 @@+// Copyright 2023 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++#include ""src/core/lib/event_engine/ares_driver.h""++#include <arpa/nameser.h>+#include <inttypes.h>+#include <netdb.h>+#include <string.h>++#include <algorithm>+#include <chrono>+#include <initializer_list>+#include <ratio>+#include <type_traits>+#include <utility>++#include <address_sorting/address_sorting.h>++#include ""absl/cleanup/cleanup.h""+#include ""absl/strings/numbers.h""+#include ""absl/strings/str_cat.h""+#include ""absl/strings/str_format.h""+#include ""absl/types/optional.h""++#include <grpc/event_engine/event_engine.h>+#include <grpc/support/alloc.h>+#include <grpc/support/log.h>++#include ""src/core/lib/address_utils/parse_address.h""+#include ""src/core/lib/address_utils/sockaddr_utils.h""+#include ""src/core/lib/event_engine/grpc_polled_fd.h""+#include ""src/core/lib/event_engine/nameser.h""  // IWYU pragma: keep+#include ""src/core/lib/event_engine/tcp_socket_utils.h""+#include ""src/core/lib/event_engine/time_util.h""+#include ""src/core/lib/gpr/string.h""+#include ""src/core/lib/gprpp/debug_location.h""+#include ""src/core/lib/gprpp/examine_stack.h""+#include ""src/core/lib/gprpp/host_port.h""+#include ""src/core/lib/gprpp/ref_counted_ptr.h""+#include ""src/core/lib/gprpp/status_helper.h""+#include ""src/core/lib/gprpp/sync.h""+#include ""src/core/lib/iomgr/error.h""+#include ""src/core/lib/iomgr/exec_ctx.h""+#include ""src/core/lib/iomgr/resolved_address.h""+#include ""src/core/lib/iomgr/sockaddr.h""+#ifdef _WIN32+#else+#include ""src/core/lib/event_engine/posix_engine/tcp_socket_utils.h""+#endif++namespace grpc_event_engine {+namespace experimental {++grpc_core::TraceFlag grpc_trace_ares_driver_address_sorting(+    false, ""ares_driver_address_sorting"");++grpc_core::TraceFlag grpc_trace_ares_driver_stacktrace(+    false, ""ares_driver_stacktrace"");++#define GRPC_ARES_DRIVER_STACK_TRACE()                                \+  do {                                                                \+    if (GRPC_TRACE_FLAG_ENABLED(grpc_trace_ares_driver_stacktrace)) { \+      absl::optional<std::string> stacktrace =                        \+          grpc_core::GetCurrentStackTrace();                          \+      if (stacktrace.has_value()) {                                   \+        gpr_log(GPR_DEBUG, ""%s"", stacktrace->c_str());                \+      } else {                                                        \+        gpr_log(GPR_DEBUG, ""stacktrace unavailable"");                 \+      }                                                               \+    }                                                                 \+  } while (0)++grpc_core::TraceFlag grpc_trace_ares_driver(false, ""ares_driver"");++namespace {++struct FdNode;+class FdNodeList;++class GrpcAresRequestImpl : public grpc_core::RefCounted<GrpcAresRequestImpl> {+ public:+  GrpcAresRequestImpl(absl::string_view name,+                      absl::optional<absl::string_view> default_port,+                      EventEngine::Duration timeout,+                      RegisterAresSocketWithPollerCallback register_cb,+                      EventEngine* event_engine);+  ~GrpcAresRequestImpl() override;++  absl::Status Initialize(absl::string_view dns_server, bool check_port)+      ABSL_LOCKS_EXCLUDED(mu_);+  bool Cancel() ABSL_LOCKS_EXCLUDED(mu_);+  absl::string_view host() const ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu_) {+    return host_;+  }+  int port() const ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu_) { return port_; }++ protected:+  void Work() ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu_);+  void StartTimers() ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu_);+  void CancelTimers() ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu_);++ private:+  friend class GrpcPolledFd;+  friend class GrpcPolledFdFactory;+  friend struct FdNode;+  friend class FdNodeList;++  absl::Status SetRequestDNSServer(absl::string_view dns_server)+      ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu_);+  void OnReadable(FdNode* fd_node, absl::Status status)+      ABSL_LOCKS_EXCLUDED(mu_);+  void OnWritable(FdNode* fd_node, absl::Status status)+      ABSL_LOCKS_EXCLUDED(mu_);+  void OnHandleDestroyed(FdNode* fd_node, absl::Status status)+      ABSL_LOCKS_EXCLUDED(mu_);+  void OnQueryTimeout() ABSL_LOCKS_EXCLUDED(mu_);+  void OnAresBackupPollAlarm() ABSL_LOCKS_EXCLUDED(mu_);+  void ShutdownPollerHandlesLocked(absl::Status status)+      ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu_);++ protected:+  grpc_core::Mutex mu_;+  bool initialized_ ABSL_GUARDED_BY(mu_) = false;+  /// name to resolve+  const std::string name_ ABSL_GUARDED_BY(mu_);+  const std::string default_port_ ABSL_GUARDED_BY(mu_);+  // ares channel+  ares_channel channel_ ABSL_GUARDED_BY(mu_) = nullptr;+  /// host to resolve; parsed from the name to resolve+  absl::string_view host_ ABSL_GUARDED_BY(mu_);+  /// port; parsed from the name to resolve or default_port_+  int port_ ABSL_GUARDED_BY(mu_) = 0;+  const EventEngine::Duration timeout_ ABSL_GUARDED_BY(mu_);+  size_t pending_queries_ ABSL_GUARDED_BY(mu_) = 0;+  bool shutting_down_ ABSL_GUARDED_BY(mu_) = false;+  bool cancelled_ ABSL_GUARDED_BY(mu_) = false;+  absl::Status error_ ABSL_GUARDED_BY(mu_);+  std::unique_ptr<FdNodeList> fd_node_list_ ABSL_GUARDED_BY(mu_);+  EventEngine* event_engine_;+  absl::optional<EventEngine::TaskHandle> query_timeout_handle_+      ABSL_GUARDED_BY(mu_);+  absl::optional<EventEngine::TaskHandle> ares_backup_poll_alarm_handle_+      ABSL_GUARDED_BY(mu_);+  std::unique_ptr<GrpcPolledFdFactory> polled_fd_factory_ ABSL_GUARDED_BY(mu_);+};++class GrpcAresHostnameRequestImpl final : public GrpcAresHostnameRequest,+                                          public GrpcAresRequestImpl {","yeah, I think the issue with the _have_ model is that these will be some extra complexities in refcounting and locking since those are essentially shared states between e.g. `GrpcAresHostnameRequestImpl` and `GrpcAresRequestImpl`.But feedback well-taken and I don't like the added complexity either. I have reverted the PIMPL change.",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/32825,1160126803,2023-04-06T18:27:13Z,src/core/ext/transport/chttp2/transport/context_list.h,"@@ -32,18 +31,46 @@ namespace grpc_core { class ContextList {  public:   // Creates a new element with \a context as the value and appends it to the-  // list.-  static void Append(ContextList** head, grpc_chttp2_stream* s);+  // list. Each RPC/stream is associated with a unique \a context. This method+  // is invoked when a chunk of data stored in an outgoing buffer is going to be+  // sent over the wire. A data chunk being written over the wire is multiplexed+  // with bytes from multiple RPCs. If one such RPC is traced, we store the+  // following information about the traced RPC:+  // - byte_offset_in_stream: Number of bytes belonging to that traced RPC which+  // have been sent so far from the start of the RPC stream.+  // - relative_start_pos_in_chunk: Starting offset of the traced RPC within+  // the current chunk that is being sent.+  // - num_traced_bytes_in_chunk: Number of bytes belonging to the traced RPC+  // within the current chunk.+  static void Append(ContextList** tail, void* context,+                     size_t byte_offset_in_stream,+                     int64_t relative_start_pos_in_chunk,+                     int64_t num_traced_bytes_in_chunk); -  // Executes a function \a fn with each context in the list and \a ts. It also-  // frees up the entire list after this operation. It is intended as a callback-  // and hence does not take a ref on \a error+  // Executes the function set using grpc_http2_set_write_timestamps_callback+  // method with each context in the list and \a ts. It also frees up the entire+  // list after this operation. It is intended as a callback and hence does not+  // take a ref on \a error. The fn receives individual contexts in the same+  // order in which they were Appended.   static void Execute(void* arg, Timestamps* ts, grpc_error_handle error); +  // Executes the passed function \a cb with each context in the list. The+  // arguments provided to cb include the trace_context_, byte_offset_,+  // traced_bytes_relative_start_pos_ and num_traced_bytes_ for each context in+  // the context list. It also frees up the entire list after this operation.+  // The cb receives individual contexts in the same order in which they were+  // Appended.+  static void ForEachExecuteCallback(+      ContextList* tail,+      std::function<void(void*, size_t, int64_t, int64_t)> cb);",Prefer `absl::FunctionRef` - we don't need to hold this function longer,
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/32808,1160266395,2023-04-06T21:18:01Z,src/core/lib/json/json.h,"@@ -86,140 +86,107 @@ class Json {    // Construct by moving a string.   // NOLINTNEXTLINE(google-explicit-constructor)-  Json(std::string&& string)-      : type_(Type::kString), string_value_(std::move(string)) {}+  Json(std::string&& string) : value_(Value(std::move(string))) {}   Json& operator=(std::string&& string) {-    type_ = Type::kString;-    string_value_ = std::move(string);+    value_ = Value(std::move(string));     return *this;   }    // Construct from bool.   // NOLINTNEXTLINE(google-explicit-constructor)-  Json(bool b) : type_(b ? Type::kTrue : Type::kFalse) {}+  Json(bool b) : value_(b) {}   Json& operator=(bool b) {-    type_ = b ? Type::kTrue : Type::kFalse;+    value_ = b;     return *this;   }    // Construct from any numeric type.   template <typename NumericType>   // NOLINTNEXTLINE(google-explicit-constructor)-  Json(NumericType number)","For a follow-up PR (I didn't catch this earlier, sorry!)This function provides implicit conversion for anything that `std::to_string` supports - which may change in the future and bite us... would suggest making an explicit set of types for a public API.Worse though:```std::to_string relies on the current locale for formatting purposes, and therefore concurrent calls to std::to_string from multiple threads may result in partial serialization of calls.```(source: https://en.cppreference.com/w/cpp/string/basic_string/to_string)I'm not terribly fussed about the serialization (scary, but not terrible) - the locale dependency is worrisome though - I don't want to be dealing with EU specific bugs in gRPC ever.",X
1644595,gnossen,https://api.github.com/repos/grpc/grpc/pulls/32800,1160847606,2023-04-07T17:24:20Z,src/python/grpcio/grpc/_cython/_cygrpc/channel.pyx.pxi,"@@ -230,6 +234,10 @@ cdef void _call(       grpc_slice_unref(method_slice)       if host_slice_ptr:         grpc_slice_unref(host_slice)++      if observability_enabled():+        set_client_call_tracer_on_call(call_state, method)",Maybe we should encapsulate the conditional logic to the observability file by renaming this function to `maybe_set_client_call_tracer_on_call` and moving the conditional inside of the function? [This naming convention](https://github.com/search?q=repo%3Agrpc%2Fgrpc+maybe+lang%3AC%2B%2B+&type=code) is well established in the codebase.,X
1644595,gnossen,https://api.github.com/repos/grpc/grpc/pulls/32800,1160886231,2023-04-07T18:36:30Z,src/python/grpcio/grpc/_observability.py,"@@ -0,0 +1,82 @@+# Copyright 2020 The gRPC authors.+#+# Licensed under the Apache License, Version 2.0 (the ""License"");+# you may not use this file except in compliance with the License.+# You may obtain a copy of the License at+#+#     http://www.apache.org/licenses/LICENSE-2.0+#+# Unless required by applicable law or agreed to in writing, software+# distributed under the License is distributed on an ""AS IS"" BASIS,+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+# See the License for the specific language governing permissions and+# limitations under the License.++import types+import logging++from grpc._cython import cygrpc as _cygrpc++_REQUIRED_SYMBOLS = (""_create_client_call_tracer_capsule"",","What this file is doing overall is adding an optional dependency _specifically_ on the gRPC *GCP* observability package. We cannot do this.Instead, we need to add hooks so that the GCP observability package can register functions with the `grpcio` module and so can any _other_ observability module conforming to the interface.I think it would be a good idea to write a design doc specifically about how these two modules interact with one another.",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/32825,1160934033,2023-04-07T20:02:18Z,src/core/ext/transport/chttp2/transport/context_list.h,"@@ -32,18 +36,59 @@ namespace grpc_core { class ContextList {",Next question - and I don't have an answer.Do we need this class or would just having `ContextListEntry` be enough?Argument against having it:Append is just an `emplace_back` if `ContextListEntry` has the right constructor.IsEmpty is trivial.MakeNewContextList is redundant (just instantiate a `std::vector<ContextListEntry>`)`ForEachExecuteCallback` is just a really complicated way of writing `for (const auto& ent : entries) { ... }`,X
1644595,gnossen,https://api.github.com/repos/grpc/grpc/pulls/32800,1160982123,2023-04-07T21:45:41Z,src/python/grpcio/grpc/_cython/_cygrpc/observability.pyx.pxi,"@@ -0,0 +1,49 @@+import sys+import time+import os+import codecs+from libcpp.cast cimport static_cast+from libc.stdio cimport printf++from grpc import _observability++cdef const char* CLIENT_CALL_TRACER = ""client_call_tracer""+cdef const char* SERVER_CALL_TRACER_FACTORY = ""server_call_tracer_factory""++def observability_enabled() -> bool:+  return observability_tracing_enabled() or observability_metrics_enabled()+++def observability_tracing_enabled() -> bool:+  return os.environ.get('GRPC_OPEN_CENSUS_TRACING_ENABLED', '0') == 'True'+++def observability_metrics_enabled() -> bool:+  return os.environ.get('GRPC_OPEN_CENSUS_STATS_ENABLED', '0') == 'True'+++def set_server_call_tracer_factory(object capsule) -> None:+  capsule_ptr = cpython.PyCapsule_GetPointer(capsule, SERVER_CALL_TRACER_FACTORY)+  grpc_register_server_call_tracer_factory(capsule_ptr)+++def set_context_from_server_call_tracer(RequestCallEvent event) -> None:+  """"""Used to propagate context from gRPC server to OC span context.+  """"""+  if not observability_enabled():+    return+  cdef ServerCallTracer* server_call_tracer+  server_call_tracer = static_cast['ServerCallTracer*'](grpc_call_get_call_tracer(event.call.c_call))+  if observability_tracing_enabled():+    # TraceId and SpanId is hex string, need to convert to str+    trace_id = _decode(codecs.decode(server_call_tracer.TraceId(), 'hex_codec'))+    span_id = _decode(codecs.decode(server_call_tracer.SpanId(), 'hex_codec'))+    is_sampled = server_call_tracer.IsSampled()+    _observability.save_span_context(trace_id, span_id, is_sampled)+++cdef void set_client_call_tracer_on_call(_CallState call_state, bytes method):+  capsule = _observability.create_client_call_tracer_capsule(method)+  capsule_ptr = cpython.PyCapsule_GetPointer(capsule, CLIENT_CALL_TRACER)",We should double check that the generated C++ code would raise an exception if this call fails (i.e. if we are passed an invalid capsule),
1644595,gnossen,https://api.github.com/repos/grpc/grpc/pulls/32800,1160984547,2023-04-07T21:51:53Z,src/python/grpcio_observability/grpc_observability/open_census.py,"@@ -0,0 +1,84 @@+# Copyright 2023 gRPC authors.+#+# Licensed under the Apache License, Version 2.0 (the ""License"");+# you may not use this file except in compliance with the License.+# You may obtain a copy of the License at+#+#     http://www.apache.org/licenses/LICENSE-2.0+#+# Unless required by applicable law or agreed to in writing, software+# distributed under the License is distributed on an ""AS IS"" BASIS,+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+# See the License for the specific language governing permissions and+# limitations under the License.++import sys+import logging+import views+import collections++from opencensus.tags.tag_key import TagKey+from opencensus.trace.tracer import Tracer+from opencensus.trace import span_context as span_context_module+from opencensus.trace import execution_context, samplers+++logger = logging.getLogger(__name__)++_Label = collections.namedtuple('_Label', (+    'key',+    'tag_key',+    'value',+))++class gcpObservabilityConfig:","Python class names should be CamelCase, so `GcpObservabilityConfig` or `GCPObservabilityConfig`",
1644595,gnossen,https://api.github.com/repos/grpc/grpc/pulls/32800,1160986867,2023-04-07T21:55:08Z,src/python/grpcio_observability/grpc_observability/open_census.py,"@@ -0,0 +1,84 @@+# Copyright 2023 gRPC authors.+#+# Licensed under the Apache License, Version 2.0 (the ""License"");+# you may not use this file except in compliance with the License.+# You may obtain a copy of the License at+#+#     http://www.apache.org/licenses/LICENSE-2.0+#+# Unless required by applicable law or agreed to in writing, software+# distributed under the License is distributed on an ""AS IS"" BASIS,+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+# See the License for the specific language governing permissions and+# limitations under the License.++import sys+import logging+import views+import collections++from opencensus.tags.tag_key import TagKey+from opencensus.trace.tracer import Tracer+from opencensus.trace import span_context as span_context_module+from opencensus.trace import execution_context, samplers+++logger = logging.getLogger(__name__)++_Label = collections.namedtuple('_Label', (+    'key',+    'tag_key',+    'value',+))++class gcpObservabilityConfig:+    _singleton = None++    def __init__(self):+        self.project_id = """"","Type annotations please. If you add them, then you can also make this a [dataclass](https://docs.python.org/3/library/dataclasses.html) so you don't need to define an `__init__` method at all.",
1644595,gnossen,https://api.github.com/repos/grpc/grpc/pulls/32800,1161016417,2023-04-07T23:07:05Z,src/python/grpcio_observability/grpc_observability/observability_main.h,"@@ -0,0 +1,111 @@+// Copyright 2023 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++#include <stdint.h>+#include <queue>+#include <condition_variable>+#include <mutex>+#include <grpc/grpc.h>+#include <chrono>+#include <mutex>+#include <map>++#include ""absl/base/thread_annotations.h""+#include ""absl/status/status.h""+#include ""absl/strings/string_view.h""+#include ""absl/time/time.h""+#include ""absl/synchronization/mutex.h""+#include ""absl/strings/strip.h""+#include ""absl/strings/escaping.h""+#include ""absl/status/statusor.h""++#include ""src/core/lib/channel/call_tracer.h""+#include ""src/core/lib/channel/context.h""+#include ""src/cpp/ext/gcp/observability_config.h""++#include ""python_census_context.h""+#include ""constants.h""++#ifndef OBSERVABILITY_MAIN_H+#define OBSERVABILITY_MAIN_H++namespace grpc_observability {++struct CensusData {+  CensusData() {}+  CensusData(Measurement mm, std::vector<Label> labels)+      : type(kMetricData), labels(std::move(labels)), measurement_data(mm)  {}+  CensusData(SpanSensusData sd)+      : type(kSpanData), span_data(sd) {}++  DataType type;+  std::vector<Label> labels;+  // TODO(xuanwn): We can use union here+  SpanSensusData span_data;+  Measurement measurement_data;+};++struct CloudMonitoring {+  CloudMonitoring() {}+};++struct CloudTrace {+  CloudTrace() {}+  CloudTrace(double sr) : sampling_rate(sr) {}+  float sampling_rate = 0.0;+};++struct CloudLogging {+  CloudLogging() {}+};++struct GcpObservabilityConfig {+  GcpObservabilityConfig() {}+  GcpObservabilityConfig(CloudMonitoring cm, CloudTrace ct, CloudLogging cl,+             std::string pi, std::vector<Label> ls)+      : cloud_monitoring(cm), cloud_trace(ct), cloud_logging(cl), project_id(pi), labels(ls) {}+  CloudMonitoring cloud_monitoring;+  CloudTrace cloud_trace;+  CloudLogging cloud_logging;+  std::string project_id;+  std::vector<Label> labels;+};++extern std::queue<CensusData> kSensusDataBuffer;","This is not quite the right way to do this. `extern` is used when you need to reference a symbol from a different buildable unit (e.g. a `.o` or `.a` file). It looks like all you're trying to do here is declare a global (mutable) variable used exclusively by your corresponding `.cc` file. You should be able to just get rid of the `extern` keyword here.There's one additional detail here to pay attention to though. [The Google C++ style guide requires the all objects with global or static storage duration be _trivially destructible_](https://google.github.io/styleguide/cppguide.html#Static_and_Global_Variables). `std::mutex` and `std::condition_variable` are trivially destructible, but `std::queue` is not. The standard trick here is this: instead of having a global variable of type `std::queue<CensusData>`, you instead have a global variable of type `std::queue<CensusData>*` (which _is_ trivially destructible) which you then lazily construct upon its first use or whenever the module is initialized.",
1644595,gnossen,https://api.github.com/repos/grpc/grpc/pulls/32800,1161022834,2023-04-07T23:25:49Z,src/python/grpcio_observability/grpc_observability/_cyobservability.pyx,"@@ -0,0 +1,199 @@+# Copyright 2023 gRPC authors.+#+# Licensed under the Apache License, Version 2.0 (the ""License"");+# you may not use this file except in compliance with the License.+# You may obtain a copy of the License at+#+#     http://www.apache.org/licenses/LICENSE-2.0+#+# Unless required by applicable law or agreed to in writing, software+# distributed under the License is distributed on an ""AS IS"" BASIS,+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+# See the License for the specific language governing permissions and+# limitations under the License.++cimport cpython++import sys+import os+import logging+from threading import Thread+from typing import List, Tuple, Mapping++from grpc_observability import open_census+from grpc_observability import measures++cdef const char* CLIENT_CALL_TRACER = ""client_call_tracer""+cdef const char* SERVER_CALL_TRACER_FACTORY = ""server_call_tracer_factory""+cdef bint GLOBAL_SHUTDOWN_EXPORT_THREAD = False+cdef object global_export_thread++_LOGGER = logging.getLogger(__name__)++class PyMetric:+  def __init__(self, measurement, labels):+    self.name = measurement['name']+    self.labels = labels+    self.measure = METRICS_NAME_TO_MEASURE.get(self.name)+    if measurement['type'] == kMeasurementDouble:+      self.measure_double = True+      self.measure_value = measurement['value']['value_double']+    else:+      self.measure_double = False+      self.measure_value = measurement['value']['value_int']+++class PySpan:+  def __init__(self, span_data, span_labels, span_annotations):+      self.name = _decode(span_data['name'])+      self.start_time = _decode(span_data['start_time'])+      self.end_time = _decode(span_data['end_time'])+      self.trace_id = _decode(span_data['trace_id'])+      self.span_id = _decode(span_data['span_id'])+      self.parent_span_id = _decode(span_data['parent_span_id'])+      self.status = _decode(span_data['status'])+      self.span_labels = span_labels+      self.span_annotations = span_annotations+      self.should_sample = span_data['should_sample']+      self.child_span_count = span_data['child_span_count']+++def observability_init() -> None:+  _start_exporting_thread()+++def _start_exporting_thread() -> None:+  global global_export_thread+  global_export_thread = Thread(target=_export_sensus_data)+  global_export_thread.start()+++def read_gcp_observability_config() -> None:+  py_labels = {}+  sampling_rate = 0.0+  tracing_enabled = False+  monitoring_enabled = False++  cdef cGcpObservabilityConfig c_config = ReadObservabilityConfig()++  for label in c_config.labels:+    py_labels[_decode(label.key)] = _decode(label.value)++  if OpenCensusTracingEnabled():","We should be able to derive this boolean strictly from the contents of `c_config`. In general, functions should be pure (i.e. without side effects such as state changes) unless we have a compelling reason (such as performance) to add a side effect. This also incurs a dependency on the C++ OC filter that we really don't want.Maybe instead we can have a function like this?```cythoncdef bint is_tracing_enabled(cGcpObservabilityConfig c_config):    return c_config.tracing_enabled```where `tracing_enabled` is a new field added to cGcpObservabilityConfig.",
1644595,gnossen,https://api.github.com/repos/grpc/grpc/pulls/32800,1161024187,2023-04-07T23:32:14Z,src/python/grpcio_observability/grpc_observability/_cyobservability.pyx,"@@ -0,0 +1,199 @@+# Copyright 2023 gRPC authors.+#+# Licensed under the Apache License, Version 2.0 (the ""License"");+# you may not use this file except in compliance with the License.+# You may obtain a copy of the License at+#+#     http://www.apache.org/licenses/LICENSE-2.0+#+# Unless required by applicable law or agreed to in writing, software+# distributed under the License is distributed on an ""AS IS"" BASIS,+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+# See the License for the specific language governing permissions and+# limitations under the License.++cimport cpython++import sys+import os+import logging+from threading import Thread+from typing import List, Tuple, Mapping++from grpc_observability import open_census+from grpc_observability import measures++cdef const char* CLIENT_CALL_TRACER = ""client_call_tracer""+cdef const char* SERVER_CALL_TRACER_FACTORY = ""server_call_tracer_factory""+cdef bint GLOBAL_SHUTDOWN_EXPORT_THREAD = False+cdef object global_export_thread++_LOGGER = logging.getLogger(__name__)++class PyMetric:+  def __init__(self, measurement, labels):+    self.name = measurement['name']+    self.labels = labels+    self.measure = METRICS_NAME_TO_MEASURE.get(self.name)+    if measurement['type'] == kMeasurementDouble:+      self.measure_double = True+      self.measure_value = measurement['value']['value_double']+    else:+      self.measure_double = False+      self.measure_value = measurement['value']['value_int']+++class PySpan:+  def __init__(self, span_data, span_labels, span_annotations):+      self.name = _decode(span_data['name'])+      self.start_time = _decode(span_data['start_time'])+      self.end_time = _decode(span_data['end_time'])+      self.trace_id = _decode(span_data['trace_id'])+      self.span_id = _decode(span_data['span_id'])+      self.parent_span_id = _decode(span_data['parent_span_id'])+      self.status = _decode(span_data['status'])+      self.span_labels = span_labels+      self.span_annotations = span_annotations+      self.should_sample = span_data['should_sample']+      self.child_span_count = span_data['child_span_count']+++def observability_init() -> None:+  _start_exporting_thread()+++def _start_exporting_thread() -> None:+  global global_export_thread+  global_export_thread = Thread(target=_export_sensus_data)+  global_export_thread.start()+++def read_gcp_observability_config() -> None:+  py_labels = {}+  sampling_rate = 0.0+  tracing_enabled = False+  monitoring_enabled = False++  cdef cGcpObservabilityConfig c_config = ReadObservabilityConfig()++  for label in c_config.labels:+    py_labels[_decode(label.key)] = _decode(label.value)++  if OpenCensusTracingEnabled():+    sampling_rate = c_config.cloud_trace.sampling_rate+    tracing_enabled = True+    os.environ['GRPC_OPEN_CENSUS_TRACING_ENABLED'] = 'True'+    # Save sampling rate to global sampler.+    ProbabilitySampler.Get().SetThreshold(sampling_rate)++  if OpenCensusStatsEnabled():+    monitoring_enabled = True+    os.environ['GRPC_OPEN_CENSUS_STATS_ENABLED'] = 'True'++  py_config = open_census.gcpObservabilityConfig.get()+  py_config.set_configuration(_decode(c_config.project_id), sampling_rate,+                              py_labels, tracing_enabled, monitoring_enabled)+++def create_client_call_tracer_capsule(bytes method, bytes trace_id,+                                      bytes parent_span_id=b'') -> cpython.PyObject:+  cdef char* c_method = cpython.PyBytes_AsString(method)+  cdef char* c_trace_id = cpython.PyBytes_AsString(trace_id)+  cdef char* c_parent_span_id = cpython.PyBytes_AsString(parent_span_id)++  cdef void* call_tracer = CreateClientCallTracer(c_method, c_trace_id, c_parent_span_id)+  capsule = cpython.PyCapsule_New(call_tracer, CLIENT_CALL_TRACER, NULL)+  return capsule+++def create_server_call_tracer_factory_capsule() -> cpython.PyObject:+  cdef void* call_tracer_factory = CreateServerCallTracerFactory()++  capsule = cpython.PyCapsule_New(call_tracer_factory, SERVER_CALL_TRACER_FACTORY, NULL)+  return capsule+++def _c_label_to_labels(cLabels) -> Mapping[str, str]:+  py_labels = {}+  for label in cLabels:+    py_labels[_decode(label['key'])] = _decode(label['value'])+  return py_labels+++def _c_annotation_to_annotations(cAnnotations) -> List[Tuple[str, str]]:+  py_annotations = []+  for annotation in cAnnotations:+    py_annotations.append((_decode(annotation['time_stamp']),+                          _decode(annotation['description'])))+  return py_annotations+++def at_observability_exit() -> None:+  _shutdown_exporting_thread()+++cdef void _export_sensus_data():+  while True:+    with nogil:+      while not GLOBAL_SHUTDOWN_EXPORT_THREAD:+        # Wait for next batch of sensus data OR timeout at fixed interval.+        # TODO(xuanwn): Changed to a proper value.+        AwaitNextBatch(500)++        # Break only when buffer have data+        LockSensusDataBuffer()+        if not kSensusDataBuffer.empty():+          UnlockSensusDataBuffer()+          break+        else:+          UnlockSensusDataBuffer()++    if GLOBAL_SHUTDOWN_EXPORT_THREAD:+      # Flush remaining data before shutdown thread+      LockSensusDataBuffer()+      if not kSensusDataBuffer.empty():+        _flush_sensus_data()+      UnlockSensusDataBuffer()+      break # Break to shutdown exporting thead++    LockSensusDataBuffer()+    _flush_sensus_data()+    UnlockSensusDataBuffer()+++cdef void _flush_sensus_data():+  py_metrics_batch = []+  py_spans_batch = []+  while not kSensusDataBuffer.empty():+    cSensusData = kSensusDataBuffer.front()+    if cSensusData.type == kMetricData:+      py_labels = _c_label_to_labels(cSensusData.labels)+      py_metric = PyMetric(cSensusData.measurement_data, py_labels)+      py_metrics_batch.append(py_metric)+    else:+      py_span_labels = _c_label_to_labels(cSensusData.span_data.span_labels)+      py_span_annotations = _c_annotation_to_annotations(cSensusData.span_data.span_annotations)+      py_span = PySpan(cSensusData.span_data, py_span_labels, py_span_annotations)+      py_spans_batch.append(py_span)+    kSensusDataBuffer.pop()++  open_census.export_metric_batch(py_metrics_batch)+  open_census.export_span_batch(py_spans_batch)+++cdef void _shutdown_exporting_thread():+  with nogil:+    global GLOBAL_SHUTDOWN_EXPORT_THREAD+    GLOBAL_SHUTDOWN_EXPORT_THREAD = True",We should also signal the condition variable here so that the thread can finish up as soon as possible.,
1644595,gnossen,https://api.github.com/repos/grpc/grpc/pulls/32800,1161025563,2023-04-07T23:38:55Z,src/python/grpcio_observability/grpc_observability/_cyobservability.pyx,"@@ -0,0 +1,199 @@+# Copyright 2023 gRPC authors.+#+# Licensed under the Apache License, Version 2.0 (the ""License"");+# you may not use this file except in compliance with the License.+# You may obtain a copy of the License at+#+#     http://www.apache.org/licenses/LICENSE-2.0+#+# Unless required by applicable law or agreed to in writing, software+# distributed under the License is distributed on an ""AS IS"" BASIS,+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+# See the License for the specific language governing permissions and+# limitations under the License.++cimport cpython++import sys+import os+import logging+from threading import Thread+from typing import List, Tuple, Mapping++from grpc_observability import open_census+from grpc_observability import measures++cdef const char* CLIENT_CALL_TRACER = ""client_call_tracer""+cdef const char* SERVER_CALL_TRACER_FACTORY = ""server_call_tracer_factory""+cdef bint GLOBAL_SHUTDOWN_EXPORT_THREAD = False+cdef object global_export_thread++_LOGGER = logging.getLogger(__name__)++class PyMetric:+  def __init__(self, measurement, labels):+    self.name = measurement['name']+    self.labels = labels+    self.measure = METRICS_NAME_TO_MEASURE.get(self.name)+    if measurement['type'] == kMeasurementDouble:+      self.measure_double = True+      self.measure_value = measurement['value']['value_double']+    else:+      self.measure_double = False+      self.measure_value = measurement['value']['value_int']+++class PySpan:+  def __init__(self, span_data, span_labels, span_annotations):+      self.name = _decode(span_data['name'])+      self.start_time = _decode(span_data['start_time'])+      self.end_time = _decode(span_data['end_time'])+      self.trace_id = _decode(span_data['trace_id'])+      self.span_id = _decode(span_data['span_id'])+      self.parent_span_id = _decode(span_data['parent_span_id'])+      self.status = _decode(span_data['status'])+      self.span_labels = span_labels+      self.span_annotations = span_annotations+      self.should_sample = span_data['should_sample']+      self.child_span_count = span_data['child_span_count']+++def observability_init() -> None:+  _start_exporting_thread()+++def _start_exporting_thread() -> None:+  global global_export_thread+  global_export_thread = Thread(target=_export_sensus_data)+  global_export_thread.start()+++def read_gcp_observability_config() -> None:+  py_labels = {}+  sampling_rate = 0.0+  tracing_enabled = False+  monitoring_enabled = False++  cdef cGcpObservabilityConfig c_config = ReadObservabilityConfig()++  for label in c_config.labels:+    py_labels[_decode(label.key)] = _decode(label.value)++  if OpenCensusTracingEnabled():+    sampling_rate = c_config.cloud_trace.sampling_rate+    tracing_enabled = True+    os.environ['GRPC_OPEN_CENSUS_TRACING_ENABLED'] = 'True'+    # Save sampling rate to global sampler.+    ProbabilitySampler.Get().SetThreshold(sampling_rate)++  if OpenCensusStatsEnabled():+    monitoring_enabled = True+    os.environ['GRPC_OPEN_CENSUS_STATS_ENABLED'] = 'True'++  py_config = open_census.gcpObservabilityConfig.get()+  py_config.set_configuration(_decode(c_config.project_id), sampling_rate,+                              py_labels, tracing_enabled, monitoring_enabled)+++def create_client_call_tracer_capsule(bytes method, bytes trace_id,+                                      bytes parent_span_id=b'') -> cpython.PyObject:+  cdef char* c_method = cpython.PyBytes_AsString(method)+  cdef char* c_trace_id = cpython.PyBytes_AsString(trace_id)+  cdef char* c_parent_span_id = cpython.PyBytes_AsString(parent_span_id)++  cdef void* call_tracer = CreateClientCallTracer(c_method, c_trace_id, c_parent_span_id)+  capsule = cpython.PyCapsule_New(call_tracer, CLIENT_CALL_TRACER, NULL)+  return capsule+++def create_server_call_tracer_factory_capsule() -> cpython.PyObject:+  cdef void* call_tracer_factory = CreateServerCallTracerFactory()++  capsule = cpython.PyCapsule_New(call_tracer_factory, SERVER_CALL_TRACER_FACTORY, NULL)+  return capsule+++def _c_label_to_labels(cLabels) -> Mapping[str, str]:+  py_labels = {}+  for label in cLabels:+    py_labels[_decode(label['key'])] = _decode(label['value'])+  return py_labels+++def _c_annotation_to_annotations(cAnnotations) -> List[Tuple[str, str]]:+  py_annotations = []+  for annotation in cAnnotations:+    py_annotations.append((_decode(annotation['time_stamp']),+                          _decode(annotation['description'])))+  return py_annotations+++def at_observability_exit() -> None:+  _shutdown_exporting_thread()+++cdef void _export_sensus_data():+  while True:+    with nogil:+      while not GLOBAL_SHUTDOWN_EXPORT_THREAD:+        # Wait for next batch of sensus data OR timeout at fixed interval.+        # TODO(xuanwn): Changed to a proper value.+        AwaitNextBatch(500)",This thread does the following:- Acquire the lock to wait on the condition variable- Wakes up from waiting on the condition variable- Gives up the lock- Immediately attempts to reacquire the lockThis is somewhat hidden because the first lock happens within `AwaitNextBatch`.This results in a slight performance loss and it could also lead to starvation of the export thread (if the reacquisition of the lock takes a long time).I think it would make more sense (and be more performant) if we rename this function to `AwaitNextBatchLocked` to indicate that it must only be called when the lock is already held. Then move the call to `LockCensusDataBuffer` to the top of this loop.,
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32835,1161025607,2023-04-07T23:39:08Z,src/core/lib/service_config/service_config_call_data.h,"@@ -40,7 +39,29 @@ namespace grpc_core { /// easily access method and global parameters for the call. class ServiceConfigCallData {  public:-  using CallAttributes = std::map<UniqueTypeName, absl::string_view>;+  class Holder {+   public:+    virtual ~Holder() = default;+  };++  template <typename T>+  class UniversalHolder : public Holder {",I don't think we want to provide this universal holder.  We don't want to encourage adding arbitrary types here; we want any caller to have to think about the right way to allocate the data.,
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32835,1161025890,2023-04-07T23:40:28Z,src/core/lib/service_config/service_config_call_data.h,"@@ -40,7 +39,29 @@ namespace grpc_core { /// easily access method and global parameters for the call. class ServiceConfigCallData {  public:-  using CallAttributes = std::map<UniqueTypeName, absl::string_view>;+  class Holder {+   public:+    virtual ~Holder() = default;+  };++  template <typename T>+  class UniversalHolder : public Holder {+   public:+    explicit UniversalHolder(T value) : value_(std::move(value)) {}+    T value() { return value_; }++   private:+    T value_;+  };++  using CallAttributes = std::map<std::uintptr_t, std::unique_ptr<Holder>>;","We definitely do not want to use `unique_ptr<>` here.  The map should not take ownership of the attributes, because we will want to allocate them on the call arena, using something like [`arena->New<MyAttributeType>(...)`](https://github.com/grpc/grpc/blob/ffafac3ce8ea53cbceffb53063070be813edc31f/src/core/lib/resource_quota/arena.h#L171) or [`arena->ManagedNew<MyAttributeType>(...)`](https://github.com/grpc/grpc/blob/ffafac3ce8ea53cbceffb53063070be813edc31f/src/core/lib/resource_quota/arena.h#L179), depending on whether it needs destruction.",
1644595,gnossen,https://api.github.com/repos/grpc/grpc/pulls/32800,1161026473,2023-04-07T23:43:35Z,src/python/grpcio_observability/grpc_observability/_cyobservability.pyx,"@@ -0,0 +1,199 @@+# Copyright 2023 gRPC authors.+#+# Licensed under the Apache License, Version 2.0 (the ""License"");+# you may not use this file except in compliance with the License.+# You may obtain a copy of the License at+#+#     http://www.apache.org/licenses/LICENSE-2.0+#+# Unless required by applicable law or agreed to in writing, software+# distributed under the License is distributed on an ""AS IS"" BASIS,+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+# See the License for the specific language governing permissions and+# limitations under the License.++cimport cpython++import sys+import os+import logging+from threading import Thread+from typing import List, Tuple, Mapping++from grpc_observability import open_census+from grpc_observability import measures++cdef const char* CLIENT_CALL_TRACER = ""client_call_tracer""+cdef const char* SERVER_CALL_TRACER_FACTORY = ""server_call_tracer_factory""+cdef bint GLOBAL_SHUTDOWN_EXPORT_THREAD = False+cdef object global_export_thread++_LOGGER = logging.getLogger(__name__)++class PyMetric:+  def __init__(self, measurement, labels):+    self.name = measurement['name']+    self.labels = labels+    self.measure = METRICS_NAME_TO_MEASURE.get(self.name)+    if measurement['type'] == kMeasurementDouble:+      self.measure_double = True+      self.measure_value = measurement['value']['value_double']+    else:+      self.measure_double = False+      self.measure_value = measurement['value']['value_int']+++class PySpan:+  def __init__(self, span_data, span_labels, span_annotations):+      self.name = _decode(span_data['name'])+      self.start_time = _decode(span_data['start_time'])+      self.end_time = _decode(span_data['end_time'])+      self.trace_id = _decode(span_data['trace_id'])+      self.span_id = _decode(span_data['span_id'])+      self.parent_span_id = _decode(span_data['parent_span_id'])+      self.status = _decode(span_data['status'])+      self.span_labels = span_labels+      self.span_annotations = span_annotations+      self.should_sample = span_data['should_sample']+      self.child_span_count = span_data['child_span_count']+++def observability_init() -> None:+  _start_exporting_thread()+++def _start_exporting_thread() -> None:+  global global_export_thread+  global_export_thread = Thread(target=_export_sensus_data)+  global_export_thread.start()+++def read_gcp_observability_config() -> None:+  py_labels = {}+  sampling_rate = 0.0+  tracing_enabled = False+  monitoring_enabled = False++  cdef cGcpObservabilityConfig c_config = ReadObservabilityConfig()++  for label in c_config.labels:+    py_labels[_decode(label.key)] = _decode(label.value)++  if OpenCensusTracingEnabled():+    sampling_rate = c_config.cloud_trace.sampling_rate+    tracing_enabled = True+    os.environ['GRPC_OPEN_CENSUS_TRACING_ENABLED'] = 'True'+    # Save sampling rate to global sampler.+    ProbabilitySampler.Get().SetThreshold(sampling_rate)++  if OpenCensusStatsEnabled():+    monitoring_enabled = True+    os.environ['GRPC_OPEN_CENSUS_STATS_ENABLED'] = 'True'++  py_config = open_census.gcpObservabilityConfig.get()+  py_config.set_configuration(_decode(c_config.project_id), sampling_rate,+                              py_labels, tracing_enabled, monitoring_enabled)+++def create_client_call_tracer_capsule(bytes method, bytes trace_id,+                                      bytes parent_span_id=b'') -> cpython.PyObject:+  cdef char* c_method = cpython.PyBytes_AsString(method)+  cdef char* c_trace_id = cpython.PyBytes_AsString(trace_id)+  cdef char* c_parent_span_id = cpython.PyBytes_AsString(parent_span_id)++  cdef void* call_tracer = CreateClientCallTracer(c_method, c_trace_id, c_parent_span_id)+  capsule = cpython.PyCapsule_New(call_tracer, CLIENT_CALL_TRACER, NULL)+  return capsule+++def create_server_call_tracer_factory_capsule() -> cpython.PyObject:+  cdef void* call_tracer_factory = CreateServerCallTracerFactory()++  capsule = cpython.PyCapsule_New(call_tracer_factory, SERVER_CALL_TRACER_FACTORY, NULL)+  return capsule+++def _c_label_to_labels(cLabels) -> Mapping[str, str]:+  py_labels = {}+  for label in cLabels:+    py_labels[_decode(label['key'])] = _decode(label['value'])+  return py_labels+++def _c_annotation_to_annotations(cAnnotations) -> List[Tuple[str, str]]:+  py_annotations = []+  for annotation in cAnnotations:+    py_annotations.append((_decode(annotation['time_stamp']),+                          _decode(annotation['description'])))+  return py_annotations+++def at_observability_exit() -> None:+  _shutdown_exporting_thread()+++cdef void _export_sensus_data():+  while True:+    with nogil:+      while not GLOBAL_SHUTDOWN_EXPORT_THREAD:+        # Wait for next batch of sensus data OR timeout at fixed interval.+        # TODO(xuanwn): Changed to a proper value.+        AwaitNextBatch(500)++        # Break only when buffer have data+        LockSensusDataBuffer()+        if not kSensusDataBuffer.empty():+          UnlockSensusDataBuffer()+          break+        else:+          UnlockSensusDataBuffer()++    if GLOBAL_SHUTDOWN_EXPORT_THREAD:+      # Flush remaining data before shutdown thread+      LockSensusDataBuffer()+      if not kSensusDataBuffer.empty():","If you add this conditional logic to the body of `_flush_census_data` (that is, don't call any export functions if `kSensusDataBuffer` is empty -- making sure that you don't hold the GIL while making that check), then you can unify this case with the case where we're not shutting down. so that the logic looks like this:```cythonLockCensusDataBuffer()_flush_census_data_locked()UnlockCensusDataBuffer()if GLOBAL_SHUTDOWN_EXPORT_THREAD:  break```",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32835,1161029163,2023-04-07T23:56:41Z,src/core/ext/filters/client_channel/resolver/xds/xds_resolver.cc,"@@ -731,13 +732,16 @@ XdsResolver::XdsConfigSelector::GetCallConfig(GetCallConfigArgs args) {         method_config->GetMethodParsedConfigVector(grpc_empty_slice());     call_config.service_config = std::move(method_config);   }-  call_config.call_attributes[XdsClusterAttributeTypeName()] = it->first;+  ServiceConfigCallData::Pack(&call_config.call_attributes,","I think what we want here is something like this:```// Put this declaration in a header file, so it can be accessed by the LB policy that uses this attribute.class XdsClusterNameAttribute : public ServiceConfigCallData::AttributeInterface { public:  explicit XdsClusterNameAttribute(absl::string_view cluster_name)      : cluster_name_(cluster_name) {}  static UniqueTypeName Type() {    static UniqueTypeName::Factory kFactory(""xds_cluster_name"");    return kFactory.Create();  }  UniqueTypeName type() const override { return Type(); }  absl::string_view cluster_name() const { return cluster_name_; } private:  absl::string_view cluster_name_;};// Add to call attributes.call_config.call_attributes[XdsClusterNameAttribute::Type()] =    args.arena->New<XdsClusterNameAttribute>(it->first);// Get from call attributes in the LB policy.auto* cluster_name =    static_cast<XdsClusterNameAttribute*>(        call_state->GetCallAttribute(XdsClusterNameAttribute::Type()));```The request hash attribute can be similar.",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/32825,1161113038,2023-04-08T13:34:05Z,src/core/ext/transport/chttp2/transport/context_list.h,"@@ -32,18 +36,59 @@ namespace grpc_core { class ContextList {","So a few things:- the code you submit usually lasts longer than you'd like- there's always another urgent customer- added complexity tends to breed more complexityTaken together, if there's a really quick change to wipe out an entire module I think we should take that... It doesn't significantly delay things now, and it speeds us up on the next thing.",
4181124,yashykt,https://api.github.com/repos/grpc/grpc/pulls/32556,1161419490,2023-04-10T04:19:06Z,src/core/lib/iomgr/exec_ctx.cc,"@@ -106,27 +106,18 @@ void ExecCtx::Run(const DebugLocation& location, grpc_closure* closure, }  void ExecCtx::RunList(const DebugLocation& location, grpc_closure_list* list) {-  (void)location;-  grpc_closure* c = list->head;-  while (c != nullptr) {-    grpc_closure* next = c->next_data.next;-#ifndef NDEBUG-    if (c->scheduled) {-      Crash(absl::StrFormat(-          ""Closure already scheduled. (closure: %p, created: [%s:%d], ""-          ""previously scheduled at: [%s: %d], newly scheduled at [%s:%d]"",-          c, c->file_created, c->line_created, c->file_initiated,-          c->line_initiated, location.file(), location.line()));+  grpc_closure_list* destlist = grpc_core::ExecCtx::Get()->closure_list();++  if (list->head != nullptr) {+    if (destlist->head == nullptr) {+      destlist->head = list->head;+      destlist->tail = list->tail;+    } else {+      destlist->tail->next_data.next = list->head;+      destlist->tail = list->tail;     }-    c->scheduled = true;",I think the approach probably works but you you are no longer setting `scheduled` any more,
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/32556,1161795471,2023-04-10T14:58:52Z,src/core/lib/iomgr/exec_ctx.cc,"@@ -106,27 +106,18 @@ void ExecCtx::Run(const DebugLocation& location, grpc_closure* closure, }  void ExecCtx::RunList(const DebugLocation& location, grpc_closure_list* list) {-  (void)location;-  grpc_closure* c = list->head;-  while (c != nullptr) {-    grpc_closure* next = c->next_data.next;-#ifndef NDEBUG-    if (c->scheduled) {-      Crash(absl::StrFormat(-          ""Closure already scheduled. (closure: %p, created: [%s:%d], ""-          ""previously scheduled at: [%s: %d], newly scheduled at [%s:%d]"",-          c, c->file_created, c->line_created, c->file_initiated,-          c->line_initiated, location.file(), location.line()));+  grpc_closure_list* destlist = grpc_core::ExecCtx::Get()->closure_list();++  if (list->head != nullptr) {+    if (destlist->head == nullptr) {+      destlist->head = list->head;+      destlist->tail = list->tail;+    } else {+      destlist->tail->next_data.next = list->head;+      destlist->tail = list->tail;     }-    c->scheduled = true;","I'd prefer not to: we do need to be able to debug the codebase, and scrambling this data will hurt that.Are there some measurements that show this to be significantly superior?We're already talking a lot about how to eliminate ExecCtx completely, so unless we're talking full percentage points on a good representative benchmark, I'd hazard that there are other, better targets for now.",
5564114,Vignesh2208,https://api.github.com/repos/grpc/grpc/pulls/32825,1161991110,2023-04-10T18:58:28Z,src/core/ext/transport/chttp2/transport/context_list.h,"@@ -32,18 +36,59 @@ namespace grpc_core { class ContextList {",I updated it so that ContextList is now a typedef of std::vector<ContextListEntry>.This required moving the grpc_http2_set_write_timestamps_callback and grpc_http2_set_fn_get_copied_context callback registration and invocation logic into chttp2_transport.cc and src/core/ext/transport/chttp2/writing.cc files.I also removed the context_list_test.cc file because its no longer needed.The PR now requires a cherrypick.,
5564114,Vignesh2208,https://api.github.com/repos/grpc/grpc/pulls/32825,1161991563,2023-04-10T18:59:03Z,src/core/ext/transport/chttp2/transport/context_list.h,"@@ -32,18 +36,59 @@ namespace grpc_core { class ContextList {  public:   // Creates a new element with \a context as the value and appends it to the-  // list.-  static void Append(ContextList** head, grpc_chttp2_stream* s);+  // list. Each RPC/stream is associated with a unique \a context. This method+  // is invoked when a chunk of data stored in an outgoing buffer is going to be+  // sent over the wire. A data chunk being written over the wire is multiplexed+  // with bytes from multiple RPCs. If one such RPC is traced, we store the+  // following information about the traced RPC:+  // - byte_offset_in_stream: Number of bytes belonging to that traced RPC which+  // have been sent so far from the start of the RPC stream.+  // - relative_start_pos_in_chunk: Starting offset of the traced RPC within+  // the current chunk that is being sent.+  // - num_traced_bytes_in_chunk: Number of bytes belonging to the traced RPC+  // within the current chunk.+  void Append(void* context, size_t byte_offset_in_stream,+              int64_t relative_start_pos_in_chunk,+              int64_t num_traced_bytes_in_chunk);++  bool IsEmpty() { return context_list_entries_.empty(); } -  // Executes a function \a fn with each context in the list and \a ts. It also-  // frees up the entire list after this operation. It is intended as a callback-  // and hence does not take a ref on \a error+  // Interprets the passed arg as a pointer to ContextList type and executes the+  // function set using grpc_http2_set_write_timestamps_callback method with+  // each context in the list and \a ts. It also deletes/frees up the passed+  // ContextList after this operation. It is intended as a callback and hence+  // does not take a ref on \a error. The fn receives individual contexts in the+  // same order in which they were Appended.   static void Execute(void* arg, Timestamps* ts, grpc_error_handle error);",Its no longer relevant now in the latest commit since we are directly dealing with the std::vector type.,
5564114,Vignesh2208,https://api.github.com/repos/grpc/grpc/pulls/32825,1161991656,2023-04-10T18:59:09Z,src/core/ext/transport/chttp2/transport/context_list.h,"@@ -32,18 +36,59 @@ namespace grpc_core { class ContextList {  public:   // Creates a new element with \a context as the value and appends it to the-  // list.-  static void Append(ContextList** head, grpc_chttp2_stream* s);+  // list. Each RPC/stream is associated with a unique \a context. This method+  // is invoked when a chunk of data stored in an outgoing buffer is going to be+  // sent over the wire. A data chunk being written over the wire is multiplexed+  // with bytes from multiple RPCs. If one such RPC is traced, we store the+  // following information about the traced RPC:+  // - byte_offset_in_stream: Number of bytes belonging to that traced RPC which+  // have been sent so far from the start of the RPC stream.+  // - relative_start_pos_in_chunk: Starting offset of the traced RPC within+  // the current chunk that is being sent.+  // - num_traced_bytes_in_chunk: Number of bytes belonging to the traced RPC+  // within the current chunk.+  void Append(void* context, size_t byte_offset_in_stream,+              int64_t relative_start_pos_in_chunk,+              int64_t num_traced_bytes_in_chunk);++  bool IsEmpty() { return context_list_entries_.empty(); } -  // Executes a function \a fn with each context in the list and \a ts. It also-  // frees up the entire list after this operation. It is intended as a callback-  // and hence does not take a ref on \a error+  // Interprets the passed arg as a pointer to ContextList type and executes the+  // function set using grpc_http2_set_write_timestamps_callback method with+  // each context in the list and \a ts. It also deletes/frees up the passed+  // ContextList after this operation. It is intended as a callback and hence+  // does not take a ref on \a error. The fn receives individual contexts in the+  // same order in which they were Appended.   static void Execute(void* arg, Timestamps* ts, grpc_error_handle error); +  // Executes the passed function \a cb with each context in the list. The+  // arguments provided to cb include the trace_context_, byte_offset_,+  // traced_bytes_relative_start_pos_ and num_traced_bytes_ for each context in+  // the context list. It also deletes/frees up the ContextList after this+  // operation. The cb receives individual contexts in the same order in which+  // they were Appended.+  static void ForEachExecuteCallback(",Its no longer relevant now in the latest commit since we are directly dealing with the std::vector type.,
5564114,Vignesh2208,https://api.github.com/repos/grpc/grpc/pulls/32825,1161991765,2023-04-10T18:59:16Z,src/core/ext/transport/chttp2/transport/context_list.h,"@@ -32,18 +36,59 @@ namespace grpc_core { class ContextList {  public:   // Creates a new element with \a context as the value and appends it to the-  // list.-  static void Append(ContextList** head, grpc_chttp2_stream* s);+  // list. Each RPC/stream is associated with a unique \a context. This method+  // is invoked when a chunk of data stored in an outgoing buffer is going to be+  // sent over the wire. A data chunk being written over the wire is multiplexed+  // with bytes from multiple RPCs. If one such RPC is traced, we store the+  // following information about the traced RPC:+  // - byte_offset_in_stream: Number of bytes belonging to that traced RPC which+  // have been sent so far from the start of the RPC stream.+  // - relative_start_pos_in_chunk: Starting offset of the traced RPC within+  // the current chunk that is being sent.+  // - num_traced_bytes_in_chunk: Number of bytes belonging to the traced RPC+  // within the current chunk.+  void Append(void* context, size_t byte_offset_in_stream,+              int64_t relative_start_pos_in_chunk,+              int64_t num_traced_bytes_in_chunk);++  bool IsEmpty() { return context_list_entries_.empty(); } -  // Executes a function \a fn with each context in the list and \a ts. It also-  // frees up the entire list after this operation. It is intended as a callback-  // and hence does not take a ref on \a error+  // Interprets the passed arg as a pointer to ContextList type and executes the+  // function set using grpc_http2_set_write_timestamps_callback method with+  // each context in the list and \a ts. It also deletes/frees up the passed+  // ContextList after this operation. It is intended as a callback and hence+  // does not take a ref on \a error. The fn receives individual contexts in the+  // same order in which they were Appended.   static void Execute(void* arg, Timestamps* ts, grpc_error_handle error); +  // Executes the passed function \a cb with each context in the list. The+  // arguments provided to cb include the trace_context_, byte_offset_,+  // traced_bytes_relative_start_pos_ and num_traced_bytes_ for each context in+  // the context list. It also deletes/frees up the ContextList after this+  // operation. The cb receives individual contexts in the same order in which+  // they were Appended.+  static void ForEachExecuteCallback(+      ContextList* list,+      absl::FunctionRef<void(void*, size_t, int64_t, int64_t)> cb);++  // Use this function to create a new ContextList instead of creating it+  // manually.+  static ContextList* MakeNewContextList() { return new ContextList; }",Its no longer relevant now in the latest commit since we are directly dealing with the std::vector type.,
85715732,yousukseung,https://api.github.com/repos/grpc/grpc/pulls/32825,1162095183,2023-04-10T21:16:05Z,src/core/ext/transport/chttp2/transport/context_list.h,"@@ -32,18 +36,59 @@ namespace grpc_core { class ContextList {","I think it's better to keep ContextList as a thin wrapper class instead of exposing the vector directly.Both Append() and Execute() are non-trivial and the underlying vector is only supposed to be updated in specific ways, so I think they should remain in one place and hidden. I assume this simply requires moving a few lines of code back.",X
5564114,Vignesh2208,https://api.github.com/repos/grpc/grpc/pulls/32825,1162109004,2023-04-10T21:37:23Z,src/core/ext/transport/chttp2/transport/context_list.h,"@@ -32,18 +36,59 @@ namespace grpc_core { class ContextList {","The pre-existing APIs seem a bit non intuitive. I unrolled the Append() logic directly into the chttp2/writing.cc  file because its the only place its used. By dealing with the vector directly, other internal EventEngine implementations can directly iterate over the ContextListEntries instead of exposing another API to the wrapper ContextList class to iterate and process them.@ctiller do you agree ? ",
85715732,yousukseung,https://api.github.com/repos/grpc/grpc/pulls/32825,1162130141,2023-04-10T22:14:51Z,src/core/ext/transport/chttp2/transport/context_list.h,"@@ -32,18 +36,59 @@ namespace grpc_core { class ContextList {",(edited after checking other replies) I'd suggest to make ContextListEntry a class as it has invariant enforced with a private default constructor.. With this I think we have the right constructor as Craig suggested and only the right one.,
7221003,rockspore,https://api.github.com/repos/grpc/grpc/pulls/32750,1162132741,2023-04-10T22:19:42Z,src/core/lib/security/audit_logging/grpc_audit_logging.h,"@@ -0,0 +1,95 @@+//+//+// Copyright 2023 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+//+//++#ifndef GRPC_SRC_CORE_LIB_SECURITY_AUDIT_LOGGING_GRPC_AUDIT_LOGGING_H+#define GRPC_SRC_CORE_LIB_SECURITY_AUDIT_LOGGING_GRPC_AUDIT_LOGGING_H++#include <grpc/support/port_platform.h>++#include <memory>+#include <string>++#include ""absl/status/statusor.h""+#include ""absl/strings/string_view.h""++#include ""src/core/lib/json/json.h""++namespace grpc_core {+namespace experimental {++// The base struct for audit context.+class AuditContext {+ public:+  AuditContext(absl::string_view rpc_method, absl::string_view principal,+               absl::string_view policy_name, absl::string_view matched_rule,+               bool authorized)+      : rpc_method_(rpc_method),+        principal_(principal),+        policy_name_(policy_name),+        matched_rule_(matched_rule),+        authorized_(authorized) {}++  absl::string_view rpc_method() const { return rpc_method_; }",We will guarantee it outlives the `Log()` invocation it is given to. Users will have to make copies if they need the info for longer (e.g. invoking some async processes inside `Log()`),
1644595,gnossen,https://api.github.com/repos/grpc/grpc/pulls/32606,1163128189,2023-04-11T17:27:10Z,test/distrib/bazel/python/WORKSPACE,"@@ -20,3 +20,20 @@ local_repository(     name = ""some_other_repo"",     path = ""../python_second_test_repo"", )++load(""@upb//bazel:system_python.bzl"", ""system_python"")++system_python(+    name = ""system_python"",+    minimum_python_version = ""3.7"",+)++load(""@system_python//:pip.bzl"", ""pip_parse"")++pip_parse(",Are these dependencies actually necessary? I don't see why they should be. This looks like it's just pulling in numpy as a test dependency. This is also a breaking change to our downstream Python Bazel build consumers.,
5564114,Vignesh2208,https://api.github.com/repos/grpc/grpc/pulls/32860,1166111010,2023-04-13T23:05:35Z,src/core/ext/transport/chttp2/transport/hpack_encoder.h,"@@ -46,6 +45,269 @@  namespace grpc_core { +// Forward decl for encoder+class HPackCompressor;++namespace hpack_encoder_detail {++class Encoder {+ public:+  Encoder(HPackCompressor* compressor, bool use_true_binary_metadata,+          SliceBuffer& output);++  void Encode(const Slice& key, const Slice& value);+  template <typename MetadataTrait>+  void Encode(MetadataTrait, const typename MetadataTrait::ValueType& value);++  void AdvertiseTableSizeChange();+  void EmitIndexed(uint32_t index);+  void EmitLitHdrWithNonBinaryStringKeyIncIdx(Slice key_slice,+                                              Slice value_slice);+  void EmitLitHdrWithBinaryStringKeyIncIdx(Slice key_slice, Slice value_slice);+  void EmitLitHdrWithBinaryStringKeyNotIdx(Slice key_slice, Slice value_slice);+  void EmitLitHdrWithBinaryStringKeyNotIdx(uint32_t key_index,+                                           Slice value_slice);+  void EmitLitHdrWithNonBinaryStringKeyNotIdx(Slice key_slice,+                                              Slice value_slice);++  void EncodeAlwaysIndexed(uint32_t* index, absl::string_view key, Slice value,+                           size_t transport_length);+  void EncodeIndexedKeyWithBinaryValue(uint32_t* index, absl::string_view key,+                                       Slice value);++  void EncodeRepeatingSliceValue(const absl::string_view& key,+                                 const Slice& slice, uint32_t* index,+                                 size_t max_compression_size);++  HPackEncoderTable& hpack_table();++ private:+  const bool use_true_binary_metadata_;+  HPackCompressor* const compressor_;+  SliceBuffer& output_;+};++// Compressor is partially specialized on CompressionTraits, but leaves+// MetadataTrait as variable.+// Via MetadataMap::StatefulCompressor it builds compression state for+// HPackCompressor.+// Each trait compressor gets to have some persistent state across the channel+// (declared as Compressor member variables).+// The compressors expose a single method:+// void EncodeWith(MetadataTrait, const MetadataTrait::ValueType, Encoder*);+// This method figures out how to encode the value, and then delegates to+// Encoder to perform the encoding.+template <typename MetadataTrait, typename CompressonTraits>+class Compressor;++// No compression encoder: just emit the key and value as literals.+template <typename MetadataTrait>+class Compressor<MetadataTrait, NoCompressionCompressor> {+ public:+  void EncodeWith(MetadataTrait, const typename MetadataTrait::ValueType& value,+                  Encoder* encoder) {+    const Slice& slice = MetadataValueAsSlice<MetadataTrait>(value);+    if (absl::EndsWith(MetadataTrait::key(), ""-bin"")) {+      encoder->EmitLitHdrWithBinaryStringKeyNotIdx(+          Slice::FromStaticString(MetadataTrait::key()), slice.Ref());+    } else {+      encoder->EmitLitHdrWithNonBinaryStringKeyNotIdx(+          Slice::FromStaticString(MetadataTrait::key()), slice.Ref());+    }+  }+};++// Frequent key with no value compression encoder+template <typename MetadataTrait>+class Compressor<MetadataTrait, FrequentKeyWithNoValueCompressionCompressor> {+ public:+  void EncodeWith(MetadataTrait, const typename MetadataTrait::ValueType& value,+                  Encoder* encoder) {+    const Slice& slice = MetadataValueAsSlice<MetadataTrait>(value);+    encoder->EncodeRepeatingSliceValue(MetadataTrait::key(), slice,+                                       &some_sent_value_,+                                       HPackEncoderTable::MaxEntrySize());+  }++ private:+  // Some previously sent value with this tag.+  uint32_t some_sent_value_ = 0;+};++// Helper to determine if two objects have the same identity.+// Equivalent here => equality, but equality does not imply equivalency.+// For example, two slices with the same contents are equal, but not+// equivalent.+// Used as a much faster check for equality than the full equality check,+// since many metadatum that are stable have the same root object in metadata+// maps.+template <typename T>+static bool IsEquivalent(T a, T b) {+  return a == b;+}++template <typename T>+static bool IsEquivalent(const Slice& a, const Slice& b) {+  return a.is_equivalent(b);+}++template <typename MetadataTrait>+class Compressor<MetadataTrait, StableValueCompressor> {+ public:+  void EncodeWith(MetadataTrait, const typename MetadataTrait::ValueType& value,+                  Encoder* encoder) {+    auto& table = encoder->hpack_table();+    if (previously_sent_value_ == value &&+        table.ConvertableToDynamicIndex(previously_sent_index_)) {+      encoder->EmitIndexed(table.DynamicIndex(previously_sent_index_));+      return;+    }+    auto key = MetadataTrait::key();+    const Slice& value_slice = MetadataValueAsSlice<MetadataTrait>(value);+    if (hpack_constants::SizeForEntry(key.size(), value_slice.size()) >+        HPackEncoderTable::MaxEntrySize()) {+      encoder->EmitLitHdrWithNonBinaryStringKeyNotIdx(+          Slice::FromStaticString(key), value_slice.Ref());+      return;+    }+    encoder->EncodeAlwaysIndexed(+        &previously_sent_index_, key, value_slice.Ref(),+        hpack_constants::SizeForEntry(key.size(), value_slice.size()));+  }++ private:+  // Previously sent value+  typename MetadataTrait::ValueType previously_sent_value_{};+  // And its index in the table+  uint32_t previously_sent_index_ = 0;+};++template <typename MetadataTrait, typename MetadataTrait::ValueType known_value>+class Compressor<+    MetadataTrait,+    KnownValueCompressor<typename MetadataTrait::ValueType, known_value>> {+ public:+  void EncodeWith(MetadataTrait, const typename MetadataTrait::ValueType& value,+                  Encoder* encoder) {+    if (value != known_value) {+      gpr_log(GPR_ERROR, ""%s"",+              absl::StrCat(""Not encoding bad "", MetadataTrait::key(), "" header"")+                  .c_str());+      return;+    }+    encoder->EncodeAlwaysIndexed(+        &previously_sent_index_, MetadataTrait::key(),+        Slice(MetadataTrait::Encode(known_value)),",Maybe we could cache the encoded value instead of calling MetadataTrait::Encode(..) twice here ?,
5564114,Vignesh2208,https://api.github.com/repos/grpc/grpc/pulls/32860,1166120628,2023-04-13T23:22:45Z,src/core/ext/transport/chttp2/transport/hpack_encoder.h,"@@ -46,6 +45,269 @@  namespace grpc_core { +// Forward decl for encoder+class HPackCompressor;++namespace hpack_encoder_detail {++class Encoder {+ public:+  Encoder(HPackCompressor* compressor, bool use_true_binary_metadata,+          SliceBuffer& output);++  void Encode(const Slice& key, const Slice& value);+  template <typename MetadataTrait>+  void Encode(MetadataTrait, const typename MetadataTrait::ValueType& value);++  void AdvertiseTableSizeChange();+  void EmitIndexed(uint32_t index);+  void EmitLitHdrWithNonBinaryStringKeyIncIdx(Slice key_slice,+                                              Slice value_slice);+  void EmitLitHdrWithBinaryStringKeyIncIdx(Slice key_slice, Slice value_slice);+  void EmitLitHdrWithBinaryStringKeyNotIdx(Slice key_slice, Slice value_slice);+  void EmitLitHdrWithBinaryStringKeyNotIdx(uint32_t key_index,+                                           Slice value_slice);+  void EmitLitHdrWithNonBinaryStringKeyNotIdx(Slice key_slice,+                                              Slice value_slice);++  void EncodeAlwaysIndexed(uint32_t* index, absl::string_view key, Slice value,+                           size_t transport_length);+  void EncodeIndexedKeyWithBinaryValue(uint32_t* index, absl::string_view key,+                                       Slice value);++  void EncodeRepeatingSliceValue(const absl::string_view& key,+                                 const Slice& slice, uint32_t* index,+                                 size_t max_compression_size);++  HPackEncoderTable& hpack_table();++ private:+  const bool use_true_binary_metadata_;+  HPackCompressor* const compressor_;+  SliceBuffer& output_;+};++// Compressor is partially specialized on CompressionTraits, but leaves+// MetadataTrait as variable.+// Via MetadataMap::StatefulCompressor it builds compression state for+// HPackCompressor.+// Each trait compressor gets to have some persistent state across the channel+// (declared as Compressor member variables).+// The compressors expose a single method:+// void EncodeWith(MetadataTrait, const MetadataTrait::ValueType, Encoder*);+// This method figures out how to encode the value, and then delegates to+// Encoder to perform the encoding.+template <typename MetadataTrait, typename CompressonTraits>+class Compressor;++// No compression encoder: just emit the key and value as literals.+template <typename MetadataTrait>+class Compressor<MetadataTrait, NoCompressionCompressor> {+ public:+  void EncodeWith(MetadataTrait, const typename MetadataTrait::ValueType& value,+                  Encoder* encoder) {+    const Slice& slice = MetadataValueAsSlice<MetadataTrait>(value);+    if (absl::EndsWith(MetadataTrait::key(), ""-bin"")) {+      encoder->EmitLitHdrWithBinaryStringKeyNotIdx(+          Slice::FromStaticString(MetadataTrait::key()), slice.Ref());+    } else {+      encoder->EmitLitHdrWithNonBinaryStringKeyNotIdx(+          Slice::FromStaticString(MetadataTrait::key()), slice.Ref());+    }+  }+};++// Frequent key with no value compression encoder+template <typename MetadataTrait>+class Compressor<MetadataTrait, FrequentKeyWithNoValueCompressionCompressor> {+ public:+  void EncodeWith(MetadataTrait, const typename MetadataTrait::ValueType& value,+                  Encoder* encoder) {+    const Slice& slice = MetadataValueAsSlice<MetadataTrait>(value);+    encoder->EncodeRepeatingSliceValue(MetadataTrait::key(), slice,+                                       &some_sent_value_,+                                       HPackEncoderTable::MaxEntrySize());+  }++ private:+  // Some previously sent value with this tag.+  uint32_t some_sent_value_ = 0;+};++// Helper to determine if two objects have the same identity.+// Equivalent here => equality, but equality does not imply equivalency.+// For example, two slices with the same contents are equal, but not+// equivalent.+// Used as a much faster check for equality than the full equality check,+// since many metadatum that are stable have the same root object in metadata+// maps.+template <typename T>+static bool IsEquivalent(T a, T b) {+  return a == b;+}++template <typename T>+static bool IsEquivalent(const Slice& a, const Slice& b) {+  return a.is_equivalent(b);+}++template <typename MetadataTrait>+class Compressor<MetadataTrait, StableValueCompressor> {+ public:+  void EncodeWith(MetadataTrait, const typename MetadataTrait::ValueType& value,+                  Encoder* encoder) {+    auto& table = encoder->hpack_table();+    if (previously_sent_value_ == value &&+        table.ConvertableToDynamicIndex(previously_sent_index_)) {+      encoder->EmitIndexed(table.DynamicIndex(previously_sent_index_));+      return;+    }","Should there be an else here which sets ```previously_sent_value_ = value; previously_sent_index = 0;``` The old HPackCompressor::Encoder::Encode(UserAgentMetadata, ....) code is doing something like this.",
5564114,Vignesh2208,https://api.github.com/repos/grpc/grpc/pulls/32860,1166124146,2023-04-13T23:30:51Z,src/core/lib/transport/metadata_batch.h,"@@ -233,54 +286,63 @@ struct GrpcAcceptEncodingMetadata { // user-agent metadata trait. struct UserAgentMetadata : public SimpleSliceBasedMetadata {   static constexpr bool kRepeatable = false;+  using CompressionTraits = StableValueCompressor;   static absl::string_view key() { return ""user-agent""; } };  // grpc-message metadata trait. struct GrpcMessageMetadata : public SimpleSliceBasedMetadata {   static constexpr bool kRepeatable = false;+  using CompressionTraits = NoCompressionCompressor;   static absl::string_view key() { return ""grpc-message""; } };  // host metadata trait. struct HostMetadata : public SimpleSliceBasedMetadata {   static constexpr bool kRepeatable = false;+  using CompressionTraits = StableValueCompressor;",Is HostMetadata expected to be StableValue type ? I'm not finding a similar behavior in the old code. Should it be NoCompressionCompressor type ?,
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/32748,1166456818,2023-04-14T08:06:43Z,tools/remote_build/linux.bazelrc,"@@ -54,6 +54,10 @@ build:msan --test_timeout=60,900,1800,3600 build:msan --test_tag_filters=-no_linux,-nomsan,-json_run_localhost build:msan --cxxopt=--stdlib=libc++ build:msan --linkopt=--stdlib=libc+++# use MSAN-instrumented version of libc+++# TODO(jtattermusch): include the modified LD_LIBRARY_PATH in an msan-specific+# toolchain configuration, instead of needing to explicitly set it here.+build:msan --action_env=LD_LIBRARY_PATH=/usr/local/libcxx-msan/lib/x86_64-unknown-linux-gnu","qq: until now, we haven't been setting any special flavor of libc++ for TSAN. Since the rbe_ubuntu2004 image now has also the TSAN-instrumented version of libstdc++ installed, it might be a good idea to use it (in a similar way we're setting MSAN-instrumented version of libstdc++ here). I'm leaving that as a possible followup (I don't want to change more stuff than necessary in this PR).",
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/32734,1166767003,2023-04-14T12:19:18Z,test/csharp/codegen/BUILD,"@@ -0,0 +1,36 @@+# Copyright 2017 gRPC authors.+#+# Licensed under the Apache License, Version 2.0 (the ""License"");+# you may not use this file except in compliance with the License.+# You may obtain a copy of the License at+#+#     http://www.apache.org/licenses/LICENSE-2.0+#+# Unless required by applicable law or agreed to in writing, software+# distributed under the License is distributed on an ""AS IS"" BASIS,+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+# See the License for the specific language governing permissions and+# limitations under the License.++load(""//bazel:grpc_build_system.bzl"", ""grpc_sh_test"")++licenses([""notice""])++grpc_sh_test(+    name = ""csharp_codegen_simple_test"",+    srcs = [""csharp_codegen_simple_test.sh""],+    data = [+        ""simple/expected/HelloworldGrpc.cs"",+        ""simple/proto/helloworld.proto"",+        ""//src/compiler:grpc_csharp_plugin"",+        ""@com_google_protobuf//:protoc"",+    ],+    tags = [+        ""no_windows"",+        ""noasan"",","FTR the asan, tsan, msan and ubsan issues can also be resolved by adding `//test/core/util:grpc_suppressions` as a dependency I think.",
16962414,gtcooke94,https://api.github.com/repos/grpc/grpc/pulls/32750,1169281799,2023-04-17T21:26:55Z,include/grpc/grpc_audit_logging.h,"@@ -0,0 +1,95 @@+//+//+// Copyright 2023 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+//+//++#ifndef GRPC_GRPC_AUDIT_LOGGING_H+#define GRPC_GRPC_AUDIT_LOGGING_H++#include <grpc/support/port_platform.h>++#include <memory>+#include <string>++#include ""absl/status/statusor.h""+#include ""absl/strings/string_view.h""++#include ""src/core/lib/json/json.h""++namespace grpc_core {+namespace experimental {++// The base struct for audit context.",nit: struct -> class,
16962414,gtcooke94,https://api.github.com/repos/grpc/grpc/pulls/32828,1171635592,2023-04-19T17:14:16Z,src/proto/grpc/testing/xds/v3/rbac.proto,"@@ -97,6 +97,45 @@ message RBAC {     LOG = 2;   } +  message AuditLoggingOptions {",Why do we have to duplicate this proto? Is there an issue taking the dependency on the proto from envoy?,
287917,eugeneo,https://api.github.com/repos/grpc/grpc/pulls/32709,1171674797,2023-04-19T17:46:14Z,src/core/ext/filters/client_channel/lb_policy/pick_first/pick_first.cc,"@@ -130,6 +131,10 @@ class PickFirst : public LoadBalancingPolicy {     void set_attempting_index(size_t index) { attempting_index_ = index; }     private:+    std::shared_ptr<WorkSerializer> work_serializer() const override {",Can this be moved to a base class?,X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32709,1171754106,2023-04-19T19:10:40Z,src/core/ext/filters/client_channel/lb_policy/pick_first/pick_first.cc,"@@ -130,6 +131,10 @@ class PickFirst : public LoadBalancingPolicy {     void set_attempting_index(size_t index) { attempting_index_ = index; }     private:+    std::shared_ptr<WorkSerializer> work_serializer() const override {","Unfortunately, it can't.  The problem is that `LoadBalancingPolicy::work_serializer()` is protected, so it can be accessed only in subclasses.  And the base `SubchannelList` class is not nested inside of a subclass of `LoadBalancingPolicy`, but the individual subclasses of `SubchannelList` are nested inside of subclasses of `LoadBalancingPolicy`, so this is where it needs to be.I agree that this is ugly.  However, I plan to clean this up as part of the changes I'm going to be making for the dualstack design.  Once I make pick_first the universal leaf policy, it will be the only policy actually using `SubchannelList`, and at that point I will move the code directly into pick_first so that it no longer needs to be a separate base class.",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/32825,1171785281,2023-04-19T19:46:22Z,src/core/ext/transport/chttp2/transport/context_list.h,"@@ -22,33 +22,47 @@ #include <grpc/support/port_platform.h>",Nit: this file should now be called context_list_entry.h,
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32852,1171879083,2023-04-19T21:37:33Z,src/core/BUILD,"@@ -5537,12 +5554,12 @@ grpc_cc_library(         ""slice"",         ""slice_buffer"",         ""time"",-        ""//:channel_stack_builder"",         ""//:config"",         ""//:gpr"",         ""//:gpr_platform"",         ""//:grpc_base"",         ""//:grpc_client_channel"",+        ""//:grpc_opencensus_plugin"",","I'll defer to @yashykt on this, but this dependency seems undesirable.  I believe the plan is to use this logging filter internally as well, and I think that requires not depending on OpenCensus.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32852,1171916302,2023-04-19T22:38:55Z,src/core/ext/filters/deadline/deadline_filter.cc,"@@ -384,27 +381,15 @@ const grpc_channel_filter grpc_server_deadline_filter = {     ""deadline"", }; -bool grpc_deadline_checking_enabled(",Please also remove the declaration of this function from deadline_filter.h.,
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32852,1171923597,2023-04-19T22:51:44Z,src/core/ext/filters/message_size/message_size_filter.cc,"@@ -247,45 +246,33 @@ ArenaPromise<ServerMetadataHandle> ServerMessageSizeFilter::MakeCallPromise( }  namespace {-// Used for GRPC_CLIENT_SUBCHANNEL-bool MaybeAddMessageSizeFilterToSubchannel(ChannelStackBuilder* builder) {-  if (builder->channel_args().WantMinimalStack()) {-    return true;-  }-  builder->PrependFilter(&ClientMessageSizeFilter::kFilter);-  return true;-}- // Used for GRPC_CLIENT_DIRECT_CHANNEL and GRPC_SERVER_CHANNEL. Adds the // filter only if message size limits or service config is specified.-auto MaybeAddMessageSizeFilter(const grpc_channel_filter* filter) {-  return [filter](ChannelStackBuilder* builder) {-    auto channel_args = builder->channel_args();-    if (channel_args.WantMinimalStack()) {-      return true;-    }-    MessageSizeParsedConfig limits =-        MessageSizeParsedConfig::GetFromChannelArgs(channel_args);-    const bool enable =-        limits.max_send_size().has_value() ||-        limits.max_recv_size().has_value() ||-        channel_args.GetString(GRPC_ARG_SERVICE_CONFIG).has_value();-    if (enable) builder->PrependFilter(filter);-    return true;-  };+bool HasMessageSizeLimits(const ChannelArgs& channel_args) {+  MessageSizeParsedConfig limits =+      MessageSizeParsedConfig::GetFromChannelArgs(channel_args);+  return limits.max_send_size().has_value() ||+         limits.max_recv_size().has_value() ||+         channel_args.GetString(GRPC_ARG_SERVICE_CONFIG).has_value(); }  }  // namespace void RegisterMessageSizeFilter(CoreConfiguration::Builder* builder) {   MessageSizeParser::Register(builder);-  builder->channel_init()->RegisterStage(GRPC_CLIENT_SUBCHANNEL,-                                         GRPC_CHANNEL_INIT_BUILTIN_PRIORITY,-                                         MaybeAddMessageSizeFilterToSubchannel);-  builder->channel_init()->RegisterStage(-      GRPC_CLIENT_DIRECT_CHANNEL, GRPC_CHANNEL_INIT_BUILTIN_PRIORITY,-      MaybeAddMessageSizeFilter(&ClientMessageSizeFilter::kFilter));-  builder->channel_init()->RegisterStage(-      GRPC_SERVER_CHANNEL, GRPC_CHANNEL_INIT_BUILTIN_PRIORITY,-      MaybeAddMessageSizeFilter(&ServerMessageSizeFilter::kFilter));+  builder->channel_init()+      ->RegisterFilter(GRPC_CLIENT_SUBCHANNEL,+                       &ClientMessageSizeFilter::kFilter)+      .ExcludeFromMinimalStack();+  builder->channel_init()+      ->RegisterFilter(GRPC_CLIENT_DIRECT_CHANNEL,+                       &ClientMessageSizeFilter::kFilter)+      .ExcludeFromMinimalStack()+      .If(HasMessageSizeLimits)+      .Before({&grpc_client_deadline_filter});","Is there a specific reason this needs to be before the deadline filter, or is this just to try to maintain the order we had before this PR?  If there's no specific reason for it, how about adding a TODO that we should reevaluate the proper ordering of all filters from first principles in a separate PR.",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/32852,1172080593,2023-04-20T04:55:39Z,src/core/BUILD,"@@ -5537,12 +5554,12 @@ grpc_cc_library(         ""slice"",         ""slice_buffer"",         ""time"",-        ""//:channel_stack_builder"",         ""//:config"",         ""//:gpr"",         ""//:gpr_platform"",         ""//:grpc_base"",         ""//:grpc_client_channel"",+        ""//:grpc_opencensus_plugin"",","Yeah this was the problem I was talking about: right now tests (specifically logging test?) need an ordering between opencensus_plugin and logging - so one needs to depend on the other and both need to be registered. We could flip the dependency, or we could fix the tests to not require this.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32852,1172756178,2023-04-20T15:23:13Z,test/core/channel/channel_stack_builder_test.cc,"@@ -57,70 +53,57 @@ void CallDestroyFunc(grpc_call_element* /*elem*/,                      const grpc_call_final_info* /*final_info*/,                      grpc_closure* /*ignored*/) {} -bool g_replacement_fn_called = false;-bool g_original_fn_called = false;--void SetReplacementFnCalled(grpc_channel_stack*, grpc_channel_element*) {-  g_replacement_fn_called = true;-}--void SetOriginalFnCalled(grpc_channel_stack*, grpc_channel_element*) {-  g_original_fn_called = true;+const grpc_channel_filter* FilterNamed(const char* name) {+  static auto* filters =+      new std::map<absl::string_view, const grpc_channel_filter*>;+  auto it = filters->find(name);+  if (it != filters->end()) return it->second;+  return filters+      ->emplace(+          name,+          new grpc_channel_filter{+              grpc_call_next_op, nullptr, grpc_channel_next_op, 0, CallInitFunc,+              grpc_call_stack_ignore_set_pollset_or_pollset_set,+              CallDestroyFunc, 0, ChannelInitFunc,+              [](grpc_channel_stack*, grpc_channel_element*) {},+              ChannelDestroyFunc, grpc_channel_next_get_info, name})+      .first->second; } -TEST(ChannelStackBuilderTest, ReplaceFilter) {-  grpc_channel_credentials* creds = grpc_insecure_credentials_create();-  grpc_channel* channel =-      grpc_channel_create(""target name isn't used"", creds, nullptr);-  grpc_channel_credentials_release(creds);-  GPR_ASSERT(channel != nullptr);-  // Make sure the high priority filter has been created.-  GPR_ASSERT(g_replacement_fn_called);-  // ... and that the low priority one hasn't.-  GPR_ASSERT(!g_original_fn_called);-  grpc_channel_destroy(channel);-}--const grpc_channel_filter replacement_filter = {-    grpc_call_next_op,    nullptr,-    grpc_channel_next_op, 0,-    CallInitFunc,         grpc_call_stack_ignore_set_pollset_or_pollset_set,-    CallDestroyFunc,      0,-    ChannelInitFunc,      SetReplacementFnCalled,-    ChannelDestroyFunc,   grpc_channel_next_get_info,-    ""filter_name""};--const grpc_channel_filter original_filter = {-    grpc_call_next_op,    nullptr,-    grpc_channel_next_op, 0,-    CallInitFunc,         grpc_call_stack_ignore_set_pollset_or_pollset_set,-    CallDestroyFunc,      0,-    ChannelInitFunc,      SetOriginalFnCalled,-    ChannelDestroyFunc,   grpc_channel_next_get_info,-    ""filter_name""};--bool AddReplacementFilter(ChannelStackBuilder* builder) {-  // Get rid of any other version of the filter, as determined by having the-  // same name.-  auto* stk = builder->mutable_stack();-  stk->erase(std::remove_if(stk->begin(), stk->end(),-                            [](const grpc_channel_filter* entry) {-                              return strcmp(entry->name, ""filter_name"") == 0;-                            }),-             stk->end());-  builder->PrependFilter(&replacement_filter);-  return true;+TEST(ChannelStackBuilder, UnknownTarget) {+  ChannelStackBuilderImpl builder(""alpha-beta-gamma"", GRPC_CLIENT_CHANNEL,+                                  ChannelArgs());+  EXPECT_EQ(builder.target(), ""unknown""); } -bool AddOriginalFilter(ChannelStackBuilder* builder) {-  builder->PrependFilter(&original_filter);-  return true;+TEST(ChannelStackBuilder, CanPrepend) {","Do we still need the `PrependFilter()` method at all anymore?  It looks like `ChannelInit::CreateStack()` is only calling `AppendFilter()`, so probably `PrependFilter()` is now unused.",
5663878,yijiem,https://api.github.com/repos/grpc/grpc/pulls/32890,1172868250,2023-04-20T16:58:37Z,test/core/event_engine/fuzzing_event_engine/fuzzing_event_engine.h,"@@ -47,6 +50,9 @@ namespace grpc_event_engine { namespace experimental { +typedef std::vector<std::tuple<EventEngine::Duration, std::string>>",Also why not use std::pair? Are we anticipating to add more elements to the action?,
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32828,1172939893,2023-04-20T18:14:51Z,src/core/ext/xds/xds_audit_logger_registry.cc,"@@ -0,0 +1,100 @@+//+// Copyright 2023 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+//++#include <grpc/support/port_platform.h>++#include ""src/core/ext/xds/xds_audit_logger_registry.h""++#include <utility>++#include ""absl/strings/string_view.h""+#include ""absl/types/optional.h""+#include ""absl/types/variant.h""+#include ""envoy/config/core/v3/extension.upb.h""+#include ""envoy/config/rbac/v3/rbac.upb.h""++#include ""src/core/ext/xds/xds_common_types.h""+#include ""src/core/lib/gprpp/validation_errors.h""+#include ""src/core/lib/json/json.h""++namespace grpc_core {++namespace {++class StdoutLoggerConfigFactory : public XdsAuditLoggerRegistry::ConfigFactory {+ public:+  Json::Object ConvertXdsAuditLoggerConfig(+      const XdsResourceType::DecodeContext& /*context*/,+      absl::string_view /*configuration*/,+      ValidationErrors* /*errors*/) override {+    return Json::Object{{""stdout_logger"", Json::Object()}};+  }++  absl::string_view type() override { return Type(); }++  static absl::string_view Type() {+    return ""envoy.extensions.rbac.audit_loggers.stream.v3.StdoutAuditLog"";+  }+};++}  // namespace++XdsAuditLoggerRegistry::XdsAuditLoggerRegistry() {+  audit_logger_config_factories_.emplace(+      StdoutLoggerConfigFactory::Type(),+      std::make_unique<StdoutLoggerConfigFactory>());+}++Json XdsAuditLoggerRegistry::ConvertXdsAuditLoggerConfig(+    const XdsResourceType::DecodeContext& context,+    const envoy_config_rbac_v3_RBAC_AuditLoggingOptions_AuditLoggerConfig*+        logger_config,+    ValidationErrors* errors) const {+  const auto* typed_extension_config =+      envoy_config_rbac_v3_RBAC_AuditLoggingOptions_AuditLoggerConfig_audit_logger(+          logger_config);+  // It is okay if this is not present.","I think this should be an error.  It's fine if the `RBAC.audit_logging_options` field is unset (i.e., no audit logging config specified), but if audit logging config is specified, then each entry in the list needs to have the `audit_logger` field populated.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32828,1172951718,2023-04-20T18:28:23Z,src/core/ext/xds/xds_audit_logger_registry.h,"@@ -0,0 +1,65 @@+//+// Copyright 2023 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+//++#ifndef GRPC_SRC_CORE_EXT_XDS_XDS_AUDIT_LOGGER_REGISTRY_H+#define GRPC_SRC_CORE_EXT_XDS_XDS_AUDIT_LOGGER_REGISTRY_H++#include <grpc/support/port_platform.h>++#include <map>+#include <memory>++#include ""absl/strings/string_view.h""+#include ""envoy/config/rbac/v3/rbac.upb.h""++#include ""src/core/ext/xds/xds_resource_type.h""+#include ""src/core/lib/gprpp/validation_errors.h""+#include ""src/core/lib/json/json.h""++namespace grpc_core {++// A registry that maintains a set of converters that are able to map xDS+// RBAC audit logger configuration to gRPC's JSON format.+class XdsAuditLoggerRegistry {+ public:+  class ConfigFactory {+   public:+    virtual ~ConfigFactory() = default;+    virtual Json::Object ConvertXdsAuditLoggerConfig(+        const XdsResourceType::DecodeContext& context,+        absl::string_view configuration, ValidationErrors* errors) = 0;+    virtual absl::string_view type() = 0;+  };++  XdsAuditLoggerRegistry();++  Json ConvertXdsAuditLoggerConfig(","It looks like you're structuring this differently than the LB policy registry, but I think we should stick with the same pattern for consistency.  Instead of calling this method to convert each individual config entry and then using the gRPC registry to choose which logger to use, I think we should pass the entire list of loggers to this method and have it return the one to use.  That way, we're not checking which loggers exist more than once, and we don't have to process any more entries once we find the one we want to use.The API here should be:```Json::Array ConvertXdsAuditLoggerConfig(    const XdsResourceType::DecodeContext& context,    const envoy_config_rbac_v3_RBAC_AuditLoggingOptions* audit_logging_options,    ValidationErrors* errors) const;```",
5663878,yijiem,https://api.github.com/repos/grpc/grpc/pulls/32890,1172956117,2023-04-20T18:33:29Z,test/core/event_engine/fuzzing_event_engine/fuzzing_event_engine.cc,"@@ -534,5 +538,97 @@ FuzzingEventEngine::ListenerInfo::~ListenerInfo() {       }); } +void FuzzingEventEngine::MockEndpoint::Init(+    const MockEndpointActions& actions) {+  Time last_action_exec_time = g_fuzzing_event_engine->Now();+  for (auto action = actions.begin(); action != actions.end(); ++action) {+    Time curr_action_exec_time =+        std::get<Duration>(*action) + last_action_exec_time;+    if (actions_by_time_.empty() ||+        std::get<Time>(actions_by_time_.back()) != curr_action_exec_time) {+      actions_by_time_.emplace_back(curr_action_exec_time,+                                    std::get<std::string>(*action));+    } else {+      // Concatenate curr action with last action because the timestamps match+      auto new_action =+          absl::StrCat(std::get<std::string>(actions_by_time_.back()),+                       std::get<std::string>(*action));+      std::get<std::string>(actions_by_time_.back()) = new_action;+    }+    last_action_exec_time = curr_action_exec_time;+  }+}++bool FuzzingEventEngine::MockEndpoint::Read(+    absl::AnyInvocable<void(absl::Status)> on_read, SliceBuffer* buffer,+    const ReadArgs* /*args*/) {+  Duration delay = Duration::zero();+  buffer->Clear();+  if (!actions_by_time_.empty() &&+      g_fuzzing_event_engine->Now() <+          std::get<Time>(actions_by_time_.front())) {+    delay = std::get<Time>(actions_by_time_.front()) -+            g_fuzzing_event_engine->Now();+  }+  g_fuzzing_event_engine->RunAfter(delay, [on_readable = std::move(on_read),+                                           buffer, this]() mutable {+    auto tcp_annotate_error = [this](absl::Status src_error) {+      auto peer_string = ResolvedAddressToNormalizedString(peer_address_);++      grpc_core::StatusSetStr(&src_error,+                              grpc_core::StatusStrProperty::kTargetAddress,+                              peer_string.ok() ? *peer_string : """");+      grpc_core::StatusSetInt(&src_error, grpc_core::StatusIntProperty::kFd,+                              -1);+      grpc_core::StatusSetInt(&src_error,+                              grpc_core::StatusIntProperty::kRpcStatus,+                              GRPC_STATUS_UNAVAILABLE);+      return src_error;+    };+    // Treat the non existence of data available to read as an Endpoint+    // error.+    if (actions_by_time_.empty()) {+      on_readable(tcp_annotate_error(absl::InternalError(""Socket Closed"")));+    } else {+      // Present the first set of bytes as the data read at this time.+      do {+        buffer->Append(Slice::FromCopiedString(+            std::get<std::string>(actions_by_time_.front())));+        actions_by_time_.erase(actions_by_time_.begin());+      } while (!actions_by_time_.empty() &&+               g_fuzzing_event_engine->Now() >=+                   std::get<Time>(actions_by_time_.front()));","This seems to imply that `actions_by_time_` is a serial of actions sorted by timepoints (earlier one happens first). But the data structure doesn't guarantee that.Maybe a `std::map<Time, std::string> actions_by_time_;` could work? Then this part would become:```while (!actions_by_time_.empty() &&       actions_by_time_.begin()->first <= g_fuzzing_event_engine->Now()) {  buffer->Append(Slice::FromCopiedString(actions_by_time_.begin()->second));  actions_by_time_.erase(actions_by_time_.begin());}```",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32828,1172969065,2023-04-20T18:48:42Z,src/core/ext/xds/xds_http_rbac_filter.cc,"@@ -381,7 +384,30 @@ Json ParsePolicyToJson(const envoy_config_rbac_v3_Policy* policy,   return policy_json; } -Json ParseHttpRbacToJson(const envoy_extensions_filters_http_rbac_v3_RBAC* rbac,+Json ParseAuditLoggerConfigsToJson(+    const XdsResourceType::DecodeContext& context,+    const envoy_config_rbac_v3_RBAC_AuditLoggingOptions* audit_logging_options,+    ValidationErrors* errors) {+  Json::Array logger_configs_json;+  size_t size;+  const auto& registry =+      static_cast<const GrpcXdsBootstrap&>(context.client->bootstrap())+          .audit_logger_registry();+  const envoy_config_rbac_v3_RBAC_AuditLoggingOptions_AuditLoggerConfig* const*","As I mentioned above, we need to parse all of the logger configs at once rather than one at a time.  The logic here should look essentially the same as what we do for LB policies:https://github.com/grpc/grpc/blob/4cb69f4658aecda3ea6e0ef222db86e5edc9f629/src/core/ext/xds/xds_cluster.cc#L323",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32828,1172975149,2023-04-20T18:55:41Z,test/core/xds/xds_audit_logger_registry_test.cc,"@@ -0,0 +1,119 @@+//+//+// Copyright 2023 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+//+//++#include ""src/core/ext/xds/xds_audit_logger_registry.h""++#include <string>++#include <google/protobuf/any.pb.h>++#include ""absl/status/status.h""+#include ""absl/status/statusor.h""+#include ""envoy/config/rbac/v3/rbac.upb.h""+#include ""gtest/gtest.h""+#include ""upb/def.hpp""  // IWYU pragma: keep+#include ""upb/upb.hpp""++#include <grpc/grpc.h>++#include ""src/core/ext/xds/xds_bootstrap_grpc.h""+#include ""src/core/lib/json/json_writer.h""+#include ""src/proto/grpc/testing/xds/v3/extension.pb.h""+#include ""src/proto/grpc/testing/xds/v3/rbac.pb.h""+#include ""src/proto/grpc/testing/xds/v3/stream.pb.h""+#include ""test/core/util/test_config.h""++// IWYU pragma: no_include ""upb/reflection/def.hpp""++namespace grpc_core {+namespace testing {+namespace {++using AuditLoggerConfigProto =+    ::envoy::config::rbac::v3::RBAC::AuditLoggingOptions::AuditLoggerConfig;+using ::envoy::extensions::rbac::audit_loggers::stream::v3::StdoutAuditLog;++absl::StatusOr<std::string> ConvertAuditLoggerConfig(+    const AuditLoggerConfigProto& config) {+  std::string serialized_config = config.SerializeAsString();+  upb::Arena arena;+  upb::SymbolTable symtab;+  XdsResourceType::DecodeContext context = {nullptr,+                                            GrpcXdsBootstrap::GrpcXdsServer(),+                                            nullptr, symtab.ptr(), arena.ptr()};+  auto* upb_config =+      envoy_config_rbac_v3_RBAC_AuditLoggingOptions_AuditLoggerConfig_parse(+          serialized_config.data(), serialized_config.size(), arena.ptr());+  ValidationErrors errors;+  ValidationErrors::ScopedField field(&errors, "".logger_config"");+  auto config_json = XdsAuditLoggerRegistry().ConvertXdsAuditLoggerConfig(+      context, upb_config, &errors);+  if (!errors.ok()) {+    return errors.status(absl::StatusCode::kInvalidArgument,+                         ""validation errors"");+  }+  return JsonDump(config_json);+}++//+// StdoutLoggerTest+//++TEST(StdoutLoggerTest, Basic) {+  AuditLoggerConfigProto config;+  config.mutable_audit_logger()->mutable_typed_config()->PackFrom(+      StdoutAuditLog());+  auto result = ConvertAuditLoggerConfig(config);+  ASSERT_TRUE(result.ok()) << result.status();+  EXPECT_EQ(*result, ""{\""stdout_logger\"":{}}"");+}++//+// XdsAuditLoggerRegistryTest+//++TEST(XdsAuditLoggerRegistryTest, EmptyAuditLoggerConfig) {+  auto result = ConvertAuditLoggerConfig(AuditLoggerConfigProto());+  EXPECT_EQ(result.status().code(), absl::StatusCode::kOk);+  EXPECT_EQ(*result, ""null"");+}++TEST(XdsAuditLoggerRegistryTest, NoSupportedType) {",Please also include tests corresponding to each of the tests we have for the LB policy registry:https://github.com/grpc/grpc/blob/4cb69f4658aecda3ea6e0ef222db86e5edc9f629/test/core/xds/xds_lb_policy_registry_test.cc#L494,
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32750,1172998869,2023-04-20T19:22:55Z,test/core/security/grpc_audit_logging_test.cc,"@@ -0,0 +1,106 @@+//+//+// Copyright 2023 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+//+//++#include <grpc/support/port_platform.h>++#include <memory>++#include <gtest/gtest.h>++#include ""absl/status/status.h""+#include ""absl/status/statusor.h""+#include ""absl/strings/string_view.h""++#include <grpc/grpc_audit_logging.h>++#include ""src/core/lib/json/json.h""+#include ""src/core/lib/security/audit_logging/audit_logging.h""+#include ""test/core/util/test_config.h""+#include ""test/core/util/tls_utils.h""++namespace grpc_core {+namespace testing {++const char kName[] = ""test_logger"";++using experimental::AuditContext;+using experimental::AuditLogger;+using experimental::AuditLoggerFactory;+using Config = experimental::AuditLoggerFactory::Config;+using experimental::GetAuditLoggerRegistry;+using experimental::RegisterAuditLoggerFactory;++namespace {++class TestAuditLogger : public AuditLogger {+ public:+  void Log(const AuditContext&) override {}+};++class TestAuditLoggerFactory : public AuditLoggerFactory {+ public:+  class TestConfig : public Config {+   public:+    const char* name() const override { return kName; }+    std::string ToString() override { return ""test_config""; }+  };++  const char* name() const override { return kName; }+  std::unique_ptr<AuditLogger> CreateAuditLogger(+      std::unique_ptr<AuditLoggerFactory::Config>) override {+    return std::make_unique<TestAuditLogger>();+  }+  absl::StatusOr<std::unique_ptr<Config>> ParseAuditLoggerConfig(+      const Json&) override {+    return std::make_unique<TestConfig>();+  }+};++}  // namespace++TEST(AuditLoggingTest, FactoryRegistrationAndLoggerCreation) {+  RegisterAuditLoggerFactory(std::make_unique<TestAuditLoggerFactory>());+  auto& registry = GetAuditLoggerRegistry();+  auto result = registry.GetAuditLoggerFactory(kName);+  ASSERT_TRUE(result.ok());+  auto* factory = result.value();+  EXPECT_EQ(factory->name(), kName);+  auto parse_result = factory->ParseAuditLoggerConfig(Json());+  ASSERT_TRUE(parse_result.ok());+  std::unique_ptr<Config> config = std::move(parse_result.value());+  ASSERT_NE(factory->CreateAuditLogger(std::move(config)), nullptr);+  registry.TestOnlyUnregisterAuditLoggerFactory(kName);","The intent of this seems to be to undo the changes that the test made to the registry.  However, the `ASSERT_*` checks above will immediately return from this function if the check fails, in which case this will never be run.I suggest replacing the `TestOnlyUnregisterAuditLoggerFactory()` method with a `TestOnlyResetRegistry()` method that simple resets the global registry to a default instance.  Then you can create a test suite class that calls that method in `TearDown()`, so that the registry will always be completely reset after each test.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32750,1173000169,2023-04-20T19:24:08Z,test/cpp/server/audit_logging_test.cc,,"Now that we're no longer wrapping the C-core API, I don't think we need this duplicate set of tests.",X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32828,1173049386,2023-04-20T20:16:29Z,src/core/ext/xds/xds_audit_logger_registry.cc,"@@ -0,0 +1,100 @@+//+// Copyright 2023 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+//++#include <grpc/support/port_platform.h>++#include ""src/core/ext/xds/xds_audit_logger_registry.h""++#include <utility>++#include ""absl/strings/string_view.h""+#include ""absl/types/optional.h""+#include ""absl/types/variant.h""+#include ""envoy/config/core/v3/extension.upb.h""+#include ""envoy/config/rbac/v3/rbac.upb.h""++#include ""src/core/ext/xds/xds_common_types.h""+#include ""src/core/lib/gprpp/validation_errors.h""+#include ""src/core/lib/json/json.h""++namespace grpc_core {++namespace {++class StdoutLoggerConfigFactory : public XdsAuditLoggerRegistry::ConfigFactory {+ public:+  Json::Object ConvertXdsAuditLoggerConfig(+      const XdsResourceType::DecodeContext& /*context*/,+      absl::string_view /*configuration*/,+      ValidationErrors* /*errors*/) override {+    return Json::Object{{""stdout_logger"", Json::Object()}};+  }++  absl::string_view type() override { return Type(); }++  static absl::string_view Type() {+    return ""envoy.extensions.rbac.audit_loggers.stream.v3.StdoutAuditLog"";+  }+};++}  // namespace++XdsAuditLoggerRegistry::XdsAuditLoggerRegistry() {+  audit_logger_config_factories_.emplace(+      StdoutLoggerConfigFactory::Type(),+      std::make_unique<StdoutLoggerConfigFactory>());+}++Json XdsAuditLoggerRegistry::ConvertXdsAuditLoggerConfig(+    const XdsResourceType::DecodeContext& context,+    const envoy_config_rbac_v3_RBAC_AuditLoggingOptions_AuditLoggerConfig*+        logger_config,+    ValidationErrors* errors) const {+  const auto* typed_extension_config =+      envoy_config_rbac_v3_RBAC_AuditLoggingOptions_AuditLoggerConfig_audit_logger(+          logger_config);+  // It is okay if this is not present.",It's fine to have 0 entries in the list.  It's not fine to have an entry in the list that does not have the `audit_logger` field set.  That's just a config error.,
7221003,rockspore,https://api.github.com/repos/grpc/grpc/pulls/32750,1173971464,2023-04-21T16:36:25Z,test/core/security/grpc_audit_logging_test.cc,"@@ -0,0 +1,106 @@+//+//+// Copyright 2023 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+//+//++#include <grpc/support/port_platform.h>++#include <memory>++#include <gtest/gtest.h>++#include ""absl/status/status.h""+#include ""absl/status/statusor.h""+#include ""absl/strings/string_view.h""++#include <grpc/grpc_audit_logging.h>++#include ""src/core/lib/json/json.h""+#include ""src/core/lib/security/audit_logging/audit_logging.h""+#include ""test/core/util/test_config.h""+#include ""test/core/util/tls_utils.h""++namespace grpc_core {+namespace testing {++const char kName[] = ""test_logger"";++using experimental::AuditContext;+using experimental::AuditLogger;+using experimental::AuditLoggerFactory;+using Config = experimental::AuditLoggerFactory::Config;",IDE warns me that using statements cannot refer to class members. But I removed this and just use `AuditLoggerFactory::Config` subsequently now.,
7221003,rockspore,https://api.github.com/repos/grpc/grpc/pulls/32750,1173979918,2023-04-21T16:47:11Z,src/core/lib/security/audit_logging/audit_logging.h,"@@ -0,0 +1,61 @@+//+//+// Copyright 2023 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+//+//++#ifndef GRPC_SRC_CORE_LIB_SECURITY_AUDIT_LOGGING_AUDIT_LOGGING_H+#define GRPC_SRC_CORE_LIB_SECURITY_AUDIT_LOGGING_AUDIT_LOGGING_H++#include <grpc/support/port_platform.h>++#include <map>+#include <memory>+#include <string>++#include ""absl/base/thread_annotations.h""+#include ""absl/status/statusor.h""+#include ""absl/strings/string_view.h""++#include <grpc/grpc_audit_logging.h>++#include ""src/core/lib/gprpp/sync.h""++namespace grpc_core {+namespace experimental {++class AuditLoggerRegistry {+ public:+  void RegisterAuditLoggerFactory(std::unique_ptr<AuditLoggerFactory>);+  absl::StatusOr<AuditLoggerFactory*> GetAuditLoggerFactory(absl::string_view);++  // Factories are registered during initialization. They should never be+  // unregistered since they will be looked up at any time till the program+  // exits. This function should only be used in tests.+  void TestOnlyUnregisterAuditLoggerFactory(absl::string_view name);++ private:+  Mutex mu_;+  std::map<std::string, std::unique_ptr<AuditLoggerFactory>>+      logger_factories_map_ ABSL_GUARDED_BY(mu_);+};++// Get the static registry instance.+AuditLoggerRegistry& GetAuditLoggerRegistry();",Done. I made all the public methods static now so that there is no need to grab a reference of the registry outside the class ever. And this one is now private.,
7221003,rockspore,https://api.github.com/repos/grpc/grpc/pulls/32750,1174187190,2023-04-21T21:56:25Z,test/core/security/grpc_audit_logging_test.cc,"@@ -0,0 +1,106 @@+//+//+// Copyright 2023 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+//+//++#include <grpc/support/port_platform.h>++#include <memory>++#include <gtest/gtest.h>++#include ""absl/status/status.h""+#include ""absl/status/statusor.h""+#include ""absl/strings/string_view.h""++#include <grpc/grpc_audit_logging.h>++#include ""src/core/lib/json/json.h""+#include ""src/core/lib/security/audit_logging/audit_logging.h""+#include ""test/core/util/test_config.h""+#include ""test/core/util/tls_utils.h""++namespace grpc_core {+namespace testing {++const char kName[] = ""test_logger"";++using experimental::AuditContext;+using experimental::AuditLogger;+using experimental::AuditLoggerFactory;+using Config = experimental::AuditLoggerFactory::Config;+using experimental::GetAuditLoggerRegistry;+using experimental::RegisterAuditLoggerFactory;++namespace {++class TestAuditLogger : public AuditLogger {+ public:+  void Log(const AuditContext&) override {}+};++class TestAuditLoggerFactory : public AuditLoggerFactory {+ public:+  class TestConfig : public Config {+   public:+    const char* name() const override { return kName; }+    std::string ToString() override { return ""test_config""; }+  };++  const char* name() const override { return kName; }+  std::unique_ptr<AuditLogger> CreateAuditLogger(+      std::unique_ptr<AuditLoggerFactory::Config>) override {+    return std::make_unique<TestAuditLogger>();+  }+  absl::StatusOr<std::unique_ptr<Config>> ParseAuditLoggerConfig(+      const Json&) override {+    return std::make_unique<TestConfig>();+  }+};++}  // namespace++TEST(AuditLoggingTest, FactoryRegistrationAndLoggerCreation) {+  RegisterAuditLoggerFactory(std::make_unique<TestAuditLoggerFactory>());+  auto& registry = GetAuditLoggerRegistry();+  auto result = registry.GetAuditLoggerFactory(kName);+  ASSERT_TRUE(result.ok());+  auto* factory = result.value();+  EXPECT_EQ(factory->name(), kName);+  auto parse_result = factory->ParseAuditLoggerConfig(Json());+  ASSERT_TRUE(parse_result.ok());+  std::unique_ptr<Config> config = std::move(parse_result.value());+  ASSERT_NE(factory->CreateAuditLogger(std::move(config)), nullptr);+  registry.TestOnlyUnregisterAuditLoggerFactory(kName);+}++TEST(AuditLoggingTest, FactoryNotFound) {+  auto& registry = GetAuditLoggerRegistry();+  auto result = registry.GetAuditLoggerFactory(kName);+  ASSERT_EQ(result.ok(), false);","Actually, on second thought, I changed my mind and let this function take the name and the ""actual config"" as two parameters. Because neither in SDK or xDS will we receive such a json object directly.I also removed those added tests.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32750,1175484348,2023-04-24T15:48:27Z,src/core/lib/security/authorization/audit_logging.h,"@@ -32,30 +31,46 @@ #include <grpc/grpc_audit_logging.h>  #include ""src/core/lib/gprpp/sync.h""+#include ""src/core/lib/json/json.h""  namespace grpc_core { namespace experimental {  class AuditLoggerRegistry {  public:-  void RegisterAuditLoggerFactory(std::unique_ptr<AuditLoggerFactory>);-  absl::StatusOr<AuditLoggerFactory*> GetAuditLoggerFactory(absl::string_view);+  static void RegisterAuditLoggerFactory(std::unique_ptr<AuditLoggerFactory>);","I think it's unnecessarily repetative to include `AuditLogger` in the names of these 3 methods, since those words are already in the class name.  I suggest renaming these methods to `RegisterFactory()`, `FactoryExists()`, and `ParseConfig()`, respectively.(I think `CreateAuditLogger()` is fine as-is, because `Create()` doesn't really make sense in this context without a noun.)",X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32828,1175622936,2023-04-24T18:02:28Z,test/core/xds/xds_audit_logger_registry_test.cc,"@@ -0,0 +1,119 @@+//+//+// Copyright 2023 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+//+//++#include ""src/core/ext/xds/xds_audit_logger_registry.h""++#include <string>++#include <google/protobuf/any.pb.h>++#include ""absl/status/status.h""+#include ""absl/status/statusor.h""+#include ""envoy/config/rbac/v3/rbac.upb.h""+#include ""gtest/gtest.h""+#include ""upb/def.hpp""  // IWYU pragma: keep+#include ""upb/upb.hpp""++#include <grpc/grpc.h>++#include ""src/core/ext/xds/xds_bootstrap_grpc.h""+#include ""src/core/lib/json/json_writer.h""+#include ""src/proto/grpc/testing/xds/v3/extension.pb.h""+#include ""src/proto/grpc/testing/xds/v3/rbac.pb.h""+#include ""src/proto/grpc/testing/xds/v3/stream.pb.h""+#include ""test/core/util/test_config.h""++// IWYU pragma: no_include ""upb/reflection/def.hpp""++namespace grpc_core {+namespace testing {+namespace {++using AuditLoggerConfigProto =+    ::envoy::config::rbac::v3::RBAC::AuditLoggingOptions::AuditLoggerConfig;+using ::envoy::extensions::rbac::audit_loggers::stream::v3::StdoutAuditLog;++absl::StatusOr<std::string> ConvertAuditLoggerConfig(+    const AuditLoggerConfigProto& config) {+  std::string serialized_config = config.SerializeAsString();+  upb::Arena arena;+  upb::SymbolTable symtab;+  XdsResourceType::DecodeContext context = {nullptr,+                                            GrpcXdsBootstrap::GrpcXdsServer(),+                                            nullptr, symtab.ptr(), arena.ptr()};+  auto* upb_config =+      envoy_config_rbac_v3_RBAC_AuditLoggingOptions_AuditLoggerConfig_parse(+          serialized_config.data(), serialized_config.size(), arena.ptr());+  ValidationErrors errors;+  ValidationErrors::ScopedField field(&errors, "".logger_config"");+  auto config_json = XdsAuditLoggerRegistry().ConvertXdsAuditLoggerConfig(+      context, upb_config, &errors);+  if (!errors.ok()) {+    return errors.status(absl::StatusCode::kInvalidArgument,+                         ""validation errors"");+  }+  return JsonDump(config_json);+}++//+// StdoutLoggerTest+//++TEST(StdoutLoggerTest, Basic) {+  AuditLoggerConfigProto config;+  config.mutable_audit_logger()->mutable_typed_config()->PackFrom(+      StdoutAuditLog());+  auto result = ConvertAuditLoggerConfig(config);+  ASSERT_TRUE(result.ok()) << result.status();+  EXPECT_EQ(*result, ""{\""stdout_logger\"":{}}"");+}++//+// XdsAuditLoggerRegistryTest+//++TEST(XdsAuditLoggerRegistryTest, EmptyAuditLoggerConfig) {+  auto result = ConvertAuditLoggerConfig(AuditLoggerConfigProto());+  EXPECT_EQ(result.status().code(), absl::StatusCode::kOk);+  EXPECT_EQ(*result, ""null"");+}++TEST(XdsAuditLoggerRegistryTest, NoSupportedType) {","I think we also need an equivalent of the `MissingTypedConfig` test, which proves that we are properly propagating errors returned by `ExtractXdsExtension()`:https://github.com/grpc/grpc/blob/4cb69f4658aecda3ea6e0ef222db86e5edc9f629/test/core/xds/xds_lb_policy_registry_test.cc#L506",
7221003,rockspore,https://api.github.com/repos/grpc/grpc/pulls/32750,1175745030,2023-04-24T20:20:45Z,src/core/lib/security/authorization/audit_logging.cc,"@@ -0,0 +1,101 @@+//+//+// Copyright 2023 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+//+//++#include <grpc/support/port_platform.h>++#include ""src/core/lib/security/authorization/audit_logging.h""++#include <initializer_list>+#include <map>+#include <memory>+#include <utility>++#include ""absl/status/status.h""+#include ""absl/status/statusor.h""+#include ""absl/strings/str_format.h""+#include ""absl/strings/string_view.h""++#include <grpc/grpc_audit_logging.h>+#include <grpc/support/log.h>++#include ""src/core/lib/gprpp/sync.h""+#include ""src/core/lib/json/json.h""++namespace grpc_core {+namespace experimental {++void AuditLoggerRegistry::RegisterAuditLoggerFactory(+    std::unique_ptr<AuditLoggerFactory> factory) {+  auto& registry = GetAuditLoggerRegistry();+  MutexLock lock(&registry.mu_);+  registry.logger_factories_map_[factory->name()] = std::move(factory);+}++bool AuditLoggerRegistry::AuditLoggerFactoryExists(absl::string_view name) {+  auto& registry = AuditLoggerRegistry::GetAuditLoggerRegistry();+  MutexLock lock(&registry.mu_);+  return registry.logger_factories_map_.find(name) !=+         registry.logger_factories_map_.end();+}++absl::StatusOr<std::unique_ptr<AuditLoggerFactory::Config>>+AuditLoggerRegistry::ParseAuditLoggerConfig(absl::string_view name,+                                            const Json& json) {+  auto factory_or = AuditLoggerRegistry::GetAuditLoggerFactory(name);+  if (!factory_or.ok()) {+    return absl::InvalidArgumentError(""unsupported audit logger type"");+  }+  return factory_or.value()->ParseAuditLoggerConfig(json);+}++std::unique_ptr<AuditLogger> AuditLoggerRegistry::CreateAuditLogger(+    std::unique_ptr<AuditLoggerFactory::Config> config) {+  auto factory_or = AuditLoggerRegistry::GetAuditLoggerFactory(config->name());+  GPR_ASSERT(factory_or.ok());+  return factory_or.value()->CreateAuditLogger(std::move(config));","Thanks for spotting the case! I followed your suggested pattern with a global `g_mu` and `g_registry`. Since the registry read is not guarded by the mutex, I think this scenario is addressed as well.",
7221003,rockspore,https://api.github.com/repos/grpc/grpc/pulls/32750,1175759788,2023-04-24T20:38:06Z,src/core/lib/security/authorization/audit_logging.cc,"@@ -0,0 +1,101 @@+//+//+// Copyright 2023 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+//+//++#include <grpc/support/port_platform.h>++#include ""src/core/lib/security/authorization/audit_logging.h""++#include <initializer_list>+#include <map>+#include <memory>+#include <utility>++#include ""absl/status/status.h""+#include ""absl/status/statusor.h""+#include ""absl/strings/str_format.h""+#include ""absl/strings/string_view.h""++#include <grpc/grpc_audit_logging.h>+#include <grpc/support/log.h>++#include ""src/core/lib/gprpp/sync.h""+#include ""src/core/lib/json/json.h""++namespace grpc_core {+namespace experimental {++void AuditLoggerRegistry::RegisterAuditLoggerFactory(+    std::unique_ptr<AuditLoggerFactory> factory) {+  auto& registry = GetAuditLoggerRegistry();+  MutexLock lock(&registry.mu_);+  registry.logger_factories_map_[factory->name()] = std::move(factory);+}++bool AuditLoggerRegistry::AuditLoggerFactoryExists(absl::string_view name) {+  auto& registry = AuditLoggerRegistry::GetAuditLoggerRegistry();+  MutexLock lock(&registry.mu_);+  return registry.logger_factories_map_.find(name) !=+         registry.logger_factories_map_.end();+}++absl::StatusOr<std::unique_ptr<AuditLoggerFactory::Config>>+AuditLoggerRegistry::ParseAuditLoggerConfig(absl::string_view name,+                                            const Json& json) {+  auto factory_or = AuditLoggerRegistry::GetAuditLoggerFactory(name);+  if (!factory_or.ok()) {+    return absl::InvalidArgumentError(""unsupported audit logger type"");+  }+  return factory_or.value()->ParseAuditLoggerConfig(json);+}++std::unique_ptr<AuditLogger> AuditLoggerRegistry::CreateAuditLogger(+    std::unique_ptr<AuditLoggerFactory::Config> config) {+  auto factory_or = AuditLoggerRegistry::GetAuditLoggerFactory(config->name());+  GPR_ASSERT(factory_or.ok());+  return factory_or.value()->CreateAuditLogger(std::move(config));+}++AuditLoggerRegistry& AuditLoggerRegistry::GetAuditLoggerRegistry() {+  static AuditLoggerRegistry& registry = *new AuditLoggerRegistry();+  return registry;+}++absl::StatusOr<AuditLoggerFactory*> AuditLoggerRegistry::GetAuditLoggerFactory(+    absl::string_view name) {+  auto& registry = GetAuditLoggerRegistry();+  MutexLock lock(&registry.mu_);+  auto it = registry.logger_factories_map_.find(name);+  if (it != registry.logger_factories_map_.end()) {+    return it->second.get();+  }+  return absl::NotFoundError(+      absl::StrFormat(""audit logger factory %s does not exist"", name));+}++void AuditLoggerRegistry::TestOnlyResetRegistry() {+  auto& registry = GetAuditLoggerRegistry();+  MutexLock lock(&registry.mu_);+  registry.logger_factories_map_.clear();",I followed this pattern and restructured all the relevant methods. I also made the ctor public again since this namespace variable needs to call it. Is this pattern using global variables fine? The only alternative I can think of still making it local to the function-static would be to have the `GetAuditLoggerRegistry` function conditionally reset the instance.,X
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/32847,1175822707,2023-04-24T22:06:33Z,src/core/lib/event_engine/posix_engine/tcp_socket_utils.cc,"@@ -128,8 +132,8 @@ absl::Status PrepareTcpClientSocket(PosixSocketWrapper sock,   if (options.tcp_receive_buffer_size != options.kReadBufferSizeUnset) {     GRPC_RETURN_IF_ERROR(sock.SetSocketRcvBuf(options.tcp_receive_buffer_size));   }-  if (reinterpret_cast<const sockaddr*>(addr.address())->sa_family != AF_UNIX) {-    // If its not a unix socket address.+  if (addr.address()->sa_family != AF_UNIX && addr.address()->sa_family != AF_VSOCK) {",I believe this added condition should be guarded by `#ifdef GRPC_HAVE_VSOCK`,
7221003,rockspore,https://api.github.com/repos/grpc/grpc/pulls/32750,1175824391,2023-04-24T22:09:52Z,src/core/lib/security/authorization/audit_logging.cc,"@@ -0,0 +1,101 @@+//+//+// Copyright 2023 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+//+//++#include <grpc/support/port_platform.h>++#include ""src/core/lib/security/authorization/audit_logging.h""++#include <initializer_list>+#include <map>+#include <memory>+#include <utility>++#include ""absl/status/status.h""+#include ""absl/status/statusor.h""+#include ""absl/strings/str_format.h""+#include ""absl/strings/string_view.h""++#include <grpc/grpc_audit_logging.h>+#include <grpc/support/log.h>++#include ""src/core/lib/gprpp/sync.h""+#include ""src/core/lib/json/json.h""++namespace grpc_core {+namespace experimental {++void AuditLoggerRegistry::RegisterAuditLoggerFactory(+    std::unique_ptr<AuditLoggerFactory> factory) {+  auto& registry = GetAuditLoggerRegistry();+  MutexLock lock(&registry.mu_);+  registry.logger_factories_map_[factory->name()] = std::move(factory);+}++bool AuditLoggerRegistry::AuditLoggerFactoryExists(absl::string_view name) {+  auto& registry = AuditLoggerRegistry::GetAuditLoggerRegistry();+  MutexLock lock(&registry.mu_);+  return registry.logger_factories_map_.find(name) !=+         registry.logger_factories_map_.end();+}++absl::StatusOr<std::unique_ptr<AuditLoggerFactory::Config>>+AuditLoggerRegistry::ParseAuditLoggerConfig(absl::string_view name,+                                            const Json& json) {+  auto factory_or = AuditLoggerRegistry::GetAuditLoggerFactory(name);+  if (!factory_or.ok()) {+    return absl::InvalidArgumentError(""unsupported audit logger type"");+  }+  return factory_or.value()->ParseAuditLoggerConfig(json);+}++std::unique_ptr<AuditLogger> AuditLoggerRegistry::CreateAuditLogger(+    std::unique_ptr<AuditLoggerFactory::Config> config) {+  auto factory_or = AuditLoggerRegistry::GetAuditLoggerFactory(config->name());+  GPR_ASSERT(factory_or.ok());+  return factory_or.value()->CreateAuditLogger(std::move(config));+}++AuditLoggerRegistry& AuditLoggerRegistry::GetAuditLoggerRegistry() {+  static AuditLoggerRegistry& registry = *new AuditLoggerRegistry();+  return registry;+}++absl::StatusOr<AuditLoggerFactory*> AuditLoggerRegistry::GetAuditLoggerFactory(+    absl::string_view name) {+  auto& registry = GetAuditLoggerRegistry();+  MutexLock lock(&registry.mu_);+  auto it = registry.logger_factories_map_.find(name);+  if (it != registry.logger_factories_map_.end()) {+    return it->second.get();+  }+  return absl::NotFoundError(+      absl::StrFormat(""audit logger factory %s does not exist"", name));+}++void AuditLoggerRegistry::TestOnlyResetRegistry() {+  auto& registry = GetAuditLoggerRegistry();+  MutexLock lock(&registry.mu_);+  registry.logger_factories_map_.clear();",(Had the response typed for a while but forgot to hit Comment).I followed your suggested pattern and restructured all the methods.,
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/32847,1175826764,2023-04-24T22:13:48Z,test/core/address_utils/parse_address_test.cc,"@@ -80,6 +83,31 @@ static void test_grpc_parse_unix_abstract(const char* uri_text,  #endif  // GRPC_HAVE_UNIX_SOCKET +#ifdef GRPC_HAVE_VSOCK++static void test_grpc_parse_vsock(const char* uri_text, uint32_t cid, uint32_t port) {+  grpc_core::ExecCtx exec_ctx;+  absl::StatusOr<grpc_core::URI> uri = grpc_core::URI::Parse(uri_text);+  if (!uri.ok()) {+    gpr_log(GPR_ERROR, ""%s"", uri.status().ToString().c_str());+    ASSERT_TRUE(uri.ok());+  }+  grpc_resolved_address addr;++  ASSERT_TRUE(grpc_parse_uri(*uri, &addr));+  struct sockaddr_vm* addr_vm =+      reinterpret_cast<struct sockaddr_vm*>(addr.addr);+  ASSERT_EQ(AF_VSOCK, addr_vm->svm_family);+  ASSERT_EQ(grpc_ntohl(addr_vm->svm_cid), cid);+  ASSERT_EQ(addr_vm->svm_port, port);+}++#else  // GRPC_HAVE_VSOCK++static void test_grpc_parse_vsock(const char* uri_text, uint32_t cid, uint32_t port) {}","I believe these arguments will be identified as unused at compile time on platforms that don't have VSOCK. Suggest `test_grpc_parse_vsock(const char* /* uri_text */, ...)`",X
7221003,rockspore,https://api.github.com/repos/grpc/grpc/pulls/32750,1175977370,2023-04-25T03:42:25Z,src/core/lib/security/authorization/audit_logging.cc,"@@ -39,62 +40,65 @@ namespace grpc_core { namespace experimental { -void AuditLoggerRegistry::RegisterAuditLoggerFactory(+namespace {++Mutex* g_mu = new Mutex();+AuditLoggerRegistry* g_registry ABSL_GUARDED_BY(g_mu) =+    new AuditLoggerRegistry();++}  // namespace++void AuditLoggerRegistry::RegisterFactory(     std::unique_ptr<AuditLoggerFactory> factory) {-  auto& registry = GetAuditLoggerRegistry();-  MutexLock lock(&registry.mu_);-  registry.logger_factories_map_[factory->name()] = std::move(factory);+  if (factory == nullptr) return;+  MutexLock lock(g_mu);+  GPR_ASSERT(g_registry->logger_factories_map_.find(factory->name()) ==+             g_registry->logger_factories_map_.end());+  g_registry->logger_factories_map_[factory->name()] = std::move(factory); } -bool AuditLoggerRegistry::AuditLoggerFactoryExists(absl::string_view name) {-  auto& registry = AuditLoggerRegistry::GetAuditLoggerRegistry();-  MutexLock lock(&registry.mu_);-  return registry.logger_factories_map_.find(name) !=-         registry.logger_factories_map_.end();+bool AuditLoggerRegistry::FactoryExists(absl::string_view name) {+  MutexLock lock(g_mu);+  return g_registry->logger_factories_map_.find(name) !=+         g_registry->logger_factories_map_.end(); }  absl::StatusOr<std::unique_ptr<AuditLoggerFactory::Config>>-AuditLoggerRegistry::ParseAuditLoggerConfig(absl::string_view name,-                                            const Json& json) {-  auto factory_or = AuditLoggerRegistry::GetAuditLoggerFactory(name);+AuditLoggerRegistry::ParseConfig(absl::string_view name, const Json& json) {+  MutexLock lock(g_mu);+  auto factory_or = g_registry->GetAuditLoggerFactory(name);   if (!factory_or.ok()) {-    return absl::InvalidArgumentError(""unsupported audit logger type"");+    return factory_or.status();   }   return factory_or.value()->ParseAuditLoggerConfig(json); }  std::unique_ptr<AuditLogger> AuditLoggerRegistry::CreateAuditLogger(     std::unique_ptr<AuditLoggerFactory::Config> config) {-  auto factory_or = AuditLoggerRegistry::GetAuditLoggerFactory(config->name());+  MutexLock lock(g_mu);+  auto factory_or = g_registry->GetAuditLoggerFactory(config->name());   GPR_ASSERT(factory_or.ok());   return factory_or.value()->CreateAuditLogger(std::move(config)); } -AuditLoggerRegistry& AuditLoggerRegistry::GetAuditLoggerRegistry() {-  static AuditLoggerRegistry& registry = *new AuditLoggerRegistry();-  return registry;-}- absl::StatusOr<AuditLoggerFactory*> AuditLoggerRegistry::GetAuditLoggerFactory(     absl::string_view name) {","I removed this function. There are only two places that use it and given the if condition there, putting this logic inline doesn't lead to more LOC. It also eliminates the problem of locking both registry reads and map I/O.",
7221003,rockspore,https://api.github.com/repos/grpc/grpc/pulls/32750,1175977901,2023-04-25T03:44:02Z,src/core/lib/security/authorization/audit_logging.cc,"@@ -0,0 +1,101 @@+//+//+// Copyright 2023 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+//+//++#include <grpc/support/port_platform.h>++#include ""src/core/lib/security/authorization/audit_logging.h""++#include <initializer_list>+#include <map>+#include <memory>+#include <utility>++#include ""absl/status/status.h""+#include ""absl/status/statusor.h""+#include ""absl/strings/str_format.h""+#include ""absl/strings/string_view.h""++#include <grpc/grpc_audit_logging.h>+#include <grpc/support/log.h>++#include ""src/core/lib/gprpp/sync.h""+#include ""src/core/lib/json/json.h""++namespace grpc_core {+namespace experimental {++void AuditLoggerRegistry::RegisterAuditLoggerFactory(+    std::unique_ptr<AuditLoggerFactory> factory) {+  auto& registry = GetAuditLoggerRegistry();+  MutexLock lock(&registry.mu_);+  registry.logger_factories_map_[factory->name()] = std::move(factory);+}++bool AuditLoggerRegistry::AuditLoggerFactoryExists(absl::string_view name) {+  auto& registry = AuditLoggerRegistry::GetAuditLoggerRegistry();+  MutexLock lock(&registry.mu_);+  return registry.logger_factories_map_.find(name) !=+         registry.logger_factories_map_.end();+}++absl::StatusOr<std::unique_ptr<AuditLoggerFactory::Config>>+AuditLoggerRegistry::ParseAuditLoggerConfig(absl::string_view name,+                                            const Json& json) {+  auto factory_or = AuditLoggerRegistry::GetAuditLoggerFactory(name);+  if (!factory_or.ok()) {+    return absl::InvalidArgumentError(""unsupported audit logger type"");+  }+  return factory_or.value()->ParseAuditLoggerConfig(json);+}++std::unique_ptr<AuditLogger> AuditLoggerRegistry::CreateAuditLogger(+    std::unique_ptr<AuditLoggerFactory::Config> config) {+  auto factory_or = AuditLoggerRegistry::GetAuditLoggerFactory(config->name());+  GPR_ASSERT(factory_or.ok());+  return factory_or.value()->CreateAuditLogger(std::move(config));+}++AuditLoggerRegistry& AuditLoggerRegistry::GetAuditLoggerRegistry() {+  static AuditLoggerRegistry& registry = *new AuditLoggerRegistry();+  return registry;+}++absl::StatusOr<AuditLoggerFactory*> AuditLoggerRegistry::GetAuditLoggerFactory(+    absl::string_view name) {+  auto& registry = GetAuditLoggerRegistry();+  MutexLock lock(&registry.mu_);+  auto it = registry.logger_factories_map_.find(name);+  if (it != registry.logger_factories_map_.end()) {+    return it->second.get();+  }+  return absl::NotFoundError(+      absl::StrFormat(""audit logger factory %s does not exist"", name));+}++void AuditLoggerRegistry::TestOnlyResetRegistry() {+  auto& registry = GetAuditLoggerRegistry();+  MutexLock lock(&registry.mu_);+  registry.logger_factories_map_.clear();","With both the mutex and registry as static class members, the ctor can remain private now.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32750,1176661631,2023-04-25T15:06:17Z,src/core/lib/security/authorization/audit_logging.cc,"@@ -40,61 +39,47 @@ namespace grpc_core { namespace experimental { -namespace {+Mutex AuditLoggerRegistry::mu; -Mutex* g_mu = new Mutex();-AuditLoggerRegistry* g_registry ABSL_GUARDED_BY(g_mu) =-    new AuditLoggerRegistry();--}  // namespace+AuditLoggerRegistry AuditLoggerRegistry::registry;  void AuditLoggerRegistry::RegisterFactory(     std::unique_ptr<AuditLoggerFactory> factory) {-  if (factory == nullptr) return;-  MutexLock lock(g_mu);-  GPR_ASSERT(g_registry->logger_factories_map_.find(factory->name()) ==-             g_registry->logger_factories_map_.end());-  g_registry->logger_factories_map_[factory->name()] = std::move(factory);+  GPR_ASSERT(factory != nullptr);+  MutexLock lock(&mu);+  GPR_ASSERT(registry.logger_factories_map_+                 .emplace(factory->name(), std::move(factory))","I believe this is undefined behavior: C++ does not guarantee the order in which the parameters are evaluated, so the `std::move(factory)` could be executed before `factory->name()`, which wouldn't work.  So I think you need to instead do something like this:```absl::string_view name = factory->name();GPR_ASSERT(registry.logger_factories_map_               .emplace(name, std::move(factory))               .second);```",
287917,eugeneo,https://api.github.com/repos/grpc/grpc/pulls/32835,1178303401,2023-04-26T19:25:46Z,src/core/lib/service_config/service_config_call_data.h,"@@ -40,7 +39,29 @@ namespace grpc_core { /// easily access method and global parameters for the call. class ServiceConfigCallData {  public:-  using CallAttributes = std::map<UniqueTypeName, absl::string_view>;+  class Holder {+   public:+    virtual ~Holder() = default;+  };++  template <typename T>+  class UniversalHolder : public Holder {+   public:+    explicit UniversalHolder(T value) : value_(std::move(value)) {}+    T value() { return value_; }++   private:+    T value_;+  };++  using CallAttributes = std::map<std::uintptr_t, std::unique_ptr<Holder>>;",I am not clear on semantics. Is noop(default) virtual dtor compatible with `New`?,
287917,eugeneo,https://api.github.com/repos/grpc/grpc/pulls/32835,1178318904,2023-04-26T19:41:57Z,src/core/ext/filters/client_channel/resolver/xds/xds_resolver.cc,"@@ -731,13 +732,16 @@ XdsResolver::XdsConfigSelector::GetCallConfig(GetCallConfigArgs args) {         method_config->GetMethodParsedConfigVector(grpc_empty_slice());     call_config.service_config = std::move(method_config);   }-  call_config.call_attributes[XdsClusterAttributeTypeName()] = it->first;+  ServiceConfigCallData::Pack(&call_config.call_attributes,",Do we need a separate class for every attribute? I created a class that wraps UniqueTypeName and absl::string_view so it can be reused. I assume that we will be using absl::string_view values in most cases anyways so I would suggest streamlining that pass as much as possible,
16962414,gtcooke94,https://api.github.com/repos/grpc/grpc/pulls/32944,1178398238,2023-04-26T21:05:11Z,test/core/security/rbac_translator_test.cc,"@@ -53,9 +68,39 @@ MATCHER_P4(EqualsHeader, expected_name, expected_matcher_type,              : arg->header_matcher.string_matcher() == expected_matcher_value; } +class TestAuditLoggerFactory : public AuditLoggerFactory {+ public:+  class TestAuditLoggerConfig : public AuditLoggerFactory::Config {+    absl::string_view name() const override { return kLoggerName; }+    std::string ToString() const override { return """"; }+  };+  absl::string_view name() const override { return kLoggerName; }+  absl::StatusOr<std::unique_ptr<AuditLoggerFactory::Config>>+  ParseAuditLoggerConfig(const Json& json) override {+    if (json.object().find(""bad"") != json.object().end()) {","I think it's worth a comment here that ""bad"" comes from hard-coding the json like that for a test",X
16962414,gtcooke94,https://api.github.com/repos/grpc/grpc/pulls/32944,1178406231,2023-04-26T21:15:02Z,test/core/security/rbac_translator_test.cc,"@@ -984,6 +1038,347 @@ TEST(GenerateRbacPoliciesTest, UnknownFieldInHeaders) {               ""\""foo\"".""); } +TEST_F(GenerateRbacPoliciesTest, AuditConditionOnDeny) {+  const char* authz_policy =+      ""{""+      ""  \""name\"": \""authz\"",""+      ""  \""allow_rules\"": [""+      ""    {""+      ""      \""name\"": \""allow_policy\""""+      ""    }""+      ""  ],""+      ""  \""deny_rules\"": [""+      ""    {""+      ""      \""name\"": \""deny_policy\""""+      ""    }""+      ""  ],""+      ""  \""audit_logging_options\"": {""+      ""    \""audit_condition\"": \""ON_DENY\""""+      ""  }""+      ""}"";+  auto rbacs = GenerateRbacPolicies(authz_policy);+  ASSERT_TRUE(rbacs.ok());+  EXPECT_EQ(rbacs->allow_policy.name, ""authz"");+  EXPECT_EQ(rbacs->deny_policy->name, ""authz"");+  EXPECT_EQ(rbacs->allow_policy.audit_condition, Rbac::AuditCondition::kOnDeny);+  EXPECT_EQ(rbacs->deny_policy->audit_condition, Rbac::AuditCondition::kOnDeny);+}++TEST_F(GenerateRbacPoliciesTest, AuditConditionOnAllowWithAuditLogger) {+  const char* authz_policy =+      ""{""+      ""  \""name\"": \""authz\"",""+      ""  \""allow_rules\"": [""+      ""    {""+      ""      \""name\"": \""allow_policy\""""+      ""    }""+      ""  ],""+      ""  \""deny_rules\"": [""+      ""    {""+      ""      \""name\"": \""deny_policy\""""+      ""    }""+      ""  ],""+      ""  \""audit_logging_options\"": {""+      ""    \""audit_condition\"": \""ON_ALLOW\"",""+      ""    \""audit_loggers\"": [""+      ""      {""+      ""        \""name\"": \""test_logger\"",""+      ""        \""config\"": {}""+      ""      }""+      ""    ]""+      ""  }""+      ""}"";+  auto rbacs = GenerateRbacPolicies(authz_policy);+  std::cout << rbacs.status().message() << std::endl;+  ASSERT_TRUE(rbacs.ok());+  EXPECT_EQ(rbacs->allow_policy.name, ""authz"");+  EXPECT_EQ(rbacs->deny_policy->name, ""authz"");+  EXPECT_EQ(rbacs->allow_policy.audit_condition,+            Rbac::AuditCondition::kOnAllow);+  EXPECT_EQ(rbacs->deny_policy->audit_condition, Rbac::AuditCondition::kNone);+  ASSERT_EQ(rbacs->allow_policy.logger_configs.size(), 1);+  EXPECT_EQ(rbacs->deny_policy->logger_configs.size(), 0);+  EXPECT_EQ(rbacs->allow_policy.logger_configs.at(0)->name(), kLoggerName);+}++TEST_F(GenerateRbacPoliciesTest,+       AuditConditionOnDenyAndAllowWithUnsupportedButOptionalLogger) {+  const char* authz_policy =+      ""{""+      ""  \""name\"": \""authz\"",""+      ""  \""allow_rules\"": [""+      ""    {""+      ""      \""name\"": \""allow_policy\""""+      ""    }""+      ""  ],""+      ""  \""deny_rules\"": [""+      ""    {""+      ""      \""name\"": \""deny_policy\""""+      ""    }""+      ""  ],""+      ""  \""audit_logging_options\"": {""+      ""    \""audit_condition\"": \""ON_DENY_AND_ALLOW\"",""+      ""    \""audit_loggers\"": [""+      ""      {""+      ""        \""name\"": \""unknown_logger\"",""+      ""        \""is_optional\"": true,""+      ""        \""config\"": {}""+      ""      }""+      ""    ]""+      ""  }""+      ""}"";+  auto rbacs = GenerateRbacPolicies(authz_policy);+  ASSERT_TRUE(rbacs.ok());+  EXPECT_EQ(rbacs->allow_policy.name, ""authz"");+  EXPECT_EQ(rbacs->deny_policy->name, ""authz"");+  EXPECT_EQ(rbacs->allow_policy.audit_condition,+            Rbac::AuditCondition::kOnDenyAndAllow);+  EXPECT_EQ(rbacs->deny_policy->audit_condition, Rbac::AuditCondition::kOnDeny);+  EXPECT_EQ(rbacs->allow_policy.logger_configs.size(), 0);+  EXPECT_EQ(rbacs->deny_policy->logger_configs.size(), 0);+}++TEST_F(GenerateRbacPoliciesTest, AuditConditionIsNotString) {+  const char* authz_policy =+      ""{""+      ""  \""name\"": \""authz\"",""+      ""  \""allow_rules\"": [""+      ""    {""+      ""      \""name\"": \""allow_policy\""""+      ""    }""+      ""  ],""+      ""  \""audit_logging_options\"": {""+      ""    \""audit_condition\"": 123""+      ""  }""+      ""}"";+  auto rbacs = GenerateRbacPolicies(authz_policy);+  EXPECT_EQ(rbacs.status().code(), absl::StatusCode::kInvalidArgument);+  EXPECT_THAT(rbacs.status().message(), ""\""audit_condition\"" is not a string."");+}++TEST_F(GenerateRbacPoliciesTest, IncorrectAuditConditionValue) {+  const char* authz_policy =+      ""{""+      ""  \""name\"": \""authz\"",""+      ""  \""allow_rules\"": [""+      ""    {""+      ""      \""name\"": \""allow_policy\""""+      ""    }""+      ""  ],""+      ""  \""audit_logging_options\"": {""+      ""    \""audit_condition\"": \""UNKNOWN\""""+      ""  }""+      ""}"";+  auto rbacs = GenerateRbacPolicies(authz_policy);+  EXPECT_EQ(rbacs.status().code(), absl::StatusCode::kInvalidArgument);+  EXPECT_THAT(rbacs.status().message(),+              ""Unsupported \""audit_condition\"" value UNKNOWN."");+}++TEST_F(GenerateRbacPoliciesTest, IncorrectAuditLoggersType) {+  const char* authz_policy =+      ""{""+      ""  \""name\"": \""authz\"",""+      ""  \""allow_rules\"": [""+      ""    {""+      ""      \""name\"": \""allow_policy\""""+      ""    }""+      ""  ],""+      ""  \""audit_logging_options\"": {""+      ""    \""audit_loggers\"": 123""+      ""  }""+      ""}"";+  auto rbacs = GenerateRbacPolicies(authz_policy);+  EXPECT_EQ(rbacs.status().code(), absl::StatusCode::kInvalidArgument);+  EXPECT_THAT(rbacs.status().message(), ""\""audit_loggers\"" is not an array."");+}++TEST_F(GenerateRbacPoliciesTest, IncorrectAuditLoggerType) {+  const char* authz_policy =+      ""{""+      ""  \""name\"": \""authz\"",""+      ""  \""allow_rules\"": [""+      ""    {""+      ""      \""name\"": \""allow_policy\""""+      ""    }""+      ""  ],""+      ""  \""audit_logging_options\"": {""+      ""    \""audit_loggers\"": [123]""+      ""  }""+      ""}"";+  auto rbacs = GenerateRbacPolicies(authz_policy);+  EXPECT_EQ(rbacs.status().code(), absl::StatusCode::kInvalidArgument);+  EXPECT_THAT(rbacs.status().message(),+              ""\""audit_loggers[0]\"" is not an object."");+}++TEST_F(GenerateRbacPoliciesTest, IncorrectAuditLoggerConfigType) {+  const char* authz_policy =+      ""{""+      ""  \""name\"": \""authz\"",""+      ""  \""allow_rules\"": [""+      ""    {""+      ""      \""name\"": \""allow_policy\""""+      ""    }""+      ""  ],""+      ""  \""audit_logging_options\"": {""+      ""    \""audit_loggers\"": [""+      ""      {""+      ""        \""name\"": \""unknown_logger\"",""+      ""        \""config\"": 123""+      ""      }""+      ""    ]""+      ""  }""+      ""}"";+  auto rbacs = GenerateRbacPolicies(authz_policy);+  EXPECT_EQ(rbacs.status().code(), absl::StatusCode::kInvalidArgument);+  EXPECT_THAT(rbacs.status().message(),+              ""\""audit_loggers[0].config\"" is not an object."");+}++TEST_F(GenerateRbacPoliciesTest, BadAuditLoggerConfig) {+  const char* authz_policy =+      ""{""+      ""  \""name\"": \""authz\"",""+      ""  \""allow_rules\"": [""+      ""    {""+      ""      \""name\"": \""allow_policy\""""+      ""    }""+      ""  ],""+      ""  \""audit_logging_options\"": {""+      ""    \""audit_loggers\"": [""+      ""      {""+      ""        \""name\"": \""test_logger\"",""+      ""        \""config\"": {\""bad\"": true}""+      ""      }""+      ""    ]""+      ""  }""+      ""}"";+  auto rbacs = GenerateRbacPolicies(authz_policy);+  EXPECT_EQ(rbacs.status().code(), absl::StatusCode::kInvalidArgument);+  EXPECT_THAT(rbacs.status().message(),+              ""\""audit_loggers[0]\"" bad logger config."");+}++TEST_F(GenerateRbacPoliciesTest, IncorrectAuditLoggerNameType) {+  const char* authz_policy =+      ""{""+      ""  \""name\"": \""authz\"",""+      ""  \""allow_rules\"": [""+      ""    {""+      ""      \""name\"": \""allow_policy\""""+      ""    }""+      ""  ],""+      ""  \""audit_logging_options\"": {""+      ""    \""audit_loggers\"": [""+      ""      {""+      ""        \""name\"": 123,""+      ""        \""config\"": {}""+      ""      }""+      ""    ]""+      ""  }""+      ""}"";+  auto rbacs = GenerateRbacPolicies(authz_policy);+  EXPECT_EQ(rbacs.status().code(), absl::StatusCode::kInvalidArgument);+  EXPECT_THAT(rbacs.status().message(),+              ""\""audit_loggers[0].name\"" is not a string."");+}++TEST_F(GenerateRbacPoliciesTest, IncorrectAuditLoggerIsOptionalType) {+  const char* authz_policy =+      ""{""+      ""  \""name\"": \""authz\"",""+      ""  \""allow_rules\"": [""+      ""    {""+      ""      \""name\"": \""allow_policy\""""+      ""    }""+      ""  ],""+      ""  \""audit_logging_options\"": {""+      ""    \""audit_loggers\"": [""+      ""      {""+      ""        \""name\"": \""test_logger\"",""+      ""        \""is_optional\"": 123,""+      ""        \""config\"": {}""+      ""      }""+      ""    ]""+      ""  }""+      ""}"";+  auto rbacs = GenerateRbacPolicies(authz_policy);+  EXPECT_EQ(rbacs.status().code(), absl::StatusCode::kInvalidArgument);+  EXPECT_THAT(rbacs.status().message(),+              ""\""audit_loggers[0].is_optional\"" is not a boolean."");+}++TEST_F(GenerateRbacPoliciesTest, MissingAuditLoggerName) {+  const char* authz_policy =+      ""{""+      ""  \""name\"": \""authz\"",""+      ""  \""allow_rules\"": [""+      ""    {""+      ""      \""name\"": \""allow_policy\""""+      ""    }""+      ""  ],""+      ""  \""audit_logging_options\"": {""+      ""    \""audit_loggers\"": [""+      ""      {""+      ""        \""config\"": {}""+      ""      }""+      ""    ]""+      ""  }""+      ""}"";+  auto rbacs = GenerateRbacPolicies(authz_policy);+  EXPECT_EQ(rbacs.status().code(), absl::StatusCode::kInvalidArgument);+  EXPECT_THAT(rbacs.status().message(),+              ""\""audit_loggers[0].name\"" is required."");+}++TEST_F(GenerateRbacPoliciesTest, MissingAuditLoggerConfig) {+  const char* authz_policy =+      ""{""+      ""  \""name\"": \""authz\"",""+      ""  \""allow_rules\"": [""+      ""    {""+      ""      \""name\"": \""allow_policy\""""+      ""    }""+      ""  ],""+      ""  \""audit_logging_options\"": {""+      ""    \""audit_loggers\"": [""+      ""      {""+      ""        \""name\"": \""test_logger\""""+      ""      }""+      ""    ]""+      ""  }""+      ""}"";+  auto rbacs = GenerateRbacPolicies(authz_policy);+  EXPECT_EQ(rbacs.status().code(), absl::StatusCode::kInvalidArgument);+  EXPECT_THAT(rbacs.status().message(),+              ""\""audit_loggers[0].config\"" is required."");+}++TEST_F(GenerateRbacPoliciesTest, UnsupportedAuditLogger) {+  const char* authz_policy =+      ""{""+      ""  \""name\"": \""authz\"",""+      ""  \""allow_rules\"": [""+      ""    {""+      ""      \""name\"": \""allow_policy\""""+      ""    }""+      ""  ],""+      ""  \""audit_logging_options\"": {""+      ""    \""audit_loggers\"": [""+      ""      {""+      ""        \""name\"": \""unknown_logger\"",""+      ""        \""config\"": {}""+      ""      }""+      ""    ]""+      ""  }""+      ""}"";+  auto rbacs = GenerateRbacPolicies(authz_policy);+  EXPECT_EQ(rbacs.status().code(), absl::StatusCode::kInvalidArgument);+  EXPECT_THAT(rbacs.status().message(),+              ""\""audit_loggers[0].name\"" unknown_logger is not supported."");+}+","Can you add a test where you parse a non-empty `config`?The `{""bad"": true}` case parses it, but having a test where we pass a valid custom config and ensure that the values are accessible is worth it IMO",
16962414,gtcooke94,https://api.github.com/repos/grpc/grpc/pulls/32944,1178407333,2023-04-26T21:16:26Z,test/core/security/rbac_translator_test.cc,"@@ -984,6 +1038,347 @@ TEST(GenerateRbacPoliciesTest, UnknownFieldInHeaders) {               ""\""foo\"".""); } +TEST_F(GenerateRbacPoliciesTest, AuditConditionOnDeny) {+  const char* authz_policy =+      ""{""+      ""  \""name\"": \""authz\"",""+      ""  \""allow_rules\"": [""+      ""    {""+      ""      \""name\"": \""allow_policy\""""+      ""    }""+      ""  ],""+      ""  \""deny_rules\"": [""+      ""    {""+      ""      \""name\"": \""deny_policy\""""+      ""    }""+      ""  ],""+      ""  \""audit_logging_options\"": {""+      ""    \""audit_condition\"": \""ON_DENY\""""+      ""  }""+      ""}"";+  auto rbacs = GenerateRbacPolicies(authz_policy);+  ASSERT_TRUE(rbacs.ok());+  EXPECT_EQ(rbacs->allow_policy.name, ""authz"");+  EXPECT_EQ(rbacs->deny_policy->name, ""authz"");+  EXPECT_EQ(rbacs->allow_policy.audit_condition, Rbac::AuditCondition::kOnDeny);+  EXPECT_EQ(rbacs->deny_policy->audit_condition, Rbac::AuditCondition::kOnDeny);+}++TEST_F(GenerateRbacPoliciesTest, AuditConditionOnAllowWithAuditLogger) {+  const char* authz_policy =+      ""{""+      ""  \""name\"": \""authz\"",""+      ""  \""allow_rules\"": [""+      ""    {""+      ""      \""name\"": \""allow_policy\""""+      ""    }""+      ""  ],""+      ""  \""deny_rules\"": [""+      ""    {""+      ""      \""name\"": \""deny_policy\""""+      ""    }""+      ""  ],""+      ""  \""audit_logging_options\"": {""+      ""    \""audit_condition\"": \""ON_ALLOW\"",""+      ""    \""audit_loggers\"": [""+      ""      {""+      ""        \""name\"": \""test_logger\"",""+      ""        \""config\"": {}""+      ""      }""+      ""    ]""+      ""  }""+      ""}"";+  auto rbacs = GenerateRbacPolicies(authz_policy);+  std::cout << rbacs.status().message() << std::endl;+  ASSERT_TRUE(rbacs.ok());+  EXPECT_EQ(rbacs->allow_policy.name, ""authz"");+  EXPECT_EQ(rbacs->deny_policy->name, ""authz"");+  EXPECT_EQ(rbacs->allow_policy.audit_condition,+            Rbac::AuditCondition::kOnAllow);+  EXPECT_EQ(rbacs->deny_policy->audit_condition, Rbac::AuditCondition::kNone);+  ASSERT_EQ(rbacs->allow_policy.logger_configs.size(), 1);+  EXPECT_EQ(rbacs->deny_policy->logger_configs.size(), 0);+  EXPECT_EQ(rbacs->allow_policy.logger_configs.at(0)->name(), kLoggerName);+}++TEST_F(GenerateRbacPoliciesTest,+       AuditConditionOnDenyAndAllowWithUnsupportedButOptionalLogger) {+  const char* authz_policy =+      ""{""+      ""  \""name\"": \""authz\"",""+      ""  \""allow_rules\"": [""+      ""    {""+      ""      \""name\"": \""allow_policy\""""+      ""    }""+      ""  ],""+      ""  \""deny_rules\"": [""+      ""    {""+      ""      \""name\"": \""deny_policy\""""+      ""    }""+      ""  ],""+      ""  \""audit_logging_options\"": {""+      ""    \""audit_condition\"": \""ON_DENY_AND_ALLOW\"",""+      ""    \""audit_loggers\"": [""+      ""      {""+      ""        \""name\"": \""unknown_logger\"",""+      ""        \""is_optional\"": true,""+      ""        \""config\"": {}""+      ""      }""+      ""    ]""+      ""  }""+      ""}"";+  auto rbacs = GenerateRbacPolicies(authz_policy);+  ASSERT_TRUE(rbacs.ok());+  EXPECT_EQ(rbacs->allow_policy.name, ""authz"");+  EXPECT_EQ(rbacs->deny_policy->name, ""authz"");+  EXPECT_EQ(rbacs->allow_policy.audit_condition,+            Rbac::AuditCondition::kOnDenyAndAllow);+  EXPECT_EQ(rbacs->deny_policy->audit_condition, Rbac::AuditCondition::kOnDeny);+  EXPECT_EQ(rbacs->allow_policy.logger_configs.size(), 0);+  EXPECT_EQ(rbacs->deny_policy->logger_configs.size(), 0);+}++TEST_F(GenerateRbacPoliciesTest, AuditConditionIsNotString) {+  const char* authz_policy =+      ""{""+      ""  \""name\"": \""authz\"",""+      ""  \""allow_rules\"": [""+      ""    {""+      ""      \""name\"": \""allow_policy\""""+      ""    }""+      ""  ],""+      ""  \""audit_logging_options\"": {""+      ""    \""audit_condition\"": 123""+      ""  }""+      ""}"";+  auto rbacs = GenerateRbacPolicies(authz_policy);+  EXPECT_EQ(rbacs.status().code(), absl::StatusCode::kInvalidArgument);+  EXPECT_THAT(rbacs.status().message(), ""\""audit_condition\"" is not a string."");+}++TEST_F(GenerateRbacPoliciesTest, IncorrectAuditConditionValue) {+  const char* authz_policy =+      ""{""+      ""  \""name\"": \""authz\"",""+      ""  \""allow_rules\"": [""+      ""    {""+      ""      \""name\"": \""allow_policy\""""+      ""    }""+      ""  ],""+      ""  \""audit_logging_options\"": {""+      ""    \""audit_condition\"": \""UNKNOWN\""""+      ""  }""+      ""}"";+  auto rbacs = GenerateRbacPolicies(authz_policy);+  EXPECT_EQ(rbacs.status().code(), absl::StatusCode::kInvalidArgument);+  EXPECT_THAT(rbacs.status().message(),+              ""Unsupported \""audit_condition\"" value UNKNOWN."");+}++TEST_F(GenerateRbacPoliciesTest, IncorrectAuditLoggersType) {+  const char* authz_policy =+      ""{""+      ""  \""name\"": \""authz\"",""+      ""  \""allow_rules\"": [""+      ""    {""+      ""      \""name\"": \""allow_policy\""""+      ""    }""+      ""  ],""+      ""  \""audit_logging_options\"": {""+      ""    \""audit_loggers\"": 123""+      ""  }""+      ""}"";+  auto rbacs = GenerateRbacPolicies(authz_policy);+  EXPECT_EQ(rbacs.status().code(), absl::StatusCode::kInvalidArgument);+  EXPECT_THAT(rbacs.status().message(), ""\""audit_loggers\"" is not an array."");+}++TEST_F(GenerateRbacPoliciesTest, IncorrectAuditLoggerType) {+  const char* authz_policy =+      ""{""+      ""  \""name\"": \""authz\"",""+      ""  \""allow_rules\"": [""+      ""    {""+      ""      \""name\"": \""allow_policy\""""+      ""    }""+      ""  ],""+      ""  \""audit_logging_options\"": {""+      ""    \""audit_loggers\"": [123]""+      ""  }""+      ""}"";+  auto rbacs = GenerateRbacPolicies(authz_policy);+  EXPECT_EQ(rbacs.status().code(), absl::StatusCode::kInvalidArgument);+  EXPECT_THAT(rbacs.status().message(),+              ""\""audit_loggers[0]\"" is not an object."");+}++TEST_F(GenerateRbacPoliciesTest, IncorrectAuditLoggerConfigType) {+  const char* authz_policy =+      ""{""+      ""  \""name\"": \""authz\"",""+      ""  \""allow_rules\"": [""+      ""    {""+      ""      \""name\"": \""allow_policy\""""+      ""    }""+      ""  ],""+      ""  \""audit_logging_options\"": {""+      ""    \""audit_loggers\"": [""+      ""      {""+      ""        \""name\"": \""unknown_logger\"",""+      ""        \""config\"": 123""+      ""      }""+      ""    ]""+      ""  }""+      ""}"";+  auto rbacs = GenerateRbacPolicies(authz_policy);+  EXPECT_EQ(rbacs.status().code(), absl::StatusCode::kInvalidArgument);+  EXPECT_THAT(rbacs.status().message(),+              ""\""audit_loggers[0].config\"" is not an object."");+}++TEST_F(GenerateRbacPoliciesTest, BadAuditLoggerConfig) {+  const char* authz_policy =+      ""{""+      ""  \""name\"": \""authz\"",""+      ""  \""allow_rules\"": [""+      ""    {""+      ""      \""name\"": \""allow_policy\""""+      ""    }""+      ""  ],""+      ""  \""audit_logging_options\"": {""+      ""    \""audit_loggers\"": [""+      ""      {""+      ""        \""name\"": \""test_logger\"",""+      ""        \""config\"": {\""bad\"": true}""+      ""      }""+      ""    ]""+      ""  }""+      ""}"";+  auto rbacs = GenerateRbacPolicies(authz_policy);+  EXPECT_EQ(rbacs.status().code(), absl::StatusCode::kInvalidArgument);+  EXPECT_THAT(rbacs.status().message(),+              ""\""audit_loggers[0]\"" bad logger config."");+}++TEST_F(GenerateRbacPoliciesTest, IncorrectAuditLoggerNameType) {+  const char* authz_policy =+      ""{""+      ""  \""name\"": \""authz\"",""+      ""  \""allow_rules\"": [""+      ""    {""+      ""      \""name\"": \""allow_policy\""""+      ""    }""+      ""  ],""+      ""  \""audit_logging_options\"": {""+      ""    \""audit_loggers\"": [""+      ""      {""+      ""        \""name\"": 123,""+      ""        \""config\"": {}""+      ""      }""+      ""    ]""+      ""  }""+      ""}"";+  auto rbacs = GenerateRbacPolicies(authz_policy);+  EXPECT_EQ(rbacs.status().code(), absl::StatusCode::kInvalidArgument);+  EXPECT_THAT(rbacs.status().message(),+              ""\""audit_loggers[0].name\"" is not a string."");+}++TEST_F(GenerateRbacPoliciesTest, IncorrectAuditLoggerIsOptionalType) {+  const char* authz_policy =+      ""{""+      ""  \""name\"": \""authz\"",""+      ""  \""allow_rules\"": [""+      ""    {""+      ""      \""name\"": \""allow_policy\""""+      ""    }""+      ""  ],""+      ""  \""audit_logging_options\"": {""+      ""    \""audit_loggers\"": [""+      ""      {""+      ""        \""name\"": \""test_logger\"",""+      ""        \""is_optional\"": 123,""+      ""        \""config\"": {}""+      ""      }""+      ""    ]""+      ""  }""+      ""}"";+  auto rbacs = GenerateRbacPolicies(authz_policy);+  EXPECT_EQ(rbacs.status().code(), absl::StatusCode::kInvalidArgument);+  EXPECT_THAT(rbacs.status().message(),+              ""\""audit_loggers[0].is_optional\"" is not a boolean."");+}++TEST_F(GenerateRbacPoliciesTest, MissingAuditLoggerName) {+  const char* authz_policy =+      ""{""+      ""  \""name\"": \""authz\"",""+      ""  \""allow_rules\"": [""+      ""    {""+      ""      \""name\"": \""allow_policy\""""+      ""    }""+      ""  ],""+      ""  \""audit_logging_options\"": {""+      ""    \""audit_loggers\"": [""+      ""      {""+      ""        \""config\"": {}""+      ""      }""+      ""    ]""+      ""  }""+      ""}"";+  auto rbacs = GenerateRbacPolicies(authz_policy);+  EXPECT_EQ(rbacs.status().code(), absl::StatusCode::kInvalidArgument);+  EXPECT_THAT(rbacs.status().message(),+              ""\""audit_loggers[0].name\"" is required."");+}++TEST_F(GenerateRbacPoliciesTest, MissingAuditLoggerConfig) {+  const char* authz_policy =+      ""{""+      ""  \""name\"": \""authz\"",""+      ""  \""allow_rules\"": [""+      ""    {""+      ""      \""name\"": \""allow_policy\""""+      ""    }""+      ""  ],""+      ""  \""audit_logging_options\"": {""+      ""    \""audit_loggers\"": [""+      ""      {""+      ""        \""name\"": \""test_logger\""""+      ""      }""+      ""    ]""+      ""  }""+      ""}"";+  auto rbacs = GenerateRbacPolicies(authz_policy);+  EXPECT_EQ(rbacs.status().code(), absl::StatusCode::kInvalidArgument);+  EXPECT_THAT(rbacs.status().message(),+              ""\""audit_loggers[0].config\"" is required."");+}++TEST_F(GenerateRbacPoliciesTest, UnsupportedAuditLogger) {+  const char* authz_policy =+      ""{""+      ""  \""name\"": \""authz\"",""+      ""  \""allow_rules\"": [""+      ""    {""+      ""      \""name\"": \""allow_policy\""""+      ""    }""+      ""  ],""+      ""  \""audit_logging_options\"": {""+      ""    \""audit_loggers\"": [""+      ""      {""+      ""        \""name\"": \""unknown_logger\"",""+      ""        \""config\"": {}""+      ""      }""+      ""    ]""+      ""  }""+      ""}"";+  auto rbacs = GenerateRbacPolicies(authz_policy);+  EXPECT_EQ(rbacs.status().code(), absl::StatusCode::kInvalidArgument);+  EXPECT_THAT(rbacs.status().message(),+              ""\""audit_loggers[0].name\"" unknown_logger is not supported."");+}+",Can you add a test that exercises the path for `NONE` as the audit condition?,
7221003,rockspore,https://api.github.com/repos/grpc/grpc/pulls/32944,1178505174,2023-04-27T00:11:17Z,src/core/lib/security/authorization/rbac_translator.cc,"@@ -328,24 +335,140 @@ absl::StatusOr<std::map<std::string, Rbac::Policy>> ParseRulesArray(           policy_or.status().code(),           absl::StrCat(""rules "", i, "": "", policy_or.status().message()));     }-    policies[std::string(name) + ""_"" + policy_name] =-        std::move(policy_or.value());+    policies[policy_name] = std::move(policy_or.value());   }   return std::move(policies); }  absl::StatusOr<Rbac> ParseDenyRulesArray(const Json& json,                                          absl::string_view name) {-  auto policies_or = ParseRulesArray(json, name);+  auto policies_or = ParseRulesArray(json);   if (!policies_or.ok()) return policies_or.status();-  return Rbac(Rbac::Action::kDeny, std::move(policies_or.value()));+  return Rbac(Rbac::Action::kDeny, std::move(policies_or.value()), name); }  absl::StatusOr<Rbac> ParseAllowRulesArray(const Json& json,                                           absl::string_view name) {-  auto policies_or = ParseRulesArray(json, name);+  auto policies_or = ParseRulesArray(json);   if (!policies_or.ok()) return policies_or.status();-  return Rbac(Rbac::Action::kAllow, std::move(policies_or.value()));+  return Rbac(Rbac::Action::kAllow, std::move(policies_or.value()), name);+}++absl::StatusOr<std::unique_ptr<experimental::AuditLoggerFactory::Config>>+ParseAuditLogger(const Json& json, size_t pos) {+  if (json.type() != Json::Type::kObject) {+    return absl::InvalidArgumentError(+        absl::StrFormat(""\""audit_loggers[%d]\"" is not an object."", pos));+  }+  bool is_optional = false;+  auto it = json.object().find(""is_optional"");+  if (it != json.object().end()) {+    switch (it->second.type()) {+      case Json::Type::kTrue:+        is_optional = true;+        break;+      case Json::Type::kFalse:+        break;+      default:+        return absl::InvalidArgumentError(absl::StrFormat(+            ""\""audit_loggers[%d].is_optional\"" is not a boolean."", pos));+    }+  }+  it = json.object().find(""name"");+  if (it == json.object().end()) {+    return absl::InvalidArgumentError(+        absl::StrFormat(""\""audit_loggers[%d].name\"" is required."", pos));+  }+  if (it->second.type() != Json::Type::kString) {+    return absl::InvalidArgumentError(+        absl::StrFormat(""\""audit_loggers[%d].name\"" is not a string."", pos));+  }+  absl::string_view name = it->second.string();+  Json config;+  it = json.object().find(""config"");+  if (it != json.object().end()) {+    if (it->second.type() != Json::Type::kObject) {+      return absl::InvalidArgumentError(absl::StrFormat(+          ""\""audit_loggers[%d].config\"" is not an object."", pos));+    }+    config = it->second;+  } else {+    return absl::InvalidArgumentError(+        absl::StrFormat(""\""audit_loggers[%d].config\"" is required."", pos));+  }+  if (!AuditLoggerRegistry::FactoryExists(name)) {+    if (is_optional) {+      return nullptr;+    }+    return absl::InvalidArgumentError(absl::StrFormat(+        ""\""audit_loggers[%d].name\"" %s is not supported."", pos, name));",We do not expose `AuditLoggerRegistry` class as a public API. There is only a namespace function `RegisterAuditLoggerFactory`. So I don't think we want to reveal the implementation details in the error message. I changed to `... is not supported natively or registered`. Let me know what you think.,
7221003,rockspore,https://api.github.com/repos/grpc/grpc/pulls/32944,1178510051,2023-04-27T00:21:01Z,test/core/security/rbac_translator_test.cc,"@@ -984,6 +1038,347 @@ TEST(GenerateRbacPoliciesTest, UnknownFieldInHeaders) {               ""\""foo\"".""); } +TEST_F(GenerateRbacPoliciesTest, AuditConditionOnDeny) {+  const char* authz_policy =+      ""{""+      ""  \""name\"": \""authz\"",""+      ""  \""allow_rules\"": [""+      ""    {""+      ""      \""name\"": \""allow_policy\""""+      ""    }""+      ""  ],""+      ""  \""deny_rules\"": [""+      ""    {""+      ""      \""name\"": \""deny_policy\""""+      ""    }""+      ""  ],""+      ""  \""audit_logging_options\"": {""+      ""    \""audit_condition\"": \""ON_DENY\""""+      ""  }""+      ""}"";+  auto rbacs = GenerateRbacPolicies(authz_policy);+  ASSERT_TRUE(rbacs.ok());+  EXPECT_EQ(rbacs->allow_policy.name, ""authz"");+  EXPECT_EQ(rbacs->deny_policy->name, ""authz"");+  EXPECT_EQ(rbacs->allow_policy.audit_condition, Rbac::AuditCondition::kOnDeny);+  EXPECT_EQ(rbacs->deny_policy->audit_condition, Rbac::AuditCondition::kOnDeny);+}++TEST_F(GenerateRbacPoliciesTest, AuditConditionOnAllowWithAuditLogger) {+  const char* authz_policy =+      ""{""+      ""  \""name\"": \""authz\"",""+      ""  \""allow_rules\"": [""+      ""    {""+      ""      \""name\"": \""allow_policy\""""+      ""    }""+      ""  ],""+      ""  \""deny_rules\"": [""+      ""    {""+      ""      \""name\"": \""deny_policy\""""+      ""    }""+      ""  ],""+      ""  \""audit_logging_options\"": {""+      ""    \""audit_condition\"": \""ON_ALLOW\"",""+      ""    \""audit_loggers\"": [""+      ""      {""+      ""        \""name\"": \""test_logger\"",""+      ""        \""config\"": {}""+      ""      }""+      ""    ]""+      ""  }""+      ""}"";+  auto rbacs = GenerateRbacPolicies(authz_policy);+  std::cout << rbacs.status().message() << std::endl;+  ASSERT_TRUE(rbacs.ok());+  EXPECT_EQ(rbacs->allow_policy.name, ""authz"");+  EXPECT_EQ(rbacs->deny_policy->name, ""authz"");+  EXPECT_EQ(rbacs->allow_policy.audit_condition,+            Rbac::AuditCondition::kOnAllow);+  EXPECT_EQ(rbacs->deny_policy->audit_condition, Rbac::AuditCondition::kNone);+  ASSERT_EQ(rbacs->allow_policy.logger_configs.size(), 1);+  EXPECT_EQ(rbacs->deny_policy->logger_configs.size(), 0);+  EXPECT_EQ(rbacs->allow_policy.logger_configs.at(0)->name(), kLoggerName);+}++TEST_F(GenerateRbacPoliciesTest,+       AuditConditionOnDenyAndAllowWithUnsupportedButOptionalLogger) {+  const char* authz_policy =+      ""{""+      ""  \""name\"": \""authz\"",""+      ""  \""allow_rules\"": [""+      ""    {""+      ""      \""name\"": \""allow_policy\""""+      ""    }""+      ""  ],""+      ""  \""deny_rules\"": [""+      ""    {""+      ""      \""name\"": \""deny_policy\""""+      ""    }""+      ""  ],""+      ""  \""audit_logging_options\"": {""+      ""    \""audit_condition\"": \""ON_DENY_AND_ALLOW\"",""+      ""    \""audit_loggers\"": [""+      ""      {""+      ""        \""name\"": \""unknown_logger\"",""+      ""        \""is_optional\"": true,""+      ""        \""config\"": {}""+      ""      }""+      ""    ]""+      ""  }""+      ""}"";+  auto rbacs = GenerateRbacPolicies(authz_policy);+  ASSERT_TRUE(rbacs.ok());+  EXPECT_EQ(rbacs->allow_policy.name, ""authz"");+  EXPECT_EQ(rbacs->deny_policy->name, ""authz"");+  EXPECT_EQ(rbacs->allow_policy.audit_condition,+            Rbac::AuditCondition::kOnDenyAndAllow);+  EXPECT_EQ(rbacs->deny_policy->audit_condition, Rbac::AuditCondition::kOnDeny);+  EXPECT_EQ(rbacs->allow_policy.logger_configs.size(), 0);+  EXPECT_EQ(rbacs->deny_policy->logger_configs.size(), 0);+}++TEST_F(GenerateRbacPoliciesTest, AuditConditionIsNotString) {+  const char* authz_policy =+      ""{""+      ""  \""name\"": \""authz\"",""+      ""  \""allow_rules\"": [""+      ""    {""+      ""      \""name\"": \""allow_policy\""""+      ""    }""+      ""  ],""+      ""  \""audit_logging_options\"": {""+      ""    \""audit_condition\"": 123""+      ""  }""+      ""}"";+  auto rbacs = GenerateRbacPolicies(authz_policy);+  EXPECT_EQ(rbacs.status().code(), absl::StatusCode::kInvalidArgument);+  EXPECT_THAT(rbacs.status().message(), ""\""audit_condition\"" is not a string."");+}++TEST_F(GenerateRbacPoliciesTest, IncorrectAuditConditionValue) {+  const char* authz_policy =+      ""{""+      ""  \""name\"": \""authz\"",""+      ""  \""allow_rules\"": [""+      ""    {""+      ""      \""name\"": \""allow_policy\""""+      ""    }""+      ""  ],""+      ""  \""audit_logging_options\"": {""+      ""    \""audit_condition\"": \""UNKNOWN\""""+      ""  }""+      ""}"";+  auto rbacs = GenerateRbacPolicies(authz_policy);+  EXPECT_EQ(rbacs.status().code(), absl::StatusCode::kInvalidArgument);+  EXPECT_THAT(rbacs.status().message(),+              ""Unsupported \""audit_condition\"" value UNKNOWN."");+}++TEST_F(GenerateRbacPoliciesTest, IncorrectAuditLoggersType) {+  const char* authz_policy =+      ""{""+      ""  \""name\"": \""authz\"",""+      ""  \""allow_rules\"": [""+      ""    {""+      ""      \""name\"": \""allow_policy\""""+      ""    }""+      ""  ],""+      ""  \""audit_logging_options\"": {""+      ""    \""audit_loggers\"": 123""+      ""  }""+      ""}"";+  auto rbacs = GenerateRbacPolicies(authz_policy);+  EXPECT_EQ(rbacs.status().code(), absl::StatusCode::kInvalidArgument);+  EXPECT_THAT(rbacs.status().message(), ""\""audit_loggers\"" is not an array."");+}++TEST_F(GenerateRbacPoliciesTest, IncorrectAuditLoggerType) {+  const char* authz_policy =+      ""{""+      ""  \""name\"": \""authz\"",""+      ""  \""allow_rules\"": [""+      ""    {""+      ""      \""name\"": \""allow_policy\""""+      ""    }""+      ""  ],""+      ""  \""audit_logging_options\"": {""+      ""    \""audit_loggers\"": [123]""+      ""  }""+      ""}"";+  auto rbacs = GenerateRbacPolicies(authz_policy);+  EXPECT_EQ(rbacs.status().code(), absl::StatusCode::kInvalidArgument);+  EXPECT_THAT(rbacs.status().message(),+              ""\""audit_loggers[0]\"" is not an object."");+}++TEST_F(GenerateRbacPoliciesTest, IncorrectAuditLoggerConfigType) {+  const char* authz_policy =+      ""{""+      ""  \""name\"": \""authz\"",""+      ""  \""allow_rules\"": [""+      ""    {""+      ""      \""name\"": \""allow_policy\""""+      ""    }""+      ""  ],""+      ""  \""audit_logging_options\"": {""+      ""    \""audit_loggers\"": [""+      ""      {""+      ""        \""name\"": \""unknown_logger\"",""+      ""        \""config\"": 123""+      ""      }""+      ""    ]""+      ""  }""+      ""}"";+  auto rbacs = GenerateRbacPolicies(authz_policy);+  EXPECT_EQ(rbacs.status().code(), absl::StatusCode::kInvalidArgument);+  EXPECT_THAT(rbacs.status().message(),+              ""\""audit_loggers[0].config\"" is not an object."");+}++TEST_F(GenerateRbacPoliciesTest, BadAuditLoggerConfig) {+  const char* authz_policy =+      ""{""+      ""  \""name\"": \""authz\"",""+      ""  \""allow_rules\"": [""+      ""    {""+      ""      \""name\"": \""allow_policy\""""+      ""    }""+      ""  ],""+      ""  \""audit_logging_options\"": {""+      ""    \""audit_loggers\"": [""+      ""      {""+      ""        \""name\"": \""test_logger\"",""+      ""        \""config\"": {\""bad\"": true}""+      ""      }""+      ""    ]""+      ""  }""+      ""}"";+  auto rbacs = GenerateRbacPolicies(authz_policy);+  EXPECT_EQ(rbacs.status().code(), absl::StatusCode::kInvalidArgument);+  EXPECT_THAT(rbacs.status().message(),+              ""\""audit_loggers[0]\"" bad logger config."");+}++TEST_F(GenerateRbacPoliciesTest, IncorrectAuditLoggerNameType) {+  const char* authz_policy =+      ""{""+      ""  \""name\"": \""authz\"",""+      ""  \""allow_rules\"": [""+      ""    {""+      ""      \""name\"": \""allow_policy\""""+      ""    }""+      ""  ],""+      ""  \""audit_logging_options\"": {""+      ""    \""audit_loggers\"": [""+      ""      {""+      ""        \""name\"": 123,""+      ""        \""config\"": {}""+      ""      }""+      ""    ]""+      ""  }""+      ""}"";+  auto rbacs = GenerateRbacPolicies(authz_policy);+  EXPECT_EQ(rbacs.status().code(), absl::StatusCode::kInvalidArgument);+  EXPECT_THAT(rbacs.status().message(),+              ""\""audit_loggers[0].name\"" is not a string."");+}++TEST_F(GenerateRbacPoliciesTest, IncorrectAuditLoggerIsOptionalType) {+  const char* authz_policy =+      ""{""+      ""  \""name\"": \""authz\"",""+      ""  \""allow_rules\"": [""+      ""    {""+      ""      \""name\"": \""allow_policy\""""+      ""    }""+      ""  ],""+      ""  \""audit_logging_options\"": {""+      ""    \""audit_loggers\"": [""+      ""      {""+      ""        \""name\"": \""test_logger\"",""+      ""        \""is_optional\"": 123,""+      ""        \""config\"": {}""+      ""      }""+      ""    ]""+      ""  }""+      ""}"";+  auto rbacs = GenerateRbacPolicies(authz_policy);+  EXPECT_EQ(rbacs.status().code(), absl::StatusCode::kInvalidArgument);+  EXPECT_THAT(rbacs.status().message(),+              ""\""audit_loggers[0].is_optional\"" is not a boolean."");+}++TEST_F(GenerateRbacPoliciesTest, MissingAuditLoggerName) {+  const char* authz_policy =+      ""{""+      ""  \""name\"": \""authz\"",""+      ""  \""allow_rules\"": [""+      ""    {""+      ""      \""name\"": \""allow_policy\""""+      ""    }""+      ""  ],""+      ""  \""audit_logging_options\"": {""+      ""    \""audit_loggers\"": [""+      ""      {""+      ""        \""config\"": {}""+      ""      }""+      ""    ]""+      ""  }""+      ""}"";+  auto rbacs = GenerateRbacPolicies(authz_policy);+  EXPECT_EQ(rbacs.status().code(), absl::StatusCode::kInvalidArgument);+  EXPECT_THAT(rbacs.status().message(),+              ""\""audit_loggers[0].name\"" is required."");+}++TEST_F(GenerateRbacPoliciesTest, MissingAuditLoggerConfig) {+  const char* authz_policy =+      ""{""+      ""  \""name\"": \""authz\"",""+      ""  \""allow_rules\"": [""+      ""    {""+      ""      \""name\"": \""allow_policy\""""+      ""    }""+      ""  ],""+      ""  \""audit_logging_options\"": {""+      ""    \""audit_loggers\"": [""+      ""      {""+      ""        \""name\"": \""test_logger\""""+      ""      }""+      ""    ]""+      ""  }""+      ""}"";+  auto rbacs = GenerateRbacPolicies(authz_policy);+  EXPECT_EQ(rbacs.status().code(), absl::StatusCode::kInvalidArgument);+  EXPECT_THAT(rbacs.status().message(),+              ""\""audit_loggers[0].config\"" is required."");+}++TEST_F(GenerateRbacPoliciesTest, UnsupportedAuditLogger) {+  const char* authz_policy =+      ""{""+      ""  \""name\"": \""authz\"",""+      ""  \""allow_rules\"": [""+      ""    {""+      ""      \""name\"": \""allow_policy\""""+      ""    }""+      ""  ],""+      ""  \""audit_logging_options\"": {""+      ""    \""audit_loggers\"": [""+      ""      {""+      ""        \""name\"": \""unknown_logger\"",""+      ""        \""config\"": {}""+      ""      }""+      ""    ]""+      ""  }""+      ""}"";+  auto rbacs = GenerateRbacPolicies(authz_policy);+  EXPECT_EQ(rbacs.status().code(), absl::StatusCode::kInvalidArgument);+  EXPECT_THAT(rbacs.status().message(),+              ""\""audit_loggers[0].name\"" unknown_logger is not supported."");+}+","This bad config test verifies that `{""bad"":  true}` is passed into the parser appropriately, since `bad` is found by it. It also confirms that the translator can propagate the error from the parser properly. IMO, this should suffice as a unit test for the rbac translator.Parsing valid config and returning a good logger is something the factory/registry unit test should do. I think we need to do that for our built-in loggers.",
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/32701,1178511124,2023-04-27T00:23:36Z,src/core/BUILD,"@@ -2209,6 +2210,54 @@ grpc_cc_library(     ], ) +grpc_cc_library(+    name = ""grpc_ares_wrapper"",+    srcs = [+        ""lib/event_engine/grpc_ares_wrapper.cc"",+        ""lib/event_engine/nameser.h"",+        ""lib/event_engine/grpc_polled_fd.h"",+    ],+    hdrs = [+        ""lib/event_engine/grpc_ares_wrapper.h"",+        ""lib/event_engine/posix_engine/grpc_polled_fd_posix.h"",+    ],+    external_deps = [+        ""absl/base:core_headers"",+        ""absl/cleanup"",+        ""absl/functional:any_invocable"",+        ""absl/status"",+        ""absl/strings"",+        ""absl/strings:str_format"",+        ""absl/types:optional"",+        ""address_sorting"",+        ""cares"",+    ],+    deps = [+        ""error"",+        ""event_engine_tcp_socket_utils"",+        ""event_engine_time_util"",+        ""examine_stack"",+        ""grpc_sockaddr"",+        ""iomgr_port"",+        ""posix_event_engine_tcp_socket_utils"",+        ""posix_event_engine_closure"",+        ""posix_event_engine_event_poller"",+        ""ref_counted"",+        ""resolved_address"",+        ""status_helper"",+        ""windows_iocp"",",this dependency shouldn't be necessary (yet). See fix_build_deps.py,
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/32701,1178516539,2023-04-27T00:36:25Z,src/core/lib/event_engine/grpc_ares_wrapper.h,"@@ -0,0 +1,309 @@+// Copyright 2023 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+#ifndef GRPC_SRC_CORE_LIB_EVENT_ENGINE_GRPC_ARES_WRAPPER_H+#define GRPC_SRC_CORE_LIB_EVENT_ENGINE_GRPC_ARES_WRAPPER_H++#include <grpc/support/port_platform.h>++#include <stddef.h>  // for size_t++#include <memory>+#include <string>+#include <vector>++#include <ares.h>++#include ""absl/base/thread_annotations.h""+#include ""absl/functional/any_invocable.h""+#include ""absl/status/status.h""+#include ""absl/status/statusor.h""+#include ""absl/strings/string_view.h""+#include ""absl/types/optional.h""++#include <grpc/event_engine/event_engine.h>+#include <grpc/support/log.h>++#include ""src/core/lib/debug/trace.h""+#include ""src/core/lib/gprpp/orphanable.h""+#include ""src/core/lib/gprpp/sync.h""+#include ""src/core/lib/iomgr/port.h""++namespace grpc_event_engine {+namespace experimental {++extern grpc_core::TraceFlag grpc_trace_ares_wrapper;++#define GRPC_ARES_WRAPPER_TRACE_LOG(format, ...)                              \+  do {                                                                        \+    if (GRPC_TRACE_FLAG_ENABLED(grpc_trace_ares_wrapper)) {                   \+      gpr_log(GPR_INFO, ""(EventEngine c-ares wrapper) "" format, __VA_ARGS__); \+    }                                                                         \+  } while (0)++class GrpcPolledFd;+class GrpcPolledFdFactory;++class GrpcAresRequest+    : public grpc_core::InternallyRefCounted<GrpcAresRequest> {+ public:+  ~GrpcAresRequest() override;++  bool Cancel() ABSL_LOCKS_EXCLUDED(mu_);+  void Orphan() override {}++ protected:+  absl::Status Initialize(absl::string_view dns_server, bool check_port)+      ABSL_LOCKS_EXCLUDED(mu_);++  GrpcAresRequest(absl::string_view name,+                  absl::optional<absl::string_view> default_port,","The base class does not need to know about a default_port, it only matters to hostname lookups. This is in the wrong abstraction layer.",X
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/32701,1178517522,2023-04-27T00:38:55Z,src/core/lib/event_engine/grpc_ares_wrapper.h,"@@ -0,0 +1,309 @@+// Copyright 2023 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+#ifndef GRPC_SRC_CORE_LIB_EVENT_ENGINE_GRPC_ARES_WRAPPER_H+#define GRPC_SRC_CORE_LIB_EVENT_ENGINE_GRPC_ARES_WRAPPER_H++#include <grpc/support/port_platform.h>++#include <stddef.h>  // for size_t++#include <memory>+#include <string>+#include <vector>++#include <ares.h>++#include ""absl/base/thread_annotations.h""+#include ""absl/functional/any_invocable.h""+#include ""absl/status/status.h""+#include ""absl/status/statusor.h""+#include ""absl/strings/string_view.h""+#include ""absl/types/optional.h""++#include <grpc/event_engine/event_engine.h>+#include <grpc/support/log.h>++#include ""src/core/lib/debug/trace.h""+#include ""src/core/lib/gprpp/orphanable.h""+#include ""src/core/lib/gprpp/sync.h""+#include ""src/core/lib/iomgr/port.h""++namespace grpc_event_engine {+namespace experimental {++extern grpc_core::TraceFlag grpc_trace_ares_wrapper;++#define GRPC_ARES_WRAPPER_TRACE_LOG(format, ...)                              \+  do {                                                                        \+    if (GRPC_TRACE_FLAG_ENABLED(grpc_trace_ares_wrapper)) {                   \+      gpr_log(GPR_INFO, ""(EventEngine c-ares wrapper) "" format, __VA_ARGS__); \+    }                                                                         \+  } while (0)++class GrpcPolledFd;+class GrpcPolledFdFactory;++class GrpcAresRequest+    : public grpc_core::InternallyRefCounted<GrpcAresRequest> {+ public:+  ~GrpcAresRequest() override;++  bool Cancel() ABSL_LOCKS_EXCLUDED(mu_);+  void Orphan() override {}++ protected:+  absl::Status Initialize(absl::string_view dns_server, bool check_port)+      ABSL_LOCKS_EXCLUDED(mu_);++  GrpcAresRequest(absl::string_view name,+                  absl::optional<absl::string_view> default_port,+                  EventEngine::Duration timeout,+                  std::unique_ptr<GrpcPolledFdFactory> polled_fd_factory,+                  EventEngine* event_engine);++  void Work() ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu_);+  void StartTimers() ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu_);+  void CancelTimers() ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu_);++ private:+  struct FdNode {","Please document. Here and elsewhere, especially class, method, and function purposes. Member variables as well if their purposes are not obvious.",
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/32701,1178520153,2023-04-27T00:45:42Z,src/core/lib/event_engine/grpc_ares_wrapper.h,"@@ -0,0 +1,309 @@+// Copyright 2023 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+#ifndef GRPC_SRC_CORE_LIB_EVENT_ENGINE_GRPC_ARES_WRAPPER_H+#define GRPC_SRC_CORE_LIB_EVENT_ENGINE_GRPC_ARES_WRAPPER_H++#include <grpc/support/port_platform.h>++#include <stddef.h>  // for size_t++#include <memory>+#include <string>+#include <vector>++#include <ares.h>++#include ""absl/base/thread_annotations.h""+#include ""absl/functional/any_invocable.h""+#include ""absl/status/status.h""+#include ""absl/status/statusor.h""+#include ""absl/strings/string_view.h""+#include ""absl/types/optional.h""++#include <grpc/event_engine/event_engine.h>+#include <grpc/support/log.h>++#include ""src/core/lib/debug/trace.h""+#include ""src/core/lib/gprpp/orphanable.h""+#include ""src/core/lib/gprpp/sync.h""+#include ""src/core/lib/iomgr/port.h""++namespace grpc_event_engine {+namespace experimental {++extern grpc_core::TraceFlag grpc_trace_ares_wrapper;++#define GRPC_ARES_WRAPPER_TRACE_LOG(format, ...)                              \+  do {                                                                        \+    if (GRPC_TRACE_FLAG_ENABLED(grpc_trace_ares_wrapper)) {                   \+      gpr_log(GPR_INFO, ""(EventEngine c-ares wrapper) "" format, __VA_ARGS__); \+    }                                                                         \+  } while (0)++class GrpcPolledFd;+class GrpcPolledFdFactory;++class GrpcAresRequest+    : public grpc_core::InternallyRefCounted<GrpcAresRequest> {+ public:+  ~GrpcAresRequest() override;++  bool Cancel() ABSL_LOCKS_EXCLUDED(mu_);+  void Orphan() override {}++ protected:+  absl::Status Initialize(absl::string_view dns_server, bool check_port)+      ABSL_LOCKS_EXCLUDED(mu_);++  GrpcAresRequest(absl::string_view name,+                  absl::optional<absl::string_view> default_port,+                  EventEngine::Duration timeout,+                  std::unique_ptr<GrpcPolledFdFactory> polled_fd_factory,+                  EventEngine* event_engine);++  void Work() ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu_);+  void StartTimers() ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu_);+  void CancelTimers() ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu_);++ private:+  struct FdNode {+    FdNode() = default;+    FdNode(ares_socket_t as, GrpcPolledFd* polled_fd);+    ares_socket_t as;+    std::unique_ptr<GrpcPolledFd> polled_fd;+    // next fd node+    FdNode* next = nullptr;+    /// if the readable closure has been registered+    bool readable_registered = false;+    /// if the writable closure has been registered+    bool writable_registered = false;+    bool already_shutdown = false;+  };++  // Per ares_channel linked-list of FdNodes+  class FdNodeList {+   public:+    class FdNodeListIterator {+     public:+      bool operator!=(const FdNodeListIterator& other) {+        return node_ != other.node_;+      }+      bool operator==(const FdNodeListIterator& other) {+        return node_ == other.node_;+      }+      FdNodeListIterator& operator++(int) {+        node_ = node_->next;+        return *this;+      }+      FdNode* operator*() { return node_; }+      static FdNodeListIterator universal_end() {+        return FdNodeListIterator(nullptr);+      }++     private:+      friend class FdNodeList;+      explicit FdNodeListIterator(FdNode* node) : node_(node) {}+      FdNode* node_;+    };+    using Iterator = FdNodeListIterator;++    ~FdNodeList() { GPR_ASSERT(IsEmpty()); }++    Iterator begin() { return Iterator(head_); }+    Iterator end() { return Iterator::universal_end(); }++    bool IsEmpty() const { return head_ == nullptr; }++    void PushFdNode(FdNode* fd_node) ABSL_EXCLUSIVE_LOCKS_REQUIRED(&mu_) {+      fd_node->next = head_;+      head_ = fd_node;+    }++    FdNode* PopFdNode() ABSL_EXCLUSIVE_LOCKS_REQUIRED(&mu_) {+      GPR_ASSERT(!IsEmpty());+      FdNode* ret = head_;+      head_ = head_->next;+      return ret;+    }++    // Search for as in the FdNode list. This is an O(n) search, the max+    // possible value of n is ARES_GETSOCK_MAXNUM (16). n is typically 1 - 2+    // in our tests.+    FdNode* PopFdNode(ares_socket_t as) ABSL_EXCLUSIVE_LOCKS_REQUIRED(&mu_);++   private:+    FdNode* head_ = nullptr;+  };+  friend class GrpcPolledFdFactory;++  absl::Status SetRequestDNSServer(absl::string_view dns_server)+      ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu_);+  void OnReadable(FdNode* fd_node, absl::Status status)+      ABSL_LOCKS_EXCLUDED(mu_);+  void OnWritable(FdNode* fd_node, absl::Status status)+      ABSL_LOCKS_EXCLUDED(mu_);+  void OnHandleDestroyed(FdNode* fd_node, absl::Status status)+      ABSL_LOCKS_EXCLUDED(mu_);+  void OnQueryTimeout() ABSL_LOCKS_EXCLUDED(mu_);+  void OnAresBackupPollAlarm() ABSL_LOCKS_EXCLUDED(mu_);+  void ShutdownPolledFdsLocked(absl::Status status)+      ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu_);++ protected:+  grpc_core::Mutex mu_;+  bool initialized_ ABSL_GUARDED_BY(mu_) = false;+  /// name to resolve","There are inconsistent uses of `///` and `//` throughout this PR. Since we aren't generating docs from these classes, `//` should suffice.",
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/32701,1178521851,2023-04-27T00:49:58Z,src/core/lib/event_engine/grpc_ares_wrapper.h,"@@ -0,0 +1,309 @@+// Copyright 2023 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+#ifndef GRPC_SRC_CORE_LIB_EVENT_ENGINE_GRPC_ARES_WRAPPER_H+#define GRPC_SRC_CORE_LIB_EVENT_ENGINE_GRPC_ARES_WRAPPER_H++#include <grpc/support/port_platform.h>++#include <stddef.h>  // for size_t++#include <memory>+#include <string>+#include <vector>++#include <ares.h>++#include ""absl/base/thread_annotations.h""+#include ""absl/functional/any_invocable.h""+#include ""absl/status/status.h""+#include ""absl/status/statusor.h""+#include ""absl/strings/string_view.h""+#include ""absl/types/optional.h""++#include <grpc/event_engine/event_engine.h>+#include <grpc/support/log.h>++#include ""src/core/lib/debug/trace.h""+#include ""src/core/lib/gprpp/orphanable.h""+#include ""src/core/lib/gprpp/sync.h""+#include ""src/core/lib/iomgr/port.h""++namespace grpc_event_engine {+namespace experimental {++extern grpc_core::TraceFlag grpc_trace_ares_wrapper;++#define GRPC_ARES_WRAPPER_TRACE_LOG(format, ...)                              \+  do {                                                                        \+    if (GRPC_TRACE_FLAG_ENABLED(grpc_trace_ares_wrapper)) {                   \+      gpr_log(GPR_INFO, ""(EventEngine c-ares wrapper) "" format, __VA_ARGS__); \+    }                                                                         \+  } while (0)++class GrpcPolledFd;+class GrpcPolledFdFactory;++class GrpcAresRequest+    : public grpc_core::InternallyRefCounted<GrpcAresRequest> {+ public:+  ~GrpcAresRequest() override;++  bool Cancel() ABSL_LOCKS_EXCLUDED(mu_);+  void Orphan() override {}++ protected:+  absl::Status Initialize(absl::string_view dns_server, bool check_port)+      ABSL_LOCKS_EXCLUDED(mu_);++  GrpcAresRequest(absl::string_view name,+                  absl::optional<absl::string_view> default_port,+                  EventEngine::Duration timeout,+                  std::unique_ptr<GrpcPolledFdFactory> polled_fd_factory,+                  EventEngine* event_engine);++  void Work() ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu_);+  void StartTimers() ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu_);+  void CancelTimers() ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu_);++ private:+  struct FdNode {+    FdNode() = default;+    FdNode(ares_socket_t as, GrpcPolledFd* polled_fd);+    ares_socket_t as;+    std::unique_ptr<GrpcPolledFd> polled_fd;+    // next fd node+    FdNode* next = nullptr;+    /// if the readable closure has been registered+    bool readable_registered = false;+    /// if the writable closure has been registered+    bool writable_registered = false;+    bool already_shutdown = false;+  };++  // Per ares_channel linked-list of FdNodes+  class FdNodeList {+   public:+    class FdNodeListIterator {+     public:+      bool operator!=(const FdNodeListIterator& other) {+        return node_ != other.node_;+      }+      bool operator==(const FdNodeListIterator& other) {+        return node_ == other.node_;+      }+      FdNodeListIterator& operator++(int) {+        node_ = node_->next;+        return *this;+      }+      FdNode* operator*() { return node_; }+      static FdNodeListIterator universal_end() {+        return FdNodeListIterator(nullptr);+      }++     private:+      friend class FdNodeList;+      explicit FdNodeListIterator(FdNode* node) : node_(node) {}+      FdNode* node_;+    };+    using Iterator = FdNodeListIterator;++    ~FdNodeList() { GPR_ASSERT(IsEmpty()); }++    Iterator begin() { return Iterator(head_); }+    Iterator end() { return Iterator::universal_end(); }++    bool IsEmpty() const { return head_ == nullptr; }++    void PushFdNode(FdNode* fd_node) ABSL_EXCLUSIVE_LOCKS_REQUIRED(&mu_) {+      fd_node->next = head_;+      head_ = fd_node;+    }++    FdNode* PopFdNode() ABSL_EXCLUSIVE_LOCKS_REQUIRED(&mu_) {+      GPR_ASSERT(!IsEmpty());+      FdNode* ret = head_;+      head_ = head_->next;+      return ret;+    }++    // Search for as in the FdNode list. This is an O(n) search, the max+    // possible value of n is ARES_GETSOCK_MAXNUM (16). n is typically 1 - 2+    // in our tests.+    FdNode* PopFdNode(ares_socket_t as) ABSL_EXCLUSIVE_LOCKS_REQUIRED(&mu_);++   private:+    FdNode* head_ = nullptr;+  };+  friend class GrpcPolledFdFactory;++  absl::Status SetRequestDNSServer(absl::string_view dns_server)+      ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu_);+  void OnReadable(FdNode* fd_node, absl::Status status)+      ABSL_LOCKS_EXCLUDED(mu_);+  void OnWritable(FdNode* fd_node, absl::Status status)+      ABSL_LOCKS_EXCLUDED(mu_);+  void OnHandleDestroyed(FdNode* fd_node, absl::Status status)+      ABSL_LOCKS_EXCLUDED(mu_);+  void OnQueryTimeout() ABSL_LOCKS_EXCLUDED(mu_);+  void OnAresBackupPollAlarm() ABSL_LOCKS_EXCLUDED(mu_);+  void ShutdownPolledFdsLocked(absl::Status status)+      ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu_);++ protected:+  grpc_core::Mutex mu_;+  bool initialized_ ABSL_GUARDED_BY(mu_) = false;+  /// name to resolve+  const std::string name_ ABSL_GUARDED_BY(mu_);+  const std::string default_port_ ABSL_GUARDED_BY(mu_);+  // ares channel+  ares_channel channel_ ABSL_GUARDED_BY(mu_) = nullptr;+  /// host to resolve, parsed from name_+  absl::string_view host_ ABSL_GUARDED_BY(mu_);+  /// port, parsed from name_ or is default_port_+  int port_ ABSL_GUARDED_BY(mu_) = 0;+  bool shutting_down_ ABSL_GUARDED_BY(mu_) = false;+  bool cancelled_ ABSL_GUARDED_BY(mu_) = false;+  std::unique_ptr<FdNodeList> fd_node_list_ ABSL_GUARDED_BY(mu_);+  const EventEngine::Duration timeout_ ABSL_GUARDED_BY(mu_);+  absl::optional<EventEngine::TaskHandle> query_timeout_handle_+      ABSL_GUARDED_BY(mu_);+  absl::optional<EventEngine::TaskHandle> ares_backup_poll_alarm_handle_+      ABSL_GUARDED_BY(mu_);+  EventEngine* event_engine_;+  std::unique_ptr<GrpcPolledFdFactory> polled_fd_factory_ ABSL_GUARDED_BY(mu_);+};++// A GrpcAresHostnameRequest represents both ""A"" and ""AAAA"" (if available)+// lookup+class GrpcAresHostnameRequest final : public GrpcAresRequest {+ public:+  using Result = std::vector<EventEngine::ResolvedAddress>;++  static absl::StatusOr<GrpcAresHostnameRequest*> Create(+      absl::string_view name, absl::string_view default_port,+      absl::string_view dns_server, bool check_port,+      EventEngine::Duration timeout,+      std::unique_ptr<GrpcPolledFdFactory> polled_fd_factory,+      EventEngine* event_engine);++  // Starting a request, on_resolve is guaranteed to be called with Result or+  // failure status unless the request was cancelled.+  void Start(absl::AnyInvocable<void(absl::StatusOr<Result>)> on_resolve)+      ABSL_LOCKS_EXCLUDED(mu_);++ private:+  // This callback is invoked from the c-ares library, so disable thread+  // safety analysis. Note that we are guaranteed to be holding mu_ though.+  static void OnHostbynameDoneLocked(void* arg, int status, int /*timeouts*/,+                                     struct hostent* hostent)+      ABSL_NO_THREAD_SAFETY_ANALYSIS;++  GrpcAresHostnameRequest(+      absl::string_view name, absl::string_view default_port,+      EventEngine::Duration timeout,+      std::unique_ptr<GrpcPolledFdFactory> polled_fd_factory,+      EventEngine* event_engine);+  ~GrpcAresHostnameRequest() override;++  bool ResolveAsIPLiteralLocked() ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu_);+  void LogResolvedAddressesList(const char* input_output_str)+      ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu_);+  void SortResolvedAddresses() ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu_);+  void OnResolve(+      absl::StatusOr<std::vector<EventEngine::ResolvedAddress>> result)",Consistency nit: the other subclasses alias define `OnResolver(absl::StatusOr<Result> result)`,
16962414,gtcooke94,https://api.github.com/repos/grpc/grpc/pulls/32944,1179326629,2023-04-27T15:19:18Z,test/core/security/rbac_translator_test.cc,"@@ -984,6 +1038,347 @@ TEST(GenerateRbacPoliciesTest, UnknownFieldInHeaders) {               ""\""foo\"".""); } +TEST_F(GenerateRbacPoliciesTest, AuditConditionOnDeny) {+  const char* authz_policy =+      ""{""+      ""  \""name\"": \""authz\"",""+      ""  \""allow_rules\"": [""+      ""    {""+      ""      \""name\"": \""allow_policy\""""+      ""    }""+      ""  ],""+      ""  \""deny_rules\"": [""+      ""    {""+      ""      \""name\"": \""deny_policy\""""+      ""    }""+      ""  ],""+      ""  \""audit_logging_options\"": {""+      ""    \""audit_condition\"": \""ON_DENY\""""+      ""  }""+      ""}"";+  auto rbacs = GenerateRbacPolicies(authz_policy);+  ASSERT_TRUE(rbacs.ok());+  EXPECT_EQ(rbacs->allow_policy.name, ""authz"");+  EXPECT_EQ(rbacs->deny_policy->name, ""authz"");+  EXPECT_EQ(rbacs->allow_policy.audit_condition, Rbac::AuditCondition::kOnDeny);+  EXPECT_EQ(rbacs->deny_policy->audit_condition, Rbac::AuditCondition::kOnDeny);+}++TEST_F(GenerateRbacPoliciesTest, AuditConditionOnAllowWithAuditLogger) {+  const char* authz_policy =+      ""{""+      ""  \""name\"": \""authz\"",""+      ""  \""allow_rules\"": [""+      ""    {""+      ""      \""name\"": \""allow_policy\""""+      ""    }""+      ""  ],""+      ""  \""deny_rules\"": [""+      ""    {""+      ""      \""name\"": \""deny_policy\""""+      ""    }""+      ""  ],""+      ""  \""audit_logging_options\"": {""+      ""    \""audit_condition\"": \""ON_ALLOW\"",""+      ""    \""audit_loggers\"": [""+      ""      {""+      ""        \""name\"": \""test_logger\"",""+      ""        \""config\"": {}""+      ""      }""+      ""    ]""+      ""  }""+      ""}"";+  auto rbacs = GenerateRbacPolicies(authz_policy);+  std::cout << rbacs.status().message() << std::endl;+  ASSERT_TRUE(rbacs.ok());+  EXPECT_EQ(rbacs->allow_policy.name, ""authz"");+  EXPECT_EQ(rbacs->deny_policy->name, ""authz"");+  EXPECT_EQ(rbacs->allow_policy.audit_condition,+            Rbac::AuditCondition::kOnAllow);+  EXPECT_EQ(rbacs->deny_policy->audit_condition, Rbac::AuditCondition::kNone);+  ASSERT_EQ(rbacs->allow_policy.logger_configs.size(), 1);+  EXPECT_EQ(rbacs->deny_policy->logger_configs.size(), 0);+  EXPECT_EQ(rbacs->allow_policy.logger_configs.at(0)->name(), kLoggerName);+}++TEST_F(GenerateRbacPoliciesTest,+       AuditConditionOnDenyAndAllowWithUnsupportedButOptionalLogger) {+  const char* authz_policy =+      ""{""+      ""  \""name\"": \""authz\"",""+      ""  \""allow_rules\"": [""+      ""    {""+      ""      \""name\"": \""allow_policy\""""+      ""    }""+      ""  ],""+      ""  \""deny_rules\"": [""+      ""    {""+      ""      \""name\"": \""deny_policy\""""+      ""    }""+      ""  ],""+      ""  \""audit_logging_options\"": {""+      ""    \""audit_condition\"": \""ON_DENY_AND_ALLOW\"",""+      ""    \""audit_loggers\"": [""+      ""      {""+      ""        \""name\"": \""unknown_logger\"",""+      ""        \""is_optional\"": true,""+      ""        \""config\"": {}""+      ""      }""+      ""    ]""+      ""  }""+      ""}"";+  auto rbacs = GenerateRbacPolicies(authz_policy);+  ASSERT_TRUE(rbacs.ok());+  EXPECT_EQ(rbacs->allow_policy.name, ""authz"");+  EXPECT_EQ(rbacs->deny_policy->name, ""authz"");+  EXPECT_EQ(rbacs->allow_policy.audit_condition,+            Rbac::AuditCondition::kOnDenyAndAllow);+  EXPECT_EQ(rbacs->deny_policy->audit_condition, Rbac::AuditCondition::kOnDeny);+  EXPECT_EQ(rbacs->allow_policy.logger_configs.size(), 0);+  EXPECT_EQ(rbacs->deny_policy->logger_configs.size(), 0);+}++TEST_F(GenerateRbacPoliciesTest, AuditConditionIsNotString) {+  const char* authz_policy =+      ""{""+      ""  \""name\"": \""authz\"",""+      ""  \""allow_rules\"": [""+      ""    {""+      ""      \""name\"": \""allow_policy\""""+      ""    }""+      ""  ],""+      ""  \""audit_logging_options\"": {""+      ""    \""audit_condition\"": 123""+      ""  }""+      ""}"";+  auto rbacs = GenerateRbacPolicies(authz_policy);+  EXPECT_EQ(rbacs.status().code(), absl::StatusCode::kInvalidArgument);+  EXPECT_THAT(rbacs.status().message(), ""\""audit_condition\"" is not a string."");+}++TEST_F(GenerateRbacPoliciesTest, IncorrectAuditConditionValue) {+  const char* authz_policy =+      ""{""+      ""  \""name\"": \""authz\"",""+      ""  \""allow_rules\"": [""+      ""    {""+      ""      \""name\"": \""allow_policy\""""+      ""    }""+      ""  ],""+      ""  \""audit_logging_options\"": {""+      ""    \""audit_condition\"": \""UNKNOWN\""""+      ""  }""+      ""}"";+  auto rbacs = GenerateRbacPolicies(authz_policy);+  EXPECT_EQ(rbacs.status().code(), absl::StatusCode::kInvalidArgument);+  EXPECT_THAT(rbacs.status().message(),+              ""Unsupported \""audit_condition\"" value UNKNOWN."");+}++TEST_F(GenerateRbacPoliciesTest, IncorrectAuditLoggersType) {+  const char* authz_policy =+      ""{""+      ""  \""name\"": \""authz\"",""+      ""  \""allow_rules\"": [""+      ""    {""+      ""      \""name\"": \""allow_policy\""""+      ""    }""+      ""  ],""+      ""  \""audit_logging_options\"": {""+      ""    \""audit_loggers\"": 123""+      ""  }""+      ""}"";+  auto rbacs = GenerateRbacPolicies(authz_policy);+  EXPECT_EQ(rbacs.status().code(), absl::StatusCode::kInvalidArgument);+  EXPECT_THAT(rbacs.status().message(), ""\""audit_loggers\"" is not an array."");+}++TEST_F(GenerateRbacPoliciesTest, IncorrectAuditLoggerType) {+  const char* authz_policy =+      ""{""+      ""  \""name\"": \""authz\"",""+      ""  \""allow_rules\"": [""+      ""    {""+      ""      \""name\"": \""allow_policy\""""+      ""    }""+      ""  ],""+      ""  \""audit_logging_options\"": {""+      ""    \""audit_loggers\"": [123]""+      ""  }""+      ""}"";+  auto rbacs = GenerateRbacPolicies(authz_policy);+  EXPECT_EQ(rbacs.status().code(), absl::StatusCode::kInvalidArgument);+  EXPECT_THAT(rbacs.status().message(),+              ""\""audit_loggers[0]\"" is not an object."");+}++TEST_F(GenerateRbacPoliciesTest, IncorrectAuditLoggerConfigType) {+  const char* authz_policy =+      ""{""+      ""  \""name\"": \""authz\"",""+      ""  \""allow_rules\"": [""+      ""    {""+      ""      \""name\"": \""allow_policy\""""+      ""    }""+      ""  ],""+      ""  \""audit_logging_options\"": {""+      ""    \""audit_loggers\"": [""+      ""      {""+      ""        \""name\"": \""unknown_logger\"",""+      ""        \""config\"": 123""+      ""      }""+      ""    ]""+      ""  }""+      ""}"";+  auto rbacs = GenerateRbacPolicies(authz_policy);+  EXPECT_EQ(rbacs.status().code(), absl::StatusCode::kInvalidArgument);+  EXPECT_THAT(rbacs.status().message(),+              ""\""audit_loggers[0].config\"" is not an object."");+}++TEST_F(GenerateRbacPoliciesTest, BadAuditLoggerConfig) {+  const char* authz_policy =+      ""{""+      ""  \""name\"": \""authz\"",""+      ""  \""allow_rules\"": [""+      ""    {""+      ""      \""name\"": \""allow_policy\""""+      ""    }""+      ""  ],""+      ""  \""audit_logging_options\"": {""+      ""    \""audit_loggers\"": [""+      ""      {""+      ""        \""name\"": \""test_logger\"",""+      ""        \""config\"": {\""bad\"": true}""+      ""      }""+      ""    ]""+      ""  }""+      ""}"";+  auto rbacs = GenerateRbacPolicies(authz_policy);+  EXPECT_EQ(rbacs.status().code(), absl::StatusCode::kInvalidArgument);+  EXPECT_THAT(rbacs.status().message(),+              ""\""audit_loggers[0]\"" bad logger config."");+}++TEST_F(GenerateRbacPoliciesTest, IncorrectAuditLoggerNameType) {+  const char* authz_policy =+      ""{""+      ""  \""name\"": \""authz\"",""+      ""  \""allow_rules\"": [""+      ""    {""+      ""      \""name\"": \""allow_policy\""""+      ""    }""+      ""  ],""+      ""  \""audit_logging_options\"": {""+      ""    \""audit_loggers\"": [""+      ""      {""+      ""        \""name\"": 123,""+      ""        \""config\"": {}""+      ""      }""+      ""    ]""+      ""  }""+      ""}"";+  auto rbacs = GenerateRbacPolicies(authz_policy);+  EXPECT_EQ(rbacs.status().code(), absl::StatusCode::kInvalidArgument);+  EXPECT_THAT(rbacs.status().message(),+              ""\""audit_loggers[0].name\"" is not a string."");+}++TEST_F(GenerateRbacPoliciesTest, IncorrectAuditLoggerIsOptionalType) {+  const char* authz_policy =+      ""{""+      ""  \""name\"": \""authz\"",""+      ""  \""allow_rules\"": [""+      ""    {""+      ""      \""name\"": \""allow_policy\""""+      ""    }""+      ""  ],""+      ""  \""audit_logging_options\"": {""+      ""    \""audit_loggers\"": [""+      ""      {""+      ""        \""name\"": \""test_logger\"",""+      ""        \""is_optional\"": 123,""+      ""        \""config\"": {}""+      ""      }""+      ""    ]""+      ""  }""+      ""}"";+  auto rbacs = GenerateRbacPolicies(authz_policy);+  EXPECT_EQ(rbacs.status().code(), absl::StatusCode::kInvalidArgument);+  EXPECT_THAT(rbacs.status().message(),+              ""\""audit_loggers[0].is_optional\"" is not a boolean."");+}++TEST_F(GenerateRbacPoliciesTest, MissingAuditLoggerName) {+  const char* authz_policy =+      ""{""+      ""  \""name\"": \""authz\"",""+      ""  \""allow_rules\"": [""+      ""    {""+      ""      \""name\"": \""allow_policy\""""+      ""    }""+      ""  ],""+      ""  \""audit_logging_options\"": {""+      ""    \""audit_loggers\"": [""+      ""      {""+      ""        \""config\"": {}""+      ""      }""+      ""    ]""+      ""  }""+      ""}"";+  auto rbacs = GenerateRbacPolicies(authz_policy);+  EXPECT_EQ(rbacs.status().code(), absl::StatusCode::kInvalidArgument);+  EXPECT_THAT(rbacs.status().message(),+              ""\""audit_loggers[0].name\"" is required."");+}++TEST_F(GenerateRbacPoliciesTest, MissingAuditLoggerConfig) {+  const char* authz_policy =+      ""{""+      ""  \""name\"": \""authz\"",""+      ""  \""allow_rules\"": [""+      ""    {""+      ""      \""name\"": \""allow_policy\""""+      ""    }""+      ""  ],""+      ""  \""audit_logging_options\"": {""+      ""    \""audit_loggers\"": [""+      ""      {""+      ""        \""name\"": \""test_logger\""""+      ""      }""+      ""    ]""+      ""  }""+      ""}"";+  auto rbacs = GenerateRbacPolicies(authz_policy);+  EXPECT_EQ(rbacs.status().code(), absl::StatusCode::kInvalidArgument);+  EXPECT_THAT(rbacs.status().message(),+              ""\""audit_loggers[0].config\"" is required."");+}++TEST_F(GenerateRbacPoliciesTest, UnsupportedAuditLogger) {+  const char* authz_policy =+      ""{""+      ""  \""name\"": \""authz\"",""+      ""  \""allow_rules\"": [""+      ""    {""+      ""      \""name\"": \""allow_policy\""""+      ""    }""+      ""  ],""+      ""  \""audit_logging_options\"": {""+      ""    \""audit_loggers\"": [""+      ""      {""+      ""        \""name\"": \""unknown_logger\"",""+      ""        \""config\"": {}""+      ""      }""+      ""    ]""+      ""  }""+      ""}"";+  auto rbacs = GenerateRbacPolicies(authz_policy);+  EXPECT_EQ(rbacs.status().code(), absl::StatusCode::kInvalidArgument);+  EXPECT_THAT(rbacs.status().message(),+              ""\""audit_loggers[0].name\"" unknown_logger is not supported."");+}+","What I was thinking is that the tests here just all ensure that the config is parsable, but this doesn't check that it correctly plumbs along those parsed values.For example if there were a mistake in the code that made an empty config always get put on the returned object vs. this parsed config, would we have a test that caught that?",
110920239,erm-g,https://api.github.com/repos/grpc/grpc/pulls/32944,1179344134,2023-04-27T15:29:48Z,src/core/lib/security/authorization/rbac_policy.h,,I think we also need to update the comment about envoy version`https://github.com/envoyproxy/envoy/blob/release/v1.17/api/envoy/config/rbac/v3/rbac.proto` - Audit doesn't exist at 1.17,
110920239,erm-g,https://api.github.com/repos/grpc/grpc/pulls/32944,1179460939,2023-04-27T17:01:18Z,test/core/security/rbac_translator_test.cc,"@@ -984,6 +1040,371 @@ TEST(GenerateRbacPoliciesTest, UnknownFieldInHeaders) {               ""\""foo\"".""); } +TEST_F(GenerateRbacPoliciesTest, AuditConditionNone) {+  const char* authz_policy =+      ""{""+      ""  \""name\"": \""authz\"",""+      ""  \""allow_rules\"": [""+      ""    {""+      ""      \""name\"": \""allow_policy\""""+      ""    }""+      ""  ],""+      ""  \""audit_logging_options\"": {""+      ""    \""audit_condition\"": \""NONE\""""+      ""  }""+      ""}"";+  auto rbacs = GenerateRbacPolicies(authz_policy);+  ASSERT_TRUE(rbacs.ok());+  EXPECT_EQ(rbacs->allow_policy.name, ""authz"");+  EXPECT_EQ(rbacs->allow_policy.audit_condition, Rbac::AuditCondition::kNone);+}++TEST_F(GenerateRbacPoliciesTest, AuditConditionOnDeny) {+  const char* authz_policy =+      ""{""+      ""  \""name\"": \""authz\"",""+      ""  \""allow_rules\"": [""+      ""    {""+      ""      \""name\"": \""allow_policy\""""+      ""    }""+      ""  ],""+      ""  \""deny_rules\"": [""+      ""    {""+      ""      \""name\"": \""deny_policy\""""+      ""    }""+      ""  ],""+      ""  \""audit_logging_options\"": {""+      ""    \""audit_condition\"": \""ON_DENY\""""+      ""  }""+      ""}"";+  auto rbacs = GenerateRbacPolicies(authz_policy);+  ASSERT_TRUE(rbacs.ok());+  EXPECT_EQ(rbacs->allow_policy.name, ""authz"");+  EXPECT_EQ(rbacs->deny_policy->name, ""authz"");+  EXPECT_EQ(rbacs->allow_policy.audit_condition, Rbac::AuditCondition::kOnDeny);+  EXPECT_EQ(rbacs->deny_policy->audit_condition, Rbac::AuditCondition::kOnDeny);+}++TEST_F(GenerateRbacPoliciesTest, AuditConditionOnAllowWithAuditLoggers) {+  const char* authz_policy =+      ""{""+      ""  \""name\"": \""authz\"",""+      ""  \""allow_rules\"": [""+      ""    {""+      ""      \""name\"": \""allow_policy\""""+      ""    }""+      ""  ],""+      ""  \""deny_rules\"": [""+      ""    {""+      ""      \""name\"": \""deny_policy\""""+      ""    }""+      ""  ],""+      ""  \""audit_logging_options\"": {""+      ""    \""audit_condition\"": \""ON_ALLOW\"",""+      ""    \""audit_loggers\"": [""+      ""      {""+      ""        \""name\"": \""test_logger\"",""+      ""        \""config\"": {}""+      ""      },""+      ""      {""+      ""        \""name\"": \""test_logger\"",""+      ""        \""config\"": {}""+      ""      }""+      ""    ]""+      ""  }""+      ""}"";+  auto rbacs = GenerateRbacPolicies(authz_policy);+  std::cout << rbacs.status().message() << std::endl;+  ASSERT_TRUE(rbacs.ok());+  EXPECT_EQ(rbacs->allow_policy.name, ""authz"");+  EXPECT_EQ(rbacs->deny_policy->name, ""authz"");+  EXPECT_EQ(rbacs->allow_policy.audit_condition,+            Rbac::AuditCondition::kOnAllow);+  EXPECT_EQ(rbacs->deny_policy->audit_condition, Rbac::AuditCondition::kNone);+  ASSERT_EQ(rbacs->allow_policy.logger_configs.size(), 2);+  EXPECT_EQ(rbacs->deny_policy->logger_configs.size(), 0);+  EXPECT_EQ(rbacs->allow_policy.logger_configs.at(0)->name(), kLoggerName);+}++TEST_F(GenerateRbacPoliciesTest,+       AuditConditionOnDenyAndAllowWithUnsupportedButOptionalLogger) {+  const char* authz_policy =+      ""{""+      ""  \""name\"": \""authz\"",""+      ""  \""allow_rules\"": [""+      ""    {""+      ""      \""name\"": \""allow_policy\""""+      ""    }""+      ""  ],""+      ""  \""deny_rules\"": [""+      ""    {""+      ""      \""name\"": \""deny_policy\""""+      ""    }""+      ""  ],""+      ""  \""audit_logging_options\"": {""+      ""    \""audit_condition\"": \""ON_DENY_AND_ALLOW\"",""+      ""    \""audit_loggers\"": [""+      ""      {""+      ""        \""name\"": \""unknown_logger\"",""+      ""        \""is_optional\"": true,""+      ""        \""config\"": {}""+      ""      }""+      ""    ]""+      ""  }""+      ""}"";+  auto rbacs = GenerateRbacPolicies(authz_policy);+  ASSERT_TRUE(rbacs.ok());+  EXPECT_EQ(rbacs->allow_policy.name, ""authz"");+  EXPECT_EQ(rbacs->deny_policy->name, ""authz"");+  EXPECT_EQ(rbacs->allow_policy.audit_condition,+            Rbac::AuditCondition::kOnDenyAndAllow);+  EXPECT_EQ(rbacs->deny_policy->audit_condition, Rbac::AuditCondition::kOnDeny);+  EXPECT_EQ(rbacs->allow_policy.logger_configs.size(), 0);+  EXPECT_EQ(rbacs->deny_policy->logger_configs.size(), 0);+}++TEST_F(GenerateRbacPoliciesTest, AuditConditionIsNotString) {+  const char* authz_policy =+      ""{""+      ""  \""name\"": \""authz\"",""+      ""  \""allow_rules\"": [""+      ""    {""+      ""      \""name\"": \""allow_policy\""""+      ""    }""+      ""  ],""+      ""  \""audit_logging_options\"": {""+      ""    \""audit_condition\"": 123""+      ""  }""+      ""}"";+  auto rbacs = GenerateRbacPolicies(authz_policy);+  EXPECT_EQ(rbacs.status().code(), absl::StatusCode::kInvalidArgument);+  EXPECT_THAT(rbacs.status().message(), ""\""audit_condition\"" is not a string."");+}++TEST_F(GenerateRbacPoliciesTest, IncorrectAuditConditionValue) {+  const char* authz_policy =+      ""{""+      ""  \""name\"": \""authz\"",""+      ""  \""allow_rules\"": [""+      ""    {""+      ""      \""name\"": \""allow_policy\""""+      ""    }""+      ""  ],""+      ""  \""audit_logging_options\"": {""+      ""    \""audit_condition\"": \""UNKNOWN\""""+      ""  }""+      ""}"";+  auto rbacs = GenerateRbacPolicies(authz_policy);+  EXPECT_EQ(rbacs.status().code(), absl::StatusCode::kInvalidArgument);+  EXPECT_THAT(rbacs.status().message(),+              ""Unsupported \""audit_condition\"" value UNKNOWN."");+}++TEST_F(GenerateRbacPoliciesTest, IncorrectAuditLoggersType) {+  const char* authz_policy =+      ""{""+      ""  \""name\"": \""authz\"",""+      ""  \""allow_rules\"": [""+      ""    {""+      ""      \""name\"": \""allow_policy\""""+      ""    }""+      ""  ],""+      ""  \""audit_logging_options\"": {""+      ""    \""audit_loggers\"": 123""+      ""  }""+      ""}"";+  auto rbacs = GenerateRbacPolicies(authz_policy);+  EXPECT_EQ(rbacs.status().code(), absl::StatusCode::kInvalidArgument);+  EXPECT_THAT(rbacs.status().message(), ""\""audit_loggers\"" is not an array."");+}++TEST_F(GenerateRbacPoliciesTest, IncorrectAuditLoggerType) {+  const char* authz_policy =+      ""{""+      ""  \""name\"": \""authz\"",""+      ""  \""allow_rules\"": [""+      ""    {""+      ""      \""name\"": \""allow_policy\""""+      ""    }""+      ""  ],""+      ""  \""audit_logging_options\"": {""+      ""    \""audit_loggers\"": [123]""+      ""  }""+      ""}"";+  auto rbacs = GenerateRbacPolicies(authz_policy);+  EXPECT_EQ(rbacs.status().code(), absl::StatusCode::kInvalidArgument);+  EXPECT_THAT(rbacs.status().message(),+              ""\""audit_loggers[0]\"" is not an object."");+}++TEST_F(GenerateRbacPoliciesTest, IncorrectAuditLoggerConfigType) {+  const char* authz_policy =+      ""{""+      ""  \""name\"": \""authz\"",""+      ""  \""allow_rules\"": [""+      ""    {""+      ""      \""name\"": \""allow_policy\""""+      ""    }""+      ""  ],""+      ""  \""audit_logging_options\"": {""+      ""    \""audit_loggers\"": [""+      ""      {""+      ""        \""name\"": \""unknown_logger\"",""+      ""        \""config\"": 123""+      ""      }""+      ""    ]""+      ""  }""+      ""}"";+  auto rbacs = GenerateRbacPolicies(authz_policy);+  EXPECT_EQ(rbacs.status().code(), absl::StatusCode::kInvalidArgument);+  EXPECT_THAT(rbacs.status().message(),+              ""\""audit_loggers[0].config\"" is not an object."");+}++TEST_F(GenerateRbacPoliciesTest, BadAuditLoggerConfig) {+  const char* authz_policy =+      ""{""+      ""  \""name\"": \""authz\"",""+      ""  \""allow_rules\"": [""+      ""    {""+      ""      \""name\"": \""allow_policy\""""+      ""    }""+      ""  ],""+      ""  \""audit_logging_options\"": {""+      ""    \""audit_loggers\"": [""+      ""      {""+      ""        \""name\"": \""test_logger\"",""+      ""        \""config\"": {\""bad\"": true}""+      ""      }""+      ""    ]""+      ""  }""+      ""}"";+  auto rbacs = GenerateRbacPolicies(authz_policy);+  EXPECT_EQ(rbacs.status().code(), absl::StatusCode::kInvalidArgument);+  EXPECT_THAT(rbacs.status().message(),+              ""\""audit_loggers[0]\"" bad logger config."");+}++TEST_F(GenerateRbacPoliciesTest, IncorrectAuditLoggerNameType) {+  const char* authz_policy =+      ""{""+      ""  \""name\"": \""authz\"",""+      ""  \""allow_rules\"": [""+      ""    {""+      ""      \""name\"": \""allow_policy\""""+      ""    }""+      ""  ],""+      ""  \""audit_logging_options\"": {""+      ""    \""audit_loggers\"": [""+      ""      {""+      ""        \""name\"": 123,""+      ""        \""config\"": {}""+      ""      }""+      ""    ]""+      ""  }""+      ""}"";+  auto rbacs = GenerateRbacPolicies(authz_policy);+  EXPECT_EQ(rbacs.status().code(), absl::StatusCode::kInvalidArgument);+  EXPECT_THAT(rbacs.status().message(),+              ""\""audit_loggers[0].name\"" is not a string."");+}++TEST_F(GenerateRbacPoliciesTest, IncorrectAuditLoggerIsOptionalType) {+  const char* authz_policy =+      ""{""+      ""  \""name\"": \""authz\"",""+      ""  \""allow_rules\"": [""+      ""    {""+      ""      \""name\"": \""allow_policy\""""+      ""    }""+      ""  ],""+      ""  \""audit_logging_options\"": {""+      ""    \""audit_loggers\"": [""+      ""      {""+      ""        \""name\"": \""test_logger\"",""+      ""        \""is_optional\"": 123,""+      ""        \""config\"": {}""+      ""      }""+      ""    ]""+      ""  }""+      ""}"";+  auto rbacs = GenerateRbacPolicies(authz_policy);+  EXPECT_EQ(rbacs.status().code(), absl::StatusCode::kInvalidArgument);+  EXPECT_THAT(rbacs.status().message(),+              ""\""audit_loggers[0].is_optional\"" is not a boolean."");+}++TEST_F(GenerateRbacPoliciesTest, MissingAuditLoggerName) {+  const char* authz_policy =+      ""{""+      ""  \""name\"": \""authz\"",""+      ""  \""allow_rules\"": [""+      ""    {""+      ""      \""name\"": \""allow_policy\""""+      ""    }""+      ""  ],""+      ""  \""audit_logging_options\"": {""+      ""    \""audit_loggers\"": [""+      ""      {""+      ""        \""config\"": {}""+      ""      }""+      ""    ]""+      ""  }""+      ""}"";+  auto rbacs = GenerateRbacPolicies(authz_policy);+  EXPECT_EQ(rbacs.status().code(), absl::StatusCode::kInvalidArgument);+  EXPECT_THAT(rbacs.status().message(),+              ""\""audit_loggers[0].name\"" is required."");+}++TEST_F(GenerateRbacPoliciesTest, MissingAuditLoggerConfig) {+  const char* authz_policy =+      ""{""+      ""  \""name\"": \""authz\"",""+      ""  \""allow_rules\"": [""+      ""    {""+      ""      \""name\"": \""allow_policy\""""+      ""    }""+      ""  ],""+      ""  \""audit_logging_options\"": {""+      ""    \""audit_loggers\"": [""+      ""      {""+      ""        \""name\"": \""test_logger\""""",Is that a correct behavior in this case? Can we treat it as an empty config or does my idea violate some best practices?,
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/32701,1179618323,2023-04-27T19:55:44Z,src/core/lib/event_engine/grpc_ares_wrapper.cc,"@@ -0,0 +1,1013 @@+// Copyright 2023 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++#include <grpc/support/port_platform.h>++#include ""src/core/lib/event_engine/grpc_ares_wrapper.h""++#include ""src/core/lib/iomgr/port.h""++// IWYU pragma: no_include <arpa/inet.h>+// IWYU pragma: no_include <arpa/nameser.h>+// IWYU pragma: no_include <inttypes.h>+// IWYU pragma: no_include <netdb.h>+// IWYU pragma: no_include <netinet/in.h>+// IWYU pragma: no_include <stdlib.h>+// IWYU pragma: no_include <sys/socket.h>+// IWYU pragma: no_include <ratio>++#if GRPC_ARES == 1++#include <string.h>++#include <algorithm>+#include <chrono>+#include <initializer_list>+#include <memory>+#include <type_traits>+#include <utility>++#include <address_sorting/address_sorting.h>++#include ""absl/cleanup/cleanup.h""+#include ""absl/strings/numbers.h""+#include ""absl/strings/str_cat.h""+#include ""absl/strings/str_format.h""+#include ""absl/types/optional.h""++#include <grpc/event_engine/event_engine.h>+#include <grpc/support/alloc.h>+#include <grpc/support/log.h>++#include ""src/core/lib/address_utils/parse_address.h""+#include ""src/core/lib/address_utils/sockaddr_utils.h""+#include ""src/core/lib/event_engine/grpc_polled_fd.h""+#include ""src/core/lib/event_engine/nameser.h""  // IWYU pragma: keep+#include ""src/core/lib/event_engine/tcp_socket_utils.h""+#include ""src/core/lib/event_engine/time_util.h""+#include ""src/core/lib/gpr/string.h""+#include ""src/core/lib/gprpp/debug_location.h""+#include ""src/core/lib/gprpp/examine_stack.h""+#include ""src/core/lib/gprpp/host_port.h""+#include ""src/core/lib/gprpp/ref_counted_ptr.h""+#include ""src/core/lib/gprpp/status_helper.h""+#include ""src/core/lib/iomgr/error.h""+#include ""src/core/lib/iomgr/exec_ctx.h""+#include ""src/core/lib/iomgr/resolved_address.h""+#include ""src/core/lib/iomgr/sockaddr.h""+#ifdef GRPC_POSIX_SOCKET_ARES_EV_DRIVER+#include ""src/core/lib/event_engine/posix_engine/tcp_socket_utils.h""+#elif defined(GRPC_WINDOWS_SOCKET_ARES_EV_DRIVER)+#endif++namespace grpc_event_engine {+namespace experimental {++grpc_core::TraceFlag grpc_trace_ares_wrapper_address_sorting(+    false, ""ares_wrapper_address_sorting"");++grpc_core::TraceFlag grpc_trace_ares_wrapper_stacktrace(+    false, ""ares_wrapper_stacktrace"");++#define GRPC_ARES_WRAPPER_STACK_TRACE()                                \+  do {                                                                 \+    if (GRPC_TRACE_FLAG_ENABLED(grpc_trace_ares_wrapper_stacktrace)) { \+      absl::optional<std::string> stacktrace =                         \+          grpc_core::GetCurrentStackTrace();                           \+      if (stacktrace.has_value()) {                                    \+        gpr_log(GPR_DEBUG, ""%s"", stacktrace->c_str());                 \+      } else {                                                         \+        gpr_log(GPR_DEBUG, ""stacktrace unavailable"");                  \+      }                                                                \+    }                                                                  \+  } while (0)++grpc_core::TraceFlag grpc_trace_ares_wrapper(false,+                                             ""event_engine_ares_wrapper"");++namespace {++EventEngine::Duration calculate_next_ares_backup_poll_alarm_duration() {+  // An alternative here could be to use ares_timeout to try to be more+  // accurate, but that would require using ""struct timeval""'s, which just+  // makes things a bit more complicated. So just poll every second, as+  // suggested by the c-ares code comments.+  return std::chrono::seconds(1);+}++bool IsIpv6LoopbackAvailable() {+#ifdef GRPC_POSIX_SOCKET_ARES_EV_DRIVER+  return PosixSocketWrapper::IsIpv6LoopbackAvailable();+#elif defined(GRPC_WINDOWS_SOCKET_ARES_EV_DRIVER)+  // TODO(yijiem): (debt) move pieces for Windows+  return false;+#else+#error ""Unsupported platform""+#endif+}++struct HostbynameArg {+  GrpcAresHostnameRequest* request;+  const char* qtype;+};++constexpr char g_service_config_attribute_prefix[] = ""grpc_config="";+constexpr size_t g_prefix_len = sizeof(g_service_config_attribute_prefix) - 1;++}  // namespace++void GrpcAresHostnameRequest::OnHostbynameDoneLocked(void* arg, int status,+                                                     int /*timeouts*/,+                                                     struct hostent* hostent) {+  std::unique_ptr<HostbynameArg> harg(static_cast<HostbynameArg*>(arg));+  GrpcAresHostnameRequest* request = harg->request;+  if (status != ARES_SUCCESS) {+    std::string error_msg = absl::StrFormat(+        ""c-ares status is not ARES_SUCCESS qtype=%s name=%s: %s"", harg->qtype,+        request->host_, ares_strerror(status));+    GRPC_ARES_WRAPPER_TRACE_LOG(""request:%p on_hostbyname_done_locked: %s"",+                                request, error_msg.c_str());+    GRPC_ARES_WRAPPER_STACK_TRACE();+    absl::Status error = GRPC_ERROR_CREATE(error_msg);+    request->OnResolve(error);+    return;+  }+  GRPC_ARES_WRAPPER_TRACE_LOG(+      ""request:%p on_hostbyname_done_locked qtype=%s host=%s ARES_SUCCESS"",+      request, harg->qtype, std::string(request->host_).c_str());+  GRPC_ARES_WRAPPER_STACK_TRACE();++  std::vector<EventEngine::ResolvedAddress> resolved_addresses;+  for (size_t i = 0; hostent->h_addr_list[i] != nullptr; i++) {+    switch (hostent->h_addrtype) {+      case AF_INET6: {+        size_t addr_len = sizeof(struct sockaddr_in6);+        struct sockaddr_in6 addr;+        memset(&addr, 0, addr_len);+        memcpy(&addr.sin6_addr, hostent->h_addr_list[i],+               sizeof(struct in6_addr));+        addr.sin6_family = static_cast<unsigned char>(hostent->h_addrtype);+        addr.sin6_port = htons(request->port_);+        resolved_addresses.emplace_back(+            reinterpret_cast<const sockaddr*>(&addr), addr_len);+        char output[INET6_ADDRSTRLEN];+        ares_inet_ntop(AF_INET6, &addr.sin6_addr, output, INET6_ADDRSTRLEN);+        GRPC_ARES_WRAPPER_TRACE_LOG(+            ""request:%p c-ares resolver gets a AF_INET6 result: \n""+            ""  addr: %s\n  port: %d\n  sin6_scope_id: %d\n"",+            request, output, request->port_, addr.sin6_scope_id);+        break;+      }+      case AF_INET: {+        size_t addr_len = sizeof(struct sockaddr_in);+        struct sockaddr_in addr;+        memset(&addr, 0, addr_len);+        memcpy(&addr.sin_addr, hostent->h_addr_list[i], sizeof(struct in_addr));+        addr.sin_family = static_cast<unsigned char>(hostent->h_addrtype);+        addr.sin_port = htons(request->port_);+        resolved_addresses.emplace_back(+            reinterpret_cast<const sockaddr*>(&addr), addr_len);+        char output[INET_ADDRSTRLEN];+        ares_inet_ntop(AF_INET, &addr.sin_addr, output, INET_ADDRSTRLEN);+        GRPC_ARES_WRAPPER_TRACE_LOG(+            ""request:%p c-ares resolver gets a AF_INET result: \n""+            ""  addr: %s\n  port: %d\n"",+            request, output, request->port_);+        break;+      }+    }+  }+  request->OnResolve(std::move(resolved_addresses));+}++void GrpcAresSRVRequest::OnSRVQueryDoneLocked(void* arg, int status,+                                              int /*timeouts*/,+                                              unsigned char* abuf, int alen) {+  GrpcAresSRVRequest* r = static_cast<GrpcAresSRVRequest*>(arg);+  if (status != ARES_SUCCESS) {+    std::string error_msg = absl::StrFormat(+        ""c-ares status is not ARES_SUCCESS qtype=SRV name=%s: %s"",+        r->service_name_, ares_strerror(status));+    GRPC_ARES_WRAPPER_TRACE_LOG(""request:%p on_srv_query_done_locked: %s"", r,+                                error_msg.c_str());+    grpc_error_handle error = GRPC_ERROR_CREATE(error_msg);+    r->OnResolve(error);+    return;+  }+  GRPC_ARES_WRAPPER_TRACE_LOG(+      ""request:%p on_srv_query_done_locked name=%s ARES_SUCCESS"", r,+      r->service_name_.c_str());+  struct ares_srv_reply* reply = nullptr;+  const int parse_status = ares_parse_srv_reply(abuf, alen, &reply);+  GRPC_ARES_WRAPPER_TRACE_LOG(""request:%p ares_parse_srv_reply: %d"", r,+                              parse_status);+  Result result;+  if (parse_status == ARES_SUCCESS) {+    for (struct ares_srv_reply* srv_it = reply; srv_it != nullptr;+         srv_it = srv_it->next) {+      EventEngine::DNSResolver::SRVRecord record;+      record.host = srv_it->host;+      record.port = srv_it->port;+      record.priority = srv_it->priority;+      record.weight = srv_it->weight;+      result.push_back(std::move(record));+    }+  }+  if (reply != nullptr) {+    ares_free_data(reply);+  }+  r->OnResolve(std::move(result));+}++void GrpcAresTXTRequest::OnTXTDoneLocked(void* arg, int status,+                                         int /*timeouts*/, unsigned char* buf,+                                         int len) {+  GrpcAresTXTRequest* r = static_cast<GrpcAresTXTRequest*>(arg);+  struct ares_txt_ext* reply = nullptr;+  int parse_status = ARES_SUCCESS;+  if (status == ARES_SUCCESS) {+    GRPC_ARES_WRAPPER_TRACE_LOG(+        ""request:%p on_txt_done_locked name=%s ARES_SUCCESS"", r,+        r->config_name_.c_str());+    parse_status = ares_parse_txt_reply_ext(buf, len, &reply);+  }+  if (status != ARES_SUCCESS || parse_status != ARES_SUCCESS) {+    grpc_error_handle error;+    std::string error_msg = absl::StrFormat(+        ""c-ares status is not ARES_SUCCESS qtype=TXT name=%s: %s"",+        r->config_name_.c_str(), ares_strerror(status));+    GRPC_ARES_WRAPPER_TRACE_LOG(""request:%p on_txt_done_locked %s"", r,+                                error_msg.c_str());+    error = GRPC_ERROR_CREATE(error_msg);+    r->OnResolve(error);+    return;+  }+  // Find service config in TXT record.+  struct ares_txt_ext* result = nullptr;+  for (result = reply; result != nullptr; result = result->next) {+    if (result->record_start &&+        memcmp(result->txt, g_service_config_attribute_prefix, g_prefix_len) ==+            0) {+      break;+    }+  }+  std::string service_config_json_out;+  // Found a service config record.+  if (result != nullptr) {+    size_t service_config_len = result->length - g_prefix_len;+    service_config_json_out.append(+        reinterpret_cast<char*>(result->txt) + g_prefix_len,+        service_config_len);+    for (result = result->next; result != nullptr && !result->record_start;+         result = result->next) {+      service_config_json_out.append(reinterpret_cast<char*>(result->txt),+                                     result->length);+    }+    GRPC_ARES_WRAPPER_TRACE_LOG(""request:%p found service config: %s"", r,+                                service_config_json_out.c_str());+  }+  // Clean up.+  ares_free_data(reply);+  r->OnResolve(std::move(service_config_json_out));+}++GrpcAresRequest::FdNode::FdNode(ares_socket_t as, GrpcPolledFd* polled_fd)+    : as(as), polled_fd(polled_fd) {}++GrpcAresRequest::FdNode* GrpcAresRequest::FdNodeList::PopFdNode(+    ares_socket_t as) {+  FdNode phony_head;+  phony_head.next = head_;+  FdNode* node = &phony_head;+  while (node->next != nullptr) {+    if (node->next->polled_fd->GetWrappedAresSocketLocked() == as) {+      FdNode* ret = node->next;+      node->next = node->next->next;+      head_ = phony_head.next;+      return ret;+    }+    node = node->next;+  }+  return nullptr;+}++GrpcAresRequest::GrpcAresRequest(+    absl::string_view name, absl::optional<absl::string_view> default_port,+    EventEngine::Duration timeout,+    std::unique_ptr<GrpcPolledFdFactory> polled_fd_factory,+    EventEngine* event_engine)+    : grpc_core::InternallyRefCounted<GrpcAresRequest>(+          GRPC_TRACE_FLAG_ENABLED(grpc_trace_ares_wrapper) ? ""GrpcAresRequest""+                                                           : nullptr),+      name_(name),+      default_port_(default_port.has_value() ? *default_port : """"),+      fd_node_list_(std::make_unique<FdNodeList>()),+      timeout_(timeout),+      event_engine_(event_engine),+      polled_fd_factory_(std::move(polled_fd_factory)) {}++GrpcAresRequest::~GrpcAresRequest() {+  if (initialized_) {+    ares_destroy(channel_);+    GRPC_ARES_WRAPPER_STACK_TRACE();+  }+  GRPC_ARES_WRAPPER_TRACE_LOG(""request:%p destructor"", this);+}++absl::Status GrpcAresRequest::Initialize(absl::string_view dns_server,+                                         bool check_port) {+  grpc_core::MutexLock lock(&mu_);+  GPR_DEBUG_ASSERT(!initialized_);+  absl::string_view port;+  // parse name, splitting it into host and port parts+  grpc_core::SplitHostPort(name_, &host_, &port);+  absl::Status error;+  if (host_.empty()) {+    error =+        grpc_error_set_str(GRPC_ERROR_CREATE(""unparseable host:port""),+                           grpc_core::StatusStrProperty::kTargetAddress, name_);+    return error;+  } else if (check_port && port.empty()) {+    if (default_port_.empty()) {+      error = grpc_error_set_str(GRPC_ERROR_CREATE(""no port in name""),+                                 grpc_core::StatusStrProperty::kTargetAddress,+                                 name_);+      return error;+    }+    port = default_port_;+  }+  if (!port.empty()) {+    if (port == ""http"") {+      port_ = 80;+    } else if (port == ""https"") {+      port_ = 443;+    } else {+      GPR_ASSERT(absl::SimpleAtoi(port, &port_));+    }+  }+  ares_options opts = {};+  opts.flags |= ARES_FLAG_STAYOPEN;+  int status = ares_init_options(&channel_, &opts, ARES_OPT_FLAGS);+  if (status != ARES_SUCCESS) {+    gpr_log(GPR_ERROR, ""ares_init_options failed, status: %d"", status);+    return GRPC_ERROR_CREATE(absl::StrCat(+        ""Failed to init ares channel. c-ares error: "", ares_strerror(status)));+  }+  event_engine_grpc_ares_test_only_inject_config(channel_);+  // If dns_server is specified, use it.+  error = SetRequestDNSServer(dns_server);+  if (!error.ok()) {+    ares_destroy(channel_);+    return error;+  }+  initialized_ = true;+  return absl::OkStatus();+}++bool GrpcAresRequest::Cancel() {+  grpc_core::MutexLock lock(&mu_);+  if (std::exchange(shutting_down_, true)) {+    // Already shutting down, maybe resolved, cancelled or timed-out.+    return false;+  }+  cancelled_ = true;+  CancelTimers();+  ShutdownPolledFdsLocked(grpc_core::StatusCreate(+      absl::StatusCode::kCancelled, ""Cancel"", DEBUG_LOCATION, {}));+  return true;+}++void GrpcAresRequest::Work() {+  auto new_list = std::make_unique<FdNodeList>();+  if (!shutting_down_) {+    ares_socket_t socks[ARES_GETSOCK_MAXNUM];+    int socks_bitmask = ares_getsock(channel_, socks, ARES_GETSOCK_MAXNUM);+    for (size_t i = 0; i < ARES_GETSOCK_MAXNUM; i++) {+      if (ARES_GETSOCK_READABLE(socks_bitmask, i) ||+          ARES_GETSOCK_WRITABLE(socks_bitmask, i)) {+        FdNode* fd_node = fd_node_list_->PopFdNode(socks[i]);+        if (fd_node == nullptr) {+          fd_node = new FdNode(+              socks[i], polled_fd_factory_->NewGrpcPolledFdLocked(socks[i]));+          GRPC_ARES_WRAPPER_TRACE_LOG(""request:%p new fd: %d"", this,+                                      fd_node->as);+        }+        new_list->PushFdNode(fd_node);+        // Register read_closure if the socket is readable and read_closure+        // has not been registered with this socket.+        if (ARES_GETSOCK_READABLE(socks_bitmask, i) &&+            !fd_node->readable_registered) {+          GRPC_ARES_WRAPPER_TRACE_LOG(""request:%p notify read on: %d"", this,+                                      fd_node->as);+          fd_node->readable_registered = true;+          fd_node->polled_fd->RegisterForOnReadableLocked(+              [self = Ref(DEBUG_LOCATION, ""Work""),+               fd_node](absl::Status status) mutable {+                // This closure might hold the last RefCount to GrpcAresRequest+                // so its destruction might trigger a chain reaction of+                // destruction: ~GrpcAresRequest ->+                // ~EventEngineClientChannelDNSResolver -> ~PollingResolver ->+                // ~ResolverResultHandler -> grpc_stream_destroy which requires+                // ExecCtx.+                grpc_core::ApplicationCallbackExecCtx callback_exec_ctx;+                grpc_core::ExecCtx exec_ctx;+                self->OnReadable(fd_node, status);+                self.reset();+              });+        }+        // Register write_closure if the socket is writable and write_closure+        // has not been registered with this socket.+        if (ARES_GETSOCK_WRITABLE(socks_bitmask, i) &&+            !fd_node->writable_registered) {+          GRPC_ARES_WRAPPER_TRACE_LOG(""request:%p notify write on: %d"", this,+                                      fd_node->as);+          fd_node->writable_registered = true;+          fd_node->polled_fd->RegisterForOnWriteableLocked(+              [self = Ref(DEBUG_LOCATION, ""Work""),+               fd_node](absl::Status status) mutable {+                grpc_core::ApplicationCallbackExecCtx callback_exec_ctx;+                grpc_core::ExecCtx exec_ctx;+                self->OnWritable(fd_node, status);+                self.reset();+              });+        }+      }+    }+  }+  // Any remaining fds in ev_driver->fds were not returned by ares_getsock()+  // and are therefore no longer in use, so they can be shut down and removed+  // from the list.+  while (!fd_node_list_->IsEmpty()) {+    FdNode* fd_node = fd_node_list_->PopFdNode();+    if (!fd_node->already_shutdown) {+      GRPC_ARES_WRAPPER_TRACE_LOG(""request: %p shutdown fd: %s"", this,+                                  fd_node->polled_fd->GetName());+      fd_node->polled_fd->ShutdownLocked(absl::OkStatus());+      fd_node->already_shutdown = true;+    }+    if (!fd_node->readable_registered && !fd_node->writable_registered) {+      GRPC_ARES_WRAPPER_TRACE_LOG(""request: %p delete fd: %s"", this,+                                  fd_node->polled_fd->GetName());+      delete fd_node;+    } else {+      new_list->PushFdNode(fd_node);+    }+  }+  fd_node_list_.swap(new_list);+}++void GrpcAresRequest::StartTimers() {+  // Initialize overall DNS resolution timeout alarm+  EventEngine::Duration timeout =+      timeout_.count() == 0 ? EventEngine::Duration::max() : timeout_;+  GRPC_ARES_WRAPPER_TRACE_LOG(""request:%p StartTimers timeout in %"" PRId64+                              "" ms"",+                              this, Milliseconds(timeout));++  Ref(DEBUG_LOCATION, ""StartTimers"").release();+  query_timeout_handle_ = event_engine_->RunAfter(timeout, [this] {+    grpc_core::ApplicationCallbackExecCtx callback_exec_ctx;+    grpc_core::ExecCtx exec_ctx;+    OnQueryTimeout();+  });++  // Initialize the backup poll alarm+  EventEngine::Duration next_ares_backup_poll_alarm_duration =+      calculate_next_ares_backup_poll_alarm_duration();+  GRPC_ARES_WRAPPER_TRACE_LOG(+      ""request:%p StartTimers next ares process poll time in %"" PRId64 "" ms"",+      this, Milliseconds(next_ares_backup_poll_alarm_duration));++  Ref(DEBUG_LOCATION, ""StartTimers"").release();+  ares_backup_poll_alarm_handle_ =+      event_engine_->RunAfter(next_ares_backup_poll_alarm_duration, [this] {+        grpc_core::ApplicationCallbackExecCtx callback_exec_ctx;+        grpc_core::ExecCtx exec_ctx;+        OnAresBackupPollAlarm();+      });+}++void GrpcAresRequest::CancelTimers() {+  if (query_timeout_handle_.has_value()) {+    if (event_engine_->Cancel(*query_timeout_handle_)) {+      Unref(DEBUG_LOCATION, ""CancelTimers"");+    }+    query_timeout_handle_.reset();+  }+  if (ares_backup_poll_alarm_handle_.has_value()) {+    if (event_engine_->Cancel(*ares_backup_poll_alarm_handle_)) {+      Unref(DEBUG_LOCATION, ""CancelTimers"");+    }+    ares_backup_poll_alarm_handle_.reset();+  }+}++absl::Status GrpcAresRequest::SetRequestDNSServer(+    absl::string_view dns_server) {+  if (!dns_server.empty()) {+    GRPC_ARES_WRAPPER_TRACE_LOG(""request:%p Using DNS server %s"", this,+                                dns_server.data());+    grpc_resolved_address addr;+    struct ares_addr_port_node dns_server_addr;+    if (grpc_parse_ipv4_hostport(dns_server, &addr, /*log_errors=*/false)) {+      dns_server_addr.family = AF_INET;+      struct sockaddr_in* in = reinterpret_cast<struct sockaddr_in*>(addr.addr);+      memcpy(&dns_server_addr.addr.addr4, &in->sin_addr,+             sizeof(struct in_addr));+      dns_server_addr.tcp_port = grpc_sockaddr_get_port(&addr);+      dns_server_addr.udp_port = grpc_sockaddr_get_port(&addr);+    } else if (grpc_parse_ipv6_hostport(dns_server, &addr,+                                        /*log_errors=*/false)) {+      dns_server_addr.family = AF_INET6;+      struct sockaddr_in6* in6 =+          reinterpret_cast<struct sockaddr_in6*>(addr.addr);+      memcpy(&dns_server_addr.addr.addr6, &in6->sin6_addr,+             sizeof(struct in6_addr));+      dns_server_addr.tcp_port = grpc_sockaddr_get_port(&addr);+      dns_server_addr.udp_port = grpc_sockaddr_get_port(&addr);+    } else {+      return GRPC_ERROR_CREATE(+          absl::StrCat(""cannot parse authority "", dns_server));+    }+    // Prevent an uninitialized variable.+    dns_server_addr.next = nullptr;+    int status = ares_set_servers_ports(channel_, &dns_server_addr);+    if (status != ARES_SUCCESS) {+      return GRPC_ERROR_CREATE(absl::StrCat(+          ""c-ares status is not ARES_SUCCESS: "", ares_strerror(status)));+    }+  }+  return absl::OkStatus();+}++void GrpcAresRequest::OnReadable(FdNode* fd_node, absl::Status status) {+  grpc_core::MutexLock lock(&mu_);+  GPR_ASSERT(fd_node->readable_registered);+  fd_node->readable_registered = false;+  GRPC_ARES_WRAPPER_TRACE_LOG(""OnReadable: fd: %d; request: %p; status: %s"",+                              fd_node->as, this, status.ToString().c_str());+  GRPC_ARES_WRAPPER_STACK_TRACE();+  if (status.ok() && !shutting_down_) {+    do {+      ares_process_fd(channel_, fd_node->as, ARES_SOCKET_BAD);+    } while (fd_node->polled_fd->IsFdStillReadableLocked());+  } else {+    // If error is not absl::OkStatus() or the resolution was cancelled, it+    // means the fd has been shutdown or timed out. The pending lookups made+    // on this ev_driver will be cancelled by the following ares_cancel() and+    // the on_done callbacks will be invoked with a status of ARES_ECANCELLED.+    // The remaining file descriptors in this ev_driver will be cleaned up in+    // the follwing grpc_ares_notify_on_event_locked().+    ares_cancel(channel_);+  }+  Work();+}++void GrpcAresRequest::OnWritable(FdNode* fd_node, absl::Status status) {+  grpc_core::MutexLock lock(&mu_);+  GPR_ASSERT(fd_node->writable_registered);+  fd_node->writable_registered = false;+  GRPC_ARES_WRAPPER_TRACE_LOG(""OnWritable: fd: %d; request:%p; status: %s"",+                              fd_node->as, this, status.ToString().c_str());+  if (status.ok() && !shutting_down_) {+    ares_process_fd(channel_, ARES_SOCKET_BAD, fd_node->as);+  } else {+    // If error is not absl::OkStatus() or the resolution was cancelled, it+    // means the fd has been shutdown or timed out. The pending lookups made+    // on this ev_driver will be cancelled by the following ares_cancel() and+    // the on_done callbacks will be invoked with a status of ARES_ECANCELLED.+    // The remaining file descriptors in this ev_driver will be cleaned up in+    // the follwing grpc_ares_notify_on_event_locked().+    ares_cancel(channel_);+  }+  Work();+}++void GrpcAresRequest::OnQueryTimeout() {+  {+    grpc_core::MutexLock lock(&mu_);+    query_timeout_handle_.reset();+    GRPC_ARES_WRAPPER_TRACE_LOG(""request:%p OnQueryTimeout. shutting_down_=%d"",+                                this, shutting_down_);+    if (!shutting_down_) {+      shutting_down_ = true;+      ShutdownPolledFdsLocked(+          grpc_core::StatusCreate(absl::StatusCode::kDeadlineExceeded,+                                  ""OnQueryTimeout"", DEBUG_LOCATION, {}));+    }+  }+  Unref(DEBUG_LOCATION, ""OnQueryTimeout"");+}++// In case of non-responsive DNS servers, dropped packets, etc., c-ares has+// intelligent timeout and retry logic, which we can take advantage of by+// polling ares_process_fd on time intervals. Overall, the c-ares library is+// meant to be called into and given a chance to proceed name resolution:+//   a) when fd events happen+//   b) when some time has passed without fd events having happened+// For the latter, we use this backup poller. Also see+// https://github.com/grpc/grpc/pull/17688 description for more details.+void GrpcAresRequest::OnAresBackupPollAlarm() {+  {+    grpc_core::MutexLock lock(&mu_);+    ares_backup_poll_alarm_handle_.reset();+    GRPC_ARES_WRAPPER_TRACE_LOG(+        ""request:%p OnAresBackupPollAlarm shutting_down=%d."", this,+        shutting_down_);+    if (!shutting_down_) {+      for (auto it = fd_node_list_->begin(); it != fd_node_list_->end(); it++) {+        if (!(*it)->already_shutdown) {+          GRPC_ARES_WRAPPER_TRACE_LOG(+              ""request:%p OnAresBackupPollAlarm; ares_process_fd. fd=%s"", this,+              (*it)->polled_fd->GetName());+          ares_socket_t as = (*it)->polled_fd->GetWrappedAresSocketLocked();+          ares_process_fd(channel_, as, as);+        }+      }+      if (!shutting_down_) {+        EventEngine::Duration next_ares_backup_poll_alarm_duration =+            calculate_next_ares_backup_poll_alarm_duration();+        Ref(DEBUG_LOCATION, ""OnAresBackupPollAlarm"").release();+        ares_backup_poll_alarm_handle_ = event_engine_->RunAfter(+            next_ares_backup_poll_alarm_duration, [this] {+              grpc_core::ApplicationCallbackExecCtx callback_exec_ctx;+              grpc_core::ExecCtx exec_ctx;+              OnAresBackupPollAlarm();+            });+      }+      Work();+    }+  }+  Unref(DEBUG_LOCATION, ""OnAresBackupPollAlarm"");+}++// TODO(yijiem): Consider report this status or as part of the result when+// calling on_resolve_. This status is received in OnReadable/OnWritable.+void GrpcAresRequest::ShutdownPolledFdsLocked(absl::Status status) {+  for (auto it = fd_node_list_->begin(); it != fd_node_list_->end(); it++) {+    if (!(*it)->already_shutdown) {+      GRPC_ARES_WRAPPER_TRACE_LOG(""request: %p shutdown fd: %s"", this,+                                  (*it)->polled_fd->GetName());+      (*it)->polled_fd->ShutdownLocked(status);+      (*it)->already_shutdown = true;+    }+  }+}++GrpcAresHostnameRequest::GrpcAresHostnameRequest(+    absl::string_view name, absl::string_view default_port,+    EventEngine::Duration timeout,+    std::unique_ptr<GrpcPolledFdFactory> polled_fd_factory,+    EventEngine* event_engine)+    : GrpcAresRequest(name, default_port, timeout, std::move(polled_fd_factory),+                      event_engine) {}++GrpcAresHostnameRequest::~GrpcAresHostnameRequest() {+  GRPC_ARES_WRAPPER_TRACE_LOG(""request:%p destructor"", this);+}++void GrpcAresHostnameRequest::Start(+    absl::AnyInvocable<void(absl::StatusOr<Result>)> on_resolve) {+  auto self = Ref(DEBUG_LOCATION, ""Start"");+  grpc_core::ReleasableMutexLock lock(&mu_);+  GPR_ASSERT(initialized_);+  on_resolve_ = std::move(on_resolve);+  GRPC_ARES_WRAPPER_TRACE_LOG(+      ""request:%p c-ares GrpcAresHostnameRequest::Start name=%s, ""+      ""default_port=%s"",+      this, name_.c_str(), default_port_.c_str());+  // Early out if the target is an ipv4 or ipv6 literal.+  if (ResolveAsIPLiteralLocked()) {+    lock.Release();+    Unref(DEBUG_LOCATION, ""Start"");+    return;+  }+  // TODO(yijiem): Early out if the target is localhost and we're on Windows.++  // We add up pending_queries_ here since ares_gethostbyname may directly+  // invoke the callback inline if there is any error with the input. The+  // callback will invoke OnResolve with an error status and may destroy the+  // object too early (before the second ares_gethostbyname) if we haven't+  // added up here.+  pending_queries_++;+  if (IsIpv6LoopbackAvailable()) {+    pending_queries_++;+    auto* arg = new HostbynameArg();+    arg->request = this;+    arg->qtype = ""AAAA"";+    ares_gethostbyname(channel_, std::string(host_).c_str(), AF_INET6,","since `host_` is a string_view into an owned std::string already, I'm not sure this conversion is necessary. Are we concerned `host_.data()` may not be NUL-terminated?",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32954,1179684538,2023-04-27T21:08:17Z,include/grpcpp/ext/server_metric_recorder.h,"@@ -43,9 +43,10 @@ class ServerMetricRecorder {  public:   // Factory method. Use this to create.   static std::unique_ptr<ServerMetricRecorder> Create();-  /// Records the server CPU utilization in the range [0, 1].-  /// Values outside of the valid range are rejected.-  /// Overrides the stored value when called again with a valid value.+  /// Records the server CPU utilization in the range [0, infy).+  /// Values may be larger than 1.0 when the usage exceeds the reporter+  /// dependent notion of soft limits. Values outside of the valid range are+  /// rejected. Overrides the stored value when called again with a valid value.   void SetCpuUtilization(double value);",Please also update the comment on `CallMetricRecorder::RecordCpuUtilizationMetric()`:https://github.com/grpc/grpc/blob/1267000bbb690353c7d5e05b32adcffdbbeed16c/include/grpcpp/ext/call_metric_recorder.h#L43,
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32954,1179697851,2023-04-27T21:27:02Z,test/cpp/end2end/client_lb_end2end_test.cc,"@@ -2752,6 +2746,73 @@ TEST_F(ClientLbInterceptTrailingMetadataTest, BackendMetricDataMerge) {   EXPECT_EQ(total_num_rpcs, num_trailers_intercepted()); } +struct ClientLbLoadReportTestParams {+  OrcaLoadReport reported;+  OrcaLoadReport received;+};++class ClientLbLoadReportTest : public ClientLbInterceptTrailingMetadataTest,+                               public ::testing::WithParamInterface<+                                   struct ClientLbLoadReportTestParams> {};++TEST_P(ClientLbLoadReportTest, Basic) {+  const int kNumServers = 1;+  const int kNumRpcs = 10;+  StartServers(kNumServers);+  auto response_generator = BuildResolverResponseGenerator();+  auto channel =+      BuildChannel(""intercept_trailing_metadata_lb"", response_generator);+  auto stub = BuildStub(channel);+  response_generator.SetNextResolution(GetServersPorts());+  for (size_t i = 0; i < kNumRpcs; ++i) {+    CheckRpcSendOk(DEBUG_LOCATION, stub, false, &GetParam().reported);+    auto actual = backend_load_report();+    ASSERT_TRUE(actual.has_value());+    CheckLoadReportAsExpected(*actual, GetParam().received);+  }+  // Check LB policy name for the channel.+  EXPECT_EQ(""intercept_trailing_metadata_lb"",+            channel->GetLoadBalancingPolicyName());+  EXPECT_EQ(kNumRpcs, num_trailers_intercepted());+}++INSTANTIATE_TEST_SUITE_P(","I think using a parameterized test is overkill here.  It makes the code harder to understand, and it generates test names that do not actually help a human understand the purpose of the test.Instead, please just add a helper method to the existing `ClientLbInterceptTrailingMetadataTest` framework to run a test with specified input and expected output, like this:```static void RunPerRpcMetricReportingTest(    const OrcaLoadReport& reported,    const OrcaLoadReport& expected) {  // ...run test...}```Then write a separate `TEST_F()` block for each test case you want to test, with an appropriate test name, which calls the helper function with appropriate values.  For example:```TEST_F(ClientLbInterceptTrailingMetadataTest, IgnoresOutOfRangeValues) {  RunPerRpcMetricReportingTest(...);}TEST_F(ClientLbInterceptTrailingMetadataTest, AllowsCpuUtilizationGreaterThan1) {  RunPerRpcMetricReportingTest(...);}```",X
85715732,yousukseung,https://api.github.com/repos/grpc/grpc/pulls/32954,1179849375,2023-04-28T01:30:52Z,test/cpp/end2end/client_lb_end2end_test.cc,"@@ -2752,6 +2746,73 @@ TEST_F(ClientLbInterceptTrailingMetadataTest, BackendMetricDataMerge) {   EXPECT_EQ(total_num_rpcs, num_trailers_intercepted()); } +struct ClientLbLoadReportTestParams {+  OrcaLoadReport reported;+  OrcaLoadReport received;+};++class ClientLbLoadReportTest : public ClientLbInterceptTrailingMetadataTest,+                               public ::testing::WithParamInterface<+                                   struct ClientLbLoadReportTestParams> {};++TEST_P(ClientLbLoadReportTest, Basic) {+  const int kNumServers = 1;+  const int kNumRpcs = 10;+  StartServers(kNumServers);+  auto response_generator = BuildResolverResponseGenerator();+  auto channel =+      BuildChannel(""intercept_trailing_metadata_lb"", response_generator);+  auto stub = BuildStub(channel);+  response_generator.SetNextResolution(GetServersPorts());+  for (size_t i = 0; i < kNumRpcs; ++i) {+    CheckRpcSendOk(DEBUG_LOCATION, stub, false, &GetParam().reported);+    auto actual = backend_load_report();+    ASSERT_TRUE(actual.has_value());+    CheckLoadReportAsExpected(*actual, GetParam().received);+  }+  // Check LB policy name for the channel.+  EXPECT_EQ(""intercept_trailing_metadata_lb"",+            channel->GetLoadBalancingPolicyName());+  EXPECT_EQ(kNumRpcs, num_trailers_intercepted());+}++INSTANTIATE_TEST_SUITE_P(","Agree that parameterizing for only two tests is overkill. Then would it make sense to break it into more smaller ones? I thought about this but was lazy. I think this way test failure will be more descriptive, instead of covering all fields in on e test. I also added test names, now it shows the test name when it fails.Let me know what you think, I can refactor as you suggested.",X
5663878,yijiem,https://api.github.com/repos/grpc/grpc/pulls/32701,1179856384,2023-04-28T01:48:45Z,src/core/lib/event_engine/grpc_ares_wrapper.cc,"@@ -0,0 +1,1013 @@+// Copyright 2023 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++#include <grpc/support/port_platform.h>++#include ""src/core/lib/event_engine/grpc_ares_wrapper.h""++#include ""src/core/lib/iomgr/port.h""++// IWYU pragma: no_include <arpa/inet.h>+// IWYU pragma: no_include <arpa/nameser.h>+// IWYU pragma: no_include <inttypes.h>+// IWYU pragma: no_include <netdb.h>+// IWYU pragma: no_include <netinet/in.h>+// IWYU pragma: no_include <stdlib.h>+// IWYU pragma: no_include <sys/socket.h>+// IWYU pragma: no_include <ratio>++#if GRPC_ARES == 1++#include <string.h>++#include <algorithm>+#include <chrono>+#include <initializer_list>+#include <memory>+#include <type_traits>+#include <utility>++#include <address_sorting/address_sorting.h>++#include ""absl/cleanup/cleanup.h""+#include ""absl/strings/numbers.h""+#include ""absl/strings/str_cat.h""+#include ""absl/strings/str_format.h""+#include ""absl/types/optional.h""++#include <grpc/event_engine/event_engine.h>+#include <grpc/support/alloc.h>+#include <grpc/support/log.h>++#include ""src/core/lib/address_utils/parse_address.h""+#include ""src/core/lib/address_utils/sockaddr_utils.h""+#include ""src/core/lib/event_engine/grpc_polled_fd.h""+#include ""src/core/lib/event_engine/nameser.h""  // IWYU pragma: keep+#include ""src/core/lib/event_engine/tcp_socket_utils.h""+#include ""src/core/lib/event_engine/time_util.h""+#include ""src/core/lib/gpr/string.h""+#include ""src/core/lib/gprpp/debug_location.h""+#include ""src/core/lib/gprpp/examine_stack.h""+#include ""src/core/lib/gprpp/host_port.h""+#include ""src/core/lib/gprpp/ref_counted_ptr.h""+#include ""src/core/lib/gprpp/status_helper.h""+#include ""src/core/lib/iomgr/error.h""+#include ""src/core/lib/iomgr/exec_ctx.h""+#include ""src/core/lib/iomgr/resolved_address.h""+#include ""src/core/lib/iomgr/sockaddr.h""+#ifdef GRPC_POSIX_SOCKET_ARES_EV_DRIVER+#include ""src/core/lib/event_engine/posix_engine/tcp_socket_utils.h""+#elif defined(GRPC_WINDOWS_SOCKET_ARES_EV_DRIVER)+#endif++namespace grpc_event_engine {+namespace experimental {++grpc_core::TraceFlag grpc_trace_ares_wrapper_address_sorting(+    false, ""ares_wrapper_address_sorting"");++grpc_core::TraceFlag grpc_trace_ares_wrapper_stacktrace(+    false, ""ares_wrapper_stacktrace"");++#define GRPC_ARES_WRAPPER_STACK_TRACE()                                \+  do {                                                                 \+    if (GRPC_TRACE_FLAG_ENABLED(grpc_trace_ares_wrapper_stacktrace)) { \+      absl::optional<std::string> stacktrace =                         \+          grpc_core::GetCurrentStackTrace();                           \+      if (stacktrace.has_value()) {                                    \+        gpr_log(GPR_DEBUG, ""%s"", stacktrace->c_str());                 \+      } else {                                                         \+        gpr_log(GPR_DEBUG, ""stacktrace unavailable"");                  \+      }                                                                \+    }                                                                  \+  } while (0)++grpc_core::TraceFlag grpc_trace_ares_wrapper(false,+                                             ""event_engine_ares_wrapper"");++namespace {++EventEngine::Duration calculate_next_ares_backup_poll_alarm_duration() {+  // An alternative here could be to use ares_timeout to try to be more+  // accurate, but that would require using ""struct timeval""'s, which just+  // makes things a bit more complicated. So just poll every second, as+  // suggested by the c-ares code comments.+  return std::chrono::seconds(1);+}++bool IsIpv6LoopbackAvailable() {+#ifdef GRPC_POSIX_SOCKET_ARES_EV_DRIVER+  return PosixSocketWrapper::IsIpv6LoopbackAvailable();+#elif defined(GRPC_WINDOWS_SOCKET_ARES_EV_DRIVER)+  // TODO(yijiem): (debt) move pieces for Windows+  return false;+#else+#error ""Unsupported platform""+#endif+}++struct HostbynameArg {+  GrpcAresHostnameRequest* request;+  const char* qtype;+};++constexpr char g_service_config_attribute_prefix[] = ""grpc_config="";","We actually use the prefix to check for the start of the relevant TXT record. They are structured as linked-list of `ares_txt_ext` as:```[ ares_txt_ext ] -> [ ares_txt_ext ] -> [ ares_txt_ext ] -> [ ares_txt_ext ] -> [ ares_txt_ext ] <record start>                                              <record start>```We check for `grpc_config=` prefix only at the position marked as `record_start`. If we want to move gRPC-specific DNS logic to EventEngineClientChannelResolver, I think we need to somehow replicate this data structure so as not to lose info and move this handling to EventEngineClientChannelResolver.",
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/32847,1180627093,2023-04-28T16:53:15Z,src/core/lib/iomgr/sockaddr_posix.h,"@@ -47,6 +47,7 @@ typedef struct in6_addr grpc_in6_addr;  #define GRPC_AF_UNSPEC AF_UNSPEC #define GRPC_AF_UNIX AF_UNIX+#define GRPC_AF_VSOCK AF_VSOCK","Good question, it looks inconsistent already. Most of the types used in this file are from either `sys/socket.h` or `arpa/inet.h`, which are included in this file. I _think_ the best thing to do is to conditionally include the vsock headers here, define `GRPC_AF_VSOCK` unconditionally, and wrap all uses of `GRPC_AF_VSOCK` in `#ifdef GRPC_HAVE_VSOCK`. Then all files that need to use AF_VSOCK will only have to wrap the usage in guards, not the includes.",
7221003,rockspore,https://api.github.com/repos/grpc/grpc/pulls/32970,1180755640,2023-04-28T19:40:27Z,src/core/ext/xds/xds_audit_logger_registry.cc,"@@ -29,17 +32,22 @@ #include ""src/core/ext/xds/xds_common_types.h"" #include ""src/core/lib/gprpp/validation_errors.h"" #include ""src/core/lib/json/json.h""+#include ""src/core/lib/security/authorization/audit_logging.h""  namespace grpc_core {  namespace { +using experimental::AuditLoggerRegistry;+ class StdoutLoggerConfigFactory : public XdsAuditLoggerRegistry::ConfigFactory {  public:   Json::Object ConvertXdsAuditLoggerConfig(       const XdsResourceType::DecodeContext& /*context*/,       absl::string_view /*configuration*/,       ValidationErrors* /*errors*/) override {+    // Stdout logger has no configuration right now. So we don't need to invoke","Since the config is sent as protobuf, we should be pretty confident that it doesn't contain anything unlike the case of Json. Therefore, I don't think it's necessary. See https://github.com/grpc/grpc/blob/e5725e47300ce3a0cba42b322c36cd8e8881199a/src/core/ext/xds/xds_lb_policy_registry.cc#L46 as an example.",
5663878,yijiem,https://api.github.com/repos/grpc/grpc/pulls/32701,1180852738,2023-04-28T22:16:09Z,src/core/lib/event_engine/grpc_ares_wrapper.cc,"@@ -0,0 +1,1013 @@+// Copyright 2023 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++#include <grpc/support/port_platform.h>++#include ""src/core/lib/event_engine/grpc_ares_wrapper.h""++#include ""src/core/lib/iomgr/port.h""++// IWYU pragma: no_include <arpa/inet.h>+// IWYU pragma: no_include <arpa/nameser.h>+// IWYU pragma: no_include <inttypes.h>+// IWYU pragma: no_include <netdb.h>+// IWYU pragma: no_include <netinet/in.h>+// IWYU pragma: no_include <stdlib.h>+// IWYU pragma: no_include <sys/socket.h>+// IWYU pragma: no_include <ratio>++#if GRPC_ARES == 1++#include <string.h>++#include <algorithm>+#include <chrono>+#include <initializer_list>+#include <memory>+#include <type_traits>+#include <utility>++#include <address_sorting/address_sorting.h>++#include ""absl/cleanup/cleanup.h""+#include ""absl/strings/numbers.h""+#include ""absl/strings/str_cat.h""+#include ""absl/strings/str_format.h""+#include ""absl/types/optional.h""++#include <grpc/event_engine/event_engine.h>+#include <grpc/support/alloc.h>+#include <grpc/support/log.h>++#include ""src/core/lib/address_utils/parse_address.h""+#include ""src/core/lib/address_utils/sockaddr_utils.h""+#include ""src/core/lib/event_engine/grpc_polled_fd.h""+#include ""src/core/lib/event_engine/nameser.h""  // IWYU pragma: keep+#include ""src/core/lib/event_engine/tcp_socket_utils.h""+#include ""src/core/lib/event_engine/time_util.h""+#include ""src/core/lib/gpr/string.h""+#include ""src/core/lib/gprpp/debug_location.h""+#include ""src/core/lib/gprpp/examine_stack.h""+#include ""src/core/lib/gprpp/host_port.h""+#include ""src/core/lib/gprpp/ref_counted_ptr.h""+#include ""src/core/lib/gprpp/status_helper.h""+#include ""src/core/lib/iomgr/error.h""+#include ""src/core/lib/iomgr/exec_ctx.h""+#include ""src/core/lib/iomgr/resolved_address.h""+#include ""src/core/lib/iomgr/sockaddr.h""+#ifdef GRPC_POSIX_SOCKET_ARES_EV_DRIVER+#include ""src/core/lib/event_engine/posix_engine/tcp_socket_utils.h""+#elif defined(GRPC_WINDOWS_SOCKET_ARES_EV_DRIVER)+#endif++namespace grpc_event_engine {+namespace experimental {++grpc_core::TraceFlag grpc_trace_ares_wrapper_address_sorting(+    false, ""ares_wrapper_address_sorting"");++grpc_core::TraceFlag grpc_trace_ares_wrapper_stacktrace(+    false, ""ares_wrapper_stacktrace"");++#define GRPC_ARES_WRAPPER_STACK_TRACE()                                \+  do {                                                                 \+    if (GRPC_TRACE_FLAG_ENABLED(grpc_trace_ares_wrapper_stacktrace)) { \+      absl::optional<std::string> stacktrace =                         \+          grpc_core::GetCurrentStackTrace();                           \+      if (stacktrace.has_value()) {                                    \+        gpr_log(GPR_DEBUG, ""%s"", stacktrace->c_str());                 \+      } else {                                                         \+        gpr_log(GPR_DEBUG, ""stacktrace unavailable"");                  \+      }                                                                \+    }                                                                  \+  } while (0)++grpc_core::TraceFlag grpc_trace_ares_wrapper(false,+                                             ""event_engine_ares_wrapper"");++namespace {++EventEngine::Duration calculate_next_ares_backup_poll_alarm_duration() {+  // An alternative here could be to use ares_timeout to try to be more+  // accurate, but that would require using ""struct timeval""'s, which just+  // makes things a bit more complicated. So just poll every second, as+  // suggested by the c-ares code comments.+  return std::chrono::seconds(1);+}++bool IsIpv6LoopbackAvailable() {+#ifdef GRPC_POSIX_SOCKET_ARES_EV_DRIVER+  return PosixSocketWrapper::IsIpv6LoopbackAvailable();+#elif defined(GRPC_WINDOWS_SOCKET_ARES_EV_DRIVER)+  // TODO(yijiem): (debt) move pieces for Windows+  return false;+#else+#error ""Unsupported platform""+#endif+}++struct HostbynameArg {+  GrpcAresHostnameRequest* request;+  const char* qtype;+};++constexpr char g_service_config_attribute_prefix[] = ""grpc_config="";+constexpr size_t g_prefix_len = sizeof(g_service_config_attribute_prefix) - 1;++}  // namespace++void GrpcAresHostnameRequest::OnHostbynameDoneLocked(void* arg, int status,+                                                     int /*timeouts*/,+                                                     struct hostent* hostent) {+  std::unique_ptr<HostbynameArg> harg(static_cast<HostbynameArg*>(arg));+  GrpcAresHostnameRequest* request = harg->request;+  if (status != ARES_SUCCESS) {+    std::string error_msg = absl::StrFormat(+        ""c-ares status is not ARES_SUCCESS qtype=%s name=%s: %s"", harg->qtype,+        request->host_, ares_strerror(status));+    GRPC_ARES_WRAPPER_TRACE_LOG(""request:%p on_hostbyname_done_locked: %s"",+                                request, error_msg.c_str());+    GRPC_ARES_WRAPPER_STACK_TRACE();+    absl::Status error = GRPC_ERROR_CREATE(error_msg);+    request->OnResolve(error);+    return;+  }+  GRPC_ARES_WRAPPER_TRACE_LOG(+      ""request:%p on_hostbyname_done_locked qtype=%s host=%s ARES_SUCCESS"",+      request, harg->qtype, std::string(request->host_).c_str());+  GRPC_ARES_WRAPPER_STACK_TRACE();++  std::vector<EventEngine::ResolvedAddress> resolved_addresses;+  for (size_t i = 0; hostent->h_addr_list[i] != nullptr; i++) {+    switch (hostent->h_addrtype) {+      case AF_INET6: {+        size_t addr_len = sizeof(struct sockaddr_in6);+        struct sockaddr_in6 addr;+        memset(&addr, 0, addr_len);+        memcpy(&addr.sin6_addr, hostent->h_addr_list[i],+               sizeof(struct in6_addr));+        addr.sin6_family = static_cast<unsigned char>(hostent->h_addrtype);+        addr.sin6_port = htons(request->port_);+        resolved_addresses.emplace_back(+            reinterpret_cast<const sockaddr*>(&addr), addr_len);+        char output[INET6_ADDRSTRLEN];+        ares_inet_ntop(AF_INET6, &addr.sin6_addr, output, INET6_ADDRSTRLEN);+        GRPC_ARES_WRAPPER_TRACE_LOG(+            ""request:%p c-ares resolver gets a AF_INET6 result: \n""+            ""  addr: %s\n  port: %d\n  sin6_scope_id: %d\n"",+            request, output, request->port_, addr.sin6_scope_id);+        break;+      }+      case AF_INET: {+        size_t addr_len = sizeof(struct sockaddr_in);+        struct sockaddr_in addr;+        memset(&addr, 0, addr_len);+        memcpy(&addr.sin_addr, hostent->h_addr_list[i], sizeof(struct in_addr));+        addr.sin_family = static_cast<unsigned char>(hostent->h_addrtype);+        addr.sin_port = htons(request->port_);+        resolved_addresses.emplace_back(+            reinterpret_cast<const sockaddr*>(&addr), addr_len);+        char output[INET_ADDRSTRLEN];+        ares_inet_ntop(AF_INET, &addr.sin_addr, output, INET_ADDRSTRLEN);+        GRPC_ARES_WRAPPER_TRACE_LOG(+            ""request:%p c-ares resolver gets a AF_INET result: \n""+            ""  addr: %s\n  port: %d\n"",+            request, output, request->port_);+        break;+      }+    }+  }+  request->OnResolve(std::move(resolved_addresses));+}++void GrpcAresSRVRequest::OnSRVQueryDoneLocked(void* arg, int status,+                                              int /*timeouts*/,+                                              unsigned char* abuf, int alen) {+  GrpcAresSRVRequest* r = static_cast<GrpcAresSRVRequest*>(arg);+  if (status != ARES_SUCCESS) {+    std::string error_msg = absl::StrFormat(+        ""c-ares status is not ARES_SUCCESS qtype=SRV name=%s: %s"",+        r->service_name_, ares_strerror(status));+    GRPC_ARES_WRAPPER_TRACE_LOG(""request:%p on_srv_query_done_locked: %s"", r,+                                error_msg.c_str());+    grpc_error_handle error = GRPC_ERROR_CREATE(error_msg);+    r->OnResolve(error);+    return;+  }+  GRPC_ARES_WRAPPER_TRACE_LOG(+      ""request:%p on_srv_query_done_locked name=%s ARES_SUCCESS"", r,+      r->service_name_.c_str());+  struct ares_srv_reply* reply = nullptr;+  const int parse_status = ares_parse_srv_reply(abuf, alen, &reply);+  GRPC_ARES_WRAPPER_TRACE_LOG(""request:%p ares_parse_srv_reply: %d"", r,+                              parse_status);+  Result result;+  if (parse_status == ARES_SUCCESS) {+    for (struct ares_srv_reply* srv_it = reply; srv_it != nullptr;+         srv_it = srv_it->next) {+      EventEngine::DNSResolver::SRVRecord record;+      record.host = srv_it->host;+      record.port = srv_it->port;+      record.priority = srv_it->priority;+      record.weight = srv_it->weight;+      result.push_back(std::move(record));+    }+  }+  if (reply != nullptr) {+    ares_free_data(reply);+  }+  r->OnResolve(std::move(result));+}++void GrpcAresTXTRequest::OnTXTDoneLocked(void* arg, int status,+                                         int /*timeouts*/, unsigned char* buf,+                                         int len) {+  GrpcAresTXTRequest* r = static_cast<GrpcAresTXTRequest*>(arg);+  struct ares_txt_ext* reply = nullptr;+  int parse_status = ARES_SUCCESS;+  if (status == ARES_SUCCESS) {+    GRPC_ARES_WRAPPER_TRACE_LOG(+        ""request:%p on_txt_done_locked name=%s ARES_SUCCESS"", r,+        r->config_name_.c_str());+    parse_status = ares_parse_txt_reply_ext(buf, len, &reply);+  }+  if (status != ARES_SUCCESS || parse_status != ARES_SUCCESS) {+    grpc_error_handle error;+    std::string error_msg = absl::StrFormat(+        ""c-ares status is not ARES_SUCCESS qtype=TXT name=%s: %s"",+        r->config_name_.c_str(), ares_strerror(status));+    GRPC_ARES_WRAPPER_TRACE_LOG(""request:%p on_txt_done_locked %s"", r,+                                error_msg.c_str());+    error = GRPC_ERROR_CREATE(error_msg);+    r->OnResolve(error);+    return;+  }+  // Find service config in TXT record.+  struct ares_txt_ext* result = nullptr;+  for (result = reply; result != nullptr; result = result->next) {+    if (result->record_start &&+        memcmp(result->txt, g_service_config_attribute_prefix, g_prefix_len) ==+            0) {+      break;+    }+  }+  std::string service_config_json_out;+  // Found a service config record.+  if (result != nullptr) {+    size_t service_config_len = result->length - g_prefix_len;+    service_config_json_out.append(+        reinterpret_cast<char*>(result->txt) + g_prefix_len,+        service_config_len);+    for (result = result->next; result != nullptr && !result->record_start;+         result = result->next) {+      service_config_json_out.append(reinterpret_cast<char*>(result->txt),+                                     result->length);+    }+    GRPC_ARES_WRAPPER_TRACE_LOG(""request:%p found service config: %s"", r,+                                service_config_json_out.c_str());+  }+  // Clean up.+  ares_free_data(reply);+  r->OnResolve(std::move(service_config_json_out));+}++GrpcAresRequest::FdNode::FdNode(ares_socket_t as, GrpcPolledFd* polled_fd)+    : as(as), polled_fd(polled_fd) {}++GrpcAresRequest::FdNode* GrpcAresRequest::FdNodeList::PopFdNode(+    ares_socket_t as) {+  FdNode phony_head;+  phony_head.next = head_;+  FdNode* node = &phony_head;+  while (node->next != nullptr) {+    if (node->next->polled_fd->GetWrappedAresSocketLocked() == as) {+      FdNode* ret = node->next;+      node->next = node->next->next;+      head_ = phony_head.next;+      return ret;+    }+    node = node->next;+  }+  return nullptr;+}++GrpcAresRequest::GrpcAresRequest(+    absl::string_view name, absl::optional<absl::string_view> default_port,+    EventEngine::Duration timeout,+    std::unique_ptr<GrpcPolledFdFactory> polled_fd_factory,+    EventEngine* event_engine)+    : grpc_core::InternallyRefCounted<GrpcAresRequest>(+          GRPC_TRACE_FLAG_ENABLED(grpc_trace_ares_wrapper) ? ""GrpcAresRequest""+                                                           : nullptr),+      name_(name),+      default_port_(default_port.has_value() ? *default_port : """"),+      fd_node_list_(std::make_unique<FdNodeList>()),+      timeout_(timeout),+      event_engine_(event_engine),+      polled_fd_factory_(std::move(polled_fd_factory)) {}++GrpcAresRequest::~GrpcAresRequest() {+  if (initialized_) {+    ares_destroy(channel_);+    GRPC_ARES_WRAPPER_STACK_TRACE();+  }+  GRPC_ARES_WRAPPER_TRACE_LOG(""request:%p destructor"", this);+}++absl::Status GrpcAresRequest::Initialize(absl::string_view dns_server,+                                         bool check_port) {+  grpc_core::MutexLock lock(&mu_);+  GPR_DEBUG_ASSERT(!initialized_);+  absl::string_view port;+  // parse name, splitting it into host and port parts+  grpc_core::SplitHostPort(name_, &host_, &port);+  absl::Status error;+  if (host_.empty()) {+    error =+        grpc_error_set_str(GRPC_ERROR_CREATE(""unparseable host:port""),+                           grpc_core::StatusStrProperty::kTargetAddress, name_);+    return error;+  } else if (check_port && port.empty()) {+    if (default_port_.empty()) {+      error = grpc_error_set_str(GRPC_ERROR_CREATE(""no port in name""),+                                 grpc_core::StatusStrProperty::kTargetAddress,+                                 name_);+      return error;+    }+    port = default_port_;+  }+  if (!port.empty()) {+    if (port == ""http"") {+      port_ = 80;+    } else if (port == ""https"") {+      port_ = 443;+    } else {+      GPR_ASSERT(absl::SimpleAtoi(port, &port_));+    }+  }+  ares_options opts = {};+  opts.flags |= ARES_FLAG_STAYOPEN;+  int status = ares_init_options(&channel_, &opts, ARES_OPT_FLAGS);+  if (status != ARES_SUCCESS) {+    gpr_log(GPR_ERROR, ""ares_init_options failed, status: %d"", status);+    return GRPC_ERROR_CREATE(absl::StrCat(+        ""Failed to init ares channel. c-ares error: "", ares_strerror(status)));+  }+  event_engine_grpc_ares_test_only_inject_config(channel_);+  // If dns_server is specified, use it.+  error = SetRequestDNSServer(dns_server);+  if (!error.ok()) {+    ares_destroy(channel_);+    return error;+  }+  initialized_ = true;+  return absl::OkStatus();+}++bool GrpcAresRequest::Cancel() {+  grpc_core::MutexLock lock(&mu_);+  if (std::exchange(shutting_down_, true)) {+    // Already shutting down, maybe resolved, cancelled or timed-out.+    return false;+  }+  cancelled_ = true;+  CancelTimers();+  ShutdownPolledFdsLocked(grpc_core::StatusCreate(+      absl::StatusCode::kCancelled, ""Cancel"", DEBUG_LOCATION, {}));+  return true;+}++void GrpcAresRequest::Work() {+  auto new_list = std::make_unique<FdNodeList>();+  if (!shutting_down_) {+    ares_socket_t socks[ARES_GETSOCK_MAXNUM];+    int socks_bitmask = ares_getsock(channel_, socks, ARES_GETSOCK_MAXNUM);+    for (size_t i = 0; i < ARES_GETSOCK_MAXNUM; i++) {+      if (ARES_GETSOCK_READABLE(socks_bitmask, i) ||+          ARES_GETSOCK_WRITABLE(socks_bitmask, i)) {+        FdNode* fd_node = fd_node_list_->PopFdNode(socks[i]);+        if (fd_node == nullptr) {+          fd_node = new FdNode(+              socks[i], polled_fd_factory_->NewGrpcPolledFdLocked(socks[i]));+          GRPC_ARES_WRAPPER_TRACE_LOG(""request:%p new fd: %d"", this,+                                      fd_node->as);+        }+        new_list->PushFdNode(fd_node);+        // Register read_closure if the socket is readable and read_closure+        // has not been registered with this socket.+        if (ARES_GETSOCK_READABLE(socks_bitmask, i) &&+            !fd_node->readable_registered) {+          GRPC_ARES_WRAPPER_TRACE_LOG(""request:%p notify read on: %d"", this,+                                      fd_node->as);+          fd_node->readable_registered = true;+          fd_node->polled_fd->RegisterForOnReadableLocked(+              [self = Ref(DEBUG_LOCATION, ""Work""),+               fd_node](absl::Status status) mutable {+                // This closure might hold the last RefCount to GrpcAresRequest+                // so its destruction might trigger a chain reaction of+                // destruction: ~GrpcAresRequest ->+                // ~EventEngineClientChannelDNSResolver -> ~PollingResolver ->+                // ~ResolverResultHandler -> grpc_stream_destroy which requires+                // ExecCtx.+                grpc_core::ApplicationCallbackExecCtx callback_exec_ctx;+                grpc_core::ExecCtx exec_ctx;+                self->OnReadable(fd_node, status);+                self.reset();+              });+        }+        // Register write_closure if the socket is writable and write_closure+        // has not been registered with this socket.+        if (ARES_GETSOCK_WRITABLE(socks_bitmask, i) &&+            !fd_node->writable_registered) {+          GRPC_ARES_WRAPPER_TRACE_LOG(""request:%p notify write on: %d"", this,+                                      fd_node->as);+          fd_node->writable_registered = true;+          fd_node->polled_fd->RegisterForOnWriteableLocked(+              [self = Ref(DEBUG_LOCATION, ""Work""),+               fd_node](absl::Status status) mutable {+                grpc_core::ApplicationCallbackExecCtx callback_exec_ctx;+                grpc_core::ExecCtx exec_ctx;+                self->OnWritable(fd_node, status);+                self.reset();+              });+        }+      }+    }+  }+  // Any remaining fds in ev_driver->fds were not returned by ares_getsock()+  // and are therefore no longer in use, so they can be shut down and removed+  // from the list.+  while (!fd_node_list_->IsEmpty()) {+    FdNode* fd_node = fd_node_list_->PopFdNode();+    if (!fd_node->already_shutdown) {+      GRPC_ARES_WRAPPER_TRACE_LOG(""request: %p shutdown fd: %s"", this,+                                  fd_node->polled_fd->GetName());+      fd_node->polled_fd->ShutdownLocked(absl::OkStatus());+      fd_node->already_shutdown = true;+    }+    if (!fd_node->readable_registered && !fd_node->writable_registered) {+      GRPC_ARES_WRAPPER_TRACE_LOG(""request: %p delete fd: %s"", this,+                                  fd_node->polled_fd->GetName());+      delete fd_node;+    } else {+      new_list->PushFdNode(fd_node);+    }+  }+  fd_node_list_.swap(new_list);+}++void GrpcAresRequest::StartTimers() {+  // Initialize overall DNS resolution timeout alarm+  EventEngine::Duration timeout =+      timeout_.count() == 0 ? EventEngine::Duration::max() : timeout_;+  GRPC_ARES_WRAPPER_TRACE_LOG(""request:%p StartTimers timeout in %"" PRId64+                              "" ms"",+                              this, Milliseconds(timeout));++  Ref(DEBUG_LOCATION, ""StartTimers"").release();+  query_timeout_handle_ = event_engine_->RunAfter(timeout, [this] {+    grpc_core::ApplicationCallbackExecCtx callback_exec_ctx;+    grpc_core::ExecCtx exec_ctx;+    OnQueryTimeout();+  });++  // Initialize the backup poll alarm+  EventEngine::Duration next_ares_backup_poll_alarm_duration =+      calculate_next_ares_backup_poll_alarm_duration();+  GRPC_ARES_WRAPPER_TRACE_LOG(+      ""request:%p StartTimers next ares process poll time in %"" PRId64 "" ms"",+      this, Milliseconds(next_ares_backup_poll_alarm_duration));++  Ref(DEBUG_LOCATION, ""StartTimers"").release();+  ares_backup_poll_alarm_handle_ =+      event_engine_->RunAfter(next_ares_backup_poll_alarm_duration, [this] {+        grpc_core::ApplicationCallbackExecCtx callback_exec_ctx;+        grpc_core::ExecCtx exec_ctx;+        OnAresBackupPollAlarm();+      });+}++void GrpcAresRequest::CancelTimers() {+  if (query_timeout_handle_.has_value()) {+    if (event_engine_->Cancel(*query_timeout_handle_)) {+      Unref(DEBUG_LOCATION, ""CancelTimers"");+    }+    query_timeout_handle_.reset();+  }+  if (ares_backup_poll_alarm_handle_.has_value()) {+    if (event_engine_->Cancel(*ares_backup_poll_alarm_handle_)) {+      Unref(DEBUG_LOCATION, ""CancelTimers"");+    }+    ares_backup_poll_alarm_handle_.reset();+  }+}++absl::Status GrpcAresRequest::SetRequestDNSServer(+    absl::string_view dns_server) {+  if (!dns_server.empty()) {+    GRPC_ARES_WRAPPER_TRACE_LOG(""request:%p Using DNS server %s"", this,+                                dns_server.data());+    grpc_resolved_address addr;+    struct ares_addr_port_node dns_server_addr;+    if (grpc_parse_ipv4_hostport(dns_server, &addr, /*log_errors=*/false)) {+      dns_server_addr.family = AF_INET;+      struct sockaddr_in* in = reinterpret_cast<struct sockaddr_in*>(addr.addr);+      memcpy(&dns_server_addr.addr.addr4, &in->sin_addr,+             sizeof(struct in_addr));+      dns_server_addr.tcp_port = grpc_sockaddr_get_port(&addr);+      dns_server_addr.udp_port = grpc_sockaddr_get_port(&addr);+    } else if (grpc_parse_ipv6_hostport(dns_server, &addr,+                                        /*log_errors=*/false)) {+      dns_server_addr.family = AF_INET6;+      struct sockaddr_in6* in6 =+          reinterpret_cast<struct sockaddr_in6*>(addr.addr);+      memcpy(&dns_server_addr.addr.addr6, &in6->sin6_addr,+             sizeof(struct in6_addr));+      dns_server_addr.tcp_port = grpc_sockaddr_get_port(&addr);+      dns_server_addr.udp_port = grpc_sockaddr_get_port(&addr);+    } else {+      return GRPC_ERROR_CREATE(+          absl::StrCat(""cannot parse authority "", dns_server));+    }+    // Prevent an uninitialized variable.+    dns_server_addr.next = nullptr;+    int status = ares_set_servers_ports(channel_, &dns_server_addr);+    if (status != ARES_SUCCESS) {+      return GRPC_ERROR_CREATE(absl::StrCat(+          ""c-ares status is not ARES_SUCCESS: "", ares_strerror(status)));+    }+  }+  return absl::OkStatus();+}++void GrpcAresRequest::OnReadable(FdNode* fd_node, absl::Status status) {+  grpc_core::MutexLock lock(&mu_);+  GPR_ASSERT(fd_node->readable_registered);+  fd_node->readable_registered = false;+  GRPC_ARES_WRAPPER_TRACE_LOG(""OnReadable: fd: %d; request: %p; status: %s"",+                              fd_node->as, this, status.ToString().c_str());+  GRPC_ARES_WRAPPER_STACK_TRACE();+  if (status.ok() && !shutting_down_) {+    do {+      ares_process_fd(channel_, fd_node->as, ARES_SOCKET_BAD);+    } while (fd_node->polled_fd->IsFdStillReadableLocked());+  } else {+    // If error is not absl::OkStatus() or the resolution was cancelled, it+    // means the fd has been shutdown or timed out. The pending lookups made+    // on this ev_driver will be cancelled by the following ares_cancel() and+    // the on_done callbacks will be invoked with a status of ARES_ECANCELLED.+    // The remaining file descriptors in this ev_driver will be cleaned up in+    // the follwing grpc_ares_notify_on_event_locked().+    ares_cancel(channel_);+  }+  Work();+}++void GrpcAresRequest::OnWritable(FdNode* fd_node, absl::Status status) {+  grpc_core::MutexLock lock(&mu_);+  GPR_ASSERT(fd_node->writable_registered);+  fd_node->writable_registered = false;+  GRPC_ARES_WRAPPER_TRACE_LOG(""OnWritable: fd: %d; request:%p; status: %s"",+                              fd_node->as, this, status.ToString().c_str());+  if (status.ok() && !shutting_down_) {+    ares_process_fd(channel_, ARES_SOCKET_BAD, fd_node->as);+  } else {+    // If error is not absl::OkStatus() or the resolution was cancelled, it+    // means the fd has been shutdown or timed out. The pending lookups made+    // on this ev_driver will be cancelled by the following ares_cancel() and+    // the on_done callbacks will be invoked with a status of ARES_ECANCELLED.+    // The remaining file descriptors in this ev_driver will be cleaned up in+    // the follwing grpc_ares_notify_on_event_locked().+    ares_cancel(channel_);+  }+  Work();+}++void GrpcAresRequest::OnQueryTimeout() {+  {+    grpc_core::MutexLock lock(&mu_);+    query_timeout_handle_.reset();+    GRPC_ARES_WRAPPER_TRACE_LOG(""request:%p OnQueryTimeout. shutting_down_=%d"",+                                this, shutting_down_);+    if (!shutting_down_) {+      shutting_down_ = true;+      ShutdownPolledFdsLocked(+          grpc_core::StatusCreate(absl::StatusCode::kDeadlineExceeded,+                                  ""OnQueryTimeout"", DEBUG_LOCATION, {}));+    }+  }+  Unref(DEBUG_LOCATION, ""OnQueryTimeout"");+}++// In case of non-responsive DNS servers, dropped packets, etc., c-ares has+// intelligent timeout and retry logic, which we can take advantage of by+// polling ares_process_fd on time intervals. Overall, the c-ares library is+// meant to be called into and given a chance to proceed name resolution:+//   a) when fd events happen+//   b) when some time has passed without fd events having happened+// For the latter, we use this backup poller. Also see+// https://github.com/grpc/grpc/pull/17688 description for more details.+void GrpcAresRequest::OnAresBackupPollAlarm() {+  {+    grpc_core::MutexLock lock(&mu_);+    ares_backup_poll_alarm_handle_.reset();+    GRPC_ARES_WRAPPER_TRACE_LOG(+        ""request:%p OnAresBackupPollAlarm shutting_down=%d."", this,+        shutting_down_);+    if (!shutting_down_) {+      for (auto it = fd_node_list_->begin(); it != fd_node_list_->end(); it++) {+        if (!(*it)->already_shutdown) {+          GRPC_ARES_WRAPPER_TRACE_LOG(+              ""request:%p OnAresBackupPollAlarm; ares_process_fd. fd=%s"", this,+              (*it)->polled_fd->GetName());+          ares_socket_t as = (*it)->polled_fd->GetWrappedAresSocketLocked();+          ares_process_fd(channel_, as, as);+        }+      }+      if (!shutting_down_) {+        EventEngine::Duration next_ares_backup_poll_alarm_duration =+            calculate_next_ares_backup_poll_alarm_duration();+        Ref(DEBUG_LOCATION, ""OnAresBackupPollAlarm"").release();+        ares_backup_poll_alarm_handle_ = event_engine_->RunAfter(+            next_ares_backup_poll_alarm_duration, [this] {+              grpc_core::ApplicationCallbackExecCtx callback_exec_ctx;+              grpc_core::ExecCtx exec_ctx;+              OnAresBackupPollAlarm();","A separate question: is it worth to guarantee that every code path from grpc_ares_wrapper/EventEngine::DNSResolver out to its caller have an ExecCtx on the stack?There are 2 types of such code paths:A. Calling `on_resolve_`: this is easy to handle by making sure ExecCtx is on the stackB. Destruction of `on_resolve_`: since the `on_resolve_` closure in GrpcAres(Hostname|SRV|TXT)Request owns the `on_resolve` closure passed in from the caller to EventEngine::DNSResolver, e.g. LookupHostnameCallback.  The destruction of `on_resolve_` may trigger a chain of destruction outward to a place which may require an ExecCtx in the thread.This at least has 2 cases:B.1 Cancellation: the caller's `on_resolve` will not be called, but its destruction will happen when the request gets destroyed.B.2 The `on_resolve` is destroyed after being called.To handle B.1, I added an ExecCtx in each destructor of GrpcAres(Hostname|SRV|TXT)Request and trigger the destruction of `on_resolve_` before the destruction of the ExecCtx.To handle B.2, I made sure that the destruction of `on_resolve` after it being called happens before the destruction of an ExecCtx.PTAL. Thanks!",
5663878,yijiem,https://api.github.com/repos/grpc/grpc/pulls/32701,1180872058,2023-04-28T23:06:35Z,src/core/lib/event_engine/grpc_ares_wrapper.cc,"@@ -0,0 +1,1013 @@+// Copyright 2023 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++#include <grpc/support/port_platform.h>++#include ""src/core/lib/event_engine/grpc_ares_wrapper.h""++#include ""src/core/lib/iomgr/port.h""++// IWYU pragma: no_include <arpa/inet.h>+// IWYU pragma: no_include <arpa/nameser.h>+// IWYU pragma: no_include <inttypes.h>+// IWYU pragma: no_include <netdb.h>+// IWYU pragma: no_include <netinet/in.h>+// IWYU pragma: no_include <stdlib.h>+// IWYU pragma: no_include <sys/socket.h>+// IWYU pragma: no_include <ratio>++#if GRPC_ARES == 1++#include <string.h>++#include <algorithm>+#include <chrono>+#include <initializer_list>+#include <memory>+#include <type_traits>+#include <utility>++#include <address_sorting/address_sorting.h>++#include ""absl/cleanup/cleanup.h""+#include ""absl/strings/numbers.h""+#include ""absl/strings/str_cat.h""+#include ""absl/strings/str_format.h""+#include ""absl/types/optional.h""++#include <grpc/event_engine/event_engine.h>+#include <grpc/support/alloc.h>+#include <grpc/support/log.h>++#include ""src/core/lib/address_utils/parse_address.h""+#include ""src/core/lib/address_utils/sockaddr_utils.h""+#include ""src/core/lib/event_engine/grpc_polled_fd.h""+#include ""src/core/lib/event_engine/nameser.h""  // IWYU pragma: keep+#include ""src/core/lib/event_engine/tcp_socket_utils.h""+#include ""src/core/lib/event_engine/time_util.h""+#include ""src/core/lib/gpr/string.h""+#include ""src/core/lib/gprpp/debug_location.h""+#include ""src/core/lib/gprpp/examine_stack.h""+#include ""src/core/lib/gprpp/host_port.h""+#include ""src/core/lib/gprpp/ref_counted_ptr.h""+#include ""src/core/lib/gprpp/status_helper.h""+#include ""src/core/lib/iomgr/error.h""+#include ""src/core/lib/iomgr/exec_ctx.h""+#include ""src/core/lib/iomgr/resolved_address.h""+#include ""src/core/lib/iomgr/sockaddr.h""+#ifdef GRPC_POSIX_SOCKET_ARES_EV_DRIVER+#include ""src/core/lib/event_engine/posix_engine/tcp_socket_utils.h""+#elif defined(GRPC_WINDOWS_SOCKET_ARES_EV_DRIVER)+#endif++namespace grpc_event_engine {+namespace experimental {++grpc_core::TraceFlag grpc_trace_ares_wrapper_address_sorting(+    false, ""ares_wrapper_address_sorting"");++grpc_core::TraceFlag grpc_trace_ares_wrapper_stacktrace(+    false, ""ares_wrapper_stacktrace"");++#define GRPC_ARES_WRAPPER_STACK_TRACE()                                \+  do {                                                                 \+    if (GRPC_TRACE_FLAG_ENABLED(grpc_trace_ares_wrapper_stacktrace)) { \+      absl::optional<std::string> stacktrace =                         \+          grpc_core::GetCurrentStackTrace();                           \+      if (stacktrace.has_value()) {                                    \+        gpr_log(GPR_DEBUG, ""%s"", stacktrace->c_str());                 \+      } else {                                                         \+        gpr_log(GPR_DEBUG, ""stacktrace unavailable"");                  \+      }                                                                \+    }                                                                  \+  } while (0)++grpc_core::TraceFlag grpc_trace_ares_wrapper(false,+                                             ""event_engine_ares_wrapper"");++namespace {++EventEngine::Duration calculate_next_ares_backup_poll_alarm_duration() {+  // An alternative here could be to use ares_timeout to try to be more+  // accurate, but that would require using ""struct timeval""'s, which just+  // makes things a bit more complicated. So just poll every second, as+  // suggested by the c-ares code comments.+  return std::chrono::seconds(1);+}++bool IsIpv6LoopbackAvailable() {+#ifdef GRPC_POSIX_SOCKET_ARES_EV_DRIVER+  return PosixSocketWrapper::IsIpv6LoopbackAvailable();+#elif defined(GRPC_WINDOWS_SOCKET_ARES_EV_DRIVER)+  // TODO(yijiem): (debt) move pieces for Windows+  return false;+#else+#error ""Unsupported platform""+#endif+}++struct HostbynameArg {+  GrpcAresHostnameRequest* request;+  const char* qtype;+};++constexpr char g_service_config_attribute_prefix[] = ""grpc_config="";+constexpr size_t g_prefix_len = sizeof(g_service_config_attribute_prefix) - 1;++}  // namespace++void GrpcAresHostnameRequest::OnHostbynameDoneLocked(void* arg, int status,+                                                     int /*timeouts*/,+                                                     struct hostent* hostent) {+  std::unique_ptr<HostbynameArg> harg(static_cast<HostbynameArg*>(arg));+  GrpcAresHostnameRequest* request = harg->request;+  if (status != ARES_SUCCESS) {+    std::string error_msg = absl::StrFormat(+        ""c-ares status is not ARES_SUCCESS qtype=%s name=%s: %s"", harg->qtype,+        request->host_, ares_strerror(status));+    GRPC_ARES_WRAPPER_TRACE_LOG(""request:%p on_hostbyname_done_locked: %s"",+                                request, error_msg.c_str());+    GRPC_ARES_WRAPPER_STACK_TRACE();+    absl::Status error = GRPC_ERROR_CREATE(error_msg);+    request->OnResolve(error);+    return;+  }+  GRPC_ARES_WRAPPER_TRACE_LOG(+      ""request:%p on_hostbyname_done_locked qtype=%s host=%s ARES_SUCCESS"",+      request, harg->qtype, std::string(request->host_).c_str());+  GRPC_ARES_WRAPPER_STACK_TRACE();++  std::vector<EventEngine::ResolvedAddress> resolved_addresses;+  for (size_t i = 0; hostent->h_addr_list[i] != nullptr; i++) {+    switch (hostent->h_addrtype) {+      case AF_INET6: {+        size_t addr_len = sizeof(struct sockaddr_in6);+        struct sockaddr_in6 addr;+        memset(&addr, 0, addr_len);+        memcpy(&addr.sin6_addr, hostent->h_addr_list[i],+               sizeof(struct in6_addr));+        addr.sin6_family = static_cast<unsigned char>(hostent->h_addrtype);+        addr.sin6_port = htons(request->port_);+        resolved_addresses.emplace_back(+            reinterpret_cast<const sockaddr*>(&addr), addr_len);+        char output[INET6_ADDRSTRLEN];+        ares_inet_ntop(AF_INET6, &addr.sin6_addr, output, INET6_ADDRSTRLEN);+        GRPC_ARES_WRAPPER_TRACE_LOG(+            ""request:%p c-ares resolver gets a AF_INET6 result: \n""+            ""  addr: %s\n  port: %d\n  sin6_scope_id: %d\n"",+            request, output, request->port_, addr.sin6_scope_id);+        break;+      }+      case AF_INET: {+        size_t addr_len = sizeof(struct sockaddr_in);+        struct sockaddr_in addr;+        memset(&addr, 0, addr_len);+        memcpy(&addr.sin_addr, hostent->h_addr_list[i], sizeof(struct in_addr));+        addr.sin_family = static_cast<unsigned char>(hostent->h_addrtype);+        addr.sin_port = htons(request->port_);+        resolved_addresses.emplace_back(+            reinterpret_cast<const sockaddr*>(&addr), addr_len);+        char output[INET_ADDRSTRLEN];+        ares_inet_ntop(AF_INET, &addr.sin_addr, output, INET_ADDRSTRLEN);+        GRPC_ARES_WRAPPER_TRACE_LOG(+            ""request:%p c-ares resolver gets a AF_INET result: \n""+            ""  addr: %s\n  port: %d\n"",+            request, output, request->port_);+        break;+      }+    }+  }+  request->OnResolve(std::move(resolved_addresses));+}++void GrpcAresSRVRequest::OnSRVQueryDoneLocked(void* arg, int status,+                                              int /*timeouts*/,+                                              unsigned char* abuf, int alen) {+  GrpcAresSRVRequest* r = static_cast<GrpcAresSRVRequest*>(arg);+  if (status != ARES_SUCCESS) {+    std::string error_msg = absl::StrFormat(+        ""c-ares status is not ARES_SUCCESS qtype=SRV name=%s: %s"",+        r->service_name_, ares_strerror(status));+    GRPC_ARES_WRAPPER_TRACE_LOG(""request:%p on_srv_query_done_locked: %s"", r,+                                error_msg.c_str());+    grpc_error_handle error = GRPC_ERROR_CREATE(error_msg);+    r->OnResolve(error);+    return;+  }+  GRPC_ARES_WRAPPER_TRACE_LOG(+      ""request:%p on_srv_query_done_locked name=%s ARES_SUCCESS"", r,+      r->service_name_.c_str());+  struct ares_srv_reply* reply = nullptr;+  const int parse_status = ares_parse_srv_reply(abuf, alen, &reply);+  GRPC_ARES_WRAPPER_TRACE_LOG(""request:%p ares_parse_srv_reply: %d"", r,+                              parse_status);+  Result result;+  if (parse_status == ARES_SUCCESS) {+    for (struct ares_srv_reply* srv_it = reply; srv_it != nullptr;+         srv_it = srv_it->next) {+      EventEngine::DNSResolver::SRVRecord record;+      record.host = srv_it->host;+      record.port = srv_it->port;+      record.priority = srv_it->priority;+      record.weight = srv_it->weight;+      result.push_back(std::move(record));+    }+  }+  if (reply != nullptr) {+    ares_free_data(reply);+  }+  r->OnResolve(std::move(result));+}++void GrpcAresTXTRequest::OnTXTDoneLocked(void* arg, int status,+                                         int /*timeouts*/, unsigned char* buf,+                                         int len) {+  GrpcAresTXTRequest* r = static_cast<GrpcAresTXTRequest*>(arg);+  struct ares_txt_ext* reply = nullptr;+  int parse_status = ARES_SUCCESS;+  if (status == ARES_SUCCESS) {+    GRPC_ARES_WRAPPER_TRACE_LOG(+        ""request:%p on_txt_done_locked name=%s ARES_SUCCESS"", r,+        r->config_name_.c_str());+    parse_status = ares_parse_txt_reply_ext(buf, len, &reply);+  }+  if (status != ARES_SUCCESS || parse_status != ARES_SUCCESS) {+    grpc_error_handle error;+    std::string error_msg = absl::StrFormat(+        ""c-ares status is not ARES_SUCCESS qtype=TXT name=%s: %s"",+        r->config_name_.c_str(), ares_strerror(status));+    GRPC_ARES_WRAPPER_TRACE_LOG(""request:%p on_txt_done_locked %s"", r,+                                error_msg.c_str());+    error = GRPC_ERROR_CREATE(error_msg);+    r->OnResolve(error);+    return;+  }+  // Find service config in TXT record.+  struct ares_txt_ext* result = nullptr;+  for (result = reply; result != nullptr; result = result->next) {+    if (result->record_start &&+        memcmp(result->txt, g_service_config_attribute_prefix, g_prefix_len) ==+            0) {+      break;+    }+  }+  std::string service_config_json_out;+  // Found a service config record.+  if (result != nullptr) {+    size_t service_config_len = result->length - g_prefix_len;+    service_config_json_out.append(+        reinterpret_cast<char*>(result->txt) + g_prefix_len,+        service_config_len);+    for (result = result->next; result != nullptr && !result->record_start;+         result = result->next) {+      service_config_json_out.append(reinterpret_cast<char*>(result->txt),+                                     result->length);+    }+    GRPC_ARES_WRAPPER_TRACE_LOG(""request:%p found service config: %s"", r,+                                service_config_json_out.c_str());+  }+  // Clean up.+  ares_free_data(reply);+  r->OnResolve(std::move(service_config_json_out));+}++GrpcAresRequest::FdNode::FdNode(ares_socket_t as, GrpcPolledFd* polled_fd)+    : as(as), polled_fd(polled_fd) {}++GrpcAresRequest::FdNode* GrpcAresRequest::FdNodeList::PopFdNode(+    ares_socket_t as) {+  FdNode phony_head;+  phony_head.next = head_;+  FdNode* node = &phony_head;+  while (node->next != nullptr) {+    if (node->next->polled_fd->GetWrappedAresSocketLocked() == as) {+      FdNode* ret = node->next;+      node->next = node->next->next;+      head_ = phony_head.next;+      return ret;+    }+    node = node->next;+  }+  return nullptr;+}++GrpcAresRequest::GrpcAresRequest(+    absl::string_view name, absl::optional<absl::string_view> default_port,+    EventEngine::Duration timeout,+    std::unique_ptr<GrpcPolledFdFactory> polled_fd_factory,+    EventEngine* event_engine)+    : grpc_core::InternallyRefCounted<GrpcAresRequest>(+          GRPC_TRACE_FLAG_ENABLED(grpc_trace_ares_wrapper) ? ""GrpcAresRequest""+                                                           : nullptr),+      name_(name),+      default_port_(default_port.has_value() ? *default_port : """"),+      fd_node_list_(std::make_unique<FdNodeList>()),+      timeout_(timeout),+      event_engine_(event_engine),+      polled_fd_factory_(std::move(polled_fd_factory)) {}++GrpcAresRequest::~GrpcAresRequest() {+  if (initialized_) {+    ares_destroy(channel_);+    GRPC_ARES_WRAPPER_STACK_TRACE();+  }+  GRPC_ARES_WRAPPER_TRACE_LOG(""request:%p destructor"", this);+}++absl::Status GrpcAresRequest::Initialize(absl::string_view dns_server,+                                         bool check_port) {+  grpc_core::MutexLock lock(&mu_);+  GPR_DEBUG_ASSERT(!initialized_);+  absl::string_view port;+  // parse name, splitting it into host and port parts+  grpc_core::SplitHostPort(name_, &host_, &port);+  absl::Status error;+  if (host_.empty()) {+    error =+        grpc_error_set_str(GRPC_ERROR_CREATE(""unparseable host:port""),+                           grpc_core::StatusStrProperty::kTargetAddress, name_);+    return error;+  } else if (check_port && port.empty()) {+    if (default_port_.empty()) {+      error = grpc_error_set_str(GRPC_ERROR_CREATE(""no port in name""),+                                 grpc_core::StatusStrProperty::kTargetAddress,+                                 name_);+      return error;+    }+    port = default_port_;+  }+  if (!port.empty()) {+    if (port == ""http"") {+      port_ = 80;+    } else if (port == ""https"") {+      port_ = 443;+    } else {+      GPR_ASSERT(absl::SimpleAtoi(port, &port_));+    }+  }+  ares_options opts = {};+  opts.flags |= ARES_FLAG_STAYOPEN;+  int status = ares_init_options(&channel_, &opts, ARES_OPT_FLAGS);+  if (status != ARES_SUCCESS) {+    gpr_log(GPR_ERROR, ""ares_init_options failed, status: %d"", status);+    return GRPC_ERROR_CREATE(absl::StrCat(+        ""Failed to init ares channel. c-ares error: "", ares_strerror(status)));+  }+  event_engine_grpc_ares_test_only_inject_config(channel_);+  // If dns_server is specified, use it.+  error = SetRequestDNSServer(dns_server);+  if (!error.ok()) {+    ares_destroy(channel_);+    return error;+  }+  initialized_ = true;+  return absl::OkStatus();+}++bool GrpcAresRequest::Cancel() {+  grpc_core::MutexLock lock(&mu_);+  if (std::exchange(shutting_down_, true)) {+    // Already shutting down, maybe resolved, cancelled or timed-out.+    return false;+  }+  cancelled_ = true;+  CancelTimers();+  ShutdownPolledFdsLocked(grpc_core::StatusCreate(+      absl::StatusCode::kCancelled, ""Cancel"", DEBUG_LOCATION, {}));+  return true;+}++void GrpcAresRequest::Work() {+  auto new_list = std::make_unique<FdNodeList>();+  if (!shutting_down_) {+    ares_socket_t socks[ARES_GETSOCK_MAXNUM];+    int socks_bitmask = ares_getsock(channel_, socks, ARES_GETSOCK_MAXNUM);+    for (size_t i = 0; i < ARES_GETSOCK_MAXNUM; i++) {+      if (ARES_GETSOCK_READABLE(socks_bitmask, i) ||+          ARES_GETSOCK_WRITABLE(socks_bitmask, i)) {+        FdNode* fd_node = fd_node_list_->PopFdNode(socks[i]);+        if (fd_node == nullptr) {+          fd_node = new FdNode(+              socks[i], polled_fd_factory_->NewGrpcPolledFdLocked(socks[i]));+          GRPC_ARES_WRAPPER_TRACE_LOG(""request:%p new fd: %d"", this,+                                      fd_node->as);+        }+        new_list->PushFdNode(fd_node);+        // Register read_closure if the socket is readable and read_closure+        // has not been registered with this socket.+        if (ARES_GETSOCK_READABLE(socks_bitmask, i) &&+            !fd_node->readable_registered) {+          GRPC_ARES_WRAPPER_TRACE_LOG(""request:%p notify read on: %d"", this,+                                      fd_node->as);+          fd_node->readable_registered = true;+          fd_node->polled_fd->RegisterForOnReadableLocked(+              [self = Ref(DEBUG_LOCATION, ""Work""),+               fd_node](absl::Status status) mutable {+                // This closure might hold the last RefCount to GrpcAresRequest+                // so its destruction might trigger a chain reaction of+                // destruction: ~GrpcAresRequest ->+                // ~EventEngineClientChannelDNSResolver -> ~PollingResolver ->+                // ~ResolverResultHandler -> grpc_stream_destroy which requires+                // ExecCtx.+                grpc_core::ApplicationCallbackExecCtx callback_exec_ctx;+                grpc_core::ExecCtx exec_ctx;+                self->OnReadable(fd_node, status);+                self.reset();+              });+        }+        // Register write_closure if the socket is writable and write_closure+        // has not been registered with this socket.+        if (ARES_GETSOCK_WRITABLE(socks_bitmask, i) &&+            !fd_node->writable_registered) {+          GRPC_ARES_WRAPPER_TRACE_LOG(""request:%p notify write on: %d"", this,+                                      fd_node->as);+          fd_node->writable_registered = true;+          fd_node->polled_fd->RegisterForOnWriteableLocked(+              [self = Ref(DEBUG_LOCATION, ""Work""),+               fd_node](absl::Status status) mutable {+                grpc_core::ApplicationCallbackExecCtx callback_exec_ctx;+                grpc_core::ExecCtx exec_ctx;+                self->OnWritable(fd_node, status);+                self.reset();+              });+        }+      }+    }+  }+  // Any remaining fds in ev_driver->fds were not returned by ares_getsock()+  // and are therefore no longer in use, so they can be shut down and removed+  // from the list.+  while (!fd_node_list_->IsEmpty()) {+    FdNode* fd_node = fd_node_list_->PopFdNode();+    if (!fd_node->already_shutdown) {+      GRPC_ARES_WRAPPER_TRACE_LOG(""request: %p shutdown fd: %s"", this,+                                  fd_node->polled_fd->GetName());+      fd_node->polled_fd->ShutdownLocked(absl::OkStatus());+      fd_node->already_shutdown = true;+    }+    if (!fd_node->readable_registered && !fd_node->writable_registered) {+      GRPC_ARES_WRAPPER_TRACE_LOG(""request: %p delete fd: %s"", this,+                                  fd_node->polled_fd->GetName());+      delete fd_node;+    } else {+      new_list->PushFdNode(fd_node);+    }+  }+  fd_node_list_.swap(new_list);+}++void GrpcAresRequest::StartTimers() {+  // Initialize overall DNS resolution timeout alarm+  EventEngine::Duration timeout =+      timeout_.count() == 0 ? EventEngine::Duration::max() : timeout_;+  GRPC_ARES_WRAPPER_TRACE_LOG(""request:%p StartTimers timeout in %"" PRId64+                              "" ms"",+                              this, Milliseconds(timeout));++  Ref(DEBUG_LOCATION, ""StartTimers"").release();+  query_timeout_handle_ = event_engine_->RunAfter(timeout, [this] {+    grpc_core::ApplicationCallbackExecCtx callback_exec_ctx;+    grpc_core::ExecCtx exec_ctx;+    OnQueryTimeout();+  });++  // Initialize the backup poll alarm+  EventEngine::Duration next_ares_backup_poll_alarm_duration =+      calculate_next_ares_backup_poll_alarm_duration();+  GRPC_ARES_WRAPPER_TRACE_LOG(+      ""request:%p StartTimers next ares process poll time in %"" PRId64 "" ms"",+      this, Milliseconds(next_ares_backup_poll_alarm_duration));++  Ref(DEBUG_LOCATION, ""StartTimers"").release();+  ares_backup_poll_alarm_handle_ =+      event_engine_->RunAfter(next_ares_backup_poll_alarm_duration, [this] {+        grpc_core::ApplicationCallbackExecCtx callback_exec_ctx;+        grpc_core::ExecCtx exec_ctx;+        OnAresBackupPollAlarm();+      });+}++void GrpcAresRequest::CancelTimers() {+  if (query_timeout_handle_.has_value()) {+    if (event_engine_->Cancel(*query_timeout_handle_)) {+      Unref(DEBUG_LOCATION, ""CancelTimers"");+    }+    query_timeout_handle_.reset();+  }+  if (ares_backup_poll_alarm_handle_.has_value()) {+    if (event_engine_->Cancel(*ares_backup_poll_alarm_handle_)) {+      Unref(DEBUG_LOCATION, ""CancelTimers"");+    }+    ares_backup_poll_alarm_handle_.reset();+  }+}++absl::Status GrpcAresRequest::SetRequestDNSServer(+    absl::string_view dns_server) {+  if (!dns_server.empty()) {+    GRPC_ARES_WRAPPER_TRACE_LOG(""request:%p Using DNS server %s"", this,+                                dns_server.data());+    grpc_resolved_address addr;+    struct ares_addr_port_node dns_server_addr;+    if (grpc_parse_ipv4_hostport(dns_server, &addr, /*log_errors=*/false)) {+      dns_server_addr.family = AF_INET;+      struct sockaddr_in* in = reinterpret_cast<struct sockaddr_in*>(addr.addr);+      memcpy(&dns_server_addr.addr.addr4, &in->sin_addr,+             sizeof(struct in_addr));+      dns_server_addr.tcp_port = grpc_sockaddr_get_port(&addr);+      dns_server_addr.udp_port = grpc_sockaddr_get_port(&addr);+    } else if (grpc_parse_ipv6_hostport(dns_server, &addr,+                                        /*log_errors=*/false)) {+      dns_server_addr.family = AF_INET6;+      struct sockaddr_in6* in6 =+          reinterpret_cast<struct sockaddr_in6*>(addr.addr);+      memcpy(&dns_server_addr.addr.addr6, &in6->sin6_addr,+             sizeof(struct in6_addr));+      dns_server_addr.tcp_port = grpc_sockaddr_get_port(&addr);+      dns_server_addr.udp_port = grpc_sockaddr_get_port(&addr);+    } else {+      return GRPC_ERROR_CREATE(+          absl::StrCat(""cannot parse authority "", dns_server));+    }+    // Prevent an uninitialized variable.+    dns_server_addr.next = nullptr;+    int status = ares_set_servers_ports(channel_, &dns_server_addr);+    if (status != ARES_SUCCESS) {+      return GRPC_ERROR_CREATE(absl::StrCat(+          ""c-ares status is not ARES_SUCCESS: "", ares_strerror(status)));+    }+  }+  return absl::OkStatus();+}++void GrpcAresRequest::OnReadable(FdNode* fd_node, absl::Status status) {+  grpc_core::MutexLock lock(&mu_);+  GPR_ASSERT(fd_node->readable_registered);+  fd_node->readable_registered = false;+  GRPC_ARES_WRAPPER_TRACE_LOG(""OnReadable: fd: %d; request: %p; status: %s"",+                              fd_node->as, this, status.ToString().c_str());+  GRPC_ARES_WRAPPER_STACK_TRACE();+  if (status.ok() && !shutting_down_) {+    do {+      ares_process_fd(channel_, fd_node->as, ARES_SOCKET_BAD);+    } while (fd_node->polled_fd->IsFdStillReadableLocked());+  } else {+    // If error is not absl::OkStatus() or the resolution was cancelled, it+    // means the fd has been shutdown or timed out. The pending lookups made+    // on this ev_driver will be cancelled by the following ares_cancel() and+    // the on_done callbacks will be invoked with a status of ARES_ECANCELLED.+    // The remaining file descriptors in this ev_driver will be cleaned up in+    // the follwing grpc_ares_notify_on_event_locked().+    ares_cancel(channel_);+  }+  Work();+}++void GrpcAresRequest::OnWritable(FdNode* fd_node, absl::Status status) {+  grpc_core::MutexLock lock(&mu_);+  GPR_ASSERT(fd_node->writable_registered);+  fd_node->writable_registered = false;+  GRPC_ARES_WRAPPER_TRACE_LOG(""OnWritable: fd: %d; request:%p; status: %s"",+                              fd_node->as, this, status.ToString().c_str());+  if (status.ok() && !shutting_down_) {+    ares_process_fd(channel_, ARES_SOCKET_BAD, fd_node->as);+  } else {+    // If error is not absl::OkStatus() or the resolution was cancelled, it+    // means the fd has been shutdown or timed out. The pending lookups made+    // on this ev_driver will be cancelled by the following ares_cancel() and+    // the on_done callbacks will be invoked with a status of ARES_ECANCELLED.+    // The remaining file descriptors in this ev_driver will be cleaned up in+    // the follwing grpc_ares_notify_on_event_locked().+    ares_cancel(channel_);+  }+  Work();+}++void GrpcAresRequest::OnQueryTimeout() {+  {+    grpc_core::MutexLock lock(&mu_);+    query_timeout_handle_.reset();+    GRPC_ARES_WRAPPER_TRACE_LOG(""request:%p OnQueryTimeout. shutting_down_=%d"",+                                this, shutting_down_);+    if (!shutting_down_) {+      shutting_down_ = true;+      ShutdownPolledFdsLocked(+          grpc_core::StatusCreate(absl::StatusCode::kDeadlineExceeded,+                                  ""OnQueryTimeout"", DEBUG_LOCATION, {}));+    }+  }+  Unref(DEBUG_LOCATION, ""OnQueryTimeout"");+}++// In case of non-responsive DNS servers, dropped packets, etc., c-ares has+// intelligent timeout and retry logic, which we can take advantage of by+// polling ares_process_fd on time intervals. Overall, the c-ares library is+// meant to be called into and given a chance to proceed name resolution:+//   a) when fd events happen+//   b) when some time has passed without fd events having happened+// For the latter, we use this backup poller. Also see+// https://github.com/grpc/grpc/pull/17688 description for more details.+void GrpcAresRequest::OnAresBackupPollAlarm() {+  {+    grpc_core::MutexLock lock(&mu_);+    ares_backup_poll_alarm_handle_.reset();+    GRPC_ARES_WRAPPER_TRACE_LOG(+        ""request:%p OnAresBackupPollAlarm shutting_down=%d."", this,+        shutting_down_);+    if (!shutting_down_) {+      for (auto it = fd_node_list_->begin(); it != fd_node_list_->end(); it++) {+        if (!(*it)->already_shutdown) {+          GRPC_ARES_WRAPPER_TRACE_LOG(+              ""request:%p OnAresBackupPollAlarm; ares_process_fd. fd=%s"", this,+              (*it)->polled_fd->GetName());+          ares_socket_t as = (*it)->polled_fd->GetWrappedAresSocketLocked();+          ares_process_fd(channel_, as, as);+        }+      }+      if (!shutting_down_) {+        EventEngine::Duration next_ares_backup_poll_alarm_duration =+            calculate_next_ares_backup_poll_alarm_duration();+        Ref(DEBUG_LOCATION, ""OnAresBackupPollAlarm"").release();+        ares_backup_poll_alarm_handle_ = event_engine_->RunAfter(+            next_ares_backup_poll_alarm_duration, [this] {+              grpc_core::ApplicationCallbackExecCtx callback_exec_ctx;+              grpc_core::ExecCtx exec_ctx;+              OnAresBackupPollAlarm();+            });+      }+      Work();+    }+  }+  Unref(DEBUG_LOCATION, ""OnAresBackupPollAlarm"");+}++// TODO(yijiem): Consider report this status or as part of the result when+// calling on_resolve_. This status is received in OnReadable/OnWritable.+void GrpcAresRequest::ShutdownPolledFdsLocked(absl::Status status) {+  for (auto it = fd_node_list_->begin(); it != fd_node_list_->end(); it++) {+    if (!(*it)->already_shutdown) {+      GRPC_ARES_WRAPPER_TRACE_LOG(""request: %p shutdown fd: %s"", this,+                                  (*it)->polled_fd->GetName());+      (*it)->polled_fd->ShutdownLocked(status);+      (*it)->already_shutdown = true;+    }+  }+}++GrpcAresHostnameRequest::GrpcAresHostnameRequest(+    absl::string_view name, absl::string_view default_port,+    EventEngine::Duration timeout,+    std::unique_ptr<GrpcPolledFdFactory> polled_fd_factory,+    EventEngine* event_engine)+    : GrpcAresRequest(name, default_port, timeout, std::move(polled_fd_factory),+                      event_engine) {}++GrpcAresHostnameRequest::~GrpcAresHostnameRequest() {+  GRPC_ARES_WRAPPER_TRACE_LOG(""request:%p destructor"", this);+}++void GrpcAresHostnameRequest::Start(+    absl::AnyInvocable<void(absl::StatusOr<Result>)> on_resolve) {+  auto self = Ref(DEBUG_LOCATION, ""Start"");+  grpc_core::ReleasableMutexLock lock(&mu_);+  GPR_ASSERT(initialized_);+  on_resolve_ = std::move(on_resolve);+  GRPC_ARES_WRAPPER_TRACE_LOG(+      ""request:%p c-ares GrpcAresHostnameRequest::Start name=%s, ""+      ""default_port=%s"",+      this, name_.c_str(), default_port_.c_str());+  // Early out if the target is an ipv4 or ipv6 literal.+  if (ResolveAsIPLiteralLocked()) {+    lock.Release();+    Unref(DEBUG_LOCATION, ""Start"");","Sorry for the refcount mess, the initial refcount is 1 because of InternallyRefCounted inheritance: `InternallyRefCounted<GrpcAresRequest>` <--- `GrpcAresRequest` <--- `GrpcAresHostnameRequest`. This `Unref` decrement the initial refcount.We take another ref across this function (`self`) since `ares_gethostbyname` may call `OnResolve` inline which could trigger shutdown. We take a RefCountedPtr `self` across this function to avoid immediate destruction and to gracefully exit this function. `OnResolve` may get called synchronously (which is this case) and asynchronously through poller callback (which is explained below). In either case, we need to take an additional ref to the initial refcount.I moved things a little bit and comment on all manual `Unref` with `// Decrement the initial refcount.`. Hopefully things get a bit more clear now. PTAL.",
5663878,yijiem,https://api.github.com/repos/grpc/grpc/pulls/32701,1180884658,2023-04-28T23:46:48Z,src/core/lib/event_engine/grpc_ares_wrapper.cc,"@@ -0,0 +1,1013 @@+// Copyright 2023 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++#include <grpc/support/port_platform.h>++#include ""src/core/lib/event_engine/grpc_ares_wrapper.h""++#include ""src/core/lib/iomgr/port.h""++// IWYU pragma: no_include <arpa/inet.h>+// IWYU pragma: no_include <arpa/nameser.h>+// IWYU pragma: no_include <inttypes.h>+// IWYU pragma: no_include <netdb.h>+// IWYU pragma: no_include <netinet/in.h>+// IWYU pragma: no_include <stdlib.h>+// IWYU pragma: no_include <sys/socket.h>+// IWYU pragma: no_include <ratio>++#if GRPC_ARES == 1++#include <string.h>++#include <algorithm>+#include <chrono>+#include <initializer_list>+#include <memory>+#include <type_traits>+#include <utility>++#include <address_sorting/address_sorting.h>++#include ""absl/cleanup/cleanup.h""+#include ""absl/strings/numbers.h""+#include ""absl/strings/str_cat.h""+#include ""absl/strings/str_format.h""+#include ""absl/types/optional.h""++#include <grpc/event_engine/event_engine.h>+#include <grpc/support/alloc.h>+#include <grpc/support/log.h>++#include ""src/core/lib/address_utils/parse_address.h""+#include ""src/core/lib/address_utils/sockaddr_utils.h""+#include ""src/core/lib/event_engine/grpc_polled_fd.h""+#include ""src/core/lib/event_engine/nameser.h""  // IWYU pragma: keep+#include ""src/core/lib/event_engine/tcp_socket_utils.h""+#include ""src/core/lib/event_engine/time_util.h""+#include ""src/core/lib/gpr/string.h""+#include ""src/core/lib/gprpp/debug_location.h""+#include ""src/core/lib/gprpp/examine_stack.h""+#include ""src/core/lib/gprpp/host_port.h""+#include ""src/core/lib/gprpp/ref_counted_ptr.h""+#include ""src/core/lib/gprpp/status_helper.h""+#include ""src/core/lib/iomgr/error.h""+#include ""src/core/lib/iomgr/exec_ctx.h""+#include ""src/core/lib/iomgr/resolved_address.h""+#include ""src/core/lib/iomgr/sockaddr.h""+#ifdef GRPC_POSIX_SOCKET_ARES_EV_DRIVER+#include ""src/core/lib/event_engine/posix_engine/tcp_socket_utils.h""+#elif defined(GRPC_WINDOWS_SOCKET_ARES_EV_DRIVER)+#endif++namespace grpc_event_engine {+namespace experimental {++grpc_core::TraceFlag grpc_trace_ares_wrapper_address_sorting(+    false, ""ares_wrapper_address_sorting"");++grpc_core::TraceFlag grpc_trace_ares_wrapper_stacktrace(+    false, ""ares_wrapper_stacktrace"");++#define GRPC_ARES_WRAPPER_STACK_TRACE()                                \+  do {                                                                 \+    if (GRPC_TRACE_FLAG_ENABLED(grpc_trace_ares_wrapper_stacktrace)) { \+      absl::optional<std::string> stacktrace =                         \+          grpc_core::GetCurrentStackTrace();                           \+      if (stacktrace.has_value()) {                                    \+        gpr_log(GPR_DEBUG, ""%s"", stacktrace->c_str());                 \+      } else {                                                         \+        gpr_log(GPR_DEBUG, ""stacktrace unavailable"");                  \+      }                                                                \+    }                                                                  \+  } while (0)++grpc_core::TraceFlag grpc_trace_ares_wrapper(false,+                                             ""event_engine_ares_wrapper"");++namespace {++EventEngine::Duration calculate_next_ares_backup_poll_alarm_duration() {+  // An alternative here could be to use ares_timeout to try to be more+  // accurate, but that would require using ""struct timeval""'s, which just+  // makes things a bit more complicated. So just poll every second, as+  // suggested by the c-ares code comments.+  return std::chrono::seconds(1);+}++bool IsIpv6LoopbackAvailable() {+#ifdef GRPC_POSIX_SOCKET_ARES_EV_DRIVER+  return PosixSocketWrapper::IsIpv6LoopbackAvailable();+#elif defined(GRPC_WINDOWS_SOCKET_ARES_EV_DRIVER)+  // TODO(yijiem): (debt) move pieces for Windows+  return false;+#else+#error ""Unsupported platform""+#endif+}++struct HostbynameArg {+  GrpcAresHostnameRequest* request;+  const char* qtype;+};++constexpr char g_service_config_attribute_prefix[] = ""grpc_config="";+constexpr size_t g_prefix_len = sizeof(g_service_config_attribute_prefix) - 1;++}  // namespace++void GrpcAresHostnameRequest::OnHostbynameDoneLocked(void* arg, int status,+                                                     int /*timeouts*/,+                                                     struct hostent* hostent) {+  std::unique_ptr<HostbynameArg> harg(static_cast<HostbynameArg*>(arg));+  GrpcAresHostnameRequest* request = harg->request;+  if (status != ARES_SUCCESS) {+    std::string error_msg = absl::StrFormat(+        ""c-ares status is not ARES_SUCCESS qtype=%s name=%s: %s"", harg->qtype,+        request->host_, ares_strerror(status));+    GRPC_ARES_WRAPPER_TRACE_LOG(""request:%p on_hostbyname_done_locked: %s"",+                                request, error_msg.c_str());+    GRPC_ARES_WRAPPER_STACK_TRACE();+    absl::Status error = GRPC_ERROR_CREATE(error_msg);+    request->OnResolve(error);+    return;+  }+  GRPC_ARES_WRAPPER_TRACE_LOG(+      ""request:%p on_hostbyname_done_locked qtype=%s host=%s ARES_SUCCESS"",+      request, harg->qtype, std::string(request->host_).c_str());+  GRPC_ARES_WRAPPER_STACK_TRACE();++  std::vector<EventEngine::ResolvedAddress> resolved_addresses;+  for (size_t i = 0; hostent->h_addr_list[i] != nullptr; i++) {+    switch (hostent->h_addrtype) {+      case AF_INET6: {+        size_t addr_len = sizeof(struct sockaddr_in6);+        struct sockaddr_in6 addr;+        memset(&addr, 0, addr_len);+        memcpy(&addr.sin6_addr, hostent->h_addr_list[i],+               sizeof(struct in6_addr));+        addr.sin6_family = static_cast<unsigned char>(hostent->h_addrtype);+        addr.sin6_port = htons(request->port_);+        resolved_addresses.emplace_back(+            reinterpret_cast<const sockaddr*>(&addr), addr_len);+        char output[INET6_ADDRSTRLEN];+        ares_inet_ntop(AF_INET6, &addr.sin6_addr, output, INET6_ADDRSTRLEN);+        GRPC_ARES_WRAPPER_TRACE_LOG(+            ""request:%p c-ares resolver gets a AF_INET6 result: \n""+            ""  addr: %s\n  port: %d\n  sin6_scope_id: %d\n"",+            request, output, request->port_, addr.sin6_scope_id);+        break;+      }+      case AF_INET: {+        size_t addr_len = sizeof(struct sockaddr_in);+        struct sockaddr_in addr;+        memset(&addr, 0, addr_len);+        memcpy(&addr.sin_addr, hostent->h_addr_list[i], sizeof(struct in_addr));+        addr.sin_family = static_cast<unsigned char>(hostent->h_addrtype);+        addr.sin_port = htons(request->port_);+        resolved_addresses.emplace_back(+            reinterpret_cast<const sockaddr*>(&addr), addr_len);+        char output[INET_ADDRSTRLEN];+        ares_inet_ntop(AF_INET, &addr.sin_addr, output, INET_ADDRSTRLEN);+        GRPC_ARES_WRAPPER_TRACE_LOG(+            ""request:%p c-ares resolver gets a AF_INET result: \n""+            ""  addr: %s\n  port: %d\n"",+            request, output, request->port_);+        break;+      }+    }+  }+  request->OnResolve(std::move(resolved_addresses));+}++void GrpcAresSRVRequest::OnSRVQueryDoneLocked(void* arg, int status,+                                              int /*timeouts*/,+                                              unsigned char* abuf, int alen) {+  GrpcAresSRVRequest* r = static_cast<GrpcAresSRVRequest*>(arg);+  if (status != ARES_SUCCESS) {+    std::string error_msg = absl::StrFormat(+        ""c-ares status is not ARES_SUCCESS qtype=SRV name=%s: %s"",+        r->service_name_, ares_strerror(status));+    GRPC_ARES_WRAPPER_TRACE_LOG(""request:%p on_srv_query_done_locked: %s"", r,+                                error_msg.c_str());+    grpc_error_handle error = GRPC_ERROR_CREATE(error_msg);+    r->OnResolve(error);+    return;+  }+  GRPC_ARES_WRAPPER_TRACE_LOG(+      ""request:%p on_srv_query_done_locked name=%s ARES_SUCCESS"", r,+      r->service_name_.c_str());+  struct ares_srv_reply* reply = nullptr;+  const int parse_status = ares_parse_srv_reply(abuf, alen, &reply);+  GRPC_ARES_WRAPPER_TRACE_LOG(""request:%p ares_parse_srv_reply: %d"", r,+                              parse_status);+  Result result;+  if (parse_status == ARES_SUCCESS) {+    for (struct ares_srv_reply* srv_it = reply; srv_it != nullptr;+         srv_it = srv_it->next) {+      EventEngine::DNSResolver::SRVRecord record;+      record.host = srv_it->host;+      record.port = srv_it->port;+      record.priority = srv_it->priority;+      record.weight = srv_it->weight;+      result.push_back(std::move(record));+    }+  }+  if (reply != nullptr) {+    ares_free_data(reply);+  }+  r->OnResolve(std::move(result));+}++void GrpcAresTXTRequest::OnTXTDoneLocked(void* arg, int status,+                                         int /*timeouts*/, unsigned char* buf,+                                         int len) {+  GrpcAresTXTRequest* r = static_cast<GrpcAresTXTRequest*>(arg);+  struct ares_txt_ext* reply = nullptr;+  int parse_status = ARES_SUCCESS;+  if (status == ARES_SUCCESS) {+    GRPC_ARES_WRAPPER_TRACE_LOG(+        ""request:%p on_txt_done_locked name=%s ARES_SUCCESS"", r,+        r->config_name_.c_str());+    parse_status = ares_parse_txt_reply_ext(buf, len, &reply);+  }+  if (status != ARES_SUCCESS || parse_status != ARES_SUCCESS) {+    grpc_error_handle error;+    std::string error_msg = absl::StrFormat(+        ""c-ares status is not ARES_SUCCESS qtype=TXT name=%s: %s"",+        r->config_name_.c_str(), ares_strerror(status));+    GRPC_ARES_WRAPPER_TRACE_LOG(""request:%p on_txt_done_locked %s"", r,+                                error_msg.c_str());+    error = GRPC_ERROR_CREATE(error_msg);+    r->OnResolve(error);+    return;+  }+  // Find service config in TXT record.+  struct ares_txt_ext* result = nullptr;+  for (result = reply; result != nullptr; result = result->next) {+    if (result->record_start &&+        memcmp(result->txt, g_service_config_attribute_prefix, g_prefix_len) ==+            0) {+      break;+    }+  }+  std::string service_config_json_out;+  // Found a service config record.+  if (result != nullptr) {+    size_t service_config_len = result->length - g_prefix_len;+    service_config_json_out.append(+        reinterpret_cast<char*>(result->txt) + g_prefix_len,+        service_config_len);+    for (result = result->next; result != nullptr && !result->record_start;+         result = result->next) {+      service_config_json_out.append(reinterpret_cast<char*>(result->txt),+                                     result->length);+    }+    GRPC_ARES_WRAPPER_TRACE_LOG(""request:%p found service config: %s"", r,+                                service_config_json_out.c_str());+  }+  // Clean up.+  ares_free_data(reply);+  r->OnResolve(std::move(service_config_json_out));+}++GrpcAresRequest::FdNode::FdNode(ares_socket_t as, GrpcPolledFd* polled_fd)+    : as(as), polled_fd(polled_fd) {}++GrpcAresRequest::FdNode* GrpcAresRequest::FdNodeList::PopFdNode(+    ares_socket_t as) {+  FdNode phony_head;+  phony_head.next = head_;+  FdNode* node = &phony_head;+  while (node->next != nullptr) {+    if (node->next->polled_fd->GetWrappedAresSocketLocked() == as) {+      FdNode* ret = node->next;+      node->next = node->next->next;+      head_ = phony_head.next;+      return ret;+    }+    node = node->next;+  }+  return nullptr;+}++GrpcAresRequest::GrpcAresRequest(+    absl::string_view name, absl::optional<absl::string_view> default_port,+    EventEngine::Duration timeout,+    std::unique_ptr<GrpcPolledFdFactory> polled_fd_factory,+    EventEngine* event_engine)+    : grpc_core::InternallyRefCounted<GrpcAresRequest>(+          GRPC_TRACE_FLAG_ENABLED(grpc_trace_ares_wrapper) ? ""GrpcAresRequest""+                                                           : nullptr),+      name_(name),+      default_port_(default_port.has_value() ? *default_port : """"),+      fd_node_list_(std::make_unique<FdNodeList>()),+      timeout_(timeout),+      event_engine_(event_engine),+      polled_fd_factory_(std::move(polled_fd_factory)) {}++GrpcAresRequest::~GrpcAresRequest() {+  if (initialized_) {+    ares_destroy(channel_);+    GRPC_ARES_WRAPPER_STACK_TRACE();+  }+  GRPC_ARES_WRAPPER_TRACE_LOG(""request:%p destructor"", this);+}++absl::Status GrpcAresRequest::Initialize(absl::string_view dns_server,+                                         bool check_port) {+  grpc_core::MutexLock lock(&mu_);+  GPR_DEBUG_ASSERT(!initialized_);+  absl::string_view port;+  // parse name, splitting it into host and port parts+  grpc_core::SplitHostPort(name_, &host_, &port);+  absl::Status error;+  if (host_.empty()) {+    error =+        grpc_error_set_str(GRPC_ERROR_CREATE(""unparseable host:port""),+                           grpc_core::StatusStrProperty::kTargetAddress, name_);+    return error;+  } else if (check_port && port.empty()) {+    if (default_port_.empty()) {+      error = grpc_error_set_str(GRPC_ERROR_CREATE(""no port in name""),+                                 grpc_core::StatusStrProperty::kTargetAddress,+                                 name_);+      return error;+    }+    port = default_port_;+  }+  if (!port.empty()) {+    if (port == ""http"") {+      port_ = 80;+    } else if (port == ""https"") {+      port_ = 443;+    } else {+      GPR_ASSERT(absl::SimpleAtoi(port, &port_));+    }+  }+  ares_options opts = {};+  opts.flags |= ARES_FLAG_STAYOPEN;+  int status = ares_init_options(&channel_, &opts, ARES_OPT_FLAGS);+  if (status != ARES_SUCCESS) {+    gpr_log(GPR_ERROR, ""ares_init_options failed, status: %d"", status);+    return GRPC_ERROR_CREATE(absl::StrCat(+        ""Failed to init ares channel. c-ares error: "", ares_strerror(status)));+  }+  event_engine_grpc_ares_test_only_inject_config(channel_);+  // If dns_server is specified, use it.+  error = SetRequestDNSServer(dns_server);+  if (!error.ok()) {+    ares_destroy(channel_);+    return error;+  }+  initialized_ = true;+  return absl::OkStatus();+}++bool GrpcAresRequest::Cancel() {+  grpc_core::MutexLock lock(&mu_);+  if (std::exchange(shutting_down_, true)) {+    // Already shutting down, maybe resolved, cancelled or timed-out.+    return false;+  }+  cancelled_ = true;+  CancelTimers();+  ShutdownPolledFdsLocked(grpc_core::StatusCreate(+      absl::StatusCode::kCancelled, ""Cancel"", DEBUG_LOCATION, {}));+  return true;+}++void GrpcAresRequest::Work() {+  auto new_list = std::make_unique<FdNodeList>();+  if (!shutting_down_) {+    ares_socket_t socks[ARES_GETSOCK_MAXNUM];+    int socks_bitmask = ares_getsock(channel_, socks, ARES_GETSOCK_MAXNUM);+    for (size_t i = 0; i < ARES_GETSOCK_MAXNUM; i++) {+      if (ARES_GETSOCK_READABLE(socks_bitmask, i) ||+          ARES_GETSOCK_WRITABLE(socks_bitmask, i)) {+        FdNode* fd_node = fd_node_list_->PopFdNode(socks[i]);+        if (fd_node == nullptr) {+          fd_node = new FdNode(+              socks[i], polled_fd_factory_->NewGrpcPolledFdLocked(socks[i]));+          GRPC_ARES_WRAPPER_TRACE_LOG(""request:%p new fd: %d"", this,+                                      fd_node->as);+        }+        new_list->PushFdNode(fd_node);+        // Register read_closure if the socket is readable and read_closure+        // has not been registered with this socket.+        if (ARES_GETSOCK_READABLE(socks_bitmask, i) &&+            !fd_node->readable_registered) {+          GRPC_ARES_WRAPPER_TRACE_LOG(""request:%p notify read on: %d"", this,+                                      fd_node->as);+          fd_node->readable_registered = true;+          fd_node->polled_fd->RegisterForOnReadableLocked(+              [self = Ref(DEBUG_LOCATION, ""Work""),+               fd_node](absl::Status status) mutable {+                // This closure might hold the last RefCount to GrpcAresRequest+                // so its destruction might trigger a chain reaction of+                // destruction: ~GrpcAresRequest ->+                // ~EventEngineClientChannelDNSResolver -> ~PollingResolver ->+                // ~ResolverResultHandler -> grpc_stream_destroy which requires+                // ExecCtx.+                grpc_core::ApplicationCallbackExecCtx callback_exec_ctx;+                grpc_core::ExecCtx exec_ctx;+                self->OnReadable(fd_node, status);+                self.reset();+              });+        }+        // Register write_closure if the socket is writable and write_closure+        // has not been registered with this socket.+        if (ARES_GETSOCK_WRITABLE(socks_bitmask, i) &&+            !fd_node->writable_registered) {+          GRPC_ARES_WRAPPER_TRACE_LOG(""request:%p notify write on: %d"", this,+                                      fd_node->as);+          fd_node->writable_registered = true;+          fd_node->polled_fd->RegisterForOnWriteableLocked(+              [self = Ref(DEBUG_LOCATION, ""Work""),+               fd_node](absl::Status status) mutable {+                grpc_core::ApplicationCallbackExecCtx callback_exec_ctx;+                grpc_core::ExecCtx exec_ctx;+                self->OnWritable(fd_node, status);+                self.reset();+              });+        }+      }+    }+  }+  // Any remaining fds in ev_driver->fds were not returned by ares_getsock()+  // and are therefore no longer in use, so they can be shut down and removed+  // from the list.+  while (!fd_node_list_->IsEmpty()) {+    FdNode* fd_node = fd_node_list_->PopFdNode();+    if (!fd_node->already_shutdown) {+      GRPC_ARES_WRAPPER_TRACE_LOG(""request: %p shutdown fd: %s"", this,+                                  fd_node->polled_fd->GetName());+      fd_node->polled_fd->ShutdownLocked(absl::OkStatus());+      fd_node->already_shutdown = true;+    }+    if (!fd_node->readable_registered && !fd_node->writable_registered) {+      GRPC_ARES_WRAPPER_TRACE_LOG(""request: %p delete fd: %s"", this,+                                  fd_node->polled_fd->GetName());+      delete fd_node;+    } else {+      new_list->PushFdNode(fd_node);+    }+  }+  fd_node_list_.swap(new_list);+}++void GrpcAresRequest::StartTimers() {+  // Initialize overall DNS resolution timeout alarm+  EventEngine::Duration timeout =+      timeout_.count() == 0 ? EventEngine::Duration::max() : timeout_;+  GRPC_ARES_WRAPPER_TRACE_LOG(""request:%p StartTimers timeout in %"" PRId64+                              "" ms"",+                              this, Milliseconds(timeout));++  Ref(DEBUG_LOCATION, ""StartTimers"").release();+  query_timeout_handle_ = event_engine_->RunAfter(timeout, [this] {+    grpc_core::ApplicationCallbackExecCtx callback_exec_ctx;+    grpc_core::ExecCtx exec_ctx;+    OnQueryTimeout();+  });++  // Initialize the backup poll alarm+  EventEngine::Duration next_ares_backup_poll_alarm_duration =+      calculate_next_ares_backup_poll_alarm_duration();+  GRPC_ARES_WRAPPER_TRACE_LOG(+      ""request:%p StartTimers next ares process poll time in %"" PRId64 "" ms"",+      this, Milliseconds(next_ares_backup_poll_alarm_duration));++  Ref(DEBUG_LOCATION, ""StartTimers"").release();+  ares_backup_poll_alarm_handle_ =+      event_engine_->RunAfter(next_ares_backup_poll_alarm_duration, [this] {+        grpc_core::ApplicationCallbackExecCtx callback_exec_ctx;+        grpc_core::ExecCtx exec_ctx;+        OnAresBackupPollAlarm();+      });+}++void GrpcAresRequest::CancelTimers() {+  if (query_timeout_handle_.has_value()) {+    if (event_engine_->Cancel(*query_timeout_handle_)) {+      Unref(DEBUG_LOCATION, ""CancelTimers"");+    }+    query_timeout_handle_.reset();+  }+  if (ares_backup_poll_alarm_handle_.has_value()) {+    if (event_engine_->Cancel(*ares_backup_poll_alarm_handle_)) {+      Unref(DEBUG_LOCATION, ""CancelTimers"");+    }+    ares_backup_poll_alarm_handle_.reset();+  }+}++absl::Status GrpcAresRequest::SetRequestDNSServer(+    absl::string_view dns_server) {+  if (!dns_server.empty()) {+    GRPC_ARES_WRAPPER_TRACE_LOG(""request:%p Using DNS server %s"", this,+                                dns_server.data());+    grpc_resolved_address addr;+    struct ares_addr_port_node dns_server_addr;+    if (grpc_parse_ipv4_hostport(dns_server, &addr, /*log_errors=*/false)) {+      dns_server_addr.family = AF_INET;+      struct sockaddr_in* in = reinterpret_cast<struct sockaddr_in*>(addr.addr);+      memcpy(&dns_server_addr.addr.addr4, &in->sin_addr,+             sizeof(struct in_addr));+      dns_server_addr.tcp_port = grpc_sockaddr_get_port(&addr);+      dns_server_addr.udp_port = grpc_sockaddr_get_port(&addr);+    } else if (grpc_parse_ipv6_hostport(dns_server, &addr,+                                        /*log_errors=*/false)) {+      dns_server_addr.family = AF_INET6;+      struct sockaddr_in6* in6 =+          reinterpret_cast<struct sockaddr_in6*>(addr.addr);+      memcpy(&dns_server_addr.addr.addr6, &in6->sin6_addr,+             sizeof(struct in6_addr));+      dns_server_addr.tcp_port = grpc_sockaddr_get_port(&addr);+      dns_server_addr.udp_port = grpc_sockaddr_get_port(&addr);+    } else {+      return GRPC_ERROR_CREATE(+          absl::StrCat(""cannot parse authority "", dns_server));+    }+    // Prevent an uninitialized variable.+    dns_server_addr.next = nullptr;+    int status = ares_set_servers_ports(channel_, &dns_server_addr);+    if (status != ARES_SUCCESS) {+      return GRPC_ERROR_CREATE(absl::StrCat(+          ""c-ares status is not ARES_SUCCESS: "", ares_strerror(status)));+    }+  }+  return absl::OkStatus();+}++void GrpcAresRequest::OnReadable(FdNode* fd_node, absl::Status status) {+  grpc_core::MutexLock lock(&mu_);+  GPR_ASSERT(fd_node->readable_registered);+  fd_node->readable_registered = false;+  GRPC_ARES_WRAPPER_TRACE_LOG(""OnReadable: fd: %d; request: %p; status: %s"",+                              fd_node->as, this, status.ToString().c_str());+  GRPC_ARES_WRAPPER_STACK_TRACE();+  if (status.ok() && !shutting_down_) {+    do {+      ares_process_fd(channel_, fd_node->as, ARES_SOCKET_BAD);+    } while (fd_node->polled_fd->IsFdStillReadableLocked());+  } else {+    // If error is not absl::OkStatus() or the resolution was cancelled, it+    // means the fd has been shutdown or timed out. The pending lookups made+    // on this ev_driver will be cancelled by the following ares_cancel() and+    // the on_done callbacks will be invoked with a status of ARES_ECANCELLED.+    // The remaining file descriptors in this ev_driver will be cleaned up in+    // the follwing grpc_ares_notify_on_event_locked().+    ares_cancel(channel_);+  }+  Work();+}++void GrpcAresRequest::OnWritable(FdNode* fd_node, absl::Status status) {+  grpc_core::MutexLock lock(&mu_);+  GPR_ASSERT(fd_node->writable_registered);+  fd_node->writable_registered = false;+  GRPC_ARES_WRAPPER_TRACE_LOG(""OnWritable: fd: %d; request:%p; status: %s"",+                              fd_node->as, this, status.ToString().c_str());+  if (status.ok() && !shutting_down_) {+    ares_process_fd(channel_, ARES_SOCKET_BAD, fd_node->as);+  } else {+    // If error is not absl::OkStatus() or the resolution was cancelled, it+    // means the fd has been shutdown or timed out. The pending lookups made+    // on this ev_driver will be cancelled by the following ares_cancel() and+    // the on_done callbacks will be invoked with a status of ARES_ECANCELLED.+    // The remaining file descriptors in this ev_driver will be cleaned up in+    // the follwing grpc_ares_notify_on_event_locked().+    ares_cancel(channel_);+  }+  Work();+}++void GrpcAresRequest::OnQueryTimeout() {+  {+    grpc_core::MutexLock lock(&mu_);+    query_timeout_handle_.reset();+    GRPC_ARES_WRAPPER_TRACE_LOG(""request:%p OnQueryTimeout. shutting_down_=%d"",+                                this, shutting_down_);+    if (!shutting_down_) {+      shutting_down_ = true;+      ShutdownPolledFdsLocked(+          grpc_core::StatusCreate(absl::StatusCode::kDeadlineExceeded,+                                  ""OnQueryTimeout"", DEBUG_LOCATION, {}));+    }+  }+  Unref(DEBUG_LOCATION, ""OnQueryTimeout"");+}++// In case of non-responsive DNS servers, dropped packets, etc., c-ares has+// intelligent timeout and retry logic, which we can take advantage of by+// polling ares_process_fd on time intervals. Overall, the c-ares library is+// meant to be called into and given a chance to proceed name resolution:+//   a) when fd events happen+//   b) when some time has passed without fd events having happened+// For the latter, we use this backup poller. Also see+// https://github.com/grpc/grpc/pull/17688 description for more details.+void GrpcAresRequest::OnAresBackupPollAlarm() {+  {+    grpc_core::MutexLock lock(&mu_);+    ares_backup_poll_alarm_handle_.reset();+    GRPC_ARES_WRAPPER_TRACE_LOG(+        ""request:%p OnAresBackupPollAlarm shutting_down=%d."", this,+        shutting_down_);+    if (!shutting_down_) {+      for (auto it = fd_node_list_->begin(); it != fd_node_list_->end(); it++) {+        if (!(*it)->already_shutdown) {+          GRPC_ARES_WRAPPER_TRACE_LOG(+              ""request:%p OnAresBackupPollAlarm; ares_process_fd. fd=%s"", this,+              (*it)->polled_fd->GetName());+          ares_socket_t as = (*it)->polled_fd->GetWrappedAresSocketLocked();+          ares_process_fd(channel_, as, as);+        }+      }+      if (!shutting_down_) {+        EventEngine::Duration next_ares_backup_poll_alarm_duration =+            calculate_next_ares_backup_poll_alarm_duration();+        Ref(DEBUG_LOCATION, ""OnAresBackupPollAlarm"").release();+        ares_backup_poll_alarm_handle_ = event_engine_->RunAfter(+            next_ares_backup_poll_alarm_duration, [this] {+              grpc_core::ApplicationCallbackExecCtx callback_exec_ctx;+              grpc_core::ExecCtx exec_ctx;+              OnAresBackupPollAlarm();+            });+      }+      Work();+    }+  }+  Unref(DEBUG_LOCATION, ""OnAresBackupPollAlarm"");+}++// TODO(yijiem): Consider report this status or as part of the result when+// calling on_resolve_. This status is received in OnReadable/OnWritable.+void GrpcAresRequest::ShutdownPolledFdsLocked(absl::Status status) {+  for (auto it = fd_node_list_->begin(); it != fd_node_list_->end(); it++) {+    if (!(*it)->already_shutdown) {+      GRPC_ARES_WRAPPER_TRACE_LOG(""request: %p shutdown fd: %s"", this,+                                  (*it)->polled_fd->GetName());+      (*it)->polled_fd->ShutdownLocked(status);+      (*it)->already_shutdown = true;+    }+  }+}++GrpcAresHostnameRequest::GrpcAresHostnameRequest(+    absl::string_view name, absl::string_view default_port,+    EventEngine::Duration timeout,+    std::unique_ptr<GrpcPolledFdFactory> polled_fd_factory,+    EventEngine* event_engine)+    : GrpcAresRequest(name, default_port, timeout, std::move(polled_fd_factory),+                      event_engine) {}++GrpcAresHostnameRequest::~GrpcAresHostnameRequest() {+  GRPC_ARES_WRAPPER_TRACE_LOG(""request:%p destructor"", this);+}++void GrpcAresHostnameRequest::Start(+    absl::AnyInvocable<void(absl::StatusOr<Result>)> on_resolve) {+  auto self = Ref(DEBUG_LOCATION, ""Start"");+  grpc_core::ReleasableMutexLock lock(&mu_);+  GPR_ASSERT(initialized_);+  on_resolve_ = std::move(on_resolve);+  GRPC_ARES_WRAPPER_TRACE_LOG(+      ""request:%p c-ares GrpcAresHostnameRequest::Start name=%s, ""+      ""default_port=%s"",+      this, name_.c_str(), default_port_.c_str());+  // Early out if the target is an ipv4 or ipv6 literal.+  if (ResolveAsIPLiteralLocked()) {+    lock.Release();+    Unref(DEBUG_LOCATION, ""Start"");+    return;+  }+  // TODO(yijiem): Early out if the target is localhost and we're on Windows.++  // We add up pending_queries_ here since ares_gethostbyname may directly+  // invoke the callback inline if there is any error with the input. The+  // callback will invoke OnResolve with an error status and may destroy the+  // object too early (before the second ares_gethostbyname) if we haven't+  // added up here.+  pending_queries_++;+  if (IsIpv6LoopbackAvailable()) {+    pending_queries_++;+    auto* arg = new HostbynameArg();+    arg->request = this;+    arg->qtype = ""AAAA"";+    ares_gethostbyname(channel_, std::string(host_).c_str(), AF_INET6,","`host_` was a string_view to `name_` which might be ""\<host\>:\<port\>"", so using `host_.data()` would give c-ares the "":\<port\>"" part which would be wrong.Actually, after auditing all the places that I have to do `std::string(host_).c_str()`, I just made `host_` a `std::string` to save unnecessary copies[0] in those places. Thanks for bring this up![0] https://github.com/abseil/abseil-cpp/blob/b971ac5250ea8de900eae9f95e06548d14cd95fe/absl/strings/string_view.h#L364-L369",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32835,1181697247,2023-05-01T16:25:40Z,src/core/ext/filters/client_channel/resolver/xds/xds_resolver.cc,"@@ -731,13 +732,16 @@ XdsResolver::XdsConfigSelector::GetCallConfig(GetCallConfigArgs args) {         method_config->GetMethodParsedConfigVector(grpc_empty_slice());     call_config.service_config = std::move(method_config);   }-  call_config.call_attributes[XdsClusterAttributeTypeName()] = it->first;+  ServiceConfigCallData::Pack(&call_config.call_attributes,","It seems like the main benefit of `StringViewAttribute` is the `FromCallData()` method.  However, as per my comment elsewhere, I think that method is not going to be useful for LB policies, since they will need to use `ClientChannel::LoadBalancedCall::LbCallState::GetCallAttribute()` instead of `ServiceConfigCallData::GetCallAttribute()`.  Given that, I'm not sure it's actually that useful to provide this common class.I don't think there's much overhead in defining a separate class for each string attribute, so it doesn't seem like something we should be working that hard to optimize away.  And having a separate subclass for each attribute provides a clean way to make it clear what the type name is for each attribute, because we can have a `static TypeName Type()` method, as per the example I showed above.  That more cleanly shows what data is associated with that typename, as opposed to the current approach of just exposing a stand-alone function to return a `UniqueTypeName` and then expecting the caller to magically know what type the associated value is.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32835,1181698734,2023-05-01T16:27:54Z,src/core/lib/service_config/service_config_call_data.h,"@@ -40,7 +39,29 @@ namespace grpc_core { /// easily access method and global parameters for the call. class ServiceConfigCallData {  public:-  using CallAttributes = std::map<UniqueTypeName, absl::string_view>;+  class Holder {+   public:+    virtual ~Holder() = default;+  };++  template <typename T>+  class UniversalHolder : public Holder {+   public:+    explicit UniversalHolder(T value) : value_(std::move(value)) {}+    T value() { return value_; }++   private:+    T value_;+  };++  using CallAttributes = std::map<std::uintptr_t, std::unique_ptr<Holder>>;","The difference between `Arena::New()` and `Arena::ManagedNew()` is the the latter calls the object's dtor when the arena is destroyed, whereas the former does not.  The associated memory will be freed either way; the difference is whether the dtor is called first.It's fine to use `Arena::New()` for any object whose dtor does not actually need to be called.  This should be the case for an object whose only data members are things like `absl::string_view` or `UniqueTypeName` that don't themselves contain any data members that need to be cleaned up -- i.e., it should be fine for `StringViewAttribute`.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32954,1181703110,2023-05-01T16:34:05Z,test/cpp/end2end/client_lb_end2end_test.cc,"@@ -2752,6 +2746,73 @@ TEST_F(ClientLbInterceptTrailingMetadataTest, BackendMetricDataMerge) {   EXPECT_EQ(total_num_rpcs, num_trailers_intercepted()); } +struct ClientLbLoadReportTestParams {+  OrcaLoadReport reported;+  OrcaLoadReport received;+};++class ClientLbLoadReportTest : public ClientLbInterceptTrailingMetadataTest,+                               public ::testing::WithParamInterface<+                                   struct ClientLbLoadReportTestParams> {};++TEST_P(ClientLbLoadReportTest, Basic) {+  const int kNumServers = 1;+  const int kNumRpcs = 10;+  StartServers(kNumServers);+  auto response_generator = BuildResolverResponseGenerator();+  auto channel =+      BuildChannel(""intercept_trailing_metadata_lb"", response_generator);+  auto stub = BuildStub(channel);+  response_generator.SetNextResolution(GetServersPorts());+  for (size_t i = 0; i < kNumRpcs; ++i) {+    CheckRpcSendOk(DEBUG_LOCATION, stub, false, &GetParam().reported);+    auto actual = backend_load_report();+    ASSERT_TRUE(actual.has_value());+    CheckLoadReportAsExpected(*actual, GetParam().received);+  }+  // Check LB policy name for the channel.+  EXPECT_EQ(""intercept_trailing_metadata_lb"",+            channel->GetLoadBalancingPolicyName());+  EXPECT_EQ(kNumRpcs, num_trailers_intercepted());+}++INSTANTIATE_TEST_SUITE_P(","Please refactor as I suggested.  I think the parameterized test interface here is much harder to read, and we simply don't need the complexity in this case.",X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32940,1181736191,2023-05-01T17:22:20Z,src/core/lib/channel/call_tracer.h,"@@ -54,6 +54,9 @@ class CallTracerAnnotationInterface {   // TODO(yashykt): If needed, extend this to attach attributes with   // annotations.   virtual void RecordAnnotation(absl::string_view annotation) = 0;+  // Records an annotation for metadata information. `metadata` should be in+  // proto string format.+  virtual void RecordMetadataInformation(absl::string_view metadata_info) = 0;",Why do we need a new method here?  Can we get this info via the existing methods to intercept metadata?,X
16571023,ananda1066,https://api.github.com/repos/grpc/grpc/pulls/32940,1181849913,2023-05-01T20:04:25Z,src/core/lib/channel/call_tracer.h,"@@ -54,6 +54,9 @@ class CallTracerAnnotationInterface {   // TODO(yashykt): If needed, extend this to attach attributes with   // annotations.   virtual void RecordAnnotation(absl::string_view annotation) = 0;+  // Records an annotation for metadata information. `metadata` should be in+  // proto string format.+  virtual void RecordMetadataInformation(absl::string_view metadata_info) = 0;","We want to serialize the string into a proto in google3 for easier parsing to collect the actual metadata sizes, but we can't take a proto dependency here in OSS, so this new function will get overridden in google3 with the serialization.  I haven't added anything besides the API change right now because we don't want to touch metadata code at the moment.@yashykt @ctiller have some context here.",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/32940,1181860010,2023-05-01T20:18:06Z,src/core/lib/channel/call_tracer.h,"@@ -54,6 +54,9 @@ class CallTracerAnnotationInterface {   // TODO(yashykt): If needed, extend this to attach attributes with   // annotations.   virtual void RecordAnnotation(absl::string_view annotation) = 0;+  // Records an annotation for metadata information. `metadata` should be in+  // proto string format.+  virtual void RecordMetadataInformation(absl::string_view metadata_info) = 0;",I just spied those methods (hadn't noticed/remembered them previously) - I think they'll do.@ananda1066 we can probably just keep the existing methods in place:```  virtual void RecordSendInitialMetadata(      grpc_metadata_batch* send_initial_metadata) = 0;  virtual void RecordSendTrailingMetadata(      grpc_metadata_batch* send_trailing_metadata) = 0;```and plumb our own logic internally to recalculate the encoded sizes and publish them out to the sink we were talking about,
4181124,yashykt,https://api.github.com/repos/grpc/grpc/pulls/32940,1181860507,2023-05-01T20:18:48Z,src/core/lib/channel/call_tracer.h,"@@ -54,6 +54,9 @@ class CallTracerAnnotationInterface {   // TODO(yashykt): If needed, extend this to attach attributes with   // annotations.   virtual void RecordAnnotation(absl::string_view annotation) = 0;+  // Records an annotation for metadata information. `metadata` should be in+  // proto string format.+  virtual void RecordMetadataInformation(absl::string_view metadata_info) = 0;","Alternative Suggestion -```enum class AnnotationType {  kProto,  kJson,  kString, // no specific format  kUnknown};virtual void RecordAnnotation(AnnotationType type, absl::string_view annotation) = 0;```",
4181124,yashykt,https://api.github.com/repos/grpc/grpc/pulls/32940,1181861989,2023-05-01T20:21:01Z,src/core/lib/channel/call_tracer.h,"@@ -54,6 +54,9 @@ class CallTracerAnnotationInterface {   // TODO(yashykt): If needed, extend this to attach attributes with   // annotations.   virtual void RecordAnnotation(absl::string_view annotation) = 0;+  // Records an annotation for metadata information. `metadata` should be in+  // proto string format.+  virtual void RecordMetadataInformation(absl::string_view metadata_info) = 0;",I think using the term `Metadata` is confusing?,
16571023,ananda1066,https://api.github.com/repos/grpc/grpc/pulls/32940,1181867792,2023-05-01T20:29:13Z,src/core/lib/channel/call_tracer.h,"@@ -54,6 +54,9 @@ class CallTracerAnnotationInterface {   // TODO(yashykt): If needed, extend this to attach attributes with   // annotations.   virtual void RecordAnnotation(absl::string_view annotation) = 0;+  // Records an annotation for metadata information. `metadata` should be in+  // proto string format.+  virtual void RecordMetadataInformation(absl::string_view metadata_info) = 0;","@ctiller I think we would just want to extend the `RecordAnnotation` in the google3 call tracer for this purpose, so that we can get metadata sizes in OSS as well (the info could be useful). I think the main thing is knowing that it is a metadata annotation and should be serialized into the specific proto type - I guess we could just do a simple StartsWith.@yashykt we could add something, but would that actually be useful in OSS? Otherwise, I think Mark's suggestion is good; we can then abandon this PR and just make the changes in google3 CallTracer's `RecordAnnotation` function. ",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32835,1181892032,2023-05-01T21:04:22Z,test/core/client_channel/lb_policy/xds_override_host_test.cc,"@@ -112,9 +112,11 @@ class XdsOverrideHostTest : public LoadBalancingPolicyTest {     EXPECT_EQ(ApplyUpdate(update, policy_.get()), absl::OkStatus());   } -  CallAttributes MakeOverrideHostAttribute(absl::string_view host) {+  LoadBalancingPolicyTest::CallAttributes MakeOverrideHostAttribute(","I don't think you need the `LoadBalancingPolicyTest::` prefix here, since this class is derived from that class.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32944,1181896513,2023-05-01T21:11:36Z,src/core/lib/security/authorization/rbac_policy.h,"@@ -162,15 +172,22 @@ struct Rbac {   };    Rbac() = default;-  Rbac(Rbac::Action action, std::map<std::string, Policy> policies);+  Rbac(Rbac::Action action, std::map<std::string, Policy> policies,+       absl::string_view name);","Please make `name` the first parameter, since it seems a little more logical that way.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32944,1181897299,2023-05-01T21:12:57Z,src/core/lib/security/authorization/rbac_policy.h,"@@ -162,15 +172,22 @@ struct Rbac {   };    Rbac() = default;-  Rbac(Rbac::Action action, std::map<std::string, Policy> policies);+  Rbac(Rbac::Action action, std::map<std::string, Policy> policies,+       absl::string_view name);    Rbac(Rbac&& other) noexcept;   Rbac& operator=(Rbac&& other) noexcept;    std::string ToString() const;    Action action;+  AuditCondition audit_condition;+   std::map<std::string, Policy> policies;+  std::vector<std::unique_ptr<experimental::AuditLoggerFactory::Config>>+      logger_configs;+  // The authorization policy name or the HTTP RBAC filter name.+  std::string name;","Similarly, let's make `name` the first data member.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32944,1181899193,2023-05-01T21:15:56Z,src/core/lib/security/authorization/rbac_policy.cc,"@@ -29,22 +29,46 @@ namespace grpc_core { // Rbac // -Rbac::Rbac(Rbac::Action action, std::map<std::string, Policy> policies)-    : action(action), policies(std::move(policies)) {}+Rbac::Rbac(Rbac::Action action, std::map<std::string, Policy> policies,+           absl::string_view name)+    : action(action), policies(std::move(policies)), name(name) {}  Rbac::Rbac(Rbac&& other) noexcept-    : action(other.action), policies(std::move(other.policies)) {}+    : action(other.action),+      audit_condition(other.audit_condition),+      policies(std::move(other.policies)),+      logger_configs(std::move(other.logger_configs)),+      name(std::move(other.name)) {}  Rbac& Rbac::operator=(Rbac&& other) noexcept {   action = other.action;+  audit_condition = other.audit_condition;   policies = std::move(other.policies);+  logger_configs = std::move(other.logger_configs);+  name = std::move(other.name);   return *this; }  std::string Rbac::ToString() const {   std::vector<std::string> contents;+  std::string condition_str;+  switch (audit_condition) {+    case Rbac::AuditCondition::kNone:+      condition_str = ""None"";+      break;+    case AuditCondition::kOnDeny:+      condition_str = ""OnDeny"";+      break;+    case AuditCondition::kOnAllow:+      condition_str = ""OnAllow"";+      break;+    case AuditCondition::kOnDenyAndAllow:+      condition_str = ""OnDenyAndAllow"";+      break;+  }   contents.push_back(absl::StrFormat(-      ""Rbac action=%s{"", action == Rbac::Action::kAllow ? ""Allow"" : ""Deny""));+      ""Rbac name=%s action=%s audit_condition=%s{"", name,",I see that you're including the `audit_condition` here.  What about also including the logger configs?,
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32940,1181908319,2023-05-01T21:30:34Z,src/core/lib/channel/call_tracer.h,"@@ -54,6 +54,9 @@ class CallTracerAnnotationInterface {   // TODO(yashykt): If needed, extend this to attach attributes with   // annotations.   virtual void RecordAnnotation(absl::string_view annotation) = 0;+  // Records an annotation for metadata information. `metadata` should be in+  // proto string format.+  virtual void RecordMetadataInformation(absl::string_view metadata_info) = 0;","I don't understand what you mean by ""a string that is in the correct format for serialization"".  The string form *is* the serialized form -- if you have that already, then you've already done the serialization, which is exactly what we don't want to do in OSS.There are two forms of a protobuf:1. The serialized form, which is a string of bytes that contains the proto as it would be stored or sent on the wire.2. The non-serialized form, which is in the form of a C++ object whose code was generated by the protobuf codegen.  This object has methods for setting and getting each of its fields and typically stores each field in a separate data member.When constructing a new proto, you typically first build it in the non-serialized form, and then you use the protobuf API to serialize it into the serialized form, in which it can be stored or put on the wire.  (Conversely, when parsing a serialized proto from storage or from the wire, you deserialize it from the string form into the non-serialized form, which allows you to easily access each field.)  The problem here is that that transformations requires using the protobuf library, and we can't depend on that in OSS.  So if you want that code to be specific to our internal implementation, then you need to do that inside the `CallTracer` implementation.That means you need to pass the non-serialized data into the `CallTracer` instead of a serialized protobuf.  And I think the existing methods here are already doing that.  I don't think we need a new method here.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32944,1181910504,2023-05-01T21:34:06Z,src/core/lib/security/authorization/rbac_translator.cc,"@@ -328,24 +336,157 @@ absl::StatusOr<std::map<std::string, Rbac::Policy>> ParseRulesArray(           policy_or.status().code(),           absl::StrCat(""rules "", i, "": "", policy_or.status().message()));     }-    policies[std::string(name) + ""_"" + policy_name] =-        std::move(policy_or.value());+    policies[policy_name] = std::move(policy_or.value());   }   return std::move(policies); }  absl::StatusOr<Rbac> ParseDenyRulesArray(const Json& json,                                          absl::string_view name) {-  auto policies_or = ParseRulesArray(json, name);+  auto policies_or = ParseRulesArray(json);   if (!policies_or.ok()) return policies_or.status();-  return Rbac(Rbac::Action::kDeny, std::move(policies_or.value()));+  return Rbac(Rbac::Action::kDeny, std::move(policies_or.value()), name); }  absl::StatusOr<Rbac> ParseAllowRulesArray(const Json& json,                                           absl::string_view name) {-  auto policies_or = ParseRulesArray(json, name);+  auto policies_or = ParseRulesArray(json);   if (!policies_or.ok()) return policies_or.status();-  return Rbac(Rbac::Action::kAllow, std::move(policies_or.value()));+  return Rbac(Rbac::Action::kAllow, std::move(policies_or.value()), name);+}++absl::StatusOr<std::unique_ptr<experimental::AuditLoggerFactory::Config>>+ParseAuditLogger(const Json& json, size_t pos) {+  if (json.type() != Json::Type::kObject) {+    return absl::InvalidArgumentError(+        absl::StrFormat(""\""audit_loggers[%d]\"" is not an object."", pos));+  }+  for (const auto& object : json.object()) {+    if (object.first != ""name"" && object.first != ""is_optional"" &&+        object.first != ""config"") {+      return absl::InvalidArgumentError(+          absl::StrFormat(""policy contains unknown field \""%s\"" in ""+                          ""\""audit_logging_options.audit_loggers[%d]\""."",+                          object.first, pos));+    }+  }+  bool is_optional = false;+  auto it = json.object().find(""is_optional"");+  if (it != json.object().end()) {+    switch (it->second.type()) {+      case Json::Type::kTrue:+        is_optional = true;+        break;+      case Json::Type::kFalse:+        break;+      default:+        return absl::InvalidArgumentError(absl::StrFormat(+            ""\""audit_loggers[%d].is_optional\"" is not a boolean."", pos));+    }+  }+  it = json.object().find(""name"");+  if (it == json.object().end()) {+    return absl::InvalidArgumentError(+        absl::StrFormat(""\""audit_loggers[%d].name\"" is required."", pos));+  }+  if (it->second.type() != Json::Type::kString) {+    return absl::InvalidArgumentError(+        absl::StrFormat(""\""audit_loggers[%d].name\"" is not a string."", pos));+  }+  absl::string_view name = it->second.string();+  Json config = Json::Object();+  it = json.object().find(""config"");+  if (it != json.object().end()) {+    if (it->second.type() != Json::Type::kObject) {+      return absl::InvalidArgumentError(absl::StrFormat(+          ""\""audit_loggers[%d].config\"" is not an object."", pos));+    }+    config = it->second;+  }+  if (!AuditLoggerRegistry::FactoryExists(name)) {+    if (is_optional) {+      return nullptr;+    }+    return absl::InvalidArgumentError(+        absl::StrFormat(""\""audit_loggers[%d].name\"" %s is not supported ""+                        ""natively or registered."",+                        pos, name));+  }+  auto result = AuditLoggerRegistry::ParseConfig(name, config);+  if (!result.ok()) {+    return absl::InvalidArgumentError(absl::StrFormat(+        ""\""audit_loggers[%d]\"" %s"", pos, result.status().message()));+  }+  return result;+}++absl::Status ParseAuditLoggingOptions(RbacPolicies& rbacs, const Json& json) {","Please put input parameters before output parameters, as per:https://google.github.io/styleguide/cppguide.html#Inputs_and_OutputsAlso, although the style guide has recently changed to say that output parameters should be references, the gRPC code generally still uses the older style guidance that said to use a pointer instead.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32944,1181917310,2023-05-01T21:45:46Z,src/core/lib/security/authorization/rbac_translator.cc,"@@ -328,24 +336,157 @@ absl::StatusOr<std::map<std::string, Rbac::Policy>> ParseRulesArray(           policy_or.status().code(),           absl::StrCat(""rules "", i, "": "", policy_or.status().message()));     }-    policies[std::string(name) + ""_"" + policy_name] =-        std::move(policy_or.value());+    policies[policy_name] = std::move(policy_or.value());   }   return std::move(policies); }  absl::StatusOr<Rbac> ParseDenyRulesArray(const Json& json,                                          absl::string_view name) {-  auto policies_or = ParseRulesArray(json, name);+  auto policies_or = ParseRulesArray(json);   if (!policies_or.ok()) return policies_or.status();-  return Rbac(Rbac::Action::kDeny, std::move(policies_or.value()));+  return Rbac(Rbac::Action::kDeny, std::move(policies_or.value()), name); }  absl::StatusOr<Rbac> ParseAllowRulesArray(const Json& json,                                           absl::string_view name) {-  auto policies_or = ParseRulesArray(json, name);+  auto policies_or = ParseRulesArray(json);   if (!policies_or.ok()) return policies_or.status();-  return Rbac(Rbac::Action::kAllow, std::move(policies_or.value()));+  return Rbac(Rbac::Action::kAllow, std::move(policies_or.value()), name);+}++absl::StatusOr<std::unique_ptr<experimental::AuditLoggerFactory::Config>>+ParseAuditLogger(const Json& json, size_t pos) {+  if (json.type() != Json::Type::kObject) {+    return absl::InvalidArgumentError(+        absl::StrFormat(""\""audit_loggers[%d]\"" is not an object."", pos));+  }+  for (const auto& object : json.object()) {+    if (object.first != ""name"" && object.first != ""is_optional"" &&+        object.first != ""config"") {+      return absl::InvalidArgumentError(+          absl::StrFormat(""policy contains unknown field \""%s\"" in ""+                          ""\""audit_logging_options.audit_loggers[%d]\""."",+                          object.first, pos));+    }+  }+  bool is_optional = false;+  auto it = json.object().find(""is_optional"");","General note, not something that blocks this PR:At some point, we should come back and do a pass through all of this JSON-validation code and convert it to use the newer JSON validation library:https://github.com/grpc/grpc/blob/master/src/core/lib/json/json_object_loader.hThe new library provides a much cleaner way of writing this kind of code, provides much better error messages when the input is invalid, and reduces some significant code bloat.",
16571023,ananda1066,https://api.github.com/repos/grpc/grpc/pulls/32940,1181920620,2023-05-01T21:51:50Z,src/core/lib/channel/call_tracer.h,"@@ -54,6 +54,9 @@ class CallTracerAnnotationInterface {   // TODO(yashykt): If needed, extend this to attach attributes with   // annotations.   virtual void RecordAnnotation(absl::string_view annotation) = 0;+  // Records an annotation for metadata information. `metadata` should be in+  // proto string format.+  virtual void RecordMetadataInformation(absl::string_view metadata_info) = 0;","I see, I'm using the term serialized incorrectly; it's a proto-formatted string I guess. I agree we don't need a new function.This is how I've currently implemented it: The caller passes in a raw string to `RecordAnnotation`. The OSS call tracer simply records the raw string. The google3 call tracer implementation does something like `absl::Substitute(R""pb($0)pb"", annotation)` and then `proto2::TextFormat::ParseFromString(annotation, &metadata_proto)` to create the proto.There may be a better way to do this, I'm not very familiar with proto parsing.",
7221003,rockspore,https://api.github.com/repos/grpc/grpc/pulls/32976,1181923091,2023-05-01T21:56:11Z,src/core/ext/xds/xds_http_rbac_filter.cc,"@@ -546,12 +546,15 @@ ChannelArgs XdsHttpRbacFilter::ModifyChannelArgs( absl::StatusOr<XdsHttpFilterImpl::ServiceConfigJsonEntry> XdsHttpRbacFilter::GenerateServiceConfig(     const FilterConfig& hcm_filter_config,-    const FilterConfig* filter_config_override) const {+    const FilterConfig* filter_config_override,+    absl::string_view filter_name) const {   Json policy_json = filter_config_override != nullptr                          ? filter_config_override->config                          : hcm_filter_config.config;-  // The policy JSON may be empty, that's allowed.-  return ServiceConfigJsonEntry{""rbacPolicy"", JsonDump(policy_json)};+  auto json_object = policy_json.object();+  json_object.emplace(""filter_name"", std::string(filter_name));",The existing pattern doesn't require us to do this here. I also don't think it's strictly necessary since there isn't a whole lot repetitions.,
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32940,1181926142,2023-05-01T22:01:53Z,src/core/lib/channel/call_tracer.h,"@@ -54,6 +54,9 @@ class CallTracerAnnotationInterface {   // TODO(yashykt): If needed, extend this to attach attributes with   // annotations.   virtual void RecordAnnotation(absl::string_view annotation) = 0;+  // Records an annotation for metadata information. `metadata` should be in+  // proto string format.+  virtual void RecordMetadataInformation(absl::string_view metadata_info) = 0;",Looks like you're talking about the textproto form.  That form is not stable and not appropriate for use in an API; it's intended only to be a human-readable form for debugging purposes only.  And parsing it on a per-RPC basis seems likely to be inefficient from a performance perspective.I don't think this is the approach we want.  I think we just want to construct the proto inside of the `CallTracer` implementation using data passed into the existing methods.I don't think we need this PR.  The existing `CallTracer` methods should already provide what we need here.,
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32970,1181929071,2023-05-01T22:07:55Z,src/core/ext/xds/xds_audit_logger_registry.cc,"@@ -29,17 +32,22 @@ #include ""src/core/ext/xds/xds_common_types.h"" #include ""src/core/lib/gprpp/validation_errors.h"" #include ""src/core/lib/json/json.h""+#include ""src/core/lib/security/authorization/audit_logging.h""  namespace grpc_core {  namespace { +using experimental::AuditLoggerRegistry;+ class StdoutLoggerConfigFactory : public XdsAuditLoggerRegistry::ConfigFactory {  public:   Json::Object ConvertXdsAuditLoggerConfig(       const XdsResourceType::DecodeContext& /*context*/,       absl::string_view /*configuration*/,       ValidationErrors* /*errors*/) override {+    // Stdout logger has no configuration right now. So we don't need to invoke","While I agree that it's not strictly required, I think it would be a good idea to invoke the gRPC registry, just to be safe.  That way, if we ever did something crazy like add a required parameter to the config, we'd detect the error here, which is what we want.I suggest doing this parsing on line 88 rather than doing it here, so that we don't have to do it in each individual audit logger factory implementation.",
5663878,yijiem,https://api.github.com/repos/grpc/grpc/pulls/32701,1181938664,2023-05-01T22:28:36Z,src/core/lib/event_engine/grpc_ares_wrapper.cc,"@@ -0,0 +1,1013 @@+// Copyright 2023 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++#include <grpc/support/port_platform.h>++#include ""src/core/lib/event_engine/grpc_ares_wrapper.h""++#include ""src/core/lib/iomgr/port.h""++// IWYU pragma: no_include <arpa/inet.h>+// IWYU pragma: no_include <arpa/nameser.h>+// IWYU pragma: no_include <inttypes.h>+// IWYU pragma: no_include <netdb.h>+// IWYU pragma: no_include <netinet/in.h>+// IWYU pragma: no_include <stdlib.h>+// IWYU pragma: no_include <sys/socket.h>+// IWYU pragma: no_include <ratio>++#if GRPC_ARES == 1++#include <string.h>++#include <algorithm>+#include <chrono>+#include <initializer_list>+#include <memory>+#include <type_traits>+#include <utility>++#include <address_sorting/address_sorting.h>++#include ""absl/cleanup/cleanup.h""+#include ""absl/strings/numbers.h""+#include ""absl/strings/str_cat.h""+#include ""absl/strings/str_format.h""+#include ""absl/types/optional.h""++#include <grpc/event_engine/event_engine.h>+#include <grpc/support/alloc.h>+#include <grpc/support/log.h>++#include ""src/core/lib/address_utils/parse_address.h""+#include ""src/core/lib/address_utils/sockaddr_utils.h""+#include ""src/core/lib/event_engine/grpc_polled_fd.h""+#include ""src/core/lib/event_engine/nameser.h""  // IWYU pragma: keep+#include ""src/core/lib/event_engine/tcp_socket_utils.h""+#include ""src/core/lib/event_engine/time_util.h""+#include ""src/core/lib/gpr/string.h""+#include ""src/core/lib/gprpp/debug_location.h""+#include ""src/core/lib/gprpp/examine_stack.h""+#include ""src/core/lib/gprpp/host_port.h""+#include ""src/core/lib/gprpp/ref_counted_ptr.h""+#include ""src/core/lib/gprpp/status_helper.h""+#include ""src/core/lib/iomgr/error.h""+#include ""src/core/lib/iomgr/exec_ctx.h""+#include ""src/core/lib/iomgr/resolved_address.h""+#include ""src/core/lib/iomgr/sockaddr.h""+#ifdef GRPC_POSIX_SOCKET_ARES_EV_DRIVER+#include ""src/core/lib/event_engine/posix_engine/tcp_socket_utils.h""+#elif defined(GRPC_WINDOWS_SOCKET_ARES_EV_DRIVER)+#endif++namespace grpc_event_engine {+namespace experimental {++grpc_core::TraceFlag grpc_trace_ares_wrapper_address_sorting(+    false, ""ares_wrapper_address_sorting"");++grpc_core::TraceFlag grpc_trace_ares_wrapper_stacktrace(+    false, ""ares_wrapper_stacktrace"");++#define GRPC_ARES_WRAPPER_STACK_TRACE()                                \+  do {                                                                 \+    if (GRPC_TRACE_FLAG_ENABLED(grpc_trace_ares_wrapper_stacktrace)) { \+      absl::optional<std::string> stacktrace =                         \+          grpc_core::GetCurrentStackTrace();                           \+      if (stacktrace.has_value()) {                                    \+        gpr_log(GPR_DEBUG, ""%s"", stacktrace->c_str());                 \+      } else {                                                         \+        gpr_log(GPR_DEBUG, ""stacktrace unavailable"");                  \+      }                                                                \+    }                                                                  \+  } while (0)++grpc_core::TraceFlag grpc_trace_ares_wrapper(false,+                                             ""event_engine_ares_wrapper"");++namespace {++EventEngine::Duration calculate_next_ares_backup_poll_alarm_duration() {+  // An alternative here could be to use ares_timeout to try to be more+  // accurate, but that would require using ""struct timeval""'s, which just+  // makes things a bit more complicated. So just poll every second, as+  // suggested by the c-ares code comments.+  return std::chrono::seconds(1);+}++bool IsIpv6LoopbackAvailable() {+#ifdef GRPC_POSIX_SOCKET_ARES_EV_DRIVER+  return PosixSocketWrapper::IsIpv6LoopbackAvailable();+#elif defined(GRPC_WINDOWS_SOCKET_ARES_EV_DRIVER)+  // TODO(yijiem): (debt) move pieces for Windows+  return false;+#else+#error ""Unsupported platform""+#endif+}++struct HostbynameArg {+  GrpcAresHostnameRequest* request;+  const char* qtype;+};++constexpr char g_service_config_attribute_prefix[] = ""grpc_config="";+constexpr size_t g_prefix_len = sizeof(g_service_config_attribute_prefix) - 1;++}  // namespace++void GrpcAresHostnameRequest::OnHostbynameDoneLocked(void* arg, int status,+                                                     int /*timeouts*/,+                                                     struct hostent* hostent) {+  std::unique_ptr<HostbynameArg> harg(static_cast<HostbynameArg*>(arg));+  GrpcAresHostnameRequest* request = harg->request;+  if (status != ARES_SUCCESS) {+    std::string error_msg = absl::StrFormat(+        ""c-ares status is not ARES_SUCCESS qtype=%s name=%s: %s"", harg->qtype,+        request->host_, ares_strerror(status));+    GRPC_ARES_WRAPPER_TRACE_LOG(""request:%p on_hostbyname_done_locked: %s"",+                                request, error_msg.c_str());+    GRPC_ARES_WRAPPER_STACK_TRACE();+    absl::Status error = GRPC_ERROR_CREATE(error_msg);+    request->OnResolve(error);+    return;+  }+  GRPC_ARES_WRAPPER_TRACE_LOG(+      ""request:%p on_hostbyname_done_locked qtype=%s host=%s ARES_SUCCESS"",+      request, harg->qtype, std::string(request->host_).c_str());+  GRPC_ARES_WRAPPER_STACK_TRACE();++  std::vector<EventEngine::ResolvedAddress> resolved_addresses;+  for (size_t i = 0; hostent->h_addr_list[i] != nullptr; i++) {+    switch (hostent->h_addrtype) {+      case AF_INET6: {+        size_t addr_len = sizeof(struct sockaddr_in6);+        struct sockaddr_in6 addr;+        memset(&addr, 0, addr_len);+        memcpy(&addr.sin6_addr, hostent->h_addr_list[i],+               sizeof(struct in6_addr));+        addr.sin6_family = static_cast<unsigned char>(hostent->h_addrtype);+        addr.sin6_port = htons(request->port_);+        resolved_addresses.emplace_back(+            reinterpret_cast<const sockaddr*>(&addr), addr_len);+        char output[INET6_ADDRSTRLEN];+        ares_inet_ntop(AF_INET6, &addr.sin6_addr, output, INET6_ADDRSTRLEN);+        GRPC_ARES_WRAPPER_TRACE_LOG(+            ""request:%p c-ares resolver gets a AF_INET6 result: \n""+            ""  addr: %s\n  port: %d\n  sin6_scope_id: %d\n"",+            request, output, request->port_, addr.sin6_scope_id);+        break;+      }+      case AF_INET: {+        size_t addr_len = sizeof(struct sockaddr_in);+        struct sockaddr_in addr;+        memset(&addr, 0, addr_len);+        memcpy(&addr.sin_addr, hostent->h_addr_list[i], sizeof(struct in_addr));+        addr.sin_family = static_cast<unsigned char>(hostent->h_addrtype);+        addr.sin_port = htons(request->port_);+        resolved_addresses.emplace_back(+            reinterpret_cast<const sockaddr*>(&addr), addr_len);+        char output[INET_ADDRSTRLEN];+        ares_inet_ntop(AF_INET, &addr.sin_addr, output, INET_ADDRSTRLEN);+        GRPC_ARES_WRAPPER_TRACE_LOG(+            ""request:%p c-ares resolver gets a AF_INET result: \n""+            ""  addr: %s\n  port: %d\n"",+            request, output, request->port_);+        break;+      }+    }+  }+  request->OnResolve(std::move(resolved_addresses));+}++void GrpcAresSRVRequest::OnSRVQueryDoneLocked(void* arg, int status,+                                              int /*timeouts*/,+                                              unsigned char* abuf, int alen) {+  GrpcAresSRVRequest* r = static_cast<GrpcAresSRVRequest*>(arg);+  if (status != ARES_SUCCESS) {+    std::string error_msg = absl::StrFormat(+        ""c-ares status is not ARES_SUCCESS qtype=SRV name=%s: %s"",+        r->service_name_, ares_strerror(status));+    GRPC_ARES_WRAPPER_TRACE_LOG(""request:%p on_srv_query_done_locked: %s"", r,+                                error_msg.c_str());+    grpc_error_handle error = GRPC_ERROR_CREATE(error_msg);+    r->OnResolve(error);+    return;+  }+  GRPC_ARES_WRAPPER_TRACE_LOG(+      ""request:%p on_srv_query_done_locked name=%s ARES_SUCCESS"", r,+      r->service_name_.c_str());+  struct ares_srv_reply* reply = nullptr;+  const int parse_status = ares_parse_srv_reply(abuf, alen, &reply);+  GRPC_ARES_WRAPPER_TRACE_LOG(""request:%p ares_parse_srv_reply: %d"", r,+                              parse_status);+  Result result;+  if (parse_status == ARES_SUCCESS) {+    for (struct ares_srv_reply* srv_it = reply; srv_it != nullptr;+         srv_it = srv_it->next) {+      EventEngine::DNSResolver::SRVRecord record;+      record.host = srv_it->host;+      record.port = srv_it->port;+      record.priority = srv_it->priority;+      record.weight = srv_it->weight;+      result.push_back(std::move(record));+    }+  }+  if (reply != nullptr) {+    ares_free_data(reply);+  }+  r->OnResolve(std::move(result));+}++void GrpcAresTXTRequest::OnTXTDoneLocked(void* arg, int status,+                                         int /*timeouts*/, unsigned char* buf,+                                         int len) {+  GrpcAresTXTRequest* r = static_cast<GrpcAresTXTRequest*>(arg);+  struct ares_txt_ext* reply = nullptr;+  int parse_status = ARES_SUCCESS;+  if (status == ARES_SUCCESS) {+    GRPC_ARES_WRAPPER_TRACE_LOG(+        ""request:%p on_txt_done_locked name=%s ARES_SUCCESS"", r,+        r->config_name_.c_str());+    parse_status = ares_parse_txt_reply_ext(buf, len, &reply);+  }+  if (status != ARES_SUCCESS || parse_status != ARES_SUCCESS) {+    grpc_error_handle error;+    std::string error_msg = absl::StrFormat(+        ""c-ares status is not ARES_SUCCESS qtype=TXT name=%s: %s"",+        r->config_name_.c_str(), ares_strerror(status));+    GRPC_ARES_WRAPPER_TRACE_LOG(""request:%p on_txt_done_locked %s"", r,+                                error_msg.c_str());+    error = GRPC_ERROR_CREATE(error_msg);+    r->OnResolve(error);+    return;+  }+  // Find service config in TXT record.+  struct ares_txt_ext* result = nullptr;+  for (result = reply; result != nullptr; result = result->next) {+    if (result->record_start &&+        memcmp(result->txt, g_service_config_attribute_prefix, g_prefix_len) ==+            0) {+      break;+    }+  }+  std::string service_config_json_out;+  // Found a service config record.+  if (result != nullptr) {+    size_t service_config_len = result->length - g_prefix_len;+    service_config_json_out.append(+        reinterpret_cast<char*>(result->txt) + g_prefix_len,+        service_config_len);+    for (result = result->next; result != nullptr && !result->record_start;+         result = result->next) {+      service_config_json_out.append(reinterpret_cast<char*>(result->txt),+                                     result->length);+    }+    GRPC_ARES_WRAPPER_TRACE_LOG(""request:%p found service config: %s"", r,+                                service_config_json_out.c_str());+  }+  // Clean up.+  ares_free_data(reply);+  r->OnResolve(std::move(service_config_json_out));+}++GrpcAresRequest::FdNode::FdNode(ares_socket_t as, GrpcPolledFd* polled_fd)+    : as(as), polled_fd(polled_fd) {}++GrpcAresRequest::FdNode* GrpcAresRequest::FdNodeList::PopFdNode(+    ares_socket_t as) {+  FdNode phony_head;+  phony_head.next = head_;+  FdNode* node = &phony_head;+  while (node->next != nullptr) {+    if (node->next->polled_fd->GetWrappedAresSocketLocked() == as) {+      FdNode* ret = node->next;+      node->next = node->next->next;+      head_ = phony_head.next;+      return ret;+    }+    node = node->next;+  }+  return nullptr;+}++GrpcAresRequest::GrpcAresRequest(+    absl::string_view name, absl::optional<absl::string_view> default_port,+    EventEngine::Duration timeout,+    std::unique_ptr<GrpcPolledFdFactory> polled_fd_factory,+    EventEngine* event_engine)+    : grpc_core::InternallyRefCounted<GrpcAresRequest>(+          GRPC_TRACE_FLAG_ENABLED(grpc_trace_ares_wrapper) ? ""GrpcAresRequest""+                                                           : nullptr),+      name_(name),+      default_port_(default_port.has_value() ? *default_port : """"),+      fd_node_list_(std::make_unique<FdNodeList>()),+      timeout_(timeout),+      event_engine_(event_engine),+      polled_fd_factory_(std::move(polled_fd_factory)) {}++GrpcAresRequest::~GrpcAresRequest() {+  if (initialized_) {+    ares_destroy(channel_);+    GRPC_ARES_WRAPPER_STACK_TRACE();+  }+  GRPC_ARES_WRAPPER_TRACE_LOG(""request:%p destructor"", this);+}++absl::Status GrpcAresRequest::Initialize(absl::string_view dns_server,+                                         bool check_port) {+  grpc_core::MutexLock lock(&mu_);+  GPR_DEBUG_ASSERT(!initialized_);+  absl::string_view port;+  // parse name, splitting it into host and port parts+  grpc_core::SplitHostPort(name_, &host_, &port);+  absl::Status error;+  if (host_.empty()) {+    error =+        grpc_error_set_str(GRPC_ERROR_CREATE(""unparseable host:port""),+                           grpc_core::StatusStrProperty::kTargetAddress, name_);+    return error;+  } else if (check_port && port.empty()) {+    if (default_port_.empty()) {+      error = grpc_error_set_str(GRPC_ERROR_CREATE(""no port in name""),+                                 grpc_core::StatusStrProperty::kTargetAddress,+                                 name_);+      return error;+    }+    port = default_port_;+  }+  if (!port.empty()) {+    if (port == ""http"") {+      port_ = 80;+    } else if (port == ""https"") {+      port_ = 443;+    } else {+      GPR_ASSERT(absl::SimpleAtoi(port, &port_));+    }+  }+  ares_options opts = {};+  opts.flags |= ARES_FLAG_STAYOPEN;+  int status = ares_init_options(&channel_, &opts, ARES_OPT_FLAGS);+  if (status != ARES_SUCCESS) {+    gpr_log(GPR_ERROR, ""ares_init_options failed, status: %d"", status);+    return GRPC_ERROR_CREATE(absl::StrCat(+        ""Failed to init ares channel. c-ares error: "", ares_strerror(status)));+  }+  event_engine_grpc_ares_test_only_inject_config(channel_);+  // If dns_server is specified, use it.+  error = SetRequestDNSServer(dns_server);+  if (!error.ok()) {+    ares_destroy(channel_);+    return error;+  }+  initialized_ = true;+  return absl::OkStatus();+}++bool GrpcAresRequest::Cancel() {+  grpc_core::MutexLock lock(&mu_);+  if (std::exchange(shutting_down_, true)) {+    // Already shutting down, maybe resolved, cancelled or timed-out.+    return false;+  }+  cancelled_ = true;+  CancelTimers();+  ShutdownPolledFdsLocked(grpc_core::StatusCreate(+      absl::StatusCode::kCancelled, ""Cancel"", DEBUG_LOCATION, {}));+  return true;+}++void GrpcAresRequest::Work() {+  auto new_list = std::make_unique<FdNodeList>();+  if (!shutting_down_) {+    ares_socket_t socks[ARES_GETSOCK_MAXNUM];+    int socks_bitmask = ares_getsock(channel_, socks, ARES_GETSOCK_MAXNUM);+    for (size_t i = 0; i < ARES_GETSOCK_MAXNUM; i++) {+      if (ARES_GETSOCK_READABLE(socks_bitmask, i) ||+          ARES_GETSOCK_WRITABLE(socks_bitmask, i)) {+        FdNode* fd_node = fd_node_list_->PopFdNode(socks[i]);+        if (fd_node == nullptr) {+          fd_node = new FdNode(+              socks[i], polled_fd_factory_->NewGrpcPolledFdLocked(socks[i]));+          GRPC_ARES_WRAPPER_TRACE_LOG(""request:%p new fd: %d"", this,+                                      fd_node->as);+        }+        new_list->PushFdNode(fd_node);+        // Register read_closure if the socket is readable and read_closure+        // has not been registered with this socket.+        if (ARES_GETSOCK_READABLE(socks_bitmask, i) &&+            !fd_node->readable_registered) {+          GRPC_ARES_WRAPPER_TRACE_LOG(""request:%p notify read on: %d"", this,+                                      fd_node->as);+          fd_node->readable_registered = true;+          fd_node->polled_fd->RegisterForOnReadableLocked(+              [self = Ref(DEBUG_LOCATION, ""Work""),+               fd_node](absl::Status status) mutable {+                // This closure might hold the last RefCount to GrpcAresRequest+                // so its destruction might trigger a chain reaction of+                // destruction: ~GrpcAresRequest ->+                // ~EventEngineClientChannelDNSResolver -> ~PollingResolver ->+                // ~ResolverResultHandler -> grpc_stream_destroy which requires+                // ExecCtx.+                grpc_core::ApplicationCallbackExecCtx callback_exec_ctx;+                grpc_core::ExecCtx exec_ctx;+                self->OnReadable(fd_node, status);+                self.reset();+              });+        }+        // Register write_closure if the socket is writable and write_closure+        // has not been registered with this socket.+        if (ARES_GETSOCK_WRITABLE(socks_bitmask, i) &&+            !fd_node->writable_registered) {+          GRPC_ARES_WRAPPER_TRACE_LOG(""request:%p notify write on: %d"", this,+                                      fd_node->as);+          fd_node->writable_registered = true;+          fd_node->polled_fd->RegisterForOnWriteableLocked(+              [self = Ref(DEBUG_LOCATION, ""Work""),+               fd_node](absl::Status status) mutable {+                grpc_core::ApplicationCallbackExecCtx callback_exec_ctx;+                grpc_core::ExecCtx exec_ctx;+                self->OnWritable(fd_node, status);+                self.reset();+              });+        }+      }+    }+  }+  // Any remaining fds in ev_driver->fds were not returned by ares_getsock()+  // and are therefore no longer in use, so they can be shut down and removed+  // from the list.+  while (!fd_node_list_->IsEmpty()) {+    FdNode* fd_node = fd_node_list_->PopFdNode();+    if (!fd_node->already_shutdown) {+      GRPC_ARES_WRAPPER_TRACE_LOG(""request: %p shutdown fd: %s"", this,+                                  fd_node->polled_fd->GetName());+      fd_node->polled_fd->ShutdownLocked(absl::OkStatus());+      fd_node->already_shutdown = true;+    }+    if (!fd_node->readable_registered && !fd_node->writable_registered) {+      GRPC_ARES_WRAPPER_TRACE_LOG(""request: %p delete fd: %s"", this,+                                  fd_node->polled_fd->GetName());+      delete fd_node;+    } else {+      new_list->PushFdNode(fd_node);+    }+  }+  fd_node_list_.swap(new_list);+}++void GrpcAresRequest::StartTimers() {+  // Initialize overall DNS resolution timeout alarm+  EventEngine::Duration timeout =+      timeout_.count() == 0 ? EventEngine::Duration::max() : timeout_;+  GRPC_ARES_WRAPPER_TRACE_LOG(""request:%p StartTimers timeout in %"" PRId64+                              "" ms"",+                              this, Milliseconds(timeout));++  Ref(DEBUG_LOCATION, ""StartTimers"").release();+  query_timeout_handle_ = event_engine_->RunAfter(timeout, [this] {+    grpc_core::ApplicationCallbackExecCtx callback_exec_ctx;+    grpc_core::ExecCtx exec_ctx;+    OnQueryTimeout();+  });++  // Initialize the backup poll alarm+  EventEngine::Duration next_ares_backup_poll_alarm_duration =+      calculate_next_ares_backup_poll_alarm_duration();+  GRPC_ARES_WRAPPER_TRACE_LOG(+      ""request:%p StartTimers next ares process poll time in %"" PRId64 "" ms"",+      this, Milliseconds(next_ares_backup_poll_alarm_duration));++  Ref(DEBUG_LOCATION, ""StartTimers"").release();+  ares_backup_poll_alarm_handle_ =+      event_engine_->RunAfter(next_ares_backup_poll_alarm_duration, [this] {+        grpc_core::ApplicationCallbackExecCtx callback_exec_ctx;+        grpc_core::ExecCtx exec_ctx;+        OnAresBackupPollAlarm();+      });+}++void GrpcAresRequest::CancelTimers() {+  if (query_timeout_handle_.has_value()) {+    if (event_engine_->Cancel(*query_timeout_handle_)) {+      Unref(DEBUG_LOCATION, ""CancelTimers"");+    }+    query_timeout_handle_.reset();+  }+  if (ares_backup_poll_alarm_handle_.has_value()) {+    if (event_engine_->Cancel(*ares_backup_poll_alarm_handle_)) {+      Unref(DEBUG_LOCATION, ""CancelTimers"");+    }+    ares_backup_poll_alarm_handle_.reset();+  }+}++absl::Status GrpcAresRequest::SetRequestDNSServer(+    absl::string_view dns_server) {+  if (!dns_server.empty()) {+    GRPC_ARES_WRAPPER_TRACE_LOG(""request:%p Using DNS server %s"", this,+                                dns_server.data());+    grpc_resolved_address addr;+    struct ares_addr_port_node dns_server_addr;+    if (grpc_parse_ipv4_hostport(dns_server, &addr, /*log_errors=*/false)) {+      dns_server_addr.family = AF_INET;+      struct sockaddr_in* in = reinterpret_cast<struct sockaddr_in*>(addr.addr);+      memcpy(&dns_server_addr.addr.addr4, &in->sin_addr,+             sizeof(struct in_addr));+      dns_server_addr.tcp_port = grpc_sockaddr_get_port(&addr);+      dns_server_addr.udp_port = grpc_sockaddr_get_port(&addr);+    } else if (grpc_parse_ipv6_hostport(dns_server, &addr,+                                        /*log_errors=*/false)) {+      dns_server_addr.family = AF_INET6;+      struct sockaddr_in6* in6 =+          reinterpret_cast<struct sockaddr_in6*>(addr.addr);+      memcpy(&dns_server_addr.addr.addr6, &in6->sin6_addr,+             sizeof(struct in6_addr));+      dns_server_addr.tcp_port = grpc_sockaddr_get_port(&addr);+      dns_server_addr.udp_port = grpc_sockaddr_get_port(&addr);+    } else {+      return GRPC_ERROR_CREATE(+          absl::StrCat(""cannot parse authority "", dns_server));+    }+    // Prevent an uninitialized variable.+    dns_server_addr.next = nullptr;+    int status = ares_set_servers_ports(channel_, &dns_server_addr);+    if (status != ARES_SUCCESS) {+      return GRPC_ERROR_CREATE(absl::StrCat(+          ""c-ares status is not ARES_SUCCESS: "", ares_strerror(status)));+    }+  }+  return absl::OkStatus();+}++void GrpcAresRequest::OnReadable(FdNode* fd_node, absl::Status status) {+  grpc_core::MutexLock lock(&mu_);+  GPR_ASSERT(fd_node->readable_registered);+  fd_node->readable_registered = false;+  GRPC_ARES_WRAPPER_TRACE_LOG(""OnReadable: fd: %d; request: %p; status: %s"",+                              fd_node->as, this, status.ToString().c_str());+  GRPC_ARES_WRAPPER_STACK_TRACE();+  if (status.ok() && !shutting_down_) {+    do {+      ares_process_fd(channel_, fd_node->as, ARES_SOCKET_BAD);+    } while (fd_node->polled_fd->IsFdStillReadableLocked());+  } else {+    // If error is not absl::OkStatus() or the resolution was cancelled, it+    // means the fd has been shutdown or timed out. The pending lookups made+    // on this ev_driver will be cancelled by the following ares_cancel() and+    // the on_done callbacks will be invoked with a status of ARES_ECANCELLED.+    // The remaining file descriptors in this ev_driver will be cleaned up in+    // the follwing grpc_ares_notify_on_event_locked().+    ares_cancel(channel_);+  }+  Work();+}++void GrpcAresRequest::OnWritable(FdNode* fd_node, absl::Status status) {+  grpc_core::MutexLock lock(&mu_);+  GPR_ASSERT(fd_node->writable_registered);+  fd_node->writable_registered = false;+  GRPC_ARES_WRAPPER_TRACE_LOG(""OnWritable: fd: %d; request:%p; status: %s"",+                              fd_node->as, this, status.ToString().c_str());+  if (status.ok() && !shutting_down_) {+    ares_process_fd(channel_, ARES_SOCKET_BAD, fd_node->as);+  } else {+    // If error is not absl::OkStatus() or the resolution was cancelled, it+    // means the fd has been shutdown or timed out. The pending lookups made+    // on this ev_driver will be cancelled by the following ares_cancel() and+    // the on_done callbacks will be invoked with a status of ARES_ECANCELLED.+    // The remaining file descriptors in this ev_driver will be cleaned up in+    // the follwing grpc_ares_notify_on_event_locked().+    ares_cancel(channel_);+  }+  Work();+}++void GrpcAresRequest::OnQueryTimeout() {+  {+    grpc_core::MutexLock lock(&mu_);+    query_timeout_handle_.reset();+    GRPC_ARES_WRAPPER_TRACE_LOG(""request:%p OnQueryTimeout. shutting_down_=%d"",+                                this, shutting_down_);+    if (!shutting_down_) {+      shutting_down_ = true;+      ShutdownPolledFdsLocked(+          grpc_core::StatusCreate(absl::StatusCode::kDeadlineExceeded,+                                  ""OnQueryTimeout"", DEBUG_LOCATION, {}));+    }+  }+  Unref(DEBUG_LOCATION, ""OnQueryTimeout"");+}++// In case of non-responsive DNS servers, dropped packets, etc., c-ares has+// intelligent timeout and retry logic, which we can take advantage of by+// polling ares_process_fd on time intervals. Overall, the c-ares library is+// meant to be called into and given a chance to proceed name resolution:+//   a) when fd events happen+//   b) when some time has passed without fd events having happened+// For the latter, we use this backup poller. Also see+// https://github.com/grpc/grpc/pull/17688 description for more details.+void GrpcAresRequest::OnAresBackupPollAlarm() {+  {+    grpc_core::MutexLock lock(&mu_);+    ares_backup_poll_alarm_handle_.reset();+    GRPC_ARES_WRAPPER_TRACE_LOG(+        ""request:%p OnAresBackupPollAlarm shutting_down=%d."", this,+        shutting_down_);+    if (!shutting_down_) {+      for (auto it = fd_node_list_->begin(); it != fd_node_list_->end(); it++) {+        if (!(*it)->already_shutdown) {+          GRPC_ARES_WRAPPER_TRACE_LOG(+              ""request:%p OnAresBackupPollAlarm; ares_process_fd. fd=%s"", this,+              (*it)->polled_fd->GetName());+          ares_socket_t as = (*it)->polled_fd->GetWrappedAresSocketLocked();+          ares_process_fd(channel_, as, as);+        }+      }+      if (!shutting_down_) {+        EventEngine::Duration next_ares_backup_poll_alarm_duration =+            calculate_next_ares_backup_poll_alarm_duration();+        Ref(DEBUG_LOCATION, ""OnAresBackupPollAlarm"").release();+        ares_backup_poll_alarm_handle_ = event_engine_->RunAfter(+            next_ares_backup_poll_alarm_duration, [this] {+              grpc_core::ApplicationCallbackExecCtx callback_exec_ctx;+              grpc_core::ExecCtx exec_ctx;+              OnAresBackupPollAlarm();+            });+      }+      Work();+    }+  }+  Unref(DEBUG_LOCATION, ""OnAresBackupPollAlarm"");+}++// TODO(yijiem): Consider report this status or as part of the result when+// calling on_resolve_. This status is received in OnReadable/OnWritable.+void GrpcAresRequest::ShutdownPolledFdsLocked(absl::Status status) {+  for (auto it = fd_node_list_->begin(); it != fd_node_list_->end(); it++) {+    if (!(*it)->already_shutdown) {+      GRPC_ARES_WRAPPER_TRACE_LOG(""request: %p shutdown fd: %s"", this,+                                  (*it)->polled_fd->GetName());+      (*it)->polled_fd->ShutdownLocked(status);+      (*it)->already_shutdown = true;+    }+  }+}++GrpcAresHostnameRequest::GrpcAresHostnameRequest(+    absl::string_view name, absl::string_view default_port,+    EventEngine::Duration timeout,+    std::unique_ptr<GrpcPolledFdFactory> polled_fd_factory,+    EventEngine* event_engine)+    : GrpcAresRequest(name, default_port, timeout, std::move(polled_fd_factory),+                      event_engine) {}++GrpcAresHostnameRequest::~GrpcAresHostnameRequest() {+  GRPC_ARES_WRAPPER_TRACE_LOG(""request:%p destructor"", this);+}++void GrpcAresHostnameRequest::Start(+    absl::AnyInvocable<void(absl::StatusOr<Result>)> on_resolve) {+  auto self = Ref(DEBUG_LOCATION, ""Start"");+  grpc_core::ReleasableMutexLock lock(&mu_);+  GPR_ASSERT(initialized_);+  on_resolve_ = std::move(on_resolve);+  GRPC_ARES_WRAPPER_TRACE_LOG(+      ""request:%p c-ares GrpcAresHostnameRequest::Start name=%s, ""+      ""default_port=%s"",+      this, name_.c_str(), default_port_.c_str());+  // Early out if the target is an ipv4 or ipv6 literal.+  if (ResolveAsIPLiteralLocked()) {+    lock.Release();+    Unref(DEBUG_LOCATION, ""Start"");+    return;+  }+  // TODO(yijiem): Early out if the target is localhost and we're on Windows.++  // We add up pending_queries_ here since ares_gethostbyname may directly+  // invoke the callback inline if there is any error with the input. The+  // callback will invoke OnResolve with an error status and may destroy the+  // object too early (before the second ares_gethostbyname) if we haven't+  // added up here.+  pending_queries_++;+  if (IsIpv6LoopbackAvailable()) {+    pending_queries_++;+    auto* arg = new HostbynameArg();+    arg->request = this;+    arg->qtype = ""AAAA"";+    ares_gethostbyname(channel_, std::string(host_).c_str(), AF_INET6,+                       &GrpcAresHostnameRequest::OnHostbynameDoneLocked,+                       static_cast<void*>(arg));+  }+  auto* arg = new HostbynameArg();+  arg->request = this;+  arg->qtype = ""A"";+  ares_gethostbyname(channel_, std::string(host_).c_str(), AF_INET,+                     &GrpcAresHostnameRequest::OnHostbynameDoneLocked,+                     static_cast<void*>(arg));+  // It's possible that ares_gethostbyname gets everything done inline.+  if (!shutting_down_) {+    Work();+    StartTimers();+  }+}++void GrpcAresHostnameRequest::OnResolve(absl::StatusOr<Result> result) {+  GPR_ASSERT(pending_queries_ > 0);+  pending_queries_--;+  if (result.ok()) {+    result_.insert(result_.end(), result->begin(), result->end());+  } else {+    error_ = grpc_error_add_child(error_, result.status());+  }+  if (pending_queries_ == 0) {+    // Always Unref when goes out of this scope. NOTE: this Unref should not+    // trigger destruction. The call chain to OnResolve is:+    // ares_process_fd -> on_hostbyname_done_locked -> OnResolve.+    // ares_process_fd is called from either OnReadable/OnWritable or+    // OnAresBackupPollAlarm which holds their own ref. So this Unref should+    // not trigger destruction thus is safe to called under the lock. This+    // applies to other OnResolve too.+    auto closer =+        absl::MakeCleanup([this] { Unref(DEBUG_LOCATION, ""OnResolve""); });+    // We mark the event driver as being shut down.+    // grpc_ares_notify_on_event_locked will shut down any remaining+    // fds.+    if (cancelled_) {+      // Cancel does not invoke on_resolve.+      return;+    }+    shutting_down_ = true;+    CancelTimers();+    if (!result_.empty()) {+      // As long as there are records, we return them. Note that there might+      // be error_ from the other request too.","Great point! It does not need to be tracked separately. There is a semantic change in the EE API that errors and results are mutually exclusive. As long as there is valid result from a request (A or AAAA), we would return it instead of any error in the other request (previously we would always report error through `on_done`). I merged `result_` and `error_` into a single `absl::StatusOr<Result>`. PTAL.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32944,1182921386,2023-05-02T18:44:24Z,src/core/lib/security/authorization/rbac_policy.cc,"@@ -29,29 +29,29 @@ namespace grpc_core { // Rbac // -Rbac::Rbac(Rbac::Action action, std::map<std::string, Policy> policies,-           absl::string_view name)-    : action(action), policies(std::move(policies)), name(name) {}+Rbac::Rbac(absl::string_view name, Rbac::Action action,","Might as well take the name parameter as `std::string` instead of `absl::string_view`, since we're making a copy anyway.  That way, if a caller happens to have a temp string that they don't need to keep, they can pass it in with `std::move()` and avoid the copy.",
4181124,yashykt,https://api.github.com/repos/grpc/grpc/pulls/32981,1182993086,2023-05-02T19:57:02Z,doc/server-reflection.md,"@@ -171,5 +171,6 @@ each language: - [Go](https://github.com/grpc/grpc-go/blob/master/Documentation/server-reflection-tutorial.md#enable-server-reflection) - [C++](https://grpc.io/grpc/cpp/md_doc_server_reflection_tutorial.html) - [Python](https://github.com/grpc/grpc/blob/master/doc/python/server_reflection.md)+- [Rust](https://github.com/hyperium/tonic/tree/master/tonic-reflection)","This Rust library is not maintained in the grpc repo, so I'm not sure if we should be including it here.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32938,1183043428,2023-05-02T20:56:21Z,src/core/ext/filters/client_channel/resolver/xds/xds_resolver.h,"@@ -21,16 +21,39 @@  #include ""absl/strings/string_view.h"" +#include ""src/core/lib/gprpp/ref_counted_ptr.h"" #include ""src/core/lib/gprpp/unique_type_name.h"" #include ""src/core/lib/service_config/service_config_call_data.h""  namespace grpc_core { +// Forward declaration only, implementation is private+class XdsClusterMap;+class ClusterState;++class XdsClusterLbDataAttribute","Please call this `XdsClusterDataAttribute`.  It doesn't make sense to have `Lb` as part of the name, since this data really has nothing to do with the LB policies.",
79056955,l-monninger,https://api.github.com/repos/grpc/grpc/pulls/32981,1183044612,2023-05-02T20:57:45Z,doc/server-reflection.md,"@@ -171,5 +171,6 @@ each language: - [Go](https://github.com/grpc/grpc-go/blob/master/Documentation/server-reflection-tutorial.md#enable-server-reflection) - [C++](https://grpc.io/grpc/cpp/md_doc_server_reflection_tutorial.html) - [Python](https://github.com/grpc/grpc/blob/master/doc/python/server_reflection.md)+- [Rust](https://github.com/hyperium/tonic/tree/master/tonic-reflection)","Yeah, on second thought, I agree. It would also be inconsistent as other docs don't refer to `hyperium/tonic`. Maybe it's worth noting in the [contribution guidelines](https://github.com/grpc/grpc/blob/master/CONTRIBUTING.md) that only implementations in the `grpc` org should be referenced in the docs, so that nobody else does the same.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32938,1183057469,2023-05-02T21:13:57Z,src/core/ext/filters/client_channel/resolver/xds/xds_resolver.cc,"@@ -99,6 +108,54 @@ UniqueTypeName XdsClusterAttribute::TypeName() {   return kFactory.Create(); } +namespace {+class XdsResolver;+}  // namespace++// An entry in the map of clusters that need to be present in the LB+// policy config.  The map holds a weak ref.  One strong ref is held by+// the ConfigSelector, and another is held by each call assigned to+// the cluster by the ConfigSelector.  The ref for each call is held+// until the call is committed.  When the strong refs go away, we hop+// back into the WorkSerializer to remove the entry from the map.+class ClusterState : public DualRefCounted<ClusterState> {+ public:+  using ClusterStateMap =+      std::map<std::string, WeakRefCountedPtr<ClusterState>>;++  ClusterState(RefCountedPtr<XdsResolver> resolver,+               const std::string& cluster_name);++  void Orphan() override;++  const std::string& cluster() const { return it_->first; }++ private:+  RefCountedPtr<XdsResolver> resolver_;+  ClusterStateMap::iterator it_;+};++class XdsClusterMap : public RefCounted<XdsClusterMap> {+ public:+  bool operator==(const XdsClusterMap& other) const {+    return clusters_ == other.clusters_;+  }++  void clear() { clusters_.clear(); }++  bool contains(absl::string_view name) const {+    return clusters_.find(name) != clusters_.end();+  }++  void Put(RefCountedPtr<ClusterState> state);","Similarly, I don't think we want a `Put()` method either.  Instead, I think we need to change the `XdsConfigSelector` code to construct the `std::map<absl::string_view, RefCountedPtr<ClusterState>>` directly and then instantiate the `XdsClusterMap`, passing the map into the `XdsClusterMap` ctor.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32938,1183071315,2023-05-02T21:32:37Z,src/core/ext/filters/client_channel/resolver/xds/xds_resolver.cc,"@@ -695,8 +764,8 @@ XdsResolver::XdsConfigSelector::GetCallConfig(GetCallConfigArgs args) {             cluster_specifier_plugin_name.cluster_specifier_plugin_name);         method_config = entry.method_config;       });-  auto it = clusters_.find(cluster_name);-  GPR_ASSERT(it != clusters_.end());+  auto it = cluster_map_->Find(cluster_name);","This is no longer an iterator, so please rename it to something appropriate.",X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32938,1183072066,2023-05-02T21:33:41Z,src/core/ext/filters/client_channel/resolver/xds/xds_resolver.h,"@@ -21,16 +21,39 @@  #include ""absl/strings/string_view.h"" +#include ""src/core/lib/gprpp/ref_counted_ptr.h"" #include ""src/core/lib/gprpp/unique_type_name.h"" #include ""src/core/lib/service_config/service_config_call_data.h""  namespace grpc_core { +// Forward declaration only, implementation is private+class XdsClusterMap;+class ClusterState;++class XdsClusterLbDataAttribute+    : public ServiceConfigCallData::CallAttributeInterface {+ public:+  static UniqueTypeName TypeName() {+    static UniqueTypeName::Factory factory(""xds_cluster_lb_data"");+    return factory.Create();+  }++  explicit XdsClusterLbDataAttribute(RefCountedPtr<XdsClusterMap> cluster_map);++  bool LockClusterConfig(absl::string_view cluster_name);++  UniqueTypeName type() const override { return TypeName(); }++ private:+  RefCountedPtr<XdsClusterMap> cluster_map_;+  RefCountedPtr<ClusterState> locked_cluster_config_;","We don't want to store the ref to the `ClusterState` object in this call attribute, because then it won't get unreffed at the right point -- the ref will be held until the end of the call, which in the case of a long-running stream could cause us to maintain connections to the cluster for much longer than we actually need to.Currently, we are unreffing the `ClusterState` object via the `on_commit` callback that I introduced in #32812 (which you reviewed previously).  The client channel code ensures that that callback will be invoked in the right place (after the last LB pick attempt for the call, across all retry attempts).  I think we want to continue to leverage that.So I think what we need here is:- Change the `LockClusterConfig()` method to return `RefCountedPtr<ClusterState>`.- Add a method to `ServiceConfigCallData` to set the `on_commit` callback.- Change the `ClusterSelectionFilter` to call `LockClusterConfig()` to get a ref to the `ClusterState` and then set the `on_commit` callback to unref that `ClusterState`.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32938,1183097312,2023-05-02T22:14:02Z,src/core/ext/filters/client_channel/resolver/xds/xds_resolver.cc,"@@ -154,6 +211,19 @@ class XdsResolver : public Resolver {     if (xds_client_ != nullptr) xds_client_->ResetBackoff();   } +  void MaybeRemoveUnusedClusters();++  void Run(std::function<void()> callback, DebugLocation location) {+    work_serializer_->Run(std::move(callback), location);+  }++  ClusterState::ClusterStateMap::iterator Emplace(","I don't think we should need this method.  It looks like there's some legacy complexity here related to how we're storing the cluster name in the map keys.  I've sent you #32989 to simplify this.  Once that change has been merged, I don't think we'll need this method anymore.",X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32938,1183098290,2023-05-02T22:15:48Z,src/core/ext/filters/client_channel/resolver/xds/xds_resolver.cc,"@@ -99,6 +108,54 @@ UniqueTypeName XdsClusterAttribute::TypeName() {   return kFactory.Create(); } +namespace {+class XdsResolver;+}  // namespace++// An entry in the map of clusters that need to be present in the LB+// policy config.  The map holds a weak ref.  One strong ref is held by+// the ConfigSelector, and another is held by each call assigned to+// the cluster by the ConfigSelector.  The ref for each call is held+// until the call is committed.  When the strong refs go away, we hop+// back into the WorkSerializer to remove the entry from the map.+class ClusterState : public DualRefCounted<ClusterState> {+ public:+  using ClusterStateMap =+      std::map<std::string, WeakRefCountedPtr<ClusterState>>;++  ClusterState(RefCountedPtr<XdsResolver> resolver,+               const std::string& cluster_name);++  void Orphan() override;++  const std::string& cluster() const { return it_->first; }++ private:+  RefCountedPtr<XdsResolver> resolver_;+  ClusterStateMap::iterator it_;+};++class XdsClusterMap : public RefCounted<XdsClusterMap> {","Please add a comment here explaining what this class is for.  In particular, it's the cluster map being held by the `XdsConfigSelector`, not the one being held by the resolver.  Refs to this will also be held by individual calls between the time that the `XdsConfigSelector` is called and the time that the `ClusterSelectionFilter` runs.",
394885,soheilhy,https://api.github.com/repos/grpc/grpc/pulls/32996,1183206872,2023-05-03T03:17:17Z,src/core/lib/channel/channelz.h,"@@ -135,44 +134,32 @@ class CallCountingHelper {   // testing peer friend.   friend class testing::CallCountingHelperPeer; -  // TODO(soheil): add a proper PerCPU helper and use it here.-  struct AtomicCounterData {-    // Define the ctors so that we can use this structure in InlinedVector.-    AtomicCounterData() = default;-    AtomicCounterData(const AtomicCounterData& that)-        : calls_started(that.calls_started.load(std::memory_order_relaxed)),-          calls_succeeded(that.calls_succeeded.load(std::memory_order_relaxed)),-          calls_failed(that.calls_failed.load(std::memory_order_relaxed)),-          last_call_started_cycle(-              that.last_call_started_cycle.load(std::memory_order_relaxed)) {}+  std::atomic<int64_t> calls_started_{0};+  std::atomic<int64_t> calls_succeeded_{0};+  std::atomic<int64_t> calls_failed_{0};+  std::atomic<gpr_cycle_counter> last_call_started_cycle_{0};+};++class PerCpuCallCountingHelper {+ public:+  void RecordCallStarted();+  void RecordCallFailed();+  void RecordCallSucceeded();++  // Common rendering of the call count data and last_call_started_timestamp.+  void PopulateCallCounts(Json::Object* json);++ private:+  // testing peer friend.+  friend class testing::CallCountingHelperPeer; +  struct alignas(GPR_CACHELINE_SIZE) PerCpuData {     std::atomic<int64_t> calls_started{0};     std::atomic<int64_t> calls_succeeded{0};     std::atomic<int64_t> calls_failed{0};     std::atomic<gpr_cycle_counter> last_call_started_cycle{0};-    // Make sure the size is exactly one cache line.-    uint8_t padding[GPR_CACHELINE_SIZE - 3 * sizeof(std::atomic<intptr_t>) --                    sizeof(std::atomic<gpr_cycle_counter>)];   };-  // TODO(soheilhy,veblush): Revist this after abseil integration.-  // This has a problem when using abseil inlined_vector because it-  // carries an alignment attribute properly but our allocator doesn't-  // respect this. To avoid UBSAN errors, this should be removed with-  // abseil inlined_vector.-  // GPR_ALIGN_STRUCT(GPR_CACHELINE_SIZE);--  struct CounterData {-    int64_t calls_started = 0;-    int64_t calls_succeeded = 0;-    int64_t calls_failed = 0;-    gpr_cycle_counter last_call_started_cycle = 0;-  };--  // collects the sharded data into one CounterData struct.-  void CollectData(CounterData* out);--  std::vector<AtomicCounterData> per_cpu_counter_data_storage_;-  size_t num_cores_ = 0;+  PerCpu<PerCpuData> per_cpu_data_;",Wouldn't this be as large as what we had before?,
5663878,yijiem,https://api.github.com/repos/grpc/grpc/pulls/32701,1183222114,2023-05-03T04:09:44Z,test/core/event_engine/test_suite/tests/dns_test.cc,"@@ -25,7 +63,529 @@ void InitDNSTests() {} }  // namespace experimental }  // namespace grpc_event_engine -class EventEngineDNSTest : public EventEngineTest {};+namespace {++// TODO(yijiem): build a portable solution for Windows+constexpr char kDNSTestRecordGroupsYamlPath[] =+    ""test/core/event_engine/test_suite/tests/dns_test_record_groups.yaml"";+constexpr char kHealthCheckRecordName[] =+    ""health-check-local-dns-server-is-alive.resolver-tests.grpctestingexp"";++// You know where this comes from.+template <typename T>+void WaitForSingleOwner(std::shared_ptr<T>&& object) {+  while (object.use_count() > 1) {+    GRPC_LOG_EVERY_N_SEC(2, GPR_INFO, ""engine.use_count() = %ld"",+                         object.use_count());+    absl::SleepFor(absl::Milliseconds(100));+  }+}++}  // namespace++class EventEngineDNSTest : public EventEngineTest {+ public:+  static void SetUpTestSuite() {+    // Invoke bazel's executeable links to the .sh and .py scripts (don't use+    // the .sh and .py suffixes) to make sure that we're using bazel's test+    // environment.+    std::string kPythonWrapper = ""tools/distrib/python_wrapper"";+    std::string kDNSServerPath = ""test/cpp/naming/utils/dns_server"";+    std::string kDNSResolverPath = ""test/cpp/naming/utils/dns_resolver"";+    std::string kTCPConnectPath = ""test/cpp/naming/utils/tcp_connect"";+    // HACK: Hyrum's law.+    if (!grpc_core::GetEnv(""TEST_SRCDIR"").has_value()) {+      // Invoke the .sh and .py scripts directly where they are in source code.+      kPythonWrapper += "".sh"";+      kDNSServerPath += "".py"";+      kDNSResolverPath += "".py"";+      kTCPConnectPath += "".py"";+    }+    // 1. launch dns_server+    int port = grpc_pick_unused_port_or_die();+    ASSERT_NE(port, 0)+        << ""pick unused port failed, maybe the port server is not running? ""+           ""Start it with tools/run_tests/start_port_server.py"";+    // <path to python wrapper> <path to dns_server.py> -p <port> -r <path to+    // records config>+    _dns_server.server_process = new grpc::SubProcess(+        {kPythonWrapper, kDNSServerPath, ""-p"", std::to_string(port), ""-r"",+         kDNSTestRecordGroupsYamlPath});+    // TODO(yijiem): no way to check whether it fails or not+    _dns_server.port = port;++    // 2. wait until dns_server is up (health check)+    bool health_check_succeed = false;+    for (int i = 0; i < 10; i++) {+      // 2.1 tcp connect succeeds+      // <path to python wrapper> <path to tcp_connect.py> -s <hostname> -p+      // <port>+      grpc::SubProcess tcp_connect({kPythonWrapper, kTCPConnectPath, ""-s"",+                                    ""localhost"", ""-p"", std::to_string(port)});+      // TODO(yijiem): no way to check whether it fails or not+      if (tcp_connect.Join()) {+        // 2.2 make an A-record query to dns_server+        // <path to python wrapper> <path to dns_resolver.py> -s <hostname> -p+        // <port> -n <domain name to query>+        std::string command = absl::StrJoin(+            {kPythonWrapper.c_str(), kDNSResolverPath.c_str(), ""-s"",+             ""127.0.0.1"", ""-p"", std::to_string(port).c_str(), ""-n"",+             kHealthCheckRecordName},+            "" "");+        // TODO(yijiem): build a portable solution for Windows+        FILE* f = popen(command.c_str(), ""r"");",I think Windows has the equivalent of this `_popen` (https://learn.microsoft.com/en-us/cpp/c-runtime-library/reference/popen-wpopen?view=msvc-170).But point noted that Python might make this scripting cleaner. We might move the health checking part into one Python script and use the return value to indicate whether health checking succeeded or not. I will evaluate this part when start to work on Windows (hopefully soon).,
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32995,1183816205,2023-05-03T15:02:03Z,src/core/ext/filters/rbac/rbac_service_config_parser.cc,"@@ -722,6 +722,9 @@ const JsonLoaderInterface* RbacConfig::RbacPolicy::Rules::Policy::JsonLoader(  Rbac RbacConfig::RbacPolicy::Rules::TakeAsRbac() {   Rbac rbac;+  // TODO(lwge): This is to fix msan failure for now. Add proper conversion once",Isn't this PR adding that support?  I would think this would no longer be needed.,
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32995,1183828567,2023-05-03T15:11:19Z,test/core/security/grpc_authorization_engine_test.cc,"@@ -16,12 +16,106 @@  #include ""src/core/lib/security/authorization/grpc_authorization_engine.h"" +#include <memory>+ #include <gmock/gmock.h> #include <gtest/gtest.h> +#include <grpc/grpc_audit_logging.h>+#include <grpc/grpc_security_constants.h>++#include ""src/core/lib/security/authorization/audit_logging.h""+#include ""test/core/util/evaluate_args_test_util.h""+ namespace grpc_core { -TEST(GrpcAuthorizationEngineTest, AllowEngineWithMatchingPolicy) {+namespace {++constexpr absl::string_view kLoggerName = ""test_logger"";+constexpr absl::string_view kPolicyName = ""authz"";+constexpr absl::string_view kSpiffeId = ""spiffe://foo"";+constexpr absl::string_view kRpcMethod = ""/foo.Bar/Echo"";++using experimental::AuditContext;+using experimental::AuditLogger;+using experimental::AuditLoggerFactory;+using experimental::AuditLoggerRegistry;+using experimental::RegisterAuditLoggerFactory;++// This test class copies the audit context.+struct TestAuditContext {+  explicit TestAuditContext(const AuditContext& context)+      : rpc_method(context.rpc_method()),+        principal(context.principal()),+        policy_name(context.policy_name()),+        matched_rule(context.matched_rule()),+        authorized(context.authorized()) {}++  std::string rpc_method;+  std::string principal;+  std::string policy_name;+  std::string matched_rule;+  bool authorized;+};++class TestAuditLogger : public AuditLogger {+ public:+  explicit TestAuditLogger(+      std::vector<std::unique_ptr<TestAuditContext>>& contexts)+      : contexts_(contexts) {}++  void Log(const AuditContext& context) override {+    contexts_.push_back(std::make_unique<TestAuditContext>(context));+  }++ private:+  std::vector<std::unique_ptr<TestAuditContext>>& contexts_;+};++class TestAuditLoggerFactory : public AuditLoggerFactory {+ public:+  explicit TestAuditLoggerFactory(+      std::vector<std::unique_ptr<TestAuditContext>>& contexts)+      : contexts_(contexts) {}++  class TestAuditLoggerConfig : public AuditLoggerFactory::Config {","As per https://google.github.io/styleguide/cppguide.html#Declaration_Order, nested classes should be declated before the ctor.",
6241635,coryan,https://api.github.com/repos/grpc/grpc/pulls/32988,1183900616,2023-05-03T16:06:07Z,cmake/protobuf.cmake,"@@ -90,6 +86,6 @@ elseif(gRPC_PROTOBUF_PROVIDER STREQUAL ""package"")         set(_gRPC_PROTOBUF_PROTOC_EXECUTABLE ${PROTOBUF_PROTOC_EXECUTABLE})       endif()     endif()-    set(_gRPC_FIND_PROTOBUF ""if(NOT Protobuf_FOUND AND NOT PROTOBUF_FOUND)\n  find_package(Protobuf ${gRPC_PROTOBUF_PACKAGE_TYPE})\nendif()"")+    set(_gRPC_FIND_PROTOBUF ""if(NOT Protobuf_FOUND AND NOT PROTOBUF_FOUND)\n  find_package(Protobuf CONFIG)\nendif()"")","Unrelated, but this is going into `gRPCConfig.cmake`, you should use `find_dependency()` and not `find_package()` in those:https://cmake.org/cmake/help/latest/module/CMakeFindDependencyMacro.htmlhttps://stackoverflow.com/questions/50263280/difference-between-find-dependency-and-find-package-in-cmake",
7221003,rockspore,https://api.github.com/repos/grpc/grpc/pulls/32995,1183929248,2023-05-03T16:27:57Z,src/core/ext/filters/rbac/rbac_service_config_parser.cc,"@@ -722,6 +722,9 @@ const JsonLoaderInterface* RbacConfig::RbacPolicy::Rules::Policy::JsonLoader(  Rbac RbacConfig::RbacPolicy::Rules::TakeAsRbac() {   Rbac rbac;+  // TODO(lwge): This is to fix msan failure for now. Add proper conversion once","The SDK support is complete after this PR, hopefully.But the xDS flow support needs this `RbacPolicy` struct to have `int audit_condition` as a member, which will be part of my subsequent PR adding audit logging support in the service config parser. For now, this is still needed otherwise the audit_condition generated from the service config will be uninitialized. We didn't see any problem before since it's this PR that the audit condition actually starts to be used by the engine.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32837,1184269967,2023-05-03T20:54:20Z,src/core/ext/filters/http/message_compress/compression_filter.cc,"@@ -273,8 +273,8 @@ ArenaPromise<ServerMetadataHandle> ClientCompressionFilter::MakeCallPromise(         return std::move(*r);       });   // Run the next filter, and race it with getting an error from decompression.-  return Race(decompress_err->Wait(),-              next_promise_factory(std::move(call_args)));+  return PrioritizedRace(decompress_err->Wait(),",How about adding a TODO here that this no longer needs to be prioritized once we switch to the new 5-pipe scheme?,
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32938,1185524920,2023-05-04T21:14:44Z,src/core/ext/filters/client_channel/resolver/xds/xds_resolver.cc,"@@ -1177,50 +1196,37 @@ void RegisterXdsResolver(CoreConfiguration::Builder* builder) {       std::make_unique<XdsResolverFactory>()); } -void XdsClusterMap::Put(RefCountedPtr<ClusterState> state) {-  absl::string_view cluster_name = state->cluster();-  clusters_.emplace(cluster_name, std::move(state));-}--absl::optional<std::pair<absl::string_view, RefCountedPtr<ClusterState>>>-XdsClusterMap::Find(absl::string_view name) const {+RefCountedPtr<ClusterState> XdsClusterMap::Find(absl::string_view name) const {   auto it = clusters_.find(name);   if (it == clusters_.end()) {-    return absl::nullopt;+    return nullptr;   }-  return *it;+  return it->second; }  ClusterState::ClusterState(RefCountedPtr<XdsResolver> resolver,-                           const std::string& cluster_name)-    : resolver_(std::move(resolver)),-      it_(resolver_->Emplace(cluster_name, WeakRef())) {}+                           absl::string_view cluster_name)+    : resolver_(std::move(resolver)), cluster_name_(cluster_name) {}  void ClusterState::Orphan() {-  auto* resolver = resolver_.get();-  resolver->Run([resolver = std::move(-                     resolver_)]() { resolver->MaybeRemoveUnusedClusters(); },-                DEBUG_LOCATION);+  resolver_->MaybeRemoveUnusedClustersInWorkSerializer();","I just noticed that this change means that we're no longer unreffing the resolver from inside the `WorkSerializer`, which I think we need to be doing.I suggest changing `MaybeRemoveUnusedClustersInWorkSerializer()` to take a `RefCountedPtr<XdsResolver>` as an argument, which it will `std::move()` into the lambda, so that we're no longer holding a ref here in `ClusterState`.  This means that `MaybeRemoveUnusedClustersInWorkSerializer()` can also be a static method.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32938,1185540461,2023-05-04T21:34:25Z,src/core/ext/filters/client_channel/resolver/xds/xds_resolver.h,"@@ -31,23 +31,23 @@ namespace grpc_core { class XdsClusterMap; class ClusterState; -class XdsClusterLbDataAttribute+class XdsClusterDataAttribute     : public ServiceConfigCallData::CallAttributeInterface {  public:   static UniqueTypeName TypeName() {     static UniqueTypeName::Factory factory(""xds_cluster_lb_data"");     return factory.Create();   } -  explicit XdsClusterLbDataAttribute(RefCountedPtr<XdsClusterMap> cluster_map);+  explicit XdsClusterDataAttribute(RefCountedPtr<XdsClusterMap> cluster_map); -  bool LockClusterConfig(absl::string_view cluster_name);+  RefCountedPtr<ClusterState> LockAndGetClusterConfig(","Please document that this method should be called exactly once, at which point we drop our ref to the cluster map, so this attribute will no longer contain anything useful.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32938,1185587114,2023-05-04T23:00:35Z,src/core/ext/filters/client_channel/resolver/xds/xds_resolver.cc,"@@ -1177,50 +1196,37 @@ void RegisterXdsResolver(CoreConfiguration::Builder* builder) {       std::make_unique<XdsResolverFactory>()); } -void XdsClusterMap::Put(RefCountedPtr<ClusterState> state) {-  absl::string_view cluster_name = state->cluster();-  clusters_.emplace(cluster_name, std::move(state));-}--absl::optional<std::pair<absl::string_view, RefCountedPtr<ClusterState>>>-XdsClusterMap::Find(absl::string_view name) const {+RefCountedPtr<ClusterState> XdsClusterMap::Find(absl::string_view name) const {   auto it = clusters_.find(name);   if (it == clusters_.end()) {-    return absl::nullopt;+    return nullptr;   }-  return *it;+  return it->second; }  ClusterState::ClusterState(RefCountedPtr<XdsResolver> resolver,-                           const std::string& cluster_name)-    : resolver_(std::move(resolver)),-      it_(resolver_->Emplace(cluster_name, WeakRef())) {}+                           absl::string_view cluster_name)+    : resolver_(std::move(resolver)), cluster_name_(cluster_name) {}  void ClusterState::Orphan() {-  auto* resolver = resolver_.get();-  resolver->Run([resolver = std::move(-                     resolver_)]() { resolver->MaybeRemoveUnusedClusters(); },-                DEBUG_LOCATION);+  resolver_->MaybeRemoveUnusedClustersInWorkSerializer();","It doesn't fix the problem to just reset `cluster_` in this function.  The `ClusterState` object may be unreffed from outside the `WorkSerializer`, which is why we're hopping into the `WorkSerializer` to begin with, so we can't unref the resolver here.The actual goal here is to ensure that the resolver is destroyed inside the `WorkSerializer`, and any ref that we're holding to the resolver might be the last one, which means that we always need to release those refs inside the `WorkSerializer`.  Keep in mind that the lambda that we pass to the `WorkSerializer` may run in another thread, and it's entirely possible that that other thread will finish executing it (thus releasing the ref it's holding) before this thread releases its ref, so this could very well be the last ref to the resolver.Static methods of a class *do* have access to the class's private members; they just need a pointer to an object of that class, because they aren't called on an object of the class (i.e., they have no `this`).  So what we need to do in `XdsResolver` is this:```  static void MaybeRemoveUnusedClustersInWorkSerializer(      RefCountedPtr<XdsResolver> resolver) {    auto* resolver_ptr = resolver.get();    resolver_ptr->work_serializer_->Run(        [resolver = std::move(resolver)]() {          resolver->MaybeRemoveUnusedClusters();        },        DEBUG_LOCATION);  }```Then this method becomes:```void ClusterState::Orphan() {  XdsResolver::MaybeRemoveUnusedClustersInWorkSerializer(      std::move(resolver_));}```",
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/32701,1185592116,2023-05-04T23:12:08Z,src/core/lib/event_engine/ares_driver.cc,"@@ -327,12 +466,12 @@ class GrpcAresRequest::FdNodeList {   bool IsEmpty() const { return head_ == nullptr; }    void PushFdNode(FdNode* fd_node)-      ABSL_EXCLUSIVE_LOCKS_REQUIRED(&GrpcAresRequest::mu_) {+      ABSL_EXCLUSIVE_LOCKS_REQUIRED(&GrpcAresRequestImpl::mu_) {","I no longer see forward declarations, nor the suggestion you added above. Calling this resolved.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32938,1185595450,2023-05-04T23:20:12Z,src/core/ext/filters/client_channel/resolver/xds/xds_resolver.h,"@@ -21,11 +21,36 @@  #include ""absl/strings/string_view.h"" +#include ""src/core/lib/gprpp/ref_counted_ptr.h"" #include ""src/core/lib/gprpp/unique_type_name.h"" #include ""src/core/lib/service_config/service_config_call_data.h""  namespace grpc_core { +// Forward declaration only, implementation is private+class XdsClusterMap;+class ClusterState;++class XdsClusterMapAttribute","It occurs to me that this class can actually be moved into the .cc file.  The only two pieces of code that ever access this are the `XdsConfigSelector` code that sets the attribute and the `ClusterSelectionFilter` code that uses the attribute, and they are both in the .cc file, so it doesn't need to be exported anywhere else.",
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/32701,1185602408,2023-05-04T23:38:21Z,test/core/event_engine/test_suite/tests/dns_test.cc,"@@ -25,7 +63,529 @@ void InitDNSTests() {} }  // namespace experimental }  // namespace grpc_event_engine -class EventEngineDNSTest : public EventEngineTest {};+namespace {++// TODO(yijiem): build a portable solution for Windows+constexpr char kDNSTestRecordGroupsYamlPath[] =+    ""test/core/event_engine/test_suite/tests/dns_test_record_groups.yaml"";+constexpr char kHealthCheckRecordName[] =+    ""health-check-local-dns-server-is-alive.resolver-tests.grpctestingexp"";++// You know where this comes from.+template <typename T>+void WaitForSingleOwner(std::shared_ptr<T>&& object) {+  while (object.use_count() > 1) {+    GRPC_LOG_EVERY_N_SEC(2, GPR_INFO, ""engine.use_count() = %ld"",+                         object.use_count());+    absl::SleepFor(absl::Milliseconds(100));+  }+}++}  // namespace++class EventEngineDNSTest : public EventEngineTest {+ public:+  static void SetUpTestSuite() {+    // Invoke bazel's executeable links to the .sh and .py scripts (don't use+    // the .sh and .py suffixes) to make sure that we're using bazel's test+    // environment.+    std::string kPythonWrapper = ""tools/distrib/python_wrapper"";+    std::string kDNSServerPath = ""test/cpp/naming/utils/dns_server"";+    std::string kDNSResolverPath = ""test/cpp/naming/utils/dns_resolver"";+    std::string kTCPConnectPath = ""test/cpp/naming/utils/tcp_connect"";+    // HACK: Hyrum's law.+    if (!grpc_core::GetEnv(""TEST_SRCDIR"").has_value()) {+      // Invoke the .sh and .py scripts directly where they are in source code.+      kPythonWrapper += "".sh"";+      kDNSServerPath += "".py"";+      kDNSResolverPath += "".py"";+      kTCPConnectPath += "".py"";+    }+    // 1. launch dns_server+    int port = grpc_pick_unused_port_or_die();+    ASSERT_NE(port, 0)+        << ""pick unused port failed, maybe the port server is not running? ""+           ""Start it with tools/run_tests/start_port_server.py"";+    // <path to python wrapper> <path to dns_server.py> -p <port> -r <path to+    // records config>+    _dns_server.server_process = new grpc::SubProcess(+        {kPythonWrapper, kDNSServerPath, ""-p"", std::to_string(port), ""-r"",+         kDNSTestRecordGroupsYamlPath});+    // TODO(yijiem): no way to check whether it fails or not+    _dns_server.port = port;++    // 2. wait until dns_server is up (health check)+    bool health_check_succeed = false;+    for (int i = 0; i < 10; i++) {+      // 2.1 tcp connect succeeds+      // <path to python wrapper> <path to tcp_connect.py> -s <hostname> -p+      // <port>+      grpc::SubProcess tcp_connect({kPythonWrapper, kTCPConnectPath, ""-s"",+                                    ""localhost"", ""-p"", std::to_string(port)});+      // TODO(yijiem): no way to check whether it fails or not+      if (tcp_connect.Join()) {+        // 2.2 make an A-record query to dns_server+        // <path to python wrapper> <path to dns_resolver.py> -s <hostname> -p+        // <port> -n <domain name to query>+        std::string command = absl::StrJoin(+            {kPythonWrapper.c_str(), kDNSResolverPath.c_str(), ""-s"",","Interesting! And clever solution! I don't see StrJoin used this way even in abseil's own tests, so we might be relying on internal details if we specify the template class here. I could go either way with that, though. It might be worth trying to submit a few new tests to abseil to ensure this does not break (if they want to support the usage pattern).",
7221003,rockspore,https://api.github.com/repos/grpc/grpc/pulls/33026,1186509946,2023-05-05T21:23:51Z,test/core/security/grpc_audit_logging_test.cc,"@@ -81,26 +82,82 @@ class AuditLoggingTest : public ::testing::Test {  }  // namespace -TEST_F(AuditLoggingTest, SuccessfulLoggerCreation) {+//+// AuditLoggerRegistryTest+//++TEST_F(AuditLoggerRegistryTest, SuccessfulLoggerCreation) {   auto result = AuditLoggerRegistry::ParseConfig(kName, Json());   ASSERT_TRUE(result.ok());   ASSERT_NE(AuditLoggerRegistry::CreateAuditLogger(std::move(result.value())),             nullptr); } -TEST_F(AuditLoggingTest, UnknownLogger) {+TEST_F(AuditLoggerRegistryTest, UnknownLogger) {   auto result = AuditLoggerRegistry::ParseConfig(""unknown_logger"", Json());   EXPECT_EQ(result.status().code(), absl::StatusCode::kNotFound);   EXPECT_EQ(result.status().message(),             ""audit logger factory for unknown_logger does not exist"")       << result.status(); } -TEST_F(AuditLoggingTest, AuditLoggerFactoryExistenceChecks) {+TEST_F(AuditLoggerRegistryTest, LoggerFactoryExistenceChecks) {   EXPECT_TRUE(AuditLoggerRegistry::FactoryExists(kName));   EXPECT_FALSE(AuditLoggerRegistry::FactoryExists(""unknown_logger"")); } +//+//  StdoutLoggerTest",The stdout logger is added to the same library target in the BUILD file. I think it's easier to have things in the same test target.,
7221003,rockspore,https://api.github.com/repos/grpc/grpc/pulls/33026,1186510405,2023-05-05T21:24:40Z,test/core/security/grpc_audit_logging_test.cc,"@@ -81,26 +82,82 @@ class AuditLoggingTest : public ::testing::Test {  }  // namespace -TEST_F(AuditLoggingTest, SuccessfulLoggerCreation) {+//+// AuditLoggerRegistryTest+//++TEST_F(AuditLoggerRegistryTest, SuccessfulLoggerCreation) {   auto result = AuditLoggerRegistry::ParseConfig(kName, Json());   ASSERT_TRUE(result.ok());   ASSERT_NE(AuditLoggerRegistry::CreateAuditLogger(std::move(result.value())),             nullptr); } -TEST_F(AuditLoggingTest, UnknownLogger) {+TEST_F(AuditLoggerRegistryTest, UnknownLogger) {   auto result = AuditLoggerRegistry::ParseConfig(""unknown_logger"", Json());   EXPECT_EQ(result.status().code(), absl::StatusCode::kNotFound);   EXPECT_EQ(result.status().message(),             ""audit logger factory for unknown_logger does not exist"")       << result.status(); } -TEST_F(AuditLoggingTest, AuditLoggerFactoryExistenceChecks) {+TEST_F(AuditLoggerRegistryTest, LoggerFactoryExistenceChecks) {   EXPECT_TRUE(AuditLoggerRegistry::FactoryExists(kName));   EXPECT_FALSE(AuditLoggerRegistry::FactoryExists(""unknown_logger"")); } +//+//  StdoutLoggerTest+//++TEST(StdoutLoggerTest, LoggerFactoryExistenceChecks) {+  EXPECT_TRUE(AuditLoggerRegistry::FactoryExists(""stdout_logger""));+}++TEST(StdoutLoggerTest, BadLoggerConfig) {+  auto result =+      AuditLoggerRegistry::ParseConfig(""stdout_logger"", Json::FromBool(false));+  ASSERT_EQ(result.status().code(), absl::StatusCode::kInvalidArgument);+  ASSERT_EQ(result.status().message(), ""config is not a json object"")+      << result.status();+}++TEST(StdoutLoggerTest, StdoutLoggerCreationAndLogInvocation) {+  auto result =+      AuditLoggerRegistry::ParseConfig(""stdout_logger"", Json::FromObject({}));+  ASSERT_TRUE(result.ok());+  auto logger =+      AuditLoggerRegistry::CreateAuditLogger(std::move(result.value()));+  AuditContext context(""method"", ""spiffe"", ""policy"", ""rule"", true);+  ::testing::internal::CaptureStdout();+  logger->Log(context);+  auto output = ::testing::internal::GetCapturedStdout();+  std::cout << output << '\n';",Sorry. This was useless stuff that I forgot to revert after using it locally. Thanks for the catch.,X
5663878,yijiem,https://api.github.com/repos/grpc/grpc/pulls/33030,1186548405,2023-05-05T23:02:51Z,src/core/ext/filters/client_channel/resolver/dns/event_engine/event_engine_client_channel_resolver.cc,"@@ -400,7 +401,21 @@ void EventEngineClientChannelDNSResolver::EventEngineDNSRequestWrapper::       errors_.AddError(service_config.status().message());       service_config_json_ = service_config.status();     } else {-      service_config_json_ = absl::StrCat(""grpc_config="", *service_config);+      constexpr char kServiceConfigAttributePrefix[] = ""grpc_config="";+      auto result = std::find_if(service_config->begin(), service_config->end(),+                                 [&](absl::string_view s) {+                                   return absl::StartsWith(+                                       s, kServiceConfigAttributePrefix);+                                 });+      if (result != service_config->end()) {","yeah, I think the previous logic is not correct (this code is still under development and not used until EventEngine::DNSResolver is ready) since gRPC's service config data starts with `grpc_config=` followed by the JSON-formatted data. See: https://github.com/grpc/proposal/blob/master/A2-service-configs-in-dns.md#encoding-in-dns-txt-records.",
16962414,gtcooke94,https://api.github.com/repos/grpc/grpc/pulls/33026,1187514546,2023-05-08T14:26:21Z,src/core/lib/security/authorization/stdout_logger.cc,"@@ -0,0 +1,75 @@+// Copyright 2023 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++#include <grpc/support/port_platform.h>++#include ""src/core/lib/security/authorization/stdout_logger.h""++#include <cstdio>+#include <initializer_list>+#include <memory>+#include <string>++#include ""absl/status/status.h""+#include ""absl/status/statusor.h""+#include ""absl/strings/str_format.h""+#include ""absl/strings/string_view.h""+#include ""absl/time/clock.h""+#include ""absl/time/time.h""++#include <grpc/grpc_audit_logging.h>+#include <grpc/support/log.h>++#include ""src/core/lib/json/json.h""++namespace grpc_core {+namespace experimental {++constexpr absl::string_view kName = ""stdout_logger"";+const char kLogFormat[] =+    ""{\""grpc_audit_log\"":{\""timestamp\"":%d,\""rpc_method\"":\""%s\"",\""principal\"":""+    ""\""%s\"",\""policy_name\"":\""%s\"",\""matched_rule\"":\""%s\"",\""authorized\"":%s}}"";","I actually meant the other way around, do we want _any_ newlines here at all, or one big single line that is the audit log?",
5564114,Vignesh2208,https://api.github.com/repos/grpc/grpc/pulls/32869,1187611109,2023-05-08T15:55:17Z,src/core/lib/event_engine/thread_pool/work_stealing_thread_pool.cc,"@@ -0,0 +1,459 @@+//+//+// Copyright 2015 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+//+//++#include <grpc/support/port_platform.h>++#include ""src/core/lib/event_engine/thread_pool/work_stealing_thread_pool.h""++#include <atomic>+#include <memory>+#include <utility>++#include ""absl/time/clock.h""+#include ""absl/time/time.h""++#include <grpc/support/log.h>++#include ""src/core/lib/backoff/backoff.h""+#include ""src/core/lib/debug/trace.h""+#include ""src/core/lib/event_engine/common_closures.h""+#include ""src/core/lib/event_engine/thread_local.h""+#include ""src/core/lib/event_engine/trace.h""+#include ""src/core/lib/event_engine/work_queue/basic_work_queue.h""+#include ""src/core/lib/event_engine/work_queue/work_queue.h""+#include ""src/core/lib/gprpp/thd.h""+#include ""src/core/lib/gprpp/time.h""++namespace grpc_event_engine {+namespace experimental {++namespace {+constexpr grpc_core::Duration kIdleThreadLimit =+    grpc_core::Duration::Seconds(20);+constexpr grpc_core::Duration kTimeBetweenThrottledThreadStarts =+    grpc_core::Duration::Seconds(1);+constexpr grpc_core::Duration kWorkerThreadMinSleepBetweenChecks{+    grpc_core::Duration::Milliseconds(33)};+constexpr grpc_core::Duration kWorkerThreadMaxSleepBetweenChecks{+    grpc_core::Duration::Seconds(3)};+constexpr grpc_core::Duration kLifeguardMinSleepBetweenChecks{+    grpc_core::Duration::Milliseconds(50)};+constexpr grpc_core::Duration kLifeguardMaxSleepBetweenChecks{+    grpc_core::Duration::Seconds(1)};+constexpr absl::Duration kSleepBetweenQuiesceCheck{absl::Milliseconds(10)};+}  // namespace++thread_local WorkQueue* g_local_queue = nullptr;++// -------- WorkStealingThreadPool --------++WorkStealingThreadPool::WorkStealingThreadPool(size_t reserve_threads)+    : pool_{std::make_shared<WorkStealingThreadPoolImpl>(reserve_threads)} {+  pool_->Start();+}++void WorkStealingThreadPool::Quiesce() { pool_->Quiesce(); }++WorkStealingThreadPool::~WorkStealingThreadPool() {+  GPR_ASSERT(pool_->IsQuiesced());+}++void WorkStealingThreadPool::Run(absl::AnyInvocable<void()> callback) {+  Run(SelfDeletingClosure::Create(std::move(callback)));+}++void WorkStealingThreadPool::Run(EventEngine::Closure* closure) {+  pool_->Run(closure);+}++// -------- WorkStealingThreadPool::TheftRegistry --------++void WorkStealingThreadPool::TheftRegistry::Enroll(WorkQueue* queue) {+  grpc_core::MutexLock lock(&mu_);+  queues_.emplace(queue);+}++void WorkStealingThreadPool::TheftRegistry::Unenroll(WorkQueue* queue) {+  grpc_core::MutexLock lock(&mu_);+  queues_.erase(queue);+}++EventEngine::Closure* WorkStealingThreadPool::TheftRegistry::StealOne() {+  grpc_core::MutexLock lock(&mu_);+  EventEngine::Closure* closure;+  for (auto* queue : queues_) {","One potential future optimization here could be that if we have a data structure that returns the queue with the highest backlog (in-terms of queue length), it might be preferable to steal from that queue first. It can even be coarse grained: queues can be put into 3 buckets: SMALL, MEDIUM, LARGE depending on their queue length and while stealing, we can iterate over large queues first before moving on to medium and small sized queues.",
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/32869,1187645881,2023-05-08T16:31:12Z,src/core/lib/event_engine/thread_pool/work_stealing_thread_pool.cc,"@@ -0,0 +1,459 @@+//+//+// Copyright 2015 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+//+//++#include <grpc/support/port_platform.h>++#include ""src/core/lib/event_engine/thread_pool/work_stealing_thread_pool.h""++#include <atomic>+#include <memory>+#include <utility>++#include ""absl/time/clock.h""+#include ""absl/time/time.h""++#include <grpc/support/log.h>++#include ""src/core/lib/backoff/backoff.h""+#include ""src/core/lib/debug/trace.h""+#include ""src/core/lib/event_engine/common_closures.h""+#include ""src/core/lib/event_engine/thread_local.h""+#include ""src/core/lib/event_engine/trace.h""+#include ""src/core/lib/event_engine/work_queue/basic_work_queue.h""+#include ""src/core/lib/event_engine/work_queue/work_queue.h""+#include ""src/core/lib/gprpp/thd.h""+#include ""src/core/lib/gprpp/time.h""++namespace grpc_event_engine {+namespace experimental {++namespace {+constexpr grpc_core::Duration kIdleThreadLimit =+    grpc_core::Duration::Seconds(20);+constexpr grpc_core::Duration kTimeBetweenThrottledThreadStarts =+    grpc_core::Duration::Seconds(1);+constexpr grpc_core::Duration kWorkerThreadMinSleepBetweenChecks{+    grpc_core::Duration::Milliseconds(33)};+constexpr grpc_core::Duration kWorkerThreadMaxSleepBetweenChecks{+    grpc_core::Duration::Seconds(3)};+constexpr grpc_core::Duration kLifeguardMinSleepBetweenChecks{+    grpc_core::Duration::Milliseconds(50)};+constexpr grpc_core::Duration kLifeguardMaxSleepBetweenChecks{+    grpc_core::Duration::Seconds(1)};+constexpr absl::Duration kSleepBetweenQuiesceCheck{absl::Milliseconds(10)};+}  // namespace++thread_local WorkQueue* g_local_queue = nullptr;++// -------- WorkStealingThreadPool --------++WorkStealingThreadPool::WorkStealingThreadPool(size_t reserve_threads)+    : pool_{std::make_shared<WorkStealingThreadPoolImpl>(reserve_threads)} {+  pool_->Start();+}++void WorkStealingThreadPool::Quiesce() { pool_->Quiesce(); }++WorkStealingThreadPool::~WorkStealingThreadPool() {+  GPR_ASSERT(pool_->IsQuiesced());+}++void WorkStealingThreadPool::Run(absl::AnyInvocable<void()> callback) {+  Run(SelfDeletingClosure::Create(std::move(callback)));+}++void WorkStealingThreadPool::Run(EventEngine::Closure* closure) {+  pool_->Run(closure);+}++// -------- WorkStealingThreadPool::TheftRegistry --------++void WorkStealingThreadPool::TheftRegistry::Enroll(WorkQueue* queue) {+  grpc_core::MutexLock lock(&mu_);+  queues_.emplace(queue);+}++void WorkStealingThreadPool::TheftRegistry::Unenroll(WorkQueue* queue) {+  grpc_core::MutexLock lock(&mu_);+  queues_.erase(queue);+}++EventEngine::Closure* WorkStealingThreadPool::TheftRegistry::StealOne() {+  grpc_core::MutexLock lock(&mu_);+  EventEngine::Closure* closure;+  for (auto* queue : queues_) {","The bucketing idea is interesting. We could also institute queue priorities, I've seen some good results there. I just wonder if the overhead of queue juggling would negate the benefits of optimizing for queue time.> One potential future optimization here could be that if we have a data structure that returns the queue with the highest backlog (in-terms of queue length), it might be preferable to steal from that queue first.Maybe so. In my chats with @soheilhy, optimizing for queue time was not terribly fruitful in their experiments. Further, this is pop-most-recent because we have a high performance queue implementation that avoids mutexes for LIFO operations. It has some very rare atomic flake issues, so I planned to land that as a subsequent improvement.But these are all things we can experiment with if the performance difference is meaningful.",
287917,eugeneo,https://api.github.com/repos/grpc/grpc/pulls/32938,1187761501,2023-05-08T18:35:29Z,src/core/ext/filters/client_channel/resolver/xds/xds_resolver.h,"@@ -21,11 +21,36 @@  #include ""absl/strings/string_view.h"" +#include ""src/core/lib/gprpp/ref_counted_ptr.h"" #include ""src/core/lib/gprpp/unique_type_name.h"" #include ""src/core/lib/service_config/service_config_call_data.h""  namespace grpc_core { +// Forward declaration only, implementation is private+class XdsClusterMap;+class ClusterState;++class XdsClusterMapAttribute",Moved all into the XdsResolver class. Will move back as/if needed. Reduced the size of the change.,
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/32869,1187764866,2023-05-08T18:39:17Z,test/core/event_engine/thread_pool_test.cc,"@@ -12,117 +12,204 @@ // See the License for the specific language governing permissions and // limitations under the License. -#include ""src/core/lib/event_engine/thread_pool.h""--#include <stdlib.h>+#include ""src/core/lib/event_engine/thread_pool/thread_pool.h"" +#include <atomic> #include <chrono>+#include <cmath>+#include <functional> #include <thread> +#include ""absl/time/clock.h""+#include ""absl/time/time.h"" #include ""gtest/gtest.h"" -#include <grpc/support/log.h>+#include <grpc/grpc.h> +#include ""src/core/lib/event_engine/thread_pool/original_thread_pool.h""+#include ""src/core/lib/event_engine/thread_pool/work_stealing_thread_pool.h"" #include ""src/core/lib/gprpp/notification.h""+#include ""test/core/util/test_config.h""  namespace grpc_event_engine { namespace experimental { -TEST(ThreadPoolTest, CanRunClosure) {-  ThreadPool p;+template <typename T>+class ThreadPoolTest : public testing::Test {};++using ThreadPoolTypes =+    ::testing::Types<OriginalThreadPool, WorkStealingThreadPool>;+TYPED_TEST_SUITE(ThreadPoolTest, ThreadPoolTypes);++TYPED_TEST(ThreadPoolTest, CanRunAnyInvocable) {+  TypeParam p(8);   grpc_core::Notification n;   p.Run([&n] { n.Notify(); });   n.WaitForNotification();   p.Quiesce(); } -TEST(ThreadPoolTest, CanDestroyInsideClosure) {-  auto p = std::make_shared<ThreadPool>();+TYPED_TEST(ThreadPoolTest, CanDestroyInsideClosure) {+  auto* p = new TypeParam(8);   grpc_core::Notification n;   p->Run([p, &n]() mutable {-    std::this_thread::sleep_for(std::chrono::seconds(1));     // This should delete the thread pool and not deadlock     p->Quiesce();-    p.reset();+    delete p;     n.Notify();   });-  // Make sure we're not keeping the thread pool alive from outside the loop-  p.reset();   n.WaitForNotification(); } -TEST(ThreadPoolTest, CanSurviveFork) {-  ThreadPool p;-  grpc_core::Notification n;-  gpr_log(GPR_INFO, ""run callback 1"");-  p.Run([&n, &p] {+TYPED_TEST(ThreadPoolTest, CanSurviveFork) {+  TypeParam p(8);+  grpc_core::Notification inner_closure_ran;+  p.Run([&inner_closure_ran, &p] {     std::this_thread::sleep_for(std::chrono::seconds(1));-    gpr_log(GPR_INFO, ""run callback 2"");-    p.Run([&n] {+    p.Run([&inner_closure_ran] {       std::this_thread::sleep_for(std::chrono::seconds(1));-      gpr_log(GPR_INFO, ""notify"");-      n.Notify();+      inner_closure_ran.Notify();     });   });-  gpr_log(GPR_INFO, ""prepare fork"");+  // simulate a fork and watch the child process   p.PrepareFork();-  gpr_log(GPR_INFO, ""postfork child"");   p.PostforkChild();-  n.WaitForNotification();+  inner_closure_ran.WaitForNotification();   grpc_core::Notification n2;-  gpr_log(GPR_INFO, ""run callback 3"");-  p.Run([&n2] {-    gpr_log(GPR_INFO, ""notify"");-    n2.Notify();-  });-  gpr_log(GPR_INFO, ""wait for notification"");+  p.Run([&n2] { n2.Notify(); });   n2.WaitForNotification();   p.Quiesce(); } -void ScheduleSelf(ThreadPool* p) {-  p->Run([p] { ScheduleSelf(p); });+TYPED_TEST(ThreadPoolTest, ForkStressTest) {+  // Runs a large number of closures and multiple simulated fork events,+  // ensuring that only some fixed number of closures are executed between fork+  // events.+  constexpr int expected_runcount = 1000;+  constexpr absl::Duration fork_freqency{absl::Milliseconds(50)};+  constexpr int num_closures_between_forks{100};+  TypeParam pool(8);+  std::atomic<int> runcount{0};+  std::atomic<int> fork_count{0};+  std::function<void()> inner_fn;+  inner_fn = [&]() {+    auto curr_runcount = runcount.load(std::memory_order_relaxed);+    // exit when the right number of closures have run, with some flex for+    // relaxed atomics.+    if (curr_runcount >= expected_runcount) return;+    if (fork_count.load(std::memory_order_relaxed) *+            num_closures_between_forks <=+        curr_runcount) {+      // skip incrementing, and schedule again.+      pool.Run(inner_fn);+      return;+    }+    runcount.fetch_add(1, std::memory_order_relaxed);+  };+  for (int i = 0; i < expected_runcount; i++) {+    pool.Run(inner_fn);+  }+  // simulate multiple forks at a fixed frequency+  int curr_runcount = 0;+  while (curr_runcount < expected_runcount) {+    absl::SleepFor(fork_freqency);+    curr_runcount = runcount.load(std::memory_order_relaxed);+    int curr_forkcount = fork_count.load(std::memory_order_relaxed);+    if (curr_forkcount * num_closures_between_forks > curr_runcount) {+      continue;+    }+    pool.PrepareFork();+    pool.PostforkChild();+    fork_count.fetch_add(1);+  }+  ASSERT_GE(fork_count.load(), expected_runcount / num_closures_between_forks);+  // owners are the local pool, and the copy inside `inner_fn`.+  pool.Quiesce(); } -// This can be re-enabled if/when the thread pool is changed to quiesce-// pre-fork. For now, it cannot get stuck because callback execution is-// effectively paused until after the post-fork reboot.-TEST(ThreadPoolDeathTest, DISABLED_CanDetectStucknessAtFork) {-  ASSERT_DEATH_IF_SUPPORTED(-      [] {-        gpr_set_log_verbosity(GPR_LOG_SEVERITY_ERROR);-        ThreadPool p;-        ScheduleSelf(&p);-        std::thread terminator([] {-          std::this_thread::sleep_for(std::chrono::seconds(10));-          abort();-        });-        p.PrepareFork();-      }(),-      ""Waiting for thread pool to idle before forking"");+void ScheduleSelf(ThreadPool* p) {+  p->Run([p] { ScheduleSelf(p); }); } -void ScheduleTwiceUntilZero(ThreadPool* p, int n) {+void ScheduleTwiceUntilZero(ThreadPool* p, std::atomic<int>& runcount, int n) {+  runcount.fetch_add(1);   if (n == 0) return;-  p->Run([p, n] {-    ScheduleTwiceUntilZero(p, n - 1);-    ScheduleTwiceUntilZero(p, n - 1);+  p->Run([p, &runcount, n] {+    ScheduleTwiceUntilZero(p, runcount, n - 1);+    ScheduleTwiceUntilZero(p, runcount, n - 1);   }); } -TEST(ThreadPoolTest, CanStartLotsOfClosures) {-  ThreadPool p;+TYPED_TEST(ThreadPoolTest, CanStartLotsOfClosures) {+  TypeParam p(8);+  std::atomic<int> runcount{0};   // Our first thread pool implementation tried to create ~1M threads for this   // test.-  ScheduleTwiceUntilZero(&p, 20);+  ScheduleTwiceUntilZero(&p, runcount, 20);+  p.Quiesce();+  ASSERT_EQ(runcount.load(), pow(2, 21) - 1);+}++TYPED_TEST(ThreadPoolTest, ScalesWhenBackloggedFromSingleThreadLocalQueue) {+  int pool_thread_count = 8;","There is no upper limit. As is, this test ensures that scaling happens, which is essential. I'm not sure if we can safely specify a minimum scale amount to assert for all implementations. Do you think some N threads would make this a better test?The biggest issue with ""more and more (N) threads"" is that the pool implementation creates at most 1 thread per second, so the test could take a while depending on N.",
287917,eugeneo,https://api.github.com/repos/grpc/grpc/pulls/32938,1187779991,2023-05-08T18:51:50Z,src/core/ext/filters/client_channel/resolver/xds/xds_resolver.cc,"@@ -1177,50 +1196,37 @@ void RegisterXdsResolver(CoreConfiguration::Builder* builder) {       std::make_unique<XdsResolverFactory>()); } -void XdsClusterMap::Put(RefCountedPtr<ClusterState> state) {-  absl::string_view cluster_name = state->cluster();-  clusters_.emplace(cluster_name, std::move(state));-}--absl::optional<std::pair<absl::string_view, RefCountedPtr<ClusterState>>>-XdsClusterMap::Find(absl::string_view name) const {+RefCountedPtr<ClusterState> XdsClusterMap::Find(absl::string_view name) const {   auto it = clusters_.find(name);   if (it == clusters_.end()) {-    return absl::nullopt;+    return nullptr;   }-  return *it;+  return it->second; }  ClusterState::ClusterState(RefCountedPtr<XdsResolver> resolver,-                           const std::string& cluster_name)-    : resolver_(std::move(resolver)),-      it_(resolver_->Emplace(cluster_name, WeakRef())) {}+                           absl::string_view cluster_name)+    : resolver_(std::move(resolver)), cluster_name_(cluster_name) {}  void ClusterState::Orphan() {-  auto* resolver = resolver_.get();-  resolver->Run([resolver = std::move(-                     resolver_)]() { resolver->MaybeRemoveUnusedClusters(); },-                DEBUG_LOCATION);+  resolver_->MaybeRemoveUnusedClustersInWorkSerializer();",Reverted to initial version as `ClusterState` is back to inner class.,
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32938,1187816799,2023-05-08T19:34:24Z,src/core/ext/filters/client_channel/resolver/xds/xds_resolver.cc,"@@ -296,6 +239,63 @@ class XdsResolver : public Resolver {     RefCountedPtr<XdsResolver> resolver_;   }; +  // An entry in the map of clusters that need to be present in the LB+  // policy config.  The map holds a weak ref.  One strong ref is held by+  // the ConfigSelector, and another is held by each call assigned to+  // the cluster by the ConfigSelector.  The ref for each call is held+  // until the call is committed.  When the strong refs go away, we hop+  // back into the WorkSerializer to remove the entry from the map.+  class ClusterState : public DualRefCounted<ClusterState> {+   public:+    using ClusterStateMap =",This typedef is no longer needed as of #32989.,X
1644595,gnossen,https://api.github.com/repos/grpc/grpc/pulls/32974,1187967882,2023-05-08T22:51:54Z,src/python/grpcio/grpc/_observability.py,"@@ -0,0 +1,106 @@+# Copyright 2023 The gRPC authors.+#+# Licensed under the Apache License, Version 2.0 (the ""License"");+# you may not use this file except in compliance with the License.+# You may obtain a copy of the License at+#+#     http://www.apache.org/licenses/LICENSE-2.0+#+# Unless required by applicable law or agreed to in writing, software+# distributed under the License is distributed on an ""AS IS"" BASIS,+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+# See the License for the specific language governing permissions and+# limitations under the License.++import abc+import logging+import sys+from typing import Any, Generic, Optional, TypeVar++import grpc  # pytype: disable=pyi-error+from grpc._cython import cygrpc as _cygrpc++_LOGGER = logging.getLogger(__name__)++_channel = Any  # _channel.py imports this module.+PyCapsule = TypeVar('PyCapsule')+++class GrpcObservability(Generic[PyCapsule], metaclass=abc.ABCMeta):+    # we need to add hooks so that the GCP observability package can register functions with+    # the grpcio module and so can any other observability module conforming to the interface.+    _TRACING_ENABLED: bool = False+    _STATS_ENABLED: bool = False++    @abc.abstractmethod+    def create_client_call_tracer_capsule(self, method_name: bytes) -> PyCapsule:+        raise NotImplementedError()++    @abc.abstractmethod+    def delete_client_call_tracer(+            self, client_call_tracer_capsule: PyCapsule) -> None:+        # delte client call tracer have to be called on o11y package side.+        # Call it for both segregated and integrated call (`_process_integrated_call_tag`)+        raise NotImplementedError()++    @abc.abstractmethod+    def save_trace_context(self, trace_id: str, span_id: str,+                           is_sampled: bool) -> None:+        raise NotImplementedError()++    @abc.abstractmethod+    def create_server_call_tracer_factory(self) -> PyCapsule:+        raise NotImplementedError()++    @abc.abstractmethod+    def record_rpc_latency(self, method: str, rpc_latency: float,+                           status_code: Any) -> None:+        raise NotImplementedError()++    def _enable_tracing(self, enable: bool) -> None:+        self._TRACING_ENABLED = enable++    def _enable_stats(self, enable: bool) -> None:+        self._STATS_ENABLED = enable++    def _tracing_enabled(self) -> bool:+        return self._TRACING_ENABLED++    def _stats_enabled(self) -> bool:+        return self._STATS_ENABLED++    def _observability_enabled(self) -> bool:+        return self._tracing_enabled() or self._stats_enabled()+++def _observability_init(grpc_observability: GrpcObservability) -> None:+    try:+        grpc._observability._grpc_observability_stub = grpc_observability+        _cygrpc.set_server_call_tracer_factory(grpc_observability)+    except Exception as e:  # pylint:disable=broad-except+        _LOGGER.exception(""grpc.observability initiazation failed with %s"", e)+++def get_grpc_observability() -> Optional[GrpcObservability]:+    observability_stub: Optional[GrpcObservability]+    try:+        observability_stub = grpc._observability._grpc_observability_stub","This is not very conventional. At the top of the file, you should initialize your singleton to `None`:```python_GRPC_OBSERVABILITY_STUB: Optional[GrpcObservablity] = None```Then this helper function becomes a no-op.",
1644595,gnossen,https://api.github.com/repos/grpc/grpc/pulls/32974,1187971589,2023-05-08T23:00:03Z,src/python/grpcio/grpc/_observability.py,"@@ -0,0 +1,106 @@+# Copyright 2023 The gRPC authors.+#+# Licensed under the Apache License, Version 2.0 (the ""License"");+# you may not use this file except in compliance with the License.+# You may obtain a copy of the License at+#+#     http://www.apache.org/licenses/LICENSE-2.0+#+# Unless required by applicable law or agreed to in writing, software+# distributed under the License is distributed on an ""AS IS"" BASIS,+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+# See the License for the specific language governing permissions and+# limitations under the License.++import abc+import logging+import sys+from typing import Any, Generic, Optional, TypeVar++import grpc  # pytype: disable=pyi-error+from grpc._cython import cygrpc as _cygrpc++_LOGGER = logging.getLogger(__name__)++_channel = Any  # _channel.py imports this module.+PyCapsule = TypeVar('PyCapsule')+++class GrpcObservability(Generic[PyCapsule], metaclass=abc.ABCMeta):","Nit: No need to include the name ""Grpc"" in the class. We're already in the `grpc` package. How about we call this interface `ObservabilityPlugin`?",X
1644595,gnossen,https://api.github.com/repos/grpc/grpc/pulls/32974,1187975115,2023-05-08T23:08:09Z,src/python/grpcio/grpc/_observability.py,"@@ -0,0 +1,106 @@+# Copyright 2023 The gRPC authors.+#+# Licensed under the Apache License, Version 2.0 (the ""License"");+# you may not use this file except in compliance with the License.+# You may obtain a copy of the License at+#+#     http://www.apache.org/licenses/LICENSE-2.0+#+# Unless required by applicable law or agreed to in writing, software+# distributed under the License is distributed on an ""AS IS"" BASIS,+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+# See the License for the specific language governing permissions and+# limitations under the License.++import abc+import logging+import sys+from typing import Any, Generic, Optional, TypeVar++import grpc  # pytype: disable=pyi-error+from grpc._cython import cygrpc as _cygrpc++_LOGGER = logging.getLogger(__name__)++_channel = Any  # _channel.py imports this module.+PyCapsule = TypeVar('PyCapsule')+++class GrpcObservability(Generic[PyCapsule], metaclass=abc.ABCMeta):+    # we need to add hooks so that the GCP observability package can register functions with+    # the grpcio module and so can any other observability module conforming to the interface.+    _TRACING_ENABLED: bool = False+    _STATS_ENABLED: bool = False++    @abc.abstractmethod+    def create_client_call_tracer_capsule(self, method_name: bytes) -> PyCapsule:",Please add specific docstrings to each of the public methods as well as to the class. These are as much a part of the API as the type signature. There should be documentation about the contract for `PyCapsule` specific enough that someone has a reasonable chance of creating their own implementation.,
24593237,XuanWang-Amos,https://api.github.com/repos/grpc/grpc/pulls/32974,1189033428,2023-05-09T19:11:41Z,BUILD,"@@ -2231,6 +2231,28 @@ grpc_cc_library(     ], ) +grpc_cc_library(+    name = ""grpc_rpc_encoding"",+    srcs = [+        ""src/cpp/ext/filters/census/rpc_encoding.cc"",+    ],+    hdrs = [+        ""src/cpp/ext/filters/census/rpc_encoding.h"",+    ],+    external_deps = [+        ""absl/base"",+        ""absl/base:core_headers"",+        ""absl/meta:type_traits"",+        ""absl/status"",+        ""absl/strings"",+        ""absl/time"",+    ],+    language = ""c++"",+    tags = [""nofixdeps""],+    visibility = [""//visibility:public""],","We don't have that visibility, I'll change it to `@grpc:public` to be aligned with other similar targets.",
672669,sergiitk,https://api.github.com/repos/grpc/grpc/pulls/33040,1189201799,2023-05-09T22:55:09Z,tools/run_tests/xds_k8s_test_driver/framework/infrastructure/k8s.py,"@@ -573,3 +573,16 @@ def _replicas_available(cls, deployment: V1Deployment, count: int) -> bool:         return (isinstance(deployment, V1Deployment) and                 deployment.status.available_replicas is not None and                 deployment.status.available_replicas >= count)+++def get_pod_restarts(k8s_namespace: KubernetesNamespace,","Let's make it a part of the class, same as other methods. I know it's not perfect, but we should refactor the whole thing anyway. At least we'll be consistent in being imperfect.",X
672669,sergiitk,https://api.github.com/repos/grpc/grpc/pulls/33040,1189202828,2023-05-09T22:57:10Z,tools/run_tests/xds_k8s_test_driver/framework/xds_k8s_testcase.py,"@@ -494,6 +495,26 @@ def cleanup(self):         self.server_runner.cleanup(force=self.force_cleanup,                                    force_namespace=self.force_cleanup) +    def _check_pod_restart_time(self) -> None:+        # We should fail test if pod restarted during test (b/269192257).+        logger.info('Checking Pods restart times')+        client_restarts = k8s.get_pod_restarts(self.client_runner.k8s_namespace,+                                               self.client_runner.deployment)+        self.assertEqual(","We should not assert here, just get the data - so the cleanup can happen. After the cleanup, we should do the assertions, in a `finally` blocks.",
24593237,XuanWang-Amos,https://api.github.com/repos/grpc/grpc/pulls/33040,1189205395,2023-05-09T23:02:37Z,tools/run_tests/xds_k8s_test_driver/framework/infrastructure/k8s.py,"@@ -573,3 +573,16 @@ def _replicas_available(cls, deployment: V1Deployment, count: int) -> bool:         return (isinstance(deployment, V1Deployment) and                 deployment.status.available_replicas is not None and                 deployment.status.available_replicas >= count)+++def get_pod_restarts(k8s_namespace: KubernetesNamespace,","Originally I did put it into the class, but got some complains from sanity tests, let me try again.",
4181124,yashykt,https://api.github.com/repos/grpc/grpc/pulls/32852,1190480931,2023-05-10T23:45:58Z,src/core/BUILD,"@@ -5537,12 +5554,12 @@ grpc_cc_library(         ""slice"",         ""slice_buffer"",         ""time"",-        ""//:channel_stack_builder"",         ""//:config"",         ""//:gpr"",         ""//:gpr_platform"",         ""//:grpc_base"",         ""//:grpc_client_channel"",+        ""//:grpc_opencensus_plugin"",","So, the problem that needs solving is that there are two filters that don't need to know about each other, but a third component wants to impose an ordering between them.",
1644595,gnossen,https://api.github.com/repos/grpc/grpc/pulls/32974,1191539347,2023-05-11T18:18:47Z,BUILD,"@@ -2231,6 +2231,28 @@ grpc_cc_library(     ], ) +grpc_cc_library(+    name = ""grpc_rpc_encoding"",+    srcs = [+        ""src/cpp/ext/filters/census/rpc_encoding.cc"",+    ],+    hdrs = [+        ""src/cpp/ext/filters/census/rpc_encoding.h"",+    ],+    external_deps = [+        ""absl/base"",+        ""absl/base:core_headers"",+        ""absl/meta:type_traits"",+        ""absl/status"",+        ""absl/strings"",+        ""absl/time"",+    ],+    language = ""c++"",+    tags = [""nofixdeps""],+    visibility = [""//visibility:public""],","`@grpc:public` is still too broad. This needs to be for _internal_ use only. I didn't realize before that there's an issue here that this visibility needs to work across both google-internal and github. This will likely require making some changes to the `grpc_cc_library` macro definition.You'll need to add something like `@grpc:grpc_python_observability` which is included [here](https://github.com/grpc/grpc/blob/7b74b078854e8e683f5a441ab7e41c5c6388e1c0/bazel/grpc_build_system.bzl#L87) as well as the internal version of this file.The reason here is that if we leave this public then it is a signal to all Bazel users that this is a _public API_ and we would be on the hook to maintain it as such going forward, including writing gRFCs for all additions to it.",
1644595,gnossen,https://api.github.com/repos/grpc/grpc/pulls/32974,1191556632,2023-05-11T18:37:48Z,src/python/grpcio/grpc/_observability.py,"@@ -0,0 +1,106 @@+# Copyright 2023 The gRPC authors.+#+# Licensed under the Apache License, Version 2.0 (the ""License"");+# you may not use this file except in compliance with the License.+# You may obtain a copy of the License at+#+#     http://www.apache.org/licenses/LICENSE-2.0+#+# Unless required by applicable law or agreed to in writing, software+# distributed under the License is distributed on an ""AS IS"" BASIS,+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+# See the License for the specific language governing permissions and+# limitations under the License.++import abc+import logging+import sys+from typing import Any, Generic, Optional, TypeVar++import grpc  # pytype: disable=pyi-error+from grpc._cython import cygrpc as _cygrpc++_LOGGER = logging.getLogger(__name__)++_channel = Any  # _channel.py imports this module.+PyCapsule = TypeVar('PyCapsule')+++class GrpcObservability(Generic[PyCapsule], metaclass=abc.ABCMeta):+    # we need to add hooks so that the GCP observability package can register functions with+    # the grpcio module and so can any other observability module conforming to the interface.+    _TRACING_ENABLED: bool = False+    _STATS_ENABLED: bool = False++    @abc.abstractmethod+    def create_client_call_tracer_capsule(self, method_name: bytes) -> PyCapsule:+        raise NotImplementedError()++    @abc.abstractmethod+    def delete_client_call_tracer(+            self, client_call_tracer_capsule: PyCapsule) -> None:+        # delte client call tracer have to be called on o11y package side.+        # Call it for both segregated and integrated call (`_process_integrated_call_tag`)+        raise NotImplementedError()++    @abc.abstractmethod+    def save_trace_context(self, trace_id: str, span_id: str,+                           is_sampled: bool) -> None:+        raise NotImplementedError()++    @abc.abstractmethod+    def create_server_call_tracer_factory(self) -> PyCapsule:+        raise NotImplementedError()++    @abc.abstractmethod+    def record_rpc_latency(self, method: str, rpc_latency: float,+                           status_code: Any) -> None:+        raise NotImplementedError()++    def _enable_tracing(self, enable: bool) -> None:+        self._TRACING_ENABLED = enable++    def _enable_stats(self, enable: bool) -> None:+        self._STATS_ENABLED = enable++    def _tracing_enabled(self) -> bool:+        return self._TRACING_ENABLED++    def _stats_enabled(self) -> bool:+        return self._STATS_ENABLED++    def _observability_enabled(self) -> bool:+        return self._tracing_enabled() or self._stats_enabled()+++def _observability_init(grpc_observability: GrpcObservability) -> None:+    try:+        grpc._observability._grpc_observability_stub = grpc_observability+        _cygrpc.set_server_call_tracer_factory(grpc_observability)+    except Exception as e:  # pylint:disable=broad-except","If this is meant to handle arbitrary exceptions from the plugin, then leaving this as `except Exception` is fine. I previously thought that this was handling the `AttributeError`.",
1644595,gnossen,https://api.github.com/repos/grpc/grpc/pulls/32974,1191559386,2023-05-11T18:41:00Z,src/python/grpcio/grpc/_observability.py,"@@ -0,0 +1,117 @@+# Copyright 2023 The gRPC authors.+#+# Licensed under the Apache License, Version 2.0 (the ""License"");+# you may not use this file except in compliance with the License.+# You may obtain a copy of the License at+#+#     http://www.apache.org/licenses/LICENSE-2.0+#+# Unless required by applicable law or agreed to in writing, software+# distributed under the License is distributed on an ""AS IS"" BASIS,+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+# See the License for the specific language governing permissions and+# limitations under the License.++from __future__ import annotations++import abc+import logging+import threading+from typing import Any, Generic, Optional, TypeVar++from grpc._cython import cygrpc as _cygrpc++_LOGGER = logging.getLogger(__name__)++_channel = Any  # _channel.py imports this module.+ClientCallTracerCapsule = TypeVar('ClientCallTracerCapsule')+ServerCallTracerFactoryCapsule = TypeVar('ServerCallTracerFactoryCapsule')++_lock: threading.RLock = threading.RLock()+_grpc_observability_stub: Optional[ObservabilityPlugin] = None  # pylint: disable=used-before-assignment+++class ObservabilityPlugin(Generic[ClientCallTracerCapsule,+                                  ServerCallTracerFactoryCapsule],+                          metaclass=abc.ABCMeta):+    """"""+    Note: Any future methods added to this interface cannot have the @abc.abstractmethod annotation.+    """"""+    _tracing_enabled: bool = False+    _stats_enabled: bool = False++    @abc.abstractmethod+    def create_client_call_tracer(+            self, method_name: bytes) -> ClientCallTracerCapsule:+        raise NotImplementedError()++    @abc.abstractmethod+    def delete_client_call_tracer(+            self, client_call_tracer: ClientCallTracerCapsule) -> None:+        # delte client call tracer have to be called on o11y package side.+        # Call it for both segregated and integrated call (`_process_integrated_call_tag`)+        raise NotImplementedError()++    @abc.abstractmethod+    def save_trace_context(self, trace_id: str, span_id: str,+                           is_sampled: bool) -> None:+        raise NotImplementedError()++    @abc.abstractmethod+    def create_server_call_tracer_factory(+            self) -> ServerCallTracerFactoryCapsule:+        raise NotImplementedError()++    @abc.abstractmethod+    def record_rpc_latency(self, method: str, rpc_latency: float,+                           status_code: Any) -> None:+        raise NotImplementedError()++    def enable_tracing(self, enable: bool) -> None:+        self._tracing_enabled = enable++    def enable_stats(self, enable: bool) -> None:+        self._stats_enabled = enable++    @property+    def tracing_enabled(self) -> bool:+        return self._tracing_enabled++    @property+    def stats_enabled(self) -> bool:+        return self._stats_enabled++    @property+    def observability_enabled(self) -> bool:+        return self.tracing_enabled or self.stats_enabled+++def _observability_init(observability_plugin: ObservabilityPlugin) -> None:+    global _grpc_observability_stub  # pylint: disable=global-statement+    try:+        with _lock:+            _grpc_observability_stub = observability_plugin+        _cygrpc.set_server_call_tracer_factory(observability_plugin)+    # TODO(xuanwn): Change to specific exception+    except Exception as e:  # pylint:disable=broad-except+        _LOGGER.exception(""grpc.observability initialization failed with %s"", e)+++def delete_call_tracer(client_call_tracer_capsule: Any) -> None:+    global _grpc_observability_stub  # pylint: disable=global-statement+    if not (_grpc_observability_stub and","While technically this function implementation is thread-safe because we are only going to allow setting the value of `_grpc_observability_stub` once, if we ever add in de-initialization, this will become a race condition. We should hold the stub lock for the duration of this function call.",
1644595,gnossen,https://api.github.com/repos/grpc/grpc/pulls/32974,1191576403,2023-05-11T18:56:56Z,src/python/grpcio/grpc/_channel.py,"@@ -136,6 +141,9 @@ def __init__(self, due: Sequence[cygrpc.OperationType],         self.code = code         self.details = details         self.debug_error_string = None+        self.rpc_start_time = None",Please add a comment that updates to these three fields do not trigger a notification on `self.condition`.,
1644595,gnossen,https://api.github.com/repos/grpc/grpc/pulls/32974,1191592443,2023-05-11T19:14:54Z,src/python/grpcio/grpc/_cython/_cygrpc/channel.pyx.pxi,"@@ -230,6 +235,7 @@ cdef void _call(       grpc_slice_unref(method_slice)       if host_slice_ptr:         grpc_slice_unref(host_slice)+      maybe_set_client_call_tracer_on_call(call_state, method)",Nit: `maybe_set_client_call_tracer_on_call` is a function taking a `_CallState` as its first argument while `maybe_delete_call_tracer` is a method on `_CallState`. These two calls seem like they should be parallel to each other -- either both methods or both function calls.,
1644595,gnossen,https://api.github.com/repos/grpc/grpc/pulls/33000,1191610042,2023-05-11T19:35:13Z,src/python/grpcio_tests/tests/unit/_jina_hanging_test.py,"@@ -0,0 +1,69 @@+# Copyright 2023 gRPC authors.+#+# Licensed under the Apache License, Version 2.0 (the ""License"");+# you may not use this file except in compliance with the License.+# You may obtain a copy of the License at+#+#     http://www.apache.org/licenses/LICENSE-2.0+#+# Unless required by applicable law or agreed to in writing, software+# distributed under the License is distributed on an ""AS IS"" BASIS,+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+# See the License for the specific language governing permissions and+# limitations under the License.++import logging+import unittest+import multiprocessing+from concurrent import futures++import grpc++_REQUEST = b'\x00\x00\x00'+_RESPONSE = b'\x00\x00\x01'++_UNARY_UNARY = '/test/UnaryUnary'+++def _handle_unary_unary(unused_request, unused_servicer_context):+  return _RESPONSE++def run_server(port, event):+  handler = grpc.method_handlers_generic_handler('test', {+    'UnaryUnary':+      grpc.unary_unary_rpc_method_handler(_handle_unary_unary)+  })+  server = grpc.server(futures.ThreadPoolExecutor(max_workers=10), (handler,))+  bind_addr = f'0.0.0.0:{port}'+  server.add_insecure_port(bind_addr)+  server.start()+  event.set()+  server.wait_for_termination()++def run_client(port):+  addr = f'0.0.0.0:{port}'+  channel = grpc.insecure_channel(addr)+  multi_callable = channel.unary_unary(_UNARY_UNARY)+  multi_callable(_REQUEST)+  channel.close()+++class ReconnectTest(unittest.TestCase):","Since this issue turned out to be fork-related, I think it probably makes sense to rehome it and adapt it to [this test suite](https://github.com/grpc/grpc/blob/74d00f2c9c483bebcc4e347d3286fea20889ec9a/src/python/grpcio_tests/tests/fork/methods.py), where we have better multiprocess instrumentation for debugging if a regression ever does happen. I recognize that this would take a lot of effort and you have already gone above and beyond by submitting this low-level fix.As long as we can manually establish that without the implementation change, there was an X/1000 flake for the current test and with the implementation change, the failure rate is now 0/1000, I think we can merge just go ahead and merge the implementation change without the corresponding test. We'll take on the task of adapting the test for our CI's requirements as a follow-up PR.",
1644595,gnossen,https://api.github.com/repos/grpc/grpc/pulls/32974,1191626274,2023-05-11T19:53:16Z,src/python/grpcio/grpc/_cython/_cygrpc/observability.pyx.pxi,"@@ -0,0 +1,69 @@+# Copyright 2023 gRPC authors.+#+# Licensed under the Apache License, Version 2.0 (the ""License"");+# you may not use this file except in compliance with the License.+# You may obtain a copy of the License at+#+#     http://www.apache.org/licenses/LICENSE-2.0+#+# Unless required by applicable law or agreed to in writing, software+# distributed under the License is distributed on an ""AS IS"" BASIS,+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+# See the License for the specific language governing permissions and+# limitations under the License.+++import codecs+from typing import Optional++from libcpp.cast cimport static_cast++from grpc import _observability+++cdef const char* CLIENT_CALL_TRACER = ""gcp_opencensus_client_call_tracer""+cdef const char* SERVER_CALL_TRACER_FACTORY = ""gcp_opencensus_server_call_tracer_factory""+++def set_server_call_tracer_factory(object observability_plugin) -> None:+  capsule = observability_plugin.create_server_call_tracer_factory()+  capsule_ptr = cpython.PyCapsule_GetPointer(capsule, SERVER_CALL_TRACER_FACTORY)+  _register_server_call_tracer_factory(capsule_ptr)+++def maybe_save_server_trace_context(RequestCallEvent event) -> None:+  observability_plugin = _observability._grpc_observability_stub+  if not (observability_plugin and observability_plugin.tracing_enabled):+    return+  cdef ServerCallTracer* server_call_tracer+  server_call_tracer = static_cast['ServerCallTracer*'](_get_call_tracer(event.call.c_call))+  # TraceId and SpanId is hex string, need to convert to str+  trace_id = _decode(codecs.decode(server_call_tracer.TraceId(), 'hex_codec'))+  span_id = _decode(codecs.decode(server_call_tracer.SpanId(), 'hex_codec'))+  is_sampled = server_call_tracer.IsSampled()+  observability_plugin.save_trace_context(trace_id, span_id, is_sampled)+++cdef void maybe_set_client_call_tracer_on_call(_CallState call_state, bytes method_name) except *:+  observability_plugin = _observability._grpc_observability_stub","It's not a great idea to access global mutable state from a different module. The `_private_module._private_variable` here is a [code smell](https://en.wikipedia.org/wiki/Code_smell).  Invariants relating to that state then start leaking across files. For example, here, we really need to be using the lock corresponding to `_grpc_observability_stub`, but that is not obvious from line 48. In general, when accessing global mutable state from a different module, you should create an interface for accessing/mutating that state. In this case, the main invariant we need to wrap up is the usage of locking. We can abstract that away by requiring that external modules acquiring the plugin do so using a context manager. That would transform this function implementation to something like this:```pythoncdef void maybe_set_client_call_tracer_on_call(_CallState call_state, bytes method_name) except *:  observability_plugin = _observability._grpc_observability_stub  with _observability.get_plugin() as plugin:    if not (plugin and plugin.observability_enabled):      return    capsule = plugin.create_client_call_tracer(method_name)    capsule_ptr = cpython.PyCapsule_GetPointer(capsule, CLIENT_CALL_TRACER)    _set_call_tracer(call_state.c_call, capsule_ptr)    call_state.call_tracer_capsule = capsule```Where the implementation of `get_plugin()` ensures that the lock is held while `plugin` is available for use by the calling code.",X
1644595,gnossen,https://api.github.com/repos/grpc/grpc/pulls/32974,1191754912,2023-05-11T22:42:44Z,src/python/grpcio_tests/tests/observability/_observability_test.py,"@@ -0,0 +1,353 @@+# Copyright 2023 gRPC authors.+#+# Licensed under the Apache License, Version 2.0 (the ""License"");+# you may not use this file except in compliance with the License.+# You may obtain a copy of the License at+#+#     http://www.apache.org/licenses/LICENSE-2.0+#+# Unless required by applicable law or agreed to in writing, software+# distributed under the License is distributed on an ""AS IS"" BASIS,+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+# See the License for the specific language governing permissions and+# limitations under the License.++from concurrent import futures+import logging+import os+from typing import List+import unittest++import grpc+import grpc_observability++logger = logging.getLogger(__name__)++_REQUEST = b'\x00\x00\x00'+_RESPONSE = b'\x00\x00\x00'++_UNARY_UNARY = '/test/UnaryUnary'+_UNARY_STREAM = '/test/UnaryStream'+_STREAM_UNARY = '/test/StreamUnary'+_STREAM_STREAM = '/test/StreamStream'+STREAM_LENGTH = 5++_VALID_CONFIG_TRACING_STATS = """"""+{+    ""project_id"":""test-project"",+    ""cloud_trace"":{+       ""sampling_rate"":1.00+    },+    ""cloud_monitoring"":{},+}+""""""++# Depends on grpc_core::IsTransportSuppliesClientLatencyEnabled,+# the following metrcis might not exist.+_SKIP_VEFIRY = [grpc_observability.MetricsName.CLIENT_TRANSPORT_LATENCY]+_SPAN_PREFIXS = ['Recv', 'Sent', 'Attempt']+++class TestExporter(grpc_observability.Exporter):++    def __init__(self, metrics: List[grpc_observability.StatsData],+                 spans: List[grpc_observability.TracingData]):+        self.span_collecter = spans+        self.metric_collecter = metrics+        self._server = None++    def export_stats_data(+            self, stats_data: List[grpc_observability.StatsData]) -> None:+        self.metric_collecter.extend(stats_data)++    def export_tracing_data(+            self, tracing_data: List[grpc_observability.TracingData]) -> None:+        self.span_collecter.extend(tracing_data)+++def handle_unary_unary(request, servicer_context):+    return _RESPONSE+++def handle_unary_stream(request, servicer_context):+    for _ in range(STREAM_LENGTH):+        yield _RESPONSE+++def handle_stream_unary(request_iterator, servicer_context):+    return _RESPONSE+++def handle_stream_stream(request_iterator, servicer_context):+    for request in request_iterator:+        yield _RESPONSE+++class _MethodHandler(grpc.RpcMethodHandler):++    def __init__(self, request_streaming, response_streaming):+        self.request_streaming = request_streaming+        self.response_streaming = response_streaming+        self.request_deserializer = None+        self.response_serializer = None+        self.unary_unary = None+        self.unary_stream = None+        self.stream_unary = None+        self.stream_stream = None+        if self.request_streaming and self.response_streaming:+            self.stream_stream = lambda x, y: handle_stream_stream(x, y)+        elif self.request_streaming:+            self.stream_unary = lambda x, y: handle_stream_unary(x, y)+        elif self.response_streaming:+            self.unary_stream = lambda x, y: handle_unary_stream(x, y)+        else:+            self.unary_unary = lambda x, y: handle_unary_unary(x, y)+++class _GenericHandler(grpc.GenericRpcHandler):++    def service(self, handler_call_details):+        if handler_call_details.method == _UNARY_UNARY:+            return _MethodHandler(False, False)+        elif handler_call_details.method == _UNARY_STREAM:+            return _MethodHandler(False, True)+        elif handler_call_details.method == _STREAM_UNARY:+            return _MethodHandler(True, False)+        elif handler_call_details.method == _STREAM_STREAM:+            return _MethodHandler(True, True)+        else:+            return None+++class ObservabilityTest(unittest.TestCase):++    def setUp(self):+        self.all_metric = []+        self.all_span = []+        self.test_exporter = TestExporter(self.all_metric, self.all_span)++    def tearDown(self):+        os.environ['GRPC_GCP_OBSERVABILITY_CONFIG'] = ''++    def testRecordUnaryUnary(self):+        os.environ[+            'GRPC_GCP_OBSERVABILITY_CONFIG'] = _VALID_CONFIG_TRACING_STATS+        with grpc_observability.GCPOpenCensusObservability() as o11y:+            o11y.init(exporter=self.test_exporter)++            port = self._start_server()+            self.unary_unary_call(port)++        self.assertTrue(len(self.all_metric) > 0)","Nit: [`self.assertGreater`](https://docs.python.org/3/library/unittest.html#unittest.TestCase.assertGreater). Generally speaking, there's almost always a more specific assertion than `assertTrue`.",
1644595,gnossen,https://api.github.com/repos/grpc/grpc/pulls/32974,1191773931,2023-05-11T23:24:49Z,src/python/grpcio/grpc/_observability.py,"@@ -0,0 +1,117 @@+# Copyright 2023 The gRPC authors.+#+# Licensed under the Apache License, Version 2.0 (the ""License"");+# you may not use this file except in compliance with the License.+# You may obtain a copy of the License at+#+#     http://www.apache.org/licenses/LICENSE-2.0+#+# Unless required by applicable law or agreed to in writing, software+# distributed under the License is distributed on an ""AS IS"" BASIS,+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+# See the License for the specific language governing permissions and+# limitations under the License.++from __future__ import annotations++import abc+import logging+import threading+from typing import Any, Generic, Optional, TypeVar++from grpc._cython import cygrpc as _cygrpc++_LOGGER = logging.getLogger(__name__)++_channel = Any  # _channel.py imports this module.+ClientCallTracerCapsule = TypeVar('ClientCallTracerCapsule')+ServerCallTracerFactoryCapsule = TypeVar('ServerCallTracerFactoryCapsule')++_lock: threading.RLock = threading.RLock()+_grpc_observability_stub: Optional[ObservabilityPlugin] = None  # pylint: disable=used-before-assignment+++class ObservabilityPlugin(Generic[ClientCallTracerCapsule,+                                  ServerCallTracerFactoryCapsule],+                          metaclass=abc.ABCMeta):+    """"""+    Note: Any future methods added to this interface cannot have the @abc.abstractmethod annotation.+    """"""+    _tracing_enabled: bool = False+    _stats_enabled: bool = False++    @abc.abstractmethod+    def create_client_call_tracer(+            self, method_name: bytes) -> ClientCallTracerCapsule:+        raise NotImplementedError()++    @abc.abstractmethod+    def delete_client_call_tracer(+            self, client_call_tracer: ClientCallTracerCapsule) -> None:+        # delte client call tracer have to be called on o11y package side.+        # Call it for both segregated and integrated call (`_process_integrated_call_tag`)+        raise NotImplementedError()++    @abc.abstractmethod+    def save_trace_context(self, trace_id: str, span_id: str,+                           is_sampled: bool) -> None:+        raise NotImplementedError()++    @abc.abstractmethod+    def create_server_call_tracer_factory(+            self) -> ServerCallTracerFactoryCapsule:+        raise NotImplementedError()++    @abc.abstractmethod+    def record_rpc_latency(self, method: str, rpc_latency: float,+                           status_code: Any) -> None:+        raise NotImplementedError()++    def enable_tracing(self, enable: bool) -> None:","The name `enable_tracing` implies that this unconditionally enables tracing and therefore takes no arguments. Instead, this should probably be named `set_tracing`. Same for `enable_stats` below.",
1644595,gnossen,https://api.github.com/repos/grpc/grpc/pulls/32974,1191777967,2023-05-11T23:34:56Z,src/python/grpcio_observability/grpc_observability/BUILD.bazel,"@@ -0,0 +1,73 @@+# Copyright 2023 gRPC authors.+#+# Licensed under the Apache License, Version 2.0 (the ""License"");+# you may not use this file except in compliance with the License.+# You may obtain a copy of the License at+#+#     http://www.apache.org/licenses/LICENSE-2.0+#+# Unless required by applicable law or agreed to in writing, software+# distributed under the License is distributed on an ""AS IS"" BASIS,+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+# See the License for the specific language governing permissions and+# limitations under the License.++load(""//bazel:cython_library.bzl"", ""pyx_library"")++package(default_visibility = [""//visibility:public""])++cc_library(+    name = ""observability"",+    srcs = [+        ""client_call_tracer.cc"",+        ""observability_main.cc"",+        ""python_census_context.cc"",+        ""sampler.cc"",+        ""server_call_tracer.cc"",+    ],+    hdrs = [+        ""client_call_tracer.h"",+        ""constants.h"",+        ""observability_main.h"",+        ""python_census_context.h"",+        ""sampler.h"",+        ""server_call_tracer.h"",+    ],+    includes = ["".""],+    deps = [+        ""//:grpc"",","When we get to the setuptools build, we're going to need to be very careful to ensure that the build only includes the code that is actually referenced from our o11y module otherwise the shared object library is going to be huge.",
672669,sergiitk,https://api.github.com/repos/grpc/grpc/pulls/33040,1191883601,2023-05-12T04:03:56Z,tools/run_tests/xds_k8s_test_driver/framework/xds_k8s_testcase.py,"@@ -480,20 +482,37 @@ def initKubernetesClientRunner(self) -> KubernetesClientRunner:      def tearDown(self):         logger.info('----- TestMethod %s teardown -----', self.id())+        # Todo(xuanwn): Add same check to XdsUrlMapTestCase.",Note: I recently made a [PR](https://github.com/grpc/grpc/pull/33090) that adds retry logic to the  `XdsUrlMapTestCase` similar to what's happening here. Don't forget to sync when my PR is merged before adding this check to the URL Map.,
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/33095,1192626220,2023-05-12T17:20:21Z,test/core/end2end/end2end_test_corpus/seed_18.textproto,"@@ -1,3 +1,6 @@ suite: ""CoreClientChannelTest"" test: ""SubchannelFilterCallInitFails"" config: ""Chttp2FakeSecurityFullstack""+config_vars {","yeah.... it's seed data for the fuzzer.... the generator picks up the current experiment list and puts them in **somewhere**... doesn't really matter where, more that the mutation engine gets to see that there's an experiment around.",
24593237,XuanWang-Amos,https://api.github.com/repos/grpc/grpc/pulls/32974,1192728540,2023-05-12T19:26:55Z,src/python/grpcio/grpc/_cython/_cygrpc/channel.pyx.pxi,"@@ -230,6 +235,7 @@ cdef void _call(       grpc_slice_unref(method_slice)       if host_slice_ptr:         grpc_slice_unref(host_slice)+      maybe_set_client_call_tracer_on_call(call_state, method)","Right, since `call_tracer_capsule` belongs to `_CallState` now, I'll change them both to `_CallState` methods.",
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/32847,1192762548,2023-05-12T20:18:31Z,src/core/lib/iomgr/vsock.h,"@@ -0,0 +1,40 @@+//+//+// Copyright 2021 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+//+//++#ifndef GRPC_SRC_CORE_LIB_IOMGR_VSOCK_H+#define GRPC_SRC_CORE_LIB_IOMGR_VSOCK_H++#include <grpc/support/port_platform.h>++#include <string>++#include ""absl/strings/string_view.h""++#include <grpc/support/string_util.h>++#include ""src/core/lib/iomgr/port.h""+#include ""src/core/lib/iomgr/resolve_address.h""++void grpc_create_socketpair_if_vsock(int sv[2]);","There is an added hiccup here: gRPC supports CentOS 7, which distributes linux kernel v3.10. I don't think this PR will build on CentOS 7 right now. `GRPC_HAVE_VSOCK` will have to be defined more carefully: only if we can detect that the current platform supports it. See https://opensource.google/documentation/policies/cplusplus-supportThe path to testing this may be a bit messy. It would require an entirely new job to be set up similar to the test configs in `tools/internal_ci/linux/*`, with some corresponding internal Google changes to make the test run (that last bit is not hard). It's possible for you to do, but it would be some extra work to grok the system. Also, the current `socketpair` implementation in this PR won't work, per https://github.com/torvalds/linux/blob/47a2ee5d4a0bda05decdda7be0a77e792cdb09a3/net/vmw_vsock/af_vsock.c#L2225, so something like VSOCK-local would have to be used to mimic a socket pair, so the end2end tests can run. See here for an example of the end2end test fixture for other socketpairs https://github.com/grpc/grpc/blob/0d678a9551608215c95f755b3562e90589a4fc3e/test/core/end2end/end2end_test_suites.cc#L729-L755If the fixes can be made to get this to build cleanly on CentOS 7, I'd be in support of documenting this everywhere as community-supported and leave it mostly untested. That does mean that if it breaks (and we won't know it when it happens), the community would need to repair it, or the functionality would likely be removed.",
24593237,XuanWang-Amos,https://api.github.com/repos/grpc/grpc/pulls/32974,1192827930,2023-05-12T22:07:24Z,src/python/grpcio_observability/grpc_observability/_observability.py,"@@ -0,0 +1,179 @@+# Copyright 2023 gRPC authors.+#+# Licensed under the Apache License, Version 2.0 (the ""License"");+# you may not use this file except in compliance with the License.+# You may obtain a copy of the License at+#+#     http://www.apache.org/licenses/LICENSE-2.0+#+# Unless required by applicable law or agreed to in writing, software+# distributed under the License is distributed on an ""AS IS"" BASIS,+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+# See the License for the specific language governing permissions and+# limitations under the License.++from dataclasses import dataclass+from dataclasses import field+import logging+import threading+import time+from typing import Any, Mapping, Optional++import grpc+from grpc_observability import _cyobservability  # pytype: disable=pyi-error+from opencensus.trace import execution_context+from opencensus.trace import span_context as span_context_module+from opencensus.trace import trace_options as trace_options_module++_LOGGER = logging.getLogger(__name__)++ClientCallTracerCapsule = Any  # it appears only once in the function signature+ServerCallTracerFactoryCapsule = Any  # it appears only once in the function signature+grpc_observability = Any  # grpc_observability.py imports this module.++GRPC_STATUS_CODE_TO_STRING = {+    grpc.StatusCode.OK: ""OK"",+    grpc.StatusCode.CANCELLED: ""CANCELLED"",+    grpc.StatusCode.UNKNOWN: ""UNKNOWN"",+    grpc.StatusCode.INVALID_ARGUMENT: ""INVALID_ARGUMENT"",+    grpc.StatusCode.DEADLINE_EXCEEDED: ""DEADLINE_EXCEEDED"",+    grpc.StatusCode.NOT_FOUND: ""NOT_FOUND"",+    grpc.StatusCode.ALREADY_EXISTS: ""ALREADY_EXISTS"",+    grpc.StatusCode.PERMISSION_DENIED: ""PERMISSION_DENIED"",+    grpc.StatusCode.UNAUTHENTICATED: ""UNAUTHENTICATED"",+    grpc.StatusCode.RESOURCE_EXHAUSTED: ""RESOURCE_EXHAUSTED"",+    grpc.StatusCode.FAILED_PRECONDITION: ""FAILED_PRECONDITION"",+    grpc.StatusCode.ABORTED: ""ABORTED"",+    grpc.StatusCode.OUT_OF_RANGE: ""OUT_OF_RANGE"",+    grpc.StatusCode.UNIMPLEMENTED: ""UNIMPLEMENTED"",+    grpc.StatusCode.INTERNAL: ""INTERNAL"",+    grpc.StatusCode.UNAVAILABLE: ""UNAVAILABLE"",+    grpc.StatusCode.DATA_LOSS: ""DATA_LOSS"",+}+++@dataclass+class GcpObservabilityPythonConfig:+    _singleton = None+    _lock: threading.RLock = threading.RLock()+    project_id: str = """"+    stats_enabled: bool = False+    tracing_enabled: bool = False+    labels: Optional[Mapping[str, str]] = field(default_factory=dict)+    sampling_rate: Optional[float] = 0.0++    @staticmethod+    def get():+        with GcpObservabilityPythonConfig._lock:+            if GcpObservabilityPythonConfig._singleton is None:+                GcpObservabilityPythonConfig._singleton = GcpObservabilityPythonConfig(+                )+        return GcpObservabilityPythonConfig._singleton++    def set_configuration(self,+                          project_id: str,+                          sampling_rate: Optional[float] = 0.0,+                          labels: Optional[Mapping[str, str]] = None,+                          tracing_enabled: bool = False,+                          stats_enabled: bool = False) -> None:+        self.project_id = project_id+        self.stats_enabled = stats_enabled+        self.tracing_enabled = tracing_enabled+        self.labels = labels+        self.sampling_rate = sampling_rate+++# pylint: disable=no-self-use+class GCPOpenCensusObservability(grpc.ObservabilityPlugin):+    config: GcpObservabilityPythonConfig+    exporter: ""grpc_observability.Exporter""++    def __init__(self):+        # 1. Read config.+        self.exporter = None+        self.config = GcpObservabilityPythonConfig.get()+        config_valid = _cyobservability.set_gcp_observability_config(+            self.config)+        if not config_valid:+            raise ValueError(""Invalid configuration"")++        if self.config.tracing_enabled:+            self.enable_tracing(True)+        if self.config.stats_enabled:+            self.enable_stats(True)++    def init(self, exporter: ""grpc_observability.Exporter"" = None) -> None:+        if exporter:+            self.exporter = exporter+        else:+            # 2. Creating measures and register views.+            # 3. Create and Saves Tracer and Sampler to ContextVar.+            pass  # Actual implementation of OC exporter+            # open_census = importlib.import_module(+            #     ""grpc_observability._open_census"")+            # self.exporter = open_census.OpenCensusExporter(+            #     self.config.get().labels)++        # 4. Start exporting thread.+        try:+            _cyobservability.cyobservability_init(self.exporter)+        #TODO(xuanwn): Use specific exceptons+        except Exception as e:  # pylint: disable=broad-except+            _LOGGER.exception(""grpc_observability init failed with: %s"", e)++        # 5. Init grpc.+        # 5.1 Refister grpc_observability+        # 5.2 set_server_call_tracer_factory+        grpc._observability_init(self)++    def exit(self) -> None:+        # Sleep for 0.5s so all data can be flushed.+        time.sleep(0.5)",This is the time we wait for next batch in `AwaitNextBatchLocked`. And C++ is [doing similar things too](http://shortn/_huZUevSe7d). We might need change this interval to a more appropriate number later (already added TODO).,
7221003,rockspore,https://api.github.com/repos/grpc/grpc/pulls/33026,1192828369,2023-05-12T22:08:29Z,src/core/lib/security/authorization/stdout_logger.cc,"@@ -0,0 +1,75 @@+// Copyright 2023 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++#include <grpc/support/port_platform.h>++#include ""src/core/lib/security/authorization/stdout_logger.h""++#include <cstdio>+#include <initializer_list>+#include <memory>+#include <string>++#include ""absl/status/status.h""+#include ""absl/status/statusor.h""+#include ""absl/strings/str_format.h""+#include ""absl/strings/string_view.h""+#include ""absl/time/clock.h""+#include ""absl/time/time.h""++#include <grpc/grpc_audit_logging.h>+#include <grpc/support/json.h>+#include <grpc/support/log.h>++namespace grpc_core {+namespace experimental {++constexpr absl::string_view kName = ""stdout_logger"";+constexpr char kLogFormat[] =+    ""{\""grpc_audit_log\"":{\""timestamp\"":%d,\""rpc_method\"":\""%s\"",\""principal\"":""+    ""\""%s\"",\""policy_name\"":\""%s\"",\""matched_rule\"":\""%s\"",\""authorized\"":%s}}""+    ""\n"";++void StdoutAuditLogger::Log(const AuditContext& context) {+  absl::FPrintF(stdout, kLogFormat, absl::ToUnixSeconds(absl::Now()),+                context.rpc_method(), context.principal(),+                context.policy_name(), context.matched_rule(),+                context.authorized() ? ""true"" : ""false"");+}++absl::string_view StdoutAuditLoggerFactory::Config::name() const {+  return kName;+}++std::string StdoutAuditLoggerFactory::Config::ToString() const { return ""{}""; }++absl::string_view StdoutAuditLoggerFactory::name() const { return kName; }++absl::StatusOr<std::unique_ptr<AuditLoggerFactory::Config>>+StdoutAuditLoggerFactory::ParseAuditLoggerConfig(const Json& json) {+  if (json.type() != Json::Type::kObject) {","It is already enforced (https://github.com/grpc/grpc/blob/ee0cf2fada30dc40ac56f41d69e01fac031ea1ee/src/core/lib/security/authorization/rbac_translator.cc#L402). Likewise, we ensure the proto from xDS gets converted appropriately. In this case, I've removed this check here as well as the unit test for it.",
24593237,XuanWang-Amos,https://api.github.com/repos/grpc/grpc/pulls/33040,1192831012,2023-05-12T22:14:56Z,tools/run_tests/xds_k8s_test_driver/framework/test_app/runners/k8s/k8s_xds_server_runner.py,"@@ -228,6 +228,17 @@ def _xds_test_server_for_pod(self,                              secure_mode=secure_mode,                              rpc_host=rpc_host) +    def get_pod_restarts(self) -> int:","It's the same with client runner, but `KubernetesBaseRunner` don't have `deployment`, I'll move it to base runner and make `deployment` as a parameter then.",
1644595,gnossen,https://api.github.com/repos/grpc/grpc/pulls/32974,1192863219,2023-05-12T23:27:42Z,src/python/grpcio_observability/grpc_observability/_observability.py,"@@ -0,0 +1,179 @@+# Copyright 2023 gRPC authors.+#+# Licensed under the Apache License, Version 2.0 (the ""License"");+# you may not use this file except in compliance with the License.+# You may obtain a copy of the License at+#+#     http://www.apache.org/licenses/LICENSE-2.0+#+# Unless required by applicable law or agreed to in writing, software+# distributed under the License is distributed on an ""AS IS"" BASIS,+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+# See the License for the specific language governing permissions and+# limitations under the License.++from dataclasses import dataclass+from dataclasses import field+import logging+import threading+import time+from typing import Any, Mapping, Optional++import grpc+from grpc_observability import _cyobservability  # pytype: disable=pyi-error+from opencensus.trace import execution_context+from opencensus.trace import span_context as span_context_module+from opencensus.trace import trace_options as trace_options_module++_LOGGER = logging.getLogger(__name__)++ClientCallTracerCapsule = Any  # it appears only once in the function signature+ServerCallTracerFactoryCapsule = Any  # it appears only once in the function signature+grpc_observability = Any  # grpc_observability.py imports this module.++GRPC_STATUS_CODE_TO_STRING = {+    grpc.StatusCode.OK: ""OK"",+    grpc.StatusCode.CANCELLED: ""CANCELLED"",+    grpc.StatusCode.UNKNOWN: ""UNKNOWN"",+    grpc.StatusCode.INVALID_ARGUMENT: ""INVALID_ARGUMENT"",+    grpc.StatusCode.DEADLINE_EXCEEDED: ""DEADLINE_EXCEEDED"",+    grpc.StatusCode.NOT_FOUND: ""NOT_FOUND"",+    grpc.StatusCode.ALREADY_EXISTS: ""ALREADY_EXISTS"",+    grpc.StatusCode.PERMISSION_DENIED: ""PERMISSION_DENIED"",+    grpc.StatusCode.UNAUTHENTICATED: ""UNAUTHENTICATED"",+    grpc.StatusCode.RESOURCE_EXHAUSTED: ""RESOURCE_EXHAUSTED"",+    grpc.StatusCode.FAILED_PRECONDITION: ""FAILED_PRECONDITION"",+    grpc.StatusCode.ABORTED: ""ABORTED"",+    grpc.StatusCode.OUT_OF_RANGE: ""OUT_OF_RANGE"",+    grpc.StatusCode.UNIMPLEMENTED: ""UNIMPLEMENTED"",+    grpc.StatusCode.INTERNAL: ""INTERNAL"",+    grpc.StatusCode.UNAVAILABLE: ""UNAVAILABLE"",+    grpc.StatusCode.DATA_LOSS: ""DATA_LOSS"",+}+++@dataclass+class GcpObservabilityPythonConfig:+    _singleton = None+    _lock: threading.RLock = threading.RLock()+    project_id: str = """"+    stats_enabled: bool = False+    tracing_enabled: bool = False+    labels: Optional[Mapping[str, str]] = field(default_factory=dict)+    sampling_rate: Optional[float] = 0.0++    @staticmethod+    def get():+        with GcpObservabilityPythonConfig._lock:+            if GcpObservabilityPythonConfig._singleton is None:+                GcpObservabilityPythonConfig._singleton = GcpObservabilityPythonConfig(+                )+        return GcpObservabilityPythonConfig._singleton++    def set_configuration(self,+                          project_id: str,+                          sampling_rate: Optional[float] = 0.0,+                          labels: Optional[Mapping[str, str]] = None,+                          tracing_enabled: bool = False,+                          stats_enabled: bool = False) -> None:+        self.project_id = project_id+        self.stats_enabled = stats_enabled+        self.tracing_enabled = tracing_enabled+        self.labels = labels+        self.sampling_rate = sampling_rate+++# pylint: disable=no-self-use+class GCPOpenCensusObservability(grpc.ObservabilityPlugin):+    config: GcpObservabilityPythonConfig+    exporter: ""grpc_observability.Exporter""++    def __init__(self):+        # 1. Read config.+        self.exporter = None+        self.config = GcpObservabilityPythonConfig.get()+        config_valid = _cyobservability.set_gcp_observability_config(+            self.config)+        if not config_valid:+            raise ValueError(""Invalid configuration"")++        if self.config.tracing_enabled:+            self.enable_tracing(True)+        if self.config.stats_enabled:+            self.enable_stats(True)++    def init(self, exporter: ""grpc_observability.Exporter"" = None) -> None:+        if exporter:+            self.exporter = exporter+        else:+            # 2. Creating measures and register views.+            # 3. Create and Saves Tracer and Sampler to ContextVar.+            pass  # Actual implementation of OC exporter+            # open_census = importlib.import_module(+            #     ""grpc_observability._open_census"")+            # self.exporter = open_census.OpenCensusExporter(+            #     self.config.get().labels)++        # 4. Start exporting thread.+        try:+            _cyobservability.cyobservability_init(self.exporter)+        #TODO(xuanwn): Use specific exceptons+        except Exception as e:  # pylint: disable=broad-except+            _LOGGER.exception(""grpc_observability init failed with: %s"", e)++        # 5. Init grpc.+        # 5.1 Refister grpc_observability+        # 5.2 set_server_call_tracer_factory+        grpc._observability_init(self)++    def exit(self) -> None:+        # Sleep for 0.5s so all data can be flushed.+        time.sleep(0.5)","If these two constants need to agree, then they should be pulled from a common constant so that we can't accidentally change one value but not the other.This method isn't fool-proof. A sleep guarantees that a thread will take _at least_ that long, not exactly that long. If the thread running `AwaitNextBatchLocked` gets swapped out for some reason, then it's totally possible for the `exit` call to complete before `AwaitNextBatchLocked` finishes. The question is how big an issue that would be.@yashykt Do you have any thoughts on this?",
1644595,gnossen,https://api.github.com/repos/grpc/grpc/pulls/32974,1192868413,2023-05-12T23:40:43Z,src/python/grpcio_observability/grpc_observability/observability_util.cc,"@@ -0,0 +1,189 @@+// Copyright 2023 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++#include ""src/python/grpcio_observability/grpc_observability/observability_util.h""+#include ""src/python/grpcio_observability/grpc_observability/server_call_tracer.h""+#include ""src/python/grpcio_observability/grpc_observability/client_call_tracer.h""++#include ""absl/strings/string_view.h""++namespace grpc_observability {++std::queue<CensusData>* kCensusDataBuffer;","[The `k` prefix indicates that this is a constant](https://google.github.io/styleguide/cppguide.html#Constant_Names), which it is not (otherwise, the `const` keyword would show up somewhere). I think you want a [`g` prefix to indicate that it is a global](https://github.com/grpc/grpc/blob/eecc8978b653f426eebda3d2a40871302108ebeb/src/core/ext/transport/chttp2/transport/chttp2_transport.cc#L122). Also, [variable names in our version of C++ are generally in `snake_case`](https://google.github.io/styleguide/cppguide.html#Variable_Names). So, for example, this variable should be named `g_census_data_buffer`. Same for the accompanying mutex and condition variable.I know these rules probably seem gratuitous, but they make the job of future readers of the code much easier. We don't have to pay much attention to variables that start with `k` (because they never change), but variables starting with `g` are suspicious because they can change over time and are often the root causes of bugs.",X
24593237,XuanWang-Amos,https://api.github.com/repos/grpc/grpc/pulls/32974,1194108448,2023-05-15T16:59:15Z,src/python/grpcio_observability/grpc_observability/_cyobservability.pyx,"@@ -0,0 +1,249 @@+# Copyright 2023 gRPC authors.+#+# Licensed under the Apache License, Version 2.0 (the ""License"");+# you may not use this file except in compliance with the License.+# You may obtain a copy of the License at+#+#     http://www.apache.org/licenses/LICENSE-2.0+#+# Unless required by applicable law or agreed to in writing, software+# distributed under the License is distributed on an ""AS IS"" BASIS,+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+# See the License for the specific language governing permissions and+# limitations under the License.++cimport cpython+from cython.operator cimport dereference++import logging+from threading import Thread+from typing import List, Mapping, Tuple++import grpc_observability+++cdef const char* CLIENT_CALL_TRACER = ""client_call_tracer""+cdef const char* SERVER_CALL_TRACER_FACTORY = ""server_call_tracer_factory""+cdef bint GLOBAL_SHUTDOWN_EXPORT_THREAD = False+cdef object global_export_thread++_LOGGER = logging.getLogger(__name__)+++class MetricsName:+  CLIENT_API_LATENCY = kRpcClientApiLatencyMeasureName+  CLIENT_SNET_MESSSAGES_PER_RPC = kRpcClientSentMessagesPerRpcMeasureName+  CLIENT_SEND_BYTES_PER_RPC = kRpcClientSentBytesPerRpcMeasureName+  CLIENT_RECEIVED_MESSAGES_PER_RPC = kRpcClientReceivedMessagesPerRpcMeasureName+  CLIENT_RECEIVED_BYTES_PER_RPC = kRpcClientReceivedBytesPerRpcMeasureName+  CLIENT_ROUNDTRIP_LATENCY = kRpcClientRoundtripLatencyMeasureName+  CLIENT_SERVER_LATENCY = kRpcClientServerLatencyMeasureName+  CLIENT_STARTED_RPCS = kRpcClientStartedRpcsMeasureName+  CLIENT_RETRIES_PER_CALL = kRpcClientRetriesPerCallMeasureName+  CLIENT_TRANSPARENT_RETRIES_PER_CALL = kRpcClientTransparentRetriesPerCallMeasureName+  CLIENT_RETRY_DELAY_PER_CALL = kRpcClientRetryDelayPerCallMeasureName+  CLIENT_TRANSPORT_LATENCY = kRpcClientTransportLatencyMeasureName+  SERVER_SENT_MESSAGES_PER_RPC = kRpcServerSentMessagesPerRpcMeasureName+  SERVER_SENT_BYTES_PER_RPC = kRpcServerSentBytesPerRpcMeasureName+  SERVER_RECEIVED_MESSAGES_PER_RPC = kRpcServerReceivedMessagesPerRpcMeasureName+  SERVER_RECEIVED_BYTES_PER_RPC = kRpcServerReceivedBytesPerRpcMeasureName+  SERVER_SERVER_LATENCY = kRpcServerServerLatencyMeasureName+  SERVER_STARTED_RPCS = kRpcServerStartedRpcsMeasureName++# Delay map creation due to circular dependencies+_CY_METRICS_NAME_TO_PY_METRICS_NAME_MAPPING = {}++def cyobservability_init(object exporter) -> None:+  global _CY_METRICS_NAME_TO_PY_METRICS_NAME_MAPPING+  _CY_METRICS_NAME_TO_PY_METRICS_NAME_MAPPING = {x.value: x for x in grpc_observability.MetricsName}","That's what's I did at first, but we'll have an circular import issue: This map needs `grpc_observability.MetricsName` and `grpc_observability.MetricsName`  requires `Cython.MetricsName`.I moved `grpc_observability.MetricsName` to Cython file so we don't have circular import anymore, but the downside is `MetricsName` which should be a public class is now imported from a Cython file.",X
24593237,XuanWang-Amos,https://api.github.com/repos/grpc/grpc/pulls/32974,1194123256,2023-05-15T17:10:25Z,src/python/grpcio_observability/grpc_observability/observability_util.cc,"@@ -0,0 +1,189 @@+// Copyright 2023 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++#include ""src/python/grpcio_observability/grpc_observability/observability_util.h""+#include ""src/python/grpcio_observability/grpc_observability/server_call_tracer.h""+#include ""src/python/grpcio_observability/grpc_observability/client_call_tracer.h""++#include ""absl/strings/string_view.h""++namespace grpc_observability {++std::queue<CensusData>* kCensusDataBuffer;","Agree that we should follow naming conventions, and I'm trying to do so across all of the files. I must've missed those while checking...",
1644595,gnossen,https://api.github.com/repos/grpc/grpc/pulls/32974,1194127315,2023-05-15T17:13:47Z,src/python/grpcio_observability/grpc_observability/_cyobservability.pyx,"@@ -0,0 +1,249 @@+# Copyright 2023 gRPC authors.+#+# Licensed under the Apache License, Version 2.0 (the ""License"");+# you may not use this file except in compliance with the License.+# You may obtain a copy of the License at+#+#     http://www.apache.org/licenses/LICENSE-2.0+#+# Unless required by applicable law or agreed to in writing, software+# distributed under the License is distributed on an ""AS IS"" BASIS,+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+# See the License for the specific language governing permissions and+# limitations under the License.++cimport cpython+from cython.operator cimport dereference++import logging+from threading import Thread+from typing import List, Mapping, Tuple++import grpc_observability+++cdef const char* CLIENT_CALL_TRACER = ""client_call_tracer""+cdef const char* SERVER_CALL_TRACER_FACTORY = ""server_call_tracer_factory""+cdef bint GLOBAL_SHUTDOWN_EXPORT_THREAD = False+cdef object global_export_thread++_LOGGER = logging.getLogger(__name__)+++class MetricsName:+  CLIENT_API_LATENCY = kRpcClientApiLatencyMeasureName+  CLIENT_SNET_MESSSAGES_PER_RPC = kRpcClientSentMessagesPerRpcMeasureName+  CLIENT_SEND_BYTES_PER_RPC = kRpcClientSentBytesPerRpcMeasureName+  CLIENT_RECEIVED_MESSAGES_PER_RPC = kRpcClientReceivedMessagesPerRpcMeasureName+  CLIENT_RECEIVED_BYTES_PER_RPC = kRpcClientReceivedBytesPerRpcMeasureName+  CLIENT_ROUNDTRIP_LATENCY = kRpcClientRoundtripLatencyMeasureName+  CLIENT_SERVER_LATENCY = kRpcClientServerLatencyMeasureName+  CLIENT_STARTED_RPCS = kRpcClientStartedRpcsMeasureName+  CLIENT_RETRIES_PER_CALL = kRpcClientRetriesPerCallMeasureName+  CLIENT_TRANSPARENT_RETRIES_PER_CALL = kRpcClientTransparentRetriesPerCallMeasureName+  CLIENT_RETRY_DELAY_PER_CALL = kRpcClientRetryDelayPerCallMeasureName+  CLIENT_TRANSPORT_LATENCY = kRpcClientTransportLatencyMeasureName+  SERVER_SENT_MESSAGES_PER_RPC = kRpcServerSentMessagesPerRpcMeasureName+  SERVER_SENT_BYTES_PER_RPC = kRpcServerSentBytesPerRpcMeasureName+  SERVER_RECEIVED_MESSAGES_PER_RPC = kRpcServerReceivedMessagesPerRpcMeasureName+  SERVER_RECEIVED_BYTES_PER_RPC = kRpcServerReceivedBytesPerRpcMeasureName+  SERVER_SERVER_LATENCY = kRpcServerServerLatencyMeasureName+  SERVER_STARTED_RPCS = kRpcServerStartedRpcsMeasureName++# Delay map creation due to circular dependencies+_CY_METRICS_NAME_TO_PY_METRICS_NAME_MAPPING = {}++def cyobservability_init(object exporter) -> None:+  global _CY_METRICS_NAME_TO_PY_METRICS_NAME_MAPPING+  _CY_METRICS_NAME_TO_PY_METRICS_NAME_MAPPING = {x.value: x for x in grpc_observability.MetricsName}","> but we'll have an circular import issueThat makes sense. Please add a comment here explaining why this is being done.> but the downside is MetricsName which should be a public class is now imported from a Cython fileBesides this hack to get around the circular import, that doesn't seem like a big deal to me. Could you maybe instead move the definition of `grpc_observability.MetricsName` to this file (or some new third file) and re-import it in `__init__.py`?",
672669,sergiitk,https://api.github.com/repos/grpc/grpc/pulls/33105,1194131396,2023-05-15T17:17:14Z,tools/run_tests/xds_k8s_test_driver/framework/rpc/grpc_channelz.py,"@@ -100,6 +100,22 @@ def find_server_socket_matching_client(server_sockets: Iterator[Socket],                 return server_socket         return None +    @staticmethod+    def channel_repr(channel: Channel) -> str:+        result = f'<Channel channel_id={channel.ref.channel_id}'","Yes, they come from the proto:https://github.com/grpc/grpc/blob/7564664f077cdaa720451633107352cb39e233e4/src/proto/grpc/channelz/channelz.proto#L36-L41If they're not populated, there's something very wrong with channelz - so IMO `AttributeError` failure would be acceptable behavior.",
1644595,gnossen,https://api.github.com/repos/grpc/grpc/pulls/32974,1194156320,2023-05-15T17:41:06Z,src/python/grpcio_observability/grpc_observability/_cyobservability.pyx,"@@ -0,0 +1,249 @@+# Copyright 2023 gRPC authors.+#+# Licensed under the Apache License, Version 2.0 (the ""License"");+# you may not use this file except in compliance with the License.+# You may obtain a copy of the License at+#+#     http://www.apache.org/licenses/LICENSE-2.0+#+# Unless required by applicable law or agreed to in writing, software+# distributed under the License is distributed on an ""AS IS"" BASIS,+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+# See the License for the specific language governing permissions and+# limitations under the License.++cimport cpython+from cython.operator cimport dereference++import logging+from threading import Thread+from typing import List, Mapping, Tuple++import grpc_observability+++cdef const char* CLIENT_CALL_TRACER = ""client_call_tracer""+cdef const char* SERVER_CALL_TRACER_FACTORY = ""server_call_tracer_factory""+cdef bint GLOBAL_SHUTDOWN_EXPORT_THREAD = False+cdef object global_export_thread++_LOGGER = logging.getLogger(__name__)+++class MetricsName:+  CLIENT_API_LATENCY = kRpcClientApiLatencyMeasureName+  CLIENT_SNET_MESSSAGES_PER_RPC = kRpcClientSentMessagesPerRpcMeasureName+  CLIENT_SEND_BYTES_PER_RPC = kRpcClientSentBytesPerRpcMeasureName+  CLIENT_RECEIVED_MESSAGES_PER_RPC = kRpcClientReceivedMessagesPerRpcMeasureName+  CLIENT_RECEIVED_BYTES_PER_RPC = kRpcClientReceivedBytesPerRpcMeasureName+  CLIENT_ROUNDTRIP_LATENCY = kRpcClientRoundtripLatencyMeasureName+  CLIENT_SERVER_LATENCY = kRpcClientServerLatencyMeasureName+  CLIENT_STARTED_RPCS = kRpcClientStartedRpcsMeasureName+  CLIENT_RETRIES_PER_CALL = kRpcClientRetriesPerCallMeasureName+  CLIENT_TRANSPARENT_RETRIES_PER_CALL = kRpcClientTransparentRetriesPerCallMeasureName+  CLIENT_RETRY_DELAY_PER_CALL = kRpcClientRetryDelayPerCallMeasureName+  CLIENT_TRANSPORT_LATENCY = kRpcClientTransportLatencyMeasureName+  SERVER_SENT_MESSAGES_PER_RPC = kRpcServerSentMessagesPerRpcMeasureName+  SERVER_SENT_BYTES_PER_RPC = kRpcServerSentBytesPerRpcMeasureName+  SERVER_RECEIVED_MESSAGES_PER_RPC = kRpcServerReceivedMessagesPerRpcMeasureName+  SERVER_RECEIVED_BYTES_PER_RPC = kRpcServerReceivedBytesPerRpcMeasureName+  SERVER_SERVER_LATENCY = kRpcServerServerLatencyMeasureName+  SERVER_STARTED_RPCS = kRpcServerStartedRpcsMeasureName++# Delay map creation due to circular dependencies+_CY_METRICS_NAME_TO_PY_METRICS_NAME_MAPPING = {}++def cyobservability_init(object exporter) -> None:+  global _CY_METRICS_NAME_TO_PY_METRICS_NAME_MAPPING+  _CY_METRICS_NAME_TO_PY_METRICS_NAME_MAPPING = {x.value: x for x in grpc_observability.MetricsName}+  NativeObservabilityInit()+  _start_exporting_thread(exporter)+++def _start_exporting_thread(object exporter) -> None:+  global global_export_thread+  global GLOBAL_SHUTDOWN_EXPORT_THREAD+  GLOBAL_SHUTDOWN_EXPORT_THREAD = False+  global_export_thread = Thread(target=_export_census_data, args=(exporter,))+  global_export_thread.start()+++def set_gcp_observability_config(object py_config) -> bool:+  py_labels = {}+  sampling_rate = 0.0++  cdef cGcpObservabilityConfig c_config = ReadAndActivateObservabilityConfig()+  if not c_config.is_valid:+    return False++  for label in c_config.labels:+    py_labels[_decode(label.key)] = _decode(label.value)++  if PythonOpenCensusTracingEnabled():+    sampling_rate = c_config.cloud_trace.sampling_rate+    # Save sampling rate to global sampler.+    ProbabilitySampler.Get().SetThreshold(sampling_rate)++  py_config.set_configuration(_decode(c_config.project_id), sampling_rate, py_labels,+                              PythonOpenCensusTracingEnabled(), PythonOpenCensusStatsEnabled())+  return True+++def create_client_call_tracer(bytes method_name, bytes trace_id,+                                      bytes parent_span_id=b'') -> cpython.PyObject:+  cdef char* c_method = cpython.PyBytes_AsString(method_name)+  cdef char* c_trace_id = cpython.PyBytes_AsString(trace_id)+  cdef char* c_parent_span_id = cpython.PyBytes_AsString(parent_span_id)++  cdef void* call_tracer = CreateClientCallTracer(c_method, c_trace_id, c_parent_span_id)+  capsule = cpython.PyCapsule_New(call_tracer, CLIENT_CALL_TRACER, NULL)+  return capsule+++def create_server_call_tracer_factory_capsule() -> cpython.PyObject:+  cdef void* call_tracer_factory = CreateServerCallTracerFactory()+  capsule = cpython.PyCapsule_New(call_tracer_factory, SERVER_CALL_TRACER_FACTORY, NULL)+  return capsule+++def delete_client_call_tracer(object client_call_tracer) -> None:+  if cpython.PyCapsule_IsValid(client_call_tracer, CLIENT_CALL_TRACER):+    capsule_ptr = cpython.PyCapsule_GetPointer(client_call_tracer, CLIENT_CALL_TRACER)+    call_tracer_ptr = <ClientCallTracer*>capsule_ptr+    del call_tracer_ptr+++def _c_label_to_labels(object cLabels) -> Mapping[str, str]:","It's not super obvious that you're getting [automatic conversion](https://cython.readthedocs.io/en/latest/src/userguide/language_basics.html#id12:~:text=list%205-,struct%2C%20union,-dict%204) from `std::vector<Label>` to `List[Dict[str, str]]`. Maybe change the parameter type to `vector[Label]` and explicitly do the conversion on the first line? This will also give readers a much better idea of what to expect from the parameter. For example, in this function, if `cLabels` were truly an arbitrary object, we wouldn't be be able to assume that it's iterable, or that its elements have either a `""key""` element of a `""value""` element.Same comment for all functions doing this automatic conversion via the parameter.",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/32956,1194380089,2023-05-15T21:28:17Z,test/core/ext/filters/event_engine_client_channel_resolver/resolver_fuzzer.cc,"@@ -0,0 +1,265 @@+// Copyright 2023 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+#include <grpc/support/port_platform.h>++#include <algorithm>+#include <memory>+#include <string>+#include <type_traits>+#include <utility>+#include <vector>++#include ""absl/base/thread_annotations.h""+#include ""absl/functional/any_invocable.h""+#include ""absl/status/status.h""+#include ""absl/status/statusor.h""+#include ""absl/strings/str_cat.h""+#include ""absl/strings/string_view.h""+#include ""absl/time/time.h""+#include ""absl/types/optional.h""++#include <grpc/event_engine/event_engine.h>+#include <grpc/grpc.h>+#include <grpc/support/log.h>++#include ""src/core/ext/filters/client_channel/resolver/dns/event_engine/event_engine_client_channel_resolver.h""+#include ""src/core/lib/channel/channel_args.h""+#include ""src/core/lib/event_engine/tcp_socket_utils.h""+#include ""src/core/lib/gprpp/debug_location.h""+#include ""src/core/lib/gprpp/notification.h""+#include ""src/core/lib/gprpp/orphanable.h""+#include ""src/core/lib/gprpp/work_serializer.h""+#include ""src/core/lib/resolver/resolver.h""+#include ""src/core/lib/resolver/resolver_factory.h""+#include ""src/core/lib/uri/uri_parser.h""+#include ""src/libfuzzer/libfuzzer_macro.h""+#include ""test/core/event_engine/fuzzing_event_engine/fuzzing_event_engine.h""+#include ""test/core/event_engine/fuzzing_event_engine/fuzzing_event_engine.pb.h""+#include ""test/core/event_engine/util/aborting_event_engine.h""+#include ""test/core/ext/filters/event_engine_client_channel_resolver/resolver_ops.pb.h""++// TODO(hork): exercise Orphan on the client channel resolver, which will+// exercise the resolution cancellation path. Currently, all requests will get+// responses.++bool squelch = true;++namespace {++using event_engine_client_channel_resolver::TXTRecordType;+using grpc_core::EventEngineClientChannelDNSResolverFactory;+using grpc_event_engine::experimental::EventEngine;+using grpc_event_engine::experimental::FuzzingEventEngine;+using grpc_event_engine::experimental::URIToResolvedAddress;++class FuzzingResolverEventEngine+    : public grpc_event_engine::experimental::AbortingEventEngine {+ public:+  explicit FuzzingResolverEventEngine(+      const event_engine_client_channel_resolver::Msg& msg)+      : runner_(FuzzingEventEngine::Options(),+                fuzzing_event_engine::Actions()) {+    // Set hostname responses+    if (msg.has_hostname_error()) {+      hostname_responses_ = absl::nullopt;+    } else {+      hostname_responses_.emplace();+      for (const auto& address : msg.hostname_response().addresses()) {+        hostname_responses_->emplace_back(*URIToResolvedAddress(+            absl::StrCat(""ipv4:127.0.0.1:"", address.port() % 65535)));+      }+    }+    // Set SRV Responses+    if (msg.has_srv_error()) {+      srv_responses_ = absl::nullopt;+    } else {+      srv_responses_.emplace();+      for (const auto& srv_record : msg.srv_response().srv_records()) {+        EventEngine::DNSResolver::SRVRecord final_r;+        final_r.host = srv_record.host();+        final_r.port = srv_record.port();+        final_r.priority = srv_record.priority();+        final_r.weight = srv_record.weight();+        srv_responses_->emplace_back(final_r);+      }+    }+    // Set TXT Responses+    if (msg.has_txt_error()) {+      txt_responses_ = absl::nullopt;+    } else {+      txt_responses_.emplace();+      for (const auto& txt_record : msg.txt_response().txt_records()) {+        if (txt_record == TXTRecordType::TXT_VALID) {+          txt_responses_->emplace_back(txt_valid_config_);+        } else {+          txt_responses_->emplace_back(txt_invalid_config_);+        }+      }+    }+  }+  std::unique_ptr<DNSResolver> GetDNSResolver(+      const DNSResolver::ResolverOptions& /* options */) override {+    return std::make_unique<FuzzingDNSResolver>(this);+  }++  void Tick() { runner_.Tick(); }++ private:+  class FuzzingDNSResolver : public DNSResolver {+   public:+    explicit FuzzingDNSResolver(FuzzingResolverEventEngine* engine)+        : engine_(engine) {}+    LookupTaskHandle LookupHostname(LookupHostnameCallback on_resolve,+                                    absl::string_view /* name */,+                                    absl::string_view /* default_port */,+                                    Duration /* timeout */) override {+      auto finish =+          [cb = std::move(on_resolve), runner = &engine_->runner_](+              absl::StatusOr<std::vector<ResolvedAddress>> response) mutable {+            runner->Run(+                [cb = std::move(cb), response = std::move(response)]() mutable {+                  cb(response);+                });+            return EventEngine::DNSResolver::LookupTaskHandle::kInvalid;+          };+      if (!engine_->hostname_responses_.has_value()) {+        return finish(engine_->lookup_hostname_response_base_case_);+      }+      return finish(*engine_->hostname_responses_);+    }+    LookupTaskHandle LookupSRV(LookupSRVCallback on_resolve,+                               absl::string_view /* name */,+                               Duration /* timeout */) override {+      auto finish =+          [cb = std::move(on_resolve), runner = &engine_->runner_](+              absl::StatusOr<std::vector<SRVRecord>> response) mutable {+            runner->Run(+                [cb = std::move(cb), response = std::move(response)]() mutable {+                  cb(response);+                });+            return EventEngine::DNSResolver::LookupTaskHandle::kInvalid;+          };+      if (!engine_->srv_responses_.has_value()) {+        return finish(engine_->lookup_srv_response_base_case_);+      }+      return finish(*engine_->srv_responses_);+    }+    LookupTaskHandle LookupTXT(LookupTXTCallback on_resolve,+                               absl::string_view /* name */,+                               Duration /* timeout */) override {+      auto finish =+          [cb = std::move(on_resolve), runner = &engine_->runner_](+              absl::StatusOr<std::vector<std::string>> response) mutable {+            runner->Run(+                [cb = std::move(cb), response = std::move(response)]() mutable {+                  cb(response);+                });+            return EventEngine::DNSResolver::LookupTaskHandle::kInvalid;+          };+      if (!engine_->txt_responses_.has_value()) {+        return finish(engine_->lookup_txt_response_base_case_);+      }+      return finish(*engine_->txt_responses_);+    }+    bool CancelLookup(LookupTaskHandle /* handle */) override { return false; }++   private:+    FuzzingResolverEventEngine* engine_;+  };++  // members+  FuzzingEventEngine runner_;++  // responses+  absl::optional<std::vector<EventEngine::ResolvedAddress>> hostname_responses_;+  absl::optional<std::vector<EventEngine::DNSResolver::SRVRecord>>+      srv_responses_;+  absl::optional<std::vector<std::string>> txt_responses_;++  // base cases+  const std::string txt_valid_config_ =+      ""grpc_config=[{\""serviceConfig\"":{\""loadBalancingPolicy\"":\""round_""","Having a ""this is good/this is bad"" example for the fuzzer is still useful though: it allows additional checks to be made if the fuzzer understands that this must definitely pass or fail.I'd probably encourage instead moving the proto to something like:```oneof {  TXTRecordType enumerated_value = 1;  string arbitrary_value = 2;}```with a weaker check on `arbitrary_value` than is possible with `enumerated_value`",
672669,sergiitk,https://api.github.com/repos/grpc/grpc/pulls/33040,1194437942,2023-05-15T22:59:23Z,tools/run_tests/xds_k8s_test_driver/framework/xds_url_map_testcase.py,"@@ -378,6 +387,16 @@ def cleanupAfterTests(cls):             retryer(cls._cleanup, cleanup_all)         except retryers.RetryError:             logging.exception('Got error during teardown')+        finally:+            # Fail if any of the pods restarted.+            cls.assertEqual(+                client_restarts,+                0,+                msg=+                ('Client pods unexpectedly restarted'+                 f' {client_restarts} times during test.'+                 ' In most cases, this is caused by the test client app crash.'+                ))","This [failed](https://source.cloud.google.com/results/invocations/696d8a3e-4805-414c-bdcc-f54d35f6a293/targets/grpc%2Fcore%2Fv1.54.x%2Fbranch%2Flinux%2Fgrpc_xds_url_map%2Furl_map/tests;group=affinity_test.TestHeaderBasedAffinity;test=tearDownClass;row=1) with```pyTraceback (most recent call last):  File ""/tmpfs/tmp/tmp.QBtlnvekrC/grpc/tools/run_tests/xds_k8s_test_driver/framework/xds_url_map_testcase.py"", line 392, in cleanupAfterTests    cls.assertEqual(TypeError: assertEqual() missing 1 required positional argument: 'second'```I think we can't call `assertEqual` here, because it's a class :( I guess just do an `assert`. Or raise an `AssertionError`.",
4111145,YifeiZhuang,https://api.github.com/repos/grpc/grpc/pulls/33098,1194448151,2023-05-15T23:21:14Z,doc/interop-test-descriptions.md,"@@ -1152,7 +1152,7 @@ Procedures:       }     }     ```-2. After getting a response, client waits up to 5 seconds to receive a OOB load +2. After getting a response, client waits up to 10 seconds to receive a OOB load ","Using a total timeout might make the debug harder if test failed, while a separate timeout can pin point the exact failed step. Java does not have other tests using overall timeout as Go does. Since it is clear enough that we are pulling for certain condition to be true, either is acceptable for me.",
1644595,gnossen,https://api.github.com/repos/grpc/grpc/pulls/32974,1194456165,2023-05-15T23:39:22Z,src/python/grpcio_observability/grpc_observability/_observability.py,"@@ -0,0 +1,180 @@+# Copyright 2023 gRPC authors.+#+# Licensed under the Apache License, Version 2.0 (the ""License"");+# you may not use this file except in compliance with the License.+# You may obtain a copy of the License at+#+#     http://www.apache.org/licenses/LICENSE-2.0+#+# Unless required by applicable law or agreed to in writing, software+# distributed under the License is distributed on an ""AS IS"" BASIS,+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+# See the License for the specific language governing permissions and+# limitations under the License.++from dataclasses import dataclass+from dataclasses import field+import logging+import threading+import time+from typing import Any, Mapping, Optional++import grpc+from grpc_observability import _cyobservability  # pytype: disable=pyi-error+from opencensus.trace import execution_context+from opencensus.trace import span_context as span_context_module+from opencensus.trace import trace_options as trace_options_module++_LOGGER = logging.getLogger(__name__)++ClientCallTracerCapsule = Any  # it appears only once in the function signature+ServerCallTracerFactoryCapsule = Any  # it appears only once in the function signature+grpc_observability = Any  # grpc_observability.py imports this module.++GRPC_STATUS_CODE_TO_STRING = {+    grpc.StatusCode.OK: ""OK"",+    grpc.StatusCode.CANCELLED: ""CANCELLED"",+    grpc.StatusCode.UNKNOWN: ""UNKNOWN"",+    grpc.StatusCode.INVALID_ARGUMENT: ""INVALID_ARGUMENT"",+    grpc.StatusCode.DEADLINE_EXCEEDED: ""DEADLINE_EXCEEDED"",+    grpc.StatusCode.NOT_FOUND: ""NOT_FOUND"",+    grpc.StatusCode.ALREADY_EXISTS: ""ALREADY_EXISTS"",+    grpc.StatusCode.PERMISSION_DENIED: ""PERMISSION_DENIED"",+    grpc.StatusCode.UNAUTHENTICATED: ""UNAUTHENTICATED"",+    grpc.StatusCode.RESOURCE_EXHAUSTED: ""RESOURCE_EXHAUSTED"",+    grpc.StatusCode.FAILED_PRECONDITION: ""FAILED_PRECONDITION"",+    grpc.StatusCode.ABORTED: ""ABORTED"",+    grpc.StatusCode.OUT_OF_RANGE: ""OUT_OF_RANGE"",+    grpc.StatusCode.UNIMPLEMENTED: ""UNIMPLEMENTED"",+    grpc.StatusCode.INTERNAL: ""INTERNAL"",+    grpc.StatusCode.UNAVAILABLE: ""UNAVAILABLE"",+    grpc.StatusCode.DATA_LOSS: ""DATA_LOSS"",+}+++@dataclass+class GcpObservabilityPythonConfig:+    _singleton = None+    _lock: threading.RLock = threading.RLock()+    project_id: str = """"+    stats_enabled: bool = False+    tracing_enabled: bool = False+    labels: Optional[Mapping[str, str]] = field(default_factory=dict)+    sampling_rate: Optional[float] = 0.0++    @staticmethod+    def get():+        with GcpObservabilityPythonConfig._lock:+            if GcpObservabilityPythonConfig._singleton is None:+                GcpObservabilityPythonConfig._singleton = GcpObservabilityPythonConfig(+                )+        return GcpObservabilityPythonConfig._singleton++    def set_configuration(self,+                          project_id: str,+                          sampling_rate: Optional[float] = 0.0,+                          labels: Optional[Mapping[str, str]] = None,+                          tracing_enabled: bool = False,+                          stats_enabled: bool = False) -> None:+        self.project_id = project_id+        self.stats_enabled = stats_enabled+        self.tracing_enabled = tracing_enabled+        self.labels = labels+        self.sampling_rate = sampling_rate+++# pylint: disable=no-self-use+class GCPOpenCensusObservability(grpc._ObservabilityPlugin):",How much of this is specific to GCP? Can we pull out a parent class that has all of the non-GCP-specific functionality?,
5663878,yijiem,https://api.github.com/repos/grpc/grpc/pulls/33131,1194456660,2023-05-15T23:40:24Z,src/core/ext/filters/client_channel/resolver/dns/event_engine/event_engine_client_channel_resolver.cc,"@@ -409,7 +410,7 @@ void EventEngineClientChannelDNSResolver::EventEngineDNSRequestWrapper::                                  });       if (result != service_config->end()) {         service_config_json_ =-            result->substr(sizeof(kServiceConfigAttributePrefix));+            result->substr(std::strlen(kServiceConfigAttributePrefix));","Great point! And looks like both MSVC and GCC can compute strlen at compile time: https://github.com/abseil/abseil-cpp/blob/b971ac5250ea8de900eae9f95e06548d14cd95fe/absl/strings/string_view.h#L607-L623, except clang though.",
5663878,yijiem,https://api.github.com/repos/grpc/grpc/pulls/33131,1194462955,2023-05-15T23:54:36Z,src/core/ext/filters/client_channel/resolver/dns/event_engine/event_engine_client_channel_resolver.cc,"@@ -409,7 +410,7 @@ void EventEngineClientChannelDNSResolver::EventEngineDNSRequestWrapper::                                  });       if (result != service_config->end()) {         service_config_json_ =-            result->substr(sizeof(kServiceConfigAttributePrefix));+            result->substr(std::strlen(kServiceConfigAttributePrefix));","Oh wrong, clang seems to have it too: https://godbolt.org/z/ac5n8d5v3.",
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/32956,1194536645,2023-05-16T02:35:55Z,test/core/ext/filters/event_engine_client_channel_resolver/resolver_ops.proto,"@@ -0,0 +1,68 @@+// Copyright 2021 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++syntax = ""proto3"";++package event_engine_client_channel_resolver;++message ResolverArgs {+    bool request_service_config = 2;+    bool enable_srv_queries = 3;+}++// Some error. The details are unimportant.+message Error {}+++message ResolvedAddress {+    uint32 port = 1;+}+message ResolvedAddresses {+    repeated ResolvedAddress addresses = 1;+}++message SRVRecord {+    string host = 1;+    uint32 port = 2;+    uint32 priority = 3;+    uint32 weight = 4;+}+message SRVRecords {+    repeated SRVRecord srv_records = 1;+}++enum TXTRecordType {+    TXT_VALID = 0;+    TXT_INVALID = 1;+}+message TXTRecords {+    repeated TXTRecordType txt_records = 1;+}++message Msg {","I think that's doable. IIUC, that amounts to calling the result health callback with bad statuses some number of times (capped at maybe 3, since that's a ~7s test already) before succeeding. We'd see timeouts if re-resolution failed. Does that sound right?",
287917,eugeneo,https://api.github.com/repos/grpc/grpc/pulls/33129,1195436611,2023-05-16T16:44:18Z,examples/cpp/error_handling/greeter_error_client.cc,"@@ -0,0 +1,144 @@+// Copyright 2023 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++#include <condition_variable>+#include <iostream>+#include <memory>+#include <mutex>+#include <string>++#include ""absl/flags/flag.h""+#include ""absl/flags/parse.h""+#include ""absl/strings/str_format.h""++#include <grpcpp/grpcpp.h>++#ifdef BAZEL_BUILD+#include ""examples/protos/helloworld.grpc.pb.h""+#include ""google/rpc/error_details.pb.h""++#include ""src/proto/grpc/status/status.pb.h""+#else+#include ""error_details.pb.h""+#include ""helloworld.grpc.pb.h""+#include ""status.pb.h""+#endif++ABSL_FLAG(std::string, target, ""localhost:50051"", ""Server address"");++using grpc::Channel;+using grpc::ClientContext;+using grpc::Status;+using helloworld::Greeter;+using helloworld::HelloReply;+using helloworld::HelloRequest;++class GreeterClient {+ public:+  GreeterClient(std::shared_ptr<Channel> channel)+      : stub_(Greeter::NewStub(channel)) {}++  // Assembles the client's payload, sends it and prints the response back+  // from the server.+  void SayHello(const std::string& user) {+    // Data we are sending to the server.+    HelloRequest request;+    request.set_name(user);+    // Container for the data we expect from the server.+    HelloReply reply;+    // Context for the client. It could be used to convey extra information to+    // the server and/or tweak certain RPC behaviors.+    ClientContext context;+    // The actual RPC.+    std::mutex mu;+    std::condition_variable cv;+    bool done = false;+    Status status;+    std::cout << absl::StrFormat(""### Send: SayHello(name=%s)"", user)+              << std::endl;+    stub_->async()->SayHello(&context, &request, &reply,+                             [&mu, &cv, &done, &status](Status s) {+                               status = std::move(s);+                               std::lock_guard<std::mutex> lock(mu);+                               done = true;+                               cv.notify_one();+                             });+    std::unique_lock<std::mutex> lock(mu);+    while (!done) {","Suggestion: `mu.LockWhen` would remove the need for a separate condition variable, streamlining the code.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/33133,1195441939,2023-05-16T16:49:30Z,test/cpp/end2end/xds/xds_csds_end2end_test.cc,"@@ -22,25 +22,26 @@  #include ""absl/memory/memory.h"" #include ""absl/strings/str_cat.h""+#include ""envoy/config/cluster/v3/cluster.pb.h""+#include ""envoy/config/endpoint/v3/endpoint.pb.h""+#include ""envoy/config/listener/v3/listener.pb.h""+#include ""envoy/config/route/v3/route.pb.h""+#include ""envoy/extensions/filters/network/http_connection_manager/v3/http_connection_manager.pb.h""  #include <grpcpp/create_channel.h> #include <grpcpp/security/credentials.h>  #include ""src/core/ext/filters/client_channel/backup_poller.h"" #include ""src/core/lib/config/config_vars.h"" #include ""src/cpp/client/secure_credentials.h""-#include ""src/proto/grpc/testing/xds/v3/cluster.grpc.pb.h""-#include ""src/proto/grpc/testing/xds/v3/endpoint.grpc.pb.h""-#include ""src/proto/grpc/testing/xds/v3/http_connection_manager.grpc.pb.h""-#include ""src/proto/grpc/testing/xds/v3/listener.grpc.pb.h""-#include ""src/proto/grpc/testing/xds/v3/route.grpc.pb.h"" #include ""test/core/util/test_config.h"" #include ""test/cpp/end2end/xds/xds_end2end_test_lib.h""  #ifndef DISABLED_XDS_PROTO_IN_CC","I suspect that we no longer need this guard.  IIRC, this was a hack that Lidi added to handle CSDS being disabled internally.  But hopefully, with this PR, it will no longer be necessary to do that.Please do a test import to make sure everything works properly before merging this.",X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/33139,1195568650,2023-05-16T18:50:22Z,src/core/lib/channel/connected_channel.cc,"@@ -824,11 +824,19 @@ ArenaPromise<ServerMetadataHandle> MakeServerCallPromise(   auto cleanup_polling_entity_latch =       std::unique_ptr<Latch<grpc_polling_entity>, CleanupPollingEntityLatch>(           &call_data->polling_entity_latch);+  struct CleanupSendInitialMetadata {+    void operator()(CallData* call_data) {+      call_data->server_initial_metadata.receiver.CloseWithError();+    }+  };+  auto cleanup_send_initial_metadata =","The `auto` doesn't seem to add much here.  Seems like this can be:```std::unique_ptr<CallData, CleanupSendInitialMetadata> cleanup_send_initial_metadata(    call_data);```Alternatively, maybe use `absl::Cleanup` here?",
1644595,gnossen,https://api.github.com/repos/grpc/grpc/pulls/32974,1195581815,2023-05-16T19:03:23Z,src/python/grpcio_observability/grpc_observability/python_census_context.h,"@@ -0,0 +1,324 @@+// Copyright 2023 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++// TODO(xuanwn): clean up includes+#include <string>+#include <initializer_list>+#include <sstream>+#include <iostream>+#include <iomanip>++#include ""absl/base/thread_annotations.h""+#include ""absl/status/status.h""+#include ""absl/strings/string_view.h""+#include ""absl/time/time.h""+#include ""absl/synchronization/mutex.h""+#include ""absl/strings/strip.h""+#include ""absl/random/random.h""+#include ""absl/strings/escaping.h""+#include ""absl/numeric/int128.h""++#include <grpc/slice.h>+#include <grpc/status.h>++#include ""src/cpp/ext/filters/census/rpc_encoding.h""+#include ""src/core/lib/channel/channel_stack.h""+#include ""src/python/grpcio_observability/grpc_observability/constants.h""+#include ""src/python/grpcio_observability/grpc_observability/sampler.h""++#ifndef GRPC_PYRHON_OPENCENSUS_H+#define GRPC_PYRHON_OPENCENSUS_H++namespace grpc_observability {++namespace {+std::atomic<bool> g_open_census_stats_enabled(true);+std::atomic<bool> g_open_census_tracing_enabled(true);+}  // namespace++// Enables/Disables Python OpenCensus stats/tracing. It's only safe to do at the start+// of a program, before any channels/servers are built.+void EnablePythonOpenCensusStats(bool enable);+void EnablePythonOpenCensusTracing(bool enable);+// Gets the current status of Python OpenCensus stats/tracing+bool PythonOpenCensusStatsEnabled();+bool PythonOpenCensusTracingEnabled();++// The length of the grpc-trace-bin value:+//      1 (version)+//   +  1 (trace_id field)+//   + 16 (length of trace_id)+//   +  1 (span_id field)+//   +  8 (span_id length)+//   +  1 (trace_options field)+//   +  1 (trace_options length)+//   ----+//     29+constexpr int kGrpcTraceBinHeaderLen = 29;++static constexpr size_t kTraceIdSize = 16;+static constexpr size_t kSpanIdSize = 8;++constexpr uint8_t kVersionId = 0;+constexpr uint8_t kTraceIdField = 0;+constexpr uint8_t kSpanIdField = 1;+constexpr uint8_t kTraceOptionsField = 2;++constexpr int kVersionLen = 1;+constexpr int kTraceIdLen = 16;+constexpr int kSpanIdLen = 8;+constexpr int kTraceOptionsLen = 1;++constexpr int kVersionOfs = 0;+constexpr int kTraceIdOfs = 1;+constexpr int kSpanIdOfs = kTraceIdOfs + 1 + kTraceIdLen;+constexpr int kTraceOptionsOfs = kSpanIdOfs + 1 + kSpanIdLen;++static constexpr size_t kSizeTraceID = 16;+static constexpr size_t kSizeSpanID = 8;+static constexpr size_t kSizeTraceOptions = 1;++static_assert(kVersionLen + 1 + kTraceIdLen + 1 + kSpanIdLen + 1 + kTraceOptionsLen == kGrpcTraceBinHeaderLen,+              ""header length is wrong"");++struct Tag {+  std::string key;+  std::string value;+};++struct Label {+  std::string key;+  std::string value;+};++union MeasurementValue {+  double value_double;+  int64_t value_int;+};++struct Measurement {+  MetricsName name;+  MeasurementType type;+  MeasurementValue value;+};++struct Annotation {+  std::string time_stamp;+  std::string description;+};++struct SpanCensusData {+  std::string name;+  std::string start_time;+  std::string end_time;+  std::string trace_id;+  std::string span_id;+  std::string parent_span_id;+  std::string status;+  std::vector<Label> span_labels;+  std::vector<Annotation> span_annotations;+  int64_t child_span_count;+  bool should_sample;+};++class SpanContext final {+ public:+  SpanContext() : is_valid_(false) {}++  SpanContext(std::string trace_id, std::string span_id, bool should_sample)+      : trace_id_(trace_id), span_id_(span_id), should_sample_(should_sample), is_valid_(true) {}++  // Returns the TraceId associated with this SpanContext.+  std::string TraceId() const { return trace_id_; }++  // Returns the SpanId associated with this SpanContext.+  std::string SpanId() const { return span_id_; }++  bool IsSampled() const { return should_sample_; }++  bool IsValid() const { return is_valid_; }++ private:+  std::string trace_id_;+  std::string span_id_;+  bool should_sample_;+  bool is_valid_;+};++class Span final {+ public:+  explicit Span(std::string name, std::string parent_span_id, absl::Time start_time, SpanContext context)+    : name_(name), parent_span_id_(parent_span_id), start_time_(start_time),+      context_(context) {}++  void End() {+    end_time_ = absl::Now();+  }++  void AddChildSpan() {+    ++child_span_count_;+  }++  static Span StartSpan(absl::string_view name, Span* parent);++  static Span StartSpan(absl::string_view name, SpanContext parent_context);++  static Span StartSpan(absl::string_view name, absl::string_view trace_id);++  static Span BlankSpan() { return StartSpan("""", """"); }++  SpanContext& Context() { return context_; }++  void SetStatus(absl::string_view status);++  void AddAttribute(absl::string_view key, absl::string_view value);++  void AddAnnotation(absl::string_view description);++  SpanCensusData ToCensusData();++ private:+  static bool ShouldSample(std::string trace_id) {+    return ProbabilitySampler::Get().ShouldSample(trace_id);+  }++  std::string name_;+  std::string parent_span_id_;+  absl::Time start_time_;+  absl::Time end_time_;+  std::string status_;+  std::vector<Label> span_labels_;+  std::vector<Annotation> span_annotations_;+  SpanContext context_;+  uint64_t child_span_count_ = 0;+};++class PythonCensusContext {",Please add comments describing what this class does and what its lifecycle is.,
24593237,XuanWang-Amos,https://api.github.com/repos/grpc/grpc/pulls/32974,1195594340,2023-05-16T19:16:13Z,src/python/grpcio_observability/grpc_observability/_cyobservability.pxd,"@@ -0,0 +1,156 @@+# Copyright 2023 gRPC authors.+#+# Licensed under the Apache License, Version 2.0 (the ""License"");+# you may not use this file except in compliance with the License.+# You may obtain a copy of the License at+#+#     http://www.apache.org/licenses/LICENSE-2.0+#+# Unless required by applicable law or agreed to in writing, software+# distributed under the License is distributed on an ""AS IS"" BASIS,+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+# See the License for the specific language governing permissions and+# limitations under the License.++from libc.stdio cimport printf+from libcpp.string cimport string+from libcpp.vector cimport vector++ctypedef   signed long long int64_t++cdef extern from ""<queue>"" namespace ""std"" nogil:+    cdef cppclass queue[T]:+        queue()+        bint empty()+        T& front()+        T& back()+        void pop()+        void push(T&)+        size_t size()++cdef extern from ""<mutex>"" namespace ""std"" nogil:+    cdef cppclass mutex:+        mutex()+        void lock()+        void unlock()++    cdef cppclass unique_lock[Mutex]:+      unique_lock(Mutex&)++cdef extern from ""<condition_variable>"" namespace ""std"" nogil:+  cdef cppclass condition_variable:+    condition_variable()+    void notify_all()+    void wait(unique_lock[mutex]&)++cdef extern from ""src/core/lib/channel/call_tracer.h"" namespace ""grpc_core"":+    cdef cppclass ClientCallTracer:+        pass++cdef extern from ""python_census_context.h"" namespace ""grpc_observability"":+  union MeasurementValue:+    double value_double+    int64_t value_int++  ctypedef struct Label:+    string key+    string value++  ctypedef struct Annotation:+    string time_stamp+    string description++  ctypedef struct Measurement:+    cMetricsName name+    MeasurementType type+    MeasurementValue value++  ctypedef struct SpanCensusData:+    string name+    string start_time+    string end_time+    string trace_id+    string span_id+    string parent_span_id+    string status+    vector[Label] span_labels+    vector[Annotation] span_annotations+    int64_t child_span_count+    bint should_sample++cdef extern from ""observability_util.h"" namespace ""grpc_observability"":+  cdef cGcpObservabilityConfig ReadAndActivateObservabilityConfig() nogil+  cdef void NativeObservabilityInit() except ++  cdef void* CreateClientCallTracer(char* method, char* trace_id, char* parent_span_id) except ++  cdef void* CreateServerCallTracerFactory() except ++  cdef queue[cCensusData]* kCensusDataBuffer+  cdef void AwaitNextBatchLocked(unique_lock[mutex]&, int) nogil+  cdef bint PythonOpenCensusStatsEnabled() nogil+  cdef bint PythonOpenCensusTracingEnabled() nogil+  cdef mutex kCensusDataBufferMutex+  cdef condition_variable CensusDataBufferCV++  cppclass cCensusData ""::grpc_observability::CensusData"":","Oh right, I'll change it to `NativeCensusData`, and also rename the other `cCensusData` to `c_census_data`.",X
7221003,rockspore,https://api.github.com/repos/grpc/grpc/pulls/33145,1195639705,2023-05-16T20:03:25Z,src/core/ext/filters/rbac/rbac_service_config_parser.cc,"@@ -750,6 +806,15 @@ void RbacConfig::RbacPolicy::Rules::JsonPostLoad(const Json&, const JsonArgs&,     ValidationErrors::ScopedField field(errors, "".action"");     errors->AddError(""unknown action"");   }+  auto rbac_audit_condition =+      static_cast<Rbac::AuditCondition>(audit_condition);","We can't really know whether it's valid before casting unless we assume 0 is `kNone` and etc. But this is exactly what `static_cast` will do for us.IIUC, it's ok to do it in the current order as long as populate the `ValidationErrors` appropriately. The `rbac_action` is processed the same way above.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32701,1195652679,2023-05-16T20:18:40Z,src/core/lib/event_engine/grpc_ares_wrapper.h,"@@ -0,0 +1,340 @@+// Copyright 2023 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+#ifndef GRPC_SRC_CORE_LIB_EVENT_ENGINE_GRPC_ARES_WRAPPER_H+#define GRPC_SRC_CORE_LIB_EVENT_ENGINE_GRPC_ARES_WRAPPER_H++#include <grpc/support/port_platform.h>++#if GRPC_ARES == 1++#include <stddef.h>++#include <algorithm>+#include <memory>+#include <string>+#include <vector>++#include <ares.h>++#include ""absl/base/thread_annotations.h""+#include ""absl/functional/any_invocable.h""+#include ""absl/status/status.h""+#include ""absl/status/statusor.h""+#include ""absl/strings/string_view.h""+#include ""absl/types/optional.h""++#include <grpc/event_engine/event_engine.h>+#include <grpc/support/log.h>++#include ""src/core/lib/debug/trace.h""+#include ""src/core/lib/event_engine/grpc_polled_fd.h""+#include ""src/core/lib/gprpp/orphanable.h""+#include ""src/core/lib/gprpp/sync.h""++namespace grpc_event_engine {+namespace experimental {++extern grpc_core::TraceFlag grpc_trace_ares_wrapper;++#define GRPC_ARES_WRAPPER_TRACE_LOG(format, ...)                              \+  do {                                                                        \+    if (GRPC_TRACE_FLAG_ENABLED(grpc_trace_ares_wrapper)) {                   \+      gpr_log(GPR_INFO, ""(EventEngine c-ares wrapper) "" format, __VA_ARGS__); \+    }                                                                         \+  } while (0)++// Base class for the c-ares based DNS lookup functionality. This class is+// inherited by the concrete leaf classes below which each represents a+// different type of lookup (i.e. A/AAAA, SRV, TXT). One request object+// represents one lookup request for a specific name. GrpcAresRequest+// encapsulates the common logics to initialize and destroy the c-ares channel+// (one channel for one request). Sets the name servers configuration for the+// channel. And interacts with c-ares sockets/fds and the EventEngine poller. It+// also encapsulates logics to start and cancel timers.+class GrpcAresRequest+    : public grpc_core::InternallyRefCounted<GrpcAresRequest> {+ public:+  ~GrpcAresRequest() override;++  // Cancels an inflight request. Returns true if cancel succeeds and will start+  // the shutdown process. Returns false if the request is already finishing,+  // cancelled or shutdown.+  bool Cancel() ABSL_LOCKS_EXCLUDED(mu_);+  void Orphan() override {}++ protected:+  GrpcAresRequest(absl::string_view name, EventEngine::Duration timeout,+                  std::unique_ptr<GrpcPolledFdFactory> polled_fd_factory,+                  EventEngine* event_engine);++  // The workhorse function. Gets the live sockets/fds used by c-ares, creates+  // FdNode if it is not currently tracked in fd_node_list_. Registers the+  // socket with the poller for read and/or write based on c-ares's demand. And+  // shutdown and destroys the poller handles whose sockets are no longer in use+  // by c-ares.+  // This function is called in every opportunities when there might be a change+  // to c-ares' sockets for the channel.+  void Work() ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu_);+  // Common logic to start the query timeout timer and the ares backup poll+  // timer. This is only called in each leaf class' Start method.+  void StartTimers() ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu_);+  // Common logic to cancel the query timeout timer and the ares backup poll+  // timer. This is called when the request is cancelled or shutting down.+  void CancelTimers() ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu_);+  // These 2 methods are deliberately thread-unsafe and should only be called in+  // the factory methods of the leaf classes as part of initialization.+  absl::StatusOr<std::string> ParseNameToResolve();+  absl::Status InitializeAresOptions(absl::string_view dns_server);++  grpc_core::Mutex mu_;","Data members must be private, as per https://google.github.io/styleguide/cppguide.html#Access_Control.One alternative is to provide access to these members via getter/setter methods.  Another option is to simply move the data members to subclasses, adding a virtual method if access is also needed in the base class.",X
24593237,XuanWang-Amos,https://api.github.com/repos/grpc/grpc/pulls/32974,1195679274,2023-05-16T20:47:08Z,src/python/grpcio_observability/grpc_observability/_observability.py,"@@ -0,0 +1,180 @@+# Copyright 2023 gRPC authors.+#+# Licensed under the Apache License, Version 2.0 (the ""License"");+# you may not use this file except in compliance with the License.+# You may obtain a copy of the License at+#+#     http://www.apache.org/licenses/LICENSE-2.0+#+# Unless required by applicable law or agreed to in writing, software+# distributed under the License is distributed on an ""AS IS"" BASIS,+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+# See the License for the specific language governing permissions and+# limitations under the License.++from dataclasses import dataclass+from dataclasses import field+import logging+import threading+import time+from typing import Any, Mapping, Optional++import grpc+from grpc_observability import _cyobservability  # pytype: disable=pyi-error+from opencensus.trace import execution_context+from opencensus.trace import span_context as span_context_module+from opencensus.trace import trace_options as trace_options_module++_LOGGER = logging.getLogger(__name__)++ClientCallTracerCapsule = Any  # it appears only once in the function signature+ServerCallTracerFactoryCapsule = Any  # it appears only once in the function signature+grpc_observability = Any  # grpc_observability.py imports this module.++GRPC_STATUS_CODE_TO_STRING = {+    grpc.StatusCode.OK: ""OK"",+    grpc.StatusCode.CANCELLED: ""CANCELLED"",+    grpc.StatusCode.UNKNOWN: ""UNKNOWN"",+    grpc.StatusCode.INVALID_ARGUMENT: ""INVALID_ARGUMENT"",+    grpc.StatusCode.DEADLINE_EXCEEDED: ""DEADLINE_EXCEEDED"",+    grpc.StatusCode.NOT_FOUND: ""NOT_FOUND"",+    grpc.StatusCode.ALREADY_EXISTS: ""ALREADY_EXISTS"",+    grpc.StatusCode.PERMISSION_DENIED: ""PERMISSION_DENIED"",+    grpc.StatusCode.UNAUTHENTICATED: ""UNAUTHENTICATED"",+    grpc.StatusCode.RESOURCE_EXHAUSTED: ""RESOURCE_EXHAUSTED"",+    grpc.StatusCode.FAILED_PRECONDITION: ""FAILED_PRECONDITION"",+    grpc.StatusCode.ABORTED: ""ABORTED"",+    grpc.StatusCode.OUT_OF_RANGE: ""OUT_OF_RANGE"",+    grpc.StatusCode.UNIMPLEMENTED: ""UNIMPLEMENTED"",+    grpc.StatusCode.INTERNAL: ""INTERNAL"",+    grpc.StatusCode.UNAVAILABLE: ""UNAVAILABLE"",+    grpc.StatusCode.DATA_LOSS: ""DATA_LOSS"",+}+++@dataclass+class GcpObservabilityPythonConfig:+    _singleton = None+    _lock: threading.RLock = threading.RLock()+    project_id: str = """"+    stats_enabled: bool = False+    tracing_enabled: bool = False+    labels: Optional[Mapping[str, str]] = field(default_factory=dict)+    sampling_rate: Optional[float] = 0.0++    @staticmethod+    def get():+        with GcpObservabilityPythonConfig._lock:+            if GcpObservabilityPythonConfig._singleton is None:+                GcpObservabilityPythonConfig._singleton = GcpObservabilityPythonConfig(+                )+        return GcpObservabilityPythonConfig._singleton++    def set_configuration(self,+                          project_id: str,+                          sampling_rate: Optional[float] = 0.0,+                          labels: Optional[Mapping[str, str]] = None,+                          tracing_enabled: bool = False,+                          stats_enabled: bool = False) -> None:+        self.project_id = project_id+        self.stats_enabled = stats_enabled+        self.tracing_enabled = tracing_enabled+        self.labels = labels+        self.sampling_rate = sampling_rate+++# pylint: disable=no-self-use+class GCPOpenCensusObservability(grpc._ObservabilityPlugin):","Most of the common functionalities was already extracted to `grpc._ObservabilityPlugin`, this object now basically does three things: 1. Implement `grpc._ObservabilityPlugin` (Already extracted). 2. Read and save configuration (Specific to GCP observability). 3. Connect the observability plugin to exporter. (We have an interface for `Exporter` and the default exporter is also specific to GCP observability).So I don't think we need additional parent class here.",X
24593237,XuanWang-Amos,https://api.github.com/repos/grpc/grpc/pulls/32974,1195687999,2023-05-16T20:56:36Z,src/python/grpcio_observability/grpc_observability/server_call_tracer.cc,"@@ -0,0 +1,238 @@+// Copyright 2023 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++// TODO(xuanwn): clean up includes+#include <stdint.h>+#include <string.h>+#include <thread>++#include <algorithm>+#include <initializer_list>+#include <string>+#include <utility>+#include <vector>++#include <grpc/support/port_platform.h>++#include ""absl/meta/type_traits.h""+#include ""absl/strings/str_cat.h""+#include ""absl/strings/str_format.h""+#include ""absl/strings/string_view.h""+#include ""absl/time/clock.h""+#include ""absl/time/time.h""+#include ""absl/types/optional.h""++#include ""src/core/lib/channel/call_tracer.h""+#include ""src/core/lib/channel/channel_stack.h""+#include ""src/core/lib/channel/context.h""+#include ""src/core/lib/iomgr/error.h""+#include ""src/core/lib/promise/context.h""+#include ""src/core/lib/resource_quota/arena.h""+#include ""src/core/lib/slice/slice.h""+#include ""src/core/lib/slice/slice_buffer.h""+#include ""src/core/lib/transport/metadata_batch.h""++#include ""src/python/grpcio_observability/grpc_observability/server_call_tracer.h""+#include ""src/python/grpcio_observability/grpc_observability/python_census_context.h""+#include ""src/python/grpcio_observability/grpc_observability/observability_util.h""++namespace grpc_observability {++namespace {++// server metadata elements+struct ServerMetadataElements {+  grpc_core::Slice path;+  grpc_core::Slice tracing_slice;+  grpc_core::Slice census_proto;+};++void FilterInitialMetadata(grpc_metadata_batch* b,+                           ServerMetadataElements* sml) {+  const auto* path = b->get_pointer(grpc_core::HttpPathMetadata());+  if (path != nullptr) {+    sml->path = path->Ref();+  }+  if (PythonOpenCensusTracingEnabled()) {+    auto grpc_trace_bin = b->Take(grpc_core::GrpcTraceBinMetadata());+    if (grpc_trace_bin.has_value()) {+      sml->tracing_slice = std::move(*grpc_trace_bin);+    }+  }+  if (PythonOpenCensusStatsEnabled()) {+    auto grpc_tags_bin = b->Take(grpc_core::GrpcTagsBinMetadata());+    if (grpc_tags_bin.has_value()) {+      sml->census_proto = std::move(*grpc_tags_bin);+    }+  }+}++}  // namespace++//+// PythonOpenCensusServerCallTracer+//++class PythonOpenCensusServerCallTracer : public grpc_core::ServerCallTracer {+ public:+  // Maximum size of server stats that are sent on the wire.+  static constexpr uint32_t kMaxServerStatsLen = 16;++  PythonOpenCensusServerCallTracer()+      : start_time_(absl::Now()),+        recv_message_count_(0),+        sent_message_count_(0) {}++  std::string TraceId() override {+    return absl::BytesToHexString(absl::string_view(context_.SpanContext().TraceId()));+  }++  std::string SpanId() override {+    return absl::BytesToHexString(absl::string_view(context_.SpanContext().SpanId()));+  }++  bool IsSampled() override { return context_.SpanContext().IsSampled(); }++  // Please refer to `grpc_transport_stream_op_batch_payload` for details on+  // arguments.+  void RecordSendInitialMetadata(+      grpc_metadata_batch* /*send_initial_metadata*/) override {}",I think it's because it's not a requirement to have this metric (Not related to any metrics listed in user guide).,
1644595,gnossen,https://api.github.com/repos/grpc/grpc/pulls/32974,1195689236,2023-05-16T20:58:12Z,src/python/grpcio_observability/grpc_observability/_cyobservability.pyx,"@@ -0,0 +1,273 @@+# Copyright 2023 gRPC authors.+#+# Licensed under the Apache License, Version 2.0 (the ""License"");+# you may not use this file except in compliance with the License.+# You may obtain a copy of the License at+#+#     http://www.apache.org/licenses/LICENSE-2.0+#+# Unless required by applicable law or agreed to in writing, software+# distributed under the License is distributed on an ""AS IS"" BASIS,+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+# See the License for the specific language governing permissions and+# limitations under the License.++cimport cpython+from cython.operator cimport dereference++import enum+import logging+from threading import Thread+from typing import List, Mapping, Tuple++import grpc_observability++# Time we wait for batch exporting census data+EXPORT_BATCH_INTERVAL = 0.5+cdef const char* CLIENT_CALL_TRACER = ""client_call_tracer""+cdef const char* SERVER_CALL_TRACER_FACTORY = ""server_call_tracer_factory""+cdef bint GLOBAL_SHUTDOWN_EXPORT_THREAD = False+cdef object GLOBAL_EXPORT_THREAD++_LOGGER = logging.getLogger(__name__)++class _CyMetricsName:+  CY_CLIENT_API_LATENCY = kRpcClientApiLatencyMeasureName+  CY_CLIENT_SNET_MESSSAGES_PER_RPC = kRpcClientSentMessagesPerRpcMeasureName+  CY_CLIENT_SEND_BYTES_PER_RPC = kRpcClientSentBytesPerRpcMeasureName+  CY_CLIENT_RECEIVED_MESSAGES_PER_RPC = kRpcClientReceivedMessagesPerRpcMeasureName+  CY_CLIENT_RECEIVED_BYTES_PER_RPC = kRpcClientReceivedBytesPerRpcMeasureName+  CY_CLIENT_ROUNDTRIP_LATENCY = kRpcClientRoundtripLatencyMeasureName+  CY_CLIENT_SERVER_LATENCY = kRpcClientServerLatencyMeasureName+  CY_CLIENT_STARTED_RPCS = kRpcClientStartedRpcsMeasureName+  CY_CLIENT_RETRIES_PER_CALL = kRpcClientRetriesPerCallMeasureName+  CY_CLIENT_TRANSPARENT_RETRIES_PER_CALL = kRpcClientTransparentRetriesPerCallMeasureName+  CY_CLIENT_RETRY_DELAY_PER_CALL = kRpcClientRetryDelayPerCallMeasureName+  CY_CLIENT_TRANSPORT_LATENCY = kRpcClientTransportLatencyMeasureName+  CY_SERVER_SENT_MESSAGES_PER_RPC = kRpcServerSentMessagesPerRpcMeasureName+  CY_SERVER_SENT_BYTES_PER_RPC = kRpcServerSentBytesPerRpcMeasureName+  CY_SERVER_RECEIVED_MESSAGES_PER_RPC = kRpcServerReceivedMessagesPerRpcMeasureName+  CY_SERVER_RECEIVED_BYTES_PER_RPC = kRpcServerReceivedBytesPerRpcMeasureName+  CY_SERVER_SERVER_LATENCY = kRpcServerServerLatencyMeasureName+  CY_SERVER_STARTED_RPCS = kRpcServerStartedRpcsMeasureName++@enum.unique+class MetricsName(enum.Enum):+  CLIENT_STARTED_RPCS = _CyMetricsName.CY_CLIENT_STARTED_RPCS+  CLIENT_API_LATENCY = _CyMetricsName.CY_CLIENT_API_LATENCY+  CLIENT_SNET_MESSSAGES_PER_RPC = _CyMetricsName.CY_CLIENT_SNET_MESSSAGES_PER_RPC+  CLIENT_SEND_BYTES_PER_RPC = _CyMetricsName.CY_CLIENT_SEND_BYTES_PER_RPC+  CLIENT_RECEIVED_MESSAGES_PER_RPC = _CyMetricsName.CY_CLIENT_RECEIVED_MESSAGES_PER_RPC+  CLIENT_RECEIVED_BYTES_PER_RPC = _CyMetricsName.CY_CLIENT_RECEIVED_BYTES_PER_RPC+  CLIENT_ROUNDTRIP_LATENCY = _CyMetricsName.CY_CLIENT_ROUNDTRIP_LATENCY+  CLIENT_SERVER_LATENCY = _CyMetricsName.CY_CLIENT_SERVER_LATENCY+  CLIENT_RETRIES_PER_CALL = _CyMetricsName.CY_CLIENT_RETRIES_PER_CALL+  CLIENT_TRANSPARENT_RETRIES_PER_CALL = _CyMetricsName.CY_CLIENT_TRANSPARENT_RETRIES_PER_CALL+  CLIENT_RETRY_DELAY_PER_CALL = _CyMetricsName.CY_CLIENT_RETRY_DELAY_PER_CALL+  CLIENT_TRANSPORT_LATENCY = _CyMetricsName.CY_CLIENT_TRANSPORT_LATENCY+  SERVER_SENT_MESSAGES_PER_RPC = _CyMetricsName.CY_SERVER_SENT_MESSAGES_PER_RPC+  SERVER_SENT_BYTES_PER_RPC = _CyMetricsName.CY_SERVER_SENT_BYTES_PER_RPC+  SERVER_RECEIVED_MESSAGES_PER_RPC = _CyMetricsName.CY_SERVER_RECEIVED_MESSAGES_PER_RPC+  SERVER_RECEIVED_BYTES_PER_RPC = _CyMetricsName.CY_SERVER_RECEIVED_BYTES_PER_RPC+  SERVER_SERVER_LATENCY = _CyMetricsName.CY_SERVER_SERVER_LATENCY+  SERVER_STARTED_RPCS = _CyMetricsName.CY_SERVER_STARTED_RPCS++# Delay map creation due to circular dependencies+_CY_METRICS_NAME_TO_PY_METRICS_NAME_MAPPING = {x.value: x for x in MetricsName}++def cyobservability_init(object exporter) -> None:+  NativeObservabilityInit()+  _start_exporting_thread(exporter)+++def _start_exporting_thread(object exporter) -> None:+  global GLOBAL_EXPORT_THREAD+  global GLOBAL_SHUTDOWN_EXPORT_THREAD+  GLOBAL_SHUTDOWN_EXPORT_THREAD = False+  GLOBAL_EXPORT_THREAD = Thread(target=_export_census_data, args=(exporter,))+  GLOBAL_EXPORT_THREAD.start()+++def set_gcp_observability_config(object py_config) -> bool:+  """"""+    Returns:+      bool: True if configuration is valid, False otherwise.+  """"""+  py_labels = {}+  sampling_rate = 0.0++  cdef cGcpObservabilityConfig c_config = ReadAndActivateObservabilityConfig()+  if not c_config.is_valid:+    return False++  for label in c_config.labels:+    py_labels[_decode(label.key)] = _decode(label.value)++  if PythonOpenCensusTracingEnabled():+    sampling_rate = c_config.cloud_trace.sampling_rate+    # Save sampling rate to global sampler.+    ProbabilitySampler.Get().SetThreshold(sampling_rate)++  py_config.set_configuration(_decode(c_config.project_id), sampling_rate, py_labels,+                              PythonOpenCensusTracingEnabled(), PythonOpenCensusStatsEnabled())+  return True+++def create_client_call_tracer(bytes method_name, bytes trace_id,+                                      bytes parent_span_id=b'') -> cpython.PyObject:+  cdef char* c_method = cpython.PyBytes_AsString(method_name)+  cdef char* c_trace_id = cpython.PyBytes_AsString(trace_id)+  cdef char* c_parent_span_id = cpython.PyBytes_AsString(parent_span_id)++  cdef void* call_tracer = CreateClientCallTracer(c_method, c_trace_id, c_parent_span_id)+  capsule = cpython.PyCapsule_New(call_tracer, CLIENT_CALL_TRACER, NULL)+  return capsule+++def create_server_call_tracer_factory_capsule() -> cpython.PyObject:+  cdef void* call_tracer_factory = CreateServerCallTracerFactory()+  capsule = cpython.PyCapsule_New(call_tracer_factory, SERVER_CALL_TRACER_FACTORY, NULL)+  return capsule+++def delete_client_call_tracer(object client_call_tracer) -> None:+  if cpython.PyCapsule_IsValid(client_call_tracer, CLIENT_CALL_TRACER):+    capsule_ptr = cpython.PyCapsule_GetPointer(client_call_tracer, CLIENT_CALL_TRACER)+    call_tracer_ptr = <ClientCallTracer*>capsule_ptr+    del call_tracer_ptr+++def _c_label_to_labels(object cLabels) -> Mapping[str, str]:+  py_labels = {}+  for label in cLabels:+    py_labels[_decode(label['key'])] = _decode(label['value'])+  return py_labels+++def _c_annotation_to_annotations(object cAnnotations) -> List[Tuple[str, str]]:+  py_annotations = []+  for annotation in cAnnotations:+    py_annotations.append((_decode(annotation['time_stamp']),+                          _decode(annotation['description'])))+  return py_annotations+++def at_observability_exit() -> None:+  _shutdown_exporting_thread()+++def _cy_metric_name_to_py_metric_name(object metric_name) -> grpc_observability.MetricsName:+  try:+      return _CY_METRICS_NAME_TO_PY_METRICS_NAME_MAPPING[metric_name]+  except KeyError:+      raise ValueError('Invalid metric name %s' % metric_name)+++def _get_stats_data(object measurement, object labels) -> grpc_observability.StatsData:+  metric_name = _cy_metric_name_to_py_metric_name(measurement['name'])+  if measurement['type'] == kMeasurementDouble:+    py_stat = grpc_observability.StatsData(name=metric_name, measure_double=True,+                                           value_float=measurement['value']['value_double'],+                                           labels=labels)+  else:+    py_stat = grpc_observability.StatsData(name=metric_name, measure_double=False,+                                           value_int=measurement['value']['value_int'],+                                           labels=labels)+  return py_stat+++def _get_tracing_data(object span_data, object span_labels, object span_annotations) -> grpc_observability.TracingData:+  py_span_labels = _c_label_to_labels(span_labels)+  py_span_annotations = _c_annotation_to_annotations(span_annotations)+  return grpc_observability.TracingData(name=_decode(span_data['name']),+                                   start_time = _decode(span_data['start_time']),+                                   end_time = _decode(span_data['end_time']),+                                   trace_id = _decode(span_data['trace_id']),+                                   span_id = _decode(span_data['span_id']),+                                   parent_span_id = _decode(span_data['parent_span_id']),+                                   status = _decode(span_data['status']),+                                   should_sample = span_data['should_sample'],+                                   child_span_count = span_data['child_span_count'],+                                   span_labels = py_span_labels,+                                   span_annotations = py_span_annotations)+++def _record_rpc_latency(object exporter, str method, float rpc_latency, str status_code) -> None:+  measurement = {}+  measurement['name'] = kRpcClientApiLatencyMeasureName+  measurement['type'] = kMeasurementDouble+  measurement['value'] = {'value_double': rpc_latency}++  labels = {}+  labels[_decode(kClientMethod)] = method.strip(""/"")+  labels[_decode(kClientStatus)] = status_code+  metric = _get_stats_data(measurement, labels)+  exporter.export_stats_data([metric])+++cdef void _export_census_data(object exporter):+  cdef int export_interval_ms = EXPORT_BATCH_INTERVAL * 1000+  while True:+    with nogil:+      while not GLOBAL_SHUTDOWN_EXPORT_THREAD:+        lk = new unique_lock[mutex](g_census_data_buffer_mutex)+        # Wait for next batch of census data OR timeout at fixed interval.+        # Batch export census data to minimize the time we acquiring the GIL.+        # TODO(xuanwn): change interval to a more appropriate number+        AwaitNextBatchLocked(dereference(lk), export_interval_ms)++        # Break only when buffer have data+        if not g_census_data_buffer.empty():+          del lk+          break+        else:+          del lk++    _flush_census_data(exporter)","If you don't keep the lock held between being woken up and emptying the buffer, the buffer could completely fill up. (I understand that it's actually a `std::queue`, which can continue growing indefinitely, but we cannot put out a transparent feature with arbitrary memory usage) We need to make a decision in this case. Either:1. We block the write side so that RPC progress pauses completely.2. We allow RPC progress to continue and throw away observability data during the period that the buffer is full.If we go with option 1, then all we'll need to do is make sure that we continuously hold `g_census_data_buffer_mutex` between the completion of `AwaitNextBatchLocked` and the end of `_flush_census_data` (including the calls to `export_stats_data` and `export_tracing_data`)If we go with option 2, then we'll need to modify `AddCensusDataToBuffer` to discard new elements when we've hit the buffer capacity.I see you currently have a single threshold: `kExportThreshold`. I think we actually need two numbers here, both of which should be configurable via environment variables. The first is the actual maximum size of our buffer, at which point we will either use option 1 or option 2 above. The second is some number less than the maximum at which we'll attempt to flush the buffer (I'd suggest something like 2/3 of the max).",
1644595,gnossen,https://api.github.com/repos/grpc/grpc/pulls/32974,1195698901,2023-05-16T21:11:37Z,src/python/grpcio_observability/grpc_observability/client_call_tracer.cc,"@@ -0,0 +1,242 @@+// Copyright 2023 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++#include ""src/python/grpcio_observability/grpc_observability/client_call_tracer.h""++#include ""absl/strings/escaping.h""+#include ""absl/strings/string_view.h""++#include <limits.h>++#include <atomic>+++namespace grpc_observability {++constexpr uint32_t+    PythonOpenCensusCallTracer::PythonOpenCensusCallAttemptTracer::kMaxTraceContextLen;+constexpr uint32_t+    PythonOpenCensusCallTracer::PythonOpenCensusCallAttemptTracer::kMaxTagsLen;++//+// OpenCensusCallTracer+//++PythonOpenCensusCallTracer::PythonOpenCensusCallTracer(char* method, char* trace_id,+                                                       char* parent_span_id, bool tracing_enabled):+      method_(GetMethod(method)),+      tracing_enabled_(tracing_enabled) {+  GenerateClientContext(absl::StrCat(""Sent."", method_), absl::string_view(trace_id),+                        absl::string_view(parent_span_id), &context_);+}++void PythonOpenCensusCallTracer::GenerateContext() {}++void PythonOpenCensusCallTracer::RecordAnnotation(absl::string_view annotation) {+  // If tracing is disabled, the following will be a no-op.+  context_.AddSpanAnnotation(annotation);+}+++PythonOpenCensusCallTracer::~PythonOpenCensusCallTracer() {+  if (PythonOpenCensusStatsEnabled()) {+    std::vector<Label> labels = context_.Labels();+    labels.emplace_back(Label{kClientMethod, std::string(method_)});+    RecordIntMetric(kRpcClientRetriesPerCallMeasureName, retries_ - 1, labels); // exclude first attempt+    RecordIntMetric(kRpcClientTransparentRetriesPerCallMeasureName, transparent_retries_, labels);+    RecordDoubleMetric(kRpcClientRetryDelayPerCallMeasureName, ToDoubleMilliseconds(retry_delay_), labels);+  }++  if (tracing_enabled_) {+    context_.EndSpan();+    if (IsSampled()) {+      RecordSpan(context_.Span().ToCensusData());+    }+  }+}+++PythonCensusContext PythonOpenCensusCallTracer::CreateCensusContextForCallAttempt() {+  auto context = PythonCensusContext(absl::StrCat(""Attempt."", method_), &(context_.Span()), context_.Labels());+  return context;+}+++PythonOpenCensusCallTracer::PythonOpenCensusCallAttemptTracer*+PythonOpenCensusCallTracer::StartNewAttempt(bool is_transparent_retry) {+  uint64_t attempt_num;+  {+    grpc_core::MutexLock lock(&mu_);+    if (transparent_retries_ != 0 || retries_ != 0) {+      if (PythonOpenCensusStatsEnabled() && num_active_rpcs_ == 0) {+        retry_delay_ += absl::Now() - time_at_last_attempt_end_;+      }+    }+    attempt_num = retries_;+    if (is_transparent_retry) {+      ++transparent_retries_;+    } else {+      ++retries_;+    }+    ++num_active_rpcs_;+  }+  context_.AddChildSpan();+  return new PythonOpenCensusCallAttemptTracer(+      this, attempt_num, is_transparent_retry);+}++//+// PythonOpenCensusCallTracer::PythonOpenCensusCallAttemptTracer+//++PythonOpenCensusCallTracer::PythonOpenCensusCallAttemptTracer::PythonOpenCensusCallAttemptTracer(+    PythonOpenCensusCallTracer* parent, uint64_t attempt_num, bool is_transparent_retry)+    : parent_(parent),+      context_(parent_->CreateCensusContextForCallAttempt()),+      start_time_(absl::Now()) {+  if (parent_->tracing_enabled_) {+    context_.AddSpanAttribute(""previous-rpc-attempts"", std::to_string(attempt_num));+    context_.AddSpanAttribute(""transparent-retry"", std::to_string(is_transparent_retry));+  }+  if (PythonOpenCensusStatsEnabled()) {+    std::vector<Label> labels = context_.Labels();+    labels.emplace_back(Label{kClientMethod, std::string(parent_->method_)});+    RecordIntMetric(kRpcClientStartedRpcsMeasureName, 1, labels);+  }+}+++void PythonOpenCensusCallTracer::PythonOpenCensusCallAttemptTracer::+    RecordSendInitialMetadata(grpc_metadata_batch* send_initial_metadata) {+  if (parent_->tracing_enabled_) {+    char tracing_buf[kMaxTraceContextLen];+    size_t tracing_len = TraceContextSerialize(context_, tracing_buf,+                                               kMaxTraceContextLen);+    if (tracing_len > 0) {+      send_initial_metadata->Set(+          grpc_core::GrpcTraceBinMetadata(),+          grpc_core::Slice::FromCopiedBuffer(tracing_buf, tracing_len));+    }+  }+  if (PythonOpenCensusStatsEnabled()) {+    grpc_slice tags = grpc_empty_slice();+    size_t encoded_tags_len = StatsContextSerialize(kMaxTagsLen, &tags);+    if (encoded_tags_len > 0) {+      send_initial_metadata->Set(grpc_core::GrpcTagsBinMetadata(),+                                 grpc_core::Slice(tags));+    }+  }+}+++void PythonOpenCensusCallTracer::PythonOpenCensusCallAttemptTracer::RecordSendMessage(+    const grpc_core::SliceBuffer& /*send_message*/) {+  ++sent_message_count_;+}+++void PythonOpenCensusCallTracer::PythonOpenCensusCallAttemptTracer::RecordReceivedMessage(+    const grpc_core::SliceBuffer& /*recv_message*/) {+  ++recv_message_count_;+}+++namespace {++void FilterTrailingMetadata(grpc_metadata_batch* b, uint64_t* elapsed_time) {+  if (PythonOpenCensusStatsEnabled()) {+    absl::optional<grpc_core::Slice> grpc_server_stats_bin =+        b->Take(grpc_core::GrpcServerStatsBinMetadata());+    if (grpc_server_stats_bin.has_value()) {+      ServerStatsDeserialize(+          reinterpret_cast<const char*>(grpc_server_stats_bin->data()),+          grpc_server_stats_bin->size(), elapsed_time);+    }+  }+}++}  // namespace+++void PythonOpenCensusCallTracer::PythonOpenCensusCallAttemptTracer::+    RecordReceivedTrailingMetadata(+        absl::Status status, grpc_metadata_batch* recv_trailing_metadata,+        const grpc_transport_stream_stats* transport_stream_stats) {+  status_code_ = status.code();+  if (PythonOpenCensusStatsEnabled()) {","Optional/style: It might make things easier to read if you rephrase this and similar methods as an early return, i.e.```c++if (!PythonOpenCensusStatsEnabled()) {  return;}// The rest of the method```Fewer braces and less indentation for the majority of the function body.",X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32701,1195707701,2023-05-16T21:31:58Z,src/core/lib/event_engine/grpc_ares_wrapper.h,"@@ -0,0 +1,340 @@+// Copyright 2023 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+#ifndef GRPC_SRC_CORE_LIB_EVENT_ENGINE_GRPC_ARES_WRAPPER_H+#define GRPC_SRC_CORE_LIB_EVENT_ENGINE_GRPC_ARES_WRAPPER_H++#include <grpc/support/port_platform.h>++#if GRPC_ARES == 1++#include <stddef.h>++#include <algorithm>+#include <memory>+#include <string>+#include <vector>++#include <ares.h>++#include ""absl/base/thread_annotations.h""+#include ""absl/functional/any_invocable.h""+#include ""absl/status/status.h""+#include ""absl/status/statusor.h""+#include ""absl/strings/string_view.h""+#include ""absl/types/optional.h""++#include <grpc/event_engine/event_engine.h>+#include <grpc/support/log.h>++#include ""src/core/lib/debug/trace.h""+#include ""src/core/lib/event_engine/grpc_polled_fd.h""+#include ""src/core/lib/gprpp/orphanable.h""+#include ""src/core/lib/gprpp/sync.h""++namespace grpc_event_engine {+namespace experimental {++extern grpc_core::TraceFlag grpc_trace_ares_wrapper;++#define GRPC_ARES_WRAPPER_TRACE_LOG(format, ...)                              \+  do {                                                                        \+    if (GRPC_TRACE_FLAG_ENABLED(grpc_trace_ares_wrapper)) {                   \+      gpr_log(GPR_INFO, ""(EventEngine c-ares wrapper) "" format, __VA_ARGS__); \+    }                                                                         \+  } while (0)++// Base class for the c-ares based DNS lookup functionality. This class is+// inherited by the concrete leaf classes below which each represents a+// different type of lookup (i.e. A/AAAA, SRV, TXT). One request object+// represents one lookup request for a specific name. GrpcAresRequest+// encapsulates the common logics to initialize and destroy the c-ares channel+// (one channel for one request). Sets the name servers configuration for the+// channel. And interacts with c-ares sockets/fds and the EventEngine poller. It+// also encapsulates logics to start and cancel timers.+class GrpcAresRequest+    : public grpc_core::InternallyRefCounted<GrpcAresRequest> {+ public:+  ~GrpcAresRequest() override;++  // Cancels an inflight request. Returns true if cancel succeeds and will start+  // the shutdown process. Returns false if the request is already finishing,+  // cancelled or shutdown.+  bool Cancel() ABSL_LOCKS_EXCLUDED(mu_);+  void Orphan() override {}++ protected:+  GrpcAresRequest(absl::string_view name, EventEngine::Duration timeout,+                  std::unique_ptr<GrpcPolledFdFactory> polled_fd_factory,+                  EventEngine* event_engine);++  // The workhorse function. Gets the live sockets/fds used by c-ares, creates+  // FdNode if it is not currently tracked in fd_node_list_. Registers the+  // socket with the poller for read and/or write based on c-ares's demand. And+  // shutdown and destroys the poller handles whose sockets are no longer in use+  // by c-ares.+  // This function is called in every opportunities when there might be a change+  // to c-ares' sockets for the channel.+  void Work() ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu_);+  // Common logic to start the query timeout timer and the ares backup poll+  // timer. This is only called in each leaf class' Start method.+  void StartTimers() ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu_);+  // Common logic to cancel the query timeout timer and the ares backup poll+  // timer. This is called when the request is cancelled or shutting down.+  void CancelTimers() ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu_);+  // These 2 methods are deliberately thread-unsafe and should only be called in+  // the factory methods of the leaf classes as part of initialization.+  absl::StatusOr<std::string> ParseNameToResolve();+  absl::Status InitializeAresOptions(absl::string_view dns_server);++  grpc_core::Mutex mu_;+  bool initialized_ ABSL_GUARDED_BY(mu_) = false;+  // name to resolve+  const std::string name_ ABSL_GUARDED_BY(mu_);+  // ares channel+  ares_channel channel_ ABSL_GUARDED_BY(mu_) = nullptr;+  // host to resolve, parsed from name_+  std::string host_ ABSL_GUARDED_BY(mu_);+  bool cancelled_ ABSL_GUARDED_BY(mu_) = false;+  bool shutting_down_ ABSL_GUARDED_BY(mu_) = false;+  EventEngine* event_engine_;++ private:+  // A FdNode saves (not owns) a live socket/fd which c-ares creates, and owns a+  // GrpcPolledFd object which has a platform-agnostic interface to interact+  // with the poller. The liveness of the socket means that c-ares needs us to+  // monitor r/w events on this socket and notifies c-ares when such events have+  // happened which we achieve through the GrpcPolledFd object. FdNode also+  // handles the shutdown (maybe due to socket no longer used, finished request,+  // cancel or timeout) and the destruction of the poller handle. Note that+  // FdNode does not own the socket and it's the c-ares' responsibility to+  // close the socket (possibly through ares_destroy).+  struct FdNode {+    FdNode() = default;+    FdNode(ares_socket_t as, GrpcPolledFd* polled_fd);+    ares_socket_t as;+    std::unique_ptr<GrpcPolledFd> polled_fd;+    // next fd node+    FdNode* next = nullptr;+    // true if the readable closure has been registered+    bool readable_registered = false;+    // true if the writable closure has been registered+    bool writable_registered = false;+    bool already_shutdown = false;+  };++  // A linked-list of FdNodes. Support operations such as pop a FdNode which has+  // a specific socket/fd that c-ares owns.+  class FdNodeList {","Why do we need a custom data structure here?  Can we just use `std::list<>`?  Or maybe some sort of map, keyed by the address of the `FdNode` or something?",
1644595,gnossen,https://api.github.com/repos/grpc/grpc/pulls/32974,1195712291,2023-05-16T21:38:16Z,src/python/grpcio_observability/grpc_observability/client_call_tracer.cc,"@@ -0,0 +1,242 @@+// Copyright 2023 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++#include ""src/python/grpcio_observability/grpc_observability/client_call_tracer.h""++#include ""absl/strings/escaping.h""+#include ""absl/strings/string_view.h""++#include <limits.h>++#include <atomic>+++namespace grpc_observability {++constexpr uint32_t+    PythonOpenCensusCallTracer::PythonOpenCensusCallAttemptTracer::kMaxTraceContextLen;+constexpr uint32_t+    PythonOpenCensusCallTracer::PythonOpenCensusCallAttemptTracer::kMaxTagsLen;++//+// OpenCensusCallTracer+//++PythonOpenCensusCallTracer::PythonOpenCensusCallTracer(char* method, char* trace_id,+                                                       char* parent_span_id, bool tracing_enabled):+      method_(GetMethod(method)),+      tracing_enabled_(tracing_enabled) {+  GenerateClientContext(absl::StrCat(""Sent."", method_), absl::string_view(trace_id),+                        absl::string_view(parent_span_id), &context_);+}++void PythonOpenCensusCallTracer::GenerateContext() {}++void PythonOpenCensusCallTracer::RecordAnnotation(absl::string_view annotation) {+  // If tracing is disabled, the following will be a no-op.+  context_.AddSpanAnnotation(annotation);+}+++PythonOpenCensusCallTracer::~PythonOpenCensusCallTracer() {+  if (PythonOpenCensusStatsEnabled()) {+    std::vector<Label> labels = context_.Labels();+    labels.emplace_back(Label{kClientMethod, std::string(method_)});+    RecordIntMetric(kRpcClientRetriesPerCallMeasureName, retries_ - 1, labels); // exclude first attempt+    RecordIntMetric(kRpcClientTransparentRetriesPerCallMeasureName, transparent_retries_, labels);+    RecordDoubleMetric(kRpcClientRetryDelayPerCallMeasureName, ToDoubleMilliseconds(retry_delay_), labels);+  }++  if (tracing_enabled_) {+    context_.EndSpan();+    if (IsSampled()) {+      RecordSpan(context_.Span().ToCensusData());+    }+  }+}+++PythonCensusContext PythonOpenCensusCallTracer::CreateCensusContextForCallAttempt() {+  auto context = PythonCensusContext(absl::StrCat(""Attempt."", method_), &(context_.Span()), context_.Labels());+  return context;+}+++PythonOpenCensusCallTracer::PythonOpenCensusCallAttemptTracer*+PythonOpenCensusCallTracer::StartNewAttempt(bool is_transparent_retry) {+  uint64_t attempt_num;+  {+    grpc_core::MutexLock lock(&mu_);+    if (transparent_retries_ != 0 || retries_ != 0) {+      if (PythonOpenCensusStatsEnabled() && num_active_rpcs_ == 0) {+        retry_delay_ += absl::Now() - time_at_last_attempt_end_;+      }+    }+    attempt_num = retries_;+    if (is_transparent_retry) {+      ++transparent_retries_;+    } else {+      ++retries_;+    }+    ++num_active_rpcs_;+  }+  context_.AddChildSpan();+  return new PythonOpenCensusCallAttemptTracer(+      this, attempt_num, is_transparent_retry);+}++//+// PythonOpenCensusCallTracer::PythonOpenCensusCallAttemptTracer+//++PythonOpenCensusCallTracer::PythonOpenCensusCallAttemptTracer::PythonOpenCensusCallAttemptTracer(+    PythonOpenCensusCallTracer* parent, uint64_t attempt_num, bool is_transparent_retry)+    : parent_(parent),+      context_(parent_->CreateCensusContextForCallAttempt()),+      start_time_(absl::Now()) {+  if (parent_->tracing_enabled_) {+    context_.AddSpanAttribute(""previous-rpc-attempts"", std::to_string(attempt_num));+    context_.AddSpanAttribute(""transparent-retry"", std::to_string(is_transparent_retry));+  }+  if (PythonOpenCensusStatsEnabled()) {+    std::vector<Label> labels = context_.Labels();+    labels.emplace_back(Label{kClientMethod, std::string(parent_->method_)});+    RecordIntMetric(kRpcClientStartedRpcsMeasureName, 1, labels);+  }+}+++void PythonOpenCensusCallTracer::PythonOpenCensusCallAttemptTracer::+    RecordSendInitialMetadata(grpc_metadata_batch* send_initial_metadata) {+  if (parent_->tracing_enabled_) {+    char tracing_buf[kMaxTraceContextLen];+    size_t tracing_len = TraceContextSerialize(context_, tracing_buf,+                                               kMaxTraceContextLen);+    if (tracing_len > 0) {+      send_initial_metadata->Set(+          grpc_core::GrpcTraceBinMetadata(),+          grpc_core::Slice::FromCopiedBuffer(tracing_buf, tracing_len));+    }+  }+  if (PythonOpenCensusStatsEnabled()) {+    grpc_slice tags = grpc_empty_slice();+    size_t encoded_tags_len = StatsContextSerialize(kMaxTagsLen, &tags);+    if (encoded_tags_len > 0) {+      send_initial_metadata->Set(grpc_core::GrpcTagsBinMetadata(),+                                 grpc_core::Slice(tags));+    }+  }+}+++void PythonOpenCensusCallTracer::PythonOpenCensusCallAttemptTracer::RecordSendMessage(+    const grpc_core::SliceBuffer& /*send_message*/) {+  ++sent_message_count_;+}+++void PythonOpenCensusCallTracer::PythonOpenCensusCallAttemptTracer::RecordReceivedMessage(+    const grpc_core::SliceBuffer& /*recv_message*/) {+  ++recv_message_count_;+}+++namespace {++void FilterTrailingMetadata(grpc_metadata_batch* b, uint64_t* elapsed_time) {","The name `FilterTrailingMetadata` doesn't really capture what this is doing. It seems like what this really does is extract the elapsed time from the trailing metadata with the benign side effect of removing the `GrpcServerStatsBin` key from the trailing metadata `GrpcServerStatsBin`.I'm guessing that `elapsed_time` here is an [outparam](https://learn.microsoft.com/en-us/cpp/dotnet/how-to-specify-an-out-parameter?view=msvc-170) because that's the way `grpc::internal::RpcServerStatsEncoding::Decode` happens to be structured (because it needs to return multiple values). Since this is a single int, we can wrap that up pretty easily.It also seems like we don't need to remove the key-value pair from the metadata, so we can use `get` instead of `Take` and completely remove the mutable parameters to this function.```c++// Returns 0 if no server stats are present in the metadata.uint64_t ElapsedTimeFromTrailingMetadata(const grpc_metadata_batch* b) {  if (!PythonOpenCensusStatsEnabled())    return 0;  absl::optional<grpc_core::Slice> grpc_server_stats_bin =      b->get(grpc_core::GrpcServerStatsBinMetadata());  if (!grpc_server_stats_bin.has_value())    return 0;  int elapsed_time = 0;  ServerStatsDeserialize(      reinterpret_cast<const char*>(grpc_server_stats_bin->data()),      grpc_server_stats_bin->size(), &elapsed_time);  return elapsed_time;}```This is now a pure function, which should be preferred unless there are good reasons not to use them, such as performance.",X
1644595,gnossen,https://api.github.com/repos/grpc/grpc/pulls/32974,1195723888,2023-05-16T21:55:19Z,src/python/grpcio_observability/grpc_observability/observability_util.cc,"@@ -0,0 +1,189 @@+// Copyright 2023 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++#include ""src/python/grpcio_observability/grpc_observability/observability_util.h""+#include ""src/python/grpcio_observability/grpc_observability/server_call_tracer.h""+#include ""src/python/grpcio_observability/grpc_observability/client_call_tracer.h""++#include ""absl/strings/string_view.h""++namespace grpc_observability {++std::queue<CensusData>* g_census_data_buffer;+std::mutex g_census_data_buffer_mutex;+std::condition_variable g_census_data_buffer_cv;+// TODO(xuanwn): Change it to a more appropriate number+constexpr int kExportThreshold = 2;+++void RecordIntMetric(MetricsName name, int64_t value, std::vector<Label> labels) {+  Measurement measurement_data;+  measurement_data.type = kMeasurementInt;+  measurement_data.name = name;+  measurement_data.value.value_int = value;++  CensusData data = CensusData(measurement_data, labels);+  AddCensusDataToBuffer(data);+}+++void RecordDoubleMetric(MetricsName name, double value, std::vector<Label> labels) {+  Measurement measurement_data;+  measurement_data.type = kMeasurementDouble;+  measurement_data.name = name;+  measurement_data.value.value_double = value;++  CensusData data = CensusData(measurement_data, labels);+  AddCensusDataToBuffer(data);+}+++void RecordSpan(SpanCensusData span_census_data) {",Same comment. This is also doing a full copy of `span_census_data` and should be passing via const ref.,
1644595,gnossen,https://api.github.com/repos/grpc/grpc/pulls/32974,1195728047,2023-05-16T22:01:29Z,src/python/grpcio_observability/grpc_observability/observability_util.cc,"@@ -0,0 +1,189 @@+// Copyright 2023 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++#include ""src/python/grpcio_observability/grpc_observability/observability_util.h""+#include ""src/python/grpcio_observability/grpc_observability/server_call_tracer.h""+#include ""src/python/grpcio_observability/grpc_observability/client_call_tracer.h""++#include ""absl/strings/string_view.h""++namespace grpc_observability {++std::queue<CensusData>* g_census_data_buffer;+std::mutex g_census_data_buffer_mutex;+std::condition_variable g_census_data_buffer_cv;+// TODO(xuanwn): Change it to a more appropriate number+constexpr int kExportThreshold = 2;+++void RecordIntMetric(MetricsName name, int64_t value, std::vector<Label> labels) {+  Measurement measurement_data;+  measurement_data.type = kMeasurementInt;+  measurement_data.name = name;+  measurement_data.value.value_int = value;++  CensusData data = CensusData(measurement_data, labels);+  AddCensusDataToBuffer(data);+}+++void RecordDoubleMetric(MetricsName name, double value, std::vector<Label> labels) {+  Measurement measurement_data;+  measurement_data.type = kMeasurementDouble;+  measurement_data.name = name;+  measurement_data.value.value_double = value;++  CensusData data = CensusData(measurement_data, labels);+  AddCensusDataToBuffer(data);+}+++void RecordSpan(SpanCensusData span_census_data) {+  CensusData data = CensusData(span_census_data);+  AddCensusDataToBuffer(data);+}+++void NativeObservabilityInit() {+    g_census_data_buffer= new std::queue<CensusData>;+}+++void* CreateClientCallTracer(char* method, char* trace_id, char* parent_span_id) {",Please read up on [C++ const correctness](https://isocpp.org/wiki/faq/const-correctness). All three of these parameters should have type `const char*`,
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32701,1195739940,2023-05-16T22:20:32Z,src/core/lib/event_engine/grpc_polled_fd.h,"@@ -0,0 +1,73 @@+// Copyright 2023 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++#ifndef GRPC_SRC_CORE_LIB_EVENT_ENGINE_GRPC_POLLED_FD_H+#define GRPC_SRC_CORE_LIB_EVENT_ENGINE_GRPC_POLLED_FD_H++#include <grpc/support/port_platform.h>++#if GRPC_ARES == 1++#include <ares.h>++#include ""absl/functional/any_invocable.h""+#include ""absl/status/status.h""++#include ""src/core/lib/iomgr/error.h""++namespace grpc_event_engine {+namespace experimental {++// A wrapped fd that integrates with the grpc iomgr of the current platform.",Please update comment.  This no longer has anything to do with iomgr.,
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32701,1195745389,2023-05-16T22:27:08Z,src/core/lib/event_engine/grpc_ares_wrapper.h,"@@ -0,0 +1,340 @@+// Copyright 2023 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+#ifndef GRPC_SRC_CORE_LIB_EVENT_ENGINE_GRPC_ARES_WRAPPER_H+#define GRPC_SRC_CORE_LIB_EVENT_ENGINE_GRPC_ARES_WRAPPER_H++#include <grpc/support/port_platform.h>++#if GRPC_ARES == 1++#include <stddef.h>++#include <algorithm>+#include <memory>+#include <string>+#include <vector>++#include <ares.h>++#include ""absl/base/thread_annotations.h""+#include ""absl/functional/any_invocable.h""+#include ""absl/status/status.h""+#include ""absl/status/statusor.h""+#include ""absl/strings/string_view.h""+#include ""absl/types/optional.h""++#include <grpc/event_engine/event_engine.h>+#include <grpc/support/log.h>++#include ""src/core/lib/debug/trace.h""+#include ""src/core/lib/event_engine/grpc_polled_fd.h""+#include ""src/core/lib/gprpp/orphanable.h""+#include ""src/core/lib/gprpp/sync.h""++namespace grpc_event_engine {+namespace experimental {++extern grpc_core::TraceFlag grpc_trace_ares_wrapper;++#define GRPC_ARES_WRAPPER_TRACE_LOG(format, ...)                              \+  do {                                                                        \+    if (GRPC_TRACE_FLAG_ENABLED(grpc_trace_ares_wrapper)) {                   \+      gpr_log(GPR_INFO, ""(EventEngine c-ares wrapper) "" format, __VA_ARGS__); \+    }                                                                         \+  } while (0)++// Base class for the c-ares based DNS lookup functionality. This class is+// inherited by the concrete leaf classes below which each represents a+// different type of lookup (i.e. A/AAAA, SRV, TXT). One request object+// represents one lookup request for a specific name. GrpcAresRequest+// encapsulates the common logics to initialize and destroy the c-ares channel+// (one channel for one request). Sets the name servers configuration for the+// channel. And interacts with c-ares sockets/fds and the EventEngine poller. It+// also encapsulates logics to start and cancel timers.+class GrpcAresRequest+    : public grpc_core::InternallyRefCounted<GrpcAresRequest> {+ public:+  ~GrpcAresRequest() override;++  // Cancels an inflight request. Returns true if cancel succeeds and will start+  // the shutdown process. Returns false if the request is already finishing,+  // cancelled or shutdown.+  bool Cancel() ABSL_LOCKS_EXCLUDED(mu_);+  void Orphan() override {}","Why is this a no-op?  The expected pattern for `InternallyRefCounted<>` is for there to be an external ref held by the single external owner, and that ref is given up when the external owner orphans the object.  For details, see go/grpc-c-core-ref-counted-types-update.I think what we want here is for the `PosixDNSResolver` object to be responsible for calling `Orphan()` on the `GrpcAresRequest` object when it is no longer needed, either because the request has just completed or because the request was cancelled.  (Normally, I would say that `Orphan()` should automatically cancel if the request is still in flight, but in this case we need a separate `Cancel()` method in order to return a bool indicating whether cancellation was successful.  I would also normally suggest having `PosixDNSResolver` use `OrphanablePtr<>`, but that probably won't work in this case, since we need to hold a raw pointer in the task handle.)It's true that we don't strictly *need* to hold an external ref like this, but I think it makes the lifetime story here easier to understand.  In the current code, the ref-counting story is much harder to follow -- in fact, I'm not even sure I completely understand all of the rules from reading the code, and they don't seem to be written down anywhere.  Just as one example, I suspect that the weird way we're taking and then releasing a ref in `Start()` for each request type would not be needed.",
1644595,gnossen,https://api.github.com/repos/grpc/grpc/pulls/32974,1195746970,2023-05-16T22:30:03Z,src/python/grpcio_observability/grpc_observability/observability_util.h,"@@ -0,0 +1,113 @@+// Copyright 2023 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++// TODO(xuanwn): clean up includes+#include <stdint.h>+#include <queue>+#include <condition_variable>+#include <mutex>+#include <chrono>+#include <mutex>+#include <map>++#include <grpc/grpc.h>++#include ""absl/base/thread_annotations.h""+#include ""absl/status/status.h""+#include ""absl/strings/string_view.h""+#include ""absl/time/time.h""+#include ""absl/synchronization/mutex.h""+#include ""absl/strings/strip.h""+#include ""absl/strings/escaping.h""+#include ""absl/status/statusor.h""++#include ""src/core/lib/channel/call_tracer.h""+#include ""src/core/lib/channel/context.h""+#include ""src/cpp/ext/gcp/observability_config.h""++#include ""src/python/grpcio_observability/grpc_observability/python_census_context.h""+#include ""src/python/grpcio_observability/grpc_observability/constants.h""++#ifndef OBSERVABILITY_MAIN_H+#define OBSERVABILITY_MAIN_H++namespace grpc_observability {++struct CensusData {+  DataType type;+  std::vector<Label> labels;+  // TODO(xuanwn): We can use union here+  SpanCensusData span_data;+  Measurement measurement_data;+  CensusData() {}+  CensusData(Measurement mm, std::vector<Label> labels)",Both of these parameters should be passed by const ref.,
24593237,XuanWang-Amos,https://api.github.com/repos/grpc/grpc/pulls/32974,1195749610,2023-05-16T22:33:32Z,src/python/grpcio_observability/grpc_observability/client_call_tracer.cc,"@@ -0,0 +1,242 @@+// Copyright 2023 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++#include ""src/python/grpcio_observability/grpc_observability/client_call_tracer.h""++#include ""absl/strings/escaping.h""+#include ""absl/strings/string_view.h""++#include <limits.h>++#include <atomic>+++namespace grpc_observability {++constexpr uint32_t+    PythonOpenCensusCallTracer::PythonOpenCensusCallAttemptTracer::kMaxTraceContextLen;+constexpr uint32_t+    PythonOpenCensusCallTracer::PythonOpenCensusCallAttemptTracer::kMaxTagsLen;++//+// OpenCensusCallTracer+//++PythonOpenCensusCallTracer::PythonOpenCensusCallTracer(char* method, char* trace_id,+                                                       char* parent_span_id, bool tracing_enabled):+      method_(GetMethod(method)),+      tracing_enabled_(tracing_enabled) {+  GenerateClientContext(absl::StrCat(""Sent."", method_), absl::string_view(trace_id),+                        absl::string_view(parent_span_id), &context_);+}++void PythonOpenCensusCallTracer::GenerateContext() {}++void PythonOpenCensusCallTracer::RecordAnnotation(absl::string_view annotation) {+  // If tracing is disabled, the following will be a no-op.+  context_.AddSpanAnnotation(annotation);+}+++PythonOpenCensusCallTracer::~PythonOpenCensusCallTracer() {+  if (PythonOpenCensusStatsEnabled()) {+    std::vector<Label> labels = context_.Labels();+    labels.emplace_back(Label{kClientMethod, std::string(method_)});+    RecordIntMetric(kRpcClientRetriesPerCallMeasureName, retries_ - 1, labels); // exclude first attempt+    RecordIntMetric(kRpcClientTransparentRetriesPerCallMeasureName, transparent_retries_, labels);+    RecordDoubleMetric(kRpcClientRetryDelayPerCallMeasureName, ToDoubleMilliseconds(retry_delay_), labels);+  }++  if (tracing_enabled_) {+    context_.EndSpan();+    if (IsSampled()) {+      RecordSpan(context_.Span().ToCensusData());+    }+  }+}+++PythonCensusContext PythonOpenCensusCallTracer::CreateCensusContextForCallAttempt() {+  auto context = PythonCensusContext(absl::StrCat(""Attempt."", method_), &(context_.Span()), context_.Labels());","Not really, we'll create a new spanId for each individual attempts, the Span passed here will be used as [parent span](https://github.com/grpc/grpc/blob/b9d51cdfdd5f8c9c8bcbd717642de21f303402f6/src/python/grpcio_observability/grpc_observability/python_census_context.h#L222).",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32701,1195764873,2023-05-16T23:00:12Z,test/core/event_engine/test_suite/tests/dns_test.cc,"@@ -25,7 +63,529 @@ void InitDNSTests() {} }  // namespace experimental }  // namespace grpc_event_engine -class EventEngineDNSTest : public EventEngineTest {};+namespace {++// TODO(yijiem): build a portable solution for Windows+constexpr char kDNSTestRecordGroupsYamlPath[] =+    ""test/core/event_engine/test_suite/tests/dns_test_record_groups.yaml"";+constexpr char kHealthCheckRecordName[] =+    ""health-check-local-dns-server-is-alive.resolver-tests.grpctestingexp"";++// You know where this comes from.+template <typename T>+void WaitForSingleOwner(std::shared_ptr<T>&& object) {+  while (object.use_count() > 1) {+    GRPC_LOG_EVERY_N_SEC(2, GPR_INFO, ""engine.use_count() = %ld"",+                         object.use_count());+    absl::SleepFor(absl::Milliseconds(100));+  }+}++}  // namespace++class EventEngineDNSTest : public EventEngineTest {+ public:+  static void SetUpTestSuite() {+    // Invoke bazel's executeable links to the .sh and .py scripts (don't use+    // the .sh and .py suffixes) to make sure that we're using bazel's test+    // environment.+    std::string kPythonWrapper = ""tools/distrib/python_wrapper"";+    std::string kDNSServerPath = ""test/cpp/naming/utils/dns_server"";+    std::string kDNSResolverPath = ""test/cpp/naming/utils/dns_resolver"";+    std::string kTCPConnectPath = ""test/cpp/naming/utils/tcp_connect"";+    // HACK: Hyrum's law.+    if (!grpc_core::GetEnv(""TEST_SRCDIR"").has_value()) {+      // Invoke the .sh and .py scripts directly where they are in source code.+      kPythonWrapper += "".sh"";+      kDNSServerPath += "".py"";+      kDNSResolverPath += "".py"";+      kTCPConnectPath += "".py"";+    }+    // 1. launch dns_server+    int port = grpc_pick_unused_port_or_die();+    ASSERT_NE(port, 0)+        << ""pick unused port failed, maybe the port server is not running? ""+           ""Start it with tools/run_tests/start_port_server.py"";+    // <path to python wrapper> <path to dns_server.py> -p <port> -r <path to+    // records config>+    _dns_server.server_process = new grpc::SubProcess(+        {kPythonWrapper, kDNSServerPath, ""-p"", std::to_string(port), ""-r"",+         kDNSTestRecordGroupsYamlPath});+    // TODO(yijiem): no way to check whether it fails or not+    _dns_server.port = port;++    // 2. wait until dns_server is up (health check)+    bool health_check_succeed = false;+    for (int i = 0; i < 10; i++) {+      // 2.1 tcp connect succeeds+      // <path to python wrapper> <path to tcp_connect.py> -s <hostname> -p+      // <port>+      grpc::SubProcess tcp_connect({kPythonWrapper, kTCPConnectPath, ""-s"",+                                    ""localhost"", ""-p"", std::to_string(port)});+      // TODO(yijiem): no way to check whether it fails or not+      if (tcp_connect.Join()) {+        // 2.2 make an A-record query to dns_server+        // <path to python wrapper> <path to dns_resolver.py> -s <hostname> -p+        // <port> -n <domain name to query>+        std::string command = absl::StrJoin(+            {kPythonWrapper.c_str(), kDNSResolverPath.c_str(), ""-s"",+             ""127.0.0.1"", ""-p"", std::to_string(port).c_str(), ""-n"",+             kHealthCheckRecordName},+            "" "");+        // TODO(yijiem): build a portable solution for Windows+        FILE* f = popen(command.c_str(), ""r"");",Can we use the same infrastructure as resolver_component_test here?  It would be better to avoid reinventing any wheels here.,
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32970,1195793486,2023-05-16T23:59:32Z,src/core/ext/xds/xds_audit_logger_registry.cc,"@@ -93,9 +92,17 @@ Json XdsAuditLoggerRegistry::ConvertXdsAuditLoggerConfig(       auto config_factory_it =           audit_logger_config_factories_.find(extension->type);       if (config_factory_it != audit_logger_config_factories_.end()) {-        return Json::FromObject(+        auto json_config = Json::FromObject(             config_factory_it->second->ConvertXdsAuditLoggerConfig(                 context, *serialized_value, errors));+        auto result = AuditLoggerRegistry::ParseConfig(","This code is essentially the same as what we have for custom loggers on lines 112-118 below.  I suggest restructuring to avoid the duplication, using something like this (see our [`Match()` function](https://github.com/grpc/grpc/blob/master/src/core/lib/gprpp/match.h)):```// Find gRPC logger name and config.absl::string_view name;Json config;Match(    extension->value,    // Registered logger type.    [&](absl::string_view serialized_value) {      auto it = audit_logger_config_factories_.find(extension->type);      if (it == audit_logger_config_factories_.end()) return;      name = it->second->name();      config = Json::FromObject(          it->second->ConvertXdsAuditLoggerConfig(              context, *serialized_value, errors));    },    // Custom logger type.    [&](const Json& json) {      if (!AuditLoggerRegistry::FactoryExists(extension->type)) return;      name = extension->type;      config = json;    });// If we didn't find a config, return here, adding an error if appropriate.if (name.empty()) {  if (!envoy_config_rbac_v3_RBAC_AuditLoggingOptions_AuditLoggerConfig_is_optional(          logger_config)) {    errors->AddError(""unsupported audit logger type"");  }  return Json();}// If we found a config, verify that it parses properly.auto result = AuditLoggerRegistry::ParseConfig(name, config);if (!result.ok()) {  errors->AddError(result.status().message());  return Json();}return Json::FromObject({{std::string(name), std::move(config)}});```",X
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/33154,1195794992,2023-05-17T00:02:41Z,src/core/lib/channel/channel_args.h,"@@ -281,7 +281,7 @@ class ChannelArgs {     const grpc_arg_pointer_vtable* vtable_;   }; -  using Value = absl::variant<int, std::string, Pointer>;+  using Value = absl::variant<int, std::shared_ptr<const std::string>, Pointer>;",We could not expose `Value` or write a class for it.,
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/33145,1195809385,2023-05-17T00:35:51Z,src/core/ext/filters/rbac/rbac_service_config_parser.cc,"@@ -750,6 +806,15 @@ void RbacConfig::RbacPolicy::Rules::JsonPostLoad(const Json&, const JsonArgs&,     ValidationErrors::ScopedField field(errors, "".action"");     errors->AddError(""unknown action"");   }+  auto rbac_audit_condition =+      static_cast<Rbac::AuditCondition>(audit_condition);","I don't think this is quite safe.  If the value of `audit_condition` does not fit into the size the compiler allocates for the `Rbac::AuditCondition` enum, then the `static_cast<>` could truncate the value, and we might wind up treating an invalid value as valid.I think a better way to do this would be something like this:```switch (audit_condition) {  case Rbac::AuditCondition::kNone:  case Rbac::AuditCondition::kOnAllow:  case Rbac::AuditCondition::kOnDeny:  case Rbac::AuditCondition::kOnDenyAndAllow:    break;  default: {    ValidationErrors::ScopedField field(errors, "".audit_condition"");    errors->AddError(""unknown audit condition"");  }}```",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/33154,1195813988,2023-05-17T00:47:09Z,src/core/lib/channel/channel_args.h,"@@ -281,7 +281,7 @@ class ChannelArgs {     const grpc_arg_pointer_vtable* vtable_;   }; -  using Value = absl::variant<int, std::string, Pointer>;+  using Value = absl::variant<int, std::shared_ptr<const std::string>, Pointer>;",Ended up needing to wrap it in a class anyway to get equality right.,
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/33145,1195821422,2023-05-17T01:00:15Z,test/core/ext/filters/rbac/rbac_service_config_parser_test.cc,"@@ -638,6 +640,138 @@ TEST(RbacServiceConfigParsingTest, StringMatcherBadTypes) {       << service_config.status(); } +TEST(RbacServiceConfigParsingTest, AuditConditionOnDenyWithMultipleLoggers) {+  const char* test_json =+      ""{\n""+      ""  \""methodConfig\"": [ {\n""+      ""    \""name\"": [\n""+      ""      {}\n""+      ""    ],\n""+      ""    \""rbacPolicy\"": [ {\n""+      ""      \""filter_name\"": \""rbac\"",\n""+      ""      \""rules\"":{\n""+      ""        \""action\"":1,\n""+      ""        \""audit_condition\"":1,\n""+      ""        \""audit_loggers\"":[ \n""+      ""          {\n""+      ""            \""stdout_logger\"": {},\n""+      ""          },\n""+      ""          {\n""+      ""            \""stdout_logger\"": {}\n""+      ""          }\n""+      ""        ]\n""+      ""      }\n""+      ""    } ]\n""+      ""  } ]\n""+      ""}"";+  ChannelArgs args = ChannelArgs().Set(GRPC_ARG_PARSE_RBAC_METHOD_CONFIG, 1);+  auto service_config = ServiceConfigImpl::Create(args, test_json);+  ASSERT_TRUE(service_config.status().ok());+  const auto* vector_ptr =+      (*service_config)->GetMethodParsedConfigVector(grpc_empty_slice());+  ASSERT_NE(vector_ptr, nullptr);+  auto* parsed_rbac_config = static_cast<RbacMethodParsedConfig*>(+      ((*vector_ptr)[RbacServiceConfigParser::ParserIndex()]).get());+  ASSERT_NE(parsed_rbac_config, nullptr);+  ASSERT_NE(parsed_rbac_config->authorization_engine(0), nullptr);+  EXPECT_EQ(parsed_rbac_config->authorization_engine(0)->audit_condition(),+            Rbac::AuditCondition::kOnDeny);+  EXPECT_EQ(parsed_rbac_config->authorization_engine(0)->num_audit_loggers(),+            2);+}++TEST(RbacServiceConfigParsingTest, BadAuditConditionAndLoggersTypes) {+  const char* test_json =+      ""{\n""+      ""  \""methodConfig\"": [ {\n""+      ""    \""name\"": [\n""+      ""      {}\n""+      ""    ],\n""+      ""    \""rbacPolicy\"": [ {\n""+      ""      \""filter_name\"": \""rbac\"",\n""+      ""      \""rules\"":{\n""+      ""        \""action\"":1,\n""+      ""        \""audit_condition\"":{},\n""+      ""        \""audit_loggers\"":{}\n""+      ""      }\n""+      ""    } ]\n""+      ""  } ]\n""+      ""}"";+  ChannelArgs args = ChannelArgs().Set(GRPC_ARG_PARSE_RBAC_METHOD_CONFIG, 1);+  auto service_config = ServiceConfigImpl::Create(args, test_json);+  EXPECT_EQ(service_config.status().code(), absl::StatusCode::kInvalidArgument);+  EXPECT_EQ(service_config.status().message(),+            ""errors validating service config: [""+            ""field:methodConfig[0].rbacPolicy[0].rules.audit_condition ""+            ""error:is not a number; ""+            ""field:methodConfig[0].rbacPolicy[0].rules.audit_loggers ""+            ""error:is not an array]"")+      << service_config.status();+}++TEST(RbacServiceConfigParsingTest, BadAuditConditionEnum) {+  const char* test_json =+      ""{\n""+      ""  \""methodConfig\"": [ {\n""+      ""    \""name\"": [\n""+      ""      {}\n""+      ""    ],\n""+      ""    \""rbacPolicy\"": [ {\n""+      ""      \""filter_name\"": \""rbac\"",\n""+      ""      \""rules\"":{\n""+      ""        \""action\"":1,\n""+      ""        \""audit_condition\"":100\n""+      ""      }\n""+      ""    } ]\n""+      ""  } ]\n""+      ""}"";+  ChannelArgs args = ChannelArgs().Set(GRPC_ARG_PARSE_RBAC_METHOD_CONFIG, 1);+  auto service_config = ServiceConfigImpl::Create(args, test_json);+  EXPECT_EQ(service_config.status().code(), absl::StatusCode::kInvalidArgument);+  EXPECT_EQ(service_config.status().message(),+            ""errors validating service config: [""+            ""field:methodConfig[0].rbacPolicy[0].rules.audit_condition ""+            ""error:unknown audit condition]"")+      << service_config.status();+}++TEST(RbacServiceConfigParsingTest, BadAuditLoggerObject) {",Let's also test the cases of an unsupported audit logger type and a supported audit logger type with a bad config.  (That latter case will probably require inserting a custom type into the registry.),
4181124,yashykt,https://api.github.com/repos/grpc/grpc/pulls/33149,1195888156,2023-05-17T03:28:31Z,test/core/util/osa_distance.cc,"@@ -42,28 +42,34 @@ size_t OsaDistance(absl::string_view s1, absl::string_view s2) {   if (s1.size() > s2.size()) std::swap(s1, s2);   if (s1.empty()) return static_cast<uint8_t>(s2.size()); -  Matrix d(s1.size() + 1, s2.size() + 1);-  d(0, 0) = 0;+  const auto width = s1.size() + 1;+  const auto height = s2.size() + 1;+  std::vector<size_t> matrix(width * height,",Matrix class is unused now?,X
7221003,rockspore,https://api.github.com/repos/grpc/grpc/pulls/32970,1195922649,2023-05-17T04:40:39Z,src/core/ext/xds/xds_audit_logger_registry.cc,"@@ -93,9 +92,17 @@ Json XdsAuditLoggerRegistry::ConvertXdsAuditLoggerConfig(       auto config_factory_it =           audit_logger_config_factories_.find(extension->type);       if (config_factory_it != audit_logger_config_factories_.end()) {-        return Json::FromObject(+        auto json_config = Json::FromObject(             config_factory_it->second->ConvertXdsAuditLoggerConfig(                 context, *serialized_value, errors));+        auto result = AuditLoggerRegistry::ParseConfig(",I basically took your suggestion. Feels great to learn nice patterns like this. Thanks for the tip!,
7221003,rockspore,https://api.github.com/repos/grpc/grpc/pulls/33145,1196806417,2023-05-17T16:47:45Z,test/core/ext/filters/rbac/rbac_service_config_parser_test.cc,"@@ -638,6 +640,138 @@ TEST(RbacServiceConfigParsingTest, StringMatcherBadTypes) {       << service_config.status(); } +TEST(RbacServiceConfigParsingTest, AuditConditionOnDenyWithMultipleLoggers) {+  const char* test_json =+      ""{\n""+      ""  \""methodConfig\"": [ {\n""+      ""    \""name\"": [\n""+      ""      {}\n""+      ""    ],\n""+      ""    \""rbacPolicy\"": [ {\n""+      ""      \""filter_name\"": \""rbac\"",\n""+      ""      \""rules\"":{\n""+      ""        \""action\"":1,\n""+      ""        \""audit_condition\"":1,\n""+      ""        \""audit_loggers\"":[ \n""+      ""          {\n""+      ""            \""stdout_logger\"": {},\n""+      ""          },\n""+      ""          {\n""+      ""            \""stdout_logger\"": {}\n""+      ""          }\n""+      ""        ]\n""+      ""      }\n""+      ""    } ]\n""+      ""  } ]\n""+      ""}"";+  ChannelArgs args = ChannelArgs().Set(GRPC_ARG_PARSE_RBAC_METHOD_CONFIG, 1);+  auto service_config = ServiceConfigImpl::Create(args, test_json);+  ASSERT_TRUE(service_config.status().ok());+  const auto* vector_ptr =+      (*service_config)->GetMethodParsedConfigVector(grpc_empty_slice());+  ASSERT_NE(vector_ptr, nullptr);+  auto* parsed_rbac_config = static_cast<RbacMethodParsedConfig*>(+      ((*vector_ptr)[RbacServiceConfigParser::ParserIndex()]).get());+  ASSERT_NE(parsed_rbac_config, nullptr);+  ASSERT_NE(parsed_rbac_config->authorization_engine(0), nullptr);+  EXPECT_EQ(parsed_rbac_config->authorization_engine(0)->audit_condition(),+            Rbac::AuditCondition::kOnDeny);+  EXPECT_EQ(parsed_rbac_config->authorization_engine(0)->num_audit_loggers(),+            2);+}++TEST(RbacServiceConfigParsingTest, BadAuditConditionAndLoggersTypes) {+  const char* test_json =+      ""{\n""+      ""  \""methodConfig\"": [ {\n""+      ""    \""name\"": [\n""+      ""      {}\n""+      ""    ],\n""+      ""    \""rbacPolicy\"": [ {\n""+      ""      \""filter_name\"": \""rbac\"",\n""+      ""      \""rules\"":{\n""+      ""        \""action\"":1,\n""+      ""        \""audit_condition\"":{},\n""+      ""        \""audit_loggers\"":{}\n""+      ""      }\n""+      ""    } ]\n""+      ""  } ]\n""+      ""}"";+  ChannelArgs args = ChannelArgs().Set(GRPC_ARG_PARSE_RBAC_METHOD_CONFIG, 1);+  auto service_config = ServiceConfigImpl::Create(args, test_json);+  EXPECT_EQ(service_config.status().code(), absl::StatusCode::kInvalidArgument);+  EXPECT_EQ(service_config.status().message(),+            ""errors validating service config: [""+            ""field:methodConfig[0].rbacPolicy[0].rules.audit_condition ""+            ""error:is not a number; ""+            ""field:methodConfig[0].rbacPolicy[0].rules.audit_loggers ""+            ""error:is not an array]"")+      << service_config.status();+}++TEST(RbacServiceConfigParsingTest, BadAuditConditionEnum) {+  const char* test_json =+      ""{\n""+      ""  \""methodConfig\"": [ {\n""+      ""    \""name\"": [\n""+      ""      {}\n""+      ""    ],\n""+      ""    \""rbacPolicy\"": [ {\n""+      ""      \""filter_name\"": \""rbac\"",\n""+      ""      \""rules\"":{\n""+      ""        \""action\"":1,\n""+      ""        \""audit_condition\"":100\n""+      ""      }\n""+      ""    } ]\n""+      ""  } ]\n""+      ""}"";+  ChannelArgs args = ChannelArgs().Set(GRPC_ARG_PARSE_RBAC_METHOD_CONFIG, 1);+  auto service_config = ServiceConfigImpl::Create(args, test_json);+  EXPECT_EQ(service_config.status().code(), absl::StatusCode::kInvalidArgument);+  EXPECT_EQ(service_config.status().message(),+            ""errors validating service config: [""+            ""field:methodConfig[0].rbacPolicy[0].rules.audit_condition ""+            ""error:unknown audit condition]"")+      << service_config.status();+}++TEST(RbacServiceConfigParsingTest, BadAuditLoggerObject) {",Added a test logger factory to verify config as well as rejecting bad configs. PTAL.,
7221003,rockspore,https://api.github.com/repos/grpc/grpc/pulls/33145,1196809731,2023-05-17T16:50:55Z,src/core/ext/filters/rbac/rbac_service_config_parser.cc,"@@ -750,6 +806,15 @@ void RbacConfig::RbacPolicy::Rules::JsonPostLoad(const Json&, const JsonArgs&,     ValidationErrors::ScopedField field(errors, "".action"");     errors->AddError(""unknown action"");   }+  auto rbac_audit_condition =+      static_cast<Rbac::AuditCondition>(audit_condition);",I took your suggestion here but it looks a bit different since I changed the type of audit_condition to `Rbac::AuditCondition` and manually parsed it in post loading. PTAL.,
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/33145,1196867413,2023-05-17T17:45:15Z,src/core/ext/filters/rbac/rbac_service_config_parser.cc,"@@ -806,14 +799,46 @@ void RbacConfig::RbacPolicy::Rules::JsonPostLoad(const Json&, const JsonArgs&,     ValidationErrors::ScopedField field(errors, "".action"");     errors->AddError(""unknown action"");   }-  auto rbac_audit_condition =-      static_cast<Rbac::AuditCondition>(audit_condition);-  if (rbac_audit_condition != Rbac::AuditCondition::kNone &&-      rbac_audit_condition != Rbac::AuditCondition::kOnAllow &&-      rbac_audit_condition != Rbac::AuditCondition::kOnDeny &&-      rbac_audit_condition != Rbac::AuditCondition::kOnDenyAndAllow) {-    ValidationErrors::ScopedField field(errors, "".audit_condition"");-    errors->AddError(""unknown audit condition"");+  // Parse and validate audit_condition field.+  auto it = json.object().find(""audit_condition"");","Suggest writing this as:```auto condition = LoadJsonObjectField<int>(json.object(), args, ""audit_condition"", errors);if (condition.has_value()) {  switch (*condition) {    case static_cast<int>(Rbac::AuditCondition::kNone):    case static_cast<int>(Rbac::AuditCondition::kOnAllow):    case static_cast<int>(Rbac::AuditCondition::kOnDeny):    case static_cast<int>(Rbac::AuditCondition::kOnDenyAndAllow):      audit_condition = static_cast<Rbac::AuditCondition>(*condition);      break;    default: {      ValidationErrors::ScopedField field(errors, "".audit_condition"");      errors->AddError(""invalid value"");    }  }}```",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/33145,1196886115,2023-05-17T18:02:34Z,src/core/lib/security/authorization/grpc_authorization_engine.h,"@@ -56,6 +56,12 @@ class GrpcAuthorizationEngine : public AuthorizationEngine {   // Required only for testing purpose.   size_t num_policies() const { return policies_.size(); } +  // Required only for testing purpose.+  Rbac::AuditCondition audit_condition() const { return audit_condition_; }++  // Required only for testing purpose.+  size_t num_audit_loggers() const { return audit_loggers_.size(); }","Ah, right, I somehow thought this object was storing the configs, not the actual logger instances.The change you made it useful, but let's also do this: Add a `name()` method to the logger itself, and then expose the list of loggers here.  That way, we can also verify the order of the loggers, at least in cases where there are not two instances of the same logger type.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/33145,1196894138,2023-05-17T18:11:11Z,src/core/ext/filters/rbac/rbac_service_config_parser.cc,"@@ -716,28 +735,65 @@ const JsonLoaderInterface* RbacConfig::RbacPolicy::Rules::Policy::JsonLoader(   return loader; } +//+// RbacConfig::RbacPolicy::Rules::AuditLogger+//++const JsonLoaderInterface*+RbacConfig::RbacPolicy::Rules::AuditLogger::JsonLoader(const JsonArgs&) {+  // All fields handled in JsonPostLoad().+  static const auto* loader = JsonObjectLoader<AuditLogger>().Finish();+  return loader;+}++void RbacConfig::RbacPolicy::Rules::AuditLogger::JsonPostLoad(+    const Json& json, const JsonArgs& args, ValidationErrors* errors) {+  // Should have exactly one field as the logger name.+  if (json.object().size() != 1) {+    errors->AddError(""audit logger should have exactly one field"");+    return;+  }+  name = json.object().begin()->first;+  auto config_or =+      LoadJsonObjectField<Json::Object>(json.object(), args, name, errors);+  if (config_or.has_value()) {+    config = std::move(config_or.value());+  }+}+ // // RbacConfig::RbacPolicy::Rules // -Rbac RbacConfig::RbacPolicy::Rules::TakeAsRbac() {+Rbac RbacConfig::RbacPolicy::Rules::TakeAsRbac(std::string name) {   Rbac rbac;-  // TODO(lwge): This is to fix msan failure for now. Add proper conversion once-  // audit logging support is added.-  rbac.audit_condition = Rbac::AuditCondition::kNone;+  rbac.name = std::move(name);   rbac.action = static_cast<Rbac::Action>(action);+  rbac.audit_condition = static_cast<Rbac::AuditCondition>(audit_condition);   for (auto& p : policies) {     rbac.policies.emplace(p.first, p.second.TakeAsRbacPolicy());   }+  for (auto& logger : audit_loggers) {+    auto config_or = AuditLoggerRegistry::ParseConfig(+        logger.name, Json::FromObject(std::move(logger.config)));+    // The config should have been validated when the service config is","I agree that this doesn't make a difference in practice, since the only way to configure this filter is via xDS.  However, more generally, our current code is designed to pass the configs to the xDS HTTP filters via the service config, so that if we have cause to in the future, it won't be hard to allow the filter to also be configured in non-xDS cases.  In the case of this particular filter, it seems unlikely that we would ever want to configure it in a non-xDS case, since users would probably just use the SDK authz API instead, but I'd prefer to keep everything structured in a consistent way.(It is also worth noting that the other languages don't do it this way; they actually create interceptors for the xDS HTTP filters somewhat dynamically for each request, so they don't have to pass the config down like this.  Currently, C-core can't do it that way, since our filters need to be instantiated when the channel stack is instantiated, which is before we choose the config for each request.  But once we're done converting our stack from the legacy filter API to the new promise-based filter API, we probably will be able to do something like the other languages.  And at that point, we'll have to have a cross-language conversation about whether or not that's what we want, since it would remove the potential to be able to configure these filters via service config if we wanted to do that at some point in the future.  But it certainly would remove a lot of code for encoding the config in JSON and then re-parsing it in the filter.)Anyway, the changes you made here look good!",
7221003,rockspore,https://api.github.com/repos/grpc/grpc/pulls/33145,1196946024,2023-05-17T19:01:53Z,src/core/ext/filters/rbac/rbac_service_config_parser.cc,"@@ -806,14 +799,46 @@ void RbacConfig::RbacPolicy::Rules::JsonPostLoad(const Json&, const JsonArgs&,     ValidationErrors::ScopedField field(errors, "".action"");     errors->AddError(""unknown action"");   }-  auto rbac_audit_condition =-      static_cast<Rbac::AuditCondition>(audit_condition);-  if (rbac_audit_condition != Rbac::AuditCondition::kNone &&-      rbac_audit_condition != Rbac::AuditCondition::kOnAllow &&-      rbac_audit_condition != Rbac::AuditCondition::kOnDeny &&-      rbac_audit_condition != Rbac::AuditCondition::kOnDenyAndAllow) {-    ValidationErrors::ScopedField field(errors, "".audit_condition"");-    errors->AddError(""unknown audit condition"");+  // Parse and validate audit_condition field.+  auto it = json.object().find(""audit_condition"");","I didn't realize I could do `auto condition = LoadJsonObjectField<int>(json.object(), args, ""audit_condition"", errors, false);` to make the field optional. That was why I manually processed it. Fixed now with your suggestion. Note I still put the error msg as `unknown audit condition` to be consistent with the `unknown action`.",
7221003,rockspore,https://api.github.com/repos/grpc/grpc/pulls/33145,1196948110,2023-05-17T19:04:12Z,src/core/ext/filters/rbac/rbac_service_config_parser.cc,"@@ -198,8 +200,8 @@ struct RbacConfig {       int action;       std::map<std::string, Policy> policies;       // Defaults to 0 since its json field is optional.-      int audit_condition = 0;-      std::vector<AuditLogger> audit_loggers;+      Rbac::AuditCondition audit_condition;",I was always assigning it with the `condition` which was initialized to `static_cast<int>(kNone)` in post loading. But I think initializing it here is indeed more readable. Changed accordingly.,
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/33161,1196967619,2023-05-17T19:26:27Z,test/core/end2end/fuzzers/api_fuzzer.proto,"@@ -95,12 +85,12 @@ message Metadatum {  message CreateChannel {     string target = 1;-    repeated ChannelArg channel_args = 2;+    grpc.testing.FuzzingChannelArgs channel_args = 2;","Given that the api fuzzer corpus only has 2 items with channel_args specified, I'd be more inclined to change those two to match the new format than to keep the tech debt of both ChannelArgs proto specifications. And I also trust Craig that the entries would be regenerated pretty quickly if regressions occurred.We could aim for backwards compatibility with the text-protos that we keep in the corpus, but I think managing the collection would be a bit messier - each fuzzer would have a collection of `FuzzingChannelArg`, instead of a single `FuzzingChannelArgs`, and we might need a templated creation method.",
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/33151,1197062108,2023-05-17T21:17:35Z,test/core/ext/filters/client_channel/service_config/service_config_fuzzer.cc,"@@ -0,0 +1,57 @@+// Copyright 2023 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+#include <grpc/support/port_platform.h>++#include <string>++#include ""absl/status/statusor.h""+#include ""google/protobuf/json/json.h""++#include <grpc/grpc.h>++#include ""src/core/ext/filters/client_channel/resolver/dns/event_engine/service_config_helper.h""+#include ""src/libfuzzer/libfuzzer_macro.h""+#include ""src/proto/grpc/service_config/service_config.pb.h""+#include ""test/core/ext/filters/client_channel/service_config/service_config_fuzzer.pb.h""++constexpr char g_grpc_config_prefix[] = ""grpc_config="";++DEFINE_PROTO_FUZZER(const service_config_fuzzer::Msg& msg) {+  std::string payload;+  if (msg.has_fuzzed_service_config()) {+    ::google::protobuf::json::PrintOptions print_options;+    auto status = MessageToJsonString(msg.fuzzed_service_config(), &payload,","That's a really good point. If we wanted to test `ChooseServiceConfig` to exercise the client channel resolver's behavior, we'd want an array of annotated service configs as defined here https://github.com/grpc/proposal/blob/master/A2-service-configs-in-dns.md?plain=1#L44.What do you think about testing both `ChooseServiceConfig` and `ServiceConfigImpl::Create` in the same fuzzer? The `ChooseServiceConfig` test is a small superset of what the other would do.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32973,1197062601,2023-05-17T21:18:20Z,src/core/ext/filters/client_channel/resolver/xds/xds_resolver.h,"@@ -40,6 +41,31 @@ class XdsClusterAttribute    absl::string_view cluster_; };++class ClusterRef;+class RouteData;++class XdsClusterDataAttribute+    : public ServiceConfigCallData::CallAttributeInterface {+ public:+  static UniqueTypeName TypeName();++  explicit XdsClusterDataAttribute(RefCountedPtr<RouteData> route_data,+                                   void* route);++  // This method can be called only once. The first call will release the+  // reference to the cluster map, and subsequent calls will return nullptr.+  RefCountedPtr<ClusterRef> LockAndGetCluster(absl::string_view cluster_name);++  bool HasClusterForRoute(absl::string_view cluster_name) const;++  UniqueTypeName type() const override { return TypeName(); }++ private:+  RefCountedPtr<RouteData> route_data_;+  // No need to leak another type","I think we should generally avoid type leakage via visibility, not via losing type safety.A better option here would be to define an interface here and then a concrete implementation in the .cc file.  For example:```class XdsRouteStateAttribute    : public ServiceConfigCallData::CallAttributeInterface { public:  static UniqueTypeName TypeName();  UniqueTypeName type() const override { return TypeName(); }  virtual bool HasClusterForRoute(absl::string_view cluster_name) const = 0;};```Then in the .cc file:```class XdsRouteStateAttributeImpl : public XdsRouteStateAttribute { public:  XdsRouteStateAttributeImpl(      RefCountedPtr<RouteData> route_data,      RouteData::Route* route)      : route_data_(std::move(route_data)), route_(route) {}  bool HasClusterForRoute(absl::string_view cluster_name) const override;  RefCountedPtr<ClusterRef> LockAndGetCluster(absl::string_view cluster_name); private:  RefCountedPtr<RouteData> route_data_;  RouteData::Route* route_;};```The code in the xds resolver can instantiate the attribute using `XdsRouteStateAttributeImpl`, the code in the cluster selection filter can down-cast the attribute to `XdsRouteStateAttributeImpl`, and the code in the stateful session filter can down-cast the attribute to `XdsRouteStateAttribute`.This way, we don't need to expose the `RouteData` or `ClusterRef` types at all, even just as forward declarations, and we don't lose any type safety.  The only overhead is a virtual function call in the stateful session filter, which should be fine.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/33151,1197088652,2023-05-17T21:52:31Z,test/core/ext/filters/client_channel/service_config/service_config_fuzzer.cc,"@@ -0,0 +1,57 @@+// Copyright 2023 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+#include <grpc/support/port_platform.h>++#include <string>++#include ""absl/status/statusor.h""+#include ""google/protobuf/json/json.h""++#include <grpc/grpc.h>++#include ""src/core/ext/filters/client_channel/resolver/dns/event_engine/service_config_helper.h""+#include ""src/libfuzzer/libfuzzer_macro.h""+#include ""src/proto/grpc/service_config/service_config.pb.h""+#include ""test/core/ext/filters/client_channel/service_config/service_config_fuzzer.pb.h""++constexpr char g_grpc_config_prefix[] = ""grpc_config="";++DEFINE_PROTO_FUZZER(const service_config_fuzzer::Msg& msg) {+  std::string payload;+  if (msg.has_fuzzed_service_config()) {+    ::google::protobuf::json::PrintOptions print_options;+    auto status = MessageToJsonString(msg.fuzzed_service_config(), &payload,","I think testing them both in the same fuzzer seems fine.  If the fuzzer proto provides a `ServiceConfig` proto, then we can call `ServiceConfigImpl::Create()`; if the fuzzer proto provides a string, we can pass it to `ChooseServiceConfig()`.Note that `ChooseServiceConfig()` is not actually a superset, because it does not actually call `ServiceConfigImpl::Create()`; it actually just returns the selected service config JSON as a string.(As an aside, this made me notice that in the DNS resolvers (both c-ares and EE-based), we're currently re-serializing the JSON in `ChooseServiceConfig()` and then re-parsing it in `ServiceConfigImpl::Create()`, which seems inefficient.  We should probably change `ChooseServiceConfig()` to return the chosen config as a `Json` object, and then have the DNS resolvers use [this override of `ServiceConfigImpl::Create()` that accepts a `Json` object](https://github.com/grpc/grpc/blob/fe3f400985035f7d0420b03a0ae55960bd25e7cb/src/core/lib/service_config/service_config_impl.h#L80).)",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32973,1197135520,2023-05-17T22:52:36Z,src/core/ext/filters/client_channel/resolver/xds/xds_resolver.cc,"@@ -107,6 +107,99 @@ UniqueTypeName XdsClusterAttribute::TypeName() {   return kFactory.Create(); } +namespace {+class XdsResolver;+}++// An entry in the map of clusters that need to be present in the LB+// policy config.  The map holds a weak ref.  One strong ref is held by+// the ConfigSelector, and another is held by each call assigned to+// the cluster by the ConfigSelector.  The ref for each call is held+// until the call is committed.  When the strong refs go away, we hop+// back into the WorkSerializer to remove the entry from the map.+class ClusterRef : public DualRefCounted<ClusterRef> {","I think that with my suggestion in the .h file of using inheritance for `XdsClusterDataAttribute`, the `ClusterRef` and `RouteData` classes can go back to being nested inside of `XdsResolver`, where they were before.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32973,1197147951,2023-05-17T23:08:55Z,src/core/ext/filters/client_channel/resolver/xds/xds_resolver.cc,"@@ -1142,13 +1014,15 @@ void XdsResolver::GenerateResult() {   if (!current_virtual_host_.has_value()) return;   // First create XdsConfigSelector, which may add new entries to the cluster   // state map, and then CreateServiceConfig for LB policies.-  absl::Status status;-  auto config_selector = MakeRefCounted<XdsConfigSelector>(Ref(), &status);+  auto status =",Please call this variable `route_config_data`.,X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32973,1197151075,2023-05-17T23:13:35Z,src/core/ext/filters/client_channel/resolver/xds/xds_resolver.cc,"@@ -316,33 +379,8 @@ class XdsResolver : public Resolver {     }     private:-    struct Route {-      struct ClusterWeightState {-        uint32_t range_end;-        absl::string_view cluster;-        RefCountedPtr<ServiceConfig> method_config;--        bool operator==(const ClusterWeightState& other) const;-      };--      XdsRouteConfigResource::Route route;-      RefCountedPtr<ServiceConfig> method_config;-      std::vector<ClusterWeightState> weighted_cluster_state;--      bool operator==(const Route& other) const;-    };-    using RouteTable = std::vector<Route>;--    class RouteListIterator;--    absl::StatusOr<RefCountedPtr<ServiceConfig>> CreateMethodConfig(-        const XdsRouteConfigResource::Route& route,-        const XdsRouteConfigResource::Route::RouteAction::ClusterWeight*-            cluster_weight);-     RefCountedPtr<XdsResolver> resolver_;-    RouteTable route_table_;-    RefCountedPtr<XdsClusterMap> cluster_map_;+    RefCountedPtr<RouteData> route_data_;",Please call this `route_config_data_`.,X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32973,1197151201,2023-05-17T23:13:48Z,src/core/ext/filters/client_channel/resolver/xds/xds_resolver.cc,"@@ -240,73 +358,18 @@ class XdsResolver : public Resolver {     RefCountedPtr<XdsResolver> resolver_;   }; -  // An entry in the map of clusters that need to be present in the LB-  // policy config.  The map holds a weak ref.  One strong ref is held by-  // the ConfigSelector, and another is held by each call assigned to-  // the cluster by the ConfigSelector.  The ref for each call is held-  // until the call is committed.  When the strong refs go away, we hop-  // back into the WorkSerializer to remove the entry from the map.-  class ClusterState : public DualRefCounted<ClusterState> {-   public:-    ClusterState(RefCountedPtr<XdsResolver> resolver,-                 absl::string_view cluster_name)-        : resolver_(std::move(resolver)), cluster_name_(cluster_name) {}--    void Orphan() override {-      auto* resolver = resolver_.get();-      resolver->work_serializer_->Run(-          [resolver = std::move(resolver_)]() {-            resolver->MaybeRemoveUnusedClusters();-          },-          DEBUG_LOCATION);-    }--    const std::string& cluster_name() const { return cluster_name_; }--   private:-    RefCountedPtr<XdsResolver> resolver_;-    std::string cluster_name_;-  };--  // A map containing cluster refs held by the XdsConfigSelector. A ref to-  // this map will be taken by each call processed by the XdsConfigSelector,-  // stored in a the call's call attributes, and later unreffed-  // by the ClusterSelection filter.-  class XdsClusterMap : public RefCounted<XdsClusterMap> {-   public:-    explicit XdsClusterMap(-        std::map<absl::string_view, RefCountedPtr<ClusterState>> clusters)-        : clusters_(std::move(clusters)) {}--    bool operator==(const XdsClusterMap& other) const {-      return clusters_ == other.clusters_;-    }--    RefCountedPtr<ClusterState> Find(absl::string_view name) const {-      auto it = clusters_.find(name);-      if (it == clusters_.end()) {-        return nullptr;-      }-      return it->second;-    }--   private:-    std::map<absl::string_view, RefCountedPtr<ClusterState>> clusters_;-  };-   class XdsConfigSelector : public ConfigSelector {    public:-    XdsConfigSelector(RefCountedPtr<XdsResolver> resolver,-                      absl::Status* status);+    XdsConfigSelector(RefCountedPtr<RouteData> data,",Please call this `route_config_data`.,X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32973,1197979742,2023-05-18T15:41:29Z,src/core/ext/filters/stateful_session/stateful_session_filter.cc,"@@ -112,6 +119,30 @@ void MaybeUpdateServerInitialMetadata(   } } +// Updates cluster with one from the cookie if cluster is still configured for+// route.+// Returns true if the cluster was found or if no cluster was in the cookie+bool OverrideClusterIfNeeded(absl::string_view cookie_cluster,+                             ServiceConfigCallData* service_config_call_data,+                             Arena* arena) {+  // Cookie has quotes that we need to remove","The cookie format does not use quotes:https://github.com/grpc/proposal/blob/master/A60-xds-stateful-session-affinity-weighted-clusters.md#include-cluster-name-in-the-cookie(We had talked about using quotes in an earlier draft of the design, but we removed it because it wasn't useful.)",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32973,1197981757,2023-05-18T15:42:58Z,src/core/ext/filters/stateful_session/stateful_session_filter.cc,"@@ -112,6 +119,30 @@ void MaybeUpdateServerInitialMetadata(   } } +// Updates cluster with one from the cookie if cluster is still configured for+// route.+// Returns true if the cluster was found or if no cluster was in the cookie+bool OverrideClusterIfNeeded(absl::string_view cookie_cluster,+                             ServiceConfigCallData* service_config_call_data,+                             Arena* arena) {+  // Cookie has quotes that we need to remove+  if (cookie_cluster.length() < 2) {+    return true;+  }+  absl::string_view cluster_name =+      absl::StripPrefix(absl::StripSuffix(cookie_cluster, ""\""""), ""\"""");+  auto cluster_data = static_cast<XdsClusterDataAttribute*>(+      service_config_call_data->GetCallAttribute(+          XdsClusterDataAttribute::TypeName()));+  if (cluster_data == nullptr ||+      !cluster_data->HasClusterForRoute(cluster_name)) {+    return false;+  }+  service_config_call_data->SetCallAttribute(+      arena->New<XdsClusterAttribute>(cluster_name));","Rather than allocating a new object here, I suggest adding a setter method to the `XdsClusterAttribute` class, so that we can just reset the value in the existing attribute.",X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32973,1197988513,2023-05-18T15:49:15Z,src/core/ext/filters/stateful_session/stateful_session_filter.cc,"@@ -112,6 +119,30 @@ void MaybeUpdateServerInitialMetadata(   } } +// Updates cluster with one from the cookie if cluster is still configured for+// route.+// Returns true if the cluster was found or if no cluster was in the cookie+bool OverrideClusterIfNeeded(absl::string_view cookie_cluster,+                             ServiceConfigCallData* service_config_call_data,+                             Arena* arena) {+  // Cookie has quotes that we need to remove+  if (cookie_cluster.length() < 2) {+    return true;+  }+  absl::string_view cluster_name =+      absl::StripPrefix(absl::StripSuffix(cookie_cluster, ""\""""), ""\"""");+  auto cluster_data = static_cast<XdsClusterDataAttribute*>(+      service_config_call_data->GetCallAttribute(+          XdsClusterDataAttribute::TypeName()));+  if (cluster_data == nullptr ||+      !cluster_data->HasClusterForRoute(cluster_name)) {+    return false;+  }+  service_config_call_data->SetCallAttribute(+      arena->New<XdsClusterAttribute>(cluster_name));","Note that the `XdsClusterAttribute` class does not actually store its own copy of the cluster name string; it actually stores an `absl::string_view` pointing to an externally owned string, which must live at least until the attribute will no longer be used (when we give up the cluster ref).The code here is setting this to point to the string allocated on the arena in `GetOverrideHostFromCookie()`, which will live long enough.  However, it feels a little fragile, because it's not necessarily going to be obvious to someone modifying this code in the future that changing the code in `GetOverrideHostFromCookie()` will break the code here.  Also, as per my comment below, we still need to arena-allocate a copy of the cluster name even in the case where there is no cookie.To address this, I suggest moving the arena allocation out of `GetOverrideHostFromCookie()`.  That function can just return a `std::string`, which can be empty if no valid cookie is found.  (Also, I suggest renaming that method to `GetOverrideCookie()`, since it's no longer returning just the host.)Instead, I think we want to handle the arena allocation for the host and cluster separately.  The arena allocation for the host should be handled in `MakeCallPromise()`, as per my comment below.  The arena allocation for the cluster should be handled in this function.Also, as per my comment elsewhere, the code here needs to handle the ""cluster:"" prefix properly: that prefix will be present in the `XdsClusterAttribute`, but not in the cookie.Taking all of that into account, I think the code here should look something like this:```// Returns an arena-allocated string containing the cluster name// to use for this RPC, which will live long enough to use when modifying// the server's initial metadata.  If cluster_from_cookie is non-empty and// points to a cluster present in the selected route, uses that; otherwise,// uses the cluster selected by the XdsConfigSelector.// Returns the empty string if cluster override cannot be used (i.e., the route// uses a cluster specifier plugin).absl::string_view GetClusterToUse(    absl::string_view cluster_from_cookie,     ServiceConfigCallData* service_config_call_data) {  static constexpr absl::string_view kClusterPrefix = ""cluster:"";  // Get cluster assigned by the XdsConfigSelector.  auto* cluster_name_attribute = static_cast<XdsClusterAttribute*>(      service_config_call_data->GetCallAttribute(          XdsClusterAttribute::TypeName()));  GPR_ASSERT(cluster_name_attribute != nullptr);  absl::string_view cluster_to_use = cluster_name_attribute->cluster();  // If prefix is not ""cluster:"", then we can't use cluster override.  if (!absl::ConsumePrefix(&cluster_to_use, kClusterPrefix)) return """";  // If we have a cluster from the cookie that is present in the  // selected route, use that instead.  if (!cluster_from_cookie.empty()) {    auto* route_data = static_cast<XdsClusterDataAttribute*>(        service_config_call_data->GetCallAttribute(            XdsClusterDataAttribute::TypeName()));    GPR_ASSERT(route_data != nullptr);    if (route_data->HasClusterForRoute(cluster_from_cookie)) {      cluster_to_use = cluster_from_cookie;    }  }  // Arena-allocate a copy of the cluster name with the ""cluster:"" prefix.  const size_t alloc_size = kClusterPrefix.size() + cluster_to_use.size();  char* allocated_value =      static_cast<char*>(GetContext<Arena>()->Alloc(alloc_size);  memcpy(allocated_value, kClusterPrefix.data(), kClusterPrefix.size());  memcpy(allocated_value + kClusterPrefix.size(), cluster_to_use.data(),         cluster_to_use.size());  cluster_to_use = absl::string_view(allocated_value, alloc_size);  // If we chose the cluster from the cookie above, then update  // the cluster name attribute as well.  Note that the attribute will  // point to the arena-allocated string, which will live long enough.  if (cluster_to_use == cluster_from_cookie) {    cluster_name_attribute->set_cluster(cluster_to_use);  }  return absl::StripPrefix(cluster_to_use, kClusterPrefix);}```",X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32973,1198070033,2023-05-18T17:08:01Z,src/core/ext/filters/stateful_session/stateful_session_filter.cc,"@@ -158,29 +189,46 @@ ArenaPromise<ServerMetadataHandle> StatefulSessionFilter::MakeCallPromise(               this, cookie_config->name->c_str(),               std::string(*cookie_value).c_str());     }-    // We have a valid cookie, so add the call attribute to be used by the-    // xds_override_host LB policy.-    service_config_call_data->SetCallAttribute(-        GetContext<Arena>()->New<XdsOverrideHostAttribute>(*cookie_value));+    std::pair<absl::string_view, absl::string_view> host_cluster =+        absl::StrSplit(*cookie_value, absl::MaxSplits(';', 1));+    if (!host_cluster.first.empty() &&+        OverrideClusterIfNeeded(host_cluster.second, service_config_call_data,+                                GetContext<Arena>())) {+      // We have a valid cookie, so add the call attribute to be used by the+      // xds_override_host LB policy.+      service_config_call_data->SetCallAttribute(+          GetContext<Arena>()->New<XdsOverrideHostAttribute>(+              host_cluster.first));+    }+    // Cluster is not yet in use+  }+  absl::string_view cluster_name;+  auto cluster_name_attribute = static_cast<XdsClusterAttribute*>(+      service_config_call_data->GetCallAttribute(+          XdsClusterAttribute::TypeName()));+  if (cluster_name_attribute != nullptr) {+    cluster_name = cluster_name_attribute->cluster();   }   // Intercept server initial metadata.   call_args.server_initial_metadata->InterceptAndMap(-      [cookie_config, cookie_value](ServerMetadataHandle md) {+      [cookie_config, cookie_value, cluster_name](ServerMetadataHandle md) {","I don't think it's safe to store the `absl::string_view` pointing to the cluster name in this lambda, because that `string_view` points to the storage inside the `ClusterRef` object, and that object may have been destroyed by the time the lambda runs, because the call will drop its ref to the `ClusterRef` as soon as it is committed (i.e., as soon as it's done with all LB picks), which happens before we see server initial metadata.  To fix this, I think we're going to need to allocate a copy of the cluster string on the arena.  See my comment above about moving the cluster string arena allocation into `OverrideClusterIfNeeded()`, which I am suggesting renaming to `GetClusterNameToUse()`.With that change in place, I think the logic here should look something like this:```std::string cookie_value = GetOverrideCookie(    call_args.client_initial_metadata, *cookie_config->name);absl::string_view cluster_from_cookie;// Cookie format is ""host;cluster"".std::pair<absl::string_view, absl::string_view> host_cluster =    absl::StrSplit(cookie_value, absl::MaxSplits(';', 1));// Set override host attribute.  Allocate the string on the// arena, so that it has the right lifetime.if (!host_cluster.first.empty()) {  char* host_str = GetContext<Arena>()->Alloc(host_cluster.first.size());  memcpy(host_str, host_cluster.first.data(), host_cluster.first.size());    service_config_call_data->SetCallAttribute(      GetContext<Arena>()->New<XdsOverrideHostAttribute>(          absl::string_view(host_str, host_cluster.first.size())));}// Check if the cluster override is valid, and apply it if necessary.// Note that cluster_name will point to an arena-allocated string// that will still be alive when we see the server initial metadata.// If the cluster name is empty, that means we cannot use a// cluster override (i.e., the route uses a cluster specifier plugin).absl::string_view cluster_name =    GetClusterNameToUse(host_cluster.second, service_config_call_data);```",
24593237,XuanWang-Amos,https://api.github.com/repos/grpc/grpc/pulls/32974,1198083855,2023-05-18T17:23:23Z,src/python/grpcio_observability/grpc_observability/_cyobservability.pyx,"@@ -0,0 +1,273 @@+# Copyright 2023 gRPC authors.+#+# Licensed under the Apache License, Version 2.0 (the ""License"");+# you may not use this file except in compliance with the License.+# You may obtain a copy of the License at+#+#     http://www.apache.org/licenses/LICENSE-2.0+#+# Unless required by applicable law or agreed to in writing, software+# distributed under the License is distributed on an ""AS IS"" BASIS,+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+# See the License for the specific language governing permissions and+# limitations under the License.++cimport cpython+from cython.operator cimport dereference++import enum+import logging+from threading import Thread+from typing import List, Mapping, Tuple++import grpc_observability++# Time we wait for batch exporting census data+EXPORT_BATCH_INTERVAL = 0.5+cdef const char* CLIENT_CALL_TRACER = ""client_call_tracer""+cdef const char* SERVER_CALL_TRACER_FACTORY = ""server_call_tracer_factory""+cdef bint GLOBAL_SHUTDOWN_EXPORT_THREAD = False+cdef object GLOBAL_EXPORT_THREAD++_LOGGER = logging.getLogger(__name__)++class _CyMetricsName:+  CY_CLIENT_API_LATENCY = kRpcClientApiLatencyMeasureName+  CY_CLIENT_SNET_MESSSAGES_PER_RPC = kRpcClientSentMessagesPerRpcMeasureName+  CY_CLIENT_SEND_BYTES_PER_RPC = kRpcClientSentBytesPerRpcMeasureName+  CY_CLIENT_RECEIVED_MESSAGES_PER_RPC = kRpcClientReceivedMessagesPerRpcMeasureName+  CY_CLIENT_RECEIVED_BYTES_PER_RPC = kRpcClientReceivedBytesPerRpcMeasureName+  CY_CLIENT_ROUNDTRIP_LATENCY = kRpcClientRoundtripLatencyMeasureName+  CY_CLIENT_SERVER_LATENCY = kRpcClientServerLatencyMeasureName+  CY_CLIENT_STARTED_RPCS = kRpcClientStartedRpcsMeasureName+  CY_CLIENT_RETRIES_PER_CALL = kRpcClientRetriesPerCallMeasureName+  CY_CLIENT_TRANSPARENT_RETRIES_PER_CALL = kRpcClientTransparentRetriesPerCallMeasureName+  CY_CLIENT_RETRY_DELAY_PER_CALL = kRpcClientRetryDelayPerCallMeasureName+  CY_CLIENT_TRANSPORT_LATENCY = kRpcClientTransportLatencyMeasureName+  CY_SERVER_SENT_MESSAGES_PER_RPC = kRpcServerSentMessagesPerRpcMeasureName+  CY_SERVER_SENT_BYTES_PER_RPC = kRpcServerSentBytesPerRpcMeasureName+  CY_SERVER_RECEIVED_MESSAGES_PER_RPC = kRpcServerReceivedMessagesPerRpcMeasureName+  CY_SERVER_RECEIVED_BYTES_PER_RPC = kRpcServerReceivedBytesPerRpcMeasureName+  CY_SERVER_SERVER_LATENCY = kRpcServerServerLatencyMeasureName+  CY_SERVER_STARTED_RPCS = kRpcServerStartedRpcsMeasureName++@enum.unique+class MetricsName(enum.Enum):+  CLIENT_STARTED_RPCS = _CyMetricsName.CY_CLIENT_STARTED_RPCS+  CLIENT_API_LATENCY = _CyMetricsName.CY_CLIENT_API_LATENCY+  CLIENT_SNET_MESSSAGES_PER_RPC = _CyMetricsName.CY_CLIENT_SNET_MESSSAGES_PER_RPC+  CLIENT_SEND_BYTES_PER_RPC = _CyMetricsName.CY_CLIENT_SEND_BYTES_PER_RPC+  CLIENT_RECEIVED_MESSAGES_PER_RPC = _CyMetricsName.CY_CLIENT_RECEIVED_MESSAGES_PER_RPC+  CLIENT_RECEIVED_BYTES_PER_RPC = _CyMetricsName.CY_CLIENT_RECEIVED_BYTES_PER_RPC+  CLIENT_ROUNDTRIP_LATENCY = _CyMetricsName.CY_CLIENT_ROUNDTRIP_LATENCY+  CLIENT_SERVER_LATENCY = _CyMetricsName.CY_CLIENT_SERVER_LATENCY+  CLIENT_RETRIES_PER_CALL = _CyMetricsName.CY_CLIENT_RETRIES_PER_CALL+  CLIENT_TRANSPARENT_RETRIES_PER_CALL = _CyMetricsName.CY_CLIENT_TRANSPARENT_RETRIES_PER_CALL+  CLIENT_RETRY_DELAY_PER_CALL = _CyMetricsName.CY_CLIENT_RETRY_DELAY_PER_CALL+  CLIENT_TRANSPORT_LATENCY = _CyMetricsName.CY_CLIENT_TRANSPORT_LATENCY+  SERVER_SENT_MESSAGES_PER_RPC = _CyMetricsName.CY_SERVER_SENT_MESSAGES_PER_RPC+  SERVER_SENT_BYTES_PER_RPC = _CyMetricsName.CY_SERVER_SENT_BYTES_PER_RPC+  SERVER_RECEIVED_MESSAGES_PER_RPC = _CyMetricsName.CY_SERVER_RECEIVED_MESSAGES_PER_RPC+  SERVER_RECEIVED_BYTES_PER_RPC = _CyMetricsName.CY_SERVER_RECEIVED_BYTES_PER_RPC+  SERVER_SERVER_LATENCY = _CyMetricsName.CY_SERVER_SERVER_LATENCY+  SERVER_STARTED_RPCS = _CyMetricsName.CY_SERVER_STARTED_RPCS++# Delay map creation due to circular dependencies+_CY_METRICS_NAME_TO_PY_METRICS_NAME_MAPPING = {x.value: x for x in MetricsName}++def cyobservability_init(object exporter) -> None:+  NativeObservabilityInit()+  _start_exporting_thread(exporter)+++def _start_exporting_thread(object exporter) -> None:+  global GLOBAL_EXPORT_THREAD+  global GLOBAL_SHUTDOWN_EXPORT_THREAD+  GLOBAL_SHUTDOWN_EXPORT_THREAD = False+  GLOBAL_EXPORT_THREAD = Thread(target=_export_census_data, args=(exporter,))+  GLOBAL_EXPORT_THREAD.start()+++def set_gcp_observability_config(object py_config) -> bool:+  """"""+    Returns:+      bool: True if configuration is valid, False otherwise.+  """"""+  py_labels = {}+  sampling_rate = 0.0++  cdef cGcpObservabilityConfig c_config = ReadAndActivateObservabilityConfig()+  if not c_config.is_valid:+    return False++  for label in c_config.labels:+    py_labels[_decode(label.key)] = _decode(label.value)++  if PythonOpenCensusTracingEnabled():+    sampling_rate = c_config.cloud_trace.sampling_rate+    # Save sampling rate to global sampler.+    ProbabilitySampler.Get().SetThreshold(sampling_rate)++  py_config.set_configuration(_decode(c_config.project_id), sampling_rate, py_labels,+                              PythonOpenCensusTracingEnabled(), PythonOpenCensusStatsEnabled())+  return True+++def create_client_call_tracer(bytes method_name, bytes trace_id,+                                      bytes parent_span_id=b'') -> cpython.PyObject:+  cdef char* c_method = cpython.PyBytes_AsString(method_name)+  cdef char* c_trace_id = cpython.PyBytes_AsString(trace_id)+  cdef char* c_parent_span_id = cpython.PyBytes_AsString(parent_span_id)++  cdef void* call_tracer = CreateClientCallTracer(c_method, c_trace_id, c_parent_span_id)+  capsule = cpython.PyCapsule_New(call_tracer, CLIENT_CALL_TRACER, NULL)+  return capsule+++def create_server_call_tracer_factory_capsule() -> cpython.PyObject:+  cdef void* call_tracer_factory = CreateServerCallTracerFactory()+  capsule = cpython.PyCapsule_New(call_tracer_factory, SERVER_CALL_TRACER_FACTORY, NULL)+  return capsule+++def delete_client_call_tracer(object client_call_tracer) -> None:+  if cpython.PyCapsule_IsValid(client_call_tracer, CLIENT_CALL_TRACER):+    capsule_ptr = cpython.PyCapsule_GetPointer(client_call_tracer, CLIENT_CALL_TRACER)+    call_tracer_ptr = <ClientCallTracer*>capsule_ptr+    del call_tracer_ptr+++def _c_label_to_labels(object cLabels) -> Mapping[str, str]:+  py_labels = {}+  for label in cLabels:+    py_labels[_decode(label['key'])] = _decode(label['value'])+  return py_labels+++def _c_annotation_to_annotations(object cAnnotations) -> List[Tuple[str, str]]:+  py_annotations = []+  for annotation in cAnnotations:+    py_annotations.append((_decode(annotation['time_stamp']),+                          _decode(annotation['description'])))+  return py_annotations+++def at_observability_exit() -> None:+  _shutdown_exporting_thread()+++def _cy_metric_name_to_py_metric_name(object metric_name) -> grpc_observability.MetricsName:+  try:+      return _CY_METRICS_NAME_TO_PY_METRICS_NAME_MAPPING[metric_name]+  except KeyError:+      raise ValueError('Invalid metric name %s' % metric_name)+++def _get_stats_data(object measurement, object labels) -> grpc_observability.StatsData:+  metric_name = _cy_metric_name_to_py_metric_name(measurement['name'])+  if measurement['type'] == kMeasurementDouble:+    py_stat = grpc_observability.StatsData(name=metric_name, measure_double=True,+                                           value_float=measurement['value']['value_double'],+                                           labels=labels)+  else:+    py_stat = grpc_observability.StatsData(name=metric_name, measure_double=False,+                                           value_int=measurement['value']['value_int'],+                                           labels=labels)+  return py_stat+++def _get_tracing_data(object span_data, object span_labels, object span_annotations) -> grpc_observability.TracingData:+  py_span_labels = _c_label_to_labels(span_labels)+  py_span_annotations = _c_annotation_to_annotations(span_annotations)+  return grpc_observability.TracingData(name=_decode(span_data['name']),+                                   start_time = _decode(span_data['start_time']),+                                   end_time = _decode(span_data['end_time']),+                                   trace_id = _decode(span_data['trace_id']),+                                   span_id = _decode(span_data['span_id']),+                                   parent_span_id = _decode(span_data['parent_span_id']),+                                   status = _decode(span_data['status']),+                                   should_sample = span_data['should_sample'],+                                   child_span_count = span_data['child_span_count'],+                                   span_labels = py_span_labels,+                                   span_annotations = py_span_annotations)+++def _record_rpc_latency(object exporter, str method, float rpc_latency, str status_code) -> None:+  measurement = {}+  measurement['name'] = kRpcClientApiLatencyMeasureName+  measurement['type'] = kMeasurementDouble+  measurement['value'] = {'value_double': rpc_latency}++  labels = {}+  labels[_decode(kClientMethod)] = method.strip(""/"")+  labels[_decode(kClientStatus)] = status_code+  metric = _get_stats_data(measurement, labels)+  exporter.export_stats_data([metric])+++cdef void _export_census_data(object exporter):+  cdef int export_interval_ms = EXPORT_BATCH_INTERVAL * 1000+  while True:+    with nogil:+      while not GLOBAL_SHUTDOWN_EXPORT_THREAD:+        lk = new unique_lock[mutex](g_census_data_buffer_mutex)+        # Wait for next batch of census data OR timeout at fixed interval.+        # Batch export census data to minimize the time we acquiring the GIL.+        # TODO(xuanwn): change interval to a more appropriate number+        AwaitNextBatchLocked(dereference(lk), export_interval_ms)++        # Break only when buffer have data+        if not g_census_data_buffer.empty():+          del lk+          break+        else:+          del lk++    _flush_census_data(exporter)","I can see pros and cons for both options.* if we go with option 1, then we'll have a performance hit since exporting will take time.* If we go with option 2, we'll have a risk of losing some observability data.Personally I prefer option 2 because we can set a threshold to reduce the risk of data loss, and we should also add a log to notify users that the data will be discarded so they can adjust the threshold if necessary.I'll make changes based on option 2, please let me know if you have other concerns.",
1644595,gnossen,https://api.github.com/repos/grpc/grpc/pulls/32974,1198098259,2023-05-18T17:35:13Z,src/python/grpcio_tests/tests/observability/_observability_test.py,"@@ -0,0 +1,341 @@+# Copyright 2023 gRPC authors.+#+# Licensed under the Apache License, Version 2.0 (the ""License"");+# you may not use this file except in compliance with the License.+# You may obtain a copy of the License at+#+#     http://www.apache.org/licenses/LICENSE-2.0+#+# Unless required by applicable law or agreed to in writing, software+# distributed under the License is distributed on an ""AS IS"" BASIS,+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+# See the License for the specific language governing permissions and+# limitations under the License.++from concurrent import futures+import logging+import os+from typing import List+import unittest++import grpc+import grpc_observability++logger = logging.getLogger(__name__)++_REQUEST = b'\x00\x00\x00'+_RESPONSE = b'\x00\x00\x00'++_UNARY_UNARY = '/test/UnaryUnary'+_UNARY_STREAM = '/test/UnaryStream'+_STREAM_UNARY = '/test/StreamUnary'+_STREAM_STREAM = '/test/StreamStream'+STREAM_LENGTH = 5++_VALID_CONFIG_TRACING_STATS = """"""+{+    ""project_id"":""test-project"",+    ""cloud_trace"":{+       ""sampling_rate"":1.00+    },+    ""cloud_monitoring"":{},+}+""""""++# Depends on grpc_core::IsTransportSuppliesClientLatencyEnabled,+# the following metrcis might not exist.+_SKIP_VEFIRY = [grpc_observability.MetricsName.CLIENT_TRANSPORT_LATENCY]+_SPAN_PREFIXS = ['Recv', 'Sent', 'Attempt']+++class TestExporter(grpc_observability.Exporter):++    def __init__(self, metrics: List[grpc_observability.StatsData],+                 spans: List[grpc_observability.TracingData]):+        self.span_collecter = spans+        self.metric_collecter = metrics+        self._server = None++    def export_stats_data(+            self, stats_data: List[grpc_observability.StatsData]) -> None:+        self.metric_collecter.extend(stats_data)++    def export_tracing_data(+            self, tracing_data: List[grpc_observability.TracingData]) -> None:+        self.span_collecter.extend(tracing_data)+++def handle_unary_unary(request, servicer_context):+    return _RESPONSE+++def handle_unary_stream(request, servicer_context):+    for _ in range(STREAM_LENGTH):+        yield _RESPONSE+++def handle_stream_unary(request_iterator, servicer_context):+    return _RESPONSE+++def handle_stream_stream(request_iterator, servicer_context):+    for request in request_iterator:+        yield _RESPONSE+++class _MethodHandler(grpc.RpcMethodHandler):++    def __init__(self, request_streaming, response_streaming):+        self.request_streaming = request_streaming+        self.response_streaming = response_streaming+        self.request_deserializer = None+        self.response_serializer = None+        self.unary_unary = None+        self.unary_stream = None+        self.stream_unary = None+        self.stream_stream = None+        if self.request_streaming and self.response_streaming:+            self.stream_stream = lambda x, y: handle_stream_stream(x, y)+        elif self.request_streaming:+            self.stream_unary = lambda x, y: handle_stream_unary(x, y)+        elif self.response_streaming:+            self.unary_stream = lambda x, y: handle_unary_stream(x, y)+        else:+            self.unary_unary = lambda x, y: handle_unary_unary(x, y)+++class _GenericHandler(grpc.GenericRpcHandler):++    def service(self, handler_call_details):+        if handler_call_details.method == _UNARY_UNARY:+            return _MethodHandler(False, False)+        elif handler_call_details.method == _UNARY_STREAM:+            return _MethodHandler(False, True)+        elif handler_call_details.method == _STREAM_UNARY:+            return _MethodHandler(True, False)+        elif handler_call_details.method == _STREAM_STREAM:+            return _MethodHandler(True, True)+        else:+            return None+++class ObservabilityTest(unittest.TestCase):","I would recommend mirroring all of [the interop tests](https://github.com/GoogleCloudPlatform/grpc-gcp-tools/blob/master/observability/test/run_o11y_tests.py) with unit test versions. It will legitimately be 10x faster to resolve any issues here in the unit test compared to resolving an issue in the interop test, so any time spent writing those tests here will be well worth it.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32973,1198117724,2023-05-18T17:54:37Z,src/core/ext/filters/stateful_session/stateful_session_filter.cc,"@@ -158,29 +189,46 @@ ArenaPromise<ServerMetadataHandle> StatefulSessionFilter::MakeCallPromise(               this, cookie_config->name->c_str(),               std::string(*cookie_value).c_str());     }-    // We have a valid cookie, so add the call attribute to be used by the-    // xds_override_host LB policy.-    service_config_call_data->SetCallAttribute(-        GetContext<Arena>()->New<XdsOverrideHostAttribute>(*cookie_value));+    std::pair<absl::string_view, absl::string_view> host_cluster =+        absl::StrSplit(*cookie_value, absl::MaxSplits(';', 1));+    if (!host_cluster.first.empty() &&+        OverrideClusterIfNeeded(host_cluster.second, service_config_call_data,","I think we should set the host override independently of the cluster override.  Even if we're not setting the cluster override, it's conceivably possible that the same host could exist in whatever cluster we choose, so we should still set the host override.  And I think it makes the logic here a bit simpler to decouple the two.",
24593237,XuanWang-Amos,https://api.github.com/repos/grpc/grpc/pulls/32974,1198224345,2023-05-18T19:29:01Z,src/python/grpcio_observability/grpc_observability/client_call_tracer.cc,"@@ -0,0 +1,242 @@+// Copyright 2023 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++#include ""src/python/grpcio_observability/grpc_observability/client_call_tracer.h""++#include ""absl/strings/escaping.h""+#include ""absl/strings/string_view.h""++#include <limits.h>++#include <atomic>+++namespace grpc_observability {++constexpr uint32_t+    PythonOpenCensusCallTracer::PythonOpenCensusCallAttemptTracer::kMaxTraceContextLen;+constexpr uint32_t+    PythonOpenCensusCallTracer::PythonOpenCensusCallAttemptTracer::kMaxTagsLen;++//+// OpenCensusCallTracer+//++PythonOpenCensusCallTracer::PythonOpenCensusCallTracer(char* method, char* trace_id,+                                                       char* parent_span_id, bool tracing_enabled):+      method_(GetMethod(method)),+      tracing_enabled_(tracing_enabled) {+  GenerateClientContext(absl::StrCat(""Sent."", method_), absl::string_view(trace_id),+                        absl::string_view(parent_span_id), &context_);+}++void PythonOpenCensusCallTracer::GenerateContext() {}++void PythonOpenCensusCallTracer::RecordAnnotation(absl::string_view annotation) {+  // If tracing is disabled, the following will be a no-op.+  context_.AddSpanAnnotation(annotation);+}+++PythonOpenCensusCallTracer::~PythonOpenCensusCallTracer() {+  if (PythonOpenCensusStatsEnabled()) {+    std::vector<Label> labels = context_.Labels();+    labels.emplace_back(Label{kClientMethod, std::string(method_)});+    RecordIntMetric(kRpcClientRetriesPerCallMeasureName, retries_ - 1, labels); // exclude first attempt+    RecordIntMetric(kRpcClientTransparentRetriesPerCallMeasureName, transparent_retries_, labels);+    RecordDoubleMetric(kRpcClientRetryDelayPerCallMeasureName, ToDoubleMilliseconds(retry_delay_), labels);+  }++  if (tracing_enabled_) {+    context_.EndSpan();+    if (IsSampled()) {+      RecordSpan(context_.Span().ToCensusData());+    }+  }+}+++PythonCensusContext PythonOpenCensusCallTracer::CreateCensusContextForCallAttempt() {+  auto context = PythonCensusContext(absl::StrCat(""Attempt."", method_), &(context_.Span()), context_.Labels());","During the creation of `PythonCensusContext` we'll call [StartSpan](https://github.com/grpc/grpc/blob/39da66545581848418e62b0c005a591e099ff0f3/src/python/grpcio_observability/grpc_observability/python_census_context.h#L225), which will start a new span and [generate span_id](https://github.com/grpc/grpc/blob/39da66545581848418e62b0c005a591e099ff0f3/src/python/grpcio_observability/grpc_observability/python_census_context.cc#L192).When create `PythonCensusContext`, we'll always create a new Span, this is related to the life circle of Span, I'll add some comments to both `PythonCensusContext` and `Span` class.",
24593237,XuanWang-Amos,https://api.github.com/repos/grpc/grpc/pulls/32974,1198236779,2023-05-18T19:44:25Z,src/python/grpcio_observability/grpc_observability/client_call_tracer.cc,"@@ -0,0 +1,242 @@+// Copyright 2023 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++#include ""src/python/grpcio_observability/grpc_observability/client_call_tracer.h""++#include ""absl/strings/escaping.h""+#include ""absl/strings/string_view.h""++#include <limits.h>++#include <atomic>+++namespace grpc_observability {++constexpr uint32_t+    PythonOpenCensusCallTracer::PythonOpenCensusCallAttemptTracer::kMaxTraceContextLen;+constexpr uint32_t+    PythonOpenCensusCallTracer::PythonOpenCensusCallAttemptTracer::kMaxTagsLen;++//+// OpenCensusCallTracer+//++PythonOpenCensusCallTracer::PythonOpenCensusCallTracer(char* method, char* trace_id,+                                                       char* parent_span_id, bool tracing_enabled):+      method_(GetMethod(method)),+      tracing_enabled_(tracing_enabled) {+  GenerateClientContext(absl::StrCat(""Sent."", method_), absl::string_view(trace_id),+                        absl::string_view(parent_span_id), &context_);+}++void PythonOpenCensusCallTracer::GenerateContext() {}++void PythonOpenCensusCallTracer::RecordAnnotation(absl::string_view annotation) {+  // If tracing is disabled, the following will be a no-op.+  context_.AddSpanAnnotation(annotation);+}+++PythonOpenCensusCallTracer::~PythonOpenCensusCallTracer() {+  if (PythonOpenCensusStatsEnabled()) {+    std::vector<Label> labels = context_.Labels();+    labels.emplace_back(Label{kClientMethod, std::string(method_)});+    RecordIntMetric(kRpcClientRetriesPerCallMeasureName, retries_ - 1, labels); // exclude first attempt+    RecordIntMetric(kRpcClientTransparentRetriesPerCallMeasureName, transparent_retries_, labels);+    RecordDoubleMetric(kRpcClientRetryDelayPerCallMeasureName, ToDoubleMilliseconds(retry_delay_), labels);+  }++  if (tracing_enabled_) {+    context_.EndSpan();+    if (IsSampled()) {+      RecordSpan(context_.Span().ToCensusData());+    }+  }+}+++PythonCensusContext PythonOpenCensusCallTracer::CreateCensusContextForCallAttempt() {+  auto context = PythonCensusContext(absl::StrCat(""Attempt."", method_), &(context_.Span()), context_.Labels());+  return context;+}+++PythonOpenCensusCallTracer::PythonOpenCensusCallAttemptTracer*+PythonOpenCensusCallTracer::StartNewAttempt(bool is_transparent_retry) {+  uint64_t attempt_num;+  {+    grpc_core::MutexLock lock(&mu_);+    if (transparent_retries_ != 0 || retries_ != 0) {+      if (PythonOpenCensusStatsEnabled() && num_active_rpcs_ == 0) {+        retry_delay_ += absl::Now() - time_at_last_attempt_end_;+      }+    }+    attempt_num = retries_;+    if (is_transparent_retry) {+      ++transparent_retries_;+    } else {+      ++retries_;+    }+    ++num_active_rpcs_;+  }+  context_.AddChildSpan();+  return new PythonOpenCensusCallAttemptTracer(+      this, attempt_num, is_transparent_retry);+}++//+// PythonOpenCensusCallTracer::PythonOpenCensusCallAttemptTracer+//++PythonOpenCensusCallTracer::PythonOpenCensusCallAttemptTracer::PythonOpenCensusCallAttemptTracer(+    PythonOpenCensusCallTracer* parent, uint64_t attempt_num, bool is_transparent_retry)+    : parent_(parent),+      context_(parent_->CreateCensusContextForCallAttempt()),+      start_time_(absl::Now()) {+  if (parent_->tracing_enabled_) {+    context_.AddSpanAttribute(""previous-rpc-attempts"", std::to_string(attempt_num));+    context_.AddSpanAttribute(""transparent-retry"", std::to_string(is_transparent_retry));+  }+  if (PythonOpenCensusStatsEnabled()) {+    std::vector<Label> labels = context_.Labels();+    labels.emplace_back(Label{kClientMethod, std::string(parent_->method_)});+    RecordIntMetric(kRpcClientStartedRpcsMeasureName, 1, labels);+  }+}+++void PythonOpenCensusCallTracer::PythonOpenCensusCallAttemptTracer::+    RecordSendInitialMetadata(grpc_metadata_batch* send_initial_metadata) {+  if (parent_->tracing_enabled_) {+    char tracing_buf[kMaxTraceContextLen];+    size_t tracing_len = TraceContextSerialize(context_, tracing_buf,+                                               kMaxTraceContextLen);+    if (tracing_len > 0) {+      send_initial_metadata->Set(+          grpc_core::GrpcTraceBinMetadata(),+          grpc_core::Slice::FromCopiedBuffer(tracing_buf, tracing_len));+    }+  }+  if (PythonOpenCensusStatsEnabled()) {+    grpc_slice tags = grpc_empty_slice();+    size_t encoded_tags_len = StatsContextSerialize(kMaxTagsLen, &tags);+    if (encoded_tags_len > 0) {+      send_initial_metadata->Set(grpc_core::GrpcTagsBinMetadata(),+                                 grpc_core::Slice(tags));+    }+  }+}+++void PythonOpenCensusCallTracer::PythonOpenCensusCallAttemptTracer::RecordSendMessage(+    const grpc_core::SliceBuffer& /*send_message*/) {+  ++sent_message_count_;+}+++void PythonOpenCensusCallTracer::PythonOpenCensusCallAttemptTracer::RecordReceivedMessage(+    const grpc_core::SliceBuffer& /*recv_message*/) {+  ++recv_message_count_;+}+++namespace {++void FilterTrailingMetadata(grpc_metadata_batch* b, uint64_t* elapsed_time) {","Thanks for the suggestion! This was originally copied from [C++ implementation](https://github.com/grpc/grpc/blob/b589c9b04596de4cdb9be57b391a7223dd1ab804/src/cpp/ext/filters/census/client_filter.cc#L193) but the refactored version definitely looks better.Seems like we can't just change it to `get`, otherwise we'll get this error:`no viable conversion from returned value of type... (aka 'const grpc_core::Slice') to function return type ... (aka 'optional<grpc_core::Slice>')`But I did manage to use `get_pointer` instead, I'll use that here.",
1644595,gnossen,https://api.github.com/repos/grpc/grpc/pulls/32974,1198269155,2023-05-18T20:23:05Z,src/python/grpcio_observability/grpc_observability/python_census_context.cc,"@@ -0,0 +1,268 @@+// Copyright 2023 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++#include ""src/python/grpcio_observability/grpc_observability/python_census_context.h""++namespace grpc_observability {++void EnablePythonOpenCensusStats(bool enable) {+  g_open_census_stats_enabled = enable;+}+++void EnablePythonOpenCensusTracing(bool enable) {+  g_open_census_tracing_enabled = enable;+}+++bool PythonOpenCensusStatsEnabled() {+  return g_open_census_stats_enabled.load(std::memory_order_relaxed);+}+++bool PythonOpenCensusTracingEnabled() {+  return g_open_census_tracing_enabled.load(std::memory_order_relaxed);+}+++void GenerateClientContext(absl::string_view method, absl::string_view trace_id, absl::string_view parent_span_id,+                           PythonCensusContext* ctxt) {+  // Destruct the current CensusContext to free the Span memory before+  // overwriting it below.+  ctxt->~PythonCensusContext();+  if (method.empty()) {+    new (ctxt) PythonCensusContext();+    return;+  }+  if (!parent_span_id.empty()) {+    // Note that parent_span_id exist also means it was marked as sampled at Python OC, we'll respect that decision.+    SpanContext parent_context = SpanContext(std::string(trace_id), std::string(parent_span_id), true);+    new (ctxt) PythonCensusContext(method, parent_context);+    return;+  }+  // Create span without parent.+  new (ctxt) PythonCensusContext(method, trace_id);+}++void GenerateServerContext(absl::string_view header, absl::string_view method,+                           PythonCensusContext* context) {+  // Destruct the current CensusContext to free the Span memory before+  // overwriting it below.+  context->~PythonCensusContext();+  if (method.empty()) {+    new (context) PythonCensusContext();+    return;+  }+  SpanContext parent_ctx = FromGrpcTraceBinHeader(header);+  if (parent_ctx.IsValid()) {+    new (context) PythonCensusContext(method, parent_ctx);+  } else {+    new (context) PythonCensusContext(method);+  }+}+++void ToGrpcTraceBinHeader(PythonCensusContext& ctx, uint8_t* out) {+  out[kVersionOfs] = kVersionId;+  out[kTraceIdOfs] = kTraceIdField;+  uint8_t trace_options_rep_[kSizeTraceOptions];++  std::string trace_id = absl::HexStringToBytes(absl::string_view(ctx.Span().Context().TraceId()));+  std::string span_id = absl::HexStringToBytes(absl::string_view(ctx.Span().Context().SpanId()));+  trace_options_rep_[0] = ctx.Span().Context().IsSampled() ? 1 : 0;++  memcpy(reinterpret_cast<uint8_t*>(&out[kTraceIdOfs + 1]),+         trace_id.c_str(),+         kSizeTraceID);++  out[kSpanIdOfs] = kSpanIdField;+  memcpy(reinterpret_cast<uint8_t*>(&out[kSpanIdOfs + 1]),+         span_id.c_str(),+         kSizeSpanID);++  out[kTraceOptionsOfs] = kTraceOptionsField;+  memcpy(reinterpret_cast<uint8_t*>(&out[kTraceOptionsOfs + 1]), trace_options_rep_, kSizeTraceOptions);+}+++SpanContext FromGrpcTraceBinHeader(absl::string_view header) {+  if (header.size() < kGrpcTraceBinHeaderLen ||+      header[kVersionOfs] != kVersionId ||+      header[kTraceIdOfs] != kTraceIdField ||+      header[kSpanIdOfs] != kSpanIdField ||+      header[kTraceOptionsOfs] != kTraceOptionsField) {+    return SpanContext();  // Invalid.+  }++  uint8_t options = header[kTraceOptionsOfs + 1] & 1;+  constexpr uint8_t kIsSampled = 1;++  uint8_t trace_id_rep_[kTraceIdSize];+  memcpy(trace_id_rep_, reinterpret_cast<const uint8_t*>(&header[kTraceIdOfs + 1]), kTraceIdSize);+  +  uint8_t span_id_rep_[kSpanIdSize];+  memcpy(span_id_rep_, reinterpret_cast<const uint8_t*>(&header[kSpanIdOfs + 1]), kSpanIdSize);++  uint8_t trace_option_rep_[kTraceOptionsLen];+  memcpy(trace_option_rep_, &options, kTraceOptionsLen);++  SpanContext context(absl::BytesToHexString(absl::string_view(reinterpret_cast<const char *>(trace_id_rep_), kTraceIdSize)),+                      absl::BytesToHexString(absl::string_view(reinterpret_cast<const char *>(span_id_rep_), kSpanIdSize)),+                      trace_option_rep_[0] & kIsSampled);+  return context;+}+++size_t TraceContextSerialize(PythonCensusContext& context,+                             char* tracing_buf, size_t tracing_buf_size) {+  if (tracing_buf_size < kGrpcTraceBinHeaderLen) {+    return 0;+  }+  ToGrpcTraceBinHeader(context, reinterpret_cast<uint8_t*>(tracing_buf));+  return kGrpcTraceBinHeaderLen;+}+++size_t StatsContextSerialize(size_t /*max_tags_len*/, grpc_slice* /*tags*/) {+  // TODO(unknown): Add implementation. Waiting on stats tagging to be added.+  return 0;+}+++size_t ServerStatsDeserialize(const char* buf, size_t buf_size,+                              uint64_t* server_elapsed_time) {+  return grpc::internal::RpcServerStatsEncoding::Decode(+      absl::string_view(buf, buf_size), server_elapsed_time);+}+++size_t ServerStatsSerialize(uint64_t server_elapsed_time, char* buf,+                            size_t buf_size) {+  return grpc::internal::RpcServerStatsEncoding::Encode(server_elapsed_time, buf,+                                                  buf_size);+}+++uint64_t GetIncomingDataSize(const grpc_call_final_info* final_info) {+  return final_info->stats.transport_stream_stats.incoming.data_bytes;+}+++uint64_t GetOutgoingDataSize(const grpc_call_final_info* final_info) {+  return final_info->stats.transport_stream_stats.outgoing.data_bytes;+}+++namespace {+// span_id is a 16-character hexadecimal encoded string.+std::string generateSpanId() {+  uint64_t span_id = absl::Uniform<uint64_t>(absl::BitGen());+  std::stringstream hex_string;+  hex_string << std::setfill('0') << std::setw(16) << std::hex << span_id;+  return std::string(hex_string.str());+}++// trace_id is a 32-character hexadecimal encoded string+std::string generateTraceId() {+  absl::uint128 trace_id = absl::Uniform<absl::uint128>(absl::BitGen());+  std::stringstream hex_string;+  hex_string << std::setfill('0') << std::setw(32) << std::hex << trace_id;+  return std::string(hex_string.str());+}++} // namespace++//+// Span+//++Span Span::StartSpan(absl::string_view name, Span* parent) {","You'll have to change around the `Span` APIs to make this work, but this should be `const Span*` since we're not mutating `parent` here.To make this work, you'll need to add a `ConstContext()` method on `Span` or you could just get rid of the method-based accessor, make `Span::context_` public, and access it directly here. More generally, if a method/function does not mutate one of its pointer/reference arguments (non-const value parameters are fine), then that parameter should be marked `const` unless we have a strong reason not to do so.",
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/33151,1198286240,2023-05-18T20:44:45Z,test/core/ext/filters/client_channel/service_config/service_config_fuzzer.cc,"@@ -0,0 +1,57 @@+// Copyright 2023 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+#include <grpc/support/port_platform.h>++#include <string>++#include ""absl/status/statusor.h""+#include ""google/protobuf/json/json.h""++#include <grpc/grpc.h>++#include ""src/core/ext/filters/client_channel/resolver/dns/event_engine/service_config_helper.h""+#include ""src/libfuzzer/libfuzzer_macro.h""+#include ""src/proto/grpc/service_config/service_config.pb.h""+#include ""test/core/ext/filters/client_channel/service_config/service_config_fuzzer.pb.h""++constexpr char g_grpc_config_prefix[] = ""grpc_config="";++DEFINE_PROTO_FUZZER(const service_config_fuzzer::Msg& msg) {+  std::string payload;+  if (msg.has_fuzzed_service_config()) {+    ::google::protobuf::json::PrintOptions print_options;+    auto status = MessageToJsonString(msg.fuzzed_service_config(), &payload,","Given Yijie is working with the dns resvoler implementations now, I'll leave the API changes to him.In the meantime, I've implemented a fuzzing strategy that tests:*  `ServiceConfigImpl::Create` with proto-fuzzed ServiceConfig records* `ChooseServiceConfig` with both arbitrary data, and a list of ServiceConfigTXTRecords, which are the service configs + DNS-specific metadata as defined in A2.",
1644595,gnossen,https://api.github.com/repos/grpc/grpc/pulls/32974,1198328915,2023-05-18T21:35:17Z,src/python/grpcio_observability/grpc_observability/server_call_tracer.cc,"@@ -0,0 +1,238 @@+// Copyright 2023 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++// TODO(xuanwn): clean up includes+#include <stdint.h>+#include <string.h>+#include <thread>++#include <algorithm>+#include <initializer_list>+#include <string>+#include <utility>+#include <vector>++#include <grpc/support/port_platform.h>++#include ""absl/meta/type_traits.h""+#include ""absl/strings/str_cat.h""+#include ""absl/strings/str_format.h""+#include ""absl/strings/string_view.h""+#include ""absl/time/clock.h""+#include ""absl/time/time.h""+#include ""absl/types/optional.h""++#include ""src/core/lib/channel/call_tracer.h""+#include ""src/core/lib/channel/channel_stack.h""+#include ""src/core/lib/channel/context.h""+#include ""src/core/lib/iomgr/error.h""+#include ""src/core/lib/promise/context.h""+#include ""src/core/lib/resource_quota/arena.h""+#include ""src/core/lib/slice/slice.h""+#include ""src/core/lib/slice/slice_buffer.h""+#include ""src/core/lib/transport/metadata_batch.h""++#include ""src/python/grpcio_observability/grpc_observability/server_call_tracer.h""+#include ""src/python/grpcio_observability/grpc_observability/python_census_context.h""+#include ""src/python/grpcio_observability/grpc_observability/observability_util.h""++namespace grpc_observability {++namespace {++// server metadata elements+struct ServerMetadataElements {",Individual structs generally should not have a plural name. How about just `ServerO11yMetadata`?,X
1644595,gnossen,https://api.github.com/repos/grpc/grpc/pulls/32974,1198329131,2023-05-18T21:35:37Z,src/python/grpcio_observability/grpc_observability/server_call_tracer.cc,"@@ -0,0 +1,238 @@+// Copyright 2023 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++// TODO(xuanwn): clean up includes+#include <stdint.h>+#include <string.h>+#include <thread>++#include <algorithm>+#include <initializer_list>+#include <string>+#include <utility>+#include <vector>++#include <grpc/support/port_platform.h>++#include ""absl/meta/type_traits.h""+#include ""absl/strings/str_cat.h""+#include ""absl/strings/str_format.h""+#include ""absl/strings/string_view.h""+#include ""absl/time/clock.h""+#include ""absl/time/time.h""+#include ""absl/types/optional.h""++#include ""src/core/lib/channel/call_tracer.h""+#include ""src/core/lib/channel/channel_stack.h""+#include ""src/core/lib/channel/context.h""+#include ""src/core/lib/iomgr/error.h""+#include ""src/core/lib/promise/context.h""+#include ""src/core/lib/resource_quota/arena.h""+#include ""src/core/lib/slice/slice.h""+#include ""src/core/lib/slice/slice_buffer.h""+#include ""src/core/lib/transport/metadata_batch.h""++#include ""src/python/grpcio_observability/grpc_observability/server_call_tracer.h""+#include ""src/python/grpcio_observability/grpc_observability/python_census_context.h""+#include ""src/python/grpcio_observability/grpc_observability/observability_util.h""++namespace grpc_observability {++namespace {++// server metadata elements+struct ServerMetadataElements {+  grpc_core::Slice path;+  grpc_core::Slice tracing_slice;+  grpc_core::Slice census_proto;+};++void FilterInitialMetadata(grpc_metadata_batch* b,","Similar comment to my previous one about the other `FilterInitialMetadata`. It seems like filtering the metadata isn't really the essential thing this function does -- it seems like the critical element is extracting the path, tracing, and census proto into the `sml`(btw, why ""l""?) out param.I would suggest- switching from `Take` to `get`- making `b` `const`- renaming to `GetO11yMetadata`",X
24593237,XuanWang-Amos,https://api.github.com/repos/grpc/grpc/pulls/32974,1198339301,2023-05-18T21:50:53Z,src/python/grpcio_observability/grpc_observability/client_call_tracer.cc,"@@ -0,0 +1,244 @@+// Copyright 2023 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++#include ""src/python/grpcio_observability/grpc_observability/client_call_tracer.h""++#include ""absl/strings/escaping.h""+#include ""absl/strings/string_view.h""++#include <limits.h>++#include <atomic>+++namespace grpc_observability {++constexpr uint32_t+    PythonOpenCensusCallTracer::PythonOpenCensusCallAttemptTracer::kMaxTraceContextLen;+constexpr uint32_t+    PythonOpenCensusCallTracer::PythonOpenCensusCallAttemptTracer::kMaxTagsLen;++//+// OpenCensusCallTracer+//++PythonOpenCensusCallTracer::PythonOpenCensusCallTracer(char* method, char* trace_id,+                                                       char* parent_span_id, bool tracing_enabled):+      method_(GetMethod(method)),+      tracing_enabled_(tracing_enabled) {+  GenerateClientContext(absl::StrCat(""Sent."", method_), absl::string_view(trace_id),+                        absl::string_view(parent_span_id), &context_);+}++void PythonOpenCensusCallTracer::GenerateContext() {}++void PythonOpenCensusCallTracer::RecordAnnotation(absl::string_view annotation) {+  // If tracing is disabled, the following will be a no-op.+  context_.AddSpanAnnotation(annotation);+}+++PythonOpenCensusCallTracer::~PythonOpenCensusCallTracer() {+  if (PythonOpenCensusStatsEnabled()) {+    std::vector<Label> labels = context_.Labels();+    labels.emplace_back(Label{kClientMethod, std::string(method_)});+    RecordIntMetric(kRpcClientRetriesPerCallMeasureName, retries_ - 1, labels); // exclude first attempt+    RecordIntMetric(kRpcClientTransparentRetriesPerCallMeasureName, transparent_retries_, labels);+    RecordDoubleMetric(kRpcClientRetryDelayPerCallMeasureName, ToDoubleMilliseconds(retry_delay_), labels);+  }++  if (tracing_enabled_) {+    context_.EndSpan();+    if (IsSampled()) {+      RecordSpan(context_.Span().ToCensusData());+    }+  }+}+++PythonCensusContext PythonOpenCensusCallTracer::CreateCensusContextForCallAttempt() {+  auto context = PythonCensusContext(absl::StrCat(""Attempt."", method_), &(context_.Span()), context_.Labels());+  return context;+}+++PythonOpenCensusCallTracer::PythonOpenCensusCallAttemptTracer*+PythonOpenCensusCallTracer::StartNewAttempt(bool is_transparent_retry) {+  uint64_t attempt_num;+  {+    grpc_core::MutexLock lock(&mu_);+    if (transparent_retries_ != 0 || retries_ != 0) {+      if (PythonOpenCensusStatsEnabled() && num_active_rpcs_ == 0) {+        retry_delay_ += absl::Now() - time_at_last_attempt_end_;+      }+    }+    attempt_num = retries_;+    if (is_transparent_retry) {+      ++transparent_retries_;+    } else {+      ++retries_;+    }+    ++num_active_rpcs_;+  }+  context_.AddChildSpan();+  return new PythonOpenCensusCallAttemptTracer(+      this, attempt_num, is_transparent_retry);+}++//+// PythonOpenCensusCallTracer::PythonOpenCensusCallAttemptTracer+//++PythonOpenCensusCallTracer::PythonOpenCensusCallAttemptTracer::PythonOpenCensusCallAttemptTracer(+    PythonOpenCensusCallTracer* parent, uint64_t attempt_num, bool is_transparent_retry)+    : parent_(parent),+      context_(parent_->CreateCensusContextForCallAttempt()),+      start_time_(absl::Now()) {+  if (parent_->tracing_enabled_) {+    context_.AddSpanAttribute(""previous-rpc-attempts"", std::to_string(attempt_num));+    context_.AddSpanAttribute(""transparent-retry"", std::to_string(is_transparent_retry));+  }+  if (PythonOpenCensusStatsEnabled()) {+    std::vector<Label> labels = context_.Labels();+    labels.emplace_back(Label{kClientMethod, std::string(parent_->method_)});+    RecordIntMetric(kRpcClientStartedRpcsMeasureName, 1, labels);+  }+}+++void PythonOpenCensusCallTracer::PythonOpenCensusCallAttemptTracer::+    RecordSendInitialMetadata(grpc_metadata_batch* send_initial_metadata) {+  if (parent_->tracing_enabled_) {+    char tracing_buf[kMaxTraceContextLen];+    size_t tracing_len = TraceContextSerialize(context_, tracing_buf,+                                               kMaxTraceContextLen);+    if (tracing_len > 0) {+      send_initial_metadata->Set(+          grpc_core::GrpcTraceBinMetadata(),+          grpc_core::Slice::FromCopiedBuffer(tracing_buf, tracing_len));+    }+  }+  if (PythonOpenCensusStatsEnabled()) {+    grpc_slice tags = grpc_empty_slice();+    size_t encoded_tags_len = StatsContextSerialize(kMaxTagsLen, &tags);+    if (encoded_tags_len > 0) {+      send_initial_metadata->Set(grpc_core::GrpcTagsBinMetadata(),+                                 grpc_core::Slice(tags));+    }+  }+}+++void PythonOpenCensusCallTracer::PythonOpenCensusCallAttemptTracer::RecordSendMessage(+    const grpc_core::SliceBuffer& /*send_message*/) {+  ++sent_message_count_;+}+++void PythonOpenCensusCallTracer::PythonOpenCensusCallAttemptTracer::RecordReceivedMessage(+    const grpc_core::SliceBuffer& /*recv_message*/) {+  ++recv_message_count_;+}+++namespace {++void FilterTrailingMetadata(grpc_metadata_batch* b, uint64_t* elapsed_time) {+  if (PythonOpenCensusStatsEnabled()) {+    absl::optional<grpc_core::Slice> grpc_server_stats_bin =+        b->Take(grpc_core::GrpcServerStatsBinMetadata());+    if (grpc_server_stats_bin.has_value()) {+      ServerStatsDeserialize(+          reinterpret_cast<const char*>(grpc_server_stats_bin->data()),+          grpc_server_stats_bin->size(), elapsed_time);+    }+  }+}++}  // namespace+++void PythonOpenCensusCallTracer::PythonOpenCensusCallAttemptTracer::+    RecordReceivedTrailingMetadata(+        absl::Status status, grpc_metadata_batch* recv_trailing_metadata,+        const grpc_transport_stream_stats* transport_stream_stats) {+  status_code_ = status.code();+  if (PythonOpenCensusStatsEnabled()) {+    uint64_t elapsed_time = 0;+    if (recv_trailing_metadata != nullptr) {+      FilterTrailingMetadata(recv_trailing_metadata, &elapsed_time);+    }++    std::string final_status = absl::StatusCodeToString(status_code_);+    std::vector<Label> labels = context_.Labels();+    labels.emplace_back(Label{kClientMethod, std::string(parent_->method_)});+    labels.emplace_back(Label{kClientStatus, final_status});+    RecordDoubleMetric(kRpcClientSentBytesPerRpcMeasureName, static_cast<double>(transport_stream_stats != nullptr ? transport_stream_stats->outgoing.data_bytes : 0), labels);+    RecordDoubleMetric(kRpcClientReceivedBytesPerRpcMeasureName, static_cast<double>(transport_stream_stats != nullptr ? transport_stream_stats->incoming.data_bytes : 0), labels);+    RecordDoubleMetric(kRpcClientServerLatencyMeasureName, absl::ToDoubleMilliseconds(absl::Nanoseconds(elapsed_time)), labels);+    RecordDoubleMetric(kRpcClientRoundtripLatencyMeasureName, absl::ToDoubleMilliseconds(absl::Now() - start_time_), labels);+    if (grpc_core::IsTransportSuppliesClientLatencyEnabled()) {+      if (transport_stream_stats != nullptr && gpr_time_cmp(transport_stream_stats->latency,+                        gpr_inf_future(GPR_TIMESPAN)) != 0) {+        double latency_ms = absl::ToDoubleMilliseconds(absl::Microseconds(+            gpr_timespec_to_micros(transport_stream_stats->latency)));+        RecordDoubleMetric(kRpcClientTransportLatencyMeasureName, latency_ms, labels);+      }+    }+  }+}+++void PythonOpenCensusCallTracer::PythonOpenCensusCallAttemptTracer::RecordCancel(","@yashykt probably have more context, since C++ is also [deleting attemptTracer in RecordEnd](https://github.com/grpc/grpc/blob/b589c9b04596de4cdb9be57b391a7223dd1ab804/src/cpp/ext/filters/census/client_filter.cc#L281).",
1644595,gnossen,https://api.github.com/repos/grpc/grpc/pulls/32974,1198388235,2023-05-18T23:21:54Z,src/python/grpcio/grpc/_observability.py,"@@ -0,0 +1,125 @@+# Copyright 2023 The gRPC authors.+#+# Licensed under the Apache License, Version 2.0 (the ""License"");+# you may not use this file except in compliance with the License.+# You may obtain a copy of the License at+#+#     http://www.apache.org/licenses/LICENSE-2.0+#+# Unless required by applicable law or agreed to in writing, software+# distributed under the License is distributed on an ""AS IS"" BASIS,+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+# See the License for the specific language governing permissions and+# limitations under the License.++from __future__ import annotations++import abc+import contextlib+import logging+import threading+from typing import Any, Generic, Optional, TypeVar++from grpc._cython import cygrpc as _cygrpc++_LOGGER = logging.getLogger(__name__)++_channel = Any  # _channel.py imports this module.+ClientCallTracerCapsule = TypeVar('ClientCallTracerCapsule')+ServerCallTracerFactoryCapsule = TypeVar('ServerCallTracerFactoryCapsule')++_plugin_lock: threading.RLock = threading.RLock()+_OBSERVABILITY_PLUGIN: Optional[_ObservabilityPlugin] = None  # pylint: disable=used-before-assignment+++class _ObservabilityPlugin(Generic[ClientCallTracerCapsule,+                                   ServerCallTracerFactoryCapsule],+                           metaclass=abc.ABCMeta):+    """"""+    Note: Any future methods added to this interface cannot have the @abc.abstractmethod annotation.+    """"""+    _tracing_enabled: bool = False+    _stats_enabled: bool = False++    @abc.abstractmethod+    def create_client_call_tracer(+            self, method_name: bytes) -> ClientCallTracerCapsule:+        raise NotImplementedError()++    @abc.abstractmethod+    def delete_client_call_tracer(+            self, client_call_tracer: ClientCallTracerCapsule) -> None:+        # delte client call tracer have to be called on o11y package side.+        # Call it for both segregated and integrated call (`_process_integrated_call_tag`)+        raise NotImplementedError()++    @abc.abstractmethod+    def save_trace_context(self, trace_id: str, span_id: str,+                           is_sampled: bool) -> None:+        raise NotImplementedError()++    @abc.abstractmethod+    def create_server_call_tracer_factory(+            self) -> ServerCallTracerFactoryCapsule:+        raise NotImplementedError()++    @abc.abstractmethod+    def record_rpc_latency(self, method: str, rpc_latency: float,+                           status_code: Any) -> None:+        raise NotImplementedError()++    def set_tracing(self, enable: bool) -> None:+        self._tracing_enabled = enable++    def set_stats(self, enable: bool) -> None:+        self._stats_enabled = enable++    @property+    def tracing_enabled(self) -> bool:+        return self._tracing_enabled++    @property+    def stats_enabled(self) -> bool:+        return self._stats_enabled++    @property+    def observability_enabled(self) -> bool:+        return self.tracing_enabled or self.stats_enabled+++@contextlib.contextmanager+def get_plugin() -> Optional[_ObservabilityPlugin]:+    with _plugin_lock:+        yield _OBSERVABILITY_PLUGIN+++def set_plugin(observability_plugin: Optional[_ObservabilityPlugin]) -> None:+    global _OBSERVABILITY_PLUGIN  # pylint: disable=global-statement+    with _plugin_lock:+        if observability_plugin and _OBSERVABILITY_PLUGIN:+            raise ValueError(""observability_plugin was already set!"")+        _OBSERVABILITY_PLUGIN = observability_plugin+++def _observability_init(observability_plugin: _ObservabilityPlugin) -> None:","What I'm currently seeing is:- When entering the o11y context manager, so the `observability` module calls `_observability_init`  - `_observability_init` calls `set_plugin`  - `_observability_init` calls `set_server_call_tracer_factory`- When exiting the o11y context manager, the `observability` module calls `set_plugin(None)`Some thoughts about this.- I don't see parallelism between the calls that the o11y context manager makes. For example, `set_plugin(foo)` and `set_plugin(None)` or `observability_init(foo)` and `observability_deinit()`- In the current setup, I don't see us ever cleaning up the server call tracer factory.- The name scheme here is confusing. `set_plugin` and `_observability_init` are both protected APIs -- ones that should only be used by packages maintained by us but I'm seeing a mixture of underscore patterns. I would suggest letting the underscore of the `_observability` module indicate that people should not touch this and removing the underscores from the functions in this module.",
1644595,gnossen,https://api.github.com/repos/grpc/grpc/pulls/32974,1198391251,2023-05-18T23:28:57Z,src/python/grpcio/grpc/_observability.py,"@@ -0,0 +1,125 @@+# Copyright 2023 The gRPC authors.+#+# Licensed under the Apache License, Version 2.0 (the ""License"");+# you may not use this file except in compliance with the License.+# You may obtain a copy of the License at+#+#     http://www.apache.org/licenses/LICENSE-2.0+#+# Unless required by applicable law or agreed to in writing, software+# distributed under the License is distributed on an ""AS IS"" BASIS,+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+# See the License for the specific language governing permissions and+# limitations under the License.++from __future__ import annotations++import abc+import contextlib+import logging+import threading+from typing import Any, Generic, Optional, TypeVar++from grpc._cython import cygrpc as _cygrpc++_LOGGER = logging.getLogger(__name__)++_channel = Any  # _channel.py imports this module.+ClientCallTracerCapsule = TypeVar('ClientCallTracerCapsule')+ServerCallTracerFactoryCapsule = TypeVar('ServerCallTracerFactoryCapsule')++_plugin_lock: threading.RLock = threading.RLock()+_OBSERVABILITY_PLUGIN: Optional[_ObservabilityPlugin] = None  # pylint: disable=used-before-assignment+++class _ObservabilityPlugin(Generic[ClientCallTracerCapsule,+                                   ServerCallTracerFactoryCapsule],+                           metaclass=abc.ABCMeta):+    """"""+    Note: Any future methods added to this interface cannot have the @abc.abstractmethod annotation.+    """"""+    _tracing_enabled: bool = False+    _stats_enabled: bool = False++    @abc.abstractmethod+    def create_client_call_tracer(+            self, method_name: bytes) -> ClientCallTracerCapsule:+        raise NotImplementedError()++    @abc.abstractmethod+    def delete_client_call_tracer(+            self, client_call_tracer: ClientCallTracerCapsule) -> None:+        # delte client call tracer have to be called on o11y package side.+        # Call it for both segregated and integrated call (`_process_integrated_call_tag`)+        raise NotImplementedError()++    @abc.abstractmethod+    def save_trace_context(self, trace_id: str, span_id: str,+                           is_sampled: bool) -> None:+        raise NotImplementedError()++    @abc.abstractmethod+    def create_server_call_tracer_factory(+            self) -> ServerCallTracerFactoryCapsule:+        raise NotImplementedError()++    @abc.abstractmethod+    def record_rpc_latency(self, method: str, rpc_latency: float,+                           status_code: Any) -> None:+        raise NotImplementedError()++    def set_tracing(self, enable: bool) -> None:+        self._tracing_enabled = enable++    def set_stats(self, enable: bool) -> None:+        self._stats_enabled = enable++    @property+    def tracing_enabled(self) -> bool:+        return self._tracing_enabled++    @property+    def stats_enabled(self) -> bool:+        return self._stats_enabled++    @property+    def observability_enabled(self) -> bool:+        return self.tracing_enabled or self.stats_enabled+++@contextlib.contextmanager+def get_plugin() -> Optional[_ObservabilityPlugin]:+    with _plugin_lock:+        yield _OBSERVABILITY_PLUGIN+++def set_plugin(observability_plugin: Optional[_ObservabilityPlugin]) -> None:+    global _OBSERVABILITY_PLUGIN  # pylint: disable=global-statement+    with _plugin_lock:+        if observability_plugin and _OBSERVABILITY_PLUGIN:+            raise ValueError(""observability_plugin was already set!"")+        _OBSERVABILITY_PLUGIN = observability_plugin+++def _observability_init(observability_plugin: _ObservabilityPlugin) -> None:+    set_plugin(observability_plugin)","We don't want to allow nested context managers, so we should raise an exception if we try to set a plugin when one has already been installed.",
1644595,gnossen,https://api.github.com/repos/grpc/grpc/pulls/32974,1198391781,2023-05-18T23:30:21Z,src/python/grpcio_observability/grpc_observability/_observability.py,"@@ -0,0 +1,179 @@+# Copyright 2023 gRPC authors.+#+# Licensed under the Apache License, Version 2.0 (the ""License"");+# you may not use this file except in compliance with the License.+# You may obtain a copy of the License at+#+#     http://www.apache.org/licenses/LICENSE-2.0+#+# Unless required by applicable law or agreed to in writing, software+# distributed under the License is distributed on an ""AS IS"" BASIS,+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+# See the License for the specific language governing permissions and+# limitations under the License.++from dataclasses import dataclass+from dataclasses import field+import logging+import threading+import time+from typing import Any, Mapping, Optional++import grpc+from grpc_observability import _cyobservability  # pytype: disable=pyi-error+from opencensus.trace import execution_context+from opencensus.trace import span_context as span_context_module+from opencensus.trace import trace_options as trace_options_module++_LOGGER = logging.getLogger(__name__)++ClientCallTracerCapsule = Any  # it appears only once in the function signature+ServerCallTracerFactoryCapsule = Any  # it appears only once in the function signature+grpc_observability = Any  # grpc_observability.py imports this module.++GRPC_STATUS_CODE_TO_STRING = {+    grpc.StatusCode.OK: ""OK"",+    grpc.StatusCode.CANCELLED: ""CANCELLED"",+    grpc.StatusCode.UNKNOWN: ""UNKNOWN"",+    grpc.StatusCode.INVALID_ARGUMENT: ""INVALID_ARGUMENT"",+    grpc.StatusCode.DEADLINE_EXCEEDED: ""DEADLINE_EXCEEDED"",+    grpc.StatusCode.NOT_FOUND: ""NOT_FOUND"",+    grpc.StatusCode.ALREADY_EXISTS: ""ALREADY_EXISTS"",+    grpc.StatusCode.PERMISSION_DENIED: ""PERMISSION_DENIED"",+    grpc.StatusCode.UNAUTHENTICATED: ""UNAUTHENTICATED"",+    grpc.StatusCode.RESOURCE_EXHAUSTED: ""RESOURCE_EXHAUSTED"",+    grpc.StatusCode.FAILED_PRECONDITION: ""FAILED_PRECONDITION"",+    grpc.StatusCode.ABORTED: ""ABORTED"",+    grpc.StatusCode.OUT_OF_RANGE: ""OUT_OF_RANGE"",+    grpc.StatusCode.UNIMPLEMENTED: ""UNIMPLEMENTED"",+    grpc.StatusCode.INTERNAL: ""INTERNAL"",+    grpc.StatusCode.UNAVAILABLE: ""UNAVAILABLE"",+    grpc.StatusCode.DATA_LOSS: ""DATA_LOSS"",+}+++@dataclass+class GcpObservabilityPythonConfig:+    _singleton = None+    _lock: threading.RLock = threading.RLock()+    project_id: str = """"+    stats_enabled: bool = False+    tracing_enabled: bool = False+    labels: Optional[Mapping[str, str]] = field(default_factory=dict)+    sampling_rate: Optional[float] = 0.0++    @staticmethod+    def get():+        with GcpObservabilityPythonConfig._lock:+            if GcpObservabilityPythonConfig._singleton is None:+                GcpObservabilityPythonConfig._singleton = GcpObservabilityPythonConfig(+                )+        return GcpObservabilityPythonConfig._singleton++    def set_configuration(self,+                          project_id: str,+                          sampling_rate: Optional[float] = 0.0,+                          labels: Optional[Mapping[str, str]] = None,+                          tracing_enabled: bool = False,+                          stats_enabled: bool = False) -> None:+        self.project_id = project_id+        self.stats_enabled = stats_enabled+        self.tracing_enabled = tracing_enabled+        self.labels = labels+        self.sampling_rate = sampling_rate+++# pylint: disable=no-self-use+class GCPOpenCensusObservability(grpc.ObservabilityPlugin):+    config: GcpObservabilityPythonConfig+    exporter: ""grpc_observability.Exporter""++    def __init__(self):+        # 1. Read config.+        self.exporter = None+        self.config = GcpObservabilityPythonConfig.get()+        config_valid = _cyobservability.set_gcp_observability_config(+            self.config)+        if not config_valid:+            raise ValueError(""Invalid configuration"")++        if self.config.tracing_enabled:+            self.enable_tracing(True)+        if self.config.stats_enabled:+            self.enable_stats(True)++    def init(self, exporter: ""grpc_observability.Exporter"" = None) -> None:+        if exporter:+            self.exporter = exporter+        else:+            # 2. Creating measures and register views.+            # 3. Create and Saves Tracer and Sampler to ContextVar.+            pass  # Actual implementation of OC exporter+            # open_census = importlib.import_module(+            #     ""grpc_observability._open_census"")+            # self.exporter = open_census.OpenCensusExporter(+            #     self.config.get().labels)++        # 4. Start exporting thread.+        try:+            _cyobservability.cyobservability_init(self.exporter)+        #TODO(xuanwn): Use specific exceptons+        except Exception as e:  # pylint: disable=broad-except+            _LOGGER.exception(""grpc_observability init failed with: %s"", e)++        # 5. Init grpc.+        # 5.1 Refister grpc_observability+        # 5.2 set_server_call_tracer_factory+        grpc._observability_init(self)++    def exit(self) -> None:+        # Sleep for 0.5s so all data can be flushed.+        time.sleep(0.5)",I just got some clarity on this from @ejona86 . The sleep is considered a kludge. We can add some synchronization with the export thread to exit as soon as all data has been exported.,
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/33192,1199070975,2023-05-19T15:04:19Z,test/core/ext/filters/event_engine_client_channel_resolver/resolver_fuzzer.cc,"@@ -142,57 +147,94 @@ class FuzzingResolverEventEngine    public:     explicit FuzzingDNSResolver(FuzzingResolverEventEngine* engine)         : engine_(engine) {}++    ~FuzzingDNSResolver() { GPR_ASSERT(known_handles == 0); }     LookupTaskHandle LookupHostname(LookupHostnameCallback on_resolve,                                     absl::string_view /* name */,                                     absl::string_view /* default_port */,                                     Duration /* timeout */) override {-      auto finish =-          [cb = std::move(on_resolve), runner = &engine_->runner_](-              absl::StatusOr<std::vector<ResolvedAddress>> response) mutable {-            runner->Run(-                [cb = std::move(cb), response = std::move(response)]() mutable {-                  cb(response);-                });-            return EventEngine::DNSResolver::LookupTaskHandle::kInvalid;-          };-      return finish(engine_->hostname_responses_);+      int handle = NextHandle();+      CheckAndSetOrphan(ShouldOrphan::DURING_LOOKUP_HOSTNAME);+      if (!engine_->has_been_orphaned_) {+        engine_->runner_.Run(+            [this, cb = std::move(on_resolve), handle]() mutable {+              if (!HandleExists(handle)) return;+              DeleteHandle(handle);+              cb(engine_->hostname_responses_);+              CheckAndSetOrphan(ShouldOrphan::AFTER_LOOKUP_HOSTNAME_CALLBACK);+            });+      }+      return {handle, 0};     }     LookupTaskHandle LookupSRV(LookupSRVCallback on_resolve,                                absl::string_view /* name */,                                Duration /* timeout */) override {-      auto finish =-          [cb = std::move(on_resolve), runner = &engine_->runner_](-              absl::StatusOr<std::vector<SRVRecord>> response) mutable {-            runner->Run(-                [cb = std::move(cb), response = std::move(response)]() mutable {-                  cb(response);-                });-            return EventEngine::DNSResolver::LookupTaskHandle::kInvalid;-          };-      return finish(engine_->srv_responses_);+      int handle = NextHandle();+      CheckAndSetOrphan(ShouldOrphan::DURING_LOOKUP_SRV);+      if (!engine_->has_been_orphaned_) {+        engine_->runner_.Run(+            [this, cb = std::move(on_resolve), handle]() mutable {+              if (!HandleExists(handle)) return;+              DeleteHandle(handle);+              cb(engine_->srv_responses_);+              CheckAndSetOrphan(ShouldOrphan::AFTER_LOOKUP_SRV_CALLBACK);+            });+      }+      return {handle, 0};     }     LookupTaskHandle LookupTXT(LookupTXTCallback on_resolve,                                absl::string_view /* name */,                                Duration /* timeout */) override {-      auto finish =-          [cb = std::move(on_resolve), runner = &engine_->runner_](-              absl::StatusOr<std::vector<std::string>> response) mutable {-            runner->Run(-                [cb = std::move(cb), response = std::move(response)]() mutable {-                  cb(response);-                });-            return EventEngine::DNSResolver::LookupTaskHandle::kInvalid;-          };-      return finish(engine_->txt_responses_);+      int handle = NextHandle();+      CheckAndSetOrphan(ShouldOrphan::DURING_LOOKUP_TXT);+      if (!engine_->has_been_orphaned_) {+        engine_->runner_.Run(+            [this, cb = std::move(on_resolve), handle]() mutable {+              if (!HandleExists(handle)) return;+              DeleteHandle(handle);+              cb(engine_->txt_responses_);+              CheckAndSetOrphan(ShouldOrphan::AFTER_LOOKUP_TXT_CALLBACK);+            });+      }+      return {handle, 0};+    }+    bool CancelLookup(LookupTaskHandle handle) override {+      int bit_handle = handle.keys[0];+      if (!HandleExists(bit_handle)) return false;+      DeleteHandle(bit_handle);+      return true;     }-    bool CancelLookup(LookupTaskHandle /* handle */) override { return false; }     private:+    int NextHandle() {+      static int next_handle = 1;+      if (next_handle == 0) ++next_handle;+      known_handles |= next_handle;+      auto ret = next_handle;+      next_handle <<= 1;+      return ret;+    }++    bool HandleExists(int handle) { return known_handles & handle; }++    void DeleteHandle(int handle) { known_handles -= handle; }++    void CheckAndSetOrphan(ShouldOrphan current_pc) {","I'm not sure what ""pc"" is supposed to stand for here.  Suggest choosing a clearer name for the parameter.",
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/33161,1199181807,2023-05-19T17:00:10Z,test/core/util/fuzzing_channel_args.h,"@@ -0,0 +1,44 @@+// Copyright 2023 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++#ifndef GRPC_TEST_CORE_UTIL_FUZZING_CHANNEL_ARGS_H+#define GRPC_TEST_CORE_UTIL_FUZZING_CHANNEL_ARGS_H++#include <grpc/support/port_platform.h>++#include ""absl/strings/string_view.h""++#include ""src/core/lib/channel/channel_args.h""+#include ""src/core/lib/gprpp/ref_counted_ptr.h""+#include ""src/core/lib/resource_quota/resource_quota.h""+#include ""test/core/util/fuzzing_channel_args.pb.h""++namespace grpc_core {+namespace testing {++// Create ChannelArgs from a fuzzer configuration.+// resource_quota is an optional input/output argument. If it's not a nullptr,+// it will be set on the ChannelArgs object. If it is a nullptr, then it will be+// set to a ResourceQuota object iff the fuzzer configuration has requested that+// a ResourceQuota be created.+// The prefix_identifier is a name given to the ResourceQuota if one is created.+ChannelArgs CreateFuzzingChannelArgs(+    const grpc::testing::FuzzingChannelArgs& fuzzing_channel_args,+    absl::string_view prefix_identifier,+    RefCountedPtr<ResourceQuota>* resource_quota = nullptr);","Good idea, I added something similar. It's fairly clean and has maybe one unnecessary allocation in some cases (probably none when we get designated initializers with C++20 ... someday).New thought for another improvement: the API fuzzer currently uses the same resource quota in both the client & server channels. It seems valuable to split them up to exercise separate reclamation actions for clients & servers. The logic gets a bit nicer if we make a proto change, but the following could work if we don't want to change the proto.```message Action {    reserved 2;    oneof type {        ...        // resize both client and server quotas.        uint32 resize_resource_quota = 22;        // use separate quotas. These are ignored if resize_resource_quota is specified.        uint32 resize_client_resource_quota = 23;        uint32 resize_server_resource_quota = 23;    }}```",
24593237,XuanWang-Amos,https://api.github.com/repos/grpc/grpc/pulls/32974,1199193022,2023-05-19T17:11:38Z,src/python/grpcio/grpc/_observability.py,"@@ -0,0 +1,125 @@+# Copyright 2023 The gRPC authors.+#+# Licensed under the Apache License, Version 2.0 (the ""License"");+# you may not use this file except in compliance with the License.+# You may obtain a copy of the License at+#+#     http://www.apache.org/licenses/LICENSE-2.0+#+# Unless required by applicable law or agreed to in writing, software+# distributed under the License is distributed on an ""AS IS"" BASIS,+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+# See the License for the specific language governing permissions and+# limitations under the License.++from __future__ import annotations++import abc+import contextlib+import logging+import threading+from typing import Any, Generic, Optional, TypeVar++from grpc._cython import cygrpc as _cygrpc++_LOGGER = logging.getLogger(__name__)++_channel = Any  # _channel.py imports this module.+ClientCallTracerCapsule = TypeVar('ClientCallTracerCapsule')+ServerCallTracerFactoryCapsule = TypeVar('ServerCallTracerFactoryCapsule')++_plugin_lock: threading.RLock = threading.RLock()+_OBSERVABILITY_PLUGIN: Optional[_ObservabilityPlugin] = None  # pylint: disable=used-before-assignment+++class _ObservabilityPlugin(Generic[ClientCallTracerCapsule,+                                   ServerCallTracerFactoryCapsule],+                           metaclass=abc.ABCMeta):+    """"""+    Note: Any future methods added to this interface cannot have the @abc.abstractmethod annotation.+    """"""+    _tracing_enabled: bool = False+    _stats_enabled: bool = False++    @abc.abstractmethod+    def create_client_call_tracer(+            self, method_name: bytes) -> ClientCallTracerCapsule:+        raise NotImplementedError()++    @abc.abstractmethod+    def delete_client_call_tracer(+            self, client_call_tracer: ClientCallTracerCapsule) -> None:+        # delte client call tracer have to be called on o11y package side.+        # Call it for both segregated and integrated call (`_process_integrated_call_tag`)+        raise NotImplementedError()++    @abc.abstractmethod+    def save_trace_context(self, trace_id: str, span_id: str,+                           is_sampled: bool) -> None:+        raise NotImplementedError()++    @abc.abstractmethod+    def create_server_call_tracer_factory(+            self) -> ServerCallTracerFactoryCapsule:+        raise NotImplementedError()++    @abc.abstractmethod+    def record_rpc_latency(self, method: str, rpc_latency: float,+                           status_code: Any) -> None:+        raise NotImplementedError()++    def set_tracing(self, enable: bool) -> None:+        self._tracing_enabled = enable++    def set_stats(self, enable: bool) -> None:+        self._stats_enabled = enable++    @property+    def tracing_enabled(self) -> bool:+        return self._tracing_enabled++    @property+    def stats_enabled(self) -> bool:+        return self._stats_enabled++    @property+    def observability_enabled(self) -> bool:+        return self.tracing_enabled or self.stats_enabled+++@contextlib.contextmanager+def get_plugin() -> Optional[_ObservabilityPlugin]:+    with _plugin_lock:+        yield _OBSERVABILITY_PLUGIN+++def set_plugin(observability_plugin: Optional[_ObservabilityPlugin]) -> None:+    global _OBSERVABILITY_PLUGIN  # pylint: disable=global-statement+    with _plugin_lock:+        if observability_plugin and _OBSERVABILITY_PLUGIN:+            raise ValueError(""observability_plugin was already set!"")+        _OBSERVABILITY_PLUGIN = observability_plugin+++def _observability_init(observability_plugin: _ObservabilityPlugin) -> None:","> I don't see parallelism between the calls that the o11y context manager makes. For example, set_plugin(foo) and set_plugin(None) or observability_init(foo) and observability_deinit()* Agree it's not a good idea to put `set_plugin(None)` in o11y context manager, I'll create an `observability_exit` to call it instead so plugin will only be changes by `_observability` module.> In the current setup, I don't see us ever cleaning up the server call tracer factory.* Right, I'll add cleanup code for server call tracer factory.> The name scheme here is confusing. set_plugin and _observability_init are both protected APIs -- ones that should only be used by packages maintained by us but I'm seeing a mixture of underscore patterns. I would suggest letting the underscore of the _observability module indicate that people should not touch this and removing the underscores from the functions in this module.* It was named `_observability_init` because we're exposing it directly to public in `__init__.py` and used as `grpc._observability_init`, I think it make sense to only underscore the module name. In this case, I'll remove this API from `grpc.__init__.py` so we'll call `grpc._observaiblity.observability_init` instead.",
16962414,gtcooke94,https://api.github.com/repos/grpc/grpc/pulls/33196,1199201807,2023-05-19T17:22:55Z,test/cpp/end2end/grpc_authz_end2end_test.cc,"@@ -415,6 +485,253 @@ TEST_F(GrpcAuthzEnd2EndTest,   EXPECT_EQ(resp.message(), kMessage); } +TEST_F(GrpcAuthzEnd2EndTest, StaticInitWithAuditLoggingOnDeny) {+  std::string policy =+      ""{""+      ""  \""name\"": \""authz\"",""+      ""  \""allow_rules\"": [""+      ""    {""+      ""      \""name\"": \""allow_foo\"",""+      ""      \""request\"": {""+      ""        \""headers\"": [""+      ""          {""+      ""            \""key\"": \""key-foo\"",""+      ""            \""values\"": [\""foo\""]""+      ""          }""+      ""        ]""+      ""      }""+      ""    }""+      ""  ],""+      ""  \""deny_rules\"": [""+      ""    {""+      ""      \""name\"": \""deny_bar\"",""+      ""      \""request\"": {""+      ""        \""headers\"": [""+      ""          {""+      ""            \""key\"": \""key-bar\"",""+      ""            \""values\"": [\""bar\""]""+      ""          }""+      ""        ]""+      ""      }""+      ""    }""+      ""  ],""+      ""  \""audit_logging_options\"": {""+      ""    \""audit_condition\"": \""ON_DENY\"",""+      ""    \""audit_loggers\"": [""+      ""      {""+      ""        \""name\"": \""test_logger\""""+      ""      },""+      ""      {""+      ""        \""name\"": \""stdout_logger\""""+      ""      }""+      ""    ]""+      ""  }""+      ""}"";+  InitServer(CreateStaticAuthzPolicyProvider(policy));+  auto channel = BuildChannel();+  grpc::testing::EchoResponse resp;+  grpc::Status status;++  ClientContext context1;+  context1.AddMetadata(""key-foo"", ""foo"");+  status = SendRpc(channel, &context1, &resp);+  EXPECT_TRUE(status.ok());+  EXPECT_EQ(log_count_, 0);++  ClientContext context2;+  context2.AddMetadata(""key-foo"", ""bar"");+  ::testing::internal::CaptureStdout();+  status = SendRpc(channel, &context2, &resp);+  CompareAuditLogEntry(+      ::testing::internal::GetCapturedStdout(),+      ""{\""authorized\"":false,\""matched_rule\"":\""\"",\""policy_name\"":\""authz\"",""+      ""\""principal\"":\""spiffe://foo.com/bar/baz\"",\""rpc_method\"":\""/""+      ""grpc.testing.EchoTestService/Echo\""}"");+  EXPECT_EQ(status.error_code(), grpc::StatusCode::PERMISSION_DENIED);+  EXPECT_EQ(status.error_message(), ""Unauthorized RPC request rejected."");+  EXPECT_EQ(log_count_, 1);++  ClientContext context3;",Would it be problematic to split this into 3 different tests? That way you don't have to chain failures or spend time figuring out which part failed,
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/33193,1199277246,2023-05-19T18:53:49Z,src/core/BUILD,"@@ -2252,6 +2268,7 @@ grpc_cc_library(         ""default_event_engine_factory"",         ""event_engine_trace"",         ""no_destruct"",+        ""thready_event_engine"",","Bloat is probably not an issue - if these symbols are unused (and they will be) they won't be compiled in.The compile time improvements would be marginal.The win here though is it means we can run the relevant ThreadyEventEngine tests in all configurations (to say, catch leaks in the implementation) even though its main use is only in one build configuration.",
24593237,XuanWang-Amos,https://api.github.com/repos/grpc/grpc/pulls/32974,1199686630,2023-05-21T02:49:50Z,src/python/grpcio_tests/tests/observability/_observability_test.py,"@@ -0,0 +1,341 @@+# Copyright 2023 gRPC authors.+#+# Licensed under the Apache License, Version 2.0 (the ""License"");+# you may not use this file except in compliance with the License.+# You may obtain a copy of the License at+#+#     http://www.apache.org/licenses/LICENSE-2.0+#+# Unless required by applicable law or agreed to in writing, software+# distributed under the License is distributed on an ""AS IS"" BASIS,+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+# See the License for the specific language governing permissions and+# limitations under the License.++from concurrent import futures+import logging+import os+from typing import List+import unittest++import grpc+import grpc_observability++logger = logging.getLogger(__name__)++_REQUEST = b'\x00\x00\x00'+_RESPONSE = b'\x00\x00\x00'++_UNARY_UNARY = '/test/UnaryUnary'+_UNARY_STREAM = '/test/UnaryStream'+_STREAM_UNARY = '/test/StreamUnary'+_STREAM_STREAM = '/test/StreamStream'+STREAM_LENGTH = 5++_VALID_CONFIG_TRACING_STATS = """"""+{+    ""project_id"":""test-project"",+    ""cloud_trace"":{+       ""sampling_rate"":1.00+    },+    ""cloud_monitoring"":{},+}+""""""++# Depends on grpc_core::IsTransportSuppliesClientLatencyEnabled,+# the following metrcis might not exist.+_SKIP_VEFIRY = [grpc_observability.MetricsName.CLIENT_TRANSPORT_LATENCY]+_SPAN_PREFIXS = ['Recv', 'Sent', 'Attempt']+++class TestExporter(grpc_observability.Exporter):++    def __init__(self, metrics: List[grpc_observability.StatsData],+                 spans: List[grpc_observability.TracingData]):+        self.span_collecter = spans+        self.metric_collecter = metrics+        self._server = None++    def export_stats_data(+            self, stats_data: List[grpc_observability.StatsData]) -> None:+        self.metric_collecter.extend(stats_data)++    def export_tracing_data(+            self, tracing_data: List[grpc_observability.TracingData]) -> None:+        self.span_collecter.extend(tracing_data)+++def handle_unary_unary(request, servicer_context):+    return _RESPONSE+++def handle_unary_stream(request, servicer_context):+    for _ in range(STREAM_LENGTH):+        yield _RESPONSE+++def handle_stream_unary(request_iterator, servicer_context):+    return _RESPONSE+++def handle_stream_stream(request_iterator, servicer_context):+    for request in request_iterator:+        yield _RESPONSE+++class _MethodHandler(grpc.RpcMethodHandler):++    def __init__(self, request_streaming, response_streaming):+        self.request_streaming = request_streaming+        self.response_streaming = response_streaming+        self.request_deserializer = None+        self.response_serializer = None+        self.unary_unary = None+        self.unary_stream = None+        self.stream_unary = None+        self.stream_stream = None+        if self.request_streaming and self.response_streaming:+            self.stream_stream = lambda x, y: handle_stream_stream(x, y)+        elif self.request_streaming:+            self.stream_unary = lambda x, y: handle_stream_unary(x, y)+        elif self.response_streaming:+            self.unary_stream = lambda x, y: handle_unary_stream(x, y)+        else:+            self.unary_unary = lambda x, y: handle_unary_unary(x, y)+++class _GenericHandler(grpc.GenericRpcHandler):++    def service(self, handler_call_details):+        if handler_call_details.method == _UNARY_UNARY:+            return _MethodHandler(False, False)+        elif handler_call_details.method == _UNARY_STREAM:+            return _MethodHandler(False, True)+        elif handler_call_details.method == _STREAM_UNARY:+            return _MethodHandler(True, False)+        elif handler_call_details.method == _STREAM_STREAM:+            return _MethodHandler(True, True)+        else:+            return None+++class ObservabilityTest(unittest.TestCase):","I checked existing interop tests and looks like we already have most of them covered with following exceptions:* Test trace sampling rate.  * Will add this.* Test use config file over env var.  * Will add this.* Test empty config.  * WiIl add this.* Logging test.  * Logging not implemented yet.* Test custom labels.  * This will be added together with `OpenCensusExporter` (The plan is add it in next PR).* Test integration with GCP.  * I don't think we need this since this will be handled by OC StackDriver extension, which can also be test in interop tests.* Test resource type and labels.  * Those will be added by OC StackDriver extension, I need to check if we can verify them before sending to GCP, otherwise I suggest test it in interop tests.",
35018399,YadongQi,https://api.github.com/repos/grpc/grpc/pulls/32847,1199929457,2023-05-22T03:54:10Z,src/core/lib/iomgr/vsock.h,"@@ -0,0 +1,40 @@+//+//+// Copyright 2021 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+//+//++#ifndef GRPC_SRC_CORE_LIB_IOMGR_VSOCK_H+#define GRPC_SRC_CORE_LIB_IOMGR_VSOCK_H++#include <grpc/support/port_platform.h>++#include <string>++#include ""absl/strings/string_view.h""++#include <grpc/support/string_util.h>++#include ""src/core/lib/iomgr/port.h""+#include ""src/core/lib/iomgr/resolve_address.h""++void grpc_create_socketpair_if_vsock(int sv[2]);","@drfloob, 1. for CentOS 7(CentOS Linux release 7.9.2009 (Core)), I have installed the OS and tried to build gRPC on it, the result turns out: - **Failed** to build with bazel(w or w/o this PR), see below errors:```[sdp@a4bf016a433b grpc]$ bazel build :allINFO: Running bazel wrapper (see //tools/bazel for details), bazel version 6.1.2 will be used instead of system-wide bazel installation.Starting local Bazel server and connecting to it...INFO: Analyzed 174 targets (169 packages loaded, 5375 targets configured).INFO: Found 174 targets...INFO: From Compiling utf8_validity.cc [for tool]:external/utf8_range/utf8_validity.cc:139:12: warning: unused function 'CodepointSkipBackwards' [-Wunused-function]inline int CodepointSkipBackwards(int32_t codepoint_word) {           ^1 warning generated.ERROR: /home/sdp/grpc/BUILD:677:16: Compiling src/core/lib/gpr/alloc.cc failed: (Exit 1): clang-11 failed: error executing command (from target //:gpr) /opt/rh/llvm-toolset-11.0/root/usr/bin/clang-11 -U_FORTIFY_SOURCE -fstack-protector -Wall -Wthread-safety -Wself-assign -fcolor-diagnostics -fno-omit-frame-pointer '-std=c++0x' -MD -MF ... (remaining 75 arguments skipped)Use --sandbox_debug to see verbose messages from the sandbox and retain the sandbox build root for debuggingsrc/core/lib/gpr/alloc.cc:21:10: error: module //:gpr does not depend on a module exporting 'stdlib.h'#include <stdlib.h>         ^1 error generated.INFO: Elapsed time: 27.790s, Critical Path: 5.43sINFO: 928 processes: 765 internal, 163 processwrapper-sandbox.FAILED: Build did NOT complete successfully```- **Succeed** to build with cmake(w or w/o this PR).- Since the build issue with bazel is not introduced by this PR, we can ignore the failure in this session, right?2. Just as you commented, we need to define `GRPC_HAVE_VSOCK` carefully, I have uploaded new commits to guard `GRPC_HAVE_VSOCK`, it will be enabled only when build with linux version >= 3.9. And also removed `grpc_create_socketpair_if_vsock()` since it is not supported. please help review.",
5663878,yijiem,https://api.github.com/repos/grpc/grpc/pulls/32701,1199949839,2023-05-22T04:47:55Z,src/core/lib/event_engine/grpc_ares_wrapper.h,"@@ -0,0 +1,340 @@+// Copyright 2023 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+#ifndef GRPC_SRC_CORE_LIB_EVENT_ENGINE_GRPC_ARES_WRAPPER_H+#define GRPC_SRC_CORE_LIB_EVENT_ENGINE_GRPC_ARES_WRAPPER_H++#include <grpc/support/port_platform.h>++#if GRPC_ARES == 1++#include <stddef.h>++#include <algorithm>+#include <memory>+#include <string>+#include <vector>++#include <ares.h>++#include ""absl/base/thread_annotations.h""+#include ""absl/functional/any_invocable.h""+#include ""absl/status/status.h""+#include ""absl/status/statusor.h""+#include ""absl/strings/string_view.h""+#include ""absl/types/optional.h""++#include <grpc/event_engine/event_engine.h>+#include <grpc/support/log.h>++#include ""src/core/lib/debug/trace.h""+#include ""src/core/lib/event_engine/grpc_polled_fd.h""+#include ""src/core/lib/gprpp/orphanable.h""+#include ""src/core/lib/gprpp/sync.h""++namespace grpc_event_engine {+namespace experimental {++extern grpc_core::TraceFlag grpc_trace_ares_wrapper;++#define GRPC_ARES_WRAPPER_TRACE_LOG(format, ...)                              \+  do {                                                                        \+    if (GRPC_TRACE_FLAG_ENABLED(grpc_trace_ares_wrapper)) {                   \+      gpr_log(GPR_INFO, ""(EventEngine c-ares wrapper) "" format, __VA_ARGS__); \+    }                                                                         \+  } while (0)++// Base class for the c-ares based DNS lookup functionality. This class is+// inherited by the concrete leaf classes below which each represents a+// different type of lookup (i.e. A/AAAA, SRV, TXT). One request object+// represents one lookup request for a specific name. GrpcAresRequest+// encapsulates the common logics to initialize and destroy the c-ares channel+// (one channel for one request). Sets the name servers configuration for the","This is an interesting point. I think it is true that c-ares API allows multiple requests on a single c-ares channel (it needs to be synchronized so multiple requests will share the same lock [0]). It might even save resources in doing so, e.g. per-channel linked-list|hash table and name servers list etc. can be shared. **Edit**: I could imagine that even connections can be shared in c-ares.However, there might be some hurdles in this approach:1. The biggest one seems to be cancellation. [ares_cancel](https://c-ares.org/ares_cancel.html) will cancel all the queries associated with a channel and there seems to be no alternative (see [1] also). This is in conflict with the EventEngine API which allows to cancel each individual request.2. Another sort of related issue is when we get a list of sockets/fds associated with a channel to wait on from c-ares, we don't necessarily know which one corresponding to which request (see [ares_getsock](https://c-ares.org/ares_getsock.html)). Besides the obvious issue with cancellation, this also has issue in timeout situation. Since we have separate timeout per-request, if one request timed out, we need to shutdown the poller handle and cancel the request. But we don't necessarily know which FdNodes should we shutdown for this request nor we can cancel the request per previous point.[0] https://github.com/c-ares/c-ares/issues/208[1] https://github.com/c-ares/c-ares/issues/135#issuecomment-392425642",
110920239,erm-g,https://api.github.com/repos/grpc/grpc/pulls/33196,1200946038,2023-05-22T19:20:54Z,test/cpp/end2end/grpc_authz_end2end_test.cc,,"Looks good! I think the only minor suggestion I have is to formally test `""audit_condition"": ""NONE""` ",
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/32847,1201106757,2023-05-22T21:08:41Z,src/core/lib/iomgr/vsock.h,"@@ -0,0 +1,40 @@+//+//+// Copyright 2021 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+//+//++#ifndef GRPC_SRC_CORE_LIB_IOMGR_VSOCK_H+#define GRPC_SRC_CORE_LIB_IOMGR_VSOCK_H++#include <grpc/support/port_platform.h>++#include <string>++#include ""absl/strings/string_view.h""++#include <grpc/support/string_util.h>++#include ""src/core/lib/iomgr/port.h""+#include ""src/core/lib/iomgr/resolve_address.h""++void grpc_create_socketpair_if_vsock(int sv[2]);","> Failed to build with bazel(w or w/o this PR), see below errors:Oh, fun! That looks like a bazel configuration issue. What version of bazel did you use? gRPC only supports 5.x and newer https://github.com/grpc/grpc/blob/master/bazel/supported_versions.txt. Something like [bazelisk](https://github.com/bazelbuild/bazelisk) would let you test with a supported version, if that's the issue.> I have uploaded new commits to guard GRPC_HAVE_VSOCK, it will be enabled only when build with linux version >= 3.9.That looks good. I've kicked off the CI again, and I'll take another pass at your implementation today. Thank you for your persistence!",
287917,eugeneo,https://api.github.com/repos/grpc/grpc/pulls/32973,1201344976,2023-05-23T00:27:54Z,src/core/ext/filters/stateful_session/stateful_session_filter.cc,"@@ -158,29 +189,46 @@ ArenaPromise<ServerMetadataHandle> StatefulSessionFilter::MakeCallPromise(               this, cookie_config->name->c_str(),               std::string(*cookie_value).c_str());     }-    // We have a valid cookie, so add the call attribute to be used by the-    // xds_override_host LB policy.-    service_config_call_data->SetCallAttribute(-        GetContext<Arena>()->New<XdsOverrideHostAttribute>(*cookie_value));+    std::pair<absl::string_view, absl::string_view> host_cluster =+        absl::StrSplit(*cookie_value, absl::MaxSplits(';', 1));+    if (!host_cluster.first.empty() &&+        OverrideClusterIfNeeded(host_cluster.second, service_config_call_data,+                                GetContext<Arena>())) {+      // We have a valid cookie, so add the call attribute to be used by the+      // xds_override_host LB policy.+      service_config_call_data->SetCallAttribute(+          GetContext<Arena>()->New<XdsOverrideHostAttribute>(+              host_cluster.first));+    }+    // Cluster is not yet in use+  }+  absl::string_view cluster_name;+  auto cluster_name_attribute = static_cast<XdsClusterAttribute*>(+      service_config_call_data->GetCallAttribute(+          XdsClusterAttribute::TypeName()));+  if (cluster_name_attribute != nullptr) {+    cluster_name = cluster_name_attribute->cluster();   }   // Intercept server initial metadata.   call_args.server_initial_metadata->InterceptAndMap(-      [cookie_config, cookie_value](ServerMetadataHandle md) {+      [cookie_config, cookie_value, cluster_name](ServerMetadataHandle md) {",Looks like we need two things on the arena:1. Decoded cookie value (`host;cluster`) Host and cluster attributes will refer to parts of this string.2. Cluster name from the `XdsClusterAttribute` if there was none in cookie or the one from cookie is no longer available.,
35018399,YadongQi,https://api.github.com/repos/grpc/grpc/pulls/32847,1201438103,2023-05-23T02:48:17Z,src/core/lib/iomgr/vsock.h,"@@ -0,0 +1,40 @@+//+//+// Copyright 2021 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+//+//++#ifndef GRPC_SRC_CORE_LIB_IOMGR_VSOCK_H+#define GRPC_SRC_CORE_LIB_IOMGR_VSOCK_H++#include <grpc/support/port_platform.h>++#include <string>++#include ""absl/strings/string_view.h""++#include <grpc/support/string_util.h>++#include ""src/core/lib/iomgr/port.h""+#include ""src/core/lib/iomgr/resolve_address.h""++void grpc_create_socketpair_if_vsock(int sv[2]);","> What version of bazel did you use? gRPC only supports 5.x and newer https://github.com/grpc/grpc/blob/master/bazel/supported_versions.txt. Something like [bazelisk](https://github.com/bazelbuild/bazelisk) would let you test with a supported version, if that's the issue.Original bazel version is v4.2.1, but even after I upgrade it to v6.1.2, the issue still exists.```[sdp@a4bf016a433b grpc]$ bazel --versionbazel 6.1.2[sdp@a4bf016a433b grpc]$ bazel build :allStarting local Bazel server and connecting to it...INFO: Analyzed 174 targets (169 packages loaded, 5375 targets configured).INFO: Found 174 targets...ERROR: /home/sdp/grpc/BUILD:2408:16: Compiling src/core/lib/config/config_vars_non_generated.cc failed: (Exit 1): clang-11 failed: error executing command (from target //:config_vars) /opt/rh/llvm-toolset-11.0/root/usr/bin/clang-11 -U_FORTIFY_SOURCE -fstack-protector -Wall -Wthread-safety -Wself-assign -fcolor-diagnostics -fno-omit-frame-pointer '-std=c++0x' -MD -MF ... (remaining 57 arguments skipped)Use --sandbox_debug to see verbose messages from the sandbox and retain the sandbox build root for debuggingsrc/core/lib/config/config_vars_non_generated.cc:19:10: error: module //:config_vars does not depend on a module exporting 'atomic'#include <atomic>         ^src/core/lib/config/config_vars_non_generated.cc:20:10: error: module //:config_vars does not depend on a module exporting 'string'#include <string>         ^2 errors generated.INFO: Elapsed time: 25.616s, Critical Path: 3.96sINFO: 1016 processes: 884 internal, 132 processwrapper-sandbox.FAILED: Build did NOT complete successfully```I think we can create a seperate issue for the grpc build with bazel on CentOS 7, no need to expand more here.For the CI results, there still 3 failures:[Bazel BinderTransport APK building/testing](https://source.cloud.google.com/results/invocations/b6d4559e-6b43-49db-bb9e-778a4a998348) : submitted commit to resolve it[Distribution Tests Python Linux](https://source.cloud.google.com/results/invocations/88f6f3fc-c2ab-4eb5-9b01-3745ce4c9150) : No idea...[IWYU (internal CI) ](https://source.cloud.google.com/results/invocations/d8cab4bc-f25a-4990-9237-373b5220c653) : It seems suggest some including position adjust, not sure to follow, do you have any comments?",
287917,eugeneo,https://api.github.com/repos/grpc/grpc/pulls/32973,1202791718,2023-05-23T17:58:12Z,src/core/ext/filters/client_channel/resolver/xds/xds_resolver.h,"@@ -40,6 +41,31 @@ class XdsClusterAttribute    absl::string_view cluster_; };++class ClusterRef;+class RouteData;++class XdsClusterDataAttribute+    : public ServiceConfigCallData::CallAttributeInterface {+ public:+  static UniqueTypeName TypeName();++  explicit XdsClusterDataAttribute(RefCountedPtr<RouteData> route_data,+                                   void* route);++  // This method can be called only once. The first call will release the+  // reference to the cluster map, and subsequent calls will return nullptr.+  RefCountedPtr<ClusterRef> LockAndGetCluster(absl::string_view cluster_name);++  bool HasClusterForRoute(absl::string_view cluster_name) const;++  UniqueTypeName type() const override { return TypeName(); }++ private:+  RefCountedPtr<RouteData> route_data_;+  // No need to leak another type",Done. Moved a bunch of classes back to nested...,X
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/33223,1202982062,2023-05-23T20:42:14Z,src/core/lib/event_engine/thread_pool/work_stealing_thread_pool.cc,"@@ -55,7 +55,9 @@ constexpr grpc_core::Duration kLifeguardMinSleepBetweenChecks{     grpc_core::Duration::Milliseconds(15)}; constexpr grpc_core::Duration kLifeguardMaxSleepBetweenChecks{     grpc_core::Duration::Seconds(1)};-constexpr absl::Duration kSleepBetweenQuiesceCheck{absl::Milliseconds(10)};+// TODO(hork): quiesce may be faster and more efficient with a lock + condition+// on thread_count = N.+constexpr absl::Duration kSleepBetweenQuiesceCheck{absl::Microseconds(50)};","> This gets close to busy waiting.Exactly, that's the reasoning behind the TODO. Introducing a new mutex + condvar wait could eliminate the loop, but quiesce should be a fairly infrequent thing, and will hopefully not take long when it does happen.>  Is the Quiesce time crucial for performance?It makes stress testing feasible.",
24593237,XuanWang-Amos,https://api.github.com/repos/grpc/grpc/pulls/32974,1203154151,2023-05-23T23:34:34Z,src/python/grpcio_observability/grpc_observability/_observability.py,"@@ -0,0 +1,172 @@+# Copyright 2023 gRPC authors.+#+# Licensed under the Apache License, Version 2.0 (the ""License"");+# you may not use this file except in compliance with the License.+# You may obtain a copy of the License at+#+#     http://www.apache.org/licenses/LICENSE-2.0+#+# Unless required by applicable law or agreed to in writing, software+# distributed under the License is distributed on an ""AS IS"" BASIS,+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+# See the License for the specific language governing permissions and+# limitations under the License.++from dataclasses import dataclass+from dataclasses import field+import logging+import threading+import time+from typing import Any, Mapping, Optional++import grpc+from grpc_observability import _cyobservability  # pytype: disable=pyi-error+from opencensus.trace import execution_context+from opencensus.trace import span_context as span_context_module+from opencensus.trace import trace_options as trace_options_module++_LOGGER = logging.getLogger(__name__)++ClientCallTracerCapsule = Any  # it appears only once in the function signature+ServerCallTracerFactoryCapsule = Any  # it appears only once in the function signature+grpc_observability = Any  # grpc_observability.py imports this module.++GRPC_STATUS_CODE_TO_STRING = {+    grpc.StatusCode.OK: ""OK"",+    grpc.StatusCode.CANCELLED: ""CANCELLED"",+    grpc.StatusCode.UNKNOWN: ""UNKNOWN"",+    grpc.StatusCode.INVALID_ARGUMENT: ""INVALID_ARGUMENT"",+    grpc.StatusCode.DEADLINE_EXCEEDED: ""DEADLINE_EXCEEDED"",+    grpc.StatusCode.NOT_FOUND: ""NOT_FOUND"",+    grpc.StatusCode.ALREADY_EXISTS: ""ALREADY_EXISTS"",+    grpc.StatusCode.PERMISSION_DENIED: ""PERMISSION_DENIED"",+    grpc.StatusCode.UNAUTHENTICATED: ""UNAUTHENTICATED"",+    grpc.StatusCode.RESOURCE_EXHAUSTED: ""RESOURCE_EXHAUSTED"",+    grpc.StatusCode.FAILED_PRECONDITION: ""FAILED_PRECONDITION"",+    grpc.StatusCode.ABORTED: ""ABORTED"",+    grpc.StatusCode.OUT_OF_RANGE: ""OUT_OF_RANGE"",+    grpc.StatusCode.UNIMPLEMENTED: ""UNIMPLEMENTED"",+    grpc.StatusCode.INTERNAL: ""INTERNAL"",+    grpc.StatusCode.UNAVAILABLE: ""UNAVAILABLE"",+    grpc.StatusCode.DATA_LOSS: ""DATA_LOSS"",+}+++@dataclass+class GcpObservabilityPythonConfig:+    _singleton = None+    _lock: threading.RLock = threading.RLock()+    project_id: str = """"+    stats_enabled: bool = False+    tracing_enabled: bool = False+    labels: Optional[Mapping[str, str]] = field(default_factory=dict)+    sampling_rate: Optional[float] = 0.0++    @staticmethod+    def get():+        with GcpObservabilityPythonConfig._lock:+            if GcpObservabilityPythonConfig._singleton is None:+                GcpObservabilityPythonConfig._singleton = GcpObservabilityPythonConfig(+                )+        return GcpObservabilityPythonConfig._singleton++    def set_configuration(self,+                          project_id: str,+                          sampling_rate: Optional[float] = 0.0,+                          labels: Optional[Mapping[str, str]] = None,+                          tracing_enabled: bool = False,+                          stats_enabled: bool = False) -> None:+        self.project_id = project_id+        self.stats_enabled = stats_enabled+        self.tracing_enabled = tracing_enabled+        self.labels = labels+        self.sampling_rate = sampling_rate+++# pylint: disable=no-self-use+class GCPOpenCensusObservability(grpc._observability.ObservabilityPlugin):+    config: GcpObservabilityPythonConfig+    exporter: ""grpc_observability.Exporter""++    def __init__(self, exporter: ""grpc_observability.Exporter"" = None):+        self.exporter = None+        self.config = GcpObservabilityPythonConfig.get()+        if exporter:+            self.exporter = exporter+        else:+            pass+            # Actual implementation of OC exporter+            # open_census = importlib.import_module(+            #     ""grpc_observability._open_census"")+            # self.exporter = open_census.OpenCensusExporter(+            #     self.config.get().labels)+        config_valid = _cyobservability.set_gcp_observability_config(+            self.config)+        if not config_valid:+            raise ValueError(""Invalid configuration"")++        if self.config.tracing_enabled:+            self.set_tracing(True)+        if self.config.stats_enabled:+            self.set_stats(True)++    def exit(self) -> None:+        # Sleep for 0.5s so all data can be flushed.+        # The time equals to the time in AwaitNextBatchLocked.+        time.sleep(_cyobservability.CENSUS_EXPORT_BATCH_INTERVAL)","> The sleep is considered a kludge. We can add some synchronization with the export thread to exit as soon as all data has been exported.* It's not enough to exit as soon as all data has been exported, If we shutdown export thread immediately after exit, it's possible that core didn't call RecordEnd in callTracer, and all data recorded by calling RecordEnd will be lost.* It's also possible to ignore those metrics since we have already exited the observability context, so anything recorded after this can be ignored. However, I think we should keep it because RecordEnd is part of RPC, and we should at least try our best (sleep one interval) to make sure it's called before exit.",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/33228,1203421027,2023-05-24T04:46:41Z,src/core/lib/experiments/config.cc,"@@ -50,13 +50,21 @@ ForcedExperiment g_forced_experiments[kNumExperiments];  std::atomic<bool> g_loaded(false); +absl::AnyInvocable<bool(struct ExperimentMetadata)> g_check_constraints_cb =","`AnyInvocable` is not trivially destructable, so we'll need to choose something else.Probably in this case a pointer would be fine (we could even delete it once we've checked the constraints!)... so `absl::AnyInvocable<bool(struct ExperimentMetadata)>* g_check_constraints_cb`?",
5564114,Vignesh2208,https://api.github.com/repos/grpc/grpc/pulls/33205,1204737647,2023-05-24T20:39:58Z,src/core/lib/slice/slice.h,"@@ -342,6 +342,22 @@ class GPR_MSVC_EMPTY_BASE_CLASS_WORKAROUND Slice     return Slice(TakeCSlice());   } +  // As per TakeOwned, but if the slice is refcounted and there are other refs+  // then it will copy instead of ref-counting, to ensure the returned slice is+  // not shared.+  Slice TakeUniquelyOwned() {",Do these slices typically tend to be small ? Otherwise is there any danger of too much copying of large slices ?,
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/33205,1204745590,2023-05-24T20:49:07Z,src/core/lib/slice/slice.h,"@@ -342,6 +342,22 @@ class GPR_MSVC_EMPTY_BASE_CLASS_WORKAROUND Slice     return Slice(TakeCSlice());   } +  // As per TakeOwned, but if the slice is refcounted and there are other refs+  // then it will copy instead of ref-counting, to ensure the returned slice is+  // not shared.+  Slice TakeUniquelyOwned() {","Yeah... we have a default limit of 64kb for *all* of them, so there's an upper bound.Realistically though, things that get compressed with our workloads are things like call path at 100s of bytes.Still, there's some variability, so making this an experiment for safety!",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32973,1205755787,2023-05-25T16:22:54Z,src/core/ext/filters/client_channel/resolver/xds/xds_resolver.cc,"@@ -199,6 +199,89 @@ class XdsResolver : public Resolver {     RefCountedPtr<XdsResolver> resolver_;   }; +  // An entry in the map of clusters that need to be present in the LB+  // policy config.  The map holds a weak ref.  One strong ref is held by+  // the ConfigSelector, and another is held by each call assigned to+  // the cluster by the ConfigSelector.  The ref for each call is held+  // until the call is committed.  When the strong refs go away, we hop+  // back into the WorkSerializer to remove the entry from the map.+  class ClusterRef : public DualRefCounted<ClusterRef> {","Please move these two classes back down to line 326, which is where `ClusterState` was before this PR.  That will minimize the diff, and it will keep the two xDS resource watcher classes (`ListenerWatcher` and `RouteConfigWatcher`) next to each other.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32973,1205765274,2023-05-25T16:31:33Z,src/core/ext/filters/client_channel/resolver/xds/xds_resolver.cc,"@@ -380,10 +346,30 @@ class XdsResolver : public Resolver {     private:     RefCountedPtr<XdsResolver> resolver_;-    RefCountedPtr<RouteData> route_data_;+    RefCountedPtr<RouteConfigData> route_config_data_;     std::vector<const grpc_channel_filter*> filters_;   }; +  class XdsRouteStateAttributeImpl : public XdsRouteStateAttribute {+   public:+    explicit XdsRouteStateAttributeImpl(+        RefCountedPtr<RouteConfigData> route_config_data,+        RouteConfigData::RouteEntry* route)+        : route_config_data_(std::move(route_config_data)), route_(route) {}++    // This method can be called only once. The first call will release+    // the reference to the cluster map, and subsequent calls will return+    // nullptr.+    RefCountedPtr<ClusterRef> LockAndGetCluster(absl::string_view cluster_name);++    bool HasClusterForRoute(absl::string_view cluster_name) const override;++   private:+    RefCountedPtr<RouteConfigData> route_config_data_;+    // No need to leak another type",This comment is no longer needed.,X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32973,1205771527,2023-05-25T16:37:06Z,src/core/ext/filters/client_channel/resolver/xds/xds_resolver.cc,"@@ -240,73 +323,19 @@ class XdsResolver : public Resolver {     RefCountedPtr<XdsResolver> resolver_;   }; -  // An entry in the map of clusters that need to be present in the LB-  // policy config.  The map holds a weak ref.  One strong ref is held by-  // the ConfigSelector, and another is held by each call assigned to-  // the cluster by the ConfigSelector.  The ref for each call is held-  // until the call is committed.  When the strong refs go away, we hop-  // back into the WorkSerializer to remove the entry from the map.-  class ClusterState : public DualRefCounted<ClusterState> {-   public:-    ClusterState(RefCountedPtr<XdsResolver> resolver,-                 absl::string_view cluster_name)-        : resolver_(std::move(resolver)), cluster_name_(cluster_name) {}--    void Orphan() override {-      auto* resolver = resolver_.get();-      resolver->work_serializer_->Run(-          [resolver = std::move(resolver_)]() {-            resolver->MaybeRemoveUnusedClusters();-          },-          DEBUG_LOCATION);-    }--    const std::string& cluster_name() const { return cluster_name_; }--   private:-    RefCountedPtr<XdsResolver> resolver_;-    std::string cluster_name_;-  };--  // A map containing cluster refs held by the XdsConfigSelector. A ref to-  // this map will be taken by each call processed by the XdsConfigSelector,-  // stored in a the call's call attributes, and later unreffed-  // by the ClusterSelection filter.-  class XdsClusterMap : public RefCounted<XdsClusterMap> {-   public:-    explicit XdsClusterMap(-        std::map<absl::string_view, RefCountedPtr<ClusterState>> clusters)-        : clusters_(std::move(clusters)) {}--    bool operator==(const XdsClusterMap& other) const {-      return clusters_ == other.clusters_;-    }--    RefCountedPtr<ClusterState> Find(absl::string_view name) const {-      auto it = clusters_.find(name);-      if (it == clusters_.end()) {-        return nullptr;-      }-      return it->second;-    }--   private:-    std::map<absl::string_view, RefCountedPtr<ClusterState>> clusters_;-  };-   class XdsConfigSelector : public ConfigSelector {    public:-    XdsConfigSelector(RefCountedPtr<XdsResolver> resolver,-                      absl::Status* status);+    XdsConfigSelector(RefCountedPtr<RouteConfigData> route_config_data,","Please swap the order of these two parameters, to match the order in which the data members are defined.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32973,1205815695,2023-05-25T17:21:26Z,src/core/ext/filters/client_channel/resolver/xds/xds_resolver.cc,"@@ -1186,7 +1240,8 @@ absl::Status RouteData::AddRouteEntry(                 weighted_clusters) {           uint32_t end = 0;           for (const auto& weighted_cluster : weighted_clusters) {-            RouteData::RouteEntry::ClusterWeightState cluster_weight_state;+            RouteConfigData::RouteEntry::ClusterWeightState","No need for the `RouteConfigData::` prefix here, since we're already in that class here.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32973,1205820014,2023-05-25T17:26:11Z,src/core/ext/filters/client_channel/resolver/xds/xds_resolver.cc,"@@ -461,8 +459,7 @@ class XdsResolver : public Resolver {            std::string /*LB policy config*/>       cluster_specifier_plugin_map_; -  std::map<absl::string_view, WeakRefCountedPtr<ClusterState>>-      cluster_state_map_;+  std::map<absl::string_view, WeakRefCountedPtr<ClusterRef>> cluster_ref_map_; };  //","Please group all of the method definitions by class, with a 3-line block comment for each class.  And please define the methods in the same order in which they are declared above.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32973,1205828265,2023-05-25T17:35:05Z,src/core/ext/filters/client_channel/resolver/xds/xds_resolver.cc,"@@ -162,6 +255,31 @@ class XdsResolver : public Resolver {     if (xds_client_ != nullptr) xds_client_->ResetBackoff();   } +  void MaybeRemoveUnusedClustersOnWorkSerializer() {+    work_serializer_->Run(+        [resolver = Ref()]() mutable {+          static_cast<XdsResolver*>(resolver.get())+              ->MaybeRemoveUnusedClusters();+        },+        DEBUG_LOCATION);+  }++  RefCountedPtr<ClusterRef> GetOrCreateClusterRef(+      absl::string_view cluster_name) {+    auto it = cluster_state_map_.find(cluster_name);+    if (it == cluster_state_map_.end()) {+      auto cluster = MakeRefCounted<ClusterRef>(Ref(), cluster_name);+      cluster_state_map_.emplace(cluster->cluster_name(), cluster->WeakRef());+      return cluster;+    }+    return it->second->Ref();+  }++  absl::StatusOr<RefCountedPtr<ServiceConfig>> CreateMethodConfig(","`RouteConfigData` is nested inside of `XdsResolver`, so it can access all of the data members of `XdsResolver`.  And since the purpose of this method is to help build the `RouteConfigData`, and the only place it is called is inside of `RouteConfigData`, I think it makes sense for the method to be in that class.Note that this is basically the same as the code prior to this PR: this method used to be in `XdsConfigSelector`, which is also directly nested inside of `XdsResolver`, and it directly accessed the resolver's data members.",X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32973,1205876885,2023-05-25T18:30:13Z,test/cpp/end2end/xds/xds_override_host_end2end_test.cc,"@@ -150,6 +155,50 @@ class OverrideHostTest : public XdsEnd2endTest {         << ""Desired backend had not been hit"";     return {};   }++  void SetClusterResource(absl::string_view cluster_name,+                          absl::string_view service_name) {",Please call this parameter `eds_resource_name`.,X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32973,1205877546,2023-05-25T18:30:59Z,test/cpp/end2end/xds/xds_override_host_end2end_test.cc,"@@ -150,6 +155,50 @@ class OverrideHostTest : public XdsEnd2endTest {         << ""Desired backend had not been hit"";     return {};   }++  void SetClusterResource(absl::string_view cluster_name,+                          absl::string_view service_name) {+    Cluster cluster = default_cluster_;+    cluster.set_name(cluster_name);+    cluster.mutable_eds_cluster_config()->set_service_name(service_name);+    balancer_->ads_service()->SetCdsResource(cluster);+  }++  struct ClusterData {+    const char* clusterName;+    uint32_t weight;+  };++  RouteConfiguration BuildRouteConfiguration(+      const std::vector<ClusterData>& clusters) {+    RouteConfiguration new_route_config = default_route_config_;+    auto* route1 = new_route_config.mutable_virtual_hosts(0)->mutable_routes(0);+    route1->mutable_match()->set_prefix("""");+    for (const auto& cluster : clusters) {+      auto* weighted_cluster =+          route1->mutable_route()->mutable_weighted_clusters()->add_clusters();+      weighted_cluster->set_name(cluster.clusterName);+      weighted_cluster->mutable_weight()->set_value(cluster.weight);+    }+    return new_route_config;+  }++  void SetEdsCdsResources(const char* cluster_name,",These parameters should be `absl::string_view` instead of `const char*`.,
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32973,1205891981,2023-05-25T18:47:16Z,test/cpp/end2end/xds/xds_override_host_end2end_test.cc,"@@ -121,13 +122,17 @@ class OverrideHostTest : public XdsEnd2endTest {   std::vector<std::pair<std::string, std::string>>   GetAffinityCookieHeaderForBackend(grpc_core::DebugLocation debug_location,                                     size_t backend_index,+                                    size_t max_requests = 0,","I don't understand the purpose of this parameter.  It looks to me like the loop below will always exit on the first iteration that hits the specified backend, no matter how high this number is.",
1644595,gnossen,https://api.github.com/repos/grpc/grpc/pulls/32974,1206039979,2023-05-25T21:55:17Z,src/python/grpcio_observability/grpc_observability/_observability.py,"@@ -0,0 +1,172 @@+# Copyright 2023 gRPC authors.+#+# Licensed under the Apache License, Version 2.0 (the ""License"");+# you may not use this file except in compliance with the License.+# You may obtain a copy of the License at+#+#     http://www.apache.org/licenses/LICENSE-2.0+#+# Unless required by applicable law or agreed to in writing, software+# distributed under the License is distributed on an ""AS IS"" BASIS,+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+# See the License for the specific language governing permissions and+# limitations under the License.++from dataclasses import dataclass+from dataclasses import field+import logging+import threading+import time+from typing import Any, Mapping, Optional++import grpc+from grpc_observability import _cyobservability  # pytype: disable=pyi-error+from opencensus.trace import execution_context+from opencensus.trace import span_context as span_context_module+from opencensus.trace import trace_options as trace_options_module++_LOGGER = logging.getLogger(__name__)++ClientCallTracerCapsule = Any  # it appears only once in the function signature+ServerCallTracerFactoryCapsule = Any  # it appears only once in the function signature+grpc_observability = Any  # grpc_observability.py imports this module.++GRPC_STATUS_CODE_TO_STRING = {+    grpc.StatusCode.OK: ""OK"",+    grpc.StatusCode.CANCELLED: ""CANCELLED"",+    grpc.StatusCode.UNKNOWN: ""UNKNOWN"",+    grpc.StatusCode.INVALID_ARGUMENT: ""INVALID_ARGUMENT"",+    grpc.StatusCode.DEADLINE_EXCEEDED: ""DEADLINE_EXCEEDED"",+    grpc.StatusCode.NOT_FOUND: ""NOT_FOUND"",+    grpc.StatusCode.ALREADY_EXISTS: ""ALREADY_EXISTS"",+    grpc.StatusCode.PERMISSION_DENIED: ""PERMISSION_DENIED"",+    grpc.StatusCode.UNAUTHENTICATED: ""UNAUTHENTICATED"",+    grpc.StatusCode.RESOURCE_EXHAUSTED: ""RESOURCE_EXHAUSTED"",+    grpc.StatusCode.FAILED_PRECONDITION: ""FAILED_PRECONDITION"",+    grpc.StatusCode.ABORTED: ""ABORTED"",+    grpc.StatusCode.OUT_OF_RANGE: ""OUT_OF_RANGE"",+    grpc.StatusCode.UNIMPLEMENTED: ""UNIMPLEMENTED"",+    grpc.StatusCode.INTERNAL: ""INTERNAL"",+    grpc.StatusCode.UNAVAILABLE: ""UNAVAILABLE"",+    grpc.StatusCode.DATA_LOSS: ""DATA_LOSS"",+}+++@dataclass+class GcpObservabilityPythonConfig:+    _singleton = None+    _lock: threading.RLock = threading.RLock()+    project_id: str = """"+    stats_enabled: bool = False+    tracing_enabled: bool = False+    labels: Optional[Mapping[str, str]] = field(default_factory=dict)+    sampling_rate: Optional[float] = 0.0++    @staticmethod+    def get():+        with GcpObservabilityPythonConfig._lock:+            if GcpObservabilityPythonConfig._singleton is None:+                GcpObservabilityPythonConfig._singleton = GcpObservabilityPythonConfig(+                )+        return GcpObservabilityPythonConfig._singleton++    def set_configuration(self,+                          project_id: str,+                          sampling_rate: Optional[float] = 0.0,+                          labels: Optional[Mapping[str, str]] = None,+                          tracing_enabled: bool = False,+                          stats_enabled: bool = False) -> None:+        self.project_id = project_id+        self.stats_enabled = stats_enabled+        self.tracing_enabled = tracing_enabled+        self.labels = labels+        self.sampling_rate = sampling_rate+++# pylint: disable=no-self-use+class GCPOpenCensusObservability(grpc._observability.ObservabilityPlugin):+    config: GcpObservabilityPythonConfig+    exporter: ""grpc_observability.Exporter""++    def __init__(self, exporter: ""grpc_observability.Exporter"" = None):+        self.exporter = None+        self.config = GcpObservabilityPythonConfig.get()+        if exporter:+            self.exporter = exporter+        else:+            pass+            # Actual implementation of OC exporter+            # open_census = importlib.import_module(+            #     ""grpc_observability._open_census"")+            # self.exporter = open_census.OpenCensusExporter(+            #     self.config.get().labels)+        config_valid = _cyobservability.set_gcp_observability_config(+            self.config)+        if not config_valid:+            raise ValueError(""Invalid configuration"")++        if self.config.tracing_enabled:+            self.set_tracing(True)+        if self.config.stats_enabled:+            self.set_stats(True)++    def exit(self) -> None:+        # Sleep for 0.5s so all data can be flushed.+        # The time equals to the time in AwaitNextBatchLocked.+        time.sleep(_cyobservability.CENSUS_EXPORT_BATCH_INTERVAL)","> It's also possible to ignore those metrics since we have already exited the observability context, so anything recorded after this can be ignored. However, I think we should keep it because RecordEnd is part of RPC, and we should at least try our best This seems reasonable. The guarantee would be that ""any RPC started while the context manager is active would be recorded"".So the concern is a situation like this?- RPC A starts- `GCPOpenCensusObservability.exit()` is called  - A flush of the buffer is initiated  - The export of the census data finishes- `GCPOpenCensusObservability.exit()` returns based on its synchronization with the export thread- RPC A finishes and `StartEnd` is called, but o11y has finishedI can see this being an issue. Could you just keep track of the number of outstanding RPCs and keep stats collection open until either all of the RPCs have finished or a timeout has elapsed? (You don't want to just block indefinitely for RPCs to finish)> If we shutdown export thread immediately after exit, it's possible that core didn't call RecordEnd in callTracerMy concern that led to the request for synchronization was actually the opposite -- that by waiting for too short a period of time, the stats would not be exported in time, the process would exit, and the buffered data would be lost.This relates to the lifecycle of the stats exporting thread. I just realized that this is not currently a daemon thread, so if the process tries to exit, it will block waiting for the stats thread to exit. This could happen if, for example, there is a bug in the opencensus library, so I _do_ think we should switch to a daemon thread.But that introduces the problem with the process exiting (and killing the exporting thread) before the stats have been exported. My thought was that the `exit()` method here would block until either exporting has finished or we hit a user-configurable timeout. ",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/33252,1206064713,2023-05-25T22:42:24Z,test/cpp/end2end/xds/xds_end2end_test_lib.h,"@@ -135,6 +147,19 @@ class XdsTestType {     } else if (rbac_action_ == ::envoy::config::rbac::v3::RBAC_Action_DENY) {       retval += ""RbacDeny"";     }+    if (rbac_audit_condition_ ==","I think you could write this a bit more easily using the protobuf method to stringify the enum element:https://protobuf.dev/reference/cpp/cpp-generated/#enumSo you should be able to do something like this:```if (rbac_audit_condition_ !=    ::envoy::config::rbac::v3::            RBAC_AuditLoggingOptions_AuditCondition_NONE) {  retval += absl::StrCat(      ""AuditCondition"",      ::envoy::config::rbac::v3::          RBAC_AuditLoggingOptions_AuditCondition_Name(              rbac_audit_condition_));}```",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/33254,1206084672,2023-05-25T23:23:11Z,src/core/ext/filters/client_channel/lb_policy/pick_first/pick_first.cc,"@@ -281,6 +322,13 @@ absl::Status PickFirst::UpdateLocked(UpdateArgs args) {   }   // Update latest_update_args_.   latest_update_args_ = std::move(args);+  if (latest_update_args_.config != nullptr) {+    RefCountedPtr<PickFirstConfig> config = latest_update_args_.config;+    if (config->shuffle_addresses() && ShufflePickFirstEnabled()) {+      static absl::BitGen bit_gen;","I suspect this violates the style guide rules about [static and global variables](https://google.github.io/styleguide/cppguide.html#Static_and_Global_Variables).  In addition, [the `absl::BitGen` object is not thread-safe](https://abseil.io/docs/cpp/guides/random#what-about-instances-shared-across-multiple-threads), and there can be multiple `pick_first` policies running on different channels in different threads at the same time, so I don't think this is safe anyway.Instead, please add an `absl::BitGen` data member to the `PickFirst` class.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/33254,1206087383,2023-05-25T23:29:48Z,test/core/client_channel/lb_policy/pick_first_test.cc,"@@ -37,19 +39,80 @@ class PickFirstTest : public LoadBalancingPolicyTest {  protected:   PickFirstTest() : lb_policy_(MakeLbPolicy(""pick_first"")) {} +  static RefCountedPtr<LoadBalancingPolicy::Config> MakePickFirstConfig(+      bool shuffleAddressList) {","This should be called `shuffle_address_list`, as per the style guide.https://google.github.io/styleguide/cppguide.html#Variable_Names",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/33254,1206098695,2023-05-25T23:57:56Z,src/core/ext/filters/client_channel/lb_policy/pick_first/pick_first.cc,"@@ -281,6 +322,13 @@ absl::Status PickFirst::UpdateLocked(UpdateArgs args) {   }   // Update latest_update_args_.   latest_update_args_ = std::move(args);+  if (latest_update_args_.config != nullptr) {","The gRFC says ""the pick_first Lb policy will randomly shuffle the order of the addresses before attempting to connect to them"", which I assume implies that we should do this before we start connecting, not when we receive an updated address list.For example, consider the following scenario:1. We had a connection, but it got closed.  This causes two things to happen:   - We generate a re-resolution request.  However, if the resolver is a watch-based resolver rather than a polling resolver, this re-resolution request is a no-op; the resolver will not actually report a new address list until/unless it has new data to report, which may never happen.   - We unref all subchannels and enter IDLE state.2. Some arbitrary amount of time later, another RPC gets sent on the channel, causing us to attempt to connect again.In this scenario, I think we want to re-shuffle the address list before we start connecting again.@easwars @temawi I assume this is consistent with how this is implemented in Java and Go?  Assuming that's correct, it might be a good idea to clarify the language in the gRFC.Assuming that's correct, then I think this shuffling code should be moved to near the top of `AttemptToConnectUsingLatestUpdateArgsLocked()`, around line 261.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/33254,1206115234,2023-05-26T00:40:57Z,test/core/client_channel/lb_policy/pick_first_test.cc,"@@ -37,19 +39,80 @@ class PickFirstTest : public LoadBalancingPolicyTest {  protected:   PickFirstTest() : lb_policy_(MakeLbPolicy(""pick_first"")) {} +  static RefCountedPtr<LoadBalancingPolicy::Config> MakePickFirstConfig(+      bool shuffleAddressList) {+    return MakeConfig(Json::FromArray({Json::FromObject({{+        ""pick_first"",+        Json::FromObject(+            {{""shuffleAddressList"", Json::FromBool(shuffleAddressList)}}),+    }})}));+  }++  template <typename C>+  absl::string_view GetConnectionRequestedAddress(","I don't think this is the right approach here.  What this seems to be doing is checking to see which address pick_first starts connecting to first, and then sending a new address list before that connection attempt even finishes.  I think all this really checks is that pick_first will pick *one* of the addresses first, but it does not actually check the order in which it attempts the other addresses in the list if the connection attempt on the first address fails.  And since the tests don't care *which* address the policy chooses first each time, I think these tests would actually pass even if the shuffling functionality was not implemented.I've sent you #33255 to add a couple of tests showing how pick_first handles multiple addresses, which I hope will be useful examples for you to work from.  That will hopefully give you some good examples to work from here.I think what we want to test here is the following:- Send only a single address list update at the start of the test.  It should not be necessary to update the address list after that.- We want to do multiple connection attempt passes.  Each pass, we should record the order in which pick_first tries the addresses.  The connection attempt for every address except the last one should fail, so that we can record the full order in which it is trying the addresses.  The last address it tries should succeed.  Then we have that subchannel indicate the connection fails by reporting IDLE, which will cause pick_first to report IDLE.- Just like in the `GoesIdleWhenConnectionFailsThenCanReconnect` test that I added in #33255, calling `ExpectStateAndQueuingPicker(GRPC_CHANNEL_IDLE)` will trigger the pick_first policy to try to reconnect, thus starting a new connection attempt pass.  As per my comment elsewhere, it should re-shuffle the address list right before it starts to connect again.- We can go through 3 connection attempt passes.  Then we can compare the order in which pick_first tried the addresses in each pass.  If it is shuffling the order, then those lists should be in a different order in each pass; if it's not, then they should be identical in each pass.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/33252,1207061986,2023-05-26T16:44:50Z,test/cpp/end2end/xds/xds_end2end_test.cc,"@@ -2975,6 +2815,206 @@ TEST_P(XdsRbacTestWithActionPermutations, AnyPermissionOrIdPrincipal) {       grpc::StatusCode::PERMISSION_DENIED); } +TEST_P(XdsRbacTestWithActionPermutations,+       AuditLoggerNotInvokedOnAuditConditionNone) {+  ScopedExperimentalEnvVar env_var(""GRPC_EXPERIMENTAL_XDS_RBAC_AUDIT_LOGGING"");+  RBAC rbac;+  rbac.mutable_rules()->set_action(GetParam().rbac_action());+  auto* logging_options = rbac.mutable_rules()->mutable_audit_logging_options();+  auto* audit_logger =+      logging_options->add_logger_configs()->mutable_audit_logger();+  audit_logger->mutable_typed_config()->set_type_url(""/test_logger"");+  TypedStruct typed_struct;+  typed_struct.set_type_url(""/test_logger"");+  typed_struct.mutable_value()->mutable_fields();+  audit_logger->mutable_typed_config()->PackFrom(typed_struct);+  SetServerRbacPolicy(rbac);+  backends_[0]->Start();+  backends_[0]->notifier()->WaitOnServingStatusChange(+      absl::StrCat(ipv6_only_ ? ""[::1]:"" : ""127.0.0.1:"", backends_[0]->port()),+      grpc::StatusCode::OK);+  // An empty RBAC policy leads to all RPCs being rejected.+  SendRpc(+      [this]() { return CreateInsecureChannel(); }, {}, {},+      /*test_expects_failure=*/GetParam().rbac_action() == RBAC_Action_ALLOW,+      grpc::StatusCode::PERMISSION_DENIED);+  EXPECT_THAT(audit_logs_, ::testing::ElementsAre());+}++TEST_P(XdsRbacTestWithActionPermutations,+       MultipleRbacPoliciesWithAuditOnAllow) {+  ScopedExperimentalEnvVar env_var(""GRPC_EXPERIMENTAL_XDS_RBAC_AUDIT_LOGGING"");+  RBAC always_allow;+  auto* rules = always_allow.mutable_rules();+  rules->set_action(RBAC_Action_ALLOW);+  Policy policy;+  policy.add_permissions()->set_any(true);+  policy.add_principals()->set_any(true);+  (*rules->mutable_policies())[""policy""] = policy;+  auto* logging_options = rules->mutable_audit_logging_options();+  logging_options->set_audit_condition(+      RBAC_AuditLoggingOptions_AuditCondition_ON_ALLOW);+  auto* audit_logger =+      logging_options->add_logger_configs()->mutable_audit_logger();+  audit_logger->mutable_typed_config()->set_type_url(""/test_logger"");+  TypedStruct typed_struct;+  typed_struct.set_type_url(""/test_logger"");+  typed_struct.mutable_value()->mutable_fields();+  audit_logger->mutable_typed_config()->PackFrom(typed_struct);+  RBAC rbac;+  rules = rbac.mutable_rules();+  rules->set_action(GetParam().rbac_action());+  (*rules->mutable_policies())[""policy""] = policy;+  logging_options = rules->mutable_audit_logging_options();+  logging_options->set_audit_condition(+      RBAC_AuditLoggingOptions_AuditCondition_ON_ALLOW);+  audit_logger = logging_options->add_logger_configs()->mutable_audit_logger();+  audit_logger->mutable_typed_config()->PackFrom(typed_struct);+  SetServerRbacPolicies(default_server_listener_,+                        {always_allow, rbac, always_allow});+  backends_[0]->Start();+  backends_[0]->notifier()->WaitOnServingStatusChange(+      absl::StrCat(ipv6_only_ ? ""[::1]:"" : ""127.0.0.1:"", backends_[0]->port()),+      grpc::StatusCode::OK);+  SendRpc([this]() { return CreateInsecureChannel(); }, {}, {},+          /*test_expects_failure=*/GetParam().rbac_action() == RBAC_Action_DENY,+          grpc::StatusCode::PERMISSION_DENIED);+  // If the second rbac denies the rpc, only one log from the first rbac.+  // Otherwise, all three rbacs log.+  if (GetParam().rbac_action() == RBAC_Action_DENY) {+    EXPECT_THAT(audit_logs_,+                ::testing::ElementsAreArray(+                    {""{\""authorized\"":true,\""matched_rule\"":\""policy\"",""+                     ""\""policy_name\"":\""rbac1\"",\""principal\"":\""\"",\""rpc_""+                     ""method\"":\""/grpc.testing.EchoTestService/Echo\""}""}));+  } else {+    EXPECT_THAT(audit_logs_,+                ::testing::ElementsAreArray(+                    {""{\""authorized\"":true,\""matched_rule\"":\""policy\"",""+                     ""\""policy_name\"":\""rbac1\"",\""principal\"":\""\"",\""rpc_""+                     ""method\"":\""/grpc.testing.EchoTestService/Echo\""}"",+                     ""{\""authorized\"":true,\""matched_rule\"":\""policy\"",""+                     ""\""policy_name\"":\""rbac2\"",\""principal\"":\""\"",\""rpc_""+                     ""method\"":\""/grpc.testing.EchoTestService/Echo\""}"",+                     ""{\""authorized\"":true,\""matched_rule\"":\""policy\"",""+                     ""\""policy_name\"":\""rbac3\"",\""principal\"":\""\"",\""rpc_""+                     ""method\"":\""/grpc.testing.EchoTestService/Echo\""}""}));+  }+}++TEST_P(XdsRbacTestWithActionPermutations, MultipleRbacPoliciesWithAuditOnDeny) {+  ScopedExperimentalEnvVar env_var(""GRPC_EXPERIMENTAL_XDS_RBAC_AUDIT_LOGGING"");+  RBAC always_allow;+  auto* rules = always_allow.mutable_rules();+  rules->set_action(RBAC_Action_ALLOW);+  Policy policy;+  policy.add_permissions()->set_any(true);+  policy.add_principals()->set_any(true);+  (*rules->mutable_policies())[""policy""] = policy;+  auto* logging_options = rules->mutable_audit_logging_options();+  logging_options->set_audit_condition(+      RBAC_AuditLoggingOptions_AuditCondition_ON_DENY);+  auto* audit_logger =+      logging_options->add_logger_configs()->mutable_audit_logger();+  audit_logger->mutable_typed_config()->set_type_url(""/test_logger"");+  TypedStruct typed_struct;+  typed_struct.set_type_url(""/test_logger"");+  typed_struct.mutable_value()->mutable_fields();+  audit_logger->mutable_typed_config()->PackFrom(typed_struct);+  RBAC rbac;+  rules = rbac.mutable_rules();+  rules->set_action(GetParam().rbac_action());+  (*rules->mutable_policies())[""policy""] = policy;+  logging_options = rules->mutable_audit_logging_options();+  logging_options->set_audit_condition(+      RBAC_AuditLoggingOptions_AuditCondition_ON_DENY);+  audit_logger = logging_options->add_logger_configs()->mutable_audit_logger();+  audit_logger->mutable_typed_config()->PackFrom(typed_struct);+  SetServerRbacPolicies(default_server_listener_,+                        {always_allow, rbac, always_allow});+  backends_[0]->Start();+  backends_[0]->notifier()->WaitOnServingStatusChange(+      absl::StrCat(ipv6_only_ ? ""[::1]:"" : ""127.0.0.1:"", backends_[0]->port()),+      grpc::StatusCode::OK);+  SendRpc([this]() { return CreateInsecureChannel(); }, {}, {},+          /*test_expects_failure=*/GetParam().rbac_action() == RBAC_Action_DENY,+          grpc::StatusCode::PERMISSION_DENIED);+  // Only the second rbac logs if it denies the rpc.+  if (GetParam().rbac_action() == RBAC_Action_DENY) {+    EXPECT_THAT(audit_logs_,+                ::testing::ElementsAreArray(+                    {""{\""authorized\"":false,\""matched_rule\"":\""policy\"",""+                     ""\""policy_name\"":\""rbac2\"",\""principal\"":\""\"",\""rpc_""+                     ""method\"":\""/grpc.testing.EchoTestService/Echo\""}""}));+  } else {+    EXPECT_THAT(audit_logs_, ::testing::ElementsAre());+  }+}++TEST_P(XdsRbacTestWithActionPermutations,+       MultipleRbacPoliciesWithAuditOnDenyAndAllow) {+  ScopedExperimentalEnvVar env_var(""GRPC_EXPERIMENTAL_XDS_RBAC_AUDIT_LOGGING"");+  RBAC always_allow;+  auto* rules = always_allow.mutable_rules();+  rules->set_action(RBAC_Action_ALLOW);+  Policy policy;+  policy.add_permissions()->set_any(true);+  policy.add_principals()->set_any(true);+  (*rules->mutable_policies())[""policy""] = policy;+  auto* logging_options = rules->mutable_audit_logging_options();+  logging_options->set_audit_condition(+      RBAC_AuditLoggingOptions_AuditCondition_ON_DENY_AND_ALLOW);+  auto* audit_logger =+      logging_options->add_logger_configs()->mutable_audit_logger();+  audit_logger->mutable_typed_config()->set_type_url(""/test_logger"");+  TypedStruct typed_struct;+  typed_struct.set_type_url(""/test_logger"");+  typed_struct.mutable_value()->mutable_fields();+  audit_logger->mutable_typed_config()->PackFrom(typed_struct);+  RBAC rbac;+  rules = rbac.mutable_rules();+  rules->set_action(GetParam().rbac_action());+  (*rules->mutable_policies())[""policy""] = policy;+  logging_options = rules->mutable_audit_logging_options();+  logging_options->set_audit_condition(+      RBAC_AuditLoggingOptions_AuditCondition_ON_DENY_AND_ALLOW);+  audit_logger = logging_options->add_logger_configs()->mutable_audit_logger();+  audit_logger->mutable_typed_config()->PackFrom(typed_struct);+  SetServerRbacPolicies(default_server_listener_,+                        {always_allow, rbac, always_allow});+  backends_[0]->Start();+  backends_[0]->notifier()->WaitOnServingStatusChange(+      absl::StrCat(ipv6_only_ ? ""[::1]:"" : ""127.0.0.1:"", backends_[0]->port()),+      grpc::StatusCode::OK);+  SendRpc([this]() { return CreateInsecureChannel(); }, {}, {},+          /*test_expects_failure=*/GetParam().rbac_action() == RBAC_Action_DENY,+          grpc::StatusCode::PERMISSION_DENIED);+  // If the second rbac denies the request, the last rbac won't log. Otherwise+  // all rbacs log.+  if (GetParam().rbac_action() == RBAC_Action_DENY) {","When I suggested using `ElementsAreArray()`, I meant something like this:```std::vector<absl::string_view> expected = {    ""{\""authorized\"":true,\""matched_rule\"":\""policy\"",""    ""\""policy_name\"":\""rbac1\"",\""principal\"":\""\"",\""rpc_""    ""method\"":\""/grpc.testing.EchoTestService/Echo\""}""};if (GetParam().rbac_action() == RBAC_Action_DENY) {  expected.push_back(      ""{\""authorized\"":false,\""matched_rule\"":\""policy\"",""      ""\""policy_name\"":\""rbac1\"",\""principal\"":\""\"",\""rpc_""      ""method\"":\""/grpc.testing.EchoTestService/Echo\""}"");} else {  expected.push_back(      ""{\""authorized\"":true,\""matched_rule\"":\""policy\"",""      ""\""policy_name\"":\""rbac1\"",\""principal\"":\""\"",\""rpc_""      ""method\"":\""/grpc.testing.EchoTestService/Echo\""}"");  expected.push_back(      ""{\""authorized\"":true,\""matched_rule\"":\""policy\"",""      ""\""policy_name\"":\""rbac1\"",\""principal\"":\""\"",\""rpc_""      ""method\"":\""/grpc.testing.EchoTestService/Echo\""}"");}EXPECT_THAT(audit_logs_, ElementsAreArray(expected));```In other words, the advantage of `ElementsAreArray()` over `ElementsAre()` is that the former allows you to construct the list separately, not specifying it as a literal in the expectation itself.  If you're going to specify it linearly in the expectation itself, then you might as well stick with `ElementsAre()`, because `ElementsAreArray()` doesn't actually provide any additional value (in fact, it's actually slightly more cumbersome).Having said that, though, it occurs to me that in this case, it's probably easier to just say this:```constexpr absl::string_view kAllowedLog =    ""{\""authorized\"":true,\""matched_rule\"":\""policy\"",""    ""\""policy_name\"":\""rbac1\"",\""principal\"":\""\"",\""rpc_""    ""method\"":\""/grpc.testing.EchoTestService/Echo\""}"";constexpr absl::string_view kDeniedLog =    ""{\""authorized\"":false,\""matched_rule\"":\""policy\"",""    ""\""policy_name\"":\""rbac1\"",\""principal\"":\""\"",\""rpc_""    ""method\"":\""/grpc.testing.EchoTestService/Echo\""}"";if (GetParam().rbac_action() == RBAC_Action_DENY) {  EXPECT_THAT(audit_logs_, ElementsAre(kAllowedLog, kDeniedLog));} else {  EXPECT_THAT(audit_logs_, ElementsAre(kAllowedLog, kAllowedLog, kAllowedLog));}```",
24593237,XuanWang-Amos,https://api.github.com/repos/grpc/grpc/pulls/32974,1207109333,2023-05-26T17:21:29Z,src/python/grpcio/grpc/_observability.py,"@@ -0,0 +1,125 @@+# Copyright 2023 The gRPC authors.+#+# Licensed under the Apache License, Version 2.0 (the ""License"");+# you may not use this file except in compliance with the License.+# You may obtain a copy of the License at+#+#     http://www.apache.org/licenses/LICENSE-2.0+#+# Unless required by applicable law or agreed to in writing, software+# distributed under the License is distributed on an ""AS IS"" BASIS,+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+# See the License for the specific language governing permissions and+# limitations under the License.++from __future__ import annotations++import abc+import contextlib+import logging+import threading+from typing import Any, Generic, Optional, TypeVar++from grpc._cython import cygrpc as _cygrpc++_LOGGER = logging.getLogger(__name__)++_channel = Any  # _channel.py imports this module.+ClientCallTracerCapsule = TypeVar('ClientCallTracerCapsule')+ServerCallTracerFactoryCapsule = TypeVar('ServerCallTracerFactoryCapsule')++_plugin_lock: threading.RLock = threading.RLock()+_OBSERVABILITY_PLUGIN: Optional[_ObservabilityPlugin] = None  # pylint: disable=used-before-assignment+++class _ObservabilityPlugin(Generic[ClientCallTracerCapsule,+                                   ServerCallTracerFactoryCapsule],+                           metaclass=abc.ABCMeta):+    """"""+    Note: Any future methods added to this interface cannot have the @abc.abstractmethod annotation.+    """"""+    _tracing_enabled: bool = False+    _stats_enabled: bool = False++    @abc.abstractmethod+    def create_client_call_tracer(+            self, method_name: bytes) -> ClientCallTracerCapsule:+        raise NotImplementedError()++    @abc.abstractmethod+    def delete_client_call_tracer(+            self, client_call_tracer: ClientCallTracerCapsule) -> None:+        # delte client call tracer have to be called on o11y package side.+        # Call it for both segregated and integrated call (`_process_integrated_call_tag`)+        raise NotImplementedError()++    @abc.abstractmethod+    def save_trace_context(self, trace_id: str, span_id: str,+                           is_sampled: bool) -> None:+        raise NotImplementedError()++    @abc.abstractmethod+    def create_server_call_tracer_factory(+            self) -> ServerCallTracerFactoryCapsule:+        raise NotImplementedError()++    @abc.abstractmethod+    def record_rpc_latency(self, method: str, rpc_latency: float,+                           status_code: Any) -> None:+        raise NotImplementedError()++    def set_tracing(self, enable: bool) -> None:+        self._tracing_enabled = enable++    def set_stats(self, enable: bool) -> None:+        self._stats_enabled = enable++    @property+    def tracing_enabled(self) -> bool:+        return self._tracing_enabled++    @property+    def stats_enabled(self) -> bool:+        return self._stats_enabled++    @property+    def observability_enabled(self) -> bool:+        return self.tracing_enabled or self.stats_enabled+++@contextlib.contextmanager+def get_plugin() -> Optional[_ObservabilityPlugin]:+    with _plugin_lock:+        yield _OBSERVABILITY_PLUGIN+++def set_plugin(observability_plugin: Optional[_ObservabilityPlugin]) -> None:+    global _OBSERVABILITY_PLUGIN  # pylint: disable=global-statement+    with _plugin_lock:+        if observability_plugin and _OBSERVABILITY_PLUGIN:+            raise ValueError(""observability_plugin was already set!"")+        _OBSERVABILITY_PLUGIN = observability_plugin+++def _observability_init(observability_plugin: _ObservabilityPlugin) -> None:","Discussed a little bit on this offline, it's more about the naming, I'll change the name to `observability_init` and `observability_deinit` on both `grpc_observability` and `grpc` module.",X
5663878,yijiem,https://api.github.com/repos/grpc/grpc/pulls/32701,1207247680,2023-05-26T19:33:15Z,src/core/lib/event_engine/grpc_ares_wrapper.h,"@@ -0,0 +1,340 @@+// Copyright 2023 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+#ifndef GRPC_SRC_CORE_LIB_EVENT_ENGINE_GRPC_ARES_WRAPPER_H+#define GRPC_SRC_CORE_LIB_EVENT_ENGINE_GRPC_ARES_WRAPPER_H++#include <grpc/support/port_platform.h>++#if GRPC_ARES == 1++#include <stddef.h>++#include <algorithm>+#include <memory>+#include <string>+#include <vector>++#include <ares.h>++#include ""absl/base/thread_annotations.h""+#include ""absl/functional/any_invocable.h""+#include ""absl/status/status.h""+#include ""absl/status/statusor.h""+#include ""absl/strings/string_view.h""+#include ""absl/types/optional.h""++#include <grpc/event_engine/event_engine.h>+#include <grpc/support/log.h>++#include ""src/core/lib/debug/trace.h""+#include ""src/core/lib/event_engine/grpc_polled_fd.h""+#include ""src/core/lib/gprpp/orphanable.h""+#include ""src/core/lib/gprpp/sync.h""++namespace grpc_event_engine {+namespace experimental {++extern grpc_core::TraceFlag grpc_trace_ares_wrapper;++#define GRPC_ARES_WRAPPER_TRACE_LOG(format, ...)                              \+  do {                                                                        \+    if (GRPC_TRACE_FLAG_ENABLED(grpc_trace_ares_wrapper)) {                   \+      gpr_log(GPR_INFO, ""(EventEngine c-ares wrapper) "" format, __VA_ARGS__); \+    }                                                                         \+  } while (0)++// Base class for the c-ares based DNS lookup functionality. This class is+// inherited by the concrete leaf classes below which each represents a+// different type of lookup (i.e. A/AAAA, SRV, TXT). One request object+// represents one lookup request for a specific name. GrpcAresRequest+// encapsulates the common logics to initialize and destroy the c-ares channel+// (one channel for one request). Sets the name servers configuration for the+// channel. And interacts with c-ares sockets/fds and the EventEngine poller. It+// also encapsulates logics to start and cancel timers.+class GrpcAresRequest+    : public grpc_core::InternallyRefCounted<GrpcAresRequest> {+ public:+  ~GrpcAresRequest() override;++  // Cancels an inflight request. Returns true if cancel succeeds and will start+  // the shutdown process. Returns false if the request is already finishing,+  // cancelled or shutdown.+  bool Cancel() ABSL_LOCKS_EXCLUDED(mu_);+  void Orphan() override {}++ protected:+  GrpcAresRequest(absl::string_view name, EventEngine::Duration timeout,+                  std::unique_ptr<GrpcPolledFdFactory> polled_fd_factory,+                  EventEngine* event_engine);++  // The workhorse function. Gets the live sockets/fds used by c-ares, creates+  // FdNode if it is not currently tracked in fd_node_list_. Registers the+  // socket with the poller for read and/or write based on c-ares's demand. And+  // shutdown and destroys the poller handles whose sockets are no longer in use+  // by c-ares.+  // This function is called in every opportunities when there might be a change+  // to c-ares' sockets for the channel.+  void Work() ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu_);+  // Common logic to start the query timeout timer and the ares backup poll+  // timer. This is only called in each leaf class' Start method.+  void StartTimers() ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu_);+  // Common logic to cancel the query timeout timer and the ares backup poll+  // timer. This is called when the request is cancelled or shutting down.+  void CancelTimers() ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu_);+  // These 2 methods are deliberately thread-unsafe and should only be called in+  // the factory methods of the leaf classes as part of initialization.+  absl::StatusOr<std::string> ParseNameToResolve();+  absl::Status InitializeAresOptions(absl::string_view dns_server);++  grpc_core::Mutex mu_;","Done. Thanks! Go with the getter/setter approach. Reviewing those members is a good practice, some of them only need read-only access from the child class.",
5663878,yijiem,https://api.github.com/repos/grpc/grpc/pulls/32701,1207266438,2023-05-26T19:52:11Z,src/core/lib/event_engine/grpc_ares_wrapper.h,"@@ -0,0 +1,340 @@+// Copyright 2023 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+#ifndef GRPC_SRC_CORE_LIB_EVENT_ENGINE_GRPC_ARES_WRAPPER_H+#define GRPC_SRC_CORE_LIB_EVENT_ENGINE_GRPC_ARES_WRAPPER_H++#include <grpc/support/port_platform.h>++#if GRPC_ARES == 1++#include <stddef.h>++#include <algorithm>+#include <memory>+#include <string>+#include <vector>++#include <ares.h>++#include ""absl/base/thread_annotations.h""+#include ""absl/functional/any_invocable.h""+#include ""absl/status/status.h""+#include ""absl/status/statusor.h""+#include ""absl/strings/string_view.h""+#include ""absl/types/optional.h""++#include <grpc/event_engine/event_engine.h>+#include <grpc/support/log.h>++#include ""src/core/lib/debug/trace.h""+#include ""src/core/lib/event_engine/grpc_polled_fd.h""+#include ""src/core/lib/gprpp/orphanable.h""+#include ""src/core/lib/gprpp/sync.h""++namespace grpc_event_engine {+namespace experimental {++extern grpc_core::TraceFlag grpc_trace_ares_wrapper;++#define GRPC_ARES_WRAPPER_TRACE_LOG(format, ...)                              \+  do {                                                                        \+    if (GRPC_TRACE_FLAG_ENABLED(grpc_trace_ares_wrapper)) {                   \+      gpr_log(GPR_INFO, ""(EventEngine c-ares wrapper) "" format, __VA_ARGS__); \+    }                                                                         \+  } while (0)++// Base class for the c-ares based DNS lookup functionality. This class is+// inherited by the concrete leaf classes below which each represents a+// different type of lookup (i.e. A/AAAA, SRV, TXT). One request object+// represents one lookup request for a specific name. GrpcAresRequest+// encapsulates the common logics to initialize and destroy the c-ares channel+// (one channel for one request). Sets the name servers configuration for the+// channel. And interacts with c-ares sockets/fds and the EventEngine poller. It+// also encapsulates logics to start and cancel timers.+class GrpcAresRequest+    : public grpc_core::InternallyRefCounted<GrpcAresRequest> {+ public:+  ~GrpcAresRequest() override;++  // Cancels an inflight request. Returns true if cancel succeeds and will start+  // the shutdown process. Returns false if the request is already finishing,+  // cancelled or shutdown.+  bool Cancel() ABSL_LOCKS_EXCLUDED(mu_);+  void Orphan() override {}++ protected:+  GrpcAresRequest(absl::string_view name, EventEngine::Duration timeout,+                  std::unique_ptr<GrpcPolledFdFactory> polled_fd_factory,+                  EventEngine* event_engine);++  // The workhorse function. Gets the live sockets/fds used by c-ares, creates+  // FdNode if it is not currently tracked in fd_node_list_. Registers the+  // socket with the poller for read and/or write based on c-ares's demand. And+  // shutdown and destroys the poller handles whose sockets are no longer in use+  // by c-ares.+  // This function is called in every opportunities when there might be a change+  // to c-ares' sockets for the channel.+  void Work() ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu_);+  // Common logic to start the query timeout timer and the ares backup poll+  // timer. This is only called in each leaf class' Start method.+  void StartTimers() ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu_);+  // Common logic to cancel the query timeout timer and the ares backup poll+  // timer. This is called when the request is cancelled or shutting down.+  void CancelTimers() ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu_);+  // These 2 methods are deliberately thread-unsafe and should only be called in+  // the factory methods of the leaf classes as part of initialization.+  absl::StatusOr<std::string> ParseNameToResolve();+  absl::Status InitializeAresOptions(absl::string_view dns_server);++  grpc_core::Mutex mu_;+  bool initialized_ ABSL_GUARDED_BY(mu_) = false;+  // name to resolve+  const std::string name_ ABSL_GUARDED_BY(mu_);+  // ares channel+  ares_channel channel_ ABSL_GUARDED_BY(mu_) = nullptr;+  // host to resolve, parsed from name_+  std::string host_ ABSL_GUARDED_BY(mu_);+  bool cancelled_ ABSL_GUARDED_BY(mu_) = false;+  bool shutting_down_ ABSL_GUARDED_BY(mu_) = false;+  EventEngine* event_engine_;++ private:+  // A FdNode saves (not owns) a live socket/fd which c-ares creates, and owns a+  // GrpcPolledFd object which has a platform-agnostic interface to interact+  // with the poller. The liveness of the socket means that c-ares needs us to+  // monitor r/w events on this socket and notifies c-ares when such events have+  // happened which we achieve through the GrpcPolledFd object. FdNode also+  // handles the shutdown (maybe due to socket no longer used, finished request,+  // cancel or timeout) and the destruction of the poller handle. Note that+  // FdNode does not own the socket and it's the c-ares' responsibility to+  // close the socket (possibly through ares_destroy).+  struct FdNode {+    FdNode() = default;+    FdNode(ares_socket_t as, GrpcPolledFd* polled_fd);+    ares_socket_t as;+    std::unique_ptr<GrpcPolledFd> polled_fd;+    // next fd node+    FdNode* next = nullptr;+    // true if the readable closure has been registered+    bool readable_registered = false;+    // true if the writable closure has been registered+    bool writable_registered = false;+    bool already_shutdown = false;+  };++  // A linked-list of FdNodes. Support operations such as pop a FdNode which has+  // a specific socket/fd that c-ares owns.+  class FdNodeList {","Done. `std::list<>` should suffice, I initially had a TODO on this but was lost/dropped somewhere.",
5663878,yijiem,https://api.github.com/repos/grpc/grpc/pulls/32701,1207293295,2023-05-26T20:11:24Z,src/core/lib/event_engine/grpc_ares_wrapper.cc,"@@ -0,0 +1,1019 @@+// Copyright 2023 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++#include <grpc/support/port_platform.h>++#include ""src/core/lib/event_engine/grpc_ares_wrapper.h""++#include ""src/core/lib/iomgr/port.h""++// IWYU pragma: no_include <arpa/inet.h>+// IWYU pragma: no_include <arpa/nameser.h>+// IWYU pragma: no_include <inttypes.h>+// IWYU pragma: no_include <netdb.h>+// IWYU pragma: no_include <netinet/in.h>+// IWYU pragma: no_include <stdlib.h>+// IWYU pragma: no_include <sys/socket.h>+// IWYU pragma: no_include <ratio>++#if GRPC_ARES == 1++#include <string.h>++#include <algorithm>+#include <chrono>+#include <initializer_list>+#include <memory>+#include <type_traits>+#include <utility>++#include <address_sorting/address_sorting.h>++#include ""absl/strings/numbers.h""+#include ""absl/strings/str_cat.h""+#include ""absl/strings/str_format.h""+#include ""absl/types/optional.h""++#include <grpc/event_engine/event_engine.h>+#include <grpc/support/alloc.h>+#include <grpc/support/log.h>++#include ""src/core/lib/address_utils/parse_address.h""+#include ""src/core/lib/address_utils/sockaddr_utils.h""+#include ""src/core/lib/event_engine/grpc_polled_fd.h""+#include ""src/core/lib/event_engine/nameser.h""  // IWYU pragma: keep+#include ""src/core/lib/event_engine/tcp_socket_utils.h""+#include ""src/core/lib/event_engine/time_util.h""+#include ""src/core/lib/gpr/string.h""+#include ""src/core/lib/gprpp/debug_location.h""+#include ""src/core/lib/gprpp/examine_stack.h""+#include ""src/core/lib/gprpp/host_port.h""+#include ""src/core/lib/gprpp/ref_counted_ptr.h""+#include ""src/core/lib/gprpp/status_helper.h""+#include ""src/core/lib/iomgr/error.h""+#include ""src/core/lib/iomgr/exec_ctx.h""+#include ""src/core/lib/iomgr/resolved_address.h""+#include ""src/core/lib/iomgr/sockaddr.h""+#ifdef GRPC_POSIX_SOCKET_ARES_EV_DRIVER+#include ""src/core/lib/event_engine/posix_engine/tcp_socket_utils.h""+#elif defined(GRPC_WINDOWS_SOCKET_ARES_EV_DRIVER)+#endif++namespace grpc_event_engine {+namespace experimental {++grpc_core::TraceFlag grpc_trace_ares_wrapper_address_sorting(+    false, ""ares_wrapper_address_sorting"");++grpc_core::TraceFlag grpc_trace_ares_wrapper_stacktrace(+    false, ""ares_wrapper_stacktrace"");++void PrintCurrentStackTrace() {+  if (GRPC_TRACE_FLAG_ENABLED(grpc_trace_ares_wrapper_stacktrace)) {+    absl::optional<std::string> stacktrace = grpc_core::GetCurrentStackTrace();+    if (stacktrace.has_value()) {+      gpr_log(GPR_DEBUG, ""%s"", stacktrace->c_str());+    } else {+      gpr_log(GPR_DEBUG, ""stacktrace unavailable"");+    }+  }+}++grpc_core::TraceFlag grpc_trace_ares_wrapper(false,+                                             ""event_engine_ares_wrapper"");++namespace {++EventEngine::Duration calculate_next_ares_backup_poll_alarm_duration() {+  // An alternative here could be to use ares_timeout to try to be more+  // accurate, but that would require using ""struct timeval""'s, which just+  // makes things a bit more complicated. So just poll every second, as+  // suggested by the c-ares code comments.+  return std::chrono::seconds(1);+}++bool IsIpv6LoopbackAvailable() {+#ifdef GRPC_POSIX_SOCKET_ARES_EV_DRIVER+  return PosixSocketWrapper::IsIpv6LoopbackAvailable();+#elif defined(GRPC_WINDOWS_SOCKET_ARES_EV_DRIVER)+  // TODO(yijiem): make this portable for Windows+  return false;+#else+#error ""Unsupported platform""+#endif+}++struct HostbynameArg {+  GrpcAresHostnameRequest* request;+  const char* qtype;+};++}  // namespace++void GrpcAresHostnameRequest::OnHostbynameDoneLocked(void* arg, int status,+                                                     int /*timeouts*/,+                                                     struct hostent* hostent) {+  std::unique_ptr<HostbynameArg> harg(static_cast<HostbynameArg*>(arg));+  GrpcAresHostnameRequest* request = harg->request;+  if (status != ARES_SUCCESS) {+    std::string error_msg = absl::StrFormat(+        ""c-ares status is not ARES_SUCCESS qtype=%s name=%s: %s"", harg->qtype,+        request->host_.c_str(), ares_strerror(status));+    GRPC_ARES_WRAPPER_TRACE_LOG(""request:%p on_hostbyname_done_locked: %s"",+                                request, error_msg.c_str());+    PrintCurrentStackTrace();+    request->OnResolveLocked(GRPC_ERROR_CREATE(error_msg));+    return;+  }+  GRPC_ARES_WRAPPER_TRACE_LOG(+      ""request:%p on_hostbyname_done_locked qtype=%s host=%s ARES_SUCCESS"",+      request, harg->qtype, request->host_.c_str());+  PrintCurrentStackTrace();++  std::vector<EventEngine::ResolvedAddress> resolved_addresses;+  for (size_t i = 0; hostent->h_addr_list[i] != nullptr; i++) {+    switch (hostent->h_addrtype) {+      case AF_INET6: {+        size_t addr_len = sizeof(struct sockaddr_in6);+        struct sockaddr_in6 addr;+        memset(&addr, 0, addr_len);+        memcpy(&addr.sin6_addr, hostent->h_addr_list[i],+               sizeof(struct in6_addr));+        addr.sin6_family = static_cast<unsigned char>(hostent->h_addrtype);+        addr.sin6_port = htons(request->port_);+        resolved_addresses.emplace_back(+            reinterpret_cast<const sockaddr*>(&addr), addr_len);+        char output[INET6_ADDRSTRLEN];+        ares_inet_ntop(AF_INET6, &addr.sin6_addr, output, INET6_ADDRSTRLEN);+        GRPC_ARES_WRAPPER_TRACE_LOG(+            ""request:%p c-ares resolver gets a AF_INET6 result: \n""+            ""  addr: %s\n  port: %d\n  sin6_scope_id: %d\n"",+            request, output, request->port_, addr.sin6_scope_id);+        break;+      }+      case AF_INET: {+        size_t addr_len = sizeof(struct sockaddr_in);+        struct sockaddr_in addr;+        memset(&addr, 0, addr_len);+        memcpy(&addr.sin_addr, hostent->h_addr_list[i], sizeof(struct in_addr));+        addr.sin_family = static_cast<unsigned char>(hostent->h_addrtype);+        addr.sin_port = htons(request->port_);+        resolved_addresses.emplace_back(+            reinterpret_cast<const sockaddr*>(&addr), addr_len);+        char output[INET_ADDRSTRLEN];+        ares_inet_ntop(AF_INET, &addr.sin_addr, output, INET_ADDRSTRLEN);+        GRPC_ARES_WRAPPER_TRACE_LOG(+            ""request:%p c-ares resolver gets a AF_INET result: \n""+            ""  addr: %s\n  port: %d\n"",+            request, output, request->port_);+        break;+      }+    }+  }+  request->OnResolveLocked(std::move(resolved_addresses));+}++void GrpcAresSRVRequest::OnSRVQueryDoneLocked(void* arg, int status,+                                              int /*timeouts*/,+                                              unsigned char* abuf, int alen) {+  GrpcAresSRVRequest* r = static_cast<GrpcAresSRVRequest*>(arg);+  if (status != ARES_SUCCESS) {+    std::string error_msg = absl::StrFormat(+        ""c-ares status is not ARES_SUCCESS qtype=SRV name=%s: %s"",+        r->host_.c_str(), ares_strerror(status));+    GRPC_ARES_WRAPPER_TRACE_LOG(""request:%p on_srv_query_done_locked: %s"", r,+                                error_msg.c_str());+    r->OnResolveLocked(GRPC_ERROR_CREATE(error_msg));+    return;+  }+  GRPC_ARES_WRAPPER_TRACE_LOG(+      ""request:%p on_srv_query_done_locked name=%s ARES_SUCCESS"", r,+      r->host_.c_str());+  struct ares_srv_reply* reply = nullptr;+  const int parse_status = ares_parse_srv_reply(abuf, alen, &reply);+  GRPC_ARES_WRAPPER_TRACE_LOG(""request:%p ares_parse_srv_reply: %d"", r,+                              parse_status);+  Result result;+  if (parse_status == ARES_SUCCESS) {+    for (struct ares_srv_reply* srv_it = reply; srv_it != nullptr;+         srv_it = srv_it->next) {+      EventEngine::DNSResolver::SRVRecord record;+      record.host = srv_it->host;+      record.port = srv_it->port;+      record.priority = srv_it->priority;+      record.weight = srv_it->weight;+      result.push_back(std::move(record));+    }+  }+  if (reply != nullptr) {+    ares_free_data(reply);+  }+  r->OnResolveLocked(std::move(result));+}++void GrpcAresTXTRequest::OnTXTDoneLocked(void* arg, int status,+                                         int /*timeouts*/, unsigned char* buf,+                                         int len) {+  GrpcAresTXTRequest* r = static_cast<GrpcAresTXTRequest*>(arg);+  struct ares_txt_ext* reply = nullptr;+  int parse_status = ARES_SUCCESS;+  if (status == ARES_SUCCESS) {+    GRPC_ARES_WRAPPER_TRACE_LOG(+        ""request:%p on_txt_done_locked name=%s ARES_SUCCESS"", r,+        r->host_.c_str());+    parse_status = ares_parse_txt_reply_ext(buf, len, &reply);+  }+  if (status != ARES_SUCCESS || parse_status != ARES_SUCCESS) {+    std::string error_msg = absl::StrFormat(+        ""c-ares status is not ARES_SUCCESS qtype=TXT name=%s: %s"",+        r->host_.c_str(), ares_strerror(status));+    GRPC_ARES_WRAPPER_TRACE_LOG(""request:%p on_txt_done_locked %s"", r,+                                error_msg.c_str());+    r->OnResolveLocked(GRPC_ERROR_CREATE(error_msg));+    return;+  }+  Result result;+  for (struct ares_txt_ext* part = reply; part != nullptr; part = part->next) {+    if (part->record_start) {+      result.emplace_back(reinterpret_cast<char*>(part->txt), part->length);+    } else {+      absl::StrAppend(+          &result.back(),+          std::string(reinterpret_cast<char*>(part->txt), part->length));+    }+  }+  GRPC_ARES_WRAPPER_TRACE_LOG(""request: %p, got %zu TXT records"", r,+                              result.size());+  if (GRPC_TRACE_FLAG_ENABLED(grpc_trace_ares_wrapper)) {+    for (const auto& record : result) {+      gpr_log(GPR_INFO, ""%s"", record.c_str());+    }+  }+  // Clean up.+  ares_free_data(reply);+  r->OnResolveLocked(std::move(result));+}++GrpcAresRequest::FdNode::FdNode(ares_socket_t as, GrpcPolledFd* polled_fd)+    : as(as), polled_fd(polled_fd) {}++GrpcAresRequest::FdNode* GrpcAresRequest::FdNodeList::PopFdNode(+    ares_socket_t as) {+  FdNode phony_head;+  phony_head.next = head_;+  FdNode* node = &phony_head;+  while (node->next != nullptr) {+    if (node->next->polled_fd->GetWrappedAresSocketLocked() == as) {+      FdNode* ret = node->next;+      node->next = node->next->next;+      head_ = phony_head.next;+      return ret;+    }+    node = node->next;+  }+  return nullptr;+}++GrpcAresRequest::GrpcAresRequest(+    absl::string_view name, EventEngine::Duration timeout,+    std::unique_ptr<GrpcPolledFdFactory> polled_fd_factory,+    EventEngine* event_engine)+    : grpc_core::InternallyRefCounted<GrpcAresRequest>(+          GRPC_TRACE_FLAG_ENABLED(grpc_trace_ares_wrapper) ? ""GrpcAresRequest""+                                                           : nullptr),+      name_(name),+      event_engine_(event_engine),+      timeout_(timeout),+      fd_node_list_(std::make_unique<FdNodeList>()),+      polled_fd_factory_(std::move(polled_fd_factory)) {}++GrpcAresRequest::~GrpcAresRequest() {+  if (initialized_) {+    ares_destroy(channel_);+    PrintCurrentStackTrace();+  }+  GRPC_ARES_WRAPPER_TRACE_LOG(""request:%p destructor"", this);+}++absl::StatusOr<std::string> GrpcAresRequest::ParseNameToResolve()+    ABSL_NO_THREAD_SAFETY_ANALYSIS {+  GPR_DEBUG_ASSERT(!initialized_);+  std::string port;+  // parse name, splitting it into host and port parts+  grpc_core::SplitHostPort(name_, &host_, &port);+  absl::Status error;+  if (host_.empty()) {+    return grpc_error_set_str(GRPC_ERROR_CREATE(""unparseable host:port""),+                              grpc_core::StatusStrProperty::kTargetAddress,+                              name_);+  }+  return port;+}++absl::Status GrpcAresRequest::InitializeAresOptions(+    absl::string_view dns_server) ABSL_NO_THREAD_SAFETY_ANALYSIS {+  GPR_DEBUG_ASSERT(!initialized_);+  ares_options opts = {};+  opts.flags |= ARES_FLAG_STAYOPEN;+  int status = ares_init_options(&channel_, &opts, ARES_OPT_FLAGS);+  if (status != ARES_SUCCESS) {+    gpr_log(GPR_ERROR, ""ares_init_options failed, status: %d"", status);+    return GRPC_ERROR_CREATE(absl::StrCat(+        ""Failed to init ares channel. c-ares error: "", ares_strerror(status)));+  }+  event_engine_grpc_ares_test_only_inject_config(channel_);+  // If dns_server is specified, use it.+  absl::Status error = SetRequestDNSServer(dns_server);+  if (!error.ok()) {+    ares_destroy(channel_);+    return error;+  }+  initialized_ = true;+  return absl::OkStatus();+}++bool GrpcAresRequest::Cancel() {+  grpc_core::MutexLock lock(&mu_);+  if (std::exchange(shutting_down_, true)) {+    // Already shutting down, maybe resolved, cancelled or timed-out.+    return false;+  }+  cancelled_ = true;+  CancelTimers();+  ShutdownPolledFdsLocked(grpc_core::StatusCreate(+      absl::StatusCode::kCancelled, ""Cancel"", DEBUG_LOCATION, {}));+  return true;+}++void GrpcAresRequest::Work() {+  auto new_list = std::make_unique<FdNodeList>();+  if (!shutting_down_) {+    ares_socket_t socks[ARES_GETSOCK_MAXNUM];+    int socks_bitmask = ares_getsock(channel_, socks, ARES_GETSOCK_MAXNUM);+    for (size_t i = 0; i < ARES_GETSOCK_MAXNUM; i++) {+      if (ARES_GETSOCK_READABLE(socks_bitmask, i) ||+          ARES_GETSOCK_WRITABLE(socks_bitmask, i)) {+        FdNode* fd_node = fd_node_list_->PopFdNode(socks[i]);+        if (fd_node == nullptr) {+          fd_node = new FdNode(+              socks[i], polled_fd_factory_->NewGrpcPolledFdLocked(socks[i]));+          GRPC_ARES_WRAPPER_TRACE_LOG(""request:%p new fd: %d"", this,+                                      fd_node->as);+        }+        new_list->PushFdNode(fd_node);+        // Register read_closure if the socket is readable and read_closure+        // has not been registered with this socket.+        if (ARES_GETSOCK_READABLE(socks_bitmask, i) &&+            !fd_node->readable_registered) {+          GRPC_ARES_WRAPPER_TRACE_LOG(""request:%p notify read on: %d"", this,+                                      fd_node->as);+          fd_node->readable_registered = true;+          fd_node->polled_fd->RegisterForOnReadableLocked(+              [self = Ref(DEBUG_LOCATION, ""Work""),+               fd_node](absl::Status status) mutable {+                grpc_core::ApplicationCallbackExecCtx callback_exec_ctx;+                grpc_core::ExecCtx exec_ctx;+                self->OnReadable(fd_node, status);+              });+        }+        // Register write_closure if the socket is writable and write_closure+        // has not been registered with this socket.+        if (ARES_GETSOCK_WRITABLE(socks_bitmask, i) &&+            !fd_node->writable_registered) {+          GRPC_ARES_WRAPPER_TRACE_LOG(""request:%p notify write on: %d"", this,+                                      fd_node->as);+          fd_node->writable_registered = true;+          fd_node->polled_fd->RegisterForOnWriteableLocked(+              [self = Ref(DEBUG_LOCATION, ""Work""),+               fd_node](absl::Status status) mutable {+                grpc_core::ApplicationCallbackExecCtx callback_exec_ctx;+                grpc_core::ExecCtx exec_ctx;+                self->OnWritable(fd_node, status);+              });+        }+      }+    }+  }+  // Any remaining fds in fd_node_list_ were not returned by ares_getsock()+  // and are therefore no longer in use, so they can be shut down and removed+  // from the list.+  while (!fd_node_list_->IsEmpty()) {+    FdNode* fd_node = fd_node_list_->PopFdNode();+    if (!fd_node->already_shutdown) {+      GRPC_ARES_WRAPPER_TRACE_LOG(""request: %p shutdown fd: %s"", this,+                                  fd_node->polled_fd->GetName());+      fd_node->polled_fd->ShutdownLocked(absl::OkStatus());+      fd_node->already_shutdown = true;+    }+    if (!fd_node->readable_registered && !fd_node->writable_registered) {+      GRPC_ARES_WRAPPER_TRACE_LOG(""request: %p delete fd: %s"", this,+                                  fd_node->polled_fd->GetName());+      delete fd_node;+    } else {+      new_list->PushFdNode(fd_node);+    }+  }+  fd_node_list_.swap(new_list);+}++void GrpcAresRequest::StartTimers() {+  // Initialize overall DNS resolution timeout alarm+  EventEngine::Duration timeout =+      timeout_.count() == 0 ? EventEngine::Duration::max() : timeout_;+  GRPC_ARES_WRAPPER_TRACE_LOG(""request:%p StartTimers timeout in %zu ms"", this,+                              Milliseconds(timeout));++  query_timeout_handle_ = event_engine_->RunAfter(+      timeout, [self = Ref(DEBUG_LOCATION, ""StartTimers"")] {+        grpc_core::ApplicationCallbackExecCtx callback_exec_ctx;+        grpc_core::ExecCtx exec_ctx;+        self->OnQueryTimeout();+      });++  // Initialize the backup poll alarm+  EventEngine::Duration next_ares_backup_poll_alarm_duration =+      calculate_next_ares_backup_poll_alarm_duration();+  GRPC_ARES_WRAPPER_TRACE_LOG(+      ""request:%p StartTimers next ares process poll time in %zu ms"", this,+      Milliseconds(next_ares_backup_poll_alarm_duration));++  ares_backup_poll_alarm_handle_ = event_engine_->RunAfter(+      next_ares_backup_poll_alarm_duration,+      [self = Ref(DEBUG_LOCATION, ""StartTimers"")]() mutable {+        grpc_core::ApplicationCallbackExecCtx callback_exec_ctx;+        grpc_core::ExecCtx exec_ctx;+        self->OnAresBackupPollAlarm();+      });+}++void GrpcAresRequest::CancelTimers() {+  if (query_timeout_handle_.has_value()) {+    event_engine_->Cancel(*query_timeout_handle_);+    query_timeout_handle_.reset();+  }+  if (ares_backup_poll_alarm_handle_.has_value()) {+    event_engine_->Cancel(*ares_backup_poll_alarm_handle_);+    ares_backup_poll_alarm_handle_.reset();+  }+}++absl::Status GrpcAresRequest::SetRequestDNSServer(+    absl::string_view dns_server) {+  if (!dns_server.empty()) {+    GRPC_ARES_WRAPPER_TRACE_LOG(""request:%p Using DNS server %s"", this,+                                dns_server.data());+    grpc_resolved_address addr;+    struct ares_addr_port_node dns_server_addr;+    if (grpc_parse_ipv4_hostport(dns_server, &addr, /*log_errors=*/false)) {+      dns_server_addr.family = AF_INET;+      struct sockaddr_in* in = reinterpret_cast<struct sockaddr_in*>(addr.addr);+      memcpy(&dns_server_addr.addr.addr4, &in->sin_addr,+             sizeof(struct in_addr));+      dns_server_addr.tcp_port = grpc_sockaddr_get_port(&addr);+      dns_server_addr.udp_port = grpc_sockaddr_get_port(&addr);+    } else if (grpc_parse_ipv6_hostport(dns_server, &addr,+                                        /*log_errors=*/false)) {+      dns_server_addr.family = AF_INET6;+      struct sockaddr_in6* in6 =+          reinterpret_cast<struct sockaddr_in6*>(addr.addr);+      memcpy(&dns_server_addr.addr.addr6, &in6->sin6_addr,+             sizeof(struct in6_addr));+      dns_server_addr.tcp_port = grpc_sockaddr_get_port(&addr);+      dns_server_addr.udp_port = grpc_sockaddr_get_port(&addr);+    } else {+      return GRPC_ERROR_CREATE(+          absl::StrCat(""cannot parse authority "", dns_server));+    }+    // Prevent an uninitialized variable.+    dns_server_addr.next = nullptr;+    int status = ares_set_servers_ports(channel_, &dns_server_addr);+    if (status != ARES_SUCCESS) {+      return GRPC_ERROR_CREATE(absl::StrCat(+          ""c-ares status is not ARES_SUCCESS: "", ares_strerror(status)));+    }+  }+  return absl::OkStatus();+}++void GrpcAresRequest::OnReadable(FdNode* fd_node, absl::Status status) {+  grpc_core::MutexLock lock(&mu_);+  GPR_ASSERT(fd_node->readable_registered);+  fd_node->readable_registered = false;+  GRPC_ARES_WRAPPER_TRACE_LOG(""OnReadable: fd: %d; request: %p; status: %s"",+                              fd_node->as, this, status.ToString().c_str());+  PrintCurrentStackTrace();+  if (status.ok() && !shutting_down_) {+    do {+      ares_process_fd(channel_, fd_node->as, ARES_SOCKET_BAD);+    } while (fd_node->polled_fd->IsFdStillReadableLocked());+  } else {+    // If error is not absl::OkStatus() or the resolution was cancelled, it+    // means the fd has been shutdown or timed out. The pending lookups made+    // on this request will be cancelled by the following ares_cancel(). The+    // remaining file descriptors in this request will be cleaned up in the+    // following Work() method.+    ares_cancel(channel_);+  }+  Work();+}++void GrpcAresRequest::OnWritable(FdNode* fd_node, absl::Status status) {+  grpc_core::MutexLock lock(&mu_);+  GPR_ASSERT(fd_node->writable_registered);+  fd_node->writable_registered = false;+  GRPC_ARES_WRAPPER_TRACE_LOG(""OnWritable: fd: %d; request:%p; status: %s"",+                              fd_node->as, this, status.ToString().c_str());+  if (status.ok() && !shutting_down_) {+    ares_process_fd(channel_, ARES_SOCKET_BAD, fd_node->as);+  } else {+    // If error is not absl::OkStatus() or the resolution was cancelled, it+    // means the fd has been shutdown or timed out. The pending lookups made+    // on this request will be cancelled by the following ares_cancel(). The+    // remaining file descriptors in this request will be cleaned up in the+    // following Work() method.+    ares_cancel(channel_);+  }+  Work();+}++void GrpcAresRequest::OnQueryTimeout() {+  grpc_core::MutexLock lock(&mu_);+  query_timeout_handle_.reset();+  GRPC_ARES_WRAPPER_TRACE_LOG(""request:%p OnQueryTimeout. shutting_down_=%d"",+                              this, shutting_down_);+  if (!shutting_down_) {+    shutting_down_ = true;+    ShutdownPolledFdsLocked(+        grpc_core::StatusCreate(absl::StatusCode::kDeadlineExceeded,+                                ""OnQueryTimeout"", DEBUG_LOCATION, {}));+  }+}++// In case of non-responsive DNS servers, dropped packets, etc., c-ares has+// intelligent timeout and retry logic, which we can take advantage of by+// polling ares_process_fd on time intervals. Overall, the c-ares library is+// meant to be called into and given a chance to proceed name resolution:+//   a) when fd events happen+//   b) when some time has passed without fd events having happened+// For the latter, we use this backup poller. Also see+// https://github.com/grpc/grpc/pull/17688 description for more details.+void GrpcAresRequest::OnAresBackupPollAlarm() {+  grpc_core::MutexLock lock(&mu_);+  ares_backup_poll_alarm_handle_.reset();+  GRPC_ARES_WRAPPER_TRACE_LOG(+      ""request:%p OnAresBackupPollAlarm shutting_down=%d."", this,+      shutting_down_);+  if (!shutting_down_) {+    for (auto it = fd_node_list_->begin(); it != fd_node_list_->end(); it++) {+      if (!(*it)->already_shutdown) {+        GRPC_ARES_WRAPPER_TRACE_LOG(+            ""request:%p OnAresBackupPollAlarm; ares_process_fd. fd=%s"", this,+            (*it)->polled_fd->GetName());+        ares_socket_t as = (*it)->polled_fd->GetWrappedAresSocketLocked();+        ares_process_fd(channel_, as, as);+      }+    }+    if (!shutting_down_) {+      EventEngine::Duration next_ares_backup_poll_alarm_duration =+          calculate_next_ares_backup_poll_alarm_duration();+      ares_backup_poll_alarm_handle_ = event_engine_->RunAfter(+          next_ares_backup_poll_alarm_duration,+          [self = Ref(DEBUG_LOCATION, ""OnAresBackupPollAlarm"")]() mutable {+            grpc_core::ApplicationCallbackExecCtx callback_exec_ctx;+            grpc_core::ExecCtx exec_ctx;+            self->OnAresBackupPollAlarm();+          });+    }+    Work();+  }+}++// TODO(yijiem): Consider report this status or as part of the result when+// calling on_resolve_. This status is received in OnReadable/OnWritable.+void GrpcAresRequest::ShutdownPolledFdsLocked(absl::Status status) {+  for (auto it = fd_node_list_->begin(); it != fd_node_list_->end(); it++) {+    if (!(*it)->already_shutdown) {+      GRPC_ARES_WRAPPER_TRACE_LOG(""request: %p shutdown fd: %s"", this,+                                  (*it)->polled_fd->GetName());+      (*it)->polled_fd->ShutdownLocked(status);+      (*it)->already_shutdown = true;+    }+  }+}++GrpcAresHostnameRequest::GrpcAresHostnameRequest(+    absl::string_view name, absl::string_view default_port,+    EventEngine::Duration timeout,+    std::unique_ptr<GrpcPolledFdFactory> polled_fd_factory,+    EventEngine* event_engine)+    : GrpcAresRequest(name, timeout, std::move(polled_fd_factory),+                      event_engine),+      default_port_(default_port) {}++GrpcAresHostnameRequest::~GrpcAresHostnameRequest() {+  // Destruction of on_resolve_ may trigger a chain of destruction that may+  // require ExecCtx in the current thread.+  grpc_core::ApplicationCallbackExecCtx callback_exec_ctx;+  grpc_core::ExecCtx exec_ctx;+  { auto c = std::move(on_resolve_); }+  GRPC_ARES_WRAPPER_TRACE_LOG(""request:%p destructor"", this);+}++void GrpcAresHostnameRequest::Start(+    absl::AnyInvocable<void(absl::StatusOr<Result>)> on_resolve) {+  // Holds a ref across this function since OnResolve might be called inline+  // inside ares_gethostbyname and we might be done in that case. This ref needs+  // to be taken outside of the lock to prevent UAF during unlock if the+  // destruction of the ref triggers the destruction of the request itself.+  auto self = Ref(DEBUG_LOCATION, ""Start"");+  grpc_core::MutexLock lock(&mu_);+  GPR_ASSERT(initialized_);+  on_resolve_ = std::move(on_resolve);+  GRPC_ARES_WRAPPER_TRACE_LOG(+      ""request:%p c-ares GrpcAresHostnameRequest::Start name=%s, ""+      ""default_port=%s"",+      this, name_.c_str(), default_port_.c_str());+  // Early out if the target is an ipv4 or ipv6 literal.+  if (ResolveAsIPLiteralLocked()) {+    return;+  }+  // TODO(yijiem): Early out if the target is localhost and we're on Windows.++  // We add up pending_queries_ here since ares_gethostbyname may directly+  // invoke the callback inline e.g. if there is any error with the input. The+  // callback will invoke OnResolve with an error status and may start the+  // shutdown process too early (before the second ares_gethostbyname) if we+  // haven't added up here.+  ++pending_queries_;+  if (IsIpv6LoopbackAvailable()) {+    ++pending_queries_;+    auto* arg = new HostbynameArg();+    arg->request = this;+    arg->qtype = ""AAAA"";+    ares_gethostbyname(channel_, host_.c_str(), AF_INET6,+                       &GrpcAresHostnameRequest::OnHostbynameDoneLocked,+                       static_cast<void*>(arg));+  }+  auto* arg = new HostbynameArg();+  arg->request = this;+  arg->qtype = ""A"";+  ares_gethostbyname(channel_, host_.c_str(), AF_INET,+                     &GrpcAresHostnameRequest::OnHostbynameDoneLocked,+                     static_cast<void*>(arg));+  // It's possible that ares_gethostbyname gets everything done inline.+  if (!shutting_down_) {+    Work();+    StartTimers();+  }+}++void GrpcAresHostnameRequest::OnResolveLocked(absl::StatusOr<Result> result) {+  GPR_ASSERT(--pending_queries_ >= 0);+  if (result_.ok()) {+    if (result.ok()) {+      result_->insert(result_->end(), result->begin(), result->end());+    }+    // else this error is ignored since we have already got a valid result.+  } else {+    if (result.ok()) {+      // Got a valid result, store it.+      result_ = std::move(result);+    } else {+      // Add result.status() as a child error of result_.+      result_ = grpc_error_add_child(result_.status(), result.status());+    }+  }+  if (pending_queries_ == 0) {+    // Decrement the initial refcount. NOTE: this Unref will not trigger+    // destruction. OnResolve is only called from c-ares callback which could be+    // called from 3 places: 1. ares_process_fd in OnReadable/OnWritable+    // where a RefCountedPtr is embedded in the closure; 2. ares_process_fd in+    // OnAresBackupPollAlarm where a RefCountedPtr is embedded in the+    // closure; 3. ares_gethostbyname in Start when OnResolve is called inline.+    // We deliberately take a ref there through self.+    Unref(DEBUG_LOCATION, ""OnResolveLocked"");+    shutting_down_ = true;+    if (cancelled_) {+      // Cancel does not invoke on_resolve_.+      return;+    }+    CancelTimers();+    if (result_.ok() && !result_->empty()) {+      SortResolvedAddressesLocked();+    }+    event_engine_->Run(+        [on_resolve = std::move(on_resolve_), result = std::move(result_),+         self = Ref(DEBUG_LOCATION, ""OnResolveLocked"")]() mutable {+          grpc_core::ApplicationCallbackExecCtx callback_exec_ctx;","This is a great callout!I initially saw some tests failed because `ExecCtx` was not on the stack in 2 cases:1. When `on_resolve` gets called2. When `on_resolve` is destroyed and the refcount inside `on_resolve` passed from the caller to the `DNSResolver` is destroyed (which triggers further destruction chain outward to a place that needs `ExecCtx`).Both of these cases, the caller is `EventEngineClientChannelDNSResolver::EventEngineDNSRequestWrapper`, so I have added `ExecCtx` in the `on_resolve` callbacks and in the destructor of `EventEngineClientChannelDNSResolver::EventEngineDNSRequestWrapper`. This is so much convenient than trying to maintain this invariant inside EventEngine (assuming our tests cover all of the scenarios). I have removed all `ExecCtx`s from EE's `grpc_ares_wrapper` and `PosixDNSResolver`. PTAL.",
5663878,yijiem,https://api.github.com/repos/grpc/grpc/pulls/32701,1207306557,2023-05-26T20:25:09Z,src/core/lib/event_engine/grpc_ares_wrapper.cc,"@@ -0,0 +1,1019 @@+// Copyright 2023 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++#include <grpc/support/port_platform.h>++#include ""src/core/lib/event_engine/grpc_ares_wrapper.h""++#include ""src/core/lib/iomgr/port.h""++// IWYU pragma: no_include <arpa/inet.h>+// IWYU pragma: no_include <arpa/nameser.h>+// IWYU pragma: no_include <inttypes.h>+// IWYU pragma: no_include <netdb.h>+// IWYU pragma: no_include <netinet/in.h>+// IWYU pragma: no_include <stdlib.h>+// IWYU pragma: no_include <sys/socket.h>+// IWYU pragma: no_include <ratio>++#if GRPC_ARES == 1++#include <string.h>++#include <algorithm>+#include <chrono>+#include <initializer_list>+#include <memory>+#include <type_traits>+#include <utility>++#include <address_sorting/address_sorting.h>++#include ""absl/strings/numbers.h""+#include ""absl/strings/str_cat.h""+#include ""absl/strings/str_format.h""+#include ""absl/types/optional.h""++#include <grpc/event_engine/event_engine.h>+#include <grpc/support/alloc.h>+#include <grpc/support/log.h>++#include ""src/core/lib/address_utils/parse_address.h""+#include ""src/core/lib/address_utils/sockaddr_utils.h""+#include ""src/core/lib/event_engine/grpc_polled_fd.h""+#include ""src/core/lib/event_engine/nameser.h""  // IWYU pragma: keep+#include ""src/core/lib/event_engine/tcp_socket_utils.h""+#include ""src/core/lib/event_engine/time_util.h""+#include ""src/core/lib/gpr/string.h""+#include ""src/core/lib/gprpp/debug_location.h""+#include ""src/core/lib/gprpp/examine_stack.h""+#include ""src/core/lib/gprpp/host_port.h""+#include ""src/core/lib/gprpp/ref_counted_ptr.h""+#include ""src/core/lib/gprpp/status_helper.h""+#include ""src/core/lib/iomgr/error.h""+#include ""src/core/lib/iomgr/exec_ctx.h""+#include ""src/core/lib/iomgr/resolved_address.h""+#include ""src/core/lib/iomgr/sockaddr.h""+#ifdef GRPC_POSIX_SOCKET_ARES_EV_DRIVER+#include ""src/core/lib/event_engine/posix_engine/tcp_socket_utils.h""+#elif defined(GRPC_WINDOWS_SOCKET_ARES_EV_DRIVER)+#endif++namespace grpc_event_engine {+namespace experimental {++grpc_core::TraceFlag grpc_trace_ares_wrapper_address_sorting(+    false, ""ares_wrapper_address_sorting"");++grpc_core::TraceFlag grpc_trace_ares_wrapper_stacktrace(+    false, ""ares_wrapper_stacktrace"");++void PrintCurrentStackTrace() {+  if (GRPC_TRACE_FLAG_ENABLED(grpc_trace_ares_wrapper_stacktrace)) {+    absl::optional<std::string> stacktrace = grpc_core::GetCurrentStackTrace();+    if (stacktrace.has_value()) {+      gpr_log(GPR_DEBUG, ""%s"", stacktrace->c_str());+    } else {+      gpr_log(GPR_DEBUG, ""stacktrace unavailable"");+    }+  }+}++grpc_core::TraceFlag grpc_trace_ares_wrapper(false,+                                             ""event_engine_ares_wrapper"");++namespace {++EventEngine::Duration calculate_next_ares_backup_poll_alarm_duration() {+  // An alternative here could be to use ares_timeout to try to be more+  // accurate, but that would require using ""struct timeval""'s, which just+  // makes things a bit more complicated. So just poll every second, as+  // suggested by the c-ares code comments.+  return std::chrono::seconds(1);+}++bool IsIpv6LoopbackAvailable() {+#ifdef GRPC_POSIX_SOCKET_ARES_EV_DRIVER+  return PosixSocketWrapper::IsIpv6LoopbackAvailable();+#elif defined(GRPC_WINDOWS_SOCKET_ARES_EV_DRIVER)+  // TODO(yijiem): make this portable for Windows+  return false;+#else+#error ""Unsupported platform""+#endif+}++struct HostbynameArg {+  GrpcAresHostnameRequest* request;+  const char* qtype;+};++}  // namespace++void GrpcAresHostnameRequest::OnHostbynameDoneLocked(void* arg, int status,+                                                     int /*timeouts*/,+                                                     struct hostent* hostent) {+  std::unique_ptr<HostbynameArg> harg(static_cast<HostbynameArg*>(arg));+  GrpcAresHostnameRequest* request = harg->request;+  if (status != ARES_SUCCESS) {+    std::string error_msg = absl::StrFormat(+        ""c-ares status is not ARES_SUCCESS qtype=%s name=%s: %s"", harg->qtype,+        request->host_.c_str(), ares_strerror(status));+    GRPC_ARES_WRAPPER_TRACE_LOG(""request:%p on_hostbyname_done_locked: %s"",+                                request, error_msg.c_str());+    PrintCurrentStackTrace();+    request->OnResolveLocked(GRPC_ERROR_CREATE(error_msg));+    return;+  }+  GRPC_ARES_WRAPPER_TRACE_LOG(+      ""request:%p on_hostbyname_done_locked qtype=%s host=%s ARES_SUCCESS"",+      request, harg->qtype, request->host_.c_str());+  PrintCurrentStackTrace();++  std::vector<EventEngine::ResolvedAddress> resolved_addresses;+  for (size_t i = 0; hostent->h_addr_list[i] != nullptr; i++) {+    switch (hostent->h_addrtype) {+      case AF_INET6: {+        size_t addr_len = sizeof(struct sockaddr_in6);+        struct sockaddr_in6 addr;+        memset(&addr, 0, addr_len);+        memcpy(&addr.sin6_addr, hostent->h_addr_list[i],+               sizeof(struct in6_addr));+        addr.sin6_family = static_cast<unsigned char>(hostent->h_addrtype);+        addr.sin6_port = htons(request->port_);+        resolved_addresses.emplace_back(+            reinterpret_cast<const sockaddr*>(&addr), addr_len);+        char output[INET6_ADDRSTRLEN];+        ares_inet_ntop(AF_INET6, &addr.sin6_addr, output, INET6_ADDRSTRLEN);+        GRPC_ARES_WRAPPER_TRACE_LOG(+            ""request:%p c-ares resolver gets a AF_INET6 result: \n""+            ""  addr: %s\n  port: %d\n  sin6_scope_id: %d\n"",+            request, output, request->port_, addr.sin6_scope_id);+        break;+      }+      case AF_INET: {+        size_t addr_len = sizeof(struct sockaddr_in);+        struct sockaddr_in addr;+        memset(&addr, 0, addr_len);+        memcpy(&addr.sin_addr, hostent->h_addr_list[i], sizeof(struct in_addr));+        addr.sin_family = static_cast<unsigned char>(hostent->h_addrtype);+        addr.sin_port = htons(request->port_);+        resolved_addresses.emplace_back(+            reinterpret_cast<const sockaddr*>(&addr), addr_len);+        char output[INET_ADDRSTRLEN];+        ares_inet_ntop(AF_INET, &addr.sin_addr, output, INET_ADDRSTRLEN);+        GRPC_ARES_WRAPPER_TRACE_LOG(+            ""request:%p c-ares resolver gets a AF_INET result: \n""+            ""  addr: %s\n  port: %d\n"",+            request, output, request->port_);+        break;+      }+    }+  }+  request->OnResolveLocked(std::move(resolved_addresses));+}++void GrpcAresSRVRequest::OnSRVQueryDoneLocked(void* arg, int status,+                                              int /*timeouts*/,+                                              unsigned char* abuf, int alen) {+  GrpcAresSRVRequest* r = static_cast<GrpcAresSRVRequest*>(arg);+  if (status != ARES_SUCCESS) {+    std::string error_msg = absl::StrFormat(+        ""c-ares status is not ARES_SUCCESS qtype=SRV name=%s: %s"",+        r->host_.c_str(), ares_strerror(status));+    GRPC_ARES_WRAPPER_TRACE_LOG(""request:%p on_srv_query_done_locked: %s"", r,+                                error_msg.c_str());+    r->OnResolveLocked(GRPC_ERROR_CREATE(error_msg));+    return;+  }+  GRPC_ARES_WRAPPER_TRACE_LOG(+      ""request:%p on_srv_query_done_locked name=%s ARES_SUCCESS"", r,+      r->host_.c_str());+  struct ares_srv_reply* reply = nullptr;+  const int parse_status = ares_parse_srv_reply(abuf, alen, &reply);+  GRPC_ARES_WRAPPER_TRACE_LOG(""request:%p ares_parse_srv_reply: %d"", r,+                              parse_status);+  Result result;+  if (parse_status == ARES_SUCCESS) {+    for (struct ares_srv_reply* srv_it = reply; srv_it != nullptr;+         srv_it = srv_it->next) {+      EventEngine::DNSResolver::SRVRecord record;+      record.host = srv_it->host;+      record.port = srv_it->port;+      record.priority = srv_it->priority;+      record.weight = srv_it->weight;+      result.push_back(std::move(record));+    }+  }+  if (reply != nullptr) {+    ares_free_data(reply);+  }+  r->OnResolveLocked(std::move(result));+}++void GrpcAresTXTRequest::OnTXTDoneLocked(void* arg, int status,+                                         int /*timeouts*/, unsigned char* buf,+                                         int len) {+  GrpcAresTXTRequest* r = static_cast<GrpcAresTXTRequest*>(arg);+  struct ares_txt_ext* reply = nullptr;+  int parse_status = ARES_SUCCESS;+  if (status == ARES_SUCCESS) {+    GRPC_ARES_WRAPPER_TRACE_LOG(+        ""request:%p on_txt_done_locked name=%s ARES_SUCCESS"", r,+        r->host_.c_str());+    parse_status = ares_parse_txt_reply_ext(buf, len, &reply);+  }+  if (status != ARES_SUCCESS || parse_status != ARES_SUCCESS) {+    std::string error_msg = absl::StrFormat(+        ""c-ares status is not ARES_SUCCESS qtype=TXT name=%s: %s"",+        r->host_.c_str(), ares_strerror(status));+    GRPC_ARES_WRAPPER_TRACE_LOG(""request:%p on_txt_done_locked %s"", r,+                                error_msg.c_str());+    r->OnResolveLocked(GRPC_ERROR_CREATE(error_msg));+    return;+  }+  Result result;+  for (struct ares_txt_ext* part = reply; part != nullptr; part = part->next) {+    if (part->record_start) {+      result.emplace_back(reinterpret_cast<char*>(part->txt), part->length);+    } else {+      absl::StrAppend(+          &result.back(),+          std::string(reinterpret_cast<char*>(part->txt), part->length));+    }+  }+  GRPC_ARES_WRAPPER_TRACE_LOG(""request: %p, got %zu TXT records"", r,+                              result.size());+  if (GRPC_TRACE_FLAG_ENABLED(grpc_trace_ares_wrapper)) {+    for (const auto& record : result) {+      gpr_log(GPR_INFO, ""%s"", record.c_str());+    }+  }+  // Clean up.+  ares_free_data(reply);+  r->OnResolveLocked(std::move(result));+}++GrpcAresRequest::FdNode::FdNode(ares_socket_t as, GrpcPolledFd* polled_fd)+    : as(as), polled_fd(polled_fd) {}++GrpcAresRequest::FdNode* GrpcAresRequest::FdNodeList::PopFdNode(+    ares_socket_t as) {+  FdNode phony_head;+  phony_head.next = head_;+  FdNode* node = &phony_head;+  while (node->next != nullptr) {+    if (node->next->polled_fd->GetWrappedAresSocketLocked() == as) {+      FdNode* ret = node->next;+      node->next = node->next->next;+      head_ = phony_head.next;+      return ret;+    }+    node = node->next;+  }+  return nullptr;+}++GrpcAresRequest::GrpcAresRequest(+    absl::string_view name, EventEngine::Duration timeout,+    std::unique_ptr<GrpcPolledFdFactory> polled_fd_factory,+    EventEngine* event_engine)+    : grpc_core::InternallyRefCounted<GrpcAresRequest>(+          GRPC_TRACE_FLAG_ENABLED(grpc_trace_ares_wrapper) ? ""GrpcAresRequest""+                                                           : nullptr),+      name_(name),+      event_engine_(event_engine),+      timeout_(timeout),+      fd_node_list_(std::make_unique<FdNodeList>()),+      polled_fd_factory_(std::move(polled_fd_factory)) {}++GrpcAresRequest::~GrpcAresRequest() {+  if (initialized_) {+    ares_destroy(channel_);+    PrintCurrentStackTrace();+  }+  GRPC_ARES_WRAPPER_TRACE_LOG(""request:%p destructor"", this);+}++absl::StatusOr<std::string> GrpcAresRequest::ParseNameToResolve()+    ABSL_NO_THREAD_SAFETY_ANALYSIS {+  GPR_DEBUG_ASSERT(!initialized_);+  std::string port;+  // parse name, splitting it into host and port parts+  grpc_core::SplitHostPort(name_, &host_, &port);+  absl::Status error;+  if (host_.empty()) {+    return grpc_error_set_str(GRPC_ERROR_CREATE(""unparseable host:port""),+                              grpc_core::StatusStrProperty::kTargetAddress,+                              name_);+  }+  return port;+}++absl::Status GrpcAresRequest::InitializeAresOptions(+    absl::string_view dns_server) ABSL_NO_THREAD_SAFETY_ANALYSIS {+  GPR_DEBUG_ASSERT(!initialized_);+  ares_options opts = {};+  opts.flags |= ARES_FLAG_STAYOPEN;+  int status = ares_init_options(&channel_, &opts, ARES_OPT_FLAGS);+  if (status != ARES_SUCCESS) {+    gpr_log(GPR_ERROR, ""ares_init_options failed, status: %d"", status);+    return GRPC_ERROR_CREATE(absl::StrCat(+        ""Failed to init ares channel. c-ares error: "", ares_strerror(status)));+  }+  event_engine_grpc_ares_test_only_inject_config(channel_);+  // If dns_server is specified, use it.+  absl::Status error = SetRequestDNSServer(dns_server);+  if (!error.ok()) {+    ares_destroy(channel_);+    return error;+  }+  initialized_ = true;+  return absl::OkStatus();+}++bool GrpcAresRequest::Cancel() {+  grpc_core::MutexLock lock(&mu_);+  if (std::exchange(shutting_down_, true)) {+    // Already shutting down, maybe resolved, cancelled or timed-out.+    return false;+  }+  cancelled_ = true;+  CancelTimers();+  ShutdownPolledFdsLocked(grpc_core::StatusCreate(+      absl::StatusCode::kCancelled, ""Cancel"", DEBUG_LOCATION, {}));+  return true;+}++void GrpcAresRequest::Work() {+  auto new_list = std::make_unique<FdNodeList>();+  if (!shutting_down_) {+    ares_socket_t socks[ARES_GETSOCK_MAXNUM];+    int socks_bitmask = ares_getsock(channel_, socks, ARES_GETSOCK_MAXNUM);+    for (size_t i = 0; i < ARES_GETSOCK_MAXNUM; i++) {+      if (ARES_GETSOCK_READABLE(socks_bitmask, i) ||+          ARES_GETSOCK_WRITABLE(socks_bitmask, i)) {+        FdNode* fd_node = fd_node_list_->PopFdNode(socks[i]);+        if (fd_node == nullptr) {+          fd_node = new FdNode(+              socks[i], polled_fd_factory_->NewGrpcPolledFdLocked(socks[i]));+          GRPC_ARES_WRAPPER_TRACE_LOG(""request:%p new fd: %d"", this,+                                      fd_node->as);+        }+        new_list->PushFdNode(fd_node);+        // Register read_closure if the socket is readable and read_closure+        // has not been registered with this socket.+        if (ARES_GETSOCK_READABLE(socks_bitmask, i) &&+            !fd_node->readable_registered) {+          GRPC_ARES_WRAPPER_TRACE_LOG(""request:%p notify read on: %d"", this,+                                      fd_node->as);+          fd_node->readable_registered = true;+          fd_node->polled_fd->RegisterForOnReadableLocked(+              [self = Ref(DEBUG_LOCATION, ""Work""),+               fd_node](absl::Status status) mutable {+                grpc_core::ApplicationCallbackExecCtx callback_exec_ctx;+                grpc_core::ExecCtx exec_ctx;+                self->OnReadable(fd_node, status);+              });+        }+        // Register write_closure if the socket is writable and write_closure+        // has not been registered with this socket.+        if (ARES_GETSOCK_WRITABLE(socks_bitmask, i) &&+            !fd_node->writable_registered) {+          GRPC_ARES_WRAPPER_TRACE_LOG(""request:%p notify write on: %d"", this,+                                      fd_node->as);+          fd_node->writable_registered = true;+          fd_node->polled_fd->RegisterForOnWriteableLocked(+              [self = Ref(DEBUG_LOCATION, ""Work""),+               fd_node](absl::Status status) mutable {+                grpc_core::ApplicationCallbackExecCtx callback_exec_ctx;+                grpc_core::ExecCtx exec_ctx;+                self->OnWritable(fd_node, status);+              });+        }+      }+    }+  }+  // Any remaining fds in fd_node_list_ were not returned by ares_getsock()+  // and are therefore no longer in use, so they can be shut down and removed+  // from the list.+  while (!fd_node_list_->IsEmpty()) {+    FdNode* fd_node = fd_node_list_->PopFdNode();+    if (!fd_node->already_shutdown) {+      GRPC_ARES_WRAPPER_TRACE_LOG(""request: %p shutdown fd: %s"", this,+                                  fd_node->polled_fd->GetName());+      fd_node->polled_fd->ShutdownLocked(absl::OkStatus());+      fd_node->already_shutdown = true;+    }+    if (!fd_node->readable_registered && !fd_node->writable_registered) {+      GRPC_ARES_WRAPPER_TRACE_LOG(""request: %p delete fd: %s"", this,+                                  fd_node->polled_fd->GetName());+      delete fd_node;+    } else {+      new_list->PushFdNode(fd_node);+    }+  }+  fd_node_list_.swap(new_list);+}++void GrpcAresRequest::StartTimers() {+  // Initialize overall DNS resolution timeout alarm+  EventEngine::Duration timeout =+      timeout_.count() == 0 ? EventEngine::Duration::max() : timeout_;+  GRPC_ARES_WRAPPER_TRACE_LOG(""request:%p StartTimers timeout in %zu ms"", this,+                              Milliseconds(timeout));++  query_timeout_handle_ = event_engine_->RunAfter(+      timeout, [self = Ref(DEBUG_LOCATION, ""StartTimers"")] {+        grpc_core::ApplicationCallbackExecCtx callback_exec_ctx;+        grpc_core::ExecCtx exec_ctx;+        self->OnQueryTimeout();+      });++  // Initialize the backup poll alarm+  EventEngine::Duration next_ares_backup_poll_alarm_duration =+      calculate_next_ares_backup_poll_alarm_duration();+  GRPC_ARES_WRAPPER_TRACE_LOG(+      ""request:%p StartTimers next ares process poll time in %zu ms"", this,+      Milliseconds(next_ares_backup_poll_alarm_duration));++  ares_backup_poll_alarm_handle_ = event_engine_->RunAfter(+      next_ares_backup_poll_alarm_duration,+      [self = Ref(DEBUG_LOCATION, ""StartTimers"")]() mutable {+        grpc_core::ApplicationCallbackExecCtx callback_exec_ctx;+        grpc_core::ExecCtx exec_ctx;+        self->OnAresBackupPollAlarm();+      });+}++void GrpcAresRequest::CancelTimers() {+  if (query_timeout_handle_.has_value()) {+    event_engine_->Cancel(*query_timeout_handle_);+    query_timeout_handle_.reset();+  }+  if (ares_backup_poll_alarm_handle_.has_value()) {+    event_engine_->Cancel(*ares_backup_poll_alarm_handle_);+    ares_backup_poll_alarm_handle_.reset();+  }+}++absl::Status GrpcAresRequest::SetRequestDNSServer(+    absl::string_view dns_server) {+  if (!dns_server.empty()) {+    GRPC_ARES_WRAPPER_TRACE_LOG(""request:%p Using DNS server %s"", this,+                                dns_server.data());+    grpc_resolved_address addr;+    struct ares_addr_port_node dns_server_addr;+    if (grpc_parse_ipv4_hostport(dns_server, &addr, /*log_errors=*/false)) {+      dns_server_addr.family = AF_INET;+      struct sockaddr_in* in = reinterpret_cast<struct sockaddr_in*>(addr.addr);+      memcpy(&dns_server_addr.addr.addr4, &in->sin_addr,+             sizeof(struct in_addr));+      dns_server_addr.tcp_port = grpc_sockaddr_get_port(&addr);+      dns_server_addr.udp_port = grpc_sockaddr_get_port(&addr);+    } else if (grpc_parse_ipv6_hostport(dns_server, &addr,+                                        /*log_errors=*/false)) {+      dns_server_addr.family = AF_INET6;+      struct sockaddr_in6* in6 =+          reinterpret_cast<struct sockaddr_in6*>(addr.addr);+      memcpy(&dns_server_addr.addr.addr6, &in6->sin6_addr,+             sizeof(struct in6_addr));+      dns_server_addr.tcp_port = grpc_sockaddr_get_port(&addr);+      dns_server_addr.udp_port = grpc_sockaddr_get_port(&addr);+    } else {+      return GRPC_ERROR_CREATE(+          absl::StrCat(""cannot parse authority "", dns_server));+    }+    // Prevent an uninitialized variable.+    dns_server_addr.next = nullptr;+    int status = ares_set_servers_ports(channel_, &dns_server_addr);+    if (status != ARES_SUCCESS) {+      return GRPC_ERROR_CREATE(absl::StrCat(+          ""c-ares status is not ARES_SUCCESS: "", ares_strerror(status)));+    }+  }+  return absl::OkStatus();+}++void GrpcAresRequest::OnReadable(FdNode* fd_node, absl::Status status) {+  grpc_core::MutexLock lock(&mu_);+  GPR_ASSERT(fd_node->readable_registered);+  fd_node->readable_registered = false;+  GRPC_ARES_WRAPPER_TRACE_LOG(""OnReadable: fd: %d; request: %p; status: %s"",+                              fd_node->as, this, status.ToString().c_str());+  PrintCurrentStackTrace();+  if (status.ok() && !shutting_down_) {+    do {+      ares_process_fd(channel_, fd_node->as, ARES_SOCKET_BAD);+    } while (fd_node->polled_fd->IsFdStillReadableLocked());+  } else {+    // If error is not absl::OkStatus() or the resolution was cancelled, it+    // means the fd has been shutdown or timed out. The pending lookups made+    // on this request will be cancelled by the following ares_cancel(). The+    // remaining file descriptors in this request will be cleaned up in the+    // following Work() method.+    ares_cancel(channel_);+  }+  Work();+}++void GrpcAresRequest::OnWritable(FdNode* fd_node, absl::Status status) {+  grpc_core::MutexLock lock(&mu_);+  GPR_ASSERT(fd_node->writable_registered);+  fd_node->writable_registered = false;+  GRPC_ARES_WRAPPER_TRACE_LOG(""OnWritable: fd: %d; request:%p; status: %s"",+                              fd_node->as, this, status.ToString().c_str());+  if (status.ok() && !shutting_down_) {+    ares_process_fd(channel_, ARES_SOCKET_BAD, fd_node->as);+  } else {+    // If error is not absl::OkStatus() or the resolution was cancelled, it+    // means the fd has been shutdown or timed out. The pending lookups made+    // on this request will be cancelled by the following ares_cancel(). The+    // remaining file descriptors in this request will be cleaned up in the+    // following Work() method.+    ares_cancel(channel_);+  }+  Work();+}++void GrpcAresRequest::OnQueryTimeout() {+  grpc_core::MutexLock lock(&mu_);+  query_timeout_handle_.reset();+  GRPC_ARES_WRAPPER_TRACE_LOG(""request:%p OnQueryTimeout. shutting_down_=%d"",+                              this, shutting_down_);+  if (!shutting_down_) {+    shutting_down_ = true;+    ShutdownPolledFdsLocked(+        grpc_core::StatusCreate(absl::StatusCode::kDeadlineExceeded,+                                ""OnQueryTimeout"", DEBUG_LOCATION, {}));+  }+}++// In case of non-responsive DNS servers, dropped packets, etc., c-ares has+// intelligent timeout and retry logic, which we can take advantage of by+// polling ares_process_fd on time intervals. Overall, the c-ares library is+// meant to be called into and given a chance to proceed name resolution:+//   a) when fd events happen+//   b) when some time has passed without fd events having happened+// For the latter, we use this backup poller. Also see+// https://github.com/grpc/grpc/pull/17688 description for more details.+void GrpcAresRequest::OnAresBackupPollAlarm() {+  grpc_core::MutexLock lock(&mu_);+  ares_backup_poll_alarm_handle_.reset();+  GRPC_ARES_WRAPPER_TRACE_LOG(+      ""request:%p OnAresBackupPollAlarm shutting_down=%d."", this,+      shutting_down_);+  if (!shutting_down_) {+    for (auto it = fd_node_list_->begin(); it != fd_node_list_->end(); it++) {+      if (!(*it)->already_shutdown) {+        GRPC_ARES_WRAPPER_TRACE_LOG(+            ""request:%p OnAresBackupPollAlarm; ares_process_fd. fd=%s"", this,+            (*it)->polled_fd->GetName());+        ares_socket_t as = (*it)->polled_fd->GetWrappedAresSocketLocked();+        ares_process_fd(channel_, as, as);+      }+    }+    if (!shutting_down_) {+      EventEngine::Duration next_ares_backup_poll_alarm_duration =+          calculate_next_ares_backup_poll_alarm_duration();+      ares_backup_poll_alarm_handle_ = event_engine_->RunAfter(+          next_ares_backup_poll_alarm_duration,+          [self = Ref(DEBUG_LOCATION, ""OnAresBackupPollAlarm"")]() mutable {+            grpc_core::ApplicationCallbackExecCtx callback_exec_ctx;+            grpc_core::ExecCtx exec_ctx;+            self->OnAresBackupPollAlarm();+          });+    }+    Work();+  }+}++// TODO(yijiem): Consider report this status or as part of the result when","There was some issues with the error handling in this code. I made changes so that:1. If there is valid result, always return that through the `absl::StatusOr` argument to the `on_resolve` callback (except cancellation).2. If error needs to be reported, the `absl::Status`'s code will be the first error status code that is encountered, e.g. if timeout happened to be the first exceptional event, the status code would be `kDeadlineExceeded`. And the `absl::Status`'s message will be a composite (concatenated) message as the code hits further error status. This is done through a newly added `AddError` method. PTAL. Thanks!",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32701,1207434360,2023-05-26T22:29:06Z,src/core/lib/event_engine/grpc_ares_wrapper.h,"@@ -242,23 +231,28 @@ class GrpcAresHostnameRequest final : public GrpcAresRequest {       EventEngine* event_engine);   ~GrpcAresHostnameRequest() override; -  bool ResolveAsIPLiteralLocked() ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu_);+  void AddError(absl::Status error) override+      ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu());+  void OnResolveLockedAndUnlock() override ABSL_UNLOCK_FUNCTION(mu());++  bool ResolveAsIPLiteralLocked() ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu());   void LogResolvedAddressesListLocked(absl::string_view input_output_str)-      ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu_);-  void SortResolvedAddressesLocked() ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu_);-  void OnResolveLocked(absl::StatusOr<Result> result)-      ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu_);+      ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu());+  void SortResolvedAddressesLocked() ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu());   // This method is deliberately thread-unsafe and should only be called in   // Create as part of initialization.   absl::Status ParsePort(absl::string_view port);    // port, parsed from name_ or default_port_-  int port_ ABSL_GUARDED_BY(mu_) = 0;-  const std::string default_port_ ABSL_GUARDED_BY(mu_);-  size_t pending_queries_ ABSL_GUARDED_BY(mu_) = 0;-  absl::StatusOr<Result> result_ ABSL_GUARDED_BY(mu_);+  int port_ ABSL_GUARDED_BY(mu()) = 0;+  const std::string default_port_ ABSL_GUARDED_BY(mu());+  size_t pending_queries_ ABSL_GUARDED_BY(mu()) = 0;+  absl::StatusOr<Result> result_ ABSL_GUARDED_BY(mu());   absl::AnyInvocable<void(absl::StatusOr<Result>)> on_resolve_-      ABSL_GUARDED_BY(mu_);+      ABSL_GUARDED_BY(mu());+  bool resolved_ ABSL_GUARDED_BY(mu()) = false;++  EventEngine* event_engine_;","Why are we storing a separate copy of this pointer in each subclass, when it's already stored in the base class?  Why not just give the base class a protected accessor method?",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32701,1207444792,2023-05-26T22:42:32Z,src/core/lib/event_engine/posix_engine/posix_engine.cc,"@@ -634,17 +614,20 @@ LookupTaskHandle PosixEventEngine::PosixDNSResolver::LookupTXT(           // on_resolve called, no longer inflight.           GPR_ASSERT(inflight_requests_.erase(handle) == 1);         }+        reinterpret_cast<GrpcAresRequest*>(handle.keys[0])->Orphan();         on_resolve(std::move(result));       });   return handle; }  bool PosixEventEngine::PosixDNSResolver::CancelLookup(LookupTaskHandle handle) {-  grpc_core::MutexLock lock(&mu_);+  grpc_core::ReleasableMutexLock lock(&mu_);","I generally find that `ReleasableMutexLock` is an anti-pattern, because it makes control flow harder to follow.  Instead, I generally prefer to restructure things slightly to make the right thing happen based on scoping.  Consider this alternative:```bool PosixEventEngine::PosixDNSResolver::CancelLookup(LookupTaskHandle handle) {  auto* request =       reinterpret_cast<GrpcAresRequest*>(handle.keys[0]));  OrphanablePtr<GrpcAresRequest> request_owner;  grpc_core::MutexLock lock(&mu_);  auto iter = inflight_requests_.find(handle);  if (iter != inflight_requests_.end() && request->Cancel()) {    inflight_requests_.erase(iter);    request_owner.reset(request);  // Orphan after releasing mutex.    return true;  }  return false;}```Same thing throughout this PR -- please try to avoid using `ReleasableMutexLock` whenever possible.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32701,1207468134,2023-05-26T23:13:35Z,src/core/lib/event_engine/grpc_ares_wrapper.h,"@@ -121,95 +141,64 @@ class GrpcAresRequest   // close the socket (possibly through ares_destroy).   struct FdNode {     FdNode() = default;-    FdNode(ares_socket_t as, GrpcPolledFd* polled_fd);+    FdNode(ares_socket_t as, GrpcPolledFd* polled_fd)+        : as(as), polled_fd(polled_fd) {}     ares_socket_t as;     std::unique_ptr<GrpcPolledFd> polled_fd;-    // next fd node-    FdNode* next = nullptr;     // true if the readable closure has been registered     bool readable_registered = false;     // true if the writable closure has been registered     bool writable_registered = false;     bool already_shutdown = false;   };+  using FdNodeList = std::list<std::unique_ptr<FdNode>>; -  // A linked-list of FdNodes. Support operations such as pop a FdNode which has-  // a specific socket/fd that c-ares owns.-  class FdNodeList {-   public:-    class FdNodeListIterator {-     public:-      bool operator!=(const FdNodeListIterator& other) {-        return node_ != other.node_;-      }-      bool operator==(const FdNodeListIterator& other) {-        return node_ == other.node_;-      }-      FdNodeListIterator& operator++(int) {-        node_ = node_->next;-        return *this;-      }-      FdNode* operator*() { return node_; }-      static FdNodeListIterator universal_end() {-        return FdNodeListIterator(nullptr);-      }--     private:-      friend class FdNodeList;-      explicit FdNodeListIterator(FdNode* node) : node_(node) {}-      FdNode* node_;-    };-    using Iterator = FdNodeListIterator;--    ~FdNodeList() { GPR_ASSERT(IsEmpty()); }--    Iterator begin() { return Iterator(head_); }-    Iterator end() { return Iterator::universal_end(); }--    bool IsEmpty() const { return head_ == nullptr; }--    void PushFdNode(FdNode* fd_node) ABSL_EXCLUSIVE_LOCKS_REQUIRED(&mu_) {-      fd_node->next = head_;-      head_ = fd_node;-    }--    FdNode* PopFdNode() ABSL_EXCLUSIVE_LOCKS_REQUIRED(&mu_) {-      GPR_ASSERT(!IsEmpty());-      FdNode* ret = head_;-      head_ = head_->next;-      return ret;-    }--    // Search for as in the FdNode list. This is an O(n) search, the max-    // possible value of n is ARES_GETSOCK_MAXNUM (16). n is typically 1 - 2-    // in our tests.-    FdNode* PopFdNode(ares_socket_t as) ABSL_EXCLUSIVE_LOCKS_REQUIRED(&mu_);--   private:-    FdNode* head_ = nullptr;-  };   friend class GrpcPolledFdFactory; +  // Requires mu_ to be locked before calling.+  // Unlock mu_ before returns.+  //+  // Ideally this could take a lock object by reference or something like a+  // std::unique_ptr<grpc_core::ReleasableMutexLock>. But Thread Safety Analysis+  // does not work in these scenarios, see for example:+  // https://github.com/llvm/llvm-project/issues/59662.+  virtual void OnResolveLockedAndUnlock() ABSL_UNLOCK_FUNCTION(mu()) = 0;","IMHO, having a function release a mutex that was taken in another function is an anti-pattern that makes control flow much harder to follow.  I would prefer to instead have the caller release the mutex, so that this function is just like any other function that requires the caller to take a `MutexLock` before calling it.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32701,1207471224,2023-05-26T23:17:14Z,src/core/lib/event_engine/grpc_ares_wrapper.h,"@@ -0,0 +1,340 @@+// Copyright 2023 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+#ifndef GRPC_SRC_CORE_LIB_EVENT_ENGINE_GRPC_ARES_WRAPPER_H+#define GRPC_SRC_CORE_LIB_EVENT_ENGINE_GRPC_ARES_WRAPPER_H++#include <grpc/support/port_platform.h>++#if GRPC_ARES == 1++#include <stddef.h>++#include <algorithm>+#include <memory>+#include <string>+#include <vector>++#include <ares.h>++#include ""absl/base/thread_annotations.h""+#include ""absl/functional/any_invocable.h""+#include ""absl/status/status.h""+#include ""absl/status/statusor.h""+#include ""absl/strings/string_view.h""+#include ""absl/types/optional.h""++#include <grpc/event_engine/event_engine.h>+#include <grpc/support/log.h>++#include ""src/core/lib/debug/trace.h""+#include ""src/core/lib/event_engine/grpc_polled_fd.h""+#include ""src/core/lib/gprpp/orphanable.h""+#include ""src/core/lib/gprpp/sync.h""++namespace grpc_event_engine {+namespace experimental {++extern grpc_core::TraceFlag grpc_trace_ares_wrapper;++#define GRPC_ARES_WRAPPER_TRACE_LOG(format, ...)                              \+  do {                                                                        \+    if (GRPC_TRACE_FLAG_ENABLED(grpc_trace_ares_wrapper)) {                   \+      gpr_log(GPR_INFO, ""(EventEngine c-ares wrapper) "" format, __VA_ARGS__); \+    }                                                                         \+  } while (0)++// Base class for the c-ares based DNS lookup functionality. This class is+// inherited by the concrete leaf classes below which each represents a+// different type of lookup (i.e. A/AAAA, SRV, TXT). One request object+// represents one lookup request for a specific name. GrpcAresRequest+// encapsulates the common logics to initialize and destroy the c-ares channel+// (one channel for one request). Sets the name servers configuration for the+// channel. And interacts with c-ares sockets/fds and the EventEngine poller. It+// also encapsulates logics to start and cancel timers.+class GrpcAresRequest+    : public grpc_core::InternallyRefCounted<GrpcAresRequest> {+ public:+  ~GrpcAresRequest() override;++  // Cancels an inflight request. Returns true if cancel succeeds and will start+  // the shutdown process. Returns false if the request is already finishing,+  // cancelled or shutdown.+  bool Cancel() ABSL_LOCKS_EXCLUDED(mu_);+  void Orphan() override {}++ protected:+  GrpcAresRequest(absl::string_view name, EventEngine::Duration timeout,+                  std::unique_ptr<GrpcPolledFdFactory> polled_fd_factory,+                  EventEngine* event_engine);++  // The workhorse function. Gets the live sockets/fds used by c-ares, creates+  // FdNode if it is not currently tracked in fd_node_list_. Registers the+  // socket with the poller for read and/or write based on c-ares's demand. And+  // shutdown and destroys the poller handles whose sockets are no longer in use+  // by c-ares.+  // This function is called in every opportunities when there might be a change+  // to c-ares' sockets for the channel.+  void Work() ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu_);+  // Common logic to start the query timeout timer and the ares backup poll+  // timer. This is only called in each leaf class' Start method.+  void StartTimers() ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu_);+  // Common logic to cancel the query timeout timer and the ares backup poll+  // timer. This is called when the request is cancelled or shutting down.+  void CancelTimers() ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu_);+  // These 2 methods are deliberately thread-unsafe and should only be called in+  // the factory methods of the leaf classes as part of initialization.+  absl::StatusOr<std::string> ParseNameToResolve();+  absl::Status InitializeAresOptions(absl::string_view dns_server);++  grpc_core::Mutex mu_;","Thanks.  This change has made it much more obvious what the interaction is between the base class and the subclasses... and I think it's far too complicated.  There's a lot of shared state, and I'm particularly unhappy with the way the mutex is shared between the two.  We can live with this kind of approach if we have to, but I'd really prefer to avoid it if we can find something better.Note the [style guide advice around inheritance](https://google.github.io/styleguide/cppguide.html#Inheritance):> Do not overuse implementation inheritance. Composition is often more appropriate.Is there a way to use a ""has-a"" paradigm here instead of an ""is-a"" paradigm?  In other words, can we move much of the common functionality to a separate `AresRequestCommon` class, and then give each subclass a data member of that type?  I'm wondering if that would make it possible to, for example, make the individual subclasses responsible for the synchronization.I think this may also be related to the comment elsewhere about moving the ares channel out into the `DNSResolver` object.  That change would probably move at least some of the shared functionality here out of the base class.",X
1644595,gnossen,https://api.github.com/repos/grpc/grpc/pulls/32974,1207471435,2023-05-26T23:17:33Z,src/python/grpcio_observability/grpc_observability/observability_util.h,"@@ -0,0 +1,114 @@+// Copyright 2023 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++// TODO(xuanwn): clean up includes+#include <stdint.h>++#include <algorithm>+#include <condition_variable>+#include <mutex>+#include <queue>+#include <string>+#include <utility>+#include <vector>++#include ""absl/strings/string_view.h""++#include <grpc/status.h>++#include ""src/python/grpcio_observability/grpc_observability/constants.h""+#include ""src/python/grpcio_observability/grpc_observability/python_census_context.h""++#ifndef OBSERVABILITY_MAIN_H+#define OBSERVABILITY_MAIN_H++namespace grpc_observability {++struct CensusData {+  DataType type;+  std::vector<Label> labels;+  // TODO(xuanwn): We can use union here+  SpanCensusData span_data;+  Measurement measurement_data;+  CensusData() {}+  CensusData(const Measurement& mm, std::vector<Label>& labels)+      : type(kMetricData), labels(std::move(labels)), measurement_data(mm) {}+  CensusData(const SpanCensusData& sd) : type(kSpanData), span_data(sd) {}+};++struct CloudMonitoring {+  CloudMonitoring() {}+};++struct CloudTrace {+  float sampling_rate = 0.0;+  CloudTrace() {}+  CloudTrace(double sr) : sampling_rate(sr) {}+};++struct CloudLogging {+  CloudLogging() {}+};++struct GcpObservabilityConfig {+  CloudMonitoring cloud_monitoring;+  CloudTrace cloud_trace;+  CloudLogging cloud_logging;+  std::string project_id;+  std::vector<Label> labels;+  bool is_valid;+  GcpObservabilityConfig() : is_valid(false) {}+  GcpObservabilityConfig(bool valid) : is_valid(true) {}+  GcpObservabilityConfig(CloudMonitoring cloud_monitoring,+                         CloudTrace cloud_trace, CloudLogging cloud_logging,+                         std::string project_id, std::vector<Label> labels)","`const std::string&``const std::vector<Label>&`In general, any type that is large or may be backed by heap allocations should be passed by const ref. This includes `std::string`, `std::vector`, and all other containers. It also includes all classes/structs that include these as fields. Please do a a scrub through the PR for this.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32701,1207477389,2023-05-26T23:27:33Z,src/core/lib/event_engine/grpc_ares_wrapper.cc,"@@ -356,22 +155,37 @@ bool GrpcAresRequest::Cancel() {   return true; } +GrpcAresRequest::GrpcAresRequest(+    absl::string_view name, EventEngine::Duration timeout,+    std::unique_ptr<GrpcPolledFdFactory> polled_fd_factory,+    EventEngine* event_engine)+    : grpc_core::InternallyRefCounted<GrpcAresRequest>(+          GRPC_TRACE_FLAG_ENABLED(grpc_trace_ares_wrapper) ? ""GrpcAresRequest""+                                                           : nullptr),+      name_(name),+      timeout_(timeout),+      polled_fd_factory_(std::move(polled_fd_factory)),+      event_engine_(event_engine) {}+ void GrpcAresRequest::Work() {-  auto new_list = std::make_unique<FdNodeList>();+  FdNodeList new_list;   if (!shutting_down_) {     ares_socket_t socks[ARES_GETSOCK_MAXNUM];     int socks_bitmask = ares_getsock(channel_, socks, ARES_GETSOCK_MAXNUM);     for (size_t i = 0; i < ARES_GETSOCK_MAXNUM; i++) {       if (ARES_GETSOCK_READABLE(socks_bitmask, i) ||           ARES_GETSOCK_WRITABLE(socks_bitmask, i)) {-        FdNode* fd_node = fd_node_list_->PopFdNode(socks[i]);-        if (fd_node == nullptr) {-          fd_node = new FdNode(-              socks[i], polled_fd_factory_->NewGrpcPolledFdLocked(socks[i]));-          GRPC_ARES_WRAPPER_TRACE_LOG(""request:%p new fd: %d"", this,-                                      fd_node->as);+        auto iter = std::find_if(+            fd_node_list_.begin(), fd_node_list_.end(),+            [sock = socks[i]](const auto& node) { return node->as == sock; });+        if (iter == std::end(fd_node_list_)) {",Prefer `fd_node_list_.end()`.,
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32701,1207486173,2023-05-26T23:42:02Z,src/core/lib/event_engine/grpc_ares_wrapper.cc,"@@ -0,0 +1,1019 @@+// Copyright 2023 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++#include <grpc/support/port_platform.h>++#include ""src/core/lib/event_engine/grpc_ares_wrapper.h""++#include ""src/core/lib/iomgr/port.h""++// IWYU pragma: no_include <arpa/inet.h>+// IWYU pragma: no_include <arpa/nameser.h>+// IWYU pragma: no_include <inttypes.h>+// IWYU pragma: no_include <netdb.h>+// IWYU pragma: no_include <netinet/in.h>+// IWYU pragma: no_include <stdlib.h>+// IWYU pragma: no_include <sys/socket.h>+// IWYU pragma: no_include <ratio>++#if GRPC_ARES == 1++#include <string.h>++#include <algorithm>+#include <chrono>+#include <initializer_list>+#include <memory>+#include <type_traits>+#include <utility>++#include <address_sorting/address_sorting.h>++#include ""absl/strings/numbers.h""+#include ""absl/strings/str_cat.h""+#include ""absl/strings/str_format.h""+#include ""absl/types/optional.h""++#include <grpc/event_engine/event_engine.h>+#include <grpc/support/alloc.h>+#include <grpc/support/log.h>++#include ""src/core/lib/address_utils/parse_address.h""+#include ""src/core/lib/address_utils/sockaddr_utils.h""+#include ""src/core/lib/event_engine/grpc_polled_fd.h""+#include ""src/core/lib/event_engine/nameser.h""  // IWYU pragma: keep+#include ""src/core/lib/event_engine/tcp_socket_utils.h""+#include ""src/core/lib/event_engine/time_util.h""+#include ""src/core/lib/gpr/string.h""+#include ""src/core/lib/gprpp/debug_location.h""+#include ""src/core/lib/gprpp/examine_stack.h""+#include ""src/core/lib/gprpp/host_port.h""+#include ""src/core/lib/gprpp/ref_counted_ptr.h""+#include ""src/core/lib/gprpp/status_helper.h""+#include ""src/core/lib/iomgr/error.h""+#include ""src/core/lib/iomgr/exec_ctx.h""+#include ""src/core/lib/iomgr/resolved_address.h""+#include ""src/core/lib/iomgr/sockaddr.h""+#ifdef GRPC_POSIX_SOCKET_ARES_EV_DRIVER+#include ""src/core/lib/event_engine/posix_engine/tcp_socket_utils.h""+#elif defined(GRPC_WINDOWS_SOCKET_ARES_EV_DRIVER)+#endif++namespace grpc_event_engine {+namespace experimental {++grpc_core::TraceFlag grpc_trace_ares_wrapper_address_sorting(+    false, ""ares_wrapper_address_sorting"");++grpc_core::TraceFlag grpc_trace_ares_wrapper_stacktrace(+    false, ""ares_wrapper_stacktrace"");++void PrintCurrentStackTrace() {+  if (GRPC_TRACE_FLAG_ENABLED(grpc_trace_ares_wrapper_stacktrace)) {+    absl::optional<std::string> stacktrace = grpc_core::GetCurrentStackTrace();+    if (stacktrace.has_value()) {+      gpr_log(GPR_DEBUG, ""%s"", stacktrace->c_str());+    } else {+      gpr_log(GPR_DEBUG, ""stacktrace unavailable"");+    }+  }+}++grpc_core::TraceFlag grpc_trace_ares_wrapper(false,+                                             ""event_engine_ares_wrapper"");++namespace {++EventEngine::Duration calculate_next_ares_backup_poll_alarm_duration() {+  // An alternative here could be to use ares_timeout to try to be more+  // accurate, but that would require using ""struct timeval""'s, which just+  // makes things a bit more complicated. So just poll every second, as+  // suggested by the c-ares code comments.+  return std::chrono::seconds(1);+}++bool IsIpv6LoopbackAvailable() {+#ifdef GRPC_POSIX_SOCKET_ARES_EV_DRIVER+  return PosixSocketWrapper::IsIpv6LoopbackAvailable();+#elif defined(GRPC_WINDOWS_SOCKET_ARES_EV_DRIVER)+  // TODO(yijiem): make this portable for Windows+  return false;+#else+#error ""Unsupported platform""+#endif+}++struct HostbynameArg {+  GrpcAresHostnameRequest* request;+  const char* qtype;+};++}  // namespace++void GrpcAresHostnameRequest::OnHostbynameDoneLocked(void* arg, int status,+                                                     int /*timeouts*/,+                                                     struct hostent* hostent) {+  std::unique_ptr<HostbynameArg> harg(static_cast<HostbynameArg*>(arg));+  GrpcAresHostnameRequest* request = harg->request;+  if (status != ARES_SUCCESS) {+    std::string error_msg = absl::StrFormat(+        ""c-ares status is not ARES_SUCCESS qtype=%s name=%s: %s"", harg->qtype,+        request->host_.c_str(), ares_strerror(status));+    GRPC_ARES_WRAPPER_TRACE_LOG(""request:%p on_hostbyname_done_locked: %s"",+                                request, error_msg.c_str());+    PrintCurrentStackTrace();+    request->OnResolveLocked(GRPC_ERROR_CREATE(error_msg));+    return;+  }+  GRPC_ARES_WRAPPER_TRACE_LOG(+      ""request:%p on_hostbyname_done_locked qtype=%s host=%s ARES_SUCCESS"",+      request, harg->qtype, request->host_.c_str());+  PrintCurrentStackTrace();++  std::vector<EventEngine::ResolvedAddress> resolved_addresses;+  for (size_t i = 0; hostent->h_addr_list[i] != nullptr; i++) {+    switch (hostent->h_addrtype) {+      case AF_INET6: {+        size_t addr_len = sizeof(struct sockaddr_in6);+        struct sockaddr_in6 addr;+        memset(&addr, 0, addr_len);+        memcpy(&addr.sin6_addr, hostent->h_addr_list[i],+               sizeof(struct in6_addr));+        addr.sin6_family = static_cast<unsigned char>(hostent->h_addrtype);+        addr.sin6_port = htons(request->port_);+        resolved_addresses.emplace_back(+            reinterpret_cast<const sockaddr*>(&addr), addr_len);+        char output[INET6_ADDRSTRLEN];+        ares_inet_ntop(AF_INET6, &addr.sin6_addr, output, INET6_ADDRSTRLEN);+        GRPC_ARES_WRAPPER_TRACE_LOG(+            ""request:%p c-ares resolver gets a AF_INET6 result: \n""+            ""  addr: %s\n  port: %d\n  sin6_scope_id: %d\n"",+            request, output, request->port_, addr.sin6_scope_id);+        break;+      }+      case AF_INET: {+        size_t addr_len = sizeof(struct sockaddr_in);+        struct sockaddr_in addr;+        memset(&addr, 0, addr_len);+        memcpy(&addr.sin_addr, hostent->h_addr_list[i], sizeof(struct in_addr));+        addr.sin_family = static_cast<unsigned char>(hostent->h_addrtype);+        addr.sin_port = htons(request->port_);+        resolved_addresses.emplace_back(+            reinterpret_cast<const sockaddr*>(&addr), addr_len);+        char output[INET_ADDRSTRLEN];+        ares_inet_ntop(AF_INET, &addr.sin_addr, output, INET_ADDRSTRLEN);+        GRPC_ARES_WRAPPER_TRACE_LOG(+            ""request:%p c-ares resolver gets a AF_INET result: \n""+            ""  addr: %s\n  port: %d\n"",+            request, output, request->port_);+        break;+      }+    }+  }+  request->OnResolveLocked(std::move(resolved_addresses));+}++void GrpcAresSRVRequest::OnSRVQueryDoneLocked(void* arg, int status,+                                              int /*timeouts*/,+                                              unsigned char* abuf, int alen) {+  GrpcAresSRVRequest* r = static_cast<GrpcAresSRVRequest*>(arg);+  if (status != ARES_SUCCESS) {+    std::string error_msg = absl::StrFormat(+        ""c-ares status is not ARES_SUCCESS qtype=SRV name=%s: %s"",+        r->host_.c_str(), ares_strerror(status));+    GRPC_ARES_WRAPPER_TRACE_LOG(""request:%p on_srv_query_done_locked: %s"", r,+                                error_msg.c_str());+    r->OnResolveLocked(GRPC_ERROR_CREATE(error_msg));+    return;+  }+  GRPC_ARES_WRAPPER_TRACE_LOG(+      ""request:%p on_srv_query_done_locked name=%s ARES_SUCCESS"", r,+      r->host_.c_str());+  struct ares_srv_reply* reply = nullptr;+  const int parse_status = ares_parse_srv_reply(abuf, alen, &reply);+  GRPC_ARES_WRAPPER_TRACE_LOG(""request:%p ares_parse_srv_reply: %d"", r,+                              parse_status);+  Result result;+  if (parse_status == ARES_SUCCESS) {+    for (struct ares_srv_reply* srv_it = reply; srv_it != nullptr;+         srv_it = srv_it->next) {+      EventEngine::DNSResolver::SRVRecord record;+      record.host = srv_it->host;+      record.port = srv_it->port;+      record.priority = srv_it->priority;+      record.weight = srv_it->weight;+      result.push_back(std::move(record));+    }+  }+  if (reply != nullptr) {+    ares_free_data(reply);+  }+  r->OnResolveLocked(std::move(result));+}++void GrpcAresTXTRequest::OnTXTDoneLocked(void* arg, int status,+                                         int /*timeouts*/, unsigned char* buf,+                                         int len) {+  GrpcAresTXTRequest* r = static_cast<GrpcAresTXTRequest*>(arg);+  struct ares_txt_ext* reply = nullptr;+  int parse_status = ARES_SUCCESS;+  if (status == ARES_SUCCESS) {+    GRPC_ARES_WRAPPER_TRACE_LOG(+        ""request:%p on_txt_done_locked name=%s ARES_SUCCESS"", r,+        r->host_.c_str());+    parse_status = ares_parse_txt_reply_ext(buf, len, &reply);+  }+  if (status != ARES_SUCCESS || parse_status != ARES_SUCCESS) {+    std::string error_msg = absl::StrFormat(+        ""c-ares status is not ARES_SUCCESS qtype=TXT name=%s: %s"",+        r->host_.c_str(), ares_strerror(status));+    GRPC_ARES_WRAPPER_TRACE_LOG(""request:%p on_txt_done_locked %s"", r,+                                error_msg.c_str());+    r->OnResolveLocked(GRPC_ERROR_CREATE(error_msg));+    return;+  }+  Result result;+  for (struct ares_txt_ext* part = reply; part != nullptr; part = part->next) {+    if (part->record_start) {+      result.emplace_back(reinterpret_cast<char*>(part->txt), part->length);+    } else {+      absl::StrAppend(+          &result.back(),+          std::string(reinterpret_cast<char*>(part->txt), part->length));+    }+  }+  GRPC_ARES_WRAPPER_TRACE_LOG(""request: %p, got %zu TXT records"", r,+                              result.size());+  if (GRPC_TRACE_FLAG_ENABLED(grpc_trace_ares_wrapper)) {+    for (const auto& record : result) {+      gpr_log(GPR_INFO, ""%s"", record.c_str());+    }+  }+  // Clean up.+  ares_free_data(reply);+  r->OnResolveLocked(std::move(result));+}++GrpcAresRequest::FdNode::FdNode(ares_socket_t as, GrpcPolledFd* polled_fd)+    : as(as), polled_fd(polled_fd) {}++GrpcAresRequest::FdNode* GrpcAresRequest::FdNodeList::PopFdNode(+    ares_socket_t as) {+  FdNode phony_head;+  phony_head.next = head_;+  FdNode* node = &phony_head;+  while (node->next != nullptr) {+    if (node->next->polled_fd->GetWrappedAresSocketLocked() == as) {+      FdNode* ret = node->next;+      node->next = node->next->next;+      head_ = phony_head.next;+      return ret;+    }+    node = node->next;+  }+  return nullptr;+}++GrpcAresRequest::GrpcAresRequest(+    absl::string_view name, EventEngine::Duration timeout,+    std::unique_ptr<GrpcPolledFdFactory> polled_fd_factory,+    EventEngine* event_engine)+    : grpc_core::InternallyRefCounted<GrpcAresRequest>(+          GRPC_TRACE_FLAG_ENABLED(grpc_trace_ares_wrapper) ? ""GrpcAresRequest""+                                                           : nullptr),+      name_(name),+      event_engine_(event_engine),+      timeout_(timeout),+      fd_node_list_(std::make_unique<FdNodeList>()),+      polled_fd_factory_(std::move(polled_fd_factory)) {}++GrpcAresRequest::~GrpcAresRequest() {+  if (initialized_) {+    ares_destroy(channel_);+    PrintCurrentStackTrace();+  }+  GRPC_ARES_WRAPPER_TRACE_LOG(""request:%p destructor"", this);+}++absl::StatusOr<std::string> GrpcAresRequest::ParseNameToResolve()+    ABSL_NO_THREAD_SAFETY_ANALYSIS {+  GPR_DEBUG_ASSERT(!initialized_);+  std::string port;+  // parse name, splitting it into host and port parts+  grpc_core::SplitHostPort(name_, &host_, &port);+  absl::Status error;+  if (host_.empty()) {+    return grpc_error_set_str(GRPC_ERROR_CREATE(""unparseable host:port""),+                              grpc_core::StatusStrProperty::kTargetAddress,+                              name_);+  }+  return port;+}++absl::Status GrpcAresRequest::InitializeAresOptions(+    absl::string_view dns_server) ABSL_NO_THREAD_SAFETY_ANALYSIS {+  GPR_DEBUG_ASSERT(!initialized_);+  ares_options opts = {};+  opts.flags |= ARES_FLAG_STAYOPEN;+  int status = ares_init_options(&channel_, &opts, ARES_OPT_FLAGS);+  if (status != ARES_SUCCESS) {+    gpr_log(GPR_ERROR, ""ares_init_options failed, status: %d"", status);+    return GRPC_ERROR_CREATE(absl::StrCat(+        ""Failed to init ares channel. c-ares error: "", ares_strerror(status)));+  }+  event_engine_grpc_ares_test_only_inject_config(channel_);+  // If dns_server is specified, use it.+  absl::Status error = SetRequestDNSServer(dns_server);+  if (!error.ok()) {+    ares_destroy(channel_);+    return error;+  }+  initialized_ = true;+  return absl::OkStatus();+}++bool GrpcAresRequest::Cancel() {+  grpc_core::MutexLock lock(&mu_);+  if (std::exchange(shutting_down_, true)) {+    // Already shutting down, maybe resolved, cancelled or timed-out.+    return false;+  }+  cancelled_ = true;+  CancelTimers();+  ShutdownPolledFdsLocked(grpc_core::StatusCreate(+      absl::StatusCode::kCancelled, ""Cancel"", DEBUG_LOCATION, {}));+  return true;+}++void GrpcAresRequest::Work() {+  auto new_list = std::make_unique<FdNodeList>();+  if (!shutting_down_) {+    ares_socket_t socks[ARES_GETSOCK_MAXNUM];+    int socks_bitmask = ares_getsock(channel_, socks, ARES_GETSOCK_MAXNUM);+    for (size_t i = 0; i < ARES_GETSOCK_MAXNUM; i++) {+      if (ARES_GETSOCK_READABLE(socks_bitmask, i) ||+          ARES_GETSOCK_WRITABLE(socks_bitmask, i)) {+        FdNode* fd_node = fd_node_list_->PopFdNode(socks[i]);+        if (fd_node == nullptr) {+          fd_node = new FdNode(+              socks[i], polled_fd_factory_->NewGrpcPolledFdLocked(socks[i]));+          GRPC_ARES_WRAPPER_TRACE_LOG(""request:%p new fd: %d"", this,+                                      fd_node->as);+        }+        new_list->PushFdNode(fd_node);+        // Register read_closure if the socket is readable and read_closure+        // has not been registered with this socket.+        if (ARES_GETSOCK_READABLE(socks_bitmask, i) &&+            !fd_node->readable_registered) {+          GRPC_ARES_WRAPPER_TRACE_LOG(""request:%p notify read on: %d"", this,+                                      fd_node->as);+          fd_node->readable_registered = true;+          fd_node->polled_fd->RegisterForOnReadableLocked(+              [self = Ref(DEBUG_LOCATION, ""Work""),+               fd_node](absl::Status status) mutable {+                grpc_core::ApplicationCallbackExecCtx callback_exec_ctx;+                grpc_core::ExecCtx exec_ctx;+                self->OnReadable(fd_node, status);+              });+        }+        // Register write_closure if the socket is writable and write_closure+        // has not been registered with this socket.+        if (ARES_GETSOCK_WRITABLE(socks_bitmask, i) &&+            !fd_node->writable_registered) {+          GRPC_ARES_WRAPPER_TRACE_LOG(""request:%p notify write on: %d"", this,+                                      fd_node->as);+          fd_node->writable_registered = true;+          fd_node->polled_fd->RegisterForOnWriteableLocked(+              [self = Ref(DEBUG_LOCATION, ""Work""),+               fd_node](absl::Status status) mutable {+                grpc_core::ApplicationCallbackExecCtx callback_exec_ctx;+                grpc_core::ExecCtx exec_ctx;+                self->OnWritable(fd_node, status);+              });+        }+      }+    }+  }+  // Any remaining fds in fd_node_list_ were not returned by ares_getsock()+  // and are therefore no longer in use, so they can be shut down and removed+  // from the list.+  while (!fd_node_list_->IsEmpty()) {+    FdNode* fd_node = fd_node_list_->PopFdNode();+    if (!fd_node->already_shutdown) {+      GRPC_ARES_WRAPPER_TRACE_LOG(""request: %p shutdown fd: %s"", this,+                                  fd_node->polled_fd->GetName());+      fd_node->polled_fd->ShutdownLocked(absl::OkStatus());+      fd_node->already_shutdown = true;+    }+    if (!fd_node->readable_registered && !fd_node->writable_registered) {+      GRPC_ARES_WRAPPER_TRACE_LOG(""request: %p delete fd: %s"", this,+                                  fd_node->polled_fd->GetName());+      delete fd_node;+    } else {+      new_list->PushFdNode(fd_node);+    }+  }+  fd_node_list_.swap(new_list);+}++void GrpcAresRequest::StartTimers() {+  // Initialize overall DNS resolution timeout alarm+  EventEngine::Duration timeout =+      timeout_.count() == 0 ? EventEngine::Duration::max() : timeout_;+  GRPC_ARES_WRAPPER_TRACE_LOG(""request:%p StartTimers timeout in %zu ms"", this,+                              Milliseconds(timeout));++  query_timeout_handle_ = event_engine_->RunAfter(+      timeout, [self = Ref(DEBUG_LOCATION, ""StartTimers"")] {+        grpc_core::ApplicationCallbackExecCtx callback_exec_ctx;+        grpc_core::ExecCtx exec_ctx;+        self->OnQueryTimeout();+      });++  // Initialize the backup poll alarm+  EventEngine::Duration next_ares_backup_poll_alarm_duration =+      calculate_next_ares_backup_poll_alarm_duration();+  GRPC_ARES_WRAPPER_TRACE_LOG(+      ""request:%p StartTimers next ares process poll time in %zu ms"", this,+      Milliseconds(next_ares_backup_poll_alarm_duration));++  ares_backup_poll_alarm_handle_ = event_engine_->RunAfter(+      next_ares_backup_poll_alarm_duration,+      [self = Ref(DEBUG_LOCATION, ""StartTimers"")]() mutable {+        grpc_core::ApplicationCallbackExecCtx callback_exec_ctx;+        grpc_core::ExecCtx exec_ctx;+        self->OnAresBackupPollAlarm();+      });+}++void GrpcAresRequest::CancelTimers() {+  if (query_timeout_handle_.has_value()) {+    event_engine_->Cancel(*query_timeout_handle_);+    query_timeout_handle_.reset();+  }+  if (ares_backup_poll_alarm_handle_.has_value()) {+    event_engine_->Cancel(*ares_backup_poll_alarm_handle_);+    ares_backup_poll_alarm_handle_.reset();+  }+}++absl::Status GrpcAresRequest::SetRequestDNSServer(+    absl::string_view dns_server) {+  if (!dns_server.empty()) {+    GRPC_ARES_WRAPPER_TRACE_LOG(""request:%p Using DNS server %s"", this,+                                dns_server.data());+    grpc_resolved_address addr;+    struct ares_addr_port_node dns_server_addr;+    if (grpc_parse_ipv4_hostport(dns_server, &addr, /*log_errors=*/false)) {+      dns_server_addr.family = AF_INET;+      struct sockaddr_in* in = reinterpret_cast<struct sockaddr_in*>(addr.addr);+      memcpy(&dns_server_addr.addr.addr4, &in->sin_addr,+             sizeof(struct in_addr));+      dns_server_addr.tcp_port = grpc_sockaddr_get_port(&addr);+      dns_server_addr.udp_port = grpc_sockaddr_get_port(&addr);+    } else if (grpc_parse_ipv6_hostport(dns_server, &addr,+                                        /*log_errors=*/false)) {+      dns_server_addr.family = AF_INET6;+      struct sockaddr_in6* in6 =+          reinterpret_cast<struct sockaddr_in6*>(addr.addr);+      memcpy(&dns_server_addr.addr.addr6, &in6->sin6_addr,+             sizeof(struct in6_addr));+      dns_server_addr.tcp_port = grpc_sockaddr_get_port(&addr);+      dns_server_addr.udp_port = grpc_sockaddr_get_port(&addr);+    } else {+      return GRPC_ERROR_CREATE(+          absl::StrCat(""cannot parse authority "", dns_server));+    }+    // Prevent an uninitialized variable.+    dns_server_addr.next = nullptr;+    int status = ares_set_servers_ports(channel_, &dns_server_addr);+    if (status != ARES_SUCCESS) {+      return GRPC_ERROR_CREATE(absl::StrCat(+          ""c-ares status is not ARES_SUCCESS: "", ares_strerror(status)));+    }+  }+  return absl::OkStatus();+}++void GrpcAresRequest::OnReadable(FdNode* fd_node, absl::Status status) {+  grpc_core::MutexLock lock(&mu_);+  GPR_ASSERT(fd_node->readable_registered);+  fd_node->readable_registered = false;+  GRPC_ARES_WRAPPER_TRACE_LOG(""OnReadable: fd: %d; request: %p; status: %s"",+                              fd_node->as, this, status.ToString().c_str());+  PrintCurrentStackTrace();+  if (status.ok() && !shutting_down_) {+    do {+      ares_process_fd(channel_, fd_node->as, ARES_SOCKET_BAD);+    } while (fd_node->polled_fd->IsFdStillReadableLocked());+  } else {+    // If error is not absl::OkStatus() or the resolution was cancelled, it+    // means the fd has been shutdown or timed out. The pending lookups made+    // on this request will be cancelled by the following ares_cancel(). The+    // remaining file descriptors in this request will be cleaned up in the+    // following Work() method.+    ares_cancel(channel_);+  }+  Work();+}++void GrpcAresRequest::OnWritable(FdNode* fd_node, absl::Status status) {+  grpc_core::MutexLock lock(&mu_);+  GPR_ASSERT(fd_node->writable_registered);+  fd_node->writable_registered = false;+  GRPC_ARES_WRAPPER_TRACE_LOG(""OnWritable: fd: %d; request:%p; status: %s"",+                              fd_node->as, this, status.ToString().c_str());+  if (status.ok() && !shutting_down_) {+    ares_process_fd(channel_, ARES_SOCKET_BAD, fd_node->as);+  } else {+    // If error is not absl::OkStatus() or the resolution was cancelled, it+    // means the fd has been shutdown or timed out. The pending lookups made+    // on this request will be cancelled by the following ares_cancel(). The+    // remaining file descriptors in this request will be cleaned up in the+    // following Work() method.+    ares_cancel(channel_);+  }+  Work();+}++void GrpcAresRequest::OnQueryTimeout() {+  grpc_core::MutexLock lock(&mu_);+  query_timeout_handle_.reset();+  GRPC_ARES_WRAPPER_TRACE_LOG(""request:%p OnQueryTimeout. shutting_down_=%d"",+                              this, shutting_down_);+  if (!shutting_down_) {+    shutting_down_ = true;+    ShutdownPolledFdsLocked(+        grpc_core::StatusCreate(absl::StatusCode::kDeadlineExceeded,+                                ""OnQueryTimeout"", DEBUG_LOCATION, {}));+  }+}++// In case of non-responsive DNS servers, dropped packets, etc., c-ares has+// intelligent timeout and retry logic, which we can take advantage of by+// polling ares_process_fd on time intervals. Overall, the c-ares library is+// meant to be called into and given a chance to proceed name resolution:+//   a) when fd events happen+//   b) when some time has passed without fd events having happened+// For the latter, we use this backup poller. Also see+// https://github.com/grpc/grpc/pull/17688 description for more details.+void GrpcAresRequest::OnAresBackupPollAlarm() {+  grpc_core::MutexLock lock(&mu_);+  ares_backup_poll_alarm_handle_.reset();+  GRPC_ARES_WRAPPER_TRACE_LOG(+      ""request:%p OnAresBackupPollAlarm shutting_down=%d."", this,+      shutting_down_);+  if (!shutting_down_) {+    for (auto it = fd_node_list_->begin(); it != fd_node_list_->end(); it++) {+      if (!(*it)->already_shutdown) {+        GRPC_ARES_WRAPPER_TRACE_LOG(+            ""request:%p OnAresBackupPollAlarm; ares_process_fd. fd=%s"", this,+            (*it)->polled_fd->GetName());+        ares_socket_t as = (*it)->polled_fd->GetWrappedAresSocketLocked();+        ares_process_fd(channel_, as, as);+      }+    }+    if (!shutting_down_) {+      EventEngine::Duration next_ares_backup_poll_alarm_duration =+          calculate_next_ares_backup_poll_alarm_duration();+      ares_backup_poll_alarm_handle_ = event_engine_->RunAfter(+          next_ares_backup_poll_alarm_duration,+          [self = Ref(DEBUG_LOCATION, ""OnAresBackupPollAlarm"")]() mutable {+            grpc_core::ApplicationCallbackExecCtx callback_exec_ctx;+            grpc_core::ExecCtx exec_ctx;+            self->OnAresBackupPollAlarm();+          });+    }+    Work();+  }+}++// TODO(yijiem): Consider report this status or as part of the result when","I think the `AddError()` machinery is unnecessary complexity.  In general, I think it's fine to just return whatever error happened first.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32701,1207490417,2023-05-26T23:48:53Z,src/core/lib/event_engine/grpc_ares_wrapper.cc,"@@ -589,166 +443,247 @@ void GrpcAresRequest::OnAresBackupPollAlarm() {           calculate_next_ares_backup_poll_alarm_duration();       ares_backup_poll_alarm_handle_ = event_engine_->RunAfter(           next_ares_backup_poll_alarm_duration,-          [self = Ref(DEBUG_LOCATION, ""OnAresBackupPollAlarm"")]() mutable {-            grpc_core::ApplicationCallbackExecCtx callback_exec_ctx;-            grpc_core::ExecCtx exec_ctx;+          [self = Ref(DEBUG_LOCATION, ""OnAresBackupPollAlarm"")]() {             self->OnAresBackupPollAlarm();           });     }     Work();+    if (shutting_down_) {+      OnResolveLockedAndUnlock();+      return;+    }   }+  mu().Unlock(); } -// TODO(yijiem): Consider report this status or as part of the result when-// calling on_resolve_. This status is received in OnReadable/OnWritable. void GrpcAresRequest::ShutdownPolledFdsLocked(absl::Status status) {-  for (auto it = fd_node_list_->begin(); it != fd_node_list_->end(); it++) {-    if (!(*it)->already_shutdown) {+  for (const auto& fd_node : fd_node_list_) {+    if (!fd_node->already_shutdown) {       GRPC_ARES_WRAPPER_TRACE_LOG(""request: %p shutdown fd: %s"", this,-                                  (*it)->polled_fd->GetName());-      (*it)->polled_fd->ShutdownLocked(status);-      (*it)->already_shutdown = true;+                                  fd_node->polled_fd->GetName());+      fd_node->polled_fd->ShutdownLocked(status);+      fd_node->already_shutdown = true;     }   } } -GrpcAresHostnameRequest::GrpcAresHostnameRequest(+absl::StatusOr<GrpcAresHostnameRequest*> GrpcAresHostnameRequest::Create(     absl::string_view name, absl::string_view default_port,-    EventEngine::Duration timeout,+    absl::string_view dns_server, EventEngine::Duration timeout,     std::unique_ptr<GrpcPolledFdFactory> polled_fd_factory,-    EventEngine* event_engine)-    : GrpcAresRequest(name, timeout, std::move(polled_fd_factory),-                      event_engine),-      default_port_(default_port) {}--GrpcAresHostnameRequest::~GrpcAresHostnameRequest() {-  // Destruction of on_resolve_ may trigger a chain of destruction that may-  // require ExecCtx in the current thread.-  grpc_core::ApplicationCallbackExecCtx callback_exec_ctx;-  grpc_core::ExecCtx exec_ctx;-  { auto c = std::move(on_resolve_); }-  GRPC_ARES_WRAPPER_TRACE_LOG(""request:%p destructor"", this);-}--void GrpcAresHostnameRequest::Start(-    absl::AnyInvocable<void(absl::StatusOr<Result>)> on_resolve) {-  // Holds a ref across this function since OnResolve might be called inline-  // inside ares_gethostbyname and we might be done in that case. This ref needs-  // to be taken outside of the lock to prevent UAF during unlock if the-  // destruction of the ref triggers the destruction of the request itself.-  auto self = Ref(DEBUG_LOCATION, ""Start"");-  grpc_core::MutexLock lock(&mu_);-  GPR_ASSERT(initialized_);-  on_resolve_ = std::move(on_resolve);-  GRPC_ARES_WRAPPER_TRACE_LOG(-      ""request:%p c-ares GrpcAresHostnameRequest::Start name=%s, ""-      ""default_port=%s"",-      this, name_.c_str(), default_port_.c_str());-  // Early out if the target is an ipv4 or ipv6 literal.-  if (ResolveAsIPLiteralLocked()) {-    return;-  }-  // TODO(yijiem): Early out if the target is localhost and we're on Windows.--  // We add up pending_queries_ here since ares_gethostbyname may directly-  // invoke the callback inline e.g. if there is any error with the input. The-  // callback will invoke OnResolve with an error status and may start the-  // shutdown process too early (before the second ares_gethostbyname) if we-  // haven't added up here.-  ++pending_queries_;+    EventEngine* event_engine) ABSL_NO_THREAD_SAFETY_ANALYSIS {+  auto* request = new GrpcAresHostnameRequest(","Suggest using a smart pointer to allow the compiler to enforce ownership:```auto request = std::make_unique<GrpcAresHostnameRequest>(    name, default_port, timeout, std::move(polled_fd_factory), event_engine);absl::StatusOr<std::string> result = request->ParseNameToResolve();if (!result.ok()) return result.status();absl::Status status = request->ParsePort(*result);if (!status.ok()) return status;status = request->InitializeAresOptions(dns_server);if (!status.ok()) return status;return request.release();```Same thing in all subclasses.Note: This comment is irrelevant if you take my suggestion below about eliminating the `ParseNameToResolve()` and `ParsePort()` methods.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32701,1207507299,2023-05-27T00:19:24Z,src/core/lib/event_engine/grpc_ares_wrapper.cc,"@@ -589,166 +443,247 @@ void GrpcAresRequest::OnAresBackupPollAlarm() {           calculate_next_ares_backup_poll_alarm_duration();       ares_backup_poll_alarm_handle_ = event_engine_->RunAfter(           next_ares_backup_poll_alarm_duration,-          [self = Ref(DEBUG_LOCATION, ""OnAresBackupPollAlarm"")]() mutable {-            grpc_core::ApplicationCallbackExecCtx callback_exec_ctx;-            grpc_core::ExecCtx exec_ctx;+          [self = Ref(DEBUG_LOCATION, ""OnAresBackupPollAlarm"")]() {             self->OnAresBackupPollAlarm();           });     }     Work();+    if (shutting_down_) {+      OnResolveLockedAndUnlock();+      return;+    }   }+  mu().Unlock(); } -// TODO(yijiem): Consider report this status or as part of the result when-// calling on_resolve_. This status is received in OnReadable/OnWritable. void GrpcAresRequest::ShutdownPolledFdsLocked(absl::Status status) {-  for (auto it = fd_node_list_->begin(); it != fd_node_list_->end(); it++) {-    if (!(*it)->already_shutdown) {+  for (const auto& fd_node : fd_node_list_) {+    if (!fd_node->already_shutdown) {       GRPC_ARES_WRAPPER_TRACE_LOG(""request: %p shutdown fd: %s"", this,-                                  (*it)->polled_fd->GetName());-      (*it)->polled_fd->ShutdownLocked(status);-      (*it)->already_shutdown = true;+                                  fd_node->polled_fd->GetName());+      fd_node->polled_fd->ShutdownLocked(status);+      fd_node->already_shutdown = true;     }   } } -GrpcAresHostnameRequest::GrpcAresHostnameRequest(+absl::StatusOr<GrpcAresHostnameRequest*> GrpcAresHostnameRequest::Create(     absl::string_view name, absl::string_view default_port,-    EventEngine::Duration timeout,+    absl::string_view dns_server, EventEngine::Duration timeout,     std::unique_ptr<GrpcPolledFdFactory> polled_fd_factory,-    EventEngine* event_engine)-    : GrpcAresRequest(name, timeout, std::move(polled_fd_factory),-                      event_engine),-      default_port_(default_port) {}--GrpcAresHostnameRequest::~GrpcAresHostnameRequest() {-  // Destruction of on_resolve_ may trigger a chain of destruction that may-  // require ExecCtx in the current thread.-  grpc_core::ApplicationCallbackExecCtx callback_exec_ctx;-  grpc_core::ExecCtx exec_ctx;-  { auto c = std::move(on_resolve_); }-  GRPC_ARES_WRAPPER_TRACE_LOG(""request:%p destructor"", this);-}--void GrpcAresHostnameRequest::Start(-    absl::AnyInvocable<void(absl::StatusOr<Result>)> on_resolve) {-  // Holds a ref across this function since OnResolve might be called inline-  // inside ares_gethostbyname and we might be done in that case. This ref needs-  // to be taken outside of the lock to prevent UAF during unlock if the-  // destruction of the ref triggers the destruction of the request itself.-  auto self = Ref(DEBUG_LOCATION, ""Start"");-  grpc_core::MutexLock lock(&mu_);-  GPR_ASSERT(initialized_);-  on_resolve_ = std::move(on_resolve);-  GRPC_ARES_WRAPPER_TRACE_LOG(-      ""request:%p c-ares GrpcAresHostnameRequest::Start name=%s, ""-      ""default_port=%s"",-      this, name_.c_str(), default_port_.c_str());-  // Early out if the target is an ipv4 or ipv6 literal.-  if (ResolveAsIPLiteralLocked()) {-    return;-  }-  // TODO(yijiem): Early out if the target is localhost and we're on Windows.--  // We add up pending_queries_ here since ares_gethostbyname may directly-  // invoke the callback inline e.g. if there is any error with the input. The-  // callback will invoke OnResolve with an error status and may start the-  // shutdown process too early (before the second ares_gethostbyname) if we-  // haven't added up here.-  ++pending_queries_;+    EventEngine* event_engine) ABSL_NO_THREAD_SAFETY_ANALYSIS {+  auto* request = new GrpcAresHostnameRequest(+      name, default_port, timeout, std::move(polled_fd_factory), event_engine);+  absl::StatusOr<std::string> result = request->ParseNameToResolve();","The `ParseNameToResolve()` and `ParsePort()` methods seem fairly cumbersome, since their names imply that they just do some parsing, but they actually read and modify the object's state.  Also, the fact that they do that means that we wind up creating and destroying an object that we don't need when the input is invalid.  And we are storing fields like `name_` and `default_port_` as data members when we actually don't actually need them beyond the ctor.I think this code would be clearer if you just inlined it here.  Consider the following alternative:```std::string host;std::string port_str;if (!SplitHostPort(name, &host, &port_str)) {  return absl::InvalidArgumentError(absl::StrCat(      ""cannot parse hostname: "", name));}if (port_str.empty()) {  if (default_port.empty()) {    return absl::InvalidArgumentError(        absl::StrFormat(""No port in name %s or default_port argument"",                        name));  }  port_str = default_port;}int port;if (port_str == ""http"") {  port = 80;} else if (port_str == ""https"") {  port = 443;} else if (!absl::SimpleAtoi(port_str, &port)) {  return absl::InvalidArgumentError(      absl::StrCat(""Failed to parse port in name: "", name));}return new GrpcAresHostnameRequest(    host, port, timeout, std::move(polled_fd_factory), event_engine);```I think this would also allow you to remove the `InitializeAresOptions()` method, because that code can instead be inlined into the base class's ctor.Similar change in all subclasses.",
1644595,gnossen,https://api.github.com/repos/grpc/grpc/pulls/32974,1210745390,2023-05-30T19:41:48Z,src/python/grpcio_observability/grpc_observability/_observability.py,"@@ -0,0 +1,175 @@+# Copyright 2023 gRPC authors.+#+# Licensed under the Apache License, Version 2.0 (the ""License"");+# you may not use this file except in compliance with the License.+# You may obtain a copy of the License at+#+#     http://www.apache.org/licenses/LICENSE-2.0+#+# Unless required by applicable law or agreed to in writing, software+# distributed under the License is distributed on an ""AS IS"" BASIS,+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+# See the License for the specific language governing permissions and+# limitations under the License.++from dataclasses import dataclass+from dataclasses import field+import logging+import threading+import time+from typing import Any, Mapping, Optional++import grpc+from grpc_observability import _cyobservability  # pytype: disable=pyi-error+from opencensus.trace import execution_context+from opencensus.trace import span_context as span_context_module+from opencensus.trace import trace_options as trace_options_module++_LOGGER = logging.getLogger(__name__)++ClientCallTracerCapsule = Any  # it appears only once in the function signature+ServerCallTracerFactoryCapsule = Any  # it appears only once in the function signature+grpc_observability = Any  # grpc_observability.py imports this module.++GRPC_STATUS_CODE_TO_STRING = {+    grpc.StatusCode.OK: ""OK"",+    grpc.StatusCode.CANCELLED: ""CANCELLED"",+    grpc.StatusCode.UNKNOWN: ""UNKNOWN"",+    grpc.StatusCode.INVALID_ARGUMENT: ""INVALID_ARGUMENT"",+    grpc.StatusCode.DEADLINE_EXCEEDED: ""DEADLINE_EXCEEDED"",+    grpc.StatusCode.NOT_FOUND: ""NOT_FOUND"",+    grpc.StatusCode.ALREADY_EXISTS: ""ALREADY_EXISTS"",+    grpc.StatusCode.PERMISSION_DENIED: ""PERMISSION_DENIED"",+    grpc.StatusCode.UNAUTHENTICATED: ""UNAUTHENTICATED"",+    grpc.StatusCode.RESOURCE_EXHAUSTED: ""RESOURCE_EXHAUSTED"",+    grpc.StatusCode.FAILED_PRECONDITION: ""FAILED_PRECONDITION"",+    grpc.StatusCode.ABORTED: ""ABORTED"",+    grpc.StatusCode.OUT_OF_RANGE: ""OUT_OF_RANGE"",+    grpc.StatusCode.UNIMPLEMENTED: ""UNIMPLEMENTED"",+    grpc.StatusCode.INTERNAL: ""INTERNAL"",+    grpc.StatusCode.UNAVAILABLE: ""UNAVAILABLE"",+    grpc.StatusCode.DATA_LOSS: ""DATA_LOSS"",+}+++@dataclass+class GcpObservabilityPythonConfig:+    _singleton = None+    _lock: threading.RLock = threading.RLock()+    project_id: str = """"+    stats_enabled: bool = False+    tracing_enabled: bool = False+    labels: Optional[Mapping[str, str]] = field(default_factory=dict)+    sampling_rate: Optional[float] = 0.0++    @staticmethod+    def get():+        with GcpObservabilityPythonConfig._lock:+            if GcpObservabilityPythonConfig._singleton is None:+                GcpObservabilityPythonConfig._singleton = GcpObservabilityPythonConfig(+                )+        return GcpObservabilityPythonConfig._singleton++    def set_configuration(self,+                          project_id: str,+                          sampling_rate: Optional[float] = 0.0,+                          labels: Optional[Mapping[str, str]] = None,+                          tracing_enabled: bool = False,+                          stats_enabled: bool = False) -> None:+        self.project_id = project_id+        self.stats_enabled = stats_enabled+        self.tracing_enabled = tracing_enabled+        self.labels = labels+        self.sampling_rate = sampling_rate+++# pylint: disable=no-self-use+class GCPOpenCensusObservability(grpc._observability.ObservabilityPlugin):+    config: GcpObservabilityPythonConfig+    exporter: ""grpc_observability.Exporter""++    def __init__(self, exporter: ""grpc_observability.Exporter"" = None):+        self.exporter = None+        self.config = GcpObservabilityPythonConfig.get()+        if exporter:+            self.exporter = exporter+        else:+            pass+            # Actual implementation of OC exporter",No need to implement a mock now. Just raise a [`NotImplementedError`](https://docs.python.org/3/library/exceptions.html#NotImplementedError) here and add a TODO pointing to a Github issue to take care of this.,
1644595,gnossen,https://api.github.com/repos/grpc/grpc/pulls/32974,1210803231,2023-05-30T20:42:06Z,src/python/grpcio_observability/grpc_observability/observability_util.cc,"@@ -0,0 +1,225 @@+// Copyright 2023 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++#include ""src/python/grpcio_observability/grpc_observability/observability_util.h""++#include <constants.h>+#include <python_census_context.h>++#include <chrono>+#include <cstdlib>+#include <map>+#include <string>++#include ""absl/status/statusor.h""+#include ""absl/strings/string_view.h""+#include ""absl/types/optional.h""++#include <grpc/support/log.h>++#include ""src/cpp/ext/gcp/observability_config.h""+#include ""src/python/grpcio_observability/grpc_observability/client_call_tracer.h""+#include ""src/python/grpcio_observability/grpc_observability/server_call_tracer.h""++namespace grpc_observability {++std::queue<CensusData>* g_census_data_buffer;+std::mutex g_census_data_buffer_mutex;+std::condition_variable g_census_data_buffer_cv;+// TODO(xuanwn): Change below to a more appropriate number.+// Assume buffer will store 100 CensusData and start export when buffer is 50%+// full. kMaxExportBufferSizeBytes = 100 * (2048(kMaxTagsLen) + 1024(Buffer))+constexpr float kExportThreshold = 0.7;+constexpr int kMaxExportBufferSizeBytes = 100 * 1024 * 3;++namespace {++float GetExportThreadHold() {+  const char* value = std::getenv(""GRPC_PYTHON_CENSUS_EXPORT_THRESHOLD"");+  if (value != nullptr) {+    return std::stof(value);+  }+  return kExportThreshold;+}++int GetMaxExportBufferSize() {+  const char* value =+      std::getenv(""GRPC_PYTHON_CENSUS_MAX_EXPORT_BUFFER_SIZE_BYTES"");","Doing this in terms of bytes is going to be tricky because, while you can easily get the in-situ footprint of class/struct using the `sizeof` operator, it's not easy to get the memory footprint of any heap allocations it may have made. For example, if you have```C++struct Foo {  int a;     // 4 bytes  char b; // 1 byte };// sizeof(Foo) returns 5```But as soon as you embed a `std::string`, `sizeof` no longer actually gives you the real memory footprint of your struct. It will only give you the amount of memory it would take up on the stack if stack-allocated, while the section stored on the heap can grow arbitrarily. ```c++std::string s = """";size_t a = sizeof(std::string); // a = 32for (size_t i = 0; i < 99999999; ++i) {  s  += ""a"";}a = sizeof(std::string); // still 32 even though s is using more like 99999999 bytes```If you instrument something like a [`capacity`](https://cplusplus.com/reference/string/string/capacity/) method across all types in your hierarchy, you could make that happen.```c++class Foo {public:  std::string a;  std::vector<char> b;  size_t bytes() const {    return a.capacity() + b.capacity() * sizeof(char);  }};class Bar {public:  Foo f;  std::vector<Foo> fs;  size_t bytes() const {    size_t count = f.bytes();    for (const Foo& fi : fs) {      // Use full runtime size for elements in vector that are actually occupied.      count += fi.bytes();    }        // Also take into account slots that have been allocated but not initialized.    count += (fs.capacity() - fs.size()) * sizeof(Foo);    return count;  }}```As you can see, this approach gets pretty complicated. It's probably more trouble than it's worth for the moment. Let's just count `CensusData` instances for now.",
1644595,gnossen,https://api.github.com/repos/grpc/grpc/pulls/32974,1210803644,2023-05-30T20:42:35Z,src/python/grpcio_observability/grpc_observability/observability_util.cc,"@@ -0,0 +1,225 @@+// Copyright 2023 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++#include ""src/python/grpcio_observability/grpc_observability/observability_util.h""++#include <constants.h>+#include <python_census_context.h>++#include <chrono>+#include <cstdlib>+#include <map>+#include <string>++#include ""absl/status/statusor.h""+#include ""absl/strings/string_view.h""+#include ""absl/types/optional.h""++#include <grpc/support/log.h>++#include ""src/cpp/ext/gcp/observability_config.h""+#include ""src/python/grpcio_observability/grpc_observability/client_call_tracer.h""+#include ""src/python/grpcio_observability/grpc_observability/server_call_tracer.h""++namespace grpc_observability {++std::queue<CensusData>* g_census_data_buffer;+std::mutex g_census_data_buffer_mutex;+std::condition_variable g_census_data_buffer_cv;+// TODO(xuanwn): Change below to a more appropriate number.+// Assume buffer will store 100 CensusData and start export when buffer is 50%+// full. kMaxExportBufferSizeBytes = 100 * (2048(kMaxTagsLen) + 1024(Buffer))+constexpr float kExportThreshold = 0.7;+constexpr int kMaxExportBufferSizeBytes = 100 * 1024 * 3;++namespace {++float GetExportThreadHold() {+  const char* value = std::getenv(""GRPC_PYTHON_CENSUS_EXPORT_THRESHOLD"");+  if (value != nullptr) {+    return std::stof(value);+  }+  return kExportThreshold;+}++int GetMaxExportBufferSize() {+  const char* value =+      std::getenv(""GRPC_PYTHON_CENSUS_MAX_EXPORT_BUFFER_SIZE_BYTES"");+  if (value != nullptr) {+    return std::stoi(value);+  }+  return kMaxExportBufferSizeBytes;+}++}  // namespace++void RecordIntMetric(MetricsName name, int64_t value,+                     const std::vector<Label>& labels) {+  Measurement measurement_data;+  measurement_data.type = kMeasurementInt;+  measurement_data.name = name;+  measurement_data.value.value_int = value;++  CensusData data = CensusData(measurement_data, labels);+  AddCensusDataToBuffer(data);+}++void RecordDoubleMetric(MetricsName name, double value,+                        const std::vector<Label>& labels) {+  Measurement measurement_data;+  measurement_data.type = kMeasurementDouble;+  measurement_data.name = name;+  measurement_data.value.value_double = value;++  CensusData data = CensusData(measurement_data, labels);+  AddCensusDataToBuffer(data);+}++void RecordSpan(const SpanCensusData& span_census_data) {+  CensusData data = CensusData(span_census_data);+  AddCensusDataToBuffer(data);+}++void NativeObservabilityInit() {+  g_census_data_buffer = new std::queue<CensusData>;+}++void* CreateClientCallTracer(const char* method, const char* trace_id,+                             const char* parent_span_id) {+  void* client_call_tracer = new PythonOpenCensusCallTracer(+      method, trace_id, parent_span_id, PythonCensusTracingEnabled());+  return client_call_tracer;+}++void* CreateServerCallTracerFactory() {+  void* server_call_tracer_factory =+      new PythonOpenCensusServerCallTracerFactory();+  return server_call_tracer_factory;+}++void AwaitNextBatchLocked(std::unique_lock<std::mutex>& lock, int timeout_ms) {+  auto now = std::chrono::system_clock::now();+  g_census_data_buffer_cv.wait_until(+      lock, now + std::chrono::milliseconds(timeout_ms));+}++void AddCensusDataToBuffer(const CensusData& data) {+  std::unique_lock<std::mutex> lk(g_census_data_buffer_mutex);+  if (g_census_data_buffer->size() >= GetMaxExportBufferSize()) {","`GetMaxExportBufferSize` returns a value in bytes but `g_census_data_buffer` returns a count of `CensusData` objects. I think this should be:```g_census_data_buffer->size() * sizeof(CensusData) >= GetMaxExportBufferSize()```But based on the other comment I made, we probably want to move away from byte calculation anyway.",
9566254,apolcyn,https://api.github.com/repos/grpc/grpc/pulls/32701,1210859256,2023-05-30T21:51:45Z,src/core/lib/event_engine/grpc_ares_wrapper.h,"@@ -0,0 +1,340 @@+// Copyright 2023 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+#ifndef GRPC_SRC_CORE_LIB_EVENT_ENGINE_GRPC_ARES_WRAPPER_H+#define GRPC_SRC_CORE_LIB_EVENT_ENGINE_GRPC_ARES_WRAPPER_H++#include <grpc/support/port_platform.h>++#if GRPC_ARES == 1++#include <stddef.h>++#include <algorithm>+#include <memory>+#include <string>+#include <vector>++#include <ares.h>++#include ""absl/base/thread_annotations.h""+#include ""absl/functional/any_invocable.h""+#include ""absl/status/status.h""+#include ""absl/status/statusor.h""+#include ""absl/strings/string_view.h""+#include ""absl/types/optional.h""++#include <grpc/event_engine/event_engine.h>+#include <grpc/support/log.h>++#include ""src/core/lib/debug/trace.h""+#include ""src/core/lib/event_engine/grpc_polled_fd.h""+#include ""src/core/lib/gprpp/orphanable.h""+#include ""src/core/lib/gprpp/sync.h""++namespace grpc_event_engine {+namespace experimental {++extern grpc_core::TraceFlag grpc_trace_ares_wrapper;++#define GRPC_ARES_WRAPPER_TRACE_LOG(format, ...)                              \+  do {                                                                        \+    if (GRPC_TRACE_FLAG_ENABLED(grpc_trace_ares_wrapper)) {                   \+      gpr_log(GPR_INFO, ""(EventEngine c-ares wrapper) "" format, __VA_ARGS__); \+    }                                                                         \+  } while (0)++// Base class for the c-ares based DNS lookup functionality. This class is+// inherited by the concrete leaf classes below which each represents a+// different type of lookup (i.e. A/AAAA, SRV, TXT). One request object+// represents one lookup request for a specific name. GrpcAresRequest+// encapsulates the common logics to initialize and destroy the c-ares channel+// (one channel for one request). Sets the name servers configuration for the","A few thoughts:> The biggest one seems to be cancellation. ares_cancel will cancel all the queries associated with a channel and there seems to be no alternative (see [1] also). This is in conflict with the EventEngine API which allows to cancel each individual request.I agree with @markdroth that whenever we want to cancel one of these requests, we will actually want to cancel all of them anyways. So the coarse grained cancellation semantics seem OK. > Another sort of related issue is when we get a list of sockets/fds associated with a channel to wait on from c-ares, we don't necessarily know which one corresponding to which request (see ares_getsock).I agree with @yijiem that this seems like a big problem, I'd imagine this will make sharing c-ares channels across requests complicated.I could think of two ways forward here:1) Restructure EE DNS APIs to make this easier, as @markdroth said.2) Don't take this optimization and live with the overhead of separate c-ares channels per request. On top of what @yijiem pointed out, this will also mean more file descriptors per request I believe. However, this *might* not be that bad because:    - SRV queries are going away long term with the deprecation of grpclb    - TXT queries are off by defaultSo if the common case in the long term is hostname queries only, perhaps we can live without sharing the c-ares channel.> And we could probably live with expressing timeouts at the DNSResolver level as well.+1 that we could handle timeouts at the caller. Right now, our c-ares lookup timeout API basically just cancels the request after the timeout - we could have the caller do that instead.",
9566254,apolcyn,https://api.github.com/repos/grpc/grpc/pulls/32701,1210867388,2023-05-30T22:03:08Z,src/core/lib/event_engine/posix_engine/posix_engine.h,"@@ -138,6 +138,11 @@ class PosixEventEngine final : public PosixEventEngineWithFdSupport,  public:   class PosixDNSResolver : public EventEngine::DNSResolver {    public:+#if GRPC_ARES == 1 && defined(GRPC_POSIX_SOCKET_TCP)+    PosixDNSResolver(const ResolverOptions& options,+                     PosixEnginePollerManager* poller_manager,+                     std::shared_ptr<EventEngine> event_engine);+#endif  // GRPC_ARES == 1 && defined(GRPC_POSIX_SOCKET_TCP)     ~PosixDNSResolver() override;     LookupTaskHandle LookupHostname(LookupHostnameCallback on_resolve,",naming nit: s/on_resolve/on_resolved for clarity,
9566254,apolcyn,https://api.github.com/repos/grpc/grpc/pulls/32701,1210876143,2023-05-30T22:12:46Z,src/core/lib/event_engine/grpc_ares_wrapper.cc,"@@ -0,0 +1,1037 @@+// Copyright 2023 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++#include <grpc/support/port_platform.h>++#include ""src/core/lib/event_engine/grpc_ares_wrapper.h""++#include <iterator>++#include ""src/core/lib/iomgr/port.h""++// IWYU pragma: no_include <arpa/inet.h>+// IWYU pragma: no_include <arpa/nameser.h>+// IWYU pragma: no_include <inttypes.h>+// IWYU pragma: no_include <netdb.h>+// IWYU pragma: no_include <netinet/in.h>+// IWYU pragma: no_include <stdlib.h>+// IWYU pragma: no_include <sys/socket.h>+// IWYU pragma: no_include <ratio>++#if GRPC_ARES == 1++#include <string.h>++#include <algorithm>+#include <chrono>+#include <initializer_list>+#include <memory>+#include <type_traits>+#include <utility>++#include <address_sorting/address_sorting.h>++#include ""absl/strings/match.h""+#include ""absl/strings/numbers.h""+#include ""absl/strings/str_cat.h""+#include ""absl/strings/str_format.h""+#include ""absl/types/optional.h""++#include <grpc/event_engine/event_engine.h>+#include <grpc/support/alloc.h>+#include <grpc/support/log.h>++#include ""src/core/lib/address_utils/parse_address.h""+#include ""src/core/lib/address_utils/sockaddr_utils.h""+#include ""src/core/lib/event_engine/grpc_polled_fd.h""+#include ""src/core/lib/event_engine/nameser.h""  // IWYU pragma: keep+#include ""src/core/lib/event_engine/tcp_socket_utils.h""+#include ""src/core/lib/event_engine/time_util.h""+#include ""src/core/lib/gprpp/debug_location.h""+#include ""src/core/lib/gprpp/examine_stack.h""+#include ""src/core/lib/gprpp/host_port.h""+#include ""src/core/lib/gprpp/ref_counted_ptr.h""+#include ""src/core/lib/gprpp/status_helper.h""+#include ""src/core/lib/iomgr/resolved_address.h""+#include ""src/core/lib/iomgr/sockaddr.h""+#ifdef GRPC_POSIX_SOCKET_ARES_EV_DRIVER+#include ""src/core/lib/event_engine/posix_engine/tcp_socket_utils.h""+#elif defined(GRPC_WINDOWS_SOCKET_ARES_EV_DRIVER)+#endif++namespace grpc_event_engine {+namespace experimental {++grpc_core::TraceFlag grpc_trace_ares_wrapper_address_sorting(+    false, ""ares_wrapper_address_sorting"");++grpc_core::TraceFlag grpc_trace_ares_wrapper_stacktrace(+    false, ""ares_wrapper_stacktrace"");++void PrintCurrentStackTrace() {+  if (GRPC_TRACE_FLAG_ENABLED(grpc_trace_ares_wrapper_stacktrace)) {+    absl::optional<std::string> stacktrace = grpc_core::GetCurrentStackTrace();+    if (stacktrace.has_value()) {+      gpr_log(GPR_DEBUG, ""%s"", stacktrace->c_str());+    } else {+      gpr_log(GPR_DEBUG, ""stacktrace unavailable"");+    }+  }+}++grpc_core::TraceFlag grpc_trace_ares_wrapper(false,+                                             ""event_engine_ares_wrapper"");++namespace {++EventEngine::Duration calculate_next_ares_backup_poll_alarm_duration() {+  // An alternative here could be to use ares_timeout to try to be more+  // accurate, but that would require using ""struct timeval""'s, which just+  // makes things a bit more complicated. So just poll every second, as+  // suggested by the c-ares code comments.+  return std::chrono::seconds(1);+}++bool IsIpv6LoopbackAvailable() {+#ifdef GRPC_POSIX_SOCKET_ARES_EV_DRIVER+  return PosixSocketWrapper::IsIpv6LoopbackAvailable();+#elif defined(GRPC_WINDOWS_SOCKET_ARES_EV_DRIVER)+  // TODO(yijiem): make this portable for Windows+  return false;+#else+#error ""Unsupported platform""+#endif+}++struct HostbynameArg {+  GrpcAresHostnameRequest* request;+  const char* qtype;+};++absl::Status AresStatusToAbslStatus(int status, const std::string& error_msg) {+  switch (status) {+    case ARES_ECANCELLED:+      return absl::Status(absl::StatusCode::kCancelled, error_msg);+    case ARES_ENOTIMP:+      return absl::Status(absl::StatusCode::kUnimplemented, error_msg);+    case ARES_ENOTFOUND:+      return absl::Status(absl::StatusCode::kNotFound, error_msg);+    default:+      return absl::Status(absl::StatusCode::kUnknown, error_msg);+  }+}++}  // namespace++GrpcAresRequest::~GrpcAresRequest() {+  GPR_ASSERT(fd_node_list_.empty());+  if (initialized_) {+    ares_destroy(channel_);+  }+  GRPC_ARES_WRAPPER_TRACE_LOG(""request:%p destructor"", this);+}++bool GrpcAresRequest::Cancel() {+  grpc_core::MutexLock lock(&mu());+  if (std::exchange(shutting_down_, true)) {+    // Already shutting down, maybe resolved, cancelled or timed-out.+    return false;+  }+  cancelled_ = true;+  CancelTimers();+  ShutdownPolledFdsLocked(grpc_core::StatusCreate(+      absl::StatusCode::kCancelled, ""Cancel"", DEBUG_LOCATION, {}));+  return true;+}++GrpcAresRequest::GrpcAresRequest(+    absl::string_view name, EventEngine::Duration timeout,+    std::unique_ptr<GrpcPolledFdFactory> polled_fd_factory,+    EventEngine* event_engine)+    : grpc_core::InternallyRefCounted<GrpcAresRequest>(+          GRPC_TRACE_FLAG_ENABLED(grpc_trace_ares_wrapper) ? ""GrpcAresRequest""+                                                           : nullptr),+      name_(name),+      timeout_(timeout),+      polled_fd_factory_(std::move(polled_fd_factory)),+      event_engine_(event_engine) {}++void GrpcAresRequest::Work() {","naming nit: the method name `Work` might be confusing here - that would normally make me think that polling is happening here.Maybe this could be better named `CheckSockets`, or something like that.",
9566254,apolcyn,https://api.github.com/repos/grpc/grpc/pulls/32701,1210879951,2023-05-30T22:18:03Z,src/core/lib/event_engine/grpc_ares_wrapper.cc,"@@ -0,0 +1,1037 @@+// Copyright 2023 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++#include <grpc/support/port_platform.h>++#include ""src/core/lib/event_engine/grpc_ares_wrapper.h""++#include <iterator>++#include ""src/core/lib/iomgr/port.h""++// IWYU pragma: no_include <arpa/inet.h>+// IWYU pragma: no_include <arpa/nameser.h>+// IWYU pragma: no_include <inttypes.h>+// IWYU pragma: no_include <netdb.h>+// IWYU pragma: no_include <netinet/in.h>+// IWYU pragma: no_include <stdlib.h>+// IWYU pragma: no_include <sys/socket.h>+// IWYU pragma: no_include <ratio>++#if GRPC_ARES == 1++#include <string.h>++#include <algorithm>+#include <chrono>+#include <initializer_list>+#include <memory>+#include <type_traits>+#include <utility>++#include <address_sorting/address_sorting.h>++#include ""absl/strings/match.h""+#include ""absl/strings/numbers.h""+#include ""absl/strings/str_cat.h""+#include ""absl/strings/str_format.h""+#include ""absl/types/optional.h""++#include <grpc/event_engine/event_engine.h>+#include <grpc/support/alloc.h>+#include <grpc/support/log.h>++#include ""src/core/lib/address_utils/parse_address.h""+#include ""src/core/lib/address_utils/sockaddr_utils.h""+#include ""src/core/lib/event_engine/grpc_polled_fd.h""+#include ""src/core/lib/event_engine/nameser.h""  // IWYU pragma: keep+#include ""src/core/lib/event_engine/tcp_socket_utils.h""+#include ""src/core/lib/event_engine/time_util.h""+#include ""src/core/lib/gprpp/debug_location.h""+#include ""src/core/lib/gprpp/examine_stack.h""+#include ""src/core/lib/gprpp/host_port.h""+#include ""src/core/lib/gprpp/ref_counted_ptr.h""+#include ""src/core/lib/gprpp/status_helper.h""+#include ""src/core/lib/iomgr/resolved_address.h""+#include ""src/core/lib/iomgr/sockaddr.h""+#ifdef GRPC_POSIX_SOCKET_ARES_EV_DRIVER+#include ""src/core/lib/event_engine/posix_engine/tcp_socket_utils.h""+#elif defined(GRPC_WINDOWS_SOCKET_ARES_EV_DRIVER)+#endif++namespace grpc_event_engine {+namespace experimental {++grpc_core::TraceFlag grpc_trace_ares_wrapper_address_sorting(+    false, ""ares_wrapper_address_sorting"");++grpc_core::TraceFlag grpc_trace_ares_wrapper_stacktrace(+    false, ""ares_wrapper_stacktrace"");++void PrintCurrentStackTrace() {",nit: may be helpful to log the request object pointer alongside the log.May also want to rename to `MaybePrintCurrentStackTrace`,
9566254,apolcyn,https://api.github.com/repos/grpc/grpc/pulls/32701,1210889070,2023-05-30T22:33:27Z,src/core/lib/event_engine/grpc_ares_wrapper.cc,"@@ -0,0 +1,1037 @@+// Copyright 2023 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++#include <grpc/support/port_platform.h>++#include ""src/core/lib/event_engine/grpc_ares_wrapper.h""++#include <iterator>++#include ""src/core/lib/iomgr/port.h""++// IWYU pragma: no_include <arpa/inet.h>+// IWYU pragma: no_include <arpa/nameser.h>+// IWYU pragma: no_include <inttypes.h>+// IWYU pragma: no_include <netdb.h>+// IWYU pragma: no_include <netinet/in.h>+// IWYU pragma: no_include <stdlib.h>+// IWYU pragma: no_include <sys/socket.h>+// IWYU pragma: no_include <ratio>++#if GRPC_ARES == 1++#include <string.h>++#include <algorithm>+#include <chrono>+#include <initializer_list>+#include <memory>+#include <type_traits>+#include <utility>++#include <address_sorting/address_sorting.h>++#include ""absl/strings/match.h""+#include ""absl/strings/numbers.h""+#include ""absl/strings/str_cat.h""+#include ""absl/strings/str_format.h""+#include ""absl/types/optional.h""++#include <grpc/event_engine/event_engine.h>+#include <grpc/support/alloc.h>+#include <grpc/support/log.h>++#include ""src/core/lib/address_utils/parse_address.h""+#include ""src/core/lib/address_utils/sockaddr_utils.h""+#include ""src/core/lib/event_engine/grpc_polled_fd.h""+#include ""src/core/lib/event_engine/nameser.h""  // IWYU pragma: keep+#include ""src/core/lib/event_engine/tcp_socket_utils.h""+#include ""src/core/lib/event_engine/time_util.h""+#include ""src/core/lib/gprpp/debug_location.h""+#include ""src/core/lib/gprpp/examine_stack.h""+#include ""src/core/lib/gprpp/host_port.h""+#include ""src/core/lib/gprpp/ref_counted_ptr.h""+#include ""src/core/lib/gprpp/status_helper.h""+#include ""src/core/lib/iomgr/resolved_address.h""+#include ""src/core/lib/iomgr/sockaddr.h""+#ifdef GRPC_POSIX_SOCKET_ARES_EV_DRIVER+#include ""src/core/lib/event_engine/posix_engine/tcp_socket_utils.h""+#elif defined(GRPC_WINDOWS_SOCKET_ARES_EV_DRIVER)+#endif++namespace grpc_event_engine {+namespace experimental {++grpc_core::TraceFlag grpc_trace_ares_wrapper_address_sorting(+    false, ""ares_wrapper_address_sorting"");++grpc_core::TraceFlag grpc_trace_ares_wrapper_stacktrace(+    false, ""ares_wrapper_stacktrace"");++void PrintCurrentStackTrace() {+  if (GRPC_TRACE_FLAG_ENABLED(grpc_trace_ares_wrapper_stacktrace)) {+    absl::optional<std::string> stacktrace = grpc_core::GetCurrentStackTrace();+    if (stacktrace.has_value()) {+      gpr_log(GPR_DEBUG, ""%s"", stacktrace->c_str());+    } else {+      gpr_log(GPR_DEBUG, ""stacktrace unavailable"");+    }+  }+}++grpc_core::TraceFlag grpc_trace_ares_wrapper(false,+                                             ""event_engine_ares_wrapper"");++namespace {++EventEngine::Duration calculate_next_ares_backup_poll_alarm_duration() {+  // An alternative here could be to use ares_timeout to try to be more+  // accurate, but that would require using ""struct timeval""'s, which just+  // makes things a bit more complicated. So just poll every second, as+  // suggested by the c-ares code comments.+  return std::chrono::seconds(1);+}++bool IsIpv6LoopbackAvailable() {+#ifdef GRPC_POSIX_SOCKET_ARES_EV_DRIVER+  return PosixSocketWrapper::IsIpv6LoopbackAvailable();+#elif defined(GRPC_WINDOWS_SOCKET_ARES_EV_DRIVER)+  // TODO(yijiem): make this portable for Windows+  return false;+#else+#error ""Unsupported platform""+#endif+}++struct HostbynameArg {+  GrpcAresHostnameRequest* request;+  const char* qtype;+};++absl::Status AresStatusToAbslStatus(int status, const std::string& error_msg) {+  switch (status) {+    case ARES_ECANCELLED:+      return absl::Status(absl::StatusCode::kCancelled, error_msg);+    case ARES_ENOTIMP:+      return absl::Status(absl::StatusCode::kUnimplemented, error_msg);+    case ARES_ENOTFOUND:+      return absl::Status(absl::StatusCode::kNotFound, error_msg);+    default:+      return absl::Status(absl::StatusCode::kUnknown, error_msg);+  }+}++}  // namespace++GrpcAresRequest::~GrpcAresRequest() {+  GPR_ASSERT(fd_node_list_.empty());+  if (initialized_) {+    ares_destroy(channel_);+  }+  GRPC_ARES_WRAPPER_TRACE_LOG(""request:%p destructor"", this);+}++bool GrpcAresRequest::Cancel() {+  grpc_core::MutexLock lock(&mu());+  if (std::exchange(shutting_down_, true)) {+    // Already shutting down, maybe resolved, cancelled or timed-out.+    return false;+  }+  cancelled_ = true;+  CancelTimers();+  ShutdownPolledFdsLocked(grpc_core::StatusCreate(+      absl::StatusCode::kCancelled, ""Cancel"", DEBUG_LOCATION, {}));+  return true;+}++GrpcAresRequest::GrpcAresRequest(+    absl::string_view name, EventEngine::Duration timeout,+    std::unique_ptr<GrpcPolledFdFactory> polled_fd_factory,+    EventEngine* event_engine)+    : grpc_core::InternallyRefCounted<GrpcAresRequest>(+          GRPC_TRACE_FLAG_ENABLED(grpc_trace_ares_wrapper) ? ""GrpcAresRequest""+                                                           : nullptr),+      name_(name),+      timeout_(timeout),+      polled_fd_factory_(std::move(polled_fd_factory)),+      event_engine_(event_engine) {}++void GrpcAresRequest::Work() {+  FdNodeList new_list;+  if (!shutting_down_) {+    ares_socket_t socks[ARES_GETSOCK_MAXNUM];+    int socks_bitmask = ares_getsock(channel_, socks, ARES_GETSOCK_MAXNUM);+    for (size_t i = 0; i < ARES_GETSOCK_MAXNUM; i++) {+      if (ARES_GETSOCK_READABLE(socks_bitmask, i) ||+          ARES_GETSOCK_WRITABLE(socks_bitmask, i)) {+        auto iter = std::find_if(+            fd_node_list_.begin(), fd_node_list_.end(),+            [sock = socks[i]](const auto& node) { return node->as == sock; });+        if (iter == std::end(fd_node_list_)) {+          new_list.emplace_back(new FdNode(+              socks[i], polled_fd_factory_->NewGrpcPolledFdLocked(socks[i])));+          GRPC_ARES_WRAPPER_TRACE_LOG(""request:%p new fd: %d"", this, socks[i]);+        } else {+          new_list.splice(new_list.end(), fd_node_list_, iter);+        }+        FdNode* fd_node = new_list.back().get();+        // Register read_closure if the socket is readable and read_closure+        // has not been registered with this socket.+        if (ARES_GETSOCK_READABLE(socks_bitmask, i) &&+            !fd_node->readable_registered) {+          GRPC_ARES_WRAPPER_TRACE_LOG(""request:%p notify read on: %d"", this,+                                      fd_node->as);+          fd_node->readable_registered = true;+          fd_node->polled_fd->RegisterForOnReadableLocked(+              [self = Ref(DEBUG_LOCATION, ""Work""),+               fd_node](absl::Status status) mutable {+                self->OnReadable(fd_node, status);+              });+        }+        // Register write_closure if the socket is writable and write_closure+        // has not been registered with this socket.+        if (ARES_GETSOCK_WRITABLE(socks_bitmask, i) &&+            !fd_node->writable_registered) {+          GRPC_ARES_WRAPPER_TRACE_LOG(""request:%p notify write on: %d"", this,+                                      fd_node->as);+          fd_node->writable_registered = true;+          fd_node->polled_fd->RegisterForOnWriteableLocked(+              [self = Ref(DEBUG_LOCATION, ""Work""),+               fd_node](absl::Status status) mutable {+                self->OnWritable(fd_node, status);+              });+        }+      }+    }+  }+  // Any remaining fds in fd_node_list_ were not returned by ares_getsock()+  // and are therefore no longer in use, so they can be shut down and removed+  // from the list.+  while (!fd_node_list_.empty()) {+    FdNode* fd_node = fd_node_list_.front().get();+    if (!fd_node->already_shutdown) {+      GRPC_ARES_WRAPPER_TRACE_LOG(""request: %p shutdown fd: %s"", this,+                                  fd_node->polled_fd->GetName());+      fd_node->polled_fd->ShutdownLocked(absl::OkStatus());+      fd_node->already_shutdown = true;+    }+    if (!fd_node->readable_registered && !fd_node->writable_registered) {+      GRPC_ARES_WRAPPER_TRACE_LOG(""request: %p delete fd: %s"", this,+                                  fd_node->polled_fd->GetName());+      fd_node_list_.pop_front();+    } else {+      new_list.splice(new_list.end(), fd_node_list_, fd_node_list_.begin());+    }+  }+  fd_node_list_ = std::move(new_list);+}++void GrpcAresRequest::StartTimers() {+  // Initialize overall DNS resolution timeout alarm+  EventEngine::Duration timeout =+      timeout_.count() == 0 ? EventEngine::Duration::max() : timeout_;+  GRPC_ARES_WRAPPER_TRACE_LOG(""request:%p StartTimers timeout in %zu ms"", this,+                              Milliseconds(timeout));++  query_timeout_handle_ = event_engine_->RunAfter(+      timeout,+      [self = Ref(DEBUG_LOCATION, ""StartTimers"")] { self->OnQueryTimeout(); });++  // Initialize the backup poll alarm+  EventEngine::Duration next_ares_backup_poll_alarm_duration =+      calculate_next_ares_backup_poll_alarm_duration();+  GRPC_ARES_WRAPPER_TRACE_LOG(+      ""request:%p StartTimers next ares process poll time in %zu ms"", this,+      Milliseconds(next_ares_backup_poll_alarm_duration));++  ares_backup_poll_alarm_handle_ =+      event_engine_->RunAfter(next_ares_backup_poll_alarm_duration,+                              [self = Ref(DEBUG_LOCATION, ""StartTimers"")]() {+                                self->OnAresBackupPollAlarm();+                              });+}++void GrpcAresRequest::CancelTimers() {+  if (query_timeout_handle_.has_value()) {+    event_engine_->Cancel(*query_timeout_handle_);+    query_timeout_handle_.reset();+  }+  if (ares_backup_poll_alarm_handle_.has_value()) {+    event_engine_->Cancel(*ares_backup_poll_alarm_handle_);+    ares_backup_poll_alarm_handle_.reset();+  }+}++absl::StatusOr<std::string> GrpcAresRequest::ParseNameToResolve()+    ABSL_NO_THREAD_SAFETY_ANALYSIS {+  GPR_DEBUG_ASSERT(!initialized_);+  std::string port;+  // parse name, splitting it into host and port parts+  grpc_core::SplitHostPort(name_, &host_, &port);+  absl::Status error;+  if (host_.empty()) {+    return absl::Status(absl::StatusCode::kInvalidArgument,+                        absl::StrCat(""Unparseable name: "", name_));+  }+  return port;+}++absl::Status GrpcAresRequest::InitializeAresOptions(+    absl::string_view dns_server) ABSL_NO_THREAD_SAFETY_ANALYSIS {+  GPR_DEBUG_ASSERT(!initialized_);+  ares_options opts = {};+  opts.flags |= ARES_FLAG_STAYOPEN;+  int status = ares_init_options(&channel_, &opts, ARES_OPT_FLAGS);+  if (status != ARES_SUCCESS) {+    gpr_log(GPR_ERROR, ""ares_init_options failed, status: %d"", status);+    return AresStatusToAbslStatus(+        status, absl::StrCat(""Failed to init ares channel. c-ares error: "",+                             ares_strerror(status)));+  }+  event_engine_grpc_ares_test_only_inject_config(channel_);+  // If dns_server is specified, use it.+  absl::Status error = SetRequestDNSServer(dns_server);+  if (!error.ok()) {+    ares_destroy(channel_);+    return error;+  }+  initialized_ = true;+  return absl::OkStatus();+}++absl::Status GrpcAresRequest::SetRequestDNSServer(+    absl::string_view dns_server) {+  if (!dns_server.empty()) {+    GRPC_ARES_WRAPPER_TRACE_LOG(""request:%p Using DNS server %s"", this,+                                dns_server.data());+    grpc_resolved_address addr;+    struct ares_addr_port_node dns_server_addr;+    if (grpc_parse_ipv4_hostport(dns_server, &addr, /*log_errors=*/false)) {+      dns_server_addr.family = AF_INET;+      struct sockaddr_in* in = reinterpret_cast<struct sockaddr_in*>(addr.addr);+      memcpy(&dns_server_addr.addr.addr4, &in->sin_addr,+             sizeof(struct in_addr));+      dns_server_addr.tcp_port = grpc_sockaddr_get_port(&addr);+      dns_server_addr.udp_port = grpc_sockaddr_get_port(&addr);+    } else if (grpc_parse_ipv6_hostport(dns_server, &addr,+                                        /*log_errors=*/false)) {+      dns_server_addr.family = AF_INET6;+      struct sockaddr_in6* in6 =+          reinterpret_cast<struct sockaddr_in6*>(addr.addr);+      memcpy(&dns_server_addr.addr.addr6, &in6->sin6_addr,+             sizeof(struct in6_addr));+      dns_server_addr.tcp_port = grpc_sockaddr_get_port(&addr);+      dns_server_addr.udp_port = grpc_sockaddr_get_port(&addr);+    } else {+      return absl::Status(absl::StatusCode::kInvalidArgument,+                          absl::StrCat(""Cannot parse authority: "", dns_server));+    }+    // Prevent an uninitialized variable.+    dns_server_addr.next = nullptr;+    int status = ares_set_servers_ports(channel_, &dns_server_addr);+    if (status != ARES_SUCCESS) {+      return AresStatusToAbslStatus(+          status, absl::StrCat(""c-ares status is not ARES_SUCCESS: "",+                               ares_strerror(status)));+    }+  }+  return absl::OkStatus();+}++void GrpcAresRequest::OnReadable(FdNode* fd_node, absl::Status status) {+  mu().Lock();+  GPR_ASSERT(fd_node->readable_registered);+  fd_node->readable_registered = false;+  GRPC_ARES_WRAPPER_TRACE_LOG(""OnReadable: fd: %d; request: %p; status: %s"",+                              fd_node->as, this, status.ToString().c_str());+  PrintCurrentStackTrace();+  if (status.ok() && !shutting_down_) {+    do {+      ares_process_fd(channel_, fd_node->as, ARES_SOCKET_BAD);+    } while (fd_node->polled_fd->IsFdStillReadableLocked());","Although we haven't seen it in practice to my knowledge, I think that there is a potential bug here where c-ares could become no longer interested in this fd, without necessarily reading all of the data off of it - in which case we'd have a busy loop. At the very least, I don't think c-ares provides any guarantees that it will read all of the data off an fd before become uninterested.So this loop should probably continue only while `ARES_GETSOCK_READABLE` returns `true` for this socket.Note this would be a pre-existing (potential) problem with the current implementation.",
1644595,gnossen,https://api.github.com/repos/grpc/grpc/pulls/32974,1210901176,2023-05-30T22:51:11Z,src/python/grpcio_observability/grpc_observability/observability_util.cc,"@@ -0,0 +1,225 @@+// Copyright 2023 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++#include ""src/python/grpcio_observability/grpc_observability/observability_util.h""++#include <constants.h>+#include <python_census_context.h>++#include <chrono>+#include <cstdlib>+#include <map>+#include <string>++#include ""absl/status/statusor.h""+#include ""absl/strings/string_view.h""+#include ""absl/types/optional.h""++#include <grpc/support/log.h>++#include ""src/cpp/ext/gcp/observability_config.h""+#include ""src/python/grpcio_observability/grpc_observability/client_call_tracer.h""+#include ""src/python/grpcio_observability/grpc_observability/server_call_tracer.h""++namespace grpc_observability {++std::queue<CensusData>* g_census_data_buffer;+std::mutex g_census_data_buffer_mutex;+std::condition_variable g_census_data_buffer_cv;+// TODO(xuanwn): Change below to a more appropriate number.+// Assume buffer will store 100 CensusData and start export when buffer is 50%+// full. kMaxExportBufferSizeBytes = 100 * (2048(kMaxTagsLen) + 1024(Buffer))+constexpr float kExportThreshold = 0.7;+constexpr int kMaxExportBufferSizeBytes = 100 * 1024 * 3;++namespace {++float GetExportThreadHold() {+  const char* value = std::getenv(""GRPC_PYTHON_CENSUS_EXPORT_THRESHOLD"");+  if (value != nullptr) {+    return std::stof(value);+  }+  return kExportThreshold;+}++int GetMaxExportBufferSize() {+  const char* value =+      std::getenv(""GRPC_PYTHON_CENSUS_MAX_EXPORT_BUFFER_SIZE_BYTES"");","> Do we need count the current size of CensusData? My understanding is we just need a reasonable maximum size for the buffer.Right. We don't actually need to calculate the byte footprint. Just limiting the number of `CensusData` instances should be enough.Also, let's pump this up to 10000 as the default starting number. That should be on the order of megabytes. If we go too low, then we'll probably start silently dropping a lot of data when the client starts going at speed.",
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/32701,1210972324,2023-05-31T00:49:30Z,src/core/lib/event_engine/grpc_ares_wrapper.h,"@@ -0,0 +1,340 @@+// Copyright 2023 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+#ifndef GRPC_SRC_CORE_LIB_EVENT_ENGINE_GRPC_ARES_WRAPPER_H+#define GRPC_SRC_CORE_LIB_EVENT_ENGINE_GRPC_ARES_WRAPPER_H++#include <grpc/support/port_platform.h>++#if GRPC_ARES == 1++#include <stddef.h>++#include <algorithm>+#include <memory>+#include <string>+#include <vector>++#include <ares.h>++#include ""absl/base/thread_annotations.h""+#include ""absl/functional/any_invocable.h""+#include ""absl/status/status.h""+#include ""absl/status/statusor.h""+#include ""absl/strings/string_view.h""+#include ""absl/types/optional.h""++#include <grpc/event_engine/event_engine.h>+#include <grpc/support/log.h>++#include ""src/core/lib/debug/trace.h""+#include ""src/core/lib/event_engine/grpc_polled_fd.h""+#include ""src/core/lib/gprpp/orphanable.h""+#include ""src/core/lib/gprpp/sync.h""++namespace grpc_event_engine {+namespace experimental {++extern grpc_core::TraceFlag grpc_trace_ares_wrapper;++#define GRPC_ARES_WRAPPER_TRACE_LOG(format, ...)                              \+  do {                                                                        \+    if (GRPC_TRACE_FLAG_ENABLED(grpc_trace_ares_wrapper)) {                   \+      gpr_log(GPR_INFO, ""(EventEngine c-ares wrapper) "" format, __VA_ARGS__); \+    }                                                                         \+  } while (0)++// Base class for the c-ares based DNS lookup functionality. This class is+// inherited by the concrete leaf classes below which each represents a+// different type of lookup (i.e. A/AAAA, SRV, TXT). One request object+// represents one lookup request for a specific name. GrpcAresRequest+// encapsulates the common logics to initialize and destroy the c-ares channel+// (one channel for one request). Sets the name servers configuration for the","> What if we moved both cancellation and timeouts to the DNSResolver object, rather than doing them on the individual requests?@markdroth You mean something like `DNSResolver::CancelAll()`? That sounds probably right from a client channel resolver perspective, but less-right from a generic resolver API perspective. If users want independent requests, they'd have to make a new DNSResolver for each request. It would be an awkward API, but usable. The bigger issue is that cancellation gets pretty weird if some subset of requests are not in a cancellable state, but others are - some client callbacks will be run but not others, and the caller would need to know what to expect based on whatever `CancelAll` returns.> Don't take this optimization and live with the overhead of separate c-ares channels per request.I think I agree with @apolcyn here, and would hope that an extra couple of `fd`s consumed while resolving TXT records would be tolerable.> And we could probably live with expressing timeouts at the DNSResolver level as well.This may be a moot point, but having a single timeout for multiple requests, all started at different times, could have a few interpretations. Does each request time out independently, or would the timeout apply as soon as the first request is sent? Alternatively, the creation of a DNSResolver could mean configuring a batch of requests, then starting them all at once. But again, I think this harms the API to serve a specific internal use case.> I believe that the entire reason that we designed the EE API to put the DNS methods into a DNSResolver object was to share this kind of state.If we don't share state, then we _could_ move the DNS lookup methods into the Engine API itself. But I still think having a separate object is nice for organization and design purposes, single-responsibility principle in particular.",
24593237,XuanWang-Amos,https://api.github.com/repos/grpc/grpc/pulls/32974,1212015031,2023-05-31T16:46:09Z,src/python/grpcio_observability/grpc_observability/_observability.py,"@@ -94,12 +95,10 @@ def __init__(self, exporter: ""grpc_observability.Exporter"" = None):         if exporter:             self.exporter = exporter         else:-            pass-            # Actual implementation of OC exporter-            # open_census = importlib.import_module(-            #     ""grpc_observability._open_census"")-            # self.exporter = open_census.OpenCensusExporter(-            #     self.config.get().labels)+            open_census = importlib.import_module(","I refactored it in a different way: I moved `GcpObservabilityPythonConfig` and `GCPOpenCensusObservability` to a new file called `_gcp_observability.py` since they're only related to GCP O11y.I also removed most of the classes from `__init__.py` since we decide that most of them are semi-private. Now, the only thing we have in `__init__.py` is `GCPOpenCensusObservability`, which was supposed to be the only public class.",X
5663878,yijiem,https://api.github.com/repos/grpc/grpc/pulls/32701,1212224290,2023-05-31T19:38:36Z,src/core/lib/event_engine/grpc_ares_wrapper.h,"@@ -0,0 +1,340 @@+// Copyright 2023 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+#ifndef GRPC_SRC_CORE_LIB_EVENT_ENGINE_GRPC_ARES_WRAPPER_H+#define GRPC_SRC_CORE_LIB_EVENT_ENGINE_GRPC_ARES_WRAPPER_H++#include <grpc/support/port_platform.h>++#if GRPC_ARES == 1++#include <stddef.h>++#include <algorithm>+#include <memory>+#include <string>+#include <vector>++#include <ares.h>++#include ""absl/base/thread_annotations.h""+#include ""absl/functional/any_invocable.h""+#include ""absl/status/status.h""+#include ""absl/status/statusor.h""+#include ""absl/strings/string_view.h""+#include ""absl/types/optional.h""++#include <grpc/event_engine/event_engine.h>+#include <grpc/support/log.h>++#include ""src/core/lib/debug/trace.h""+#include ""src/core/lib/event_engine/grpc_polled_fd.h""+#include ""src/core/lib/gprpp/orphanable.h""+#include ""src/core/lib/gprpp/sync.h""++namespace grpc_event_engine {+namespace experimental {++extern grpc_core::TraceFlag grpc_trace_ares_wrapper;++#define GRPC_ARES_WRAPPER_TRACE_LOG(format, ...)                              \+  do {                                                                        \+    if (GRPC_TRACE_FLAG_ENABLED(grpc_trace_ares_wrapper)) {                   \+      gpr_log(GPR_INFO, ""(EventEngine c-ares wrapper) "" format, __VA_ARGS__); \+    }                                                                         \+  } while (0)++// Base class for the c-ares based DNS lookup functionality. This class is+// inherited by the concrete leaf classes below which each represents a+// different type of lookup (i.e. A/AAAA, SRV, TXT). One request object+// represents one lookup request for a specific name. GrpcAresRequest+// encapsulates the common logics to initialize and destroy the c-ares channel+// (one channel for one request). Sets the name servers configuration for the+// channel. And interacts with c-ares sockets/fds and the EventEngine poller. It+// also encapsulates logics to start and cancel timers.+class GrpcAresRequest+    : public grpc_core::InternallyRefCounted<GrpcAresRequest> {+ public:+  ~GrpcAresRequest() override;++  // Cancels an inflight request. Returns true if cancel succeeds and will start+  // the shutdown process. Returns false if the request is already finishing,+  // cancelled or shutdown.+  bool Cancel() ABSL_LOCKS_EXCLUDED(mu_);+  void Orphan() override {}++ protected:+  GrpcAresRequest(absl::string_view name, EventEngine::Duration timeout,+                  std::unique_ptr<GrpcPolledFdFactory> polled_fd_factory,+                  EventEngine* event_engine);++  // The workhorse function. Gets the live sockets/fds used by c-ares, creates+  // FdNode if it is not currently tracked in fd_node_list_. Registers the+  // socket with the poller for read and/or write based on c-ares's demand. And+  // shutdown and destroys the poller handles whose sockets are no longer in use+  // by c-ares.+  // This function is called in every opportunities when there might be a change+  // to c-ares' sockets for the channel.+  void Work() ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu_);+  // Common logic to start the query timeout timer and the ares backup poll+  // timer. This is only called in each leaf class' Start method.+  void StartTimers() ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu_);+  // Common logic to cancel the query timeout timer and the ares backup poll+  // timer. This is called when the request is cancelled or shutting down.+  void CancelTimers() ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu_);+  // These 2 methods are deliberately thread-unsafe and should only be called in+  // the factory methods of the leaf classes as part of initialization.+  absl::StatusOr<std::string> ParseNameToResolve();+  absl::Status InitializeAresOptions(absl::string_view dns_server);++  grpc_core::Mutex mu_;","Sure, ""has-a"" could work, but there are a few issues as well. Currently the primary states sharing between the base class (`GrpcAresRequest`) and the child classes (`GrpcAres<Type>Request`s) are:1. Refcounting2. Mutex3. OnResolve callback through override a pure virtual member function.4. ares_channel5. A few signals, e.g. `cancelled_`, `shutting_down_`.To modify those into a ""has-a"" model, i.e. `GrpcAres<Type>Request` has a `GrpcAresRequestCommon` object which encapsulates the shared functionalities, these changes may be necessary:1. Refcounting: this might be an awkward one. One of the shared functionalities is to pass an OnReadable or OnWritable closure to a poller handle, the closure needs to take a refcount of the `GrpcAres<Type>Request`. So if we don't share refcounting through inheritance, we could maybe pass a raw pointer of `GrpcAres<Type>Request` to `GrpcAresRequestCommon` and it would then invoke `request_->Ref()` and embed the `RefCountedPtr` in the closure. However, this might mean that we need a common interface for all `GrpcAres<Type>Request`s, since `GrpcAresRequestCommon` does not work with any specific `GrpcAres<Type>Request` type. This might also mean that we need to use multiple inheritance for `GrpcAres<Type>Request`s, one for `InternallyRefCounted<>` and one for that interface. Multiple inheritance is also discouraged by the style guide.2. Mutex: because of the asynchronous nature of many of the shared functionalities, i.e. poller callback and timer callback, the mutex has to be shared in some way between `GrpcAresRequestCommon` and  `GrpcAres<Type>Request`. I could think of to pass a pointer to the `mutex_` member of `GrpcAres<Type>Request` to `GrpcAresRequestCommon`. Note that the Thread Safety Analysis might not behave as expected since it does not support alias analysis: https://clang.llvm.org/docs/ThreadSafetyAnalysis.html#no-alias-analysis.3. OnResolve callback: this could work through passing a raw pointer of `GrpcAres<Type>Request` to `GrpcAresRequestCommon`. Again it would need a common interface for all `GrpcAres<Type>Request`s.4. ares_channel: I believe this can live in `GrpcAresRequestCommon` with a getter method.5. Signals: `cancelled_` or `shutting_down_`: `cancelled_` could live in `GrpcAresRequestCommon` with a getter method. `shutting_down_` could also live in `GrpcAresRequestCommon` but `GrpcAres<Type>Request`s might also need to set it in its static member function. So `GrpcAresRequestCommon` might have a public setter and `GrpcAres<Type>Request`s might have a private setter which will invoke the public setter.For the point 1 about Refcounting, there might be another approach to only make `GrpcAresRequestCommon` InternallyRefCounted, but that may come with its own complexity.Honestly, if we really don't like the implementation inheritance, we could also try to extract some of the functionalities in `GrpcAresRequest` into free functions, e.g. initialize an ares_channel, set dns server, process fd_node_list. There will be some code duplications, e.g. timers, OnReadable OnWritable callbacks, but won't be a lot. And we can avoid the complexities with either implementation inheritance or composition. There might be a small interface inheritance for `Cancel` and `Orphan` methods exposing to the EE DNSResolver.",X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32701,1212415275,2023-05-31T23:33:39Z,src/core/lib/event_engine/grpc_ares_wrapper.h,"@@ -0,0 +1,340 @@+// Copyright 2023 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+#ifndef GRPC_SRC_CORE_LIB_EVENT_ENGINE_GRPC_ARES_WRAPPER_H+#define GRPC_SRC_CORE_LIB_EVENT_ENGINE_GRPC_ARES_WRAPPER_H++#include <grpc/support/port_platform.h>++#if GRPC_ARES == 1++#include <stddef.h>++#include <algorithm>+#include <memory>+#include <string>+#include <vector>++#include <ares.h>++#include ""absl/base/thread_annotations.h""+#include ""absl/functional/any_invocable.h""+#include ""absl/status/status.h""+#include ""absl/status/statusor.h""+#include ""absl/strings/string_view.h""+#include ""absl/types/optional.h""++#include <grpc/event_engine/event_engine.h>+#include <grpc/support/log.h>++#include ""src/core/lib/debug/trace.h""+#include ""src/core/lib/event_engine/grpc_polled_fd.h""+#include ""src/core/lib/gprpp/orphanable.h""+#include ""src/core/lib/gprpp/sync.h""++namespace grpc_event_engine {+namespace experimental {++extern grpc_core::TraceFlag grpc_trace_ares_wrapper;++#define GRPC_ARES_WRAPPER_TRACE_LOG(format, ...)                              \+  do {                                                                        \+    if (GRPC_TRACE_FLAG_ENABLED(grpc_trace_ares_wrapper)) {                   \+      gpr_log(GPR_INFO, ""(EventEngine c-ares wrapper) "" format, __VA_ARGS__); \+    }                                                                         \+  } while (0)++// Base class for the c-ares based DNS lookup functionality. This class is+// inherited by the concrete leaf classes below which each represents a+// different type of lookup (i.e. A/AAAA, SRV, TXT). One request object+// represents one lookup request for a specific name. GrpcAresRequest+// encapsulates the common logics to initialize and destroy the c-ares channel+// (one channel for one request). Sets the name servers configuration for the","> @markdroth You mean something like `DNSResolver::CancelAll()`? That sounds probably right from a client channel resolver perspective, but less-right from a generic resolver API perspective. If users want independent requests, they'd have to make a new DNSResolver for each request. It would be an awkward API, but usable. Do we actually have any such use-cases?  I'm not aware of any.> The bigger issue is that cancellation gets pretty weird if some subset of requests are not in a cancellable state, but others are - some client callbacks will be run but not others, and the caller would need to know what to expect based on whatever `CancelAll` returns.That's a really good point.  If we can't come up with a reasonable cancellation semantic here, then this may be a good reason to stick with the current approach.  But let's make sure we don't have a way to do this first.Question: How much does the result of cancellation matter for DNS query use-cases?  How much of our existing code that does a DNS query cares whether cancellation succeeded?  If all the callers are just storing a ref in the callback lambda and don't need any other sort of clean up, then maybe this isn't much of a problem; `CancelAll()` could just return `void`.Alternatively, maybe the semantic for the DNS callbacks should be that the callbacks are always run, even upon cancellation?  I think the callbacks mostly take `StatusOr<>` parameters, right?  IIRC, we discarded this option for timer and async-execution callbacks for performance reasons, but I don't think that's a concern for the DNS API.  Although making the behavior here inconsistent would admittedly make the API a bit more confusing.> I think I agree with @apolcyn here, and would hope that an extra couple of `fd`s consumed while resolving TXT records would be tolerable.I'm not really concerned about the duplicate fds.  I'm more concerned about the code structure.> This may be a moot point, but having a single timeout for multiple requests, all started at different times, could have a few interpretations. Does each request time out independently, or would the timeout apply as soon as the first request is sent? Alternatively, the creation of a DNSResolver could mean configuring a batch of requests, then starting them all at once. You're right about the timeout semantic being a bit weird here.  I don't think it's an issue for the initial A/AAAA, TXT, and SRV lookups, since they're all effectively started at the same time.  But it would be a bit strange for the additional A/AAAA lookups we do after the SRV lookup returns.Maybe we could do something like have a fixed timeout but have the timeout period reset relative to the time the most recent query was started.> But again, I think this harms the API to serve a specific internal use case.This API is actually designed specifically for our use-cases, so I don't consider that part a problem.> If we don't share state, then we _could_ move the DNS lookup methods into the Engine API itself. But I still think having a separate object is nice for organization and design purposes, single-responsibility principle in particular.If we're doing it only for organizational purposes, then the `DNSResolver` object should basically be stateless.  It seems very inconsistent to me to configure the DNS servers at that level but nothing else.  If we actually have the ability to configure the DNS servers for each query, why aren't we doing it that way?As per my comment here, I actually think we should be going the opposite way, moving more state *into* the `DNSResolver` object.  But ultimately, I think that we need to have clearly articulated criteria for what state goes in the `DNSResolver` object and what state goes in the individual queries.",X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32701,1212439067,2023-06-01T00:19:33Z,src/core/lib/event_engine/grpc_ares_wrapper.h,"@@ -0,0 +1,340 @@+// Copyright 2023 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+#ifndef GRPC_SRC_CORE_LIB_EVENT_ENGINE_GRPC_ARES_WRAPPER_H+#define GRPC_SRC_CORE_LIB_EVENT_ENGINE_GRPC_ARES_WRAPPER_H++#include <grpc/support/port_platform.h>++#if GRPC_ARES == 1++#include <stddef.h>++#include <algorithm>+#include <memory>+#include <string>+#include <vector>++#include <ares.h>++#include ""absl/base/thread_annotations.h""+#include ""absl/functional/any_invocable.h""+#include ""absl/status/status.h""+#include ""absl/status/statusor.h""+#include ""absl/strings/string_view.h""+#include ""absl/types/optional.h""++#include <grpc/event_engine/event_engine.h>+#include <grpc/support/log.h>++#include ""src/core/lib/debug/trace.h""+#include ""src/core/lib/event_engine/grpc_polled_fd.h""+#include ""src/core/lib/gprpp/orphanable.h""+#include ""src/core/lib/gprpp/sync.h""++namespace grpc_event_engine {+namespace experimental {++extern grpc_core::TraceFlag grpc_trace_ares_wrapper;++#define GRPC_ARES_WRAPPER_TRACE_LOG(format, ...)                              \+  do {                                                                        \+    if (GRPC_TRACE_FLAG_ENABLED(grpc_trace_ares_wrapper)) {                   \+      gpr_log(GPR_INFO, ""(EventEngine c-ares wrapper) "" format, __VA_ARGS__); \+    }                                                                         \+  } while (0)++// Base class for the c-ares based DNS lookup functionality. This class is+// inherited by the concrete leaf classes below which each represents a+// different type of lookup (i.e. A/AAAA, SRV, TXT). One request object+// represents one lookup request for a specific name. GrpcAresRequest+// encapsulates the common logics to initialize and destroy the c-ares channel+// (one channel for one request). Sets the name servers configuration for the+// channel. And interacts with c-ares sockets/fds and the EventEngine poller. It+// also encapsulates logics to start and cancel timers.+class GrpcAresRequest+    : public grpc_core::InternallyRefCounted<GrpcAresRequest> {+ public:+  ~GrpcAresRequest() override;++  // Cancels an inflight request. Returns true if cancel succeeds and will start+  // the shutdown process. Returns false if the request is already finishing,+  // cancelled or shutdown.+  bool Cancel() ABSL_LOCKS_EXCLUDED(mu_);+  void Orphan() override {}++ protected:+  GrpcAresRequest(absl::string_view name, EventEngine::Duration timeout,+                  std::unique_ptr<GrpcPolledFdFactory> polled_fd_factory,+                  EventEngine* event_engine);++  // The workhorse function. Gets the live sockets/fds used by c-ares, creates+  // FdNode if it is not currently tracked in fd_node_list_. Registers the+  // socket with the poller for read and/or write based on c-ares's demand. And+  // shutdown and destroys the poller handles whose sockets are no longer in use+  // by c-ares.+  // This function is called in every opportunities when there might be a change+  // to c-ares' sockets for the channel.+  void Work() ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu_);+  // Common logic to start the query timeout timer and the ares backup poll+  // timer. This is only called in each leaf class' Start method.+  void StartTimers() ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu_);+  // Common logic to cancel the query timeout timer and the ares backup poll+  // timer. This is called when the request is cancelled or shutting down.+  void CancelTimers() ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu_);+  // These 2 methods are deliberately thread-unsafe and should only be called in+  // the factory methods of the leaf classes as part of initialization.+  absl::StatusOr<std::string> ParseNameToResolve();+  absl::Status InitializeAresOptions(absl::string_view dns_server);++  grpc_core::Mutex mu_;","Let's take a step back.  I think the overall problem here is that we were supposed to be writing new code, and instead it looks like we've basically copied the existing horrible code and just made a few small tweaks to it.  The existing code has evolved over a long period of time, through many authors, and has never had a clear architecture imposed on it.  It is a rat's nest of implicit dependencies, complex and undocumented interactions between base class and subclasses, and tons of shared state.  No one can possibly understand this, and I think we need to do better.  The more we talk about this, the less happy I am with it.What I want to see here is an architecture where there are clearly defined components, each with obvious and well documented responsibility and scope, and each providing a no-larger-than-absolutely-necessary API surface that makes it obvious how to use it.  The goal here is to make it easy for readers to understand which objects are responsible for what and how they interact with each other.  We need this code to be maintainable enough that members of the team can work with it without having to first spend days trying to understand the code.I do not want to see any code where we are sharing a mutex between a base class and subclasses.  That sort of pattern is a horrible code smell; it can sometimes be necessary in performance-sensitive code, but this code does not fall into that category, so there's no justification for it here.I do not want to see so much shared state between the base class and subclasses.  The style gude specifically recommends [against overusing implementation inheritence](https://google.github.io/styleguide/cppguide.html#Inheritance), and I think this code is a great example of why it says that.I think we should step back and try to design a cleaner way of structuring this.  Here's one possible approach:1. A polling object, which deals with all of the interaction with the EventEngine polling code, the fds, etc.   - The API exposed by this object should allow the caller to start a particular c-ares query (e.g., an A/AAAA query, a TXT query, or an SRV query) and specify a callback to be invoked with the result of that query.  Note that this callback should be in a form that does not care what type of object it is calling back into.   - The OnReadable and OnWritable callbacks should be purely internal to this object.  Every time one of those callbacks is invoked, we should do the appropriate reading and writing.  When we determine that a request is complete, we invoke the on-complete callback for that request.   - As per the other comment thread, this object might be the top-level `DNSResolver` object itself.  Or, if we elect to keep this state separate for each individual query, then it should be a separate object that we create for each query.2. The query type objects, each of which represents a query of a particular type (A/AAAA, TXT, or SRV).   - If the polling object is actually the `DNSResolver` object, then each of these higher-level objects will hold a ref to the `DNSResolver`; otherwise, each of these higher-level objects should create its own instance of the polling object.   - The query-type objects should tell the polling object what type of c-ares query to start and provide an on-complete callback to be invoked by the polling object when the query is complete.   - The query-type objects will be responsible for tracking the task handles and dealing with cancellation.  If we continue to do cancellation on a per-query basis, then when a query-type object is cancelled, it can propagate that cancellation to its polling object.   - The on-complete callback will be responsible for doing query-type-specific response parsing and invoking the on-complete callback provided by the caller of the EE API.I think in this approach, there is no need for any inheritence or any mutex sharing, and the interface between the polling code and the query-type objects is a very small, well-defined, easy-to-understand interface.Why can't something like this work?",X
287917,eugeneo,https://api.github.com/repos/grpc/grpc/pulls/32973,1213435074,2023-06-01T16:54:42Z,src/core/ext/filters/client_channel/resolver/xds/xds_resolver.cc,"@@ -199,6 +199,89 @@ class XdsResolver : public Resolver {     RefCountedPtr<XdsResolver> resolver_;   }; +  // An entry in the map of clusters that need to be present in the LB+  // policy config.  The map holds a weak ref.  One strong ref is held by+  // the ConfigSelector, and another is held by each call assigned to+  // the cluster by the ConfigSelector.  The ref for each call is held+  // until the call is committed.  When the strong refs go away, we hop+  // back into the WorkSerializer to remove the entry from the map.+  class ClusterRef : public DualRefCounted<ClusterRef> {+   public:+    ClusterRef(RefCountedPtr<XdsResolver> resolver,+               absl::string_view cluster_name)+        : resolver_(std::move(resolver)), cluster_name_(cluster_name) {}++    void Orphan() override {+      resolver_->work_serializer_->Run(+          [resolver = std::move(resolver_)]() mutable {+            static_cast<XdsResolver*>(resolver.get())",At some point it refused to compile  Now it works.,
5564114,Vignesh2208,https://api.github.com/repos/grpc/grpc/pulls/33223,1213452598,2023-06-01T17:12:50Z,test/core/event_engine/thread_pool_test.cc,"@@ -221,6 +221,22 @@ TEST_F(WorkStealingThreadPoolTest,   p.Quiesce(); } +// TODO(hork): This is currently a pathological case for the original thread+// pool, it takes around 50s to run. When that is fixed, or the implementation+// is deleted, make this a typed test again.+TEST_F(WorkStealingThreadPoolTest, QuiesceRaceStressTest) {",Why does this take a long time to run ?,
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/33223,1213455435,2023-06-01T17:15:48Z,src/core/lib/event_engine/thread_pool/work_stealing_thread_pool.cc,"@@ -425,36 +456,57 @@ void WorkStealingThreadPool::ThreadState::FinishDraining() { // -------- WorkStealingThreadPool::ThreadCount --------  void WorkStealingThreadPool::ThreadCount::Add(CounterType counter_type) {-  thread_counts_[counter_type].fetch_add(1, std::memory_order_relaxed);+  grpc_core::MutexLock lock(&wait_mu_[counter_type]);+  ++thread_counts_[counter_type];+  wait_cv_[counter_type].SignalAll(); }  void WorkStealingThreadPool::ThreadCount::Remove(CounterType counter_type) {-  thread_counts_[counter_type].fetch_sub(1, std::memory_order_relaxed);+  grpc_core::MutexLock lock(&wait_mu_[counter_type]);+  --thread_counts_[counter_type];+  wait_cv_[counter_type].SignalAll(); }  void WorkStealingThreadPool::ThreadCount::BlockUntilThreadCount(-    CounterType counter_type, int desired_threads, const char* why,+    CounterType counter_type, size_t desired_threads, const char* why,     WorkSignal* work_signal) {-  auto& counter = thread_counts_[counter_type];-  int curr_threads = counter.load(std::memory_order_relaxed);   // Wait for all threads to exit.-  auto last_log_time = grpc_core::Timestamp::Now();-  while (curr_threads > desired_threads) {-    absl::SleepFor(kSleepBetweenQuiesceCheck);+  while (true) {+    auto curr_threads = WaitForCountChange(+        counter_type, desired_threads,+        grpc_core::Duration::Seconds(kBlockingQuiesceLogRateSeconds));+    if (curr_threads == desired_threads) break;+    GRPC_LOG_EVERY_N_SEC_DELAYED(+        kBlockingQuiesceLogRateSeconds, GPR_DEBUG,+        ""Waiting for thread pool to idle before %s. (%"" PRIdPTR "" to %"" PRIdPTR+        "")"",+        why, curr_threads, desired_threads);     work_signal->SignalAll();","Good question. `BlockUntilThreadCount` is currently either waiting for:* 0 threads, in which case nothing is listening on the work_signal when the desired thread count is reached, or* 1 thread, because this thread is running `BlockUntilThreadCount`, and not waiting on the work_signal either.",
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/33223,1213475931,2023-06-01T17:34:45Z,test/core/event_engine/thread_pool_test.cc,"@@ -221,6 +221,22 @@ TEST_F(WorkStealingThreadPoolTest,   p.Quiesce(); } +// TODO(hork): This is currently a pathological case for the original thread+// pool, it takes around 50s to run. When that is fixed, or the implementation+// is deleted, make this a typed test again.+TEST_F(WorkStealingThreadPoolTest, QuiesceRaceStressTest) {","I haven't profiled it in earnest since that code is going away, but based on a rough cycle count, the original pool will more often (non-deterministically) take longer in either quiesce or destruction. Generally, the old code is more likely to get stuck in a few spots.```D0601 17:31:31.160825129      12 thread_pool_test.cc:180]              DO NOT SUBMIT: run_time:496.500000  , quiesce_time:96.500000  , destroy_time:1001072.000000D0601 17:31:32.161774568      12 thread_pool_test.cc:180]              DO NOT SUBMIT: run_time:640.750000  , quiesce_time:1000272.250000  , destroy_time:626.000000D0601 17:31:32.162480260      12 thread_pool_test.cc:180]              DO NOT SUBMIT: run_time:450.500000  , quiesce_time:214.000000  , destroy_time:1000957.750000D0601 17:31:32.163147749      12 thread_pool_test.cc:180]              DO NOT SUBMIT: run_time:443.750000  , quiesce_time:185.750000  , destroy_time:699.500000```",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/33290,1213698663,2023-06-01T21:27:07Z,src/core/ext/xds/xds_route_config.cc,"@@ -80,10 +80,9 @@  namespace grpc_core { -// TODO(donnadionne): Remove once RLS is no longer experimental","This TODO needs to stay, although you can change the assignee.  We still want to get rid of this env var guard before too long.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32973,1213705247,2023-06-01T21:34:51Z,src/core/ext/filters/client_channel/resolver/xds/xds_resolver.cc,"@@ -199,6 +199,89 @@ class XdsResolver : public Resolver {     RefCountedPtr<XdsResolver> resolver_;   }; +  // An entry in the map of clusters that need to be present in the LB+  // policy config.  The map holds a weak ref.  One strong ref is held by+  // the ConfigSelector, and another is held by each call assigned to+  // the cluster by the ConfigSelector.  The ref for each call is held+  // until the call is committed.  When the strong refs go away, we hop+  // back into the WorkSerializer to remove the entry from the map.+  class ClusterRef : public DualRefCounted<ClusterRef> {","I don't see this change.  The `ClusterRef` and `RouteConfigData` classes are still in between `ListenerWatcher` and `RouteConfigWatcher`.  Please move them down to line 342, after `RouteConfigWatcher`.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32973,1213736469,2023-06-01T22:18:58Z,src/core/ext/filters/client_channel/resolver/xds/xds_resolver.cc,"@@ -461,8 +459,7 @@ class XdsResolver : public Resolver {            std::string /*LB policy config*/>       cluster_specifier_plugin_map_; -  std::map<absl::string_view, WeakRefCountedPtr<ClusterState>>-      cluster_state_map_;+  std::map<absl::string_view, WeakRefCountedPtr<ClusterRef>> cluster_ref_map_; };  //","Please reorder the classes to match the declaration order.  Specifically, the order should be:1. RouteConfigData2. XdsConfigSelector3. XdsRouteStateAttributeImpl4. ClusterSelectionFilter5. XdsResolverXdsResolverFactory should stay at the end, after XdsResolver and all of its nested classes.In addition to making more sense, I think the diff will be smaller this way.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32973,1213744518,2023-06-01T22:33:46Z,src/core/ext/filters/stateful_session/stateful_session_filter.cc,"@@ -129,32 +131,42 @@ void MaybeUpdateServerInitialMetadata(       }); } +// Returns an arena-allocated string containing the cluster name+// to use for this RPC, which will live long enough to use when modifying+// the server's initial metadata.  If cluster_from_cookie is non-empty and+// points to a cluster present in the selected route, uses that; otherwise,+// uses the cluster selected by the XdsConfigSelector.+// Returns the empty string if cluster override cannot be used (i.e., the route+// uses a cluster specifier plugin). absl::string_view GetClusterToUse(     absl::string_view cluster_from_cookie,     ServiceConfigCallData* service_config_call_data) {-  static constexpr absl::string_view kClusterPrefix = ""cluster:"";+  // Get cluster assigned by the XdsConfigSelector.   auto cluster_attribute =       service_config_call_data->GetCallAttribute<XdsClusterAttribute>();   GPR_ASSERT(cluster_attribute != nullptr);-  auto cluster = cluster_attribute->cluster();-  auto cluster_to_use = cluster;-  if (!absl::StartsWith(cluster, kClusterPrefix)) {+  auto cluster_to_use = cluster_attribute->cluster();+  // If prefix is not ""cluster:"", then we can't use cluster override.+  if (!absl::ConsumePrefix(&cluster_to_use, kClusterPrefix)) {     return absl::string_view();   }+  // If we have a cluster from the cookie that is present in the+  // selected route, use that instead.   if (!cluster_from_cookie.empty()) {     auto route_data =         service_config_call_data->GetCallAttribute<XdsRouteStateAttribute>();     GPR_ASSERT(route_data != nullptr);-    if (route_data->HasClusterForRoute(-            absl::StripPrefix(cluster_from_cookie, kClusterPrefix))) {+    if (route_data->HasClusterForRoute(cluster_from_cookie)) {       // This string is already allocated on arena       cluster_to_use = cluster_from_cookie;-    } else {-      cluster_to_use = ToArena(cluster);     }   }-  cluster_attribute->set_cluster(cluster_to_use);-  return cluster_to_use;+  // If we chose the cluster from the cookie above, then update+  // the cluster name attribute as well.  Note that the attribute will+  // point to the arena-allocated string, which will live long enough.+  cluster_attribute->set_cluster(","The comment above says that we're resetting the cluster name attribute only if we use the value from the cookie, but the code is doing it unconditionally.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32973,1213749598,2023-06-01T22:42:50Z,src/core/ext/filters/stateful_session/stateful_session_filter.cc,"@@ -129,32 +131,42 @@ void MaybeUpdateServerInitialMetadata(       }); } +// Returns an arena-allocated string containing the cluster name+// to use for this RPC, which will live long enough to use when modifying+// the server's initial metadata.  If cluster_from_cookie is non-empty and+// points to a cluster present in the selected route, uses that; otherwise,+// uses the cluster selected by the XdsConfigSelector.+// Returns the empty string if cluster override cannot be used (i.e., the route+// uses a cluster specifier plugin). absl::string_view GetClusterToUse(     absl::string_view cluster_from_cookie,     ServiceConfigCallData* service_config_call_data) {-  static constexpr absl::string_view kClusterPrefix = ""cluster:"";+  // Get cluster assigned by the XdsConfigSelector.   auto cluster_attribute =       service_config_call_data->GetCallAttribute<XdsClusterAttribute>();   GPR_ASSERT(cluster_attribute != nullptr);-  auto cluster = cluster_attribute->cluster();-  auto cluster_to_use = cluster;-  if (!absl::StartsWith(cluster, kClusterPrefix)) {+  auto cluster_to_use = cluster_attribute->cluster();+  // If prefix is not ""cluster:"", then we can't use cluster override.+  if (!absl::ConsumePrefix(&cluster_to_use, kClusterPrefix)) {     return absl::string_view();   }+  // If we have a cluster from the cookie that is present in the+  // selected route, use that instead.   if (!cluster_from_cookie.empty()) {     auto route_data =         service_config_call_data->GetCallAttribute<XdsRouteStateAttribute>();     GPR_ASSERT(route_data != nullptr);-    if (route_data->HasClusterForRoute(-            absl::StripPrefix(cluster_from_cookie, kClusterPrefix))) {+    if (route_data->HasClusterForRoute(cluster_from_cookie)) {       // This string is already allocated on arena       cluster_to_use = cluster_from_cookie;-    } else {-      cluster_to_use = ToArena(cluster);     }   }-  cluster_attribute->set_cluster(cluster_to_use);-  return cluster_to_use;+  // If we chose the cluster from the cookie above, then update+  // the cluster name attribute as well.  Note that the attribute will+  // point to the arena-allocated string, which will live long enough.+  cluster_attribute->set_cluster(+      AllocateStringOnArena(absl::StrCat(kClusterPrefix, cluster_to_use)));","Using `absl::StrCat()` here does a non-arena allocation, which defeats the purpose of using the arena here.  Instead, I think we need to do something like what I showed in the same code in my previous comment:```  // Arena-allocate a copy of the cluster name with the ""cluster:"" prefix.  const size_t alloc_size = kClusterPrefix.size() + cluster_to_use.size();  char* allocated_value =      static_cast<char*>(GetContext<Arena>()->Alloc(alloc_size);  memcpy(allocated_value, kClusterPrefix.data(), kClusterPrefix.size());  memcpy(allocated_value + kClusterPrefix.size(), cluster_to_use.data(),         cluster_to_use.size());  cluster_to_use = absl::string_view(allocated_value, alloc_size);```",
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/32701,1213762663,2023-06-01T23:07:19Z,src/core/lib/event_engine/grpc_ares_wrapper.h,"@@ -0,0 +1,340 @@+// Copyright 2023 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+#ifndef GRPC_SRC_CORE_LIB_EVENT_ENGINE_GRPC_ARES_WRAPPER_H+#define GRPC_SRC_CORE_LIB_EVENT_ENGINE_GRPC_ARES_WRAPPER_H++#include <grpc/support/port_platform.h>++#if GRPC_ARES == 1++#include <stddef.h>++#include <algorithm>+#include <memory>+#include <string>+#include <vector>++#include <ares.h>++#include ""absl/base/thread_annotations.h""+#include ""absl/functional/any_invocable.h""+#include ""absl/status/status.h""+#include ""absl/status/statusor.h""+#include ""absl/strings/string_view.h""+#include ""absl/types/optional.h""++#include <grpc/event_engine/event_engine.h>+#include <grpc/support/log.h>++#include ""src/core/lib/debug/trace.h""+#include ""src/core/lib/event_engine/grpc_polled_fd.h""+#include ""src/core/lib/gprpp/orphanable.h""+#include ""src/core/lib/gprpp/sync.h""++namespace grpc_event_engine {+namespace experimental {++extern grpc_core::TraceFlag grpc_trace_ares_wrapper;++#define GRPC_ARES_WRAPPER_TRACE_LOG(format, ...)                              \+  do {                                                                        \+    if (GRPC_TRACE_FLAG_ENABLED(grpc_trace_ares_wrapper)) {                   \+      gpr_log(GPR_INFO, ""(EventEngine c-ares wrapper) "" format, __VA_ARGS__); \+    }                                                                         \+  } while (0)++// Base class for the c-ares based DNS lookup functionality. This class is+// inherited by the concrete leaf classes below which each represents a+// different type of lookup (i.e. A/AAAA, SRV, TXT). One request object+// represents one lookup request for a specific name. GrpcAresRequest+// encapsulates the common logics to initialize and destroy the c-ares channel+// (one channel for one request). Sets the name servers configuration for the","> Do we actually have any such use-cases [for a specific DNS cancellation usage]? I'm not aware of any.No users specifically for DNS externally yet that I'm aware of, but I expect so eventually. We have external EventEngine users and authors already. And _we ourselves_ may eventually be users who want fine-grained cancellation, because it seems like the most natural usage of a generic resolver API. See below.> Alternatively, maybe the semantic for the DNS callbacks should be that the callbacks are always run, even upon cancellation?That would confuse users. I'd really prefer to not have two different cancellation semantics in the EventEngine API. If it simplified things immensely, the tradeoff might be worth it.> This API is actually designed specifically for our use-cases, so I don't consider [tuning the API for an internal use case] a problem.I disagree here. Tuning a public API for our current internal use cases (especially when it makes the API more awkward for any other use case) would be a mistake for everyone. This public API may very well outlive the specifics of what gRPC is doing internally with DNS. And we know the EventEngine is being used outside gRPC already, with more plans to create custom engines. I don't want to create an awkward future by optimizing for the wrong things today.> If we actually have the ability to configure the DNS servers for each query, why aren't we doing it that way?It's a good point, and we have that ability today with an Ares implementation. If you aren't using ares, specifying the authority on every request might not make sense. Having a different timeout for every request could make a lot of sense, though - say a lookup implementation returns DEADLINE_EXCEEDED, I can imagine wanting to retry a lookup with a longer timeout. The design here was generally that you create a DNS Resolver for a given authority, and with a given set of overall resolver settings ... and if you need to resolve against a different authority or with incompatible settings, you get a different resolver.  But If the usefulness of a separate `DNSResolver` object is in question, then it could be a moot point as well.Another thing to consider is creating a separate, optional `GetBatchedDNSResolver` method with a no-op default. This could provide a mechanism for channel sharing optimizations without harming the generality of the API, and probably allow a lot of code reuse internally. I think the addition is a bit kludgy already, but if we need the optimization, we could.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32973,1213765328,2023-06-01T23:11:49Z,src/core/ext/filters/stateful_session/stateful_session_filter.cc,"@@ -160,105 +222,41 @@ ArenaPromise<ServerMetadataHandle> StatefulSessionFilter::MakeCallPromise(   GPR_ASSERT(method_params != nullptr);   auto* cookie_config = method_params->GetConfig(index_);   GPR_ASSERT(cookie_config != nullptr);-  if (!cookie_config->name.has_value()) {+  if (!cookie_config->name.has_value() ||+      !IsConfiguredPath(cookie_config->path,+                        call_args.client_initial_metadata)) {     return next_promise_factory(std::move(call_args));   }-  // We have a config.-  // If the config has a path, check to see if it matches the request path.-  if (!cookie_config->path.empty()) {-    Slice* path_slice =-        call_args.client_initial_metadata->get_pointer(HttpPathMetadata());-    GPR_ASSERT(path_slice != nullptr);-    absl::string_view path = path_slice->as_string_view();-    // Matching criteria from-    // https://www.rfc-editor.org/rfc/rfc6265#section-5.1.4.-    if (!absl::StartsWith(path, cookie_config->path) ||-        (path.size() != cookie_config->path.size() &&-         cookie_config->path.back() != '/' &&-         path[cookie_config->path.size() + 1] != '/')) {-      return next_promise_factory(std::move(call_args));-    }-  }-  // Check to see if we have a host override cookie.-  auto cookie_value = GetOverrideHostFromCookie(-      call_args.client_initial_metadata, *cookie_config->name);-  if (cookie_value.has_value()) {-    if (GRPC_TRACE_FLAG_ENABLED(grpc_stateful_session_filter_trace)) {-      gpr_log(GPR_INFO,-              ""chand=%p: stateful session filter found cookie %s value %s"",-              this, cookie_config->name->c_str(),-              std::string(*cookie_value).c_str());-    }-    std::pair<absl::string_view, absl::string_view> host_cluster =-        absl::StrSplit(*cookie_value, absl::MaxSplits(';', 1));-    if (!host_cluster.first.empty() &&-        OverrideClusterIfNeeded(host_cluster.second, service_config_call_data,-                                GetContext<Arena>())) {-      // We have a valid cookie, so add the call attribute to be used by the-      // xds_override_host LB policy.-      service_config_call_data->SetCallAttribute(-          GetContext<Arena>()->New<XdsOverrideHostAttribute>(-              host_cluster.first));-    }-    // Cluster is not yet in use-  }-  absl::string_view cluster_name;-  auto cluster_name_attribute = static_cast<XdsClusterAttribute*>(-      service_config_call_data->GetCallAttribute(-          XdsClusterAttribute::TypeName()));-  if (cluster_name_attribute != nullptr) {-    cluster_name = cluster_name_attribute->cluster();+  // Base64-decode cookie value.+  absl::string_view cookie_value = ToArena(","I don't think we actually need the original cookie to decide whether we need to update the cookie.  I think there are 3 cases where we would choose to update the cookie:1. There was no cookie originally.2. The cookie specified a cluster that we cannot use because it does not exist in the route.3. The cookie specified a host that does not match the host we actually used.Note that cases 1 and 2 are known when we see the cookie, without waiting for the server initial metadata; only case 3 needs to wait for the server initial metadata to detect it.Given that, I think what we should do here is to pass the following things into the lambdas that process the server initial metadata:- a boolean indicating if we already know that we need to update the cookie (i.e., this will be true in cases 1 and 2 -- it can be something like `bool cookie_update_needed = host_cluster.first != cluster_name;`)- the cluster name that we have chosen- the expected host name from the cookie, if anyWe can then have the lambdas capture `cookie_config`, `cookie_update_needed`, `cluster_name`, and `host_name` (the latter of which should be arena-allocated on line 251).  And we can then change `MaybeUpdateServerInitialMetadata()` to do something like this:```void MaybeUpdateServerInitialMetadata(    const StatefulSessionMethodParsedConfig::CookieConfig* cookie_config,    bool cookie_update_needed, absl::string_view actual_cluster,    absl::string_view expected_host, ServerMetadata* server_initial_metadata) {  Slice* peer_string = server_initial_metadata->get_pointer(PeerString());  if (peer_string == nullptr) {    // No changes, keep the same set-cookie header.    return;  }  absl::string_view actual_host = peer_string->as_string_view();  // If nothing changed, then we have nothing to do.  if (!cookie_update_needed && actual_host == expected_host) return;  // Otherwise, construct a new cookie.  // ...existing code...}```",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32973,1213780559,2023-06-01T23:44:17Z,test/cpp/end2end/xds/xds_override_host_end2end_test.cc,"@@ -121,13 +122,17 @@ class OverrideHostTest : public XdsEnd2endTest {   std::vector<std::pair<std::string, std::string>>   GetAffinityCookieHeaderForBackend(grpc_core::DebugLocation debug_location,                                     size_t backend_index,+                                    size_t max_requests = 0,","Oh, I see -- this is because we may need more iterations than the number of backends in the case that WeightedClusters sends too many RPCs to one of the clusters.Okay, I think this parameter does make sense then, because we don't want to unconditionally do 10x the number of requests needed for tests that are not using WeightedClusters.  But please document why we need the parameter, because it's very non-obvious.",
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/32701,1213783268,2023-06-01T23:51:32Z,src/core/lib/event_engine/grpc_ares_wrapper.h,"@@ -0,0 +1,340 @@+// Copyright 2023 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+#ifndef GRPC_SRC_CORE_LIB_EVENT_ENGINE_GRPC_ARES_WRAPPER_H+#define GRPC_SRC_CORE_LIB_EVENT_ENGINE_GRPC_ARES_WRAPPER_H++#include <grpc/support/port_platform.h>++#if GRPC_ARES == 1++#include <stddef.h>++#include <algorithm>+#include <memory>+#include <string>+#include <vector>++#include <ares.h>++#include ""absl/base/thread_annotations.h""+#include ""absl/functional/any_invocable.h""+#include ""absl/status/status.h""+#include ""absl/status/statusor.h""+#include ""absl/strings/string_view.h""+#include ""absl/types/optional.h""++#include <grpc/event_engine/event_engine.h>+#include <grpc/support/log.h>++#include ""src/core/lib/debug/trace.h""+#include ""src/core/lib/event_engine/grpc_polled_fd.h""+#include ""src/core/lib/gprpp/orphanable.h""+#include ""src/core/lib/gprpp/sync.h""++namespace grpc_event_engine {+namespace experimental {++extern grpc_core::TraceFlag grpc_trace_ares_wrapper;++#define GRPC_ARES_WRAPPER_TRACE_LOG(format, ...)                              \+  do {                                                                        \+    if (GRPC_TRACE_FLAG_ENABLED(grpc_trace_ares_wrapper)) {                   \+      gpr_log(GPR_INFO, ""(EventEngine c-ares wrapper) "" format, __VA_ARGS__); \+    }                                                                         \+  } while (0)++// Base class for the c-ares based DNS lookup functionality. This class is+// inherited by the concrete leaf classes below which each represents a+// different type of lookup (i.e. A/AAAA, SRV, TXT). One request object+// represents one lookup request for a specific name. GrpcAresRequest+// encapsulates the common logics to initialize and destroy the c-ares channel+// (one channel for one request). Sets the name servers configuration for the","Chatting with @yijiem, the more we work through potential semantics for `GetBatchedDNSResolver`, the worse the idea seems. I retract my support for the concept.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/33254,1218519682,2023-06-05T19:45:53Z,test/core/client_channel/lb_policy/pick_first_test.cc,"@@ -39,6 +47,78 @@ class PickFirstTest : public LoadBalancingPolicyTest {  protected:   PickFirstTest() : lb_policy_(MakeLbPolicy(""pick_first"")) {} +  static RefCountedPtr<LoadBalancingPolicy::Config> MakePickFirstConfig(+      bool shuffle_address_list) {+    return MakeConfig(Json::FromArray({Json::FromObject({{+        ""pick_first"",+        Json::FromObject(+            {{""shuffleAddressList"", Json::FromBool(shuffle_address_list)}}),+    }})}));+  }++  absl::string_view GetConnectingSubchannel(+      absl::Span<const absl::string_view> addresses,+      SourceLocation location = SourceLocation()) {+    for (auto address : addresses) {+      auto* subchannel = FindSubchannel(+          address, ChannelArgs().Set(GRPC_ARG_INHIBIT_HEALTH_CHECKING, true));+      EXPECT_NE(subchannel, nullptr)+          << location.file() << "":"" << location.line();+      if (subchannel == nullptr) {+        return absl::string_view();+      } else if (subchannel->ConnectionRequested()) {+        return address;+      }+    }+    return absl::string_view();+  }++  // Gets order the addresses are being picked. Return type is void so+  // assertions can be used+  void GetOrderAddressesArePicked(+      absl::Span<const absl::string_view> addresses,+      std::vector<absl::string_view>* out_address_order) {+    absl::string_view address;+    SubchannelState* subchannel = nullptr;+    out_address_order->clear();+    while (addresses.size() > out_address_order->size()) {","The logic here is written in a way that is a little hard to follow.  For example, reporting TRANSIENT_FAILURE is done at the start of the loop for the subchannel from the previous loop iteration, so it's hard to understand the order in which the actions occur for each subchannel.  Also, we are winding up calling `FindSubchannel()` twice, once in `GetConnectingSubchannel()` and then again here, and we're doing this for every iteration of the loop.Instead, I suggest constructing a list of subchannels at the start of the function, and removing elements from it as you iterate.  I think this approach results in more readable code:```// Construct a map of subchannel to address.// We will remove entries as each subchannel starts to connect.std::map<SubchannelState*, absl::string_view> subchannels;for (auto address : addresses) {  auto* subchannel = FindSubchannel(      address, ChannelArgs().Set(GRPC_ARG_INHIBIT_HEALTH_CHECKING, true));  ASSERT_NE(subchannel, nullptr);  subchannels.emplace_back(subchannel, address);}// Now process each subchannel in the order in which pick_first tries it.while (!subchannels.empty()) {  // Find the subchannel that is being attempted.  SubchannelState* subchannel = nullptr;  for (const auto& p : subchannels) {    if (p.first->ConnectionRequested()) {      out_address_order->push_back(p.second);      subchannel = p.first;      break;    }  }  ASSERT_NE(subchannel, """");  // The subchannel reports CONNECTING.  subchannel->SetConnectivityState(GRPC_CHANNEL_CONNECTING);  // If this is the first subchannel being attempted, expect a CONNECTING update.  if (subchannels.size() == kAddresses.size()) {    ExpectConnectingUpdate();  }  if (subchannels.size() > 1) {    // Not the last subchannel in the list.  Connection attempt should fail.    subchannel->SetConnectivityState(        GRPC_CHANNEL_TRANSIENT_FAILURE,        absl::UnavailableError(""failed to connect""));    subchannel->SetConnectivityState(GRPC_CHANNEL_IDLE);  } else {    // Last subchannel in the list.  Connection attempt should succeed.    subchannel->SetConnectivityState(GRPC_CHANNEL_READY);    auto picker = WaitForConnected();    ASSERT_NE(picker, nullptr);    EXPECT_EQ(ExpectPickComplete(picker.get()), out_address_order->back());    // Then it should become disconnected.    subchannel->SetConnectivityState(GRPC_CHANNEL_IDLE);    ExpectReresolutionRequest();    ExpectStateAndQueuingPicker(GRPC_CHANNEL_IDLE);  }  // Remove the subchannel from the map.  subchannels.erase(subchannel);}```",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/33254,1218523334,2023-06-05T19:50:05Z,src/core/ext/filters/client_channel/lb_policy/pick_first/pick_first.cc,"@@ -281,6 +322,13 @@ absl::Status PickFirst::UpdateLocked(UpdateArgs args) {   }   // Update latest_update_args_.   latest_update_args_ = std::move(args);+  if (latest_update_args_.config != nullptr) {","Looks like we're having some internal discussions about whether we actually want to shuffle the address list when we get the updated address list or when we start connecting.  If it turns out that we actually want to do it when we get the address list, we'll have to make some changes here.  But for now, this looks good!",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32973,1219895225,2023-06-06T15:47:47Z,src/core/ext/filters/client_channel/resolver/xds/xds_resolver.cc,"@@ -461,157 +454,195 @@ class XdsResolver : public Resolver {            std::string /*LB policy config*/>       cluster_specifier_plugin_map_; -  std::map<absl::string_view, WeakRefCountedPtr<ClusterState>>-      cluster_state_map_;+  std::map<absl::string_view, WeakRefCountedPtr<ClusterRef>> cluster_ref_map_; };  //-// XdsResolver::XdsConfigSelector::Route+// XdsResolverFactory // -bool MethodConfigsEqual(const ServiceConfig* sc1, const ServiceConfig* sc2) {-  if (sc1 == nullptr) return sc2 == nullptr;-  if (sc2 == nullptr) return false;-  return sc1->json_string() == sc2->json_string();-}+class XdsResolverFactory : public ResolverFactory {+ public:+  absl::string_view scheme() const override { return ""xds""; } -const grpc_channel_filter XdsResolver::ClusterSelectionFilter::kFilter =-    MakePromiseBasedFilter<ClusterSelectionFilter, FilterEndpoint::kClient,-                           kFilterExaminesServerInitialMetadata>(-        ""cluster_selection_filter"");+  bool IsValidUri(const URI& uri) const override {+    if (uri.path().empty() || uri.path().back() == '/') {+      gpr_log(GPR_ERROR,+              ""URI path does not contain valid data plane authority"");+      return false;+    }+    return true;+  } -bool XdsResolver::XdsConfigSelector::Route::ClusterWeightState::operator==(-    const ClusterWeightState& other) const {-  return range_end == other.range_end && cluster == other.cluster &&-         MethodConfigsEqual(method_config.get(), other.method_config.get());-}+  std::string GetDefaultAuthority(const URI& uri) const override {+    return GetDefaultAuthorityInternal(uri);+  } -bool XdsResolver::XdsConfigSelector::Route::operator==(-    const Route& other) const {-  return route == other.route &&-         weighted_cluster_state == other.weighted_cluster_state &&-         MethodConfigsEqual(method_config.get(), other.method_config.get());-}+  OrphanablePtr<Resolver> CreateResolver(ResolverArgs args) const override {+    if (!IsValidUri(args.uri)) return nullptr;+    return MakeOrphanable<XdsResolver>(std::move(args));+  }+};++//+// XdsResolver::RouteConfigData::RouteListIterator+//  // Implementation of XdsRouting::RouteListIterator for getting the matching // route for a request.-class XdsResolver::XdsConfigSelector::RouteListIterator+class XdsResolver::RouteConfigData::RouteListIterator     : public XdsRouting::RouteListIterator {  public:-  explicit RouteListIterator(const RouteTable* route_table)+  explicit RouteListIterator(const RouteConfigData* route_table)       : route_table_(route_table) {} -  size_t Size() const override { return route_table_->size(); }+  size_t Size() const override { return route_table_->routes_.size(); }    const XdsRouteConfigResource::Route::Matchers& GetMatchersForRoute(       size_t index) const override {-    return (*route_table_)[index].route.matchers;+    return route_table_->routes_[index].route.matchers;   }   private:-  const RouteTable* route_table_;+  const RouteConfigData* route_table_; };  //-// XdsResolver::XdsConfigSelector+// XdsResolver::RouteConfigData // -XdsResolver::XdsConfigSelector::XdsConfigSelector(-    RefCountedPtr<XdsResolver> resolver, absl::Status* status)-    : resolver_(std::move(resolver)) {-  if (GRPC_TRACE_FLAG_ENABLED(grpc_xds_resolver_trace)) {-    gpr_log(GPR_INFO, ""[xds_resolver %p] creating XdsConfigSelector %p"",-            resolver_.get(), this);-  }-  // 1. Construct the route table-  // 2  Update resolver's cluster state map-  // 3. Construct cluster list to hold on to entries in the cluster state-  // map.+absl::StatusOr<RefCountedPtr<XdsResolver::RouteConfigData>>+XdsResolver::RouteConfigData::Create(+    XdsResolver* resolver,+    const std::vector<XdsRouteConfigResource::Route>& routes,+    const Duration& default_max_stream_duration) {+  auto data = MakeRefCounted<RouteConfigData>();   // Reserve the necessary entries up-front to avoid reallocation as we add   // elements. This is necessary because the string_view in the entry's   // weighted_cluster_state field points to the memory in the route field, so   // moving the entry in a reallocation will cause the string_view to point to   // invalid data.-  route_table_.reserve(resolver_->current_virtual_host_->routes.size());-  std::map<absl::string_view, RefCountedPtr<ClusterState>> clusters;+  data->routes_.reserve(routes.size());+  for (auto& route : routes) {+    absl::Status status =+        data->AddRouteEntry(route, default_max_stream_duration, resolver);+    if (!status.ok()) {+      return status;+    }+  }+  return data;+}++XdsResolver::RouteConfigData::RouteEntry*+XdsResolver::RouteConfigData::GetRouteForRequest(+    absl::string_view path, grpc_metadata_batch* initial_metadata) {+  auto route_index = XdsRouting::GetRouteForRequest(RouteListIterator(this),+                                                    path, initial_metadata);+  if (!route_index.has_value()) {+    return nullptr;+  }+  return &routes_[*route_index];+}++absl::Status XdsResolver::RouteConfigData::AddRouteEntry(+    const XdsRouteConfigResource::Route& route,+    const Duration& default_max_stream_duration, XdsResolver* resolver) {+  if (GRPC_TRACE_FLAG_ENABLED(grpc_xds_resolver_trace)) {+    gpr_log(GPR_INFO, ""[xds_resolver %p] XdsConfigSelector %p: route: %s"",+            resolver, this, route.ToString().c_str());+  }+  routes_.emplace_back(route);+  auto* route_entry = &routes_.back();   auto maybe_add_cluster = [&](absl::string_view cluster_name) {-    if (clusters.find(cluster_name) != clusters.end()) return;-    auto cluster_state = resolver_->GetOrCreateClusterState(cluster_name);+    if (clusters_.find(cluster_name) != clusters_.end()) return;+    auto cluster_state = resolver->GetOrCreateClusterRef(cluster_name);     absl::string_view name = cluster_state->cluster_name();-    clusters.emplace(name, std::move(cluster_state));+    clusters_.emplace(name, std::move(cluster_state));   };-  for (auto& route : resolver_->current_virtual_host_->routes) {-    if (GRPC_TRACE_FLAG_ENABLED(grpc_xds_resolver_trace)) {-      gpr_log(GPR_INFO, ""[xds_resolver %p] XdsConfigSelector %p: route: %s"",-              resolver_.get(), this, route.ToString().c_str());+  auto* route_action = absl::get_if<XdsRouteConfigResource::Route::RouteAction>(+      &route_entry->route.action);+  if (route_action != nullptr) {+    // If the route doesn't specify a timeout, set its timeout to the global+    // one.+    if (!route_action->max_stream_duration.has_value()) {+      route_action->max_stream_duration = default_max_stream_duration;     }-    route_table_.emplace_back();-    auto& route_entry = route_table_.back();-    route_entry.route = route;-    auto* route_action =-        absl::get_if<XdsRouteConfigResource::Route::RouteAction>(-            &route_entry.route.action);-    if (route_action != nullptr) {-      // If the route doesn't specify a timeout, set its timeout to the global-      // one.-      if (!route_action->max_stream_duration.has_value()) {-        route_action->max_stream_duration =-            resolver_->current_listener_.http_max_stream_duration;-      }-      Match(-          route_action->action,-          // cluster name-          [&](const XdsRouteConfigResource::Route::RouteAction::ClusterName&-                  cluster_name) {-            auto result = CreateMethodConfig(route_entry.route, nullptr);-            if (!result.ok()) {-              *status = result.status();-              return;-            }-            route_entry.method_config = std::move(*result);-            maybe_add_cluster(-                absl::StrCat(""cluster:"", cluster_name.cluster_name));-          },-          // WeightedClusters-          [&](const std::vector<-              XdsRouteConfigResource::Route::RouteAction::ClusterWeight>&-                  weighted_clusters) {-            uint32_t end = 0;-            for (const auto& weighted_cluster : weighted_clusters) {-              Route::ClusterWeightState cluster_weight_state;-              auto result =-                  CreateMethodConfig(route_entry.route, &weighted_cluster);-              if (!result.ok()) {-                *status = result.status();-                return;-              }-              cluster_weight_state.method_config = std::move(*result);-              end += weighted_cluster.weight;-              cluster_weight_state.range_end = end;-              cluster_weight_state.cluster = weighted_cluster.name;-              route_entry.weighted_cluster_state.push_back(-                  std::move(cluster_weight_state));-              maybe_add_cluster(-                  absl::StrCat(""cluster:"", weighted_cluster.name));-            }-          },-          // ClusterSpecifierPlugin-          [&](const XdsRouteConfigResource::Route::RouteAction::-                  ClusterSpecifierPluginName& cluster_specifier_plugin_name) {-            auto result = CreateMethodConfig(route_entry.route, nullptr);+    absl::Status status = Match(+        route_action->action,+        // cluster name+        [&](const XdsRouteConfigResource::Route::RouteAction::ClusterName&+                cluster_name) {+          auto result =+              resolver->CreateMethodConfig(route_entry->route, nullptr);+          if (!result.ok()) {+            return result.status();+          }+          route_entry->method_config = std::move(*result);+          maybe_add_cluster(+              absl::StrCat(""cluster:"", cluster_name.cluster_name));+          return absl::OkStatus();+        },+        // WeightedClusters+        [&](const std::vector<+            XdsRouteConfigResource::Route::RouteAction::ClusterWeight>&+                weighted_clusters) {+          uint32_t end = 0;+          for (const auto& weighted_cluster : weighted_clusters) {+            auto result = resolver->CreateMethodConfig(route_entry->route,+                                                       &weighted_cluster);             if (!result.ok()) {-              *status = result.status();-              return;+              return result.status();             }-            route_entry.method_config = std::move(*result);-            maybe_add_cluster(absl::StrCat(-                ""cluster_specifier_plugin:"",-                cluster_specifier_plugin_name.cluster_specifier_plugin_name));-          });-      if (!status->ok()) return;+            RouteEntry::ClusterWeightState cluster_weight_state;+            cluster_weight_state.method_config = std::move(*result);+            end += weighted_cluster.weight;+            cluster_weight_state.range_end = end;+            cluster_weight_state.cluster = weighted_cluster.name;+            route_entry->weighted_cluster_state.push_back(+                std::move(cluster_weight_state));+            maybe_add_cluster(absl::StrCat(""cluster:"", weighted_cluster.name));+          }+          return absl::OkStatus();+        },+        // ClusterSpecifierPlugin+        [&](const XdsRouteConfigResource::Route::RouteAction::+                ClusterSpecifierPluginName& cluster_specifier_plugin_name) {+          auto result =+              resolver->CreateMethodConfig(route_entry->route, nullptr);+          if (!result.ok()) {+            return result.status();+          }+          route_entry->method_config = std::move(*result);+          maybe_add_cluster(absl::StrCat(+              ""cluster_specifier_plugin:"",+              cluster_specifier_plugin_name.cluster_specifier_plugin_name));+          return absl::OkStatus();+        });+    if (!status.ok()) {+      return status;     }   }-  cluster_map_ = MakeRefCounted<XdsClusterMap>(std::move(clusters));+  return absl::OkStatus();+}++//+// XdsResolver::XdsConfigSelector+//++const grpc_channel_filter XdsResolver::ClusterSelectionFilter::kFilter =","This belongs with the `ClusterSelectionFilter` code, not with the `XdsConfigSelector` code.  Please move it down to line 857.",X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32973,1219899254,2023-06-06T15:49:57Z,src/core/ext/filters/client_channel/resolver/xds/xds_resolver.cc,"@@ -461,8 +459,7 @@ class XdsResolver : public Resolver {            std::string /*LB policy config*/>       cluster_specifier_plugin_map_; -  std::map<absl::string_view, WeakRefCountedPtr<ClusterState>>-      cluster_state_map_;+  std::map<absl::string_view, WeakRefCountedPtr<ClusterRef>> cluster_ref_map_; };  //",You've still got `XdsResolverFactory` right in the middle of all of the `XdsResolver` code.  Please move it down to line 1284.,X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32973,1219914601,2023-06-06T15:58:24Z,src/core/ext/filters/client_channel/resolver/xds/xds_resolver.cc,"@@ -162,6 +255,31 @@ class XdsResolver : public Resolver {     if (xds_client_ != nullptr) xds_client_->ResetBackoff();   } +  void MaybeRemoveUnusedClustersOnWorkSerializer() {+    work_serializer_->Run(+        [resolver = Ref()]() mutable {+          static_cast<XdsResolver*>(resolver.get())+              ->MaybeRemoveUnusedClusters();+        },+        DEBUG_LOCATION);+  }++  RefCountedPtr<ClusterRef> GetOrCreateClusterRef(+      absl::string_view cluster_name) {+    auto it = cluster_state_map_.find(cluster_name);+    if (it == cluster_state_map_.end()) {+      auto cluster = MakeRefCounted<ClusterRef>(Ref(), cluster_name);+      cluster_state_map_.emplace(cluster->cluster_name(), cluster->WeakRef());+      return cluster;+    }+    return it->second->Ref();+  }++  absl::StatusOr<RefCountedPtr<ServiceConfig>> CreateMethodConfig(",This is still not done.  Please move the `CreateMethodConfig()` method into the `RouteConfigData` class.,X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32973,1220012378,2023-06-06T17:02:21Z,src/core/ext/filters/stateful_session/stateful_session_filter.cc,"@@ -129,32 +131,42 @@ void MaybeUpdateServerInitialMetadata(       }); } +// Returns an arena-allocated string containing the cluster name+// to use for this RPC, which will live long enough to use when modifying+// the server's initial metadata.  If cluster_from_cookie is non-empty and+// points to a cluster present in the selected route, uses that; otherwise,+// uses the cluster selected by the XdsConfigSelector.+// Returns the empty string if cluster override cannot be used (i.e., the route+// uses a cluster specifier plugin). absl::string_view GetClusterToUse(     absl::string_view cluster_from_cookie,     ServiceConfigCallData* service_config_call_data) {-  static constexpr absl::string_view kClusterPrefix = ""cluster:"";+  // Get cluster assigned by the XdsConfigSelector.   auto cluster_attribute =       service_config_call_data->GetCallAttribute<XdsClusterAttribute>();   GPR_ASSERT(cluster_attribute != nullptr);-  auto cluster = cluster_attribute->cluster();-  auto cluster_to_use = cluster;-  if (!absl::StartsWith(cluster, kClusterPrefix)) {+  auto cluster_to_use = cluster_attribute->cluster();+  // If prefix is not ""cluster:"", then we can't use cluster override.+  if (!absl::ConsumePrefix(&cluster_to_use, kClusterPrefix)) {     return absl::string_view();   }+  // If we have a cluster from the cookie that is present in the+  // selected route, use that instead.   if (!cluster_from_cookie.empty()) {     auto route_data =         service_config_call_data->GetCallAttribute<XdsRouteStateAttribute>();     GPR_ASSERT(route_data != nullptr);-    if (route_data->HasClusterForRoute(-            absl::StripPrefix(cluster_from_cookie, kClusterPrefix))) {+    if (route_data->HasClusterForRoute(cluster_from_cookie)) {       // This string is already allocated on arena       cluster_to_use = cluster_from_cookie;-    } else {-      cluster_to_use = ToArena(cluster);     }   }-  cluster_attribute->set_cluster(cluster_to_use);-  return cluster_to_use;+  // If we chose the cluster from the cookie above, then update+  // the cluster name attribute as well.  Note that the attribute will+  // point to the arena-allocated string, which will live long enough.+  cluster_attribute->set_cluster(","As I mentioned in one of my earlier rounds of review, it's not okay to simply return the existing string from the attribute here, since there is no guarantee that that string will live long enough.  The string in the attribute will point to the one held in the `ClusterRef` object, and that object might go away as soon as the `on_commit` callback is invoked for this call (right after the call finishes the LB pick), which will be before we see the server's initial metadata.  So this latest round of changes re-introduced a bug that we'd already fixed.  Please put this code back the way it was before.All I was asking for here was to either (a) change the comment to indicate that we're doing this unconditionally or (b) change the code to set it conditionally.  Either option is probably fine, but neither one should affect the overall code structure here.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/33254,1220453601,2023-06-06T22:23:55Z,test/core/client_channel/lb_policy/pick_first_test.cc,"@@ -39,6 +50,87 @@ class PickFirstTest : public LoadBalancingPolicyTest {  protected:   PickFirstTest() : lb_policy_(MakeLbPolicy(""pick_first"")) {} +  static RefCountedPtr<LoadBalancingPolicy::Config> MakePickFirstConfig(+      bool shuffle_address_list) {+    return MakeConfig(Json::FromArray({Json::FromObject({{+        ""pick_first"",+        Json::FromObject(+            {{""shuffleAddressList"", Json::FromBool(shuffle_address_list)}}),+    }})}));+  }++  absl::string_view GetConnectingSubchannel(",This method is no longer needed.,X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/33254,1220486115,2023-06-06T22:37:49Z,test/core/client_channel/lb_policy/pick_first_test.cc,"@@ -177,6 +269,61 @@ TEST_F(PickFirstTest, GoesIdleWhenConnectionFailsThenCanReconnect) {   } } +TEST_F(PickFirstTest, WithShuffle) {+  testing::ScopedExperimentalEnvVar env_var(+      ""GRPC_EXPERIMENTAL_PICKFIRST_LB_CONFIG"");+  // 6 addresses have 6! = 720 permutations or 0.1% chance that the shuffle+  // returns initial sequence+  constexpr std::array<absl::string_view, 6> kAddresses = {+      ""ipv4:127.0.0.1:443"", ""ipv4:127.0.0.1:444"", ""ipv4:127.0.0.1:445"",+      ""ipv4:127.0.0.1:446"", ""ipv4:127.0.0.1:447"", ""ipv4:127.0.0.1:448""};+  absl::Status status = ApplyUpdate(+      BuildUpdate(kAddresses, MakePickFirstConfig(true)), lb_policy_.get());+  EXPECT_TRUE(status.ok()) << status;+  std::vector<absl::string_view> prev_attempt_connect_order;","I think we need to initialize this to the order from `kAddresses`.  Otherwise, the condition on line 295 below will always evaluate to true on the very first attempt, which means that this test will pass even if shuffling is not working properly.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/33355,1221738407,2023-06-07T14:52:27Z,test/core/client_channel/lb_policy/weighted_round_robin_test.cc,"@@ -334,24 +340,58 @@ TEST_F(WeightedRoundRobinTest, Basic) {   // No utilization report from backend 2, so it gets the average weight 2.   WaitForWeightedRoundRobinPicks(       &picker,-      {{kAddresses[0], MakeBackendMetricData(/*cpu_utilization=*/0.9,+      {{kAddresses[0], MakeBackendMetricData(/*app_utilization=*/0.9,                                              /*qps=*/100.0, /*eps=*/0.0)},-       {kAddresses[1], MakeBackendMetricData(/*cpu_utilization=*/0.3,+       {kAddresses[1], MakeBackendMetricData(/*app_utilization=*/0.3,                                              /*qps=*/100.0, /*eps=*/0.0)}},       {{kAddresses[0], 1}, {kAddresses[1], 3}, {kAddresses[2], 2}});   // Now have backend 2 report utilization the same as backend 1, so its   // weight will be the same.   WaitForWeightedRoundRobinPicks(       &picker,-      {{kAddresses[0], MakeBackendMetricData(/*cpu_utilization=*/0.9,+      {{kAddresses[0], MakeBackendMetricData(/*app_utilization=*/0.9,                                              /*qps=*/100.0, /*eps=*/0.0)},-       {kAddresses[1], MakeBackendMetricData(/*cpu_utilization=*/0.3,+       {kAddresses[1], MakeBackendMetricData(/*app_utilization=*/0.3,                                              /*qps=*/100.0, /*eps=*/0.0)},-       {kAddresses[2], MakeBackendMetricData(/*cpu_utilization=*/0.3,+       {kAddresses[2], MakeBackendMetricData(/*app_utilization=*/0.3,                                              /*qps=*/100.0, /*eps=*/0.0)}},       {{kAddresses[0], 1}, {kAddresses[1], 3}, {kAddresses[2], 3}}); } +TEST_F(WeightedRoundRobinTest, CpuUtilWhenNoAppUtil) {+  // Send address list to LB policy.+  const std::array<absl::string_view, 3> kAddresses = {+      ""ipv4:127.0.0.1:441"", ""ipv4:127.0.0.1:442"", ""ipv4:127.0.0.1:443""};+  auto picker = SendInitialUpdateAndWaitForConnected(kAddresses);+  ASSERT_NE(picker, nullptr);+  // Address 0 gets weight 1, address 1 gets weight 3.+  // No utilization report from backend 2, so it gets the average weight 2.+  WaitForWeightedRoundRobinPicks(+      &picker,+      {{kAddresses[0], MakeBackendMetricData(/*app_utilization=*/0,+                                             /*qps=*/100.0, /*eps=*/0.0,+                                             /*cpu_utilization=*/0.9)},+       {kAddresses[1],+        MakeBackendMetricData(/*app_utilization=*/0,","Please change some of the data in this test to set both application_utilization and cpu_utilization, the latter using a bogus value, so that we are testing that we prefer application_utilization when both values are set.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32973,1221954221,2023-06-07T17:33:54Z,src/core/ext/filters/stateful_session/stateful_session_filter.cc,"@@ -147,14 +146,14 @@ absl::string_view GetClusterToUse(       service_config_call_data->GetCallAttribute<XdsClusterAttribute>();   GPR_ASSERT(cluster_attribute != nullptr);   auto cluster_to_use = cluster_attribute->cluster();","Since you've changed the logic here to no longer actually use this variable as the cluster to use in all cases, I suggest renaming this to `current_cluster`.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32973,1221962777,2023-06-07T17:41:05Z,src/core/ext/filters/stateful_session/stateful_session_filter.cc,"@@ -83,35 +85,140 @@ StatefulSessionFilter::StatefulSessionFilter(ChannelFilter::Args filter_args)  namespace { +absl::string_view AllocateStringOnArena(+    absl::string_view src1, absl::string_view src2 = absl::string_view()) {+  if (src1.empty() && src2.empty()) {+    return absl::string_view();+  }+  char* arena_allocated_value =+      static_cast<char*>(GetContext<Arena>()->Alloc(src1.size() + src2.size()));+  if (!src1.empty()) {","Oh, interesting.  Well, in that case, I guess go ahead and put the conditionals back.",
2811396,ejona86,https://api.github.com/repos/grpc/grpc/pulls/33360,1222114542,2023-06-07T20:20:04Z,tools/run_tests/xds_k8s_test_driver/framework/xds_k8s_testcase.py,"@@ -301,55 +301,66 @@ def assertRpcStatusCodes(self,                              method: str,                              stray_rpc_limit: int = 0) -> None:         """"""Assert all RPCs for a method are completing with a certain status.""""""+        expected_status_int: int = expected_status.value[0]+        expected_status_fmt: str = helpers_grpc.status_pretty(expected_status)+         # Sending with pre-set QPS for a period of time         before_stats = test_client.get_load_balancer_accumulated_stats()+        before_stats_fmt: str = self._pretty_accumulated_stats(before_stats)         logging.debug(","The main argument for me to log them is that all other interactions with control plane, test server, and test client log. There are so many components of the test we want to know what is happening to debug. If ""lines"" is the problem, then print them as a single line. If we don't want to record them when they happen, then I don't think we'd log on error either. Part of the value of logging is the timestamp, and there's been no issue with the diffing and that is unrelated to these error messages. Either keep the logs, or trash them. And certainly not logger.error() followed by raise with much of the content copied.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/33254,1222253938,2023-06-07T22:45:35Z,test/core/client_channel/lb_policy/pick_first_test.cc,"@@ -39,6 +49,70 @@ class PickFirstTest : public LoadBalancingPolicyTest {  protected:   PickFirstTest() : lb_policy_(MakeLbPolicy(""pick_first"")) {} +  static RefCountedPtr<LoadBalancingPolicy::Config> MakePickFirstConfig(+      bool shuffle_address_list) {+    return MakeConfig(Json::FromArray({Json::FromObject({{+        ""pick_first"",+        Json::FromObject(+            {{""shuffleAddressList"", Json::FromBool(shuffle_address_list)}}),+    }})}));+  }++  // Gets order the addresses are being picked. Return type is void so+  // assertions can be used+  void GetOrderAddressesArePicked(+      absl::Span<const absl::string_view> addresses,+      std::vector<absl::string_view>* out_address_order) {+    // Construct a map of subchannel to address.+    // We will remove entries as each subchannel starts to connect.+    std::map<SubchannelState*, absl::string_view> subchannels;+    for (auto address : addresses) {+      auto* subchannel = FindSubchannel(+          address, ChannelArgs().Set(GRPC_ARG_INHIBIT_HEALTH_CHECKING, true));+      ASSERT_NE(subchannel, nullptr);+      subchannels.emplace(subchannel, address);+    }+    // Now process each subchannel in the order in which pick_first tries it.+    while (!subchannels.empty()) {+      // Find the subchannel that is being attempted.+      SubchannelState* subchannel = nullptr;+      for (const auto& p : subchannels) {+        if (p.first->ConnectionRequested()) {+          out_address_order->push_back(p.second);+          subchannel = p.first;+          break;+        }+      }+      ASSERT_NE(subchannel, nullptr);+      // The subchannel reports CONNECTING.+      subchannel->SetConnectivityState(GRPC_CHANNEL_CONNECTING);+      // If this is the first subchannel being attempted, expect a CONNECTING+      // update.+      if (subchannels.size() == addresses.size()) {+        ExpectConnectingUpdate();+      }+      if (subchannels.size() > 1) {+        // Not the last subchannel in the list.  Connection attempt should fail.+        subchannel->SetConnectivityState(+            GRPC_CHANNEL_TRANSIENT_FAILURE,+            absl::UnavailableError(""failed to connect""));+        subchannel->SetConnectivityState(GRPC_CHANNEL_IDLE);+      } else {","I think we should remove this `else` block.  We can just leave the last subchannel trying to connect, since the policy will stop using it as soon as we deliver a new address list.",
2811396,ejona86,https://api.github.com/repos/grpc/grpc/pulls/33360,1223158436,2023-06-08T14:51:40Z,tools/run_tests/xds_k8s_test_driver/framework/xds_k8s_testcase.py,"@@ -301,55 +301,66 @@ def assertRpcStatusCodes(self,                              method: str,                              stray_rpc_limit: int = 0) -> None:         """"""Assert all RPCs for a method are completing with a certain status.""""""+        expected_status_int: int = expected_status.value[0]+        expected_status_fmt: str = helpers_grpc.status_pretty(expected_status)+         # Sending with pre-set QPS for a period of time         before_stats = test_client.get_load_balancer_accumulated_stats()+        before_stats_fmt: str = self._pretty_accumulated_stats(before_stats)         logging.debug(","I'd have had less of a problem with the log+raise if the log was info and just had the before/after details. I'd probably have turned my noise up at it a bit in the same ""have it or don't have it, not based on the error"" sense, but would have been much less likely to raise an objection. So it was both the logger's level and the fact much of the content was copied. And that's also partly the amount of code/formatting/duplication dedicated to the task, for the error case that had previously been just fine.",X
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/33375,1223441717,2023-06-08T19:03:39Z,src/core/lib/event_engine/posix_engine/posix_endpoint.cc,"@@ -549,29 +551,52 @@ void PosixEndpointImpl::MaybeMakeReadSlices() {   } } -void PosixEndpointImpl::HandleRead(absl::Status status) {-  read_mu_.Lock();+bool PosixEndpointImpl::HandleReadLocked(absl::Status status) {   if (status.ok() && memory_owner_.is_valid()) {     MaybeMakeReadSlices();     if (!TcpDoRead(status)) {       UpdateRcvLowat();       // We've consumed the edge, request a new one.-      read_mu_.Unlock();-      handle_->NotifyOnRead(on_read_);-      return;+      return false;     }   } else {-    if (!memory_owner_.is_valid()) {-      status = absl::UnknownError(""Shutting down endpoint"");+    if (!memory_owner_.is_valid() && status.ok()) {+      status = TcpAnnotateError(absl::UnknownError(""Shutting down endpoint""));     }     incoming_buffer_->Clear();     last_read_buffer_.Clear();   }-  absl::AnyInvocable<void(absl::Status)> cb = std::move(read_cb_);-  read_cb_ = nullptr;-  incoming_buffer_ = nullptr;-  read_mu_.Unlock();-  cb(status);+  return true;+}++void PosixEndpointImpl::HandleRead(absl::Status status) {+  if (grpc_core::ExecCtx::Get() == nullptr) {","This pattern repeats a few times. I think we should eliminate the duplication it incurs, either by locally adding extra methods, or maybe:```template <typename F>void EnsureRunInExecCtx(F f) {  if (grpc_core::ExecCtx::Get() == nullptr) {    grpc_core::ApplicationCallbackExecCtx app_ctx;    grpc_core::ExecCtx exec_ctx;    f();  } else {    f();  }}```this could be added to exec_ctx.h and used wherever needed during this transition:```EnsureRunInExecCtx([]{      grpc_core::ReleasableMutexLock lock(&read_mu_);    if (!HandleReadLocked(status)) {      lock.Release();      handle_->NotifyOnRead(on_read_);      return;    }    absl::AnyInvocable<void(absl::Status)> cb = std::move(read_cb_);    read_cb_ = nullptr;    incoming_buffer_ = nullptr;    lock.Release();    cb(status);  });```",X
672669,sergiitk,https://api.github.com/repos/grpc/grpc/pulls/33360,1223864735,2023-06-09T05:40:23Z,tools/run_tests/xds_k8s_test_driver/framework/xds_k8s_testcase.py,"@@ -301,55 +301,66 @@ def assertRpcStatusCodes(self,                              method: str,                              stray_rpc_limit: int = 0) -> None:         """"""Assert all RPCs for a method are completing with a certain status.""""""+        expected_status_int: int = expected_status.value[0]+        expected_status_fmt: str = helpers_grpc.status_pretty(expected_status)+         # Sending with pre-set QPS for a period of time         before_stats = test_client.get_load_balancer_accumulated_stats()+        before_stats_fmt: str = self._pretty_accumulated_stats(before_stats)         logging.debug(","Thanks. The reason I asked about the error log level and repeating the error is related to an idea I'm entertaining that would address another good point in @larry-safran's feedback - the one about not having error-level message when a test failed (which is certainly expected by folks familiar with absl-style logging). I was thinking to add the plumbing to automatically error-log the exception when a test just failed, before the teardown sequence. This also would solve several other problems as:1. Having to determine that the test failed (or passed) from the fact the teardown sequence started, and not even seeing the error until all tests end.2. The fact that python unittest (and absl) loggers just print (not log, so it doesn't even include the timestamp) errors collected from the all tests at the end of the log, after all tests has completed. This shows these errors out of context, and makes adds unnecessary extra steps for folks investigating an error. They to find the actual failed test among all other, find where it ends, scroll up above the teardown sequence, and find what was the last operation before the teardown. I have documented this process, but it's counterintuitive, and people tend to forget.3. Because of (1) and (2) - not being able to clearly the timestamp of the error occurred. When I requested this info, I had to perform very complicated grep trickery to get the data, and then manually check if the error at the end corresponded to the failed test.",