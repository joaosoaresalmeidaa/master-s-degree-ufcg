user_id,user_login,pull_request_url,comment_id,created_at,path,diff_hunk,content,code_smell
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/4527,58486999,2016-04-05T04:59:06Z,src/nvim/option.c,"@@ -2455,15 +2455,9 @@ did_set_string_option (   }   /* 'helpfile' */   else if (varp == &p_hf) {-    /* May compute new values for $VIM and $VIMRUNTIME */-    if (didset_vim) {-      vim_setenv(""VIM"", """");-      didset_vim = FALSE;-    }-    if (didset_vimruntime) {-      vim_setenv(""VIMRUNTIME"", """");-      didset_vimruntime = FALSE;-    }+    // May compute new values for $VIM and $VIMRUNTIME+    vim_setenv(""VIM"", """");+    vim_setenv(""VIMRUNTIME"", """");","With the old logic, if VIMRUNTIME was inherited from the environment, then `:set helpfile=...` will not unset it. Although this feature probably isn't used much, in general we want to avoid unsetting env vars because it affects `:term`, `:!`, etc. Especially we don't want to do that as a side-effect of `set helpfile`--at least not _more_ often...It's great to remove globals, but these `didset_` globals are mostly harmless as long as they aren't used by many interacting components.",X
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/4540,59116922,2016-04-09T15:38:23Z,test/functional/ui/highlight_spec.lua,"@@ -16,6 +17,91 @@ describe('color scheme compatibility', function()   end) end) +describe('buffer switching leaves manual syntax highlights ok', function()+  -- When using manual syntax highlighting, it should be preserved even when+  -- switching buffers... bug did only occur without :set hidden+  -- Ref: vim patch 7.4.1236+  local screen++  before_each(function()+    clear()+    screen = Screen.new()+    screen:attach()+    --ignore highligting of ~-lines+    screen:set_default_attr_ignore( {{bold=true, foreground=Screen.colors.Blue}} )+    --syntax highlight for vimcscripts ""echo""+    screen:set_default_attr_ids( {{bold=true, foreground=Screen.colors.Brown}} )","please use `[1] =`, even if it's technically redundant, it maintains the visual connection with the usages `{1:...}` below. ",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/4553,59145838,2016-04-11T00:59:38Z,test/functional/provider/define_spec.lua,"@@ -333,6 +333,39 @@ local function function_specs_for(fn, sync, first_arg_factory, init)           runx(sync, handler, on_setup)         end)       end)++      describe('with range', function()","I agree we should move away from the odd pattern in this test. It's come up before, but we keep adding more tests using the existing pattern. @snoe If you wouldn't mind, it would be preferable to collapse each `describe()` block containing a single `it()`, to just an `it()` without a `describe()`.There are no `setup()` nor `teardown()` functions in this file (which apply to `describe()` blocks), so I don't see a reason for the current structure.",X
4466899,tjdevries,https://api.github.com/repos/neovim/neovim/pulls/4489,59554546,2016-04-13T14:11:58Z,test/unit/buffer_spec.lua,"@@ -293,11 +298,131 @@ describe('buffer functions', function()     it('should print the number of lines in the buffer', function()       buffer.setfname(globals.curbuf, to_cstr(""test/unit/buffer_spec.lua""), NULL, 1) -      local width = build_stl_str_hl(""%L"")+      local width = build_stl_str_hl(""%L"", 80)        eq(1, width)       eq(""1"", helpers.ffi.string(output_buffer, width))      end)++    it('should right align when using =', function()+      buffer.setfname(globals.curbuf, to_cstr(""test/unit/buffer_spec.lua""), NULL, 1)++      local expected_width = 20+      local width = build_stl_str_hl(""neo%=vim"", expected_width)++      eq(width, expected_width)+      eq(""neo              vim"", get_str(output_buffer, expected_width))+    end)++    it('should approximately center text when using %=text%=', function()+      buffer.setfname(globals.curbuf, to_cstr(""test/unit/buffer_spec.lua""), NULL, 1)++      local expected_width = 20+      local width = build_stl_str_hl(""abc%=neovim%=def"", expected_width)++      eq(width, expected_width)+      eq(""abc    neovim    def"", get_str(output_buffer, expected_width))+    end)++    it('should completely fill the buffer when using %=text%=', function()+      -- This tests to make sure that it still fills the buffer, even when+      --  we don't have perfectly equal spacing+      buffer.setfname(globals.curbuf, to_cstr(""test/unit/buffer_spec.lua""), NULL, 1)++      local expected_width = 20+      local width = build_stl_str_hl(""abc%=neo_vim%=def"", expected_width)++      eq(width, expected_width)+      eq(""abc   neo_vim    def"", get_str(output_buffer, expected_width))+    end)++    it('should correctly quadrant the text when using 3 %=\'s', function()+      buffer.setfname(globals.curbuf, to_cstr(""test/unit/buffer_spec.lua""), NULL, 1)++      local expected_width = 40+      local width = build_stl_str_hl(""abc%=n%=eovim%=def"", expected_width)++      eq(width, width)+      eq(""abc         n         eovim          def"", get_str(output_buffer, expected_width))+    end)++    it('should truncate when standard text pattern is too long', function()+      -- This is the standard way Vim truncates text when it is too long+      buffer.setfname(globals.curbuf, to_cstr(""test/unit/buffer_spec.lua""), NULL, 1)++      local pat = ""abcneovimdef""+      local expected_width = 10+      local width = build_stl_str_hl(pat, expected_width)++      eq(width, width)+      eq(""<neovimdef"", get_str(output_buffer, expected_width))+    end)++    it('should truncate when using =', function()+      buffer.setfname(globals.curbuf, to_cstr(""test/unit/buffer_spec.lua""), NULL, 1)++      local pat = ""abcdef%=ghijkl""+      local expected_width = 10+      local width = build_stl_str_hl(pat, expected_width)++      eq(width, expected_width)+      -- It puts all of the text that is left aligned in the buffer,+      --    and then truncates the text on the right.+      eq(""abcdef<jkl"",  get_str(output_buffer, expected_width))+    end)++    it('should truncate centered text when using %=%=', function()+      -- Is this a desired behavior?+      buffer.setfname(globals.curbuf, to_cstr(""test/unit/buffer_spec.lua""), NULL, 1)++      local pat = ""abc%=this_text_should_be_gone%=def""+      local expected_width = 7+      local width = build_stl_str_hl(pat, expected_width)++      eq(width, expected_width)+      eq(""abc<def"", get_str(output_buffer, expected_width))+    end)","I'm not sure exactly how to do that. Also, I'm not sure how well supported that is currently. While reading through the code, I saw this:https://github.com/neovim/neovim/blob/master/src/nvim/buffer.c#L2914 ",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/4398,59581496,2016-04-13T16:38:00Z,test/functional/plugin/shada_spec.lua,"@@ -184,7 +154,7 @@ describe('In autoload/shada.vim', function()         '  + b                 2',         '  + c    column       3',         '  + d                 4',-      }, {{type=1, timestamp=0, data=st({a=1, b=2, c=3, d=4})}})","AFAIR it is needed for the test because to check that resulting order does not depend on initial order one needs to have known initial order. Using different order will not make test fail if everything is fine, but it may make test _not_ fail if something is _not_ fine with the ordering. Though it looks like here test was not actually doing what intended: before data reaches tested VimL function it will be transformed into a VimL dictionary: without keeping order obviously.",X
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/4597,60130155,2016-04-18T20:40:26Z,src/nvim/eval.c,"@@ -14456,11 +14456,11 @@ static void f_setreg(typval_T *argvars, typval_T *rettv)   char_u      *strregname;   char_u      *stropt;   bool append = false;-  char_u yank_type;+  MotionType yank_type;   long block_len;    block_len = -1;-  yank_type = MAUTO;+  yank_type = kUnknownMotion;","Dunno,  ""when motion_type == kLineWise, ..."" in a doc/comment (prose) reads naturally as ""when the motion type is linewise"" and is at the same time clear with how the condition looks in code. I can add  MT if the style mandates it but I don't see the value (what usage below is unclear) and why then are we already adding enums that don't follow it.",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/4597,60130640,2016-04-18T20:43:35Z,src/nvim/eval.c,"@@ -14456,11 +14456,11 @@ static void f_setreg(typval_T *argvars, typval_T *rettv)   char_u      *strregname;   char_u      *stropt;   bool append = false;-  char_u yank_type;+  MotionType yank_type;   long block_len;    block_len = -1;-  yank_type = MAUTO;+  yank_type = kUnknownMotion;","It is better to ask people which add enums that do not follow it why. I do not add such enums. Common prefix indicates that value belongs to some enum, it also provides a way to easily search for all places where any enum value is mentioned.",X
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/4618,60395928,2016-04-20T12:12:54Z,test/functional/legacy/eval_spec.lua,"@@ -495,6 +495,18 @@ describe('eval', function()       ' abcE4b10-4\000abcE4b10-4-2')   end) +  it(""setreg('0',getreg('a',1,1)) doesn't crash for unset register"", function()","No, wrong. Do not use `setreg` here _at all_, test that `getreg('a', 1, 1) isnot# v:_null_list`. Or that it can be extended.",X
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/4618,60396151,2016-04-20T12:14:56Z,test/functional/legacy/eval_spec.lua,"@@ -495,6 +495,18 @@ describe('eval', function()       ' abcE4b10-4\000abcE4b10-4-2')   end) +  it(""setreg('0',getreg('a',1,1)) doesn't crash for unset register"", function()","well it is a functional test, `setreg(getreg())` is something a register plugin actually would do.  (and this is a real crash when using my own clipboard manager plugin).But we should fix and test `setreg(""0"", v:_null_list)` as well, for sure (really I would like to just remove NULL list, we can use an interned fixed empty list for that purpose, but there is too many cases to check I guess so we need to support it for now)",X
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/4618,60396787,2016-04-20T12:20:36Z,test/functional/legacy/eval_spec.lua,"@@ -495,6 +495,18 @@ describe('eval', function()       ' abcE4b10-4\000abcE4b10-4-2')   end) +  it(""setreg('0',getreg('a',1,1)) doesn't crash for unset register"", function()","Vim has NULL lists, dictionaries and strings. Hopefully not funcrefs. I do not know a way to produce a NULL dictionary (except for `v:_null_dict`) and did not see crash reports (though most likely there will be some once I start testing), but NULL strings already produced bugs, including the one after which I added `v:_null_���` variables. Since testing that NULL x does not produce a crash is easier then making sure that NULL x does not appear in first place I would suggest to keep them all, but create `test/functional/viml/null_spec.lua` with contents similar to that in #4615.",X
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/4618,60398184,2016-04-20T12:32:33Z,test/functional/legacy/eval_spec.lua,"@@ -495,6 +495,18 @@ describe('eval', function()       ' abcE4b10-4\000abcE4b10-4-2')   end) +  it(""setreg('0',getreg('a',1,1)) doesn't crash for unset register"", function()","well getreg() _sometimes_ is mutable and sometimes not is bad interface, bram agreed that much. This PR is  the neovim resolution of that, as neovim are not as afraid of ""excessive"" memory allocation as vim, so we don't need tricks to fake the mutability of a NULL list and can just alloc it. I will add tests for mutability here.",X
4466899,tjdevries,https://api.github.com/repos/neovim/neovim/pulls/4489,60677705,2016-04-22T00:52:48Z,test/unit/buffer_spec.lua,"@@ -211,93 +212,177 @@ describe('buffer functions', function()   end)    describe('build_stl_str_hl', function()+    local buffer_byte_size = 100+    local STL_MAX_ITEM = 80++    -- This function builds the statusline+    --+    -- @param arg Optional arguments are:+    --    .pat The statusline format string+    --    .fillchar The fill character used in the statusline+    --    .maximum_cell_count The number of cells available in the statusline+    local build_stl_str_hl = function (arg)+      output_buffer = to_cstr(string.rep("" "", buffer_byte_size))++      local pat = arg.pat or ''+      local fillchar = arg.fillchar or (' '):byte()+      local maximum_cell_count = arg.maximum_cell_count or buffer_byte_size -    local output_buffer = to_cstr(string.rep("" "", 100))--    local build_stl_str_hl = function(pat)       return buffer.build_stl_str_hl(globals.curwin,                                      output_buffer,-                                     100,+                                     buffer_byte_size,                                      to_cstr(pat),                                      false,-                                     32,-                                     80,+                                     fillchar,+                                     maximum_cell_count,                                      NULL,                                      NULL)     end -    it('should copy plain text', function()-      local width = build_stl_str_hl(""this is a test"")--      eq(14, width)-      eq(""this is a test"", helpers.ffi.string(output_buffer, width))--    end)--    it('should print no file name', function()-      local width = build_stl_str_hl(""%f"")--      eq(9, width)-      eq(""[No Name]"", helpers.ffi.string(output_buffer, width))--    end)--    it('should print the relative file name', function()-      buffer.setfname(globals.curbuf, to_cstr(""Makefile""), NULL, 1)-      local width = build_stl_str_hl(""%f"")--      eq(8, width)-      eq(""Makefile"", helpers.ffi.string(output_buffer, width))--    end)--    it('should print the full file name', function()-      buffer.setfname(globals.curbuf, to_cstr(""Makefile""), NULL, 1)--      local width = build_stl_str_hl(""%F"")--      assert.is_true(8 < width)-      neq(NULL, string.find(helpers.ffi.string(output_buffer, width), ""Makefile""))--    end)--    it('should print the tail file name', function()-      buffer.setfname(globals.curbuf, to_cstr(""src/nvim/buffer.c""), NULL, 1)--      local width = build_stl_str_hl(""%t"")--      eq(8, width)-      eq(""buffer.c"", helpers.ffi.string(output_buffer, width))--    end)--    it('should print the buffer number', function()-      buffer.setfname(globals.curbuf, to_cstr(""src/nvim/buffer.c""), NULL, 1)--      local width = build_stl_str_hl(""%n"")--      eq(1, width)-      eq(""1"", helpers.ffi.string(output_buffer, width))-    end)--    it('should print the current line number in the buffer', function()-      buffer.setfname(globals.curbuf, to_cstr(""test/unit/buffer_spec.lua""), NULL, 1)--      local width = build_stl_str_hl(""%l"")--      eq(1, width)-      eq(""0"", helpers.ffi.string(output_buffer, width))--    end)--    it('should print the number of lines in the buffer', function()-      buffer.setfname(globals.curbuf, to_cstr(""test/unit/buffer_spec.lua""), NULL, 1)--      local width = build_stl_str_hl(""%L"")+    -- Use this function to simplify testing the comparison between+    --  the format string and the resulting statusline.+    --+    -- @param description The description of what the test should be doing+    -- @param statusline_cell_count The number of cells available in the statusline+    -- @param expected_cell_count The expected number of cells build_stl_str_hl will return+    -- @param expected_byte_length The expected byte length of the string+    -- @param input_stl The format string for the statusline+    -- @param expected_stl The expected result string for the statusline+    local function statusline_test (description,+                                    statusline_cell_count,+                                    expected_cell_count,+                                    expected_byte_length,+                                    input_stl,+                                    expected_stl,+                                    arg)+","@ZyX-I, Is this more in line with what you were thinking for the function that would handle each individual test? I have now removed the `before_each` and made everything I could find local.Do you think it is okay to have the optional parameters in the way that I do? I thought this separated out any concerns between tests giving them each the ability to add a new feature to test whenever they wanted, without having to change the old tests.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/4630,60688220,2016-04-22T03:49:03Z,src/nvim/regexp_nfa.c,"@@ -4853,6 +4854,9 @@ static int nfa_regmatch(nfa_regprog_T *prog, nfa_state_T *start, regsubs_T *subm   fast_breakcheck();   if (got_int)     return FALSE;+  if (nfa_time_limit != NULL && profile_passed_limit(*nfa_time_limit)) {+    return FALSE;","Understood. My last comment was a general comment regarding the alternative (i.e. ""leave the old code alone throughout the entire project""). It doesn't seem to me any worse to assign `false` to `int` than `FALSE`. Because the implied semantics of `FALSE` and `TRUE` are just as wrong as `false` and `true`. A tri-state should be an enum, ideally.",X
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/4630,60688476,2016-04-22T03:54:44Z,src/nvim/regexp_nfa.c,"@@ -6075,6 +6079,13 @@ static int nfa_regmatch(nfa_regprog_T *prog, nfa_state_T *start, regsubs_T *subm     if (got_int) {","That's weird, both `fast_breakcheck` and `line_breakcheck` call `os_breakcheck`. Sounds like a race condition which we should address (i.e. we're only getting lucky that `fast_breakcheck` calls `os_breakcheck` less frequently). Can you post the backtrace?",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/4489,60834504,2016-04-23T20:28:26Z,test/unit/buffer_spec.lua,"@@ -211,93 +212,177 @@ describe('buffer functions', function()   end)    describe('build_stl_str_hl', function()+    local buffer_byte_size = 100+    local STL_MAX_ITEM = 80++    -- This function builds the statusline+    --+    -- @param arg Optional arguments are:+    --    .pat The statusline format string+    --    .fillchar The fill character used in the statusline+    --    .maximum_cell_count The number of cells available in the statusline+    local build_stl_str_hl = function (arg)+      output_buffer = to_cstr(string.rep("" "", buffer_byte_size))++      local pat = arg.pat or ''+      local fillchar = arg.fillchar or (' '):byte()+      local maximum_cell_count = arg.maximum_cell_count or buffer_byte_size -    local output_buffer = to_cstr(string.rep("" "", 100))--    local build_stl_str_hl = function(pat)       return buffer.build_stl_str_hl(globals.curwin,                                      output_buffer,-                                     100,+                                     buffer_byte_size,                                      to_cstr(pat),                                      false,-                                     32,-                                     80,+                                     fillchar,+                                     maximum_cell_count,                                      NULL,                                      NULL)     end -    it('should copy plain text', function()-      local width = build_stl_str_hl(""this is a test"")--      eq(14, width)-      eq(""this is a test"", helpers.ffi.string(output_buffer, width))--    end)--    it('should print no file name', function()-      local width = build_stl_str_hl(""%f"")--      eq(9, width)-      eq(""[No Name]"", helpers.ffi.string(output_buffer, width))--    end)--    it('should print the relative file name', function()-      buffer.setfname(globals.curbuf, to_cstr(""Makefile""), NULL, 1)-      local width = build_stl_str_hl(""%f"")--      eq(8, width)-      eq(""Makefile"", helpers.ffi.string(output_buffer, width))--    end)--    it('should print the full file name', function()-      buffer.setfname(globals.curbuf, to_cstr(""Makefile""), NULL, 1)--      local width = build_stl_str_hl(""%F"")--      assert.is_true(8 < width)-      neq(NULL, string.find(helpers.ffi.string(output_buffer, width), ""Makefile""))--    end)--    it('should print the tail file name', function()-      buffer.setfname(globals.curbuf, to_cstr(""src/nvim/buffer.c""), NULL, 1)--      local width = build_stl_str_hl(""%t"")--      eq(8, width)-      eq(""buffer.c"", helpers.ffi.string(output_buffer, width))--    end)--    it('should print the buffer number', function()-      buffer.setfname(globals.curbuf, to_cstr(""src/nvim/buffer.c""), NULL, 1)--      local width = build_stl_str_hl(""%n"")--      eq(1, width)-      eq(""1"", helpers.ffi.string(output_buffer, width))-    end)--    it('should print the current line number in the buffer', function()-      buffer.setfname(globals.curbuf, to_cstr(""test/unit/buffer_spec.lua""), NULL, 1)--      local width = build_stl_str_hl(""%l"")--      eq(1, width)-      eq(""0"", helpers.ffi.string(output_buffer, width))--    end)--    it('should print the number of lines in the buffer', function()-      buffer.setfname(globals.curbuf, to_cstr(""test/unit/buffer_spec.lua""), NULL, 1)--      local width = build_stl_str_hl(""%L"")+    -- Use this function to simplify testing the comparison between+    --  the format string and the resulting statusline.+    --+    -- @param description The description of what the test should be doing+    -- @param statusline_cell_count The number of cells available in the statusline+    -- @param expected_cell_count The expected number of cells build_stl_str_hl will return+    -- @param expected_byte_length The expected byte length of the string+    -- @param input_stl The format string for the statusline+    -- @param expected_stl The expected result string for the statusline+    local function statusline_test (description,+                                    statusline_cell_count,+                                    expected_cell_count,+                                    expected_byte_length,+                                    input_stl,+                                    expected_stl,+                                    arg)+","I do not like the idea of the function with seven arguments. While it is easy to understand what most of the arguments mean, meanings of the three numbers in the middle are hard to remember. I also think that expected_byte_length may default to expected_cell_count which may default to statusline_cell_count, so some tests will have one or two arguments less.",X
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/4598,61026762,2016-04-26T04:13:48Z,src/nvim/testdir/test_cursor_func.vim,"@@ -0,0 +1,54 @@+"" Tests for cursor().","New tests must be added to `src/nvim/testdir/Makefile`. Then to run the test, 7.4.1092 is needed for `assert_exception`. So I did that in https://github.com/neovim/neovim/pull/4649",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/4654,61154782,2016-04-26T20:06:48Z,test/functional/api/vim_spec.lua,"@@ -1,6 +1,7 @@ -- Sanity checks for vim_* API calls via msgpack-rpc local helpers = require('test.functional.helpers') local Screen = require('test.functional.ui.screen')+local NIL = require('mpack').NIL","well, it is a transitive dependency via the `nvim` module imported in helpers, which is the source of the NIL values, so I think it should be imported via `helpers`",X
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/4652,61194168,2016-04-27T02:03:49Z,src/nvim/eval.c,"@@ -9828,34 +9829,15 @@ static void f_getcwd(typval_T *argvars, typval_T *rettv)     scope_number[i] = argvars[i].vval.v_number;     // The scope is the current iteration step.     scope = i;--    if (scope_number[i] < -1) {-      EMSG(_(e_invarg));-      return;-    }-  }--  // Allocate and initialize the string to return.-  cwd = xmalloc(MAXPATHL);--  // Get the scope and numbers from the arguments-  for (int i = 0; i < MAX_CD_SCOPE; i++) {-    // If there is no argument there are no more scopes after it, break out.-    if (argvars[i].v_type == VAR_UNKNOWN) {-      break;-    }-    scope_number[i] = argvars[i].vval.v_number;-    // The scope is the current iteration step.-    scope = i;     // It is an error for the scope number to be less than `-1`.     if (scope_number[i] < -1) {       EMSG(_(e_invarg));-      goto end;+      return;     }   } -  // If the deepest scope number is `-1` advance the scope.-  if (scope_number[scope] < 0) {+  // If a scope number is `-1` advance the scope by one.+  while (scope_number[scope] < 0 && scope < MAX_CD_SCOPE) {     scope++;","The comment is kind of redundant, maybe this is more meaningful:```// Normalize `-1` scopes.```Also shouldn't the `scope < MAX_CD_SCOPE` condition should go first?```while (scope < MAX_CD_SCOPE && scope_number[scope] < 0) {```",X
4954650,HiPhish,https://api.github.com/repos/neovim/neovim/pulls/4652,61288387,2016-04-27T16:16:09Z,src/nvim/eval.c,"@@ -9828,34 +9829,15 @@ static void f_getcwd(typval_T *argvars, typval_T *rettv)     scope_number[i] = argvars[i].vval.v_number;     // The scope is the current iteration step.     scope = i;--    if (scope_number[i] < -1) {-      EMSG(_(e_invarg));-      return;-    }-  }--  // Allocate and initialize the string to return.-  cwd = xmalloc(MAXPATHL);--  // Get the scope and numbers from the arguments-  for (int i = 0; i < MAX_CD_SCOPE; i++) {-    // If there is no argument there are no more scopes after it, break out.-    if (argvars[i].v_type == VAR_UNKNOWN) {-      break;-    }-    scope_number[i] = argvars[i].vval.v_number;-    // The scope is the current iteration step.-    scope = i;     // It is an error for the scope number to be less than `-1`.     if (scope_number[i] < -1) {       EMSG(_(e_invarg));-      goto end;+      return;     }   } -  // If the deepest scope number is `-1` advance the scope.-  if (scope_number[scope] < 0) {+  // If a scope number is `-1` advance the scope by one.+  while (scope_number[scope] < 0 && scope < MAX_CD_SCOPE) {     scope++;","Another idea would be to forbid the last argument from being `-1` instead of implicitly moving a scope up. So `getcwd(-1)` throws an error instead of being equivalent to `getcwd(-1,0)`. Similarly `getcwd(-1,-1)` would be an error as well. But what about is we want the global working directory? In that case the user would have to call `getcwd(-1,-1,0)`, but this would break if a scope was later added between tab and global because the `0` would no longer refer to global but to whatever comes in between. I don't think we should do that.You right about making the comment less verbose, I'll split it up in two comments, one before the `if` and one inside, that's still the same amount of extra lines, but it's easier on the eyes.",X
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/4652,61290936,2016-04-27T16:30:55Z,src/nvim/eval.c,"@@ -9828,34 +9829,15 @@ static void f_getcwd(typval_T *argvars, typval_T *rettv)     scope_number[i] = argvars[i].vval.v_number;     // The scope is the current iteration step.     scope = i;--    if (scope_number[i] < -1) {-      EMSG(_(e_invarg));-      return;-    }-  }--  // Allocate and initialize the string to return.-  cwd = xmalloc(MAXPATHL);--  // Get the scope and numbers from the arguments-  for (int i = 0; i < MAX_CD_SCOPE; i++) {-    // If there is no argument there are no more scopes after it, break out.-    if (argvars[i].v_type == VAR_UNKNOWN) {-      break;-    }-    scope_number[i] = argvars[i].vval.v_number;-    // The scope is the current iteration step.-    scope = i;     // It is an error for the scope number to be less than `-1`.     if (scope_number[i] < -1) {       EMSG(_(e_invarg));-      goto end;+      return;     }   } -  // If the deepest scope number is `-1` advance the scope.-  if (scope_number[scope] < 0) {+  // If a scope number is `-1` advance the scope by one.+  while (scope_number[scope] < 0 && scope < MAX_CD_SCOPE) {     scope++;",> but this would break if a scope was later added between tab and global because the 0 would no longer refer to global but to whatever comes in between. I don't think we should do that.Agreed.,X
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/4588,61362978,2016-04-28T01:26:44Z,runtime/doc/eval.txt,"@@ -2007,6 +2007,7 @@ range( {expr} [, {max} [, {stride}]]) readfile( {fname} [, {binary} [, {max}]]) 				List	get list of lines from file {fname} reltime( [{start} [, {end}]])	List	get time value+reltimefloat({time})		Float	turn the time value into a Float",The space after the paren in this list of functions is intentional so that `ctrl-]` works. ```reltimefloat( {time})```,
4117685,KillTheMule,https://api.github.com/repos/neovim/neovim/pulls/4654,61467587,2016-04-28T17:23:39Z,test/unit/mbyte_spec.lua,"@@ -153,39 +137,33 @@ describe('mbyte', function()       eq(0x007f, mbyte.utfc_ptr2char_len(to_string({0x7f, 0x7f, 0xcc, 0x80, 0x80}), pcc, 5))       eq(0, pcc[0])       -- No second UTF-8 character-      local pcc = to_intp()       eq(0x007f, mbyte.utfc_ptr2char_len(to_string({0x7f, 0xc2, 0xcc, 0x80, 0x80}), pcc, 5))       eq(0, pcc[0])        -- Combining character U+0300-      local pcc = to_intp()       eq(0x007f, mbyte.utfc_ptr2char_len(to_string({0x7f, 0xcc, 0x80, 0xcc}), pcc, 5))       eq(0x0300, pcc[0])       eq(0x0000, pcc[1])        -- Combining characters U+0300 and U+0301-      local pcc = to_intp()","Ugh, you're right, I totally ignored that this is a cdata object! I'll clear that up, thanks!",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/4597,61687538,2016-05-01T14:06:54Z,src/nvim/ops.c,"@@ -5013,24 +5020,24 @@ void write_reg_contents_ex(int name, /// When the register is not empty, the string is appended. /// /// @param y_ptr pointer to yank register-/// @param yank_type MCHAR, MLINE, MBLOCK or MAUTO+/// @param yank_type The motion type (kMTUnknown to auto detect) /// @param str string or list of strings to put in register /// @param len length of the string (Ignored when str_list=true.) /// @param blocklen width of visual block, or -1 for ""I don't know."" /// @param str_list True if str is `char_u **`.-static void str_to_reg(yankreg_T *y_ptr, int yank_type, const char_u *str,-                       size_t len, colnr_T blocklen, bool str_list)+static void str_to_reg(yankreg_T *y_ptr, MotionType yank_type,+                       const char_u *str, size_t len, colnr_T blocklen,+                       bool str_list)   FUNC_ATTR_NONNULL_ALL {   if (y_ptr->y_array == NULL) {  // NULL means empty register     y_ptr->y_size = 0;   } -  int type = yank_type;  // MCHAR, MLINE or MBLOCK-  if (yank_type == MAUTO) {-    type = ((str_list ||-             (len > 0 && (str[len - 1] == NL || str[len - 1] == CAR)))-            ? MLINE : MCHAR);+  if (yank_type == kMTUnknown) {+    yank_type = ((str_list ||",Assigning to a parameter is generally discouraged.,X
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/4697,61858032,2016-05-03T09:39:34Z,test/functional/eval/capture_spec.lua,"@@ -0,0 +1,39 @@+local helpers = require('test.functional.helpers')+local eq = helpers.eq+local eval = helpers.eval+local clear = helpers.clear+local execute = helpers.execute+local source = helpers.source++describe('capture()', function()+  before_each(clear)++  it('returns the same result with :redir', function()+    execute('redir => g:foo | messages | redir END')+    eq(eval('g:foo'), eval('capture("":messages"")'))+  end)++  it('returns the output of the commands if the argument is List', function()+    eq(""foobar"", eval([[capture(['echon ""foo""', 'echon ""bar""'])]]))+  end)++  it('supports the nested redirection', function()+    source([[+    function! g:Foo()+      let a = ''+      redir => a+      silent echon ""foo""+      redir END+      return a+    endfunction+    function! g:Bar()+      let a = ''+      redir => a+      call g:Foo()+      redir END+      return a+    endfunction+    ]])+    eq('foo', eval('capture(""call g:Bar()"")'))+  end)","Missing tests:1. Nested `capture('echo capture(""echo 42"")')`.2. Nested `redir => g:mes|echo capture('echo capture(""redir => g:mes2|echo 42|redir END"")')|redir END` (check `g:mes` and `g:mes2`). No functions!3. `capture([])`4. `capture(v:_null_list)`5. Errors: `capture(0.0)`, `capture(v:_null_dict)`, `capture(function('tr'))` (use `exc_exec`).6. Errors: same, but inside a list. Better check separately when invalid type has neither first nor last element of the list. Here  and previously `redir_exec` with `echo capture()` may be used if you think that output of `capture()` in case of error should be something specific, otherwise `exc_exec`.",X
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/4697,61858123,2016-05-03T09:40:28Z,src/nvim/eval.c,"@@ -8021,6 +8022,40 @@ static void f_call(typval_T *argvars, typval_T *rettv)   (void)func_call(func, &argvars[1], selfdict, rettv); } +// ""capture(command)"" function+static void f_capture(typval_T *argvars, typval_T *rettv)+{+    int save_msg_silent = msg_silent;+    garray_T *save_capture_ga = capture_ga;++    if (check_secure()) {+      return;+    }++    capture_ga = xmalloc(sizeof(garray_T));+    ga_init(capture_ga, (int)sizeof(char), 80);++    msg_silent++;+    if (argvars[0].v_type == VAR_LIST) {+      listitem_T *li;+      for (li = argvars[0].vval.v_list->lv_first;+           li != NULL; li = li->li_next) {+        do_cmdline_cmd((char *)get_tv_string(&li->li_tv));+      }+    } else {+      do_cmdline_cmd((char *)get_tv_string(&argvars[0]));+    }+    msg_silent = save_msg_silent;++    ga_append(capture_ga, NUL);+    rettv->v_type = VAR_STRING;+    rettv->vval.v_string = vim_strsave((char_u *)capture_ga->ga_data);","Do not copy string here. This is absolutely useless action, you _already_ have an allocated string, just use it. And remove `ga_clear`.",X
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/4697,61861034,2016-05-03T10:10:52Z,src/nvim/message.c,"@@ -2383,6 +2383,15 @@ static void redir_write(char_u *str, int maxlen)   char_u      *s = str;   static int cur_col = 0; +  // Append output to capture().+  if (capture_ga) {+    int len = maxlen > 0 ? maxlen : (int)STRLEN(str);","Also this line is incorrect as I see handling of `maxlen` below:1. Documentations states that you should check for `maxlen == -1`. Below code checks that `maxlen < 0`. Negation is `maxlen >= 0`. You have `maxlen > 0`.2. Below cycle has `*s != NUL && (maxlen < 0 || (int)(s - str) < maxlen`. Note the first condition: `maxlen` is _maximal_ length of the string, not _exact_ length. Based on the code I see this should not lead to any bugs now, but this still is not correct. `strlen()` should be computed always. Though based on the code I could say that you may just rename `maxlen` argument of this and `msg_puts_attr_len` (the only place where `redir_write` is called not with `-1`) to just `len` and treat it as the actual length.",X
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/4697,61861499,2016-05-03T10:16:13Z,src/nvim/message.c,"@@ -2383,6 +2383,15 @@ static void redir_write(char_u *str, int maxlen)   char_u      *s = str;   static int cur_col = 0; +  // Append output to capture().+  if (capture_ga) {+    int len = maxlen > 0 ? maxlen : (int)STRLEN(str);+    ga_grow(capture_ga, len);+    memmove((char *)capture_ga->ga_data","Actually not `memmove` and not `memcpy` and not `ga_grow`. Neovim has `ga_concat_len` function just for this purpose. Basically``` Cif (len < 0) {  ga_concat(capture_ga, str);} else {  ga_concat_len(capture_ga, str, len);}```if you accept the renaming of `maxlen`. Or``` Csize_t len = STRLEN(str);if (maxlen < 0 && len > maxlen) {  len = (size_t) maxlen;}ga_concat_len(capture_ga, str, len);```if you do not. I do not know why Vim does not have this function, I added it in a somewhat similar situation.",X
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/4626,61926723,2016-05-03T18:01:34Z,src/nvim/buffer.c,"@@ -2200,8 +2200,11 @@ void buflist_list(exarg_T *eap)         (buf->b_nwindows == 0 ? 'h' : 'a'),         !MODIFIABLE(buf) ? '-' : (buf->b_p_ro ? '=' : ' '),         (buf->b_flags & BF_READERR) ? 'x'-        : (bufIsChanged(buf) ? '+' : ' '),-        NameBuff);+         : (bufIsChanged(buf) ? '+' : ' '),+         NameBuff);+    if (len > IOSIZE - 20) {+        len = IOSIZE - 20;",Indentation to big.,X
4117685,KillTheMule,https://api.github.com/repos/neovim/neovim/pulls/4707,61995119,2016-05-04T06:48:44Z,src/nvim/getchar.c,"@@ -264,16 +266,16 @@ add_buff (   buf->bh_index = 0;    ssize_t len;-  if (buf->bh_space >= (int)slen) {-    len = STRLEN(buf->bh_curr->b_str);+  if (buf->bh_space >= slen) {+    len = (ssize_t)STRLEN(buf->bh_curr->b_str);     STRLCPY(buf->bh_curr->b_str + len, s, slen + 1);-    buf->bh_space -= slen;+    buf->bh_space -= (int)slen;","Things like this make me uncomfortable. If this cast is ok without checks, why is `slen` not an `int` to begin with?From the projects perspective, this does not really change anything, because that was a cast `long ->  int` before, which basically has the same problem (maybe not in the platforms nvim runs on, but is that an assumption that should be considered valid forever?).",X
715238,equalsraf,https://api.github.com/repos/neovim/neovim/pulls/4705,62161279,2016-05-05T08:39:03Z,src/nvim/os/fs.c,"@@ -148,11 +148,7 @@ int os_nodetype(const char *name)     case UV_TCP:         // unix only     case UV_UNKNOWN_HANDLE:     default:-#ifdef WIN32-      nodetype = NODE_OTHER;",Its not clear to me whether the original [mch_nodetype](https://github.com/vim/vim/blob/4445f7ee708f1a1304526a5979c9dd9883a92a0a/src/os_win32.c#L3510) would return NODE_OTHER or not. The docs don't mention what happens if  `GetFileType(ERROR_FILE_NOT_FOUND)`.Now that I look at it NODE_WRITABLE seems wrong (https://msdn.microsoft.com/en-us/library/windows/desktop/aa364960%28v=vs.85%29.aspx) since its meant for devices not files. So NODE_NORMAL should be used for non existing files.,X
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/4697,62412521,2016-05-07T05:49:00Z,test/functional/eval/capture_spec.lua,"@@ -0,0 +1,72 @@+local helpers = require('test.functional.helpers')+local eq = helpers.eq+local eval = helpers.eval+local clear = helpers.clear+local source = helpers.source+local redir_exec = helpers.redir_exec+local exc_exec = helpers.exc_exec+local funcs = helpers.funcs++describe('capture()', function()+  before_each(clear)++  it('returns the same result with :redir', function()+    eq(redir_exec('messages'), funcs.capture('messages'))+  end)++  it('returns the output of the commands if the argument is List', function()+    eq(""foobar"", funcs.capture({'echon ""foo""', 'echon ""bar""'}))+    eq(""\nfoo\nbar"", funcs.capture({'echo ""foo""', 'echo ""bar""'}))+  end)++  it('supports the nested redirection', function()+    source([[+    function! g:Foo()+      let a = ''+      redir => a+      silent echon ""foo""+      redir END+      return a+    endfunction+    function! g:Bar()+      let a = ''+      redir => a+      call g:Foo()+      redir END+      return a+    endfunction+    ]])+    eq('foo', funcs.capture('call g:Bar()'))++    eq('42', funcs.capture([[echon capture(""echon capture('echon 42')""]]))+  end)++  it('supports the nested echo', function()+    eq('42', funcs.capture('echon capture(""echon 42"")'))+  end)++  it('returns the literal string', function()+    eq('^A', funcs.capture('echon ""\\<C-a>""'))+  end)++  it('returns the empty string if the argument list is empty', function()+    eq('', funcs.capture({}))+    exc_exec('let g:ret = capture(v:_null_list)')","If you use `exc_exec` then you need to test its output: `eq(0, exc_exec(���))`. Otherwise what you do is silencing the exceptions.",X
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/4697,62412592,2016-05-07T05:59:31Z,runtime/doc/eval.txt,"@@ -2476,6 +2477,20 @@ call({func}, {arglist} [, {dict}])			*call()* *E699* 		{dict} is for functions with the ""dict"" attribute.  It will be 		used to set the local variable ""self"". |Dictionary-function| +capture({command})					*capture()*+		Capture output of {command}.+		If {command} is a |String|, it returns {command} output.+		If {command} is a |List|, it returns all results of {command}+		outputs of each items.",Better ������ it returns concatenated outputs of each list item.���,X
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/4697,62664707,2016-05-10T12:50:35Z,runtime/doc/eval.txt,"@@ -2476,6 +2477,20 @@ call({func}, {arglist} [, {dict}])			*call()* *E699* 		{dict} is for functions with the ""dict"" attribute.  It will be 		used to set the local variable ""self"". |Dictionary-function| +capture({command})					*capture()*+		Capture output of {command}.+		If {command} is a |String|, it returns {command} output.+		If {command} is a |List|, it returns concatenated outputs of+		each items.","���Items��� is still plural.---By the way, I see `f_capture` is using msg_silent. If I am not mistaking, this is like `:silent` (without bang), but this fact is neither expressed in a help nor is tested. I think that1. Here another paragraph is needed telling that ���Commands are run as if they were prepended with |:silent| modifier.{two spaces}|:redir| and capture() work in parallel: capture() does not cancel |:redir|, |:redir| does not cancel capture().{two spaces}capture() inside capture() is allowed unlike nested |:redir|s, outer capture will not catch commands��� output of the inner one, but inner will neither cancel outer.���2. Add test like      ``` lua     it('silences command run inside', function()         local screen = Screen.new()         screen:attach()         screen:set_default_attr_ignore( {{bold=true, foreground=255}} )         feed(':let g:mes = capture(""echo 42"")<CR>')         screen:expect([[         ^                                                     |         ~                                                    |         ~                                                    |         ~                                                    |         ~                                                    |         ~                                                    |         ~                                                    |         ~                                                    |         ~                                                    |         ~                                                    |         ~                                                    |         ~                                                    |         [No Name]                                            |                                                              |       ]])       eq('42', meths.get_var('msg'))     end)   ```      (last line may actually be `:let ���`, but in any case there should not be line containing ���42���.)",X
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/4646,62743111,2016-05-10T20:12:27Z,src/nvim/event/process.c,"@@ -333,9 +333,47 @@ static void process_close(Process *proc)   } } +/// Flush output stream.+///+/// @param proc     Process, for which an output stream should be flushed.+/// @param stream   Stream to flush.+static void flush_stream(Process *proc, Stream *stream)+  FUNC_ATTR_NONNULL_ARG(1)+{+  if (!stream || stream->closed) {+    return;+  }++  // Limit amount of data we accept after process terminated.+  size_t max_bytes = stream->num_bytes + rbuffer_capacity(stream->buffer);++  while (!stream->closed && stream->num_bytes < max_bytes) {+    // Remember number of bytes before polling+    size_t num_bytes = stream->num_bytes;++    // Poll for data and process the generated events.+    loop_poll_events(&loop, 0);+    if (proc->events && !queue_empty(proc->events)) {+      queue_process_events(proc->events);+    }++    // Stream can be closed if it is empty.+    if (num_bytes == stream->num_bytes) {+      break;+    }+  }+}+ static void process_close_handles(void **argv) {   Process *proc = argv[0];++  // Did our process forked a child that keeps the output streams open?+  if (!process_is_tearing_down) {","How about a TODO here mentioning ""there could be some data loss when nvim exits and does not check the open streams.""",X
112971,jamessan,https://api.github.com/repos/neovim/neovim/pulls/4742,62945807,2016-05-11T23:44:47Z,scripts/vim-patch.sh,"@@ -132,37 +132,54 @@ get_vim_patch() {    # Patch surgery: preprocess the patch.   #   - transform src/ paths to src/nvim/-  local vim_full=""$(git show -1 --pretty=medium ""${vim_commit}"" \+  local vim_full+  vim_full=""$(git show -1 --pretty=medium ""${vim_commit}"" \     | LC_ALL=C sed -e 's/\( [ab]\/src\)/\1\/nvim/g')""   local neovim_branch=""${BRANCH_PREFIX}${vim_version}""    cd ""${NEOVIM_SOURCE_DIR}""-  local git_remote=$(find_git_remote)-  local checked_out_branch=""$(git rev-parse --abbrev-ref HEAD)""+  local git_remote+  git_remote=$(find_git_remote)+  local checked_out_branch+  checked_out_branch=""$(git rev-parse --abbrev-ref HEAD)""    if [[ ""${checked_out_branch}"" == ${BRANCH_PREFIX}* ]]; then     echo ""��� Current branch '${checked_out_branch}' seems to be a vim-patch""     echo ""  branch; not creating a new branch.""   else     echo     echo ""Fetching '${git_remote}/master'.""-    output=""$(git fetch ""${git_remote}"" master 2>&1)"" &&-      echo ""��� ${output}"" ||+    output=""$(git fetch ""${git_remote}"" master 2>&1)""+    if [[ $output ]]+    then+      echo ""��� ${output}""+    else       (echo ""��� ${output}""; false)+    fi      echo     echo ""Creating new branch '${neovim_branch}' based on '${git_remote}/master'.""     cd ""${NEOVIM_SOURCE_DIR}""-    output=""$(git checkout -b ""${neovim_branch}"" ""${git_remote}/master"" 2>&1)"" &&-      echo ""��� ${output}"" ||+++    output=""$(git checkout -b ""${neovim_branch}"" ""${git_remote}/master"" 2>&1)""+    if [[ $output ]]+    then+      echo ""��� ${output}""+    else       (echo ""��� ${output}""; false)","Yes, the `set -e` is what requires this.  This change now means that if `git checkout` errors, the script immediately exits instead of chaining through to the `(echo ""��� ${output}""; false)`.",X
112971,jamessan,https://api.github.com/repos/neovim/neovim/pulls/4742,62946225,2016-05-11T23:49:51Z,scripts/vim-patch.sh,"@@ -132,37 +132,54 @@ get_vim_patch() {    # Patch surgery: preprocess the patch.   #   - transform src/ paths to src/nvim/-  local vim_full=""$(git show -1 --pretty=medium ""${vim_commit}"" \+  local vim_full+  vim_full=""$(git show -1 --pretty=medium ""${vim_commit}"" \     | LC_ALL=C sed -e 's/\( [ab]\/src\)/\1\/nvim/g')""   local neovim_branch=""${BRANCH_PREFIX}${vim_version}""    cd ""${NEOVIM_SOURCE_DIR}""-  local git_remote=$(find_git_remote)-  local checked_out_branch=""$(git rev-parse --abbrev-ref HEAD)""+  local git_remote+  git_remote=$(find_git_remote)+  local checked_out_branch+  checked_out_branch=""$(git rev-parse --abbrev-ref HEAD)""    if [[ ""${checked_out_branch}"" == ${BRANCH_PREFIX}* ]]; then     echo ""��� Current branch '${checked_out_branch}' seems to be a vim-patch""     echo ""  branch; not creating a new branch.""   else     echo     echo ""Fetching '${git_remote}/master'.""-    output=""$(git fetch ""${git_remote}"" master 2>&1)"" &&-      echo ""��� ${output}"" ||+    output=""$(git fetch ""${git_remote}"" master 2>&1)""+    if [[ $output ]]",Ditto here about going back to chaining the commands.,X
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/4646,63277000,2016-05-14T14:35:46Z,src/nvim/event/process.c,"@@ -333,9 +333,47 @@ static void process_close(Process *proc)   } } +/// Flush output stream.+///+/// @param proc     Process, for which an output stream should be flushed.+/// @param stream   Stream to flush.+static void flush_stream(Process *proc, Stream *stream)+  FUNC_ATTR_NONNULL_ARG(1)+{+  if (!stream || stream->closed) {+    return;+  }++  // Limit amount of data we accept after process terminated.+  size_t max_bytes = stream->num_bytes + rbuffer_capacity(stream->buffer);++  while (!stream->closed && stream->num_bytes < max_bytes) {+    // Remember number of bytes before polling+    size_t num_bytes = stream->num_bytes;++    // Poll for data and process the generated events.+    loop_poll_events(&loop, 0);+    if (proc->events && !queue_empty(proc->events)) {+      queue_process_events(proc->events);+    }++    // Stream can be closed if it is empty.+    if (num_bytes == stream->num_bytes) {+      break;+    }+  }+}+ static void process_close_handles(void **argv) {   Process *proc = argv[0];++  // Did our process forked a child that keeps the output streams open?+  if (!process_is_tearing_down) {","After commit fixup2 there should only be data loss for a child process that keeps the streams open.  Otherwise something like this`:!./a.out` with `a.out` from``` c#include <stdio.h>#include <stdlib.h>#include <unistd.h>int main(int argc, char *argv[]){  pid_t cpid = fork();  if (cpid == -1) {    perror(""fork"");    exit(EXIT_FAILURE);  }  if (cpid == 0) {    char* arg[]={""/usr/bin/yes"",NULL};    execv(""/usr/bin/yes"",arg);    _exit(EXIT_SUCCESS);  } else {     sleep(3);    exit(EXIT_SUCCESS);  }}```would block forever and nvim could not exit (without data loss).",X
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/4755,63277427,2016-05-14T15:14:43Z,config/CMakeLists.txt,"@@ -67,14 +67,25 @@ if(HAVE_LANGINFO_H)   check_symbol_exists(CODESET ""langinfo.h"" HAVE_NL_LANGINFO_CODESET) endif() +check_include_files(""endian.h"" HAVE_ENDIAN_H)+check_include_files(""sys/endian.h"" HAVE_SYS_ENDIAN_H)++if(HAVE_ENDIAN_H)+  set(ENDIAN_INCLUDE_FILE ""endian.h"")+elseif(HAVE_SYS_ENDIAN_H)+  set(ENDIAN_INCLUDE_FILE ""sys/endian.h"")+else()+  set(ENDIAN_INCLUDE_FILE ""endian.h"")+endif()","It would be more logical to write as```set(ENDIAN_INCLUDE_FILE ""endian.h"")if(HAVE_SYS_ENDIAN_H)  if(NOT HAVE_ENDIAN_H)    set(ENDIAN_INCLUDE_FILE ""sys/endian.h"")  endif()endif()```(maybe conditions may be joined like `HAVE_SYS_ENDIAN_H AND NOT HAVE_ENDIAN_H`, but I am not sure when this works and when not).",X
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/4697,63289449,2016-05-15T10:20:30Z,runtime/doc/eval.txt,"@@ -2476,6 +2477,28 @@ call({func}, {arglist} [, {dict}])			*call()* *E699* 		{dict} is for functions with the ""dict"" attribute.  It will be 		used to set the local variable ""self"". |Dictionary-function| +capture({command})					*capture()*+		Capture output of {command}.+		If {command} is a |String|, it returns {command} output.+		If {command} is a |List|, it returns concatenated outputs of+		each item.+		Examples: >+			let a = capture('echon ""foo""')+			echo a+<			foo >+			let a = capture(['echon ""foo""', 'echon ""bar""'])+			echo a+<			foobar+		This function is not available in the |sandbox|.+		Note: The commands are run as if they were prepended with+		|:silent| modifier.  |:redir| and |capture()| work in parallel:+		|capture()| does not cancel |:redir|, |:redir| does not cancel+		|capture()|.  |capture()| inside |capture()| is allowed+		unlike nested |:redir|s, outer capture will not catch+		commands' output of the inner one, but inner will neither+		cancel outer.+		Note: The attributes are ignored.","I am not sure that user will understand WTF are ���attributes���. Even `:echohl` documentation call this ���highlight group���, so better write ���Note: highlighting is ignored.���I would also say that I think that function name is fine, but it is reasonable to mention it under `:h :redir`. It already lists one alternative, you may add more:> Alternatives are the 'verbosefile' option and the |capture()| function, both can be used in combination with "":redir"".",X
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/4744,63295410,2016-05-15T17:45:45Z,test/functional/ui/highlight_spec.lua,"@@ -303,3 +303,248 @@ describe('Default highlight groups', function()     ]], {[1] = {foreground = Screen.colors.Red, background = Screen.colors.Green}})   end) end)++describe('Cursorline highlight', function()","```describe(""'cursorline' with 'listchars'"", function()```",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/4764,63298596,2016-05-15T21:56:24Z,test/functional/terminal/ex_terminal_spec.lua,"@@ -51,10 +45,15 @@ describe(':terminal', function()       ready $ echo 'hello' \ ""world""                    |                                                         |       [Process exited 0]                                |-                                                        |-                                                        |-                                                        |       -- TERMINAL --                                    |     ]])   end)++  it('ex_terminal() double-free #4554', function()+    source([[+      autocmd BufNew * set shell=foo+      terminal]])","This correctly invoked the ASan failure:```===================================================================12080==ERROR: AddressSanitizer: attempting double-free on 0x60600000c140 in thread T0:    #0 0x4f1f72 in __interceptor_free (/home/travis/build/neovim/neovim/build/bin/nvim+0x4f1f72)    #1 0x2073d25 in xfree /home/travis/build/neovim/neovim/src/nvim/memory.c:105:3    #2 0x1527fe5 in ex_terminal /home/travis/build/neovim/neovim/src/nvim/ex_docmd.c:9516:5    #3 0x141c2e0 in do_one_cmd /home/travis/build/neovim/neovim/src/nvim/ex_docmd.c:2191:15    #4 0x13ce683 in do_cmdline /home/travis/build/neovim/neovim/src/nvim/ex_docmd.c:601:20    #5 0x138a55d in do_source /home/travis/build/neovim/neovim/src/nvim/ex_cmds2.c:2611:3    #6 0x1380347 in cmd_source /home/travis/build/neovim/neovim/src/nvim/ex_cmds2.c:2323:12    #7 0x1380853 in ex_source /home/travis/build/neovim/neovim/src/nvim/ex_cmds2.c:2301:3    #8 0x141c2e0 in do_one_cmd /home/travis/build/neovim/neovim/src/nvim/ex_docmd.c:2191:15    #9 0x13ce683 in do_cmdline /home/travis/build/neovim/neovim/src/nvim/ex_docmd.c:601:20    #10 0x13dd51c in do_cmdline_cmd /home/travis/build/neovim/neovim/src/nvim/ex_docmd.c:274:10    #11 0x68414a in vim_command /home/travis/build/neovim/neovim/src/nvim/api/vim.c:43:3    #12 0x599ed9 in handle_vim_command /home/travis/build/neovim/neovim/build/src/nvim/auto/msgpack_dispatch.c:2128:3    #13 0x2348725 in on_request_event /home/travis/build/neovim/neovim/src/nvim/msgpack_rpc/channel.c:481:19    #14 0x118ff42 in queue_process_events /home/travis/build/neovim/neovim/src/nvim/event/queue.c:142:7    #15 0x25cb500 in nv_event /home/travis/build/neovim/neovim/src/nvim/normal.c:7876:3    #16 0x249de83 in normal_execute /home/travis/build/neovim/neovim/src/nvim/normal.c:1144:12    #17 0x3822e33 in state_enter /home/travis/build/neovim/neovim/src/nvim/state.c:55:26    #18 0x23e38b4 in normal_enter /home/travis/build/neovim/neovim/src/nvim/normal.c:464:3    #19 0x1cfcbb7 in main /home/travis/build/neovim/neovim/src/nvim/main.c:538:3    #20 0x2b01b582a76c in __libc_start_main /build/eglibc-rrybNj/eglibc-2.15/csu/libc-start.c:226    #21 0x46b268 in _start (/home/travis/build/neovim/neovim/build/bin/nvim+0x46b268)0x60600000c140 is located 0 bytes inside of 54-byte region [0x60600000c140,0x60600000c176)freed by thread T0 here:    #0 0x4f1f72 in __interceptor_free (/home/travis/build/neovim/neovim/build/bin/nvim+0x4f1f72)    #1 0x2073d25 in xfree /home/travis/build/neovim/neovim/src/nvim/memory.c:105:3    #2 0x27e3108 in free_string_option /home/travis/build/neovim/neovim/src/nvim/option.c:2165:5    #3 0x2888a5f in did_set_string_option /home/travis/build/neovim/neovim/src/nvim/option.c:3142:7    #4 0x2811cd2 in do_set /home/travis/build/neovim/neovim/src/nvim/option.c:1733:22    #5 0x15120d4 in ex_set /home/travis/build/neovim/neovim/src/nvim/ex_docmd.c:9393:9    #6 0x141c2e0 in do_one_cmd /home/travis/build/neovim/neovim/src/nvim/ex_docmd.c:2191:15    #7 0x13ce683 in do_cmdline /home/travis/build/neovim/neovim/src/nvim/ex_docmd.c:601:20    #8 0x191d06f in apply_autocmds_group /home/travis/build/neovim/neovim/src/nvim/fileio.c:6711:5    #9 0x18e7ff2 in apply_autocmds /home/travis/build/neovim/neovim/src/nvim/fileio.c:6358:10    #10 0x70d323 in buflist_new /home/travis/build/neovim/neovim/src/nvim/buffer.c:1490:5    #11 0x122cb59 in do_ecmd /home/travis/build/neovim/neovim/src/nvim/ex_cmds.c:2168:13    #12 0x14a4f39 in do_exedit /home/travis/build/neovim/neovim/src/nvim/ex_docmd.c:6618:9    #13 0x14b8769 in ex_edit /home/travis/build/neovim/neovim/src/nvim/ex_docmd.c:6541:3    #14 0x141c2e0 in do_one_cmd /home/travis/build/neovim/neovim/src/nvim/ex_docmd.c:2191:15    #15 0x13ce683 in do_cmdline /home/travis/build/neovim/neovim/src/nvim/ex_docmd.c:601:20    #16 0x13dd51c in do_cmdline_cmd /home/travis/build/neovim/neovim/src/nvim/ex_docmd.c:274:10    #17 0x1527eaf in ex_terminal /home/travis/build/neovim/neovim/src/nvim/ex_docmd.c:9513:3    #18 0x141c2e0 in do_one_cmd /home/travis/build/neovim/neovim/src/nvim/ex_docmd.c:2191:15    #19 0x13ce683 in do_cmdline /home/travis/build/neovim/neovim/src/nvim/ex_docmd.c:601:20    #20 0x138a55d in do_source /home/travis/build/neovim/neovim/src/nvim/ex_cmds2.c:2611:3    #21 0x1380347 in cmd_source /home/travis/build/neovim/neovim/src/nvim/ex_cmds2.c:2323:12    #22 0x1380853 in ex_source /home/travis/build/neovim/neovim/src/nvim/ex_cmds2.c:2301:3    #23 0x141c2e0 in do_one_cmd /home/travis/build/neovim/neovim/src/nvim/ex_docmd.c:2191:15    #24 0x13ce683 in do_cmdline /home/travis/build/neovim/neovim/src/nvim/ex_docmd.c:601:20    #25 0x13dd51c in do_cmdline_cmd /home/travis/build/neovim/neovim/src/nvim/ex_docmd.c:274:10    #26 0x68414a in vim_command /home/travis/build/neovim/neovim/src/nvim/api/vim.c:43:3    #27 0x599ed9 in handle_vim_command /home/travis/build/neovim/neovim/build/src/nvim/auto/msgpack_dispatch.c:2128:3    #28 0x2348725 in on_request_event /home/travis/build/neovim/neovim/src/nvim/msgpack_rpc/channel.c:481:19    #29 0x118ff42 in queue_process_events /home/travis/build/neovim/neovim/src/nvim/event/queue.c:142:7previously allocated by thread T0 here:    #0 0x4f2252 in malloc (/home/travis/build/neovim/neovim/build/bin/nvim+0x4f2252)    #1 0x2072f35 in try_malloc /home/travis/build/neovim/neovim/src/nvim/memory.c:59:15    #2 0x2073981 in xmalloc /home/travis/build/neovim/neovim/src/nvim/memory.c:93:15    #3 0x20752b4 in xmallocz /home/travis/build/neovim/neovim/src/nvim/memory.c:168:15    #4 0x20756a9 in xmemdupz /home/travis/build/neovim/neovim/src/nvim/memory.c:186:17    #5 0x20798d8 in xstrdup /home/travis/build/neovim/neovim/src/nvim/memory.c:378:10    #6 0x38237eb in vim_strsave /home/travis/build/neovim/neovim/src/nvim/strings.c:52:20    #7 0x28b2a35 in set_string_option /home/travis/build/neovim/neovim/src/nvim/option.c:2334:7    #8 0x27dbdd7 in set_option_value /home/travis/build/neovim/neovim/src/nvim/option.c:4653:14    #9 0x6782dc in set_option_value_err /home/travis/build/neovim/neovim/src/nvim/api/private/helpers.c:817:25    #10 0x653161 in set_option_value_for /home/travis/build/neovim/neovim/src/nvim/api/private/helpers.c:797:7    #11 0x651c71 in set_option_to /home/travis/build/neovim/neovim/src/nvim/api/private/helpers.c:308:5    #12 0x6933e8 in vim_set_option /home/travis/build/neovim/neovim/src/nvim/api/vim.c:394:3    #13 0x5bec92 in handle_vim_set_option /home/travis/build/neovim/neovim/build/src/nvim/auto/msgpack_dispatch.c:2728:3    #14 0x2348725 in on_request_event /home/travis/build/neovim/neovim/src/nvim/msgpack_rpc/channel.c:481:19    #15 0x118ff42 in queue_process_events /home/travis/build/neovim/neovim/src/nvim/event/queue.c:142:7    #16 0x25cb500 in nv_event /home/travis/build/neovim/neovim/src/nvim/normal.c:7876:3    #17 0x249de83 in normal_execute /home/travis/build/neovim/neovim/src/nvim/normal.c:1144:12    #18 0x3822e33 in state_enter /home/travis/build/neovim/neovim/src/nvim/state.c:55:26    #19 0x23e38b4 in normal_enter /home/travis/build/neovim/neovim/src/nvim/normal.c:464:3    #20 0x1cfcbb7 in main /home/travis/build/neovim/neovim/src/nvim/main.c:538:3    #21 0x2b01b582a76c in __libc_start_main /build/eglibc-rrybNj/eglibc-2.15/csu/libc-start.c:226SUMMARY: AddressSanitizer: double-free ??:0 __interceptor_free==12080==ABORTING```https://travis-ci.org/neovim/neovim/jobs/130438287",X
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/4765,63298898,2016-05-15T22:16:48Z,runtime/autoload/provider/clipboard.vim,"@@ -52,6 +52,11 @@ elseif executable('lemonade')   let s:paste['+'] = 'lemonade paste'   let s:copy['*'] = 'lemonade copy'   let s:paste['*'] = 'lemonade paste'+elseif executable('doitclient')",We should probably cache the conclusion from this `if..elseif..elseif` chain instead of doing it every time.,X
116470,jbradaric,https://api.github.com/repos/neovim/neovim/pulls/4787,63999630,2016-05-20T07:08:58Z,src/nvim/ops.c,"@@ -5387,20 +5386,18 @@ void cursor_pos_info(dict_T *dict)   }    if (dict != NULL) {+    // Don't shorten this message, the user asked for it.     dict_add_nr_str(dict, ""words"", word_count, NULL);     dict_add_nr_str(dict, ""chars"", char_count, NULL);     dict_add_nr_str(dict, ""bytes"", byte_count + bom_count, NULL); -    if (l_VIsual_active) {-      dict_add_nr_str(dict, ""visual_bytes"", byte_count_cursor, NULL);-      dict_add_nr_str(dict, ""visual_chars"", char_count_cursor, NULL);-      dict_add_nr_str(dict, ""visual_words"", word_count_cursor, NULL);-    } else {-      dict_add_nr_str(dict, ""cursor_bytes"", byte_count_cursor, NULL);-      dict_add_nr_str(dict, ""cursor_chars"", char_count_cursor, NULL);-      dict_add_nr_str(dict, ""cursor_words"", word_count_cursor, NULL);+    dict_add_nr_str(dict, l_VIsual_active ? ""visual_bytes"" : ""cursor_bytes"",+                    (long)byte_count_cursor, NULL);+    dict_add_nr_str(dict, l_VIsual_active ? ""visual_chars"" : ""cursor_chars"",+                    (long)char_count_cursor, NULL);+    dict_add_nr_str(dict, l_VIsual_active ? ""visual_words"" : ""cursor_words"",+                    (long)word_count_cursor, NULL);","I don't think these casts are necessary since the type of `byte_count_cursor`, `char_count_cursor`, and `word_count_cursor` is `long`.",X
715238,equalsraf,https://api.github.com/repos/neovim/neovim/pulls/4779,64019886,2016-05-20T10:21:46Z,CMakeLists.txt,"@@ -300,9 +300,6 @@ include_directories(SYSTEM ${LIBUV_INCLUDE_DIRS}) find_package(Msgpack 1.0.0 REQUIRED) include_directories(SYSTEM ${MSGPACK_INCLUDE_DIRS}) -find_package(LuaJit REQUIRED)-include_directories(SYSTEM ${LUAJIT_INCLUDE_DIRS})",It is still needed in third-party for components that link against lua/luajit like luv and other lua modules and dependencies.,
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/4798,64097461,2016-05-20T19:48:34Z,src/nvim/event/process.c,"@@ -120,14 +120,10 @@ void process_teardown(Loop *loop) FUNC_ATTR_NONNULL_ALL       // Close handles to process without killing it.       CREATE_EVENT(loop->events, process_close_handles, 1, proc);     } else {-      if (proc->type == kProcessTypeUv) {-        uv_kill(proc->pid, SIGTERM);-        proc->term_sent = true;-        process_stop(proc);-      } else {  // kProcessTypePty-        process_close_streams(proc);-        pty_process_close_master((PtyProcess *)proc);-      }+      // Make sure the job kill timer is running and all children are marked+      // for termination. Otherwise children could block us forever in the+      // following event loop.+      process_stop(proc);",nvim's job kill timer could take up to `3`s to kill a pty process (does not react on SIGTERM?). If this is too long one could speed this up by sending SIGKILL from here to the pty process.,X
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/4798,64106696,2016-05-20T21:00:30Z,src/nvim/event/process.c,"@@ -120,14 +120,10 @@ void process_teardown(Loop *loop) FUNC_ATTR_NONNULL_ALL       // Close handles to process without killing it.       CREATE_EVENT(loop->events, process_close_handles, 1, proc);     } else {-      if (proc->type == kProcessTypeUv) {-        uv_kill(proc->pid, SIGTERM);-        proc->term_sent = true;-        process_stop(proc);-      } else {  // kProcessTypePty-        process_close_streams(proc);-        pty_process_close_master((PtyProcess *)proc);-      }+      // Make sure the job kill timer is running and all children are marked+      // for termination. Otherwise children could block us forever in the+      // following event loop.+      process_stop(proc);","https://github.com/neovim/neovim/pull/4789 is a sloppy/WIP attempt to avoid a deadlock, which seems to work. Is it related?",X
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/4798,64107612,2016-05-20T21:08:12Z,src/nvim/event/process.c,"@@ -120,14 +120,10 @@ void process_teardown(Loop *loop) FUNC_ATTR_NONNULL_ALL       // Close handles to process without killing it.       CREATE_EVENT(loop->events, process_close_handles, 1, proc);     } else {-      if (proc->type == kProcessTypeUv) {-        uv_kill(proc->pid, SIGTERM);-        proc->term_sent = true;-        process_stop(proc);-      } else {  // kProcessTypePty-        process_close_streams(proc);-        pty_process_close_master((PtyProcess *)proc);-      }+      // Make sure the job kill timer is running and all children are marked+      // for termination. Otherwise children could block us forever in the+      // following event loop.+      process_stop(proc);","> #4789 is a sloppy/WIP attempt to avoid a deadlock, which seems to work. Is it related?Does not look like this has anything to do with TUI.`nvim +te +'!xclip' +qa` still blocked when tested with #4789 a few hours ago.",X
112971,jamessan,https://api.github.com/repos/neovim/neovim/pulls/4697,64670666,2016-05-25T23:30:19Z,runtime/doc/eval.txt,"@@ -2477,6 +2478,28 @@ call({func}, {arglist} [, {dict}])			*call()* *E699* 		{dict} is for functions with the ""dict"" attribute.  It will be 		used to set the local variable ""self"". |Dictionary-function| +capture({command})					*capture()*+		Capture output of {command}.+		If {command} is a |String|, it returns {command} output.+		If {command} is a |List|, it returns concatenated outputs of+		each item.+		Examples: >+			let a = capture('echon ""foo""')+			echo a+<			foo >+			let a = capture(['echon ""foo""', 'echon ""bar""'])+			echo a+<			foobar+		This function is not available in the |sandbox|.+		Note: The commands are run as if they were prepended with+		|:silent| modifier.  |:redir| and |capture()| work in parallel:+		|capture()| does not cancel |:redir|, |:redir| does not cancel+		|capture()|.  |capture()| inside |capture()| is allowed+		unlike nested |:redir|s, outer capture will not catch","It depends on which are considered the independent statements.  Is it `capture() inside capture() is allowed, unlike nested |:redir|s. ...` or `capture() inside capture() is allowed. Unlike nested |:redir|s, ...`.Also, the phrase `but inner will neither cancel outer` should probably be reworded to something like `but the inner capture will not cancel the outer`.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/4697,64679572,2016-05-26T01:25:59Z,runtime/doc/eval.txt,"@@ -2477,6 +2478,28 @@ call({func}, {arglist} [, {dict}])			*call()* *E699* 		{dict} is for functions with the ""dict"" attribute.  It will be 		used to set the local variable ""self"". |Dictionary-function| +capture({command})					*capture()*+		Capture output of {command}.+		If {command} is a |String|, it returns {command} output.+		If {command} is a |List|, it returns concatenated outputs of+		each item.+		Examples: >+			let a = capture('echon ""foo""')+			echo a+<			foo >+			let a = capture(['echon ""foo""', 'echon ""bar""'])+			echo a+<			foobar+		This function is not available in the |sandbox|.+		Note: The commands are run as if they were prepended with+		|:silent| modifier.  |:redir| and |capture()| work in parallel:","""work in parallel"" => ""work together""Actually, I think it is more confusing for this sentence to exist at all. 99% of users would not think there would be any conflict, so mentioning the lack of conflict is just noise.",X
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/4817,64870124,2016-05-27T08:02:57Z,src/nvim/api/ui.c,"@@ -24,21 +23,13 @@ typedef struct { static PMap(uint64_t) *connected_uis = NULL;  void remote_ui_init(void)+    FUNC_ATTR_NOEXPORT {   connected_uis = pmap_new(uint64_t)();-  // Add handler for ""attach_ui""-  String method = cstr_as_string(""ui_attach"");-  MsgpackRpcRequestHandler handler = {.fn = remote_ui_attach, .async = false};-  msgpack_rpc_add_method_handler(method, handler);-  method = cstr_as_string(""ui_detach"");-  handler.fn = remote_ui_detach;-  msgpack_rpc_add_method_handler(method, handler);-  method = cstr_as_string(""ui_try_resize"");-  handler.fn = remote_ui_try_resize;-  msgpack_rpc_add_method_handler(method, handler); }  void remote_ui_disconnect(uint64_t channel_id)+    FUNC_ATTR_NOEXPORT","So maybe just rename FUNC_ATTR_NOEXPORT to API_NOEXPORT or something. To avoid overloading the semantics of ""FUNC_ATTR_"".",X
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/4817,64890581,2016-05-27T11:13:40Z,src/nvim/api/ui.c,"@@ -24,21 +23,13 @@ typedef struct { static PMap(uint64_t) *connected_uis = NULL;  void remote_ui_init(void)+    FUNC_ATTR_NOEXPORT {   connected_uis = pmap_new(uint64_t)();-  // Add handler for ""attach_ui""-  String method = cstr_as_string(""ui_attach"");-  MsgpackRpcRequestHandler handler = {.fn = remote_ui_attach, .async = false};-  msgpack_rpc_add_method_handler(method, handler);-  method = cstr_as_string(""ui_detach"");-  handler.fn = remote_ui_detach;-  msgpack_rpc_add_method_handler(method, handler);-  method = cstr_as_string(""ui_try_resize"");-  handler.fn = remote_ui_try_resize;-  msgpack_rpc_add_method_handler(method, handler); }  void remote_ui_disconnect(uint64_t channel_id)+    FUNC_ATTR_NOEXPORT","There was a reason FUNC_ATTR_ was used, it is understood by our tooling, like `gendeclarations.lua`, so arguably they are not strictly only for the compiler. I could add the special cases to gendeclarations as well but these will be special cases that needs to remembered by anything else wanting to parse neovim code.An option would be to let `FUNC_` be the generic prefix and reserve `FUNC_ATTR_` for compiler attributes, and use say `FUNC_API_ASYNC` and `FUNC_API_NOEXPORT`.",X
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/4825,64948899,2016-05-27T18:32:52Z,test/functional/provider/python_spec.lua,"@@ -15,49 +25,58 @@ do   end end -describe('python commands and functions', function()-  before_each(function()-    clear()-    command('python import vim')-  end)+before_each(function()","@justinmk Busted does not have thorough documentation. I know that this works locally and I know that this code works on travis and docs do not say that `before_each` _must not_ be used like this (as well as that `before_each` _must_ be placed inside `describe`), so I have this code. There will be more: a071e3896ecc7e2ff36fbcdbdc39e540bbca8511 (given issues with tests on branch this commit belongs to I guess I will move it to a separate PR).",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/3745,65000107,2016-05-29T09:24:23Z,src/nvim/ops.c,"@@ -5519,8 +5511,9 @@ static bool get_clipboard(int name, yankreg_T **target, bool quiet)     reg->y_type = kMTUnknown;   } -  reg->y_array = xcalloc(lines->lv_len, sizeof(uint8_t *));-  reg->y_size = lines->lv_len;+  assert(lines->lv_len >= 0);","I think it safe to assume the length of a list is nonnegative. (we could have asserts in the functions for manipulating lists, but not in every case a list is just being used).",X
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/4811,65000785,2016-05-29T09:50:41Z,src/nvim/ex_cmds.c,"@@ -5836,3 +5873,166 @@ void set_context_in_sign_cmd(expand_T *xp, char_u *arg)     }   } }++/// live_sub()+/// Open a window for future displaying of the live_sub mode.+/// +/// Does not allow editing in the window. +/// Returns when the window is closed.+///+/// @param sub the replacement word+/// @param lmatch the list containing our data+///+/// @returns  CR	      if the command is to be executed+///           Ctrl_C    if it is to be abandoned+///           K_IGNORE  if editing continues++int ex_window_live_sub(char_u* sub, klist_t(matchedline_T) *lmatch)+{+  int i;+  garray_T winsizes;+  char_u typestr[2];+  int save_restart_edit = restart_edit;+  int save_State = State;+  int save_exmode = exmode_active;+  int save_cmdmsg_rl = cmdmsg_rl;++  // Can't do this recursively.  Can't do it when typing a password. +  if (cmdwin_type != 0+      || cmdline_star > 0+      ) {+    beep_flush();+    return K_IGNORE;+  }++  // Save current window sizes. +  win_size_save(&winsizes);++  // Save the current window to restore it later +  win_T* oldwin = curwin;++  // Don't execute autocommands while creating the window. +  block_autocmds();+  // don't use a new tab page +  cmdmod.tab = 0;++  // close last buffer used for ex_window_live_sub() +  buf_T* oldbuf;+  if((oldbuf = buflist_findname_exp((char_u *)""[live_sub]""))!=NULL) {+    close_windows (oldbuf, FALSE);+    close_buffer (NULL, oldbuf, DOBUF_WIPE, FALSE);+  }++  // Create a window for the command-line buffer. +  if (win_split((int)p_cwh, WSP_BOT) == FAIL) {+    beep_flush();+    unblock_autocmds();+    return K_IGNORE;+  }+  cmdwin_type = get_cmdline_type();++  // Create the command-line buffer empty. +  (void)do_ecmd(0, NULL, NULL, NULL, ECMD_ONE, ECMD_HIDE, NULL);+  (void)setfname(curbuf, (char_u *)""[live_sub]"", NULL, TRUE);+  set_option_value((char_u *)""bt"", 0L, (char_u *)""nofile"", OPT_LOCAL);+  set_option_value((char_u *)""swf"", 0L, NULL, OPT_LOCAL);+  curbuf->b_p_ma = FALSE; // Not Modifiable+  curwin->w_p_fen = FALSE;+  curwin->w_p_rl = cmdmsg_rl;+  cmdmsg_rl = FALSE;+  RESET_BINDING(curwin);++  // Do execute autocommands for setting the filetype (load syntax). +  unblock_autocmds();++  // Showing the prompt may have set need_wait_return, reset it. +  need_wait_return = FALSE;++  // Reset 'textwidth' after setting 'filetype' (the Vim filetype plugin sets 'textwidth' to 78). +  curbuf->b_p_tw = 0;++  // Initialize line and highliht variables +  int line = 0;+  int src_id_highlight = 0;+  long match_size = strlen((char*)sub);+  +  // allocate a line sized for the window+  char *str = xmalloc((size_t )curwin->w_frame->fr_width);+  +  // Append the lines to our buffer+  kl_iter(matchedline_T, lmatch, current) {+    matchedline_T mat = (*current)->data;+    size_t line_size = sizeof(mat.line) + sizeof(long) + 5;",The length of the string placed into `str` is not computed right. `sizeof(mat.line)` is the size of the pointer not the string length. Similar for `sizeof(long)`.,X
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/4811,65917760,2016-06-06T16:00:34Z,src/nvim/options.lua,"@@ -2766,5 +2766,14 @@ return {       varname='p_wd',       defaults={if_true={vi=0}}     },+    {+      full_name='livesub', abbreviation='lsu',+      type='bool', scope={'global'},+      vi_def=true,+      redraw={'everything'},+      varname='p_sub',+      defaults={if_true={vi=false, vim=false}}+    },",I believe the problem is you added this in the wrong spot. Try putting it in alphanumeric order: after the `listchars` entry.,X
112971,jamessan,https://api.github.com/repos/neovim/neovim/pulls/4811,65930885,2016-06-06T17:22:28Z,src/nvim/options.lua,"@@ -2766,5 +2766,14 @@ return {       varname='p_wd',       defaults={if_true={vi=0}}     },+    {+      full_name='livesub', abbreviation='lsu',+      type='bool', scope={'global'},+      vi_def=true,+      redraw={'everything'},+      varname='p_sub',+      defaults={if_true={vi=false, vim=false}}+    },",That requirement should probably be added to the checklist in option.c.,X
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/4841,66004149,2016-06-07T03:11:04Z,test/functional/legacy/getcwd_spec.lua,"@@ -0,0 +1,92 @@+-- Tests for getcwd(), haslocaldir(), and :lcd++local helpers = require('test.functional.helpers')+local eq, eval, source = helpers.eq, helpers.eval, helpers.source+local call, clear, execute = helpers.call, helpers.clear, helpers.execute++describe('getcwd', function()+  before_each(clear)++  after_each(function()+    helpers.rmdir('Xtopdir')+  end)++  it('is working', function()+    -- Do all test in a separate window to avoid E211 when we recursively.+    -- Delete the Xtopdir directory during cleanup.++    -- This will cause a few errors, do it silently.",comment is no longer relevant?,X
6589866,brcolow,https://api.github.com/repos/neovim/neovim/pulls/4804,66027081,2016-06-07T08:15:50Z,src/nvim/ex_docmd.c,"@@ -7858,19 +7858,21 @@ static void ex_stopinsert(exarg_T *eap)  */ void exec_normal_cmd(char_u *cmd, int remap, bool silent) {+  // Stuff the argument into the typeahead buffer.+  ins_typebuf(cmd, remap, 0, true, silent);+  exec_normal(false);+}++void exec_normal(int was_typed)",Updated. Thanks. I also changed the parameter from `int` to `bool` as that seemed better. I honestly wasn't sure how to describe the `was_typed` parameter as the `exec_normal` method is only called once and the argument is always true so I just wrote something very generic.,X
112971,jamessan,https://api.github.com/repos/neovim/neovim/pulls/4738,66486367,2016-06-09T17:39:05Z,test/functional/legacy/assert_spec.lua,"@@ -142,4 +142,16 @@ describe('assert function:', function()       })     end)   end)++  it('should allow setting to a number', function()","This is actually testing whether the old value of `v:errors` is properly freed when an `assert_*` function sets a new value, regardless of the old type of `v:errors` (which is supposed to just be a list).Maybe reword this to `it('is reset to a list by assert functions', function()`?",X
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/4607,66666597,2016-06-10T19:13:02Z,src/nvim/eval.c,"@@ -18095,45 +18096,147 @@ void free_tv(typval_T *varp)   } } -/*- * Free the memory for a variable value and set the value to NULL or 0.- */+#define TYPVAL_ENCODE_ALLOW_SPECIALS false++#define TYPVAL_ENCODE_CONV_NIL() \+    do { \+      tv->vval.v_special = kSpecialVarFalse; \+      tv->v_lock = VAR_UNLOCKED; \+    } while (0)++#define TYPVAL_ENCODE_CONV_BOOL(ignored) \+    TYPVAL_ENCODE_CONV_NIL()++#define TYPVAL_ENCODE_CONV_NUMBER(ignored) \+    do { \+      (void) ignored; \+      tv->vval.v_number = 0; \+      tv->v_lock = VAR_UNLOCKED; \+    } while (0)++#define TYPVAL_ENCODE_CONV_UNSIGNED_NUMBER(ignored) \+    assert(false)++#define TYPVAL_ENCODE_CONV_FLOAT(ignored) \+    do { \+      tv->vval.v_float = 0; \+      tv->v_lock = VAR_UNLOCKED; \+    } while (0)++#define TYPVAL_ENCODE_CONV_STRING(str, ignored) \+    do { \+      xfree(str); \+      tv->vval.v_string = NULL; \+      tv->v_lock = VAR_UNLOCKED; \+    } while (0)++#define TYPVAL_ENCODE_CONV_STR_STRING(ignored1, ignored2)++#define TYPVAL_ENCODE_CONV_EXT_STRING(ignored1, ignored2, ignored3)++#define TYPVAL_ENCODE_CONV_FUNC(fun) \+    do { \+      func_unref(fun); \+      if (fun != empty_string) { \+        xfree(fun); \+      } \+      tv->vval.v_string = NULL; \+      tv->v_lock = VAR_UNLOCKED; \+    } while (0)++#define TYPVAL_ENCODE_CONV_EMPTY_LIST() \+    do { \+      list_unref(tv->vval.v_list); \+      tv->vval.v_list = NULL; \+      tv->v_lock = VAR_UNLOCKED; \+    } while (0)++#define TYPVAL_ENCODE_CONV_EMPTY_DICT() \+    do { \+      dict_unref(tv->vval.v_dict); \+      tv->vval.v_dict = NULL; \+      tv->v_lock = VAR_UNLOCKED; \+    } while (0)++#define TYPVAL_ENCODE_CONV_LIST_START(ignored) \+    do { \+      if (tv->vval.v_list->lv_refcount > 1) { \+        tv->vval.v_list->lv_refcount--; \+        tv->vval.v_list = NULL; \","~~This macro is called before we push a new element on the stack in `nothing_convert_one_value()`.When  constructing the pushed element, `tv->vval.v_list->lv_first` is read after `tv->vval.v_list` was set to `NULL`.~~",X
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/4607,66666799,2016-06-10T19:14:30Z,src/nvim/eval.c,"@@ -18095,45 +18096,147 @@ void free_tv(typval_T *varp)   } } -/*- * Free the memory for a variable value and set the value to NULL or 0.- */+#define TYPVAL_ENCODE_ALLOW_SPECIALS false++#define TYPVAL_ENCODE_CONV_NIL() \+    do { \+      tv->vval.v_special = kSpecialVarFalse; \+      tv->v_lock = VAR_UNLOCKED; \+    } while (0)++#define TYPVAL_ENCODE_CONV_BOOL(ignored) \+    TYPVAL_ENCODE_CONV_NIL()++#define TYPVAL_ENCODE_CONV_NUMBER(ignored) \+    do { \+      (void) ignored; \+      tv->vval.v_number = 0; \+      tv->v_lock = VAR_UNLOCKED; \+    } while (0)++#define TYPVAL_ENCODE_CONV_UNSIGNED_NUMBER(ignored) \+    assert(false)++#define TYPVAL_ENCODE_CONV_FLOAT(ignored) \+    do { \+      tv->vval.v_float = 0; \+      tv->v_lock = VAR_UNLOCKED; \+    } while (0)++#define TYPVAL_ENCODE_CONV_STRING(str, ignored) \+    do { \+      xfree(str); \+      tv->vval.v_string = NULL; \+      tv->v_lock = VAR_UNLOCKED; \+    } while (0)++#define TYPVAL_ENCODE_CONV_STR_STRING(ignored1, ignored2)++#define TYPVAL_ENCODE_CONV_EXT_STRING(ignored1, ignored2, ignored3)++#define TYPVAL_ENCODE_CONV_FUNC(fun) \+    do { \+      func_unref(fun); \+      if (fun != empty_string) { \+        xfree(fun); \+      } \+      tv->vval.v_string = NULL; \+      tv->v_lock = VAR_UNLOCKED; \+    } while (0)++#define TYPVAL_ENCODE_CONV_EMPTY_LIST() \+    do { \+      list_unref(tv->vval.v_list); \+      tv->vval.v_list = NULL; \+      tv->v_lock = VAR_UNLOCKED; \+    } while (0)++#define TYPVAL_ENCODE_CONV_EMPTY_DICT() \+    do { \+      dict_unref(tv->vval.v_dict); \+      tv->vval.v_dict = NULL; \+      tv->v_lock = VAR_UNLOCKED; \+    } while (0)++#define TYPVAL_ENCODE_CONV_LIST_START(ignored) \+    do { \+      if (tv->vval.v_list->lv_refcount > 1) { \+        tv->vval.v_list->lv_refcount--; \",~~`list_unref()` in macro `TYPVAL_ENCODE_LIST_END()` also decreases the refcount. Is this right?~~,X
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/4607,66704531,2016-06-11T10:55:12Z,src/nvim/eval/typval_encode.h,"@@ -154,6 +154,7 @@ typedef enum { /// Structure representing current VimL to messagepack conversion state typedef struct {   MPConvStackValType type;  ///< Type of the stack entry.+  typval_T *tv;  ///< Currently converted typval_T.",Where is that new member used (other than for writing)? Could it replace member `data`?,X
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/4885,66707894,2016-06-11T16:05:11Z,runtime/autoload/health.vim,"@@ -0,0 +1,413 @@+function! s:trim(s) abort+  return substitute(a:s, '^\_s*\|\_s*$', '', 'g')+endfunction+++"" Simple version comparison.+function! s:version_cmp(a, b) abort+  let a = split(a:a, '\.')+  let b = split(a:b, '\.')++  for i in range(len(a))+    if a[i] > b[i]+      return 1+    elseif a[i] < b[i]+      return -1+    endif+  endfor++  return 0+endfunction+++"" Fetch the contents of a URL.+function! s:download(url) abort+  let content = ''+  if executable('curl')+    let content = system('curl -sL ""'.a:url.'""')+  endif++  if empty(content) && executable('python')+    let script = ""+          \try:\n+          \    from urllib.request import urlopen\n+          \except ImportError:\n+          \    from urllib2 import urlopen\n+          \\n+          \try:\n+          \    response = urlopen('"".a:url.""')\n+          \    print(response.read().decode('utf8'))\n+          \except Exception:\n+          \    pass\n+          \""+    let content = system('python -c ""'.script.'"" 2>/dev/null')+  endif++  return content+endfunction+++"" Get the latest Neovim Python client version from PyPI.  The result is+"" cached.+function! s:latest_pypi_version()+  if exists('s:pypi_version')+    return s:pypi_version+  endif++  let s:pypi_version = 'unknown'+  let pypi_info = s:download('https://pypi.python.org/pypi/neovim/json')+  if !empty(pypi_info)+    let pypi_data = json_decode(pypi_info)+    let s:pypi_version = get(get(pypi_data, 'info', {}), 'version', 'unknown')+    return s:pypi_version+  endif+endfunction+++"" Get version information using the specified interpreter.  The interpreter is+"" used directly in case breaking changes were introduced since the last time+"" Neovim's Python client was updated.+function! s:version_info(python) abort+  let pypi_version = s:latest_pypi_version()+  let python_version = s:trim(system(+        \ printf('""%s"" -c ""import sys; print(''.''.join(str(x) '+        \ . 'for x in sys.version_info[:3]))""', a:python)))+  if empty(python_version)+    let python_version = 'unknown'+  endif+  +  let nvim_path = s:trim(system(printf('""%s"" -c ""import sys, neovim;'+        \ . 'print(neovim.__file__)"" 2>/dev/null', a:python)))+  if empty(nvim_path)+    return [python_version, 'not found', pypi_version, 'unknown']+  endif++  let nvim_version = 'unknown'+  let base = fnamemodify(nvim_path, ':h')+  for meta in glob(base.'-*/METADATA', 1, 1) + glob(base.'-*/PKG-INFO', 1, 1)+    for meta_line in readfile(meta)+      if meta_line =~# '^Version:'+        let nvim_version = matchstr(meta_line, '^Version: \zs\S\+')+      endif+    endfor+  endfor++  let version_status = 'unknown'+  if nvim_version != 'unknown' && pypi_version != 'unknown'+    if s:version_cmp(nvim_version, pypi_version) == -1+      let version_status = 'outdated'+    else+      let version_status = 'up to date'+    endif+  endif++  return [python_version, nvim_version, pypi_version, version_status]+endfunction+++"" Check the Python interpreter's usability.+function! s:check_bin(bin, notes) abort+  if !filereadable(a:bin)+    call add(a:notes, printf('Error: ""%s"" was not found.', a:bin))+    return 0+  elseif executable(a:bin) != 1+    call add(a:notes, printf('Error: ""%s"" is not executable.', a:bin))+    return 0+  endif+  return 1+endfunction+++"" Text wrapping that returns a list of lines+function! s:textwrap(text, width) abort+  let pattern = '.*\%(\s\+\|\_$\)\zs\%<'.a:width.'c'+  return map(split(a:text, pattern), 's:trim(v:val)')+endfunction+++"" Echo wrapped notes+function! s:echo_notes(notes) abort+  if empty(a:notes)+    return+  endif++  echo '  Messages:'+  for msg in a:notes+    let msg_lines = s:textwrap(msg, 74)+    echo '    *' msg_lines[0]+    if len(msg_lines) > 1+      echo join(map(msg_lines[1:], '""      "".v:val'), ""\n"")+    endif+  endfor+endfunction+++"" Load the remote plugin manifest file and check for unregistered plugins+function! s:diagnose_manifest() abort+  echo 'Checking: Remote Plugins'+  let existing_rplugins = {}++  for item in remote#host#PluginsForHost('python')+    let existing_rplugins[item.path] = 'python'+  endfor++  for item in remote#host#PluginsForHost('python3')+    let existing_rplugins[item.path] = 'python3'+  endfor++  let require_update = 0+  let notes = []++  for path in map(split(&rtp, ','), 'resolve(v:val)')+    let python_glob = glob(path.'/rplugin/python*', 1, 1)+    if empty(python_glob)+      continue+    endif++    let python_dir = python_glob[0]+    let python_version = fnamemodify(python_dir, ':t')++    for script in glob(python_dir.'/*.py', 1, 1)+          \ + glob(python_dir.'/*/__init__.py', 1, 1)+      let contents = join(readfile(script))+      if contents =~# '\<\%(from\|import\)\s\+neovim\>'+        if script =~# '/__init__\.py$'+          let script = fnamemodify(script, ':h')+        endif++        if !has_key(existing_rplugins, script)+          let msg = printf('""%s"" is not registered.', fnamemodify(path, ':t'))+          if python_version == 'pythonx'+            if !has('python2') && !has('python3')+              let msg .= ' (python2 and python3 not available)'+            endif+          elseif !has(python_version)+            let msg .= printf(' (%s not available)', python_version)+          else+            let require_update = 1+          endif++          call add(notes, msg)+        endif++        break+      endif+    endfor+  endfor++  echo '  Status: '+  if require_update+    echon 'Out of date'+    call add(notes, 'Run :UpdateRemotePlugins')+  else+    echon 'Up to date'+  endif++  call s:echo_notes(notes)+endfunction+++function! s:diagnose_python(version) abort+  let python_bin_name = 'python'.(a:version == 2 ? '' : '3')+  let pyenv = resolve(exepath('pyenv'))+  let pyenv_root = exists('$PYENV_ROOT') ? resolve($PYENV_ROOT) : ''+  let venv = exists('$VIRTUAL_ENV') ? resolve($VIRTUAL_ENV) : ''+  let host_prog_var = python_bin_name.'_host_prog'+  let host_skip_var = python_bin_name.'_host_skip_check'+  let python_bin = ''+  let python_multiple = []+  let notes = []++  if exists('g:'.host_prog_var)+    call add(notes, printf('Using: g:%s = ""%s""', host_prog_var, get(g:, host_prog_var)))+  endif++  let old_skip = get(g:, host_skip_var, 0)+  let g:[host_skip_var] = 1","> I don't think there's a problem with calling the detection a second time to get the first found interpreter, but it felt sloppy at the time (global variables aside)Doing two passes and merging the results is fine. It's ok to be a little sloppy as long as it's isolated/encapsulated. Regarding the ""skip"" globals, my medium-term hope is that they can be removed (we should cache the previous conclusion in viminfo/shada).",X
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/4607,66708597,2016-06-11T16:56:36Z,src/nvim/eval/typval_encode.h,"@@ -154,6 +154,7 @@ typedef enum { /// Structure representing current VimL to messagepack conversion state typedef struct {   MPConvStackValType type;  ///< Type of the stack entry.+  typval_T *tv;  ///< Currently converted typval_T.","@oni-link It is used in clear_tv only, and it is inconvenient to use in other places. Also it cannot possibly replace `data` completely, only `data.l.list` and `data.d.dict`.",X
972014,mhinz,https://api.github.com/repos/neovim/neovim/pulls/4489,66821026,2016-06-13T16:14:01Z,test/unit/buffer_spec.lua,"@@ -211,93 +210,245 @@ describe('buffer functions', function()   end)    describe('build_stl_str_hl', function()+    local buffer_byte_size = 100+    local STL_MAX_ITEM = 80+    local output_buffer = ''++    -- This function builds the statusline+    --+    -- @param arg Optional arguments are:+    --    .pat The statusline format string+    --    .fillchar The fill character used in the statusline+    --    .maximum_cell_count The number of cells available in the statusline+    local build_stl_str_hl = function (arg)+      output_buffer = to_cstr(string.rep("" "", buffer_byte_size))++      local pat = arg.pat or ''+      local fillchar = arg.fillchar or (' '):byte()+      local maximum_cell_count = arg.maximum_cell_count or buffer_byte_size -    local output_buffer = to_cstr(string.rep("" "", 100))--    local build_stl_str_hl = function(pat)       return buffer.build_stl_str_hl(globals.curwin,                                      output_buffer,-                                     100,+                                     buffer_byte_size,                                      to_cstr(pat),                                      false,-                                     32,-                                     80,+                                     fillchar,+                                     maximum_cell_count,                                      NULL,                                      NULL)     end -    it('should copy plain text', function()-      local width = build_stl_str_hl(""this is a test"")--      eq(14, width)-      eq(""this is a test"", helpers.ffi.string(output_buffer, width))--    end)--    it('should print no file name', function()-      local width = build_stl_str_hl(""%f"")--      eq(9, width)-      eq(""[No Name]"", helpers.ffi.string(output_buffer, width))--    end)--    it('should print the relative file name', function()-      buffer.setfname(globals.curbuf, to_cstr(""Makefile""), NULL, 1)-      local width = build_stl_str_hl(""%f"")--      eq(8, width)-      eq(""Makefile"", helpers.ffi.string(output_buffer, width))--    end)--    it('should print the full file name', function()-      buffer.setfname(globals.curbuf, to_cstr(""Makefile""), NULL, 1)--      local width = build_stl_str_hl(""%F"")--      assert.is_true(8 < width)-      neq(NULL, string.find(helpers.ffi.string(output_buffer, width), ""Makefile""))--    end)--    it('should print the tail file name', function()-      buffer.setfname(globals.curbuf, to_cstr(""src/nvim/buffer.c""), NULL, 1)--      local width = build_stl_str_hl(""%t"")--      eq(8, width)-      eq(""buffer.c"", helpers.ffi.string(output_buffer, width))--    end)--    it('should print the buffer number', function()-      buffer.setfname(globals.curbuf, to_cstr(""src/nvim/buffer.c""), NULL, 1)--      local width = build_stl_str_hl(""%n"")--      eq(1, width)-      eq(""1"", helpers.ffi.string(output_buffer, width))-    end)--    it('should print the current line number in the buffer', function()-      buffer.setfname(globals.curbuf, to_cstr(""test/unit/buffer_spec.lua""), NULL, 1)--      local width = build_stl_str_hl(""%l"")--      eq(1, width)-      eq(""0"", helpers.ffi.string(output_buffer, width))--    end)--    it('should print the number of lines in the buffer', function()-      buffer.setfname(globals.curbuf, to_cstr(""test/unit/buffer_spec.lua""), NULL, 1)--      local width = build_stl_str_hl(""%L"")+    -- Use this function to simplify testing the comparison between+    --  the format string and the resulting statusline.+    --+    -- @param description The description of what the test should be doing+    -- @param statusline_cell_count The number of cells available in the statusline+    -- @param input_stl The format string for the statusline+    -- @param expected_stl The expected result string for the statusline+    --+    -- @param arg Options can be placed in an optional dictionary as the last parameter+    --    .expected_cell_count The expected number of cells build_stl_str_hl will return+    --    .expected_byte_length The expected byte length of the string+    --    .file_name The name of the file to be tested (useful in %f type tests)+    --    .fillchar The character that will be used to fill any 'extra' space in the stl+    local function statusline_test (description,+                                    statusline_cell_count,+                                    input_stl,+                                    expected_stl,+                                    arg)++      -- arg is our optional parameter+      local arg = arg or {}","lualint will complain about the `local` here, because `arg` is already defined (since it's a function parameter). Just remove the `local`.",X
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/4923,67239377,2016-06-15T20:29:18Z,runtime/doc/msgpack_rpc.txt,"@@ -1,97 +1,88 @@-*msgpack_rpc.txt*    For Nvim.						 {Nvim}+*msgpack_rpc.txt*							{Nvim}   		 NVIM REFERENCE MANUAL    by Thiago de Arruda  -The Msgpack-RPC Interface to Nvim				  *msgpack-rpc*+RPC API for Nvim				     *RPC* *rpc* *msgpack-rpc* -1. Introduction			|msgpack-rpc-intro|-2. API mapping			|msgpack-rpc-api|-3. Connecting			|msgpack-rpc-connecting|-4. Clients			|msgpack-rpc-clients|-5. Types			|msgpack-rpc-types|-6. Wrapping methods		|msgpack-rpc-wrap-methods|-7. Vimscript functions		|msgpack-rpc-vim-functions|+1. Introduction			|rpc-intro|+2. API mapping			|rpc-api|+3. Connecting			|rpc-connecting|+4. Clients			|rpc-client|+5. Types			|rpc-types|+6. Vimscript functions		|rpc-vim-functions|  ==============================================================================-1. Introduction						    *msgpack-rpc-intro*+1. Introduction						            *rpc-intro* -The primary way to control a running Nvim instance is through-MessagePack-RPC, a messaging protocol that uses the MessagePack serialization-format: https://github.com/msgpack/msgpack/blob/7498cf3/spec.md.-From now on, we refer to the protocol as msgpack-rpc.+The primary way to control Nvim programmatically is the RPC API, which speaks+MessagePack-RPC (""msgpack-rpc""), a messaging protocol that uses the+MessagePack serialization format:+  https://github.com/msgpack/msgpack/blob/0b8f5ac/spec.md -At this point, only plugins use msgpack-rpc, but eventually even user-interaction will happen through it, since user interfaces will be separate-programs that control a headless Nvim instance.+All kinds of Nvim ""clients"" use the RPC API: user interfaces (GUIs), remote+plugins, scripts like ""nvr"" (https://github.com/mhinz/neovim-remote), and even+`nvim` itself can control other `nvim` instances. By connecting to the RPC API+programs can: -By connecting to the msgpack-rpc interface, programs can:+  - Call any API function+  - Listen for events+  - Receive remote calls from Nvim -- Call any Nvim API function-- Listen for Nvim events-- Receive remote calls from Nvim--Nvim's msgpack-rpc interface is like a more powerful version of Vim's-`clientserver` feature.+The RPC API is like a more powerful version of Vim's `clientserver` feature.  ==============================================================================-2. API mapping						      *msgpack-rpc-api*+ 2. API mapping							    *rpc-api* -The Nvim C API, see |nvim-api|, is automatically exposed to the msgpack-rpc-interface by the build system, which parses headers at src/nvim/api from the-project root. A dispatch function is generated, which matches msgpack-rpc method-names with non-static API functions, converting/validating arguments and return-values back to msgpack.+The Nvim C |API| is automatically exposed to the RPC API by the build system,+which parses headers at src/nvim/api/*. A dispatch function is generated which+matches RPC API method names with public API functions, converting/validating+arguments and return values back to msgpack. -Client libraries will normally provide wrappers that hide msgpack-rpc details-from programmers. The wrappers can be automatically generated by reading-bundled API metadata from a compiled Nvim instance.+Client libraries (|api-client|s) normally provide wrappers that hide+msgpack-rpc details from application developers. The wrappers can be+automatically generated by reading bundled API metadata from a compiled Nvim+instance.  There are two ways to obtain API metadata: -1. By connecting to a running Nvim instance and calling `vim_get_api_info`-   via msgpack-rpc. This is best for clients written in dynamically-typed-   languages, which can define functions at runtime.+  1. Connect to a running Nvim instance and call `vim_get_api_info` via+     msgpack-rpc. This is best for clients written in dynamic languages which+     can define functions at runtime. -2. By starting Nvim with the `--api-info` command-line option, which makes Nvim-   dump a blob of msgpack metadata to standard output and exit. This is best-   for clients written in statically-typed languages, which require a separate-   compilation step.+  2. Start Nvim with the `--api-info` command-line option, which dumps a blob+     of msgpack metadata to standard output. This is useful for clients+     written in statically-compiled languages. -Here's a simple way to get human-readable description of the API (requires-Python and the `pyyaml`/`msgpack-python` pip packages):->-    nvim --api-info | python -c 'import msgpack, sys, yaml; print yaml.dump(msgpack.unpackb(sys.stdin.read()))' > api.yaml+To get a human-readable list of API functions, try this one-liner: >+    nvim --api-info | nvim --headless +'put =msgpackparse([getline(1)])|g/\V\^{\._TYPE\.: [], \._VAL\.: [\.\w\+_\w\+\.]}\$/p' +'q!' -","Less terrible one-liner from @mhinz:```:echomsg string(map(msgpackparse(systemlist('nvim --api-info'))[0].functions, 'v:val.name._VAL[0]'))```",X
972014,mhinz,https://api.github.com/repos/neovim/neovim/pulls/4929,67291165,2016-06-16T06:03:12Z,src/nvim/fileio.c,"@@ -6147,6 +6147,11 @@ void ex_doautoall(exarg_T *eap)     /* restore the current window */     aucmd_restbuf(&aco); +    if (aco.new_curbuf->terminal) {+      terminal_resize(aco.new_curbuf->terminal, aco.save_curwin->w_width,+                      aco.save_curwin->w_height);+    }","Yes, or maybe even more general.. because the actual problem is the same terminal buffer shown in differently sized windows.E.g. http://imgur.com/MTJIB2pHere, the terminal buffer was created in the bottom right window. Then I switched to that buffer in the bigger left window and can only scroll to the middle, since that's the height of the window the terminal buffer was created in.So.. it should probably done in `win_enter()` instead? EDIT: Even `buffer_enter()` instead of `win_enter()`.",X
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/4938,67605035,2016-06-18T18:57:05Z,src/nvim/eval.c,"@@ -7472,7 +7472,9 @@ static void f_and(typval_T *argvars, typval_T *rettv) static void f_api_info(typval_T *argvars, typval_T *rettv) {   Dictionary metadata = api_metadata();-  object_to_vim(DICTIONARY_OBJ(metadata), rettv, NULL);+  if (!object_to_vim(DICTIONARY_OBJ(metadata), rettv, NULL)) {","why not just `(void)object_to_vim(DICTIONARY_OBJ(metadata), rettv, NULL);` ?",
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/4915,67616410,2016-06-19T12:48:54Z,src/nvim/ex_cmds.c,"@@ -2946,6 +2951,20 @@ void do_sub(exarg_T *eap)   int start_nsubs;   int save_ma = 0; +  //  list to save matched lines+  //  Note: Could not use nolint with rule, line would be > 100 chars+  klist_t(matchedline_T) *lmatch = kl_init(matchedline_T); // NOLINT",Is there a reason why this line (if it needs to be in this function) cannot be moved in front of the big `for` loop? Then we would not need the `goto` replacement before the loop.,X
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/4915,67621012,2016-06-19T17:48:32Z,src/nvim/ex_cmds.c,"@@ -5846,3 +5910,298 @@ void set_context_in_sign_cmd(expand_T *xp, char_u *arg)     }   } }++/// function called after a live command to get back to+/// a normal state+/// validate can take two values :+///     0 if the live_command has not been validated+///     1 if the user has validated the command+void finish_live_cmd(int save_state,+                     garray_T *winsizes,+                     int save_exmode,+                     int save_restart_edit,+                     int save_cmdmsg_rl,+                     int validate) {+  block_autocmds();++  if (validate == 0 && sub_done == 1) {+    do_cmdline_cmd("":u"");+    sub_done = 0;+  }++  // Restore window sizes.+  if (winsizes != NULL) {+    win_size_restore(winsizes);+    ga_clear(winsizes);+  }++  unblock_autocmds();++  char_u typestr[2];+  typestr[0] = cmdwin_type;+  typestr[1] = NUL;+  apply_autocmds(EVENT_CMDWINLEAVE, typestr, typestr, false, curbuf);++  exmode_active = save_exmode;+  restart_edit = save_restart_edit;+  cmdmsg_rl = save_cmdmsg_rl;++  cmdwin_type = 0;+  RedrawingDisabled = 0;++  State = save_state;+  setmouse();+  update_screen(0);+}++/// ex_window_live_sub()+/// Open a window for future displaying of the live_sub mode.+///+/// Does not allow editing in the window.+/// Returns when the window is closed.+///+/// @param pat the pattern word+/// @param sub the replacement word+/// @param lmatch the list containing our data+void ex_window_live_sub(char_u * pat,+                        char_u * sub,+                        klist_t(matchedline_T) *lmatch, // NOLINT+                        bool split)+FUNC_ATTR_NONNULL_ARG(1, 2, 3)+{+  garray_T winsizes;+  int save_restart_edit = restart_edit;+  int save_State = State;+  int save_exmode = exmode_active;+  int save_cmdmsg_rl = cmdmsg_rl;++  // Can't do this recursively.  Can't do it when typing a password.+  if (cmdline_star > 0) {+    beep_flush();+    return;+  }++  // Save current window sizes.+  win_size_save(&winsizes);++  // Save the current window to restore it later+  win_T *oldwin = curwin;++  if (split) {+    // Don't execute autocommands while creating the window.+    block_autocmds();+    // don't use a new tab page+    cmdmod.tab = 0;++    // Create a window for the command-line buffer.+    if (win_split((int)p_cwh, WSP_BOT) == FAIL) {+      beep_flush();+      unblock_autocmds();+      return;+    }+    cmdwin_type = get_cmdline_type();++    // Create the command-line buffer empty.+    (void)do_ecmd(0, NULL, NULL, NULL, ECMD_ONE, ECMD_HIDE, NULL);+    (void)setfname(curbuf, (char_u *) ""[live_sub]"", NULL, true);+    set_option_value((char_u *) ""bt"", 0L, (char_u *) ""nofile"", OPT_LOCAL);+    set_option_value((char_u *) ""swf"", 0L, NULL, OPT_LOCAL);+    curbuf->b_p_ma = false;  // Not Modifiable+    curwin->w_p_fen = false;+    curwin->w_p_rl = cmdmsg_rl;+    cmdmsg_rl = false;+    RESET_BINDING(curwin);++    // Do execute autocommands for setting the filetype (load syntax).+    unblock_autocmds();++    // Showing the prompt may have set need_wait_return, reset it.+    need_wait_return = false;++    // Reset 'textwidth' after setting 'filetype'+    // (the Vim filetype plugin sets 'textwidth' to 78).+    curbuf->b_p_tw = 0;++    // Save the buffer used in the split+    livebuf = curbuf;++    // Initialize line and highlight variables+    int line = 0;+    int src_id_highlight = 0;+    long sub_size = STRLEN(sub);+    long pat_size = STRLEN(pat);++    // Get the width of the column which display the number of the line+    linenr_T highest_num_line = 0;+    kl_iter(matchedline_T, lmatch, current) {+      highest_num_line = (*current)->data.lnum;+    }++    // computing the length of the column that will display line number+    //TODO: Is log10 efficient for counting the nr of digits?+    int col_width = log10(highest_num_line) + 1 + 3;+    // better? log10 might not be precise for large numbers (ref?)+    //int col_width = snprintf(NULL, 0, ""%ld"", highest_num_line) + 3;++    // allocate a line sized for the window+    char *str = xcalloc((size_t)curwin->w_frame->fr_width, sizeof(char));++    // Append the lines to our buffer+    kl_iter(matchedline_T, lmatch, current) {+      matchedline_T mat = (*current)->data;+      size_t line_size = STRLEN(mat.line) + col_width + 1;++      // Reallocation if str not long enough+      if (line_size > curwin->w_frame->fr_width * sizeof(char)) {","- Here we should compare against the old value of `line_size`, otherwise we would reallocate `str` even if it was bigger than `line_size`.- For `ml_append()` we already know the size of our string.- Highlight loop changed.``` c    size_t old_line_size = 0;    size_t line_size;    char *str = NULL;    // Append the lines to our buffer    kl_iter(matchedline_T, lmatch, current) {      matchedline_T mat = (*current)->data;      line_size = STRLEN(mat.line) + col_width + 1;      // Reallocation if str not long enough      if (line_size > old_line_size) {        str = xrealloc(str, line_size);        old_line_size = line_size;      }      // put ' [ lnum]line' into str and append it to the livesub buffer      str[0] = ' ';      str[1] = '[';      int i = 2;      for (; i < col_width - (log10(mat.lnum) + 1) - 1; i++) {        str[i] = ' ';      }      snprintf(str+i, line_size - i, ""%ld]%s"", mat.lnum, mat.line);      ml_append(line++, (char_u *)str, (colnr_T)(line_size), false);      if (sub_size > 0) {        i = 0;        int hlgroup_ls = syn_check_group((char_u *)""LiveSub"", 7);        kl_iter(colnr_T, mat.start_col, col)        {          // highlight the replaced part          src_id_highlight = bufhl_add_hl(              curbuf, src_id_highlight,              // TODO: Replace the magic 2              // https://github.com/neovim/neovim/pull/4915#discussion_r67605963              hlgroup_ls,  // id of our highlight              line, (*col)->data + col_width + i * (sub_size - pat_size) + 1,              (*col)->data + col_width + i * (sub_size - pat_size) + sub_size);          i++;        }      }    }```",X
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/4915,67621094,2016-06-19T17:54:16Z,src/nvim/ex_cmds.h,"@@ -19,13 +19,47 @@ #define ECMD_LAST       (linenr_T)-1    /* use last position in all files */ #define ECMD_ONE        (linenr_T)1     /* use first line */ +/// for cmdl_progress in live substitution+typedef enum {+  LS_NO_WD,                 /// state of cmdline when none words are typed+                              /// "":%s"" or "":%s/""+  LS_ONE_WD,                /// state of cmd line when only pattern word began+                              /// to be typed : "":%s/patt""+  LS_TWO_SLASH_ONE_WD,      /// Second / has been typed but not the second+                              /// word yet : ""%s/pattern/""+  LS_TWO_WD                /// state of cmd line when pattern has been completed+                            /// and substitue is being typed : "":%s/pattern/sub""+} LiveSub_state;+ /// Previous :substitute replacement string definition typedef struct {   char *sub;            ///< Previous replacement string.   Timestamp timestamp;  ///< Time when it was last set.   list_T *additional_elements;  ///< Additional data left from ShaDa file. } SubReplacementString; +/// Defs for live_sub functionality+#define _noop(x)+/// initializer for a list of match in a line+KLIST_INIT(colnr_T, colnr_T, _noop)++/// structure to backup and display matched lines in live_substitution+typedef struct {+  linenr_T lnum;","Missing header for `linenr_T` and `klist`:``` c#include ""nvim/pos.h""#include ""nvim/lib/klist.h""```",X
4117685,KillTheMule,https://api.github.com/repos/neovim/neovim/pulls/4915,67644335,2016-06-20T07:12:07Z,src/nvim/ex_cmds.c,"@@ -6035,10 +6034,7 @@ FUNC_ATTR_NONNULL_ARG(1, 2, 3)     }      // computing the length of the column that will display line number-    //TODO: Is log10 efficient for counting the nr of digits?-    int col_width = log10(highest_num_line) + 1 + 3;-    // better? log10 might not be precise for large numbers (ref?)-    //int col_width = snprintf(NULL, 0, ""%ld"", highest_num_line) + 3;+    int col_width = snprintf(NULL, 0, ""%ld"", highest_num_line) + 3;","And here I was thinking it was overkill to include `math.h` and use this complicated function on floats.I'm not sold on this in any way, I've just seen a comment somewhere on SO while investigating, that claimed that `log10` might not give proper return values for large integers. Can't find it anymore and haven't seen it mentioned anywhere else, so I might misremember that...Also, I did just now see your line note above. I'll revert that change.",X
4117685,KillTheMule,https://api.github.com/repos/neovim/neovim/pulls/4915,67754745,2016-06-20T19:53:20Z,src/nvim/globals.h,"@@ -434,67 +434,74 @@ EXTERN int did_check_timestamps INIT(= FALSE);      /* did check timestamps                                                        recently */ EXTERN int no_check_timestamps INIT(= 0);       /* Don't check timestamps */ ++// When typing a live action starting by a ':'+// (eg: substitution), need to know when to start+// checking for a live command (=1) and end it (=0)+EXTERN int EVENT_COLON INIT(= 0);+ /*  * Values for index in highlight_attr[].  * When making changes, also update HL_FLAGS below!  And update the default  * value of 'highlight' in option.c.  */ typedef enum {-  HLF_8 = 0         /* Meta & special keys listed with "":map"", text that is-                       displayed different from what it is */-  , HLF_EOB         //< after the last line in the buffer-  , HLF_TERM        //< terminal cursor focused-  , HLF_TERMNC      //< terminal cursor unfocused-  , HLF_AT          /* @ characters at end of screen, characters that-                       don't really exist in the text */-  , HLF_D           /* directories in CTRL-D listing */-  , HLF_E           /* error messages */-  , HLF_I           /* incremental search */-  , HLF_L           /* last search string */-  , HLF_M           /* ""--More--"" message */-  , HLF_CM          /* Mode (e.g., ""-- INSERT --"") */-  , HLF_N           /* line number for "":number"" and "":#"" commands */-  , HLF_CLN         /* current line number */-  , HLF_R           /* return to continue message and yes/no questions */-  , HLF_S           /* status lines */-  , HLF_SNC         /* status lines of not-current windows */-  , HLF_C           /* column to separate vertically split windows */-  , HLF_T           /* Titles for output from "":set all"", "":autocmd"" etc. */-  , HLF_V           /* Visual mode */-  , HLF_VNC         /* Visual mode, autoselecting and not clipboard owner */-  , HLF_W           /* warning messages */-  , HLF_WM          /* Wildmenu highlight */-  , HLF_FL          /* Folded line */-  , HLF_FC          /* Fold column */-  , HLF_ADD         /* Added diff line */-  , HLF_CHD         /* Changed diff line */-  , HLF_DED         /* Deleted diff line */-  , HLF_TXD         /* Text Changed in diff line */-  , HLF_CONCEAL     /* Concealed text */-  , HLF_SC          /* Sign column */-  , HLF_SPB         /* SpellBad */-  , HLF_SPC         /* SpellCap */-  , HLF_SPR         /* SpellRare */-  , HLF_SPL         /* SpellLocal */-  , HLF_PNI         /* popup menu normal item */-  , HLF_PSI         /* popup menu selected item */-  , HLF_PSB         /* popup menu scrollbar */-  , HLF_PST         /* popup menu scrollbar thumb */-  , HLF_TP          /* tabpage line */-  , HLF_TPS         /* tabpage line selected */-  , HLF_TPF         /* tabpage line filler */-  , HLF_CUC         /* 'cursurcolumn' */-  , HLF_CUL         /* 'cursurline' */-  , HLF_MC          /* 'colorcolumn' */-  , HLF_COUNT       /* MUST be the last one */+  HLF_8 = 0         // Meta & special keys listed with "":map"", text that is+                    // displayed different from what it is+  , HLF_EOB         // after the last line in the buffer+  , HLF_TERM        // terminal cursor focused+  , HLF_TERMNC      // terminal cursor unfocused+  , HLF_AT          // @ characters at end of screen, characters that+                    // don't really exist in the text+  , HLF_D           // directories in CTRL-D listing+  , HLF_E           // error messages+  , HLF_I           // incremental search+  , HLF_L           // last search string+  , HLF_M           // ""--More--"" message+  , HLF_CM          // Mode (e.g., ""-- INSERT --"")+  , HLF_N           // line number for "":number"" and "":#"" commands+  , HLF_CLN         // current line number+  , HLF_R           // return to continue message and yes/no questions+  , HLF_S           // status lines+  , HLF_SNC         // status lines of not-current windows+  , HLF_C           // column to separate vertically split windows+  , HLF_T           // Titles for output from "":set all"", "":autocmd"" etc.+  , HLF_V           // Visual mode+  , HLF_VNC         // Visual mode, autoselecting and not clipboard owner+  , HLF_W           // warning messages+  , HLF_WM          // Wildmenu highlight+  , HLF_FL          // Folded line+  , HLF_FC          // Fold column+  , HLF_ADD         // Added diff line+  , HLF_CHD         // Changed diff line+  , HLF_DED         // Deleted diff line+  , HLF_TXD         // Text Changed in diff line+  , HLF_CONCEAL     // Concealed text+  , HLF_SC          // Sign column+  , HLF_SPB         // SpellBad+  , HLF_SPC         // SpellCap+  , HLF_SPR         // SpellRare+  , HLF_SPL         // SpellLocal+  , HLF_PNI         // popup menu normal item+  , HLF_PSI         // popup menu selected item+  , HLF_PSB         // popup menu scrollbar+  , HLF_PST         // popup menu scrollbar thumb+  , HLF_TP          // tabpage line+  , HLF_TPS         // tabpage line selected+  , HLF_TPF         // tabpage line filler+  , HLF_CUC         // 'cursurcolumn'+  , HLF_CUL         // 'cursurline'+  , HLF_MC          // 'colorcolumn'+  , HLF_LS          // LiveSub","I had a hard time understanding this stuff, but as far as I understood, the ""need"" here mainly is for HLF_COUNT to have the right integer value so the loops to convert e.g. a name to an id run long enough.Other than that, I also do not understand what you mean by ""hard coded LiveSub"".",X
111942,tweekmonster,https://api.github.com/repos/neovim/neovim/pulls/4932,67807293,2016-06-21T04:43:19Z,runtime/autoload/health/nvim.vim,"@@ -0,0 +1,408 @@+function! s:trim(s) abort+  return substitute(a:s, '^\_s*\|\_s*$', '', 'g')+endfunction++"" Simple version comparison.+function! s:version_cmp(a, b) abort+  let a = split(a:a, '\.')+  let b = split(a:b, '\.')++  for i in range(len(a))+    if a[i] > b[i]+      return 1+    elseif a[i] < b[i]+      return -1+    endif+  endfor++  return 0+endfunction+++"" Fetch the contents of a URL.+function! s:download(url) abort+  let content = ''+  if executable('curl')+    let content = system('curl -sL ""'.a:url.'""')+  endif++  if empty(content) && executable('python')+    let script = ""+          \try:\n+          \    from urllib.request import urlopen\n+          \except ImportError:\n+          \    from urllib2 import urlopen\n+          \\n+          \try:\n+          \    response = urlopen('"".a:url.""')\n+          \    print(response.read().decode('utf8'))\n+          \except Exception:\n+          \    pass\n+          \""+    let content = system('python -c ""'.script.'"" 2>/dev/null')+  endif++  return content+endfunction+++"" Get the latest Neovim Python client version from PyPI.  The result is+"" cached.+function! s:latest_pypi_version() abort+  if exists('s:pypi_version')+    return s:pypi_version+  endif++  let s:pypi_version = 'unknown'+  let pypi_info = s:download('https://pypi.python.org/pypi/neovim/json')+  if !empty(pypi_info)+    let pypi_data = json_decode(pypi_info)+    let s:pypi_version = get(get(pypi_data, 'info', {}), 'version', 'unknown')+    return s:pypi_version+  endif+endfunction+++"" Get version information using the specified interpreter.  The interpreter is+"" used directly in case breaking changes were introduced since the last time+"" Neovim's Python client was updated.+function! s:version_info(python) abort+  let pypi_version = s:latest_pypi_version()+  let python_version = s:trim(system(+        \ printf('""%s"" -c ""import sys; print(''.''.join(str(x) '+        \ . 'for x in sys.version_info[:3]))""', a:python)))+  if empty(python_version)+    let python_version = 'unknown'+  endif+  +  let nvim_path = s:trim(system(printf('""%s"" -c ""import sys, neovim;'+        \ . 'print(neovim.__file__)"" 2>/dev/null', a:python)))+  if empty(nvim_path)+    return [python_version, 'not found', pypi_version, 'unknown']+  endif++  let nvim_version = 'unknown'+  let base = fnamemodify(nvim_path, ':h')+  for meta in glob(base.'-*/METADATA', 1, 1) + glob(base.'-*/PKG-INFO', 1, 1)+    for meta_line in readfile(meta)+      if meta_line =~# '^Version:'+        let nvim_version = matchstr(meta_line, '^Version: \zs\S\+')+      endif+    endfor+  endfor++  let version_status = 'unknown'+  if nvim_version != 'unknown' && pypi_version != 'unknown'+    if s:version_cmp(nvim_version, pypi_version) == -1+      let version_status = 'outdated'+    else+      let version_status = 'up to date'+    endif+  endif++  return [python_version, nvim_version, pypi_version, version_status]+endfunction+++"" Check the Python interpreter's usability.+function! s:check_bin(bin, notes) abort+  if !filereadable(a:bin)+    call add(a:notes, printf('Error: ""%s"" was not found.', a:bin))+    return 0+  elseif executable(a:bin) != 1+    call add(a:notes, printf('Error: ""%s"" is not executable.', a:bin))+    return 0+  endif+  return 1+endfunction+++++"" Load the remote plugin manifest file and check for unregistered plugins+function! s:diagnose_manifest() abort+  call health#report_start('Remote Plugins')+  let existing_rplugins = {}++  for item in remote#host#PluginsForHost('python')+    let existing_rplugins[item.path] = 'python'+  endfor++  for item in remote#host#PluginsForHost('python3')+    let existing_rplugins[item.path] = 'python3'+  endfor++  let require_update = 0+  let notes = []++  for path in map(split(&runtimepath, ','), 'resolve(v:val)')+    let python_glob = glob(path.'/rplugin/python*', 1, 1)+    if empty(python_glob)+      continue+    endif++    let python_dir = python_glob[0]+    let python_version = fnamemodify(python_dir, ':t')++    for script in glob(python_dir.'/*.py', 1, 1)+          \ + glob(python_dir.'/*/__init__.py', 1, 1)+      let contents = join(readfile(script))+      if contents =~# '\<\%(from\|import\)\s\+neovim\>'+        if script =~# '/__init__\.py$'+          let script = fnamemodify(script, ':h')+        endif++        if !has_key(existing_rplugins, script)+          let msg = printf('""%s"" is not registered.', fnamemodify(path, ':t'))+          if python_version == 'pythonx'+            if !has('python2') && !has('python3')+              let msg .= ' (python2 and python3 not available)'+            endif+          elseif !has(python_version)+            let msg .= printf(' (%s not available)', python_version)+          else+            let require_update = 1+          endif++          call add(notes, msg)+        endif++        break+      endif+    endfor+  endfor++  if require_update+    call health#report_warn('Out of date', ['Run `:UpdateRemotePlugins`'])+  else+    call health#report_ok('Up to date')+  endif++  call health#report_notes(notes)+endfunction+++function! s:diagnose_python(version) abort+  let python_bin_name = 'python'.(a:version == 2 ? '' : '3')+  let pyenv = resolve(exepath('pyenv'))+  let pyenv_root = exists('$PYENV_ROOT') ? resolve($PYENV_ROOT) : ''+  let venv = exists('$VIRTUAL_ENV') ? resolve($VIRTUAL_ENV) : ''+  let host_prog_var = python_bin_name.'_host_prog'+  let host_skip_var = python_bin_name.'_host_skip_check'+  let python_bin = ''+  let python_multiple = []+  let notes = []++  call health#report_start('Python ' . a:version . ' Configuration')++  if exists('g:'.host_prog_var)+    "" call add(notes, printf('Using: g:%s = ""%s""', host_prog_var, get(g:, host_prog_var)))+    call health#report_info(printf('Using: g:%s = ""%s""', host_prog_var, get(g:, host_prog_var)))+  endif++  let [python_bin_name, pythonx_errs] = provider#pythonx#Detect(a:version)+  if empty(python_bin_name)+    "" call add(notes, 'Warning: No Python interpreter was found with the neovim '+    ""       \ . 'module.  Using the first available for diagnostics.')+    call health#report_warn('No Python interpreter was found with the neovim '+            \ . 'module.  Using the first available for diagnostics.')++    "" TODO: Not sure what to do about these errors, or if this is the right+    "" type.+    if !empty(pythonx_errs)+      call health#report_warn(pythonx_errs)+    endif+    let old_skip = get(g:, host_skip_var, 0)+    let g:[host_skip_var] = 1+    let [python_bin_name, pythonx_errs] = provider#pythonx#Detect(a:version)+    let g:[host_skip_var] = old_skip+  endif++  if !empty(python_bin_name)+    if exists('g:'.host_prog_var)+      let python_bin = exepath(python_bin_name)+    endif+    let python_bin_name = fnamemodify(python_bin_name, ':t')+  endif++  if !empty(pythonx_errs)+    call add(notes, pythonx_errs)+  endif++  if !empty(python_bin_name) && empty(python_bin) && empty(pythonx_errs)+    if !exists('g:'.host_prog_var)+      call health#report_warn(printf('""g:%s"" is not set.  Searching for '+            \ . '%s in the environment.', host_prog_var, python_bin_name))+    endif++    if !empty(pyenv)+      if empty(pyenv_root)+        call health#report_warn(+              \ 'pyenv was found, but $PYENV_ROOT is not set.'+              \ ['Did you follow the final install instructions?']+              \ )+      else+        call health#report_ok(printf('pyenv found: ""%s""', pyenv))+      endif++      let python_bin = s:trim(system(+            \ printf('""%s"" which %s 2>/dev/null', pyenv, python_bin_name)))++      if empty(python_bin)+        call health#report_warn(printf('pyenv couldn''t find %s.', python_bin_name))+      endif+    endif++    if empty(python_bin)+      let python_bin = exepath(python_bin_name)++      if exists('$PATH')+        for path in split($PATH, ':')+          let path_bin = path.'/'.python_bin_name+          if path_bin != python_bin && index(python_multiple, path_bin) == -1+                \ && executable(path_bin)+            call add(python_multiple, path_bin)+          endif+        endfor++        if len(python_multiple)+          "" This is worth noting since the user may install something+          "" that changes $PATH, like homebrew.+          call health#report_info(printf('There are multiple %s executables found.  '+                \ . 'Set ""g:%s"" to avoid surprises.', python_bin_name, host_prog_var))+        endif++        if python_bin =~# '\<shims\>'+          call health#report_warn(printf('""%s"" appears to be a pyenv shim.', python_bin), [+                      \ 'The ""pyenv"" executable is not in $PATH,',+                      \ 'Your pyenv installation is broken. You should set '+                      \ . '""g:'.host_prog_var.'"" to avoid surprises.',+                      \ ])+        endif+      endif+    endif+  endif++  if !empty(python_bin)+    if !empty(pyenv) && !exists('g:'.host_prog_var) && !empty(pyenv_root)+          \ && resolve(python_bin) !~# '^'.pyenv_root.'/'+      call health#report_warn('Your virtualenv is not set up optimally.', [+            \ printf('Suggestion: Create a virtualenv specifically '+            \ . 'for Neovim using pyenv and use ""g:%s"".  This will avoid '+            \ . 'the need to install Neovim''s Python client in each '+            \ . 'version/virtualenv.', host_prog_var)+            \ ])+    endif++    if !empty(venv) && exists('g:'.host_prog_var)+      if !empty(pyenv_root)+        let venv_root = pyenv_root+      else+        let venv_root = fnamemodify(venv, ':h')+      endif++      if resolve(python_bin) !~# '^'.venv_root.'/'+        call health#report_warn('Your virtualenv is not set up optimatlly.', [+              \ printf('Suggestion: Create a virtualenv specifically '+              \ . 'for Neovim and use ""g:%s"".  This will avoid '+              \ . 'the need to install Neovim''s Python client in each '+              \ . 'virtualenv.', host_prog_var)+              \ ])+      endif+    endif+  endif++  if empty(python_bin) && !empty(python_bin_name)+    "" An error message should have already printed.+    call health#report_error(printf('""%s"" was not found.', python_bin_name))+  elseif !empty(python_bin) && !s:check_bin(python_bin, notes)+    let python_bin = ''+  endif++  "" Check if $VIRTUAL_ENV is active+  let virtualenv_inactive = 0++  if exists('$VIRTUAL_ENV')+    if !empty(pyenv)+      let pyenv_prefix = resolve(s:trim(system(printf('""%s"" prefix', pyenv))))+      if $VIRTUAL_ENV != pyenv_prefix+        let virtualenv_inactive = 1+      endif+    elseif !empty(python_bin_name) && exepath(python_bin_name) !~# '^'.$VIRTUAL_ENV.'/'+      let virtualenv_inactive = 1+    endif+  endif++  if virtualenv_inactive+    suggestions = [+          \ 'If you are using Zsh, see: http://vi.stackexchange.com/a/7654/5229',+          \ ]+    call health#report_warn(+          \ '$VIRTUAL_ENV exists but appears to be inactive. ' +          \ . 'This could lead to unexpected results.', +          \ suggestions)+  endif++  "" Diagnostic output+  call health#report_info('Executable:' . (empty(python_bin) ? 'Not found' : python_bin))+  if len(python_multiple)+    for path_bin in python_multiple+      call health#report_info('Other python executable: ' . path_bin)+    endfor+  endif++  if !empty(python_bin)+    let [pyversion, current, latest, status] = s:version_info(python_bin)+    if a:version != str2nr(pyversion)+      "" call add(notes, 'Warning: Got an unexpected version of Python.  '+      ""       \ . 'This could lead to confusing error messages.  Please '+      ""       \ . 'consider this before reporting bugs to plugin developers.')+      call health#report_warn('Got an unexpected version of Python.' .+                  \ ' This could lead to confusing error messages.')+    endif+    if a:version == 3 && str2float(pyversion) < 3.3+      call health#report_warn('Python 3.3+ is recommended.')+    endif++    call health#report_info('Python Version: ' . pyversion)+    call health#report_info(printf('%s-neovim Version: %s', python_bin_name, current))++    if current == 'not found'+      suggestions = [+            \ 'Use the command `pip' . a:version . 'install neovim`',+            \ ]+      call health#report_error(+            \ 'Neovim Python client is not installed.',+            \ suggestions)+    endif++    if latest == 'unknown'+      call health#report_warn('Unable to fetch latest Neovim Python client version.')+    endif++    if status == 'outdated'+      call health#report_warn('Latest Neovim Python client versions: ('.latest.')')+    else+      call health#report_ok('Latest Neovim Python client is installed: ('.status.')')+    endif+  endif++  call health#report_notes(notes)+endfunction+++function! health#nvim#check() abort+  redir => report",The `redir` capturing part since that should be the only point of failure for output.  Leaving that up to checker might cause output leaking out of order or an exception thrown without `redir END`,X
111942,tweekmonster,https://api.github.com/repos/neovim/neovim/pulls/4932,67944618,2016-06-21T20:24:41Z,runtime/autoload/health/nvim.vim,"@@ -0,0 +1,408 @@+function! s:trim(s) abort+  return substitute(a:s, '^\_s*\|\_s*$', '', 'g')+endfunction++"" Simple version comparison.+function! s:version_cmp(a, b) abort+  let a = split(a:a, '\.')+  let b = split(a:b, '\.')++  for i in range(len(a))+    if a[i] > b[i]+      return 1+    elseif a[i] < b[i]+      return -1+    endif+  endfor++  return 0+endfunction+++"" Fetch the contents of a URL.+function! s:download(url) abort+  let content = ''+  if executable('curl')+    let content = system('curl -sL ""'.a:url.'""')+  endif++  if empty(content) && executable('python')+    let script = ""+          \try:\n+          \    from urllib.request import urlopen\n+          \except ImportError:\n+          \    from urllib2 import urlopen\n+          \\n+          \try:\n+          \    response = urlopen('"".a:url.""')\n+          \    print(response.read().decode('utf8'))\n+          \except Exception:\n+          \    pass\n+          \""+    let content = system('python -c ""'.script.'"" 2>/dev/null')+  endif++  return content+endfunction+++"" Get the latest Neovim Python client version from PyPI.  The result is+"" cached.+function! s:latest_pypi_version() abort+  if exists('s:pypi_version')+    return s:pypi_version+  endif++  let s:pypi_version = 'unknown'+  let pypi_info = s:download('https://pypi.python.org/pypi/neovim/json')+  if !empty(pypi_info)+    let pypi_data = json_decode(pypi_info)+    let s:pypi_version = get(get(pypi_data, 'info', {}), 'version', 'unknown')+    return s:pypi_version+  endif+endfunction+++"" Get version information using the specified interpreter.  The interpreter is+"" used directly in case breaking changes were introduced since the last time+"" Neovim's Python client was updated.+function! s:version_info(python) abort+  let pypi_version = s:latest_pypi_version()+  let python_version = s:trim(system(+        \ printf('""%s"" -c ""import sys; print(''.''.join(str(x) '+        \ . 'for x in sys.version_info[:3]))""', a:python)))+  if empty(python_version)+    let python_version = 'unknown'+  endif+  +  let nvim_path = s:trim(system(printf('""%s"" -c ""import sys, neovim;'+        \ . 'print(neovim.__file__)"" 2>/dev/null', a:python)))+  if empty(nvim_path)+    return [python_version, 'not found', pypi_version, 'unknown']+  endif++  let nvim_version = 'unknown'+  let base = fnamemodify(nvim_path, ':h')+  for meta in glob(base.'-*/METADATA', 1, 1) + glob(base.'-*/PKG-INFO', 1, 1)+    for meta_line in readfile(meta)+      if meta_line =~# '^Version:'+        let nvim_version = matchstr(meta_line, '^Version: \zs\S\+')+      endif+    endfor+  endfor++  let version_status = 'unknown'+  if nvim_version != 'unknown' && pypi_version != 'unknown'+    if s:version_cmp(nvim_version, pypi_version) == -1+      let version_status = 'outdated'+    else+      let version_status = 'up to date'+    endif+  endif++  return [python_version, nvim_version, pypi_version, version_status]+endfunction+++"" Check the Python interpreter's usability.+function! s:check_bin(bin, notes) abort+  if !filereadable(a:bin)+    call add(a:notes, printf('Error: ""%s"" was not found.', a:bin))+    return 0+  elseif executable(a:bin) != 1+    call add(a:notes, printf('Error: ""%s"" is not executable.', a:bin))+    return 0+  endif+  return 1+endfunction+++++"" Load the remote plugin manifest file and check for unregistered plugins+function! s:diagnose_manifest() abort+  call health#report_start('Remote Plugins')+  let existing_rplugins = {}++  for item in remote#host#PluginsForHost('python')+    let existing_rplugins[item.path] = 'python'+  endfor++  for item in remote#host#PluginsForHost('python3')+    let existing_rplugins[item.path] = 'python3'+  endfor++  let require_update = 0+  let notes = []++  for path in map(split(&runtimepath, ','), 'resolve(v:val)')+    let python_glob = glob(path.'/rplugin/python*', 1, 1)+    if empty(python_glob)+      continue+    endif++    let python_dir = python_glob[0]+    let python_version = fnamemodify(python_dir, ':t')++    for script in glob(python_dir.'/*.py', 1, 1)+          \ + glob(python_dir.'/*/__init__.py', 1, 1)+      let contents = join(readfile(script))+      if contents =~# '\<\%(from\|import\)\s\+neovim\>'+        if script =~# '/__init__\.py$'+          let script = fnamemodify(script, ':h')+        endif++        if !has_key(existing_rplugins, script)+          let msg = printf('""%s"" is not registered.', fnamemodify(path, ':t'))+          if python_version == 'pythonx'+            if !has('python2') && !has('python3')+              let msg .= ' (python2 and python3 not available)'+            endif+          elseif !has(python_version)+            let msg .= printf(' (%s not available)', python_version)+          else+            let require_update = 1+          endif++          call add(notes, msg)+        endif++        break+      endif+    endfor+  endfor++  if require_update+    call health#report_warn('Out of date', ['Run `:UpdateRemotePlugins`'])+  else+    call health#report_ok('Up to date')+  endif++  call health#report_notes(notes)+endfunction+++function! s:diagnose_python(version) abort+  let python_bin_name = 'python'.(a:version == 2 ? '' : '3')+  let pyenv = resolve(exepath('pyenv'))+  let pyenv_root = exists('$PYENV_ROOT') ? resolve($PYENV_ROOT) : ''+  let venv = exists('$VIRTUAL_ENV') ? resolve($VIRTUAL_ENV) : ''+  let host_prog_var = python_bin_name.'_host_prog'+  let host_skip_var = python_bin_name.'_host_skip_check'+  let python_bin = ''+  let python_multiple = []+  let notes = []++  call health#report_start('Python ' . a:version . ' Configuration')++  if exists('g:'.host_prog_var)+    "" call add(notes, printf('Using: g:%s = ""%s""', host_prog_var, get(g:, host_prog_var)))+    call health#report_info(printf('Using: g:%s = ""%s""', host_prog_var, get(g:, host_prog_var)))+  endif++  let [python_bin_name, pythonx_errs] = provider#pythonx#Detect(a:version)+  if empty(python_bin_name)+    "" call add(notes, 'Warning: No Python interpreter was found with the neovim '+    ""       \ . 'module.  Using the first available for diagnostics.')+    call health#report_warn('No Python interpreter was found with the neovim '+            \ . 'module.  Using the first available for diagnostics.')++    "" TODO: Not sure what to do about these errors, or if this is the right+    "" type.+    if !empty(pythonx_errs)+      call health#report_warn(pythonx_errs)+    endif+    let old_skip = get(g:, host_skip_var, 0)+    let g:[host_skip_var] = 1+    let [python_bin_name, pythonx_errs] = provider#pythonx#Detect(a:version)+    let g:[host_skip_var] = old_skip+  endif++  if !empty(python_bin_name)+    if exists('g:'.host_prog_var)+      let python_bin = exepath(python_bin_name)+    endif+    let python_bin_name = fnamemodify(python_bin_name, ':t')+  endif++  if !empty(pythonx_errs)+    call add(notes, pythonx_errs)+  endif++  if !empty(python_bin_name) && empty(python_bin) && empty(pythonx_errs)+    if !exists('g:'.host_prog_var)+      call health#report_warn(printf('""g:%s"" is not set.  Searching for '+            \ . '%s in the environment.', host_prog_var, python_bin_name))+    endif++    if !empty(pyenv)+      if empty(pyenv_root)+        call health#report_warn(+              \ 'pyenv was found, but $PYENV_ROOT is not set.'+              \ ['Did you follow the final install instructions?']+              \ )+      else+        call health#report_ok(printf('pyenv found: ""%s""', pyenv))+      endif++      let python_bin = s:trim(system(+            \ printf('""%s"" which %s 2>/dev/null', pyenv, python_bin_name)))++      if empty(python_bin)+        call health#report_warn(printf('pyenv couldn''t find %s.', python_bin_name))+      endif+    endif++    if empty(python_bin)+      let python_bin = exepath(python_bin_name)++      if exists('$PATH')+        for path in split($PATH, ':')+          let path_bin = path.'/'.python_bin_name+          if path_bin != python_bin && index(python_multiple, path_bin) == -1+                \ && executable(path_bin)+            call add(python_multiple, path_bin)+          endif+        endfor++        if len(python_multiple)+          "" This is worth noting since the user may install something+          "" that changes $PATH, like homebrew.+          call health#report_info(printf('There are multiple %s executables found.  '+                \ . 'Set ""g:%s"" to avoid surprises.', python_bin_name, host_prog_var))+        endif++        if python_bin =~# '\<shims\>'+          call health#report_warn(printf('""%s"" appears to be a pyenv shim.', python_bin), [+                      \ 'The ""pyenv"" executable is not in $PATH,',+                      \ 'Your pyenv installation is broken. You should set '+                      \ . '""g:'.host_prog_var.'"" to avoid surprises.',+                      \ ])+        endif+      endif+    endif+  endif++  if !empty(python_bin)+    if !empty(pyenv) && !exists('g:'.host_prog_var) && !empty(pyenv_root)+          \ && resolve(python_bin) !~# '^'.pyenv_root.'/'+      call health#report_warn('Your virtualenv is not set up optimally.', [+            \ printf('Suggestion: Create a virtualenv specifically '+            \ . 'for Neovim using pyenv and use ""g:%s"".  This will avoid '+            \ . 'the need to install Neovim''s Python client in each '+            \ . 'version/virtualenv.', host_prog_var)+            \ ])+    endif++    if !empty(venv) && exists('g:'.host_prog_var)+      if !empty(pyenv_root)+        let venv_root = pyenv_root+      else+        let venv_root = fnamemodify(venv, ':h')+      endif++      if resolve(python_bin) !~# '^'.venv_root.'/'+        call health#report_warn('Your virtualenv is not set up optimatlly.', [+              \ printf('Suggestion: Create a virtualenv specifically '+              \ . 'for Neovim and use ""g:%s"".  This will avoid '+              \ . 'the need to install Neovim''s Python client in each '+              \ . 'virtualenv.', host_prog_var)+              \ ])+      endif+    endif+  endif++  if empty(python_bin) && !empty(python_bin_name)+    "" An error message should have already printed.+    call health#report_error(printf('""%s"" was not found.', python_bin_name))+  elseif !empty(python_bin) && !s:check_bin(python_bin, notes)+    let python_bin = ''+  endif++  "" Check if $VIRTUAL_ENV is active+  let virtualenv_inactive = 0++  if exists('$VIRTUAL_ENV')+    if !empty(pyenv)+      let pyenv_prefix = resolve(s:trim(system(printf('""%s"" prefix', pyenv))))+      if $VIRTUAL_ENV != pyenv_prefix+        let virtualenv_inactive = 1+      endif+    elseif !empty(python_bin_name) && exepath(python_bin_name) !~# '^'.$VIRTUAL_ENV.'/'+      let virtualenv_inactive = 1+    endif+  endif++  if virtualenv_inactive+    suggestions = [+          \ 'If you are using Zsh, see: http://vi.stackexchange.com/a/7654/5229',+          \ ]+    call health#report_warn(+          \ '$VIRTUAL_ENV exists but appears to be inactive. ' +          \ . 'This could lead to unexpected results.', +          \ suggestions)+  endif++  "" Diagnostic output+  call health#report_info('Executable:' . (empty(python_bin) ? 'Not found' : python_bin))+  if len(python_multiple)+    for path_bin in python_multiple+      call health#report_info('Other python executable: ' . path_bin)+    endfor+  endif++  if !empty(python_bin)+    let [pyversion, current, latest, status] = s:version_info(python_bin)+    if a:version != str2nr(pyversion)+      "" call add(notes, 'Warning: Got an unexpected version of Python.  '+      ""       \ . 'This could lead to confusing error messages.  Please '+      ""       \ . 'consider this before reporting bugs to plugin developers.')+      call health#report_warn('Got an unexpected version of Python.' .+                  \ ' This could lead to confusing error messages.')+    endif+    if a:version == 3 && str2float(pyversion) < 3.3+      call health#report_warn('Python 3.3+ is recommended.')+    endif++    call health#report_info('Python Version: ' . pyversion)+    call health#report_info(printf('%s-neovim Version: %s', python_bin_name, current))++    if current == 'not found'+      suggestions = [+            \ 'Use the command `pip' . a:version . 'install neovim`',+            \ ]+      call health#report_error(+            \ 'Neovim Python client is not installed.',+            \ suggestions)+    endif++    if latest == 'unknown'+      call health#report_warn('Unable to fetch latest Neovim Python client version.')+    endif++    if status == 'outdated'+      call health#report_warn('Latest Neovim Python client versions: ('.latest.')')+    else+      call health#report_ok('Latest Neovim Python client is installed: ('.status.')')+    endif+  endif++  call health#report_notes(notes)+endfunction+++function! health#nvim#check() abort+  redir => report","Ah, didn't know it existed.  Looks like a list of checkers could be built up and ran through `capture()`",X
111942,tweekmonster,https://api.github.com/repos/neovim/neovim/pulls/4932,68170129,2016-06-23T03:11:56Z,runtime/autoload/health.vim,"@@ -1,141 +1,135 @@-function! s:trim(s) abort-  return substitute(a:s, '^\_s*\|\_s*$', '', 'g')-endfunction +"" Dictionary where we keep all of the healtch check functions we've found.+"" They will only be run if they are true+let g:health_checkers = get(g:, 'health_checkers', {})+let s:current_checker = get(s:, 'current_checker', '') -"" Simple version comparison.-function! s:version_cmp(a, b) abort-  let a = split(a:a, '\.')-  let b = split(a:b, '\.')+function! health#check(bang) abort+  let l:report = 'Checking health' -  for i in range(len(a))-    if a[i] > b[i]-      return 1-    elseif a[i] < b[i]-      return -1-    endif-  endfor -  return 0-endfunction+  for l:checker in items(g:health_checkers)+    "" Disabled checkers will not run their registered check functions+    if l:checker[1]+      let s:current_checker = l:checker[0]+      let l:report .= printf(""\nChecker %s says: %s"", s:current_checker, l:checker[1]) +      let l:report .= capture('call ' . l:checker[0] . '()')",Should this be put in a `try` block to catch unforeseen exceptions or will `capture()` grab the exception output?,X
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/4932,68172139,2016-06-23T03:49:00Z,runtime/autoload/health.vim,"@@ -1,141 +1,135 @@-function! s:trim(s) abort-  return substitute(a:s, '^\_s*\|\_s*$', '', 'g')-endfunction +"" Dictionary where we keep all of the healtch check functions we've found.+"" They will only be run if they are true+let g:health_checkers = get(g:, 'health_checkers', {})+let s:current_checker = get(s:, 'current_checker', '') -"" Simple version comparison.-function! s:version_cmp(a, b) abort-  let a = split(a:a, '\.')-  let b = split(a:b, '\.')+function! health#check(bang) abort+  let l:report = 'Checking health' -  for i in range(len(a))-    if a[i] > b[i]-      return 1-    elseif a[i] < b[i]-      return -1-    endif-  endfor -  return 0-endfunction+  for l:checker in items(g:health_checkers)+    "" Disabled checkers will not run their registered check functions+    if l:checker[1]+      let s:current_checker = l:checker[0]+      let l:report .= printf(""\nChecker %s says: %s"", s:current_checker, l:checker[1]) +      let l:report .= capture('call ' . l:checker[0] . '()')","See https://github.com/neovim/neovim/pull/4697#issuecomment-227634187- `capture('foo')` will capture the exception _and_ display it to the user  - can be wrapped in `try` if you need to handle the exception in some way- `capture('silent! foo')` will capture the exception output, without showing it to the user",
41495,Shougo,https://api.github.com/repos/neovim/neovim/pulls/4932,68367160,2016-06-24T08:17:59Z,runtime/autoload/health/nvim.vim,"@@ -0,0 +1,393 @@+function! s:trim(s) abort+  return substitute(a:s, '^\_s*\|\_s*$', '', 'g')+endfunction++"" Simple version comparison.+function! s:version_cmp(a, b) abort+  let a = split(a:a, '\.')+  let b = split(a:b, '\.')++  for i in range(len(a))+    if a[i] > b[i]+      return 1+    elseif a[i] < b[i]+      return -1+    endif+  endfor++  return 0+endfunction+++"" Fetch the contents of a URL.+function! s:download(url) abort+  let content = ''+  if executable('curl')+    let content = system('curl -sL ""'.a:url.'""')","I think using list is better like this `system(['curl', '-sL', a:url])`.",
41495,Shougo,https://api.github.com/repos/neovim/neovim/pulls/4932,68367187,2016-06-24T08:18:16Z,runtime/autoload/health/nvim.vim,"@@ -0,0 +1,393 @@+function! s:trim(s) abort+  return substitute(a:s, '^\_s*\|\_s*$', '', 'g')+endfunction++"" Simple version comparison.+function! s:version_cmp(a, b) abort+  let a = split(a:a, '\.')+  let b = split(a:b, '\.')++  for i in range(len(a))+    if a[i] > b[i]+      return 1+    elseif a[i] < b[i]+      return -1+    endif+  endfor++  return 0+endfunction+++"" Fetch the contents of a URL.+function! s:download(url) abort+  let content = ''+  if executable('curl')+    let content = system('curl -sL ""'.a:url.'""')+  endif++  if empty(content) && executable('python')+    let script = ""+          \try:\n+          \    from urllib.request import urlopen\n+          \except ImportError:\n+          \    from urllib2 import urlopen\n+          \\n+          \try:\n+          \    response = urlopen('"".a:url.""')\n+          \    print(response.read().decode('utf8'))\n+          \except Exception:\n+          \    pass\n+          \""+    let content = system('python -c ""'.script.'"" 2>/dev/null')",I think using list is better.,
41495,Shougo,https://api.github.com/repos/neovim/neovim/pulls/4932,68367201,2016-06-24T08:18:27Z,runtime/autoload/health/nvim.vim,"@@ -0,0 +1,393 @@+function! s:trim(s) abort+  return substitute(a:s, '^\_s*\|\_s*$', '', 'g')+endfunction++"" Simple version comparison.+function! s:version_cmp(a, b) abort+  let a = split(a:a, '\.')+  let b = split(a:b, '\.')++  for i in range(len(a))+    if a[i] > b[i]+      return 1+    elseif a[i] < b[i]+      return -1+    endif+  endfor++  return 0+endfunction+++"" Fetch the contents of a URL.+function! s:download(url) abort+  let content = ''+  if executable('curl')+    let content = system('curl -sL ""'.a:url.'""')+  endif++  if empty(content) && executable('python')+    let script = ""+          \try:\n+          \    from urllib.request import urlopen\n+          \except ImportError:\n+          \    from urllib2 import urlopen\n+          \\n+          \try:\n+          \    response = urlopen('"".a:url.""')\n+          \    print(response.read().decode('utf8'))\n+          \except Exception:\n+          \    pass\n+          \""+    let content = system('python -c ""'.script.'"" 2>/dev/null')+  endif++  return content+endfunction+++"" Get the latest Neovim Python client version from PyPI.  The result is+"" cached.+function! s:latest_pypi_version() abort+  if exists('s:pypi_version')+    return s:pypi_version+  endif++  let s:pypi_version = 'unknown'+  let pypi_info = s:download('https://pypi.python.org/pypi/neovim/json')+  if !empty(pypi_info)+    let pypi_data = json_decode(pypi_info)+    let s:pypi_version = get(get(pypi_data, 'info', {}), 'version', 'unknown')+    return s:pypi_version+  endif+endfunction+++"" Get version information using the specified interpreter.  The interpreter is+"" used directly in case breaking changes were introduced since the last time+"" Neovim's Python client was updated.+function! s:version_info(python) abort+  let pypi_version = s:latest_pypi_version()+  let python_version = s:trim(system(",I think using list is better,
41495,Shougo,https://api.github.com/repos/neovim/neovim/pulls/4932,68367263,2016-06-24T08:19:13Z,runtime/autoload/health/nvim.vim,"@@ -0,0 +1,393 @@+function! s:trim(s) abort+  return substitute(a:s, '^\_s*\|\_s*$', '', 'g')+endfunction++"" Simple version comparison.+function! s:version_cmp(a, b) abort+  let a = split(a:a, '\.')+  let b = split(a:b, '\.')++  for i in range(len(a))+    if a[i] > b[i]+      return 1+    elseif a[i] < b[i]+      return -1+    endif+  endfor++  return 0+endfunction+++"" Fetch the contents of a URL.+function! s:download(url) abort+  let content = ''+  if executable('curl')+    let content = system('curl -sL ""'.a:url.'""')+  endif++  if empty(content) && executable('python')+    let script = ""+          \try:\n+          \    from urllib.request import urlopen\n+          \except ImportError:\n+          \    from urllib2 import urlopen\n+          \\n+          \try:\n+          \    response = urlopen('"".a:url.""')\n+          \    print(response.read().decode('utf8'))\n+          \except Exception:\n+          \    pass\n+          \""+    let content = system('python -c ""'.script.'"" 2>/dev/null')+  endif++  return content+endfunction+++"" Get the latest Neovim Python client version from PyPI.  The result is+"" cached.+function! s:latest_pypi_version() abort+  if exists('s:pypi_version')+    return s:pypi_version+  endif++  let s:pypi_version = 'unknown'+  let pypi_info = s:download('https://pypi.python.org/pypi/neovim/json')+  if !empty(pypi_info)+    let pypi_data = json_decode(pypi_info)+    let s:pypi_version = get(get(pypi_data, 'info', {}), 'version', 'unknown')+    return s:pypi_version+  endif+endfunction+++"" Get version information using the specified interpreter.  The interpreter is+"" used directly in case breaking changes were introduced since the last time+"" Neovim's Python client was updated.+function! s:version_info(python) abort+  let pypi_version = s:latest_pypi_version()+  let python_version = s:trim(system(+        \ printf('""%s"" -c ""import sys; print(''.''.join(str(x) '+        \ . 'for x in sys.version_info[:3]))""', a:python)))+  if empty(python_version)+    let python_version = 'unknown'+  endif+  +  let nvim_path = s:trim(system(printf('""%s"" -c ""import sys, neovim;'+        \ . 'print(neovim.__file__)"" 2>/dev/null', a:python)))+  if empty(nvim_path)+    return [python_version, 'not found', pypi_version, 'unknown']+  endif++  let nvim_version = 'unknown'+  let base = fnamemodify(nvim_path, ':h')+  for meta in glob(base.'-*/METADATA', 1, 1) + glob(base.'-*/PKG-INFO', 1, 1)+    for meta_line in readfile(meta)+      if meta_line =~# '^Version:'+        let nvim_version = matchstr(meta_line, '^Version: \zs\S\+')+      endif+    endfor+  endfor++  let version_status = 'unknown'+  if nvim_version != 'unknown' && pypi_version != 'unknown'+    if s:version_cmp(nvim_version, pypi_version) == -1+      let version_status = 'outdated'+    else+      let version_status = 'up to date'+    endif+  endif++  return [python_version, nvim_version, pypi_version, version_status]+endfunction+++"" Check the Python interpreter's usability.+function! s:check_bin(bin) abort+  if !filereadable(a:bin)+    call health#report_error(printf('""%s"" was not found.', a:bin))+    return 0+  elseif executable(a:bin) != 1+    call health#report_error(printf('""%s"" is not executable.', a:bin))+    return 0+  endif+  return 1+endfunction+++++"" Load the remote plugin manifest file and check for unregistered plugins+function! s:diagnose_manifest() abort+  call health#report_start('Remote Plugins')+  let existing_rplugins = {}++  for item in remote#host#PluginsForHost('python')+    let existing_rplugins[item.path] = 'python'+  endfor++  for item in remote#host#PluginsForHost('python3')+    let existing_rplugins[item.path] = 'python3'+  endfor++  let require_update = 0+  let notes = []++  for path in map(split(&runtimepath, ','), 'resolve(v:val)')+    let python_glob = glob(path.'/rplugin/python*', 1, 1)+    if empty(python_glob)+      continue+    endif++    let python_dir = python_glob[0]+    let python_version = fnamemodify(python_dir, ':t')++    for script in glob(python_dir.'/*.py', 1, 1)+          \ + glob(python_dir.'/*/__init__.py', 1, 1)+      let contents = join(readfile(script))+      if contents =~# '\<\%(from\|import\)\s\+neovim\>'+        if script =~# '/__init__\.py$'+          let script = fnamemodify(script, ':h')+        endif++        if !has_key(existing_rplugins, script)+          let msg = printf('""%s"" is not registered.', fnamemodify(path, ':t'))+          if python_version == 'pythonx'+            if !has('python2') && !has('python3')+              let msg .= ' (python2 and python3 not available)'+            endif+          elseif !has(python_version)+            let msg .= printf(' (%s not available)', python_version)+          else+            let require_update = 1+          endif++          call add(notes, msg)+        endif++        break+      endif+    endfor+  endfor++  if require_update+    call health#report_warn('Out of date', ['Run `:UpdateRemotePlugins`'])+  else+    call health#report_ok('Up to date')+  endif++  call health#report_notes(notes)+endfunction+++function! s:diagnose_python(version) abort+  let python_bin_name = 'python'.(a:version == 2 ? '' : '3')+  let pyenv = resolve(exepath('pyenv'))+  let pyenv_root = exists('$PYENV_ROOT') ? resolve($PYENV_ROOT) : ''+  let venv = exists('$VIRTUAL_ENV') ? resolve($VIRTUAL_ENV) : ''+  let host_prog_var = python_bin_name.'_host_prog'+  let host_skip_var = python_bin_name.'_host_skip_check'+  let python_bin = ''+  let python_multiple = []+  let notes = []++  call health#report_start('Python ' . a:version . ' Configuration')++  if exists('g:'.host_prog_var)+    call health#report_info(printf('Using: g:%s = ""%s""', host_prog_var, get(g:, host_prog_var)))+  endif++  let [python_bin_name, pythonx_errs] = provider#pythonx#Detect(a:version)+  if empty(python_bin_name)+    call health#report_warn('No Python interpreter was found with the neovim '+            \ . 'module.  Using the first available for diagnostics.')++    "" TODO: Not sure what to do about these errors, or if this is the right+    "" type.+    if !empty(pythonx_errs)+      call health#report_warn(pythonx_errs)+    endif+    let old_skip = get(g:, host_skip_var, 0)+    let g:[host_skip_var] = 1+    let [python_bin_name, pythonx_errs] = provider#pythonx#Detect(a:version)+    let g:[host_skip_var] = old_skip+  endif++  if !empty(python_bin_name)+    if exists('g:'.host_prog_var)+      let python_bin = exepath(python_bin_name)+    endif+    let python_bin_name = fnamemodify(python_bin_name, ':t')+  endif++  if !empty(pythonx_errs)+    call add(notes, pythonx_errs)+  endif++  if !empty(python_bin_name) && empty(python_bin) && empty(pythonx_errs)+    if !exists('g:'.host_prog_var)+      call health#report_warn(printf('""g:%s"" is not set.  Searching for '+            \ . '%s in the environment.', host_prog_var, python_bin_name))+    endif++    if !empty(pyenv)+      if empty(pyenv_root)+        call health#report_warn(+              \ 'pyenv was found, but $PYENV_ROOT is not set.'+              \ ['Did you follow the final install instructions?']+              \ )+      else+        call health#report_ok(printf('pyenv found: ""%s""', pyenv))+      endif++      let python_bin = s:trim(system(+            \ printf('""%s"" which %s 2>/dev/null', pyenv, python_bin_name)))++      if empty(python_bin)+        call health#report_warn(printf('pyenv couldn''t find %s.', python_bin_name))+      endif+    endif++    if empty(python_bin)+      let python_bin = exepath(python_bin_name)++      if exists('$PATH')+        for path in split($PATH, ':')+          let path_bin = path.'/'.python_bin_name+          if path_bin != python_bin && index(python_multiple, path_bin) == -1+                \ && executable(path_bin)+            call add(python_multiple, path_bin)+          endif+        endfor++        if len(python_multiple)+          "" This is worth noting since the user may install something+          "" that changes $PATH, like homebrew.+          call health#report_info(printf('There are multiple %s executables found.  '+                \ . 'Set ""g:%s"" to avoid surprises.', python_bin_name, host_prog_var))+        endif++        if python_bin =~# '\<shims\>'+          call health#report_warn(printf('""%s"" appears to be a pyenv shim.', python_bin), [+                      \ 'The ""pyenv"" executable is not in $PATH,',+                      \ 'Your pyenv installation is broken. You should set '+                      \ . '""g:'.host_prog_var.'"" to avoid surprises.',+                      \ ])+        endif+      endif+    endif+  endif++  if !empty(python_bin)+    if empty(venv) && !empty(pyenv) && !exists('g:'.host_prog_var)+          \ && !empty(pyenv_root) && resolve(python_bin) !~# '^'.pyenv_root.'/'+      call health#report_warn('pyenv is not set up optimally.', [+            \ printf('Suggestion: Create a virtualenv specifically '+            \ . 'for Neovim using pyenv and use ""g:%s"".  This will avoid '+            \ . 'the need to install Neovim''s Python client in each '+            \ . 'version/virtualenv.', host_prog_var)+            \ ])+    elseif !empty(venv) && exists('g:'.host_prog_var)+      if !empty(pyenv_root)+        let venv_root = pyenv_root+      else+        let venv_root = fnamemodify(venv, ':h')+      endif++      if resolve(python_bin) !~# '^'.venv_root.'/'+        call health#report_warn('Your virtualenv is not set up optimally.', [+              \ printf('Suggestion: Create a virtualenv specifically '+              \ . 'for Neovim and use ""g:%s"".  This will avoid '+              \ . 'the need to install Neovim''s Python client in each '+              \ . 'virtualenv.', host_prog_var)+              \ ])+      endif+    endif+  endif++  if empty(python_bin) && !empty(python_bin_name)+    "" An error message should have already printed.+    call health#report_error(printf('""%s"" was not found.', python_bin_name))+  elseif !empty(python_bin) && !s:check_bin(python_bin)+    let python_bin = ''+  endif++  "" Check if $VIRTUAL_ENV is active+  let virtualenv_inactive = 0++  if exists('$VIRTUAL_ENV')+    if !empty(pyenv)+      let pyenv_prefix = resolve(s:trim(system(printf('""%s"" prefix', pyenv))))",I think using list is better,
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/4915,68490804,2016-06-25T16:53:28Z,src/nvim/state.c,"@@ -54,10 +62,23 @@ void state_enter(VimState *s)     }      int execute_result = s->execute(s, key);++    // close buffer and windows if we leave the inc_sub mode+    // and undo+    if (p_ics != 0 && EVENT_COLON && (key == ESC || key == Ctrl_C)","this  likely does not belong here, but in `ex_getln.c`",X
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/4915,68494073,2016-06-25T21:21:02Z,src/nvim/ex_cmds.c,"@@ -5846,3 +5914,286 @@ void set_context_in_sign_cmd(expand_T *xp, char_u *arg)     }   } }++/// function called after a live command to get back to+/// a normal state+/// validate can take two values :+///     0 if the live_command has not been validated+///     1 if the user has validated the command+void finish_live_cmd(int save_state,+                     garray_T *winsizes,+                     int save_exmode,+                     int save_restart_edit,+                     int save_cmdmsg_rl,+                     int validate) {+  block_autocmds();++  if (validate == 0 && sub_done == 1) {+    do_cmdline_cmd("":u"");+    sub_done = 0;+  }++  // Restore window sizes.+  if (winsizes != NULL) {+    win_size_restore(winsizes);+    ga_clear(winsizes);+  }++  unblock_autocmds();++  char_u typestr[2];+  typestr[0] = cmdwin_type;+  typestr[1] = NUL;+  apply_autocmds(EVENT_CMDWINLEAVE, typestr, typestr, false, curbuf);++  exmode_active = save_exmode;+  restart_edit = save_restart_edit;+  cmdmsg_rl = save_cmdmsg_rl;++  cmdwin_type = 0;+  RedrawingDisabled = 0;++  State = save_state;+  setmouse();+  update_screen(0);+}++/// ex_window_inc_sub()+/// Open a window for future displaying of the inc_sub mode.+///+/// Does not allow editing in the window.+/// Returns when the window is closed.+///+/// @param pat the pattern word+/// @param sub the replacement word+/// @param lmatch the list containing our data+void ex_window_inc_sub(char_u * pat,+                       char_u * sub,+                       klist_t(matchedline_T) *lmatch, // NOLINT+                       bool split)+FUNC_ATTR_NONNULL_ARG(1, 2, 3)","This should be indented. Function name in doc comment should not be present. Also no NOLINT.By the way, another way to avoid linter is```typedef klist_t(matchedline_T) MatchedLinesList;```: if line does not start with a space this rule does not apply (workaround for `int func(void) FUNC_ATTR_WARN_UNUSED_RESULT`).",X
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/4915,68494137,2016-06-25T21:25:47Z,src/nvim/ex_cmds.h,"@@ -19,13 +21,47 @@ #define ECMD_LAST       (linenr_T)-1    /* use last position in all files */ #define ECMD_ONE        (linenr_T)1     /* use first line */ +/// for cmdl_progress in incsubstitute+typedef enum {+  ICS_NO_WD,                 /// state of cmdline when none words are typed","Capitals here. Also documentation that is put after what it is documenting is marked with `///<`, not `///`. `///<` should be used on all lines.And style guide suggests using `kICSPatternStart`, `kICSPattern`, `kICSReplacementStart`, `kICSReplacement`. Current names are incorrect from the style guide point of view _and_ confusing: ���words��� you are referring to have good names ���pattern��� and ���replacement string���, no need to use indexes. And no need to fear too long constant names.",X
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/4915,68494493,2016-06-25T21:58:47Z,runtime/doc/options.txt,"@@ -4006,6 +4005,16 @@ A jump table for the options with a short description can be found at |Q_op|. 	""precedes"".  ""SpecialKey"" for ""nbsp"", ""space"", ""tab"" and ""trail"". 	|hl-NonText| |hl-SpecialKey| +						*'incsubstitute'* *'ics'*+'incsubstitute' 'ics'	number	(default 0)+			global+			+	If set to a nonzero value, substitutions (|:s|) are updated live while+	the user types the command.  If set to a nonzero value other than 1, a+	split is open which displays the lines where the search matches. The+	replacement text in the split is hightlighted using+	|hl-IncSubstitute|. Note: Only '/' is supported as a delimiter.","This is not a number option, number options define quantity (unless they are legacy like &laststatus (which BTW rejects any values, but 0, 1, 2)). I suggest string with values1. Empty (default): 0.2. `""origin""`: 1.3. `""splitview""`: 2.",X
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/4915,68494811,2016-06-25T22:31:36Z,test/functional/ui/incsubstitution_spec.lua,"@@ -0,0 +1,379 @@+-- Test the good behavior of the live action : substitution++local helpers = require('test.functional.helpers')(after_each)+local Screen = require('test.functional.ui.screen')+local clear, feed, insert = helpers.clear, helpers.feed, helpers.insert+local execute = helpers.execute++describe('Substitution', function()+  local screen++  before_each(function()+    clear()+    execute(""syntax on"")+    execute(""set incsubstitute=2"")+    execute('set nohlsearch')+    execute(""hi IncSubstitute guifg=red guibg=yellow"")+    screen = Screen.new(40, 20)  -- 40 lines of 40 char+    screen:attach()+    screen:set_default_attr_ignore( {{bold=true, foreground=Screen.colors.Blue}} )+    screen:set_default_attr_ids({+      [1]  = {foreground = Screen.colors.Fuchsia},+      [2]  = {foreground = Screen.colors.Brown, bold = true},+      [3]  = {foreground = Screen.colors.SlateBlue},+      [4]  = {bold = true, foreground = Screen.colors.SlateBlue},+      [5]  = {foreground = Screen.colors.DarkCyan},+      [6]  = {bold = true},+      [7]  = {underline = true, bold = true, foreground = Screen.colors.SlateBlue},+      [8]  = {foreground = Screen.colors.Slateblue, underline = true},+      [9]  = {background = Screen.colors.Yellow},+      [10] = {reverse = true},+      [11] = {reverse = true, bold=true},+      [12] = {foreground = Screen.colors.Red, background = Screen.colors.Yellow}+    })+  end)++  after_each(function()+    screen:detach()+  end)++  -- ----------------------------------------------------------------------+  -- simple tests+  -- ----------------------------------------------------------------------++  it('old behavior if :set incsubstitute=0', function()+    insert([[+      these are some lines+      with colorful text (are)]])++    feed(':set incsubstitute=0\n')+    feed(':%s/are/ARE')++    screen:expect([[+      these are some lines                    |+      with colorful text (are)                |+      ~                                       |+      ~                                       |+      ~                                       |+      ~                                       |+      ~                                       |+      ~                                       |+      ~                                       |+      ~                                       |+      ~                                       |+      ~                                       |+      ~                                       |+      ~                                       |+      ~                                       |+      ~                                       |+      ~                                       |+      ~                                       |+      ~                                       |+      :%s/are/ARE^                             |+    ]])++    feed('\27')     -- ESC+    feed(':%s/are/ARE\n')++    screen:expect([[+      these ARE some lines                    |+      ^with colorful text (ARE)                |+      ~                                       |+      ~                                       |+      ~                                       |+      ~                                       |+      ~                                       |+      ~                                       |+      ~                                       |+      ~                                       |+      ~                                       |+      ~                                       |+      ~                                       |+      ~                                       |+      ~                                       |+      ~                                       |+      ~                                       |+      ~                                       |+      ~                                       |+      :%s/are/ARE                             |+    ]])+  end)++  it('no split if :s', function()+    insert([[+      these are some lines+      with colorful text (are)]])++    feed(':s/are/ARE')++    screen:expect([[+      these are some lines                    |+      with colorful text (ARE)                |+      ~                                       |+      ~                                       |+      ~                                       |+      ~                                       |+      ~                                       |+      ~                                       |+      ~                                       |+      ~                                       |+      ~                                       |+      ~                                       |+      ~                                       |+      ~                                       |+      ~                                       |+      ~                                       |+      ~                                       |+      ~                                       |+      ~                                       |+      :s/are/ARE^                              |+    ]])+  end)++  it('split if :%s/are', function()+    insert([[+      these are some lines+      without colorful text (are)]])++    execute('set hlsearch')+    feed(':%s/are')++    screen:expect([[+      these {9:are} some lines                    |+      without colorful text ({9:are})             |+      ~                                       |+      ~                                       |+      ~                                       |+      ~                                       |+      ~                                       |+      ~                                       |+      ~                                       |+      ~                                       |+      {11:[No Name] [+]                           }|+       [1]these {9:are} some lines                |+       [2]without colorful text ({9:are})         |+                                              |+      ~                                       |+      ~                                       |+      ~                                       |+      ~                                       |+      {10:[inc_sub]                               }|+      :%s/are^                                 |+    ]])+  end)++  it('split if :%s/are/', function()+    insert([[+      these are some lines+      with colorful text (are)]])++    feed(':%s/are/')++    screen:expect([[+      these  some lines                       |+      with colorful text ()                   |+      ~                                       |+      ~                                       |+      ~                                       |+      ~                                       |+      ~                                       |+      ~                                       |+      ~                                       |+      ~                                       |+      {11:[No Name] [+]                           }|+       [1]these  some lines                   |+       [2]with colorful text ()               |+                                              |+      ~                                       |+      ~                                       |+      ~                                       |+      ~                                       |+      {10:[inc_sub]                               }|+      :%s/are/^                                |+    ]])+  end)+++  it('split if :%s/are/to', function()+    insert([[+      these are some lines+      with colorful text (are)]])++    feed(':%s/are/to')++    screen:expect([[+      these to some lines                     |+      with colorful text (to)                 |+      ~                                       |+      ~                                       |+      ~                                       |+      ~                                       |+      ~                                       |+      ~                                       |+      ~                                       |+      ~                                       |+      {11:[No Name] [+]                           }|+       [1]these {12:to} some lines                 |+       [2]with colorful text ({12:to})             |+                                              |+      ~                                       |+      ~                                       |+      ~                                       |+      ~                                       |+      {10:[inc_sub]                               }|+      :%s/are/to^                              |+    ]])+  end)++  it('with set incsubstitute=1', function()+    execute('set incsubstitute=1')+    insert([[+      these are some lines+      with colorful text (are)]])++    feed(':%s/are/to')++    screen:expect([[+      these to some lines                     |+      with colorful text (to)                 |+      ~                                       |+      ~                                       |+      ~                                       |+      ~                                       |+      ~                                       |+      ~                                       |+      ~                                       |+      ~                                       |+      ~                                       |+      ~                                       |+      ~                                       |+      ~                                       |+      ~                                       |+      ~                                       |+      ~                                       |+      ~                                       |+      ~                                       |+      :%s/are/to^                              |+    ]])++  end)++  -- ----------------------------------------------------------------------+  -- complex tests+  -- ----------------------------------------------------------------------++  it('scenario', function()+    insert([[+      these are some lines+      with colorful text (are)]])++    feed('gg')+    feed('2yy')+    feed('1000p')+    execute('set nohlsearch')+    execute(':%s/are/ARE')     -- simple sub++    screen:expect([[+      these ARE some lines                    |+      with colorful text (ARE)                |+      these ARE some lines                    |+      with colorful text (ARE)                |+      these ARE some lines                    |+      with colorful text (ARE)                |+      these ARE some lines                    |+      with colorful text (ARE)                |+      these ARE some lines                    |+      with colorful text (ARE)                |+      these ARE some lines                    |+      with colorful text (ARE)                |+      these ARE some lines                    |+      with colorful text (ARE)                |+      these ARE some lines                    |+      with colorful text (ARE)                |+      these ARE some lines                    |+      with colorful text (ARE)                |+      ^with colorful text (ARE)                |+      2002 substitutions on 2002 lines        |+    ]])++    execute(':%s/some.*/nothing')      -- regex sub++    screen:expect([[+      these ARE nothing                       |+      with colorful text (ARE)                |+      these ARE nothing                       |+      with colorful text (ARE)                |+      these ARE nothing                       |+      with colorful text (ARE)                |+      these ARE nothing                       |+      with colorful text (ARE)                |+      these ARE nothing                       |+      with colorful text (ARE)                |+      these ARE nothing                       |+      with colorful text (ARE)                |+      these ARE nothing                       |+      with colorful text (ARE)                |+      these ARE nothing                       |+      with colorful text (ARE)                |+      ^these ARE nothing                       |+      with colorful text (ARE)                |+      with colorful text (ARE)                |+      1001 substitutions on 1001 lines        |+    ]])++    feed('i')+    feed('example of insertion')++    screen:expect([[+      these ARE nothing                       |+      with colorful text (ARE)                |+      these ARE nothing                       |+      with colorful text (ARE)                |+      these ARE nothing                       |+      with colorful text (ARE)                |+      these ARE nothing                       |+      with colorful text (ARE)                |+      these ARE nothing                       |+      with colorful text (ARE)                |+      these ARE nothing                       |+      with colorful text (ARE)                |+      these ARE nothing                       |+      with colorful text (ARE)                |+      these ARE nothing                       |+      with colorful text (ARE)                |+      example of insertion^these ARE nothing   |+      with colorful text (ARE)                |+      with colorful text (ARE)                |+      {6:-- INSERT --}                            |+   ]])++   feed('<esc>')+   execute('set incsubstitute=2')+   execute('1,1000s/ARE/nut/g')+   feed(':%s/ARE/to')++   screen:expect([[+     with colorful text (to)                 |+     these to nothing                        |+     with colorful text (to)                 |+     these to nothing                        |+     with colorful text (to)                 |+     these to nothing                        |+     with colorful text (to)                 |+     example of insertionthese to nothing    |+     with colorful text (to)                 |+     with colorful text (to)                 |+     {11:[No Name] [+]                           }|+      [1001]with colorful text ({12:to})          |+      [1002]these {12:to} nothing                 |+      [1003]with colorful text ({12:to})          |+      [1004]these {12:to} nothing                 |+      [1005]with colorful text ({12:to})          |+      [1006]these {12:to} nothing                 |+      [1007]with colorful text ({12:to})          |+     {10:[inc_sub]                               }|+     :%s/ARE/to^                              |+   ]])+  end)++end)","Missing tests:1. `s@test@���`. I know that currently it only works with `/`, but this only means that tests should check that Neovim does not crash (or whatever) with `@` as delimiters, not that all tests should use `/`.2. One of the livesub tests, but with all characters coming from `cnoremap / /` (i.e. remapped to themselves).3. Livesub test with characters coming from mapping that moves the cursor (e.g. `:%s/ARE,S` with `cnoremap ,S \(\)<left><left>`).4. Livesub tests with unfinished failing pattern which _fails_ to compile like `foo\(`.5. Livesub tests with unfinished failing replacement: e.g. `%s/ARE/\='to`.6. Livesub tests with finished failing replacement: e.g. `%s/ARE/\=xxx_nonexistent_var_xxx`.7. Livesub splitview tests with failing mapping: e.g. `%s/ARE/tox` with `cnoremap <expr> x capture('bwipeout!')[-1].'x'` (this one should produce an error because `bwipeout!` fails due to textlock).8. Livesub splitview tests with mapping which temporary moves the cursor: e.g. `%s/ARE/tox` with `cnoremap <expr> x cursor(1, 1)[-1].'x'`.9. Livesub tests with mapping which disables livesub: e.g. `%s/ARE/tox` with `cnoremap <expr> x capture('set incsubstitute=')[-1]`. Especially interesting what splitview livesub will do here.10. Livesub tests with mapping which saves command line, opens a temporary split with new buffer, wipes it out and restores command line: e.g. `%s/ARE/tox` with `cnoremap x <C-\>eextend(g:, {'foo_savedcmdline': getcmdline()}).foo_savedcmdline<CR><C-c>:new<CR>:bw!<CR>:<C-r>=remove(g:, 'foo_savedcmdline')<CR>x`. Again, splitview livesub is especially interesting.11. Tests which check what autocommands (out of Buf*, Win*, Syntax and FileType) are run when ics=splitview opens and closes a window. If no are run and this is intended, tests should check that no are run.12. If any are run when window is opened, then tests which check what if these autocommands close the window.13. If any are run when window is opened, then tests which check what if these autocommands wipe out buffer without closing the window.14. If any are run when window is opened, then tests which check what if these autocommands switch buffer without closing the window or wiping buffer out.15. If any are run when window is opened, then tests which check what if these autocommands wipe out buffer where substitution is being made.16. If any are run when window is opened, then tests which check what if these autocommands close window where substitution is being made (but not window with temporary view).",X
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/4950,68512337,2016-06-26T23:35:10Z,test/functional/terminal/job_spec.lua,"@@ -31,9 +30,6 @@ describe('job handler', function()         elseif 'stderr' ==# a:event           put =join(a:data,""\n"")         elseif 'exit' ==# a:event-          "" Length of received data.-          call setline('.', 'bytes: '.len(join(g:job_stdout[0:-2],""\n"")))",@jamessan There might not be a bug here after all. Instead this might be the result of the behavior described here: https://github.com/neovim/neovim/issues/4897#issuecomment-224754553Because the job handlers here are blindly joining `a:data` without regards to whether `a:data` continues a previous partial result.,
112971,jamessan,https://api.github.com/repos/neovim/neovim/pulls/4950,68512702,2016-06-26T23:55:22Z,test/functional/terminal/job_spec.lua,"@@ -31,9 +30,6 @@ describe('job handler', function()         elseif 'stderr' ==# a:event           put =join(a:data,""\n"")         elseif 'exit' ==# a:event-          "" Length of received data.-          call setline('.', 'bytes: '.len(join(g:job_stdout[0:-2],""\n"")))",> Because the job handlers here are blindly joining a:data without regards to whether a:data continues a previous partial result.Then the help should be clarified.  I've read ZyX's response there and the help a few times now and I can't fully understand ZyX's description nor see anything in the help that agrees with what I think he's trying to state.It's especially bad since all of the examples in the help seem to be doing **exactly** what ZyX is saying shouldn't be done.,X
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/4980,68700526,2016-06-28T05:47:49Z,test/functional/provider/ruby_spec.lua,"@@ -0,0 +1,69 @@+local helpers = require('test.functional.helpers')(after_each)++local eq = helpers.eq+local neq = helpers.neq+local feed = helpers.feed+local clear = helpers.clear+local funcs = helpers.funcs+local meths = helpers.meths+local insert = helpers.insert+local expect = helpers.expect+local command = helpers.command+local exc_exec = helpers.exc_exec+local write_file = helpers.write_file+local curbufmeths = helpers.curbufmeths","There should be a check like https://github.com/neovim/neovim/blob/master/test/functional/provider/python_spec.lua#L16-L26 so that the tests show up in the ""pending"" list (and won't fail) if ruby is missing.``` lua  do    clear()    command('let [g:interp, g:errors] = provider#ruby#Detect()')    local errors = meths.get_var('errors')    if errors ~= '' then      pending(        'Ruby (or the Ruby neovim gem) is broken or missing:\n' .. errors,        function() end)      return    end  end```",X
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/4980,68722195,2016-06-28T09:07:48Z,runtime/autoload/provider/script_host.rb,"@@ -0,0 +1,42 @@+require ""neovim/vim_compatibility""++Neovim.plugin do |plug|+  plug.rpc(:ruby_execute, sync: true) do |nvim, *args|+    ruby, start, stop = args+    nvim.current.range = (start-1..stop-1)++    Neovim::VimCompatibility.wrap_client(nvim) do+      eval(ruby, binding, __FILE__, __LINE__)+    end+  end++  plug.rpc(:ruby_execute_file, sync: true) do |nvim, *args|+    script, start, stop = args+    nvim.current.range = (start-1..stop-1)++    Neovim::VimCompatibility.wrap_client(nvim) do+      eval(File.read(script), binding, __FILE__, __LINE__)+    end+  end++  plug.rpc(:ruby_do_range, sync: true) do |nvim, *args|+    begin+      start, stop, script = args+      buffer = nvim.current.buffer++      (start-1..stop-1).each_slice(5000) do |linenos|+        lines = buffer.get_line_slice(linenos[0], linenos[-1], true, true)","please use `get_lines` and `set_lines` instead, these functions are deprecated.",X
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/4963,68726333,2016-06-28T09:36:04Z,src/nvim/ops.c,"@@ -1686,9 +1686,10 @@ int op_replace(oparg_T *oap, int c)        oldp = get_cursor_line_ptr();       oldlen = STRLEN(oldp);-      assert(n >= 0);-      newp = (char_u *)xmalloc(oldlen + 1 + (size_t)n);-      memset(newp, NUL, oldlen + 1 + (size_t)n);+      assert(oldlen <= (size_t)(INT_MAX - 1 - n));","I looked at the code after `xcalloc()` to see how big `newp` needs to be. Looks like one could also remove a lot of `strlen()` calls.``` diffdiff --git a/src/nvim/ops.c b/src/nvim/ops.cindex 51cb8a0..3d09142 100644--- a/src/nvim/ops.c+++ b/src/nvim/ops.c@@ -1681,15 +1681,19 @@ int op_replace(oparg_T *oap, int c)       /* Compute bytes needed, move character count to num_chars. */       num_chars = numc;       numc *= (*mb_char2len)(c);-      /* oldlen includes textlen, so don't double count */-      n += numc - bd.textlen;       oldp = get_cursor_line_ptr();       oldlen = STRLEN(oldp);-      assert(oldlen <= (size_t)(INT_MAX - 1 - n));-      int new_size = (int)oldlen + 1 + n;-      assert(new_size >= 0);-      newp = xcalloc((size_t)new_size, 1);++      size_t newp_size = (size_t)(bd.textcol + bd.startspaces);+      if (had_ctrl_v_cr || (c != '\r' && c != '\n')) {+        newp_size += (size_t)numc;+        if (!bd.is_short) {+          newp_size += bd.endspaces + oldlen - bd.textcol - bd.textlen + 1;+        }+      }+      newp = xcalloc(newp_size, 1);+       // copy up to deleted part       memmove(newp, oldp, (size_t)bd.textcol);       oldp += bd.textcol + bd.textlen;@@ -1697,28 +1701,36 @@ int op_replace(oparg_T *oap, int c)       memset(newp + bd.textcol, ' ', (size_t)bd.startspaces);       // insert replacement chars CHECK FOR ALLOCATED SPACE       // -1/-2 is used for entering CR literally.+      size_t after_p_len = 0;       if (had_ctrl_v_cr || (c != '\r' && c != '\n')) {-        if (has_mbyte) {-          n = (int)STRLEN(newp);-          while (--num_chars >= 0)-            n += (*mb_char2bytes)(c, newp + n);-        } else-          memset(newp + STRLEN(newp), c, (size_t)numc);-        if (!bd.is_short) {-          /* insert post-spaces */-          memset(newp + STRLEN(newp), ' ', (size_t)bd.endspaces);-          /* copy the part after the changed part */-          STRMOVE(newp + STRLEN(newp), oldp);+          // strlen(newp) at this point+          int newp_len = bd.textcol + bd.startspaces;+          if (has_mbyte) {+            while (--num_chars >= 0) {+              newp_len += (*mb_char2bytes)(c, newp + newp_len);+            }+          } else {+            memset(newp + newp_len, c, (size_t)numc);+            newp_len += numc;+          }+          if (!bd.is_short) {+            // insert post-spaces+            memset(newp + newp_len, ' ', (size_t)bd.endspaces);+            newp_len += bd.endspaces;+            // copy the part after the changed part+            memmove(newp + newp_len, oldp,+                    oldlen - bd.textcol - bd.textlen + 1);         }       } else {         // Replacing with \r or \n means splitting the line.-        after_p = (char_u *)xmalloc(oldlen + 1 + (size_t)n - STRLEN(newp));-        STRMOVE(after_p, oldp);+        after_p_len = (size_t)(oldlen - bd.textcol - bd.textlen + 1);+        after_p = (char_u *)xmalloc(after_p_len);+        memmove(after_p, oldp, after_p_len);       }       /* replace the line */       ml_replace(curwin->w_cursor.lnum, newp, FALSE);       if (after_p != NULL) {-        ml_append(curwin->w_cursor.lnum++, after_p, 0, FALSE);+        ml_append(curwin->w_cursor.lnum++, after_p, (int)after_p_len, FALSE);         appended_lines_mark(curwin->w_cursor.lnum, 1L);         oap->end.lnum++;         xfree(after_p);```",X
4466899,tjdevries,https://api.github.com/repos/neovim/neovim/pulls/4932,69033949,2016-06-29T21:43:03Z,runtime/autoload/health/nvim.vim,"@@ -0,0 +1,410 @@+"" Script variables+let s:bad_responses = ['unknown', 'unable to parse', 'unable to get pypi response', 'unable to get neovim executable']++function! s:trim(s) abort+  return substitute(a:s, '^\_s*\|\_s*$', '', 'g')+endfunction++"" Simple version comparison.+function! s:version_cmp(a, b) abort+  let a = split(a:a, '\.')+  let b = split(a:b, '\.')++  for i in range(len(a))+    if a[i] > b[i]+      return 1+    elseif a[i] < b[i]+      return -1+    endif+  endfor++  return 0+endfunction+++"" Fetch the contents of a URL.+function! s:download(url) abort+  let content = ''+  if executable('curl')+    let content = system(['curl', '-sL', ""'"", a:url, ""'""])+  endif++  if empty(content) && executable('python')+    let script = ""+          \try:\n+          \    from urllib.request import urlopen\n+          \except ImportError:\n+          \    from urllib2 import urlopen\n+          \\n+          \try:\n+          \    response = urlopen('"".a:url.""')\n+          \    print(response.read().decode('utf8'))\n+          \except Exception:\n+          \    pass\n+          \""+    let content = system(['python', '-c', ""'"", script, ""'"", '2>/dev/null')+  endif++  return content+endfunction+++"" Get the latest Neovim Python client version from PyPI.  The result is+"" cached.+function! s:latest_pypi_version() abort+  if exists('s:pypi_version')+    return s:pypi_version+  endif++  let s:pypi_version = 'unable to get pypi response'+  let pypi_info = s:download('https://pypi.python.org/pypi/neovim/json')+  if !empty(pypi_info)+    let pypi_data = json_decode(pypi_info)+    let s:pypi_version = get(get(pypi_data, 'info', {}), 'version', 'unable to parse')+    return s:pypi_version+  endif+endfunction+++""""+"" Get version information using the specified interpreter.  The interpreter is+"" used directly in case breaking changes were introduced since the last time+"" Neovim's Python client was updated.+""+"" Returns [+""           python executable version,+""           current nvim version,+""           current pypi nvim status,+""           installed version status+""         ]+function! s:version_info(python) abort+  let pypi_version = s:latest_pypi_version()+  let python_version = s:trim(system([+        \ a:python, +        \ '-c',+        \ '""import sys; print(\"".\"".join(str(x) for x in sys.version_info[:3]))""']))++  if empty(python_version)+    let python_version = 'unknown'+  endif++  let nvim_path = s:trim(system([+        \ a:python,+        \ '-c',+        \ '""import sys, neovim; print(neovim.__file__)""',+        \ '2>/dev/null']))++  if empty(nvim_path)+    return [python_version, 'not found', pypi_version, 'unable to get neovim executable']+  endif++  let nvim_version = 'unknown'+  let base = fnamemodify(nvim_path, ':h')+  for meta in glob(base.'-*/METADATA', 1, 1) + glob(base.'-*/PKG-INFO', 1, 1)+    for meta_line in readfile(meta)+      if meta_line =~# '^Version:'+        let nvim_version = matchstr(meta_line, '^Version: \zs\S\+')+      endif+    endfor+  endfor++  let version_status = 'unknown'+  if nvim_version != 'unknown' && pypi_version != 'unknown'+    if s:version_cmp(nvim_version, pypi_version) == -1+      let version_status = 'outdated'+    else+      let version_status = 'up to date'+    endif+  endif++  return [python_version, nvim_version, pypi_version, version_status]+endfunction+++"" Check the Python interpreter's usability.+function! s:check_bin(bin) abort+  if !filereadable(a:bin)+    call health#report_error(printf('""%s"" was not found.', a:bin))+    return 0+  elseif executable(a:bin) != 1+    call health#report_error(printf('""%s"" is not executable.', a:bin))+    return 0+  endif+  return 1+endfunction+++++"" Load the remote plugin manifest file and check for unregistered plugins+function! s:diagnose_manifest() abort+  call health#report_start('Remote Plugins')+  let existing_rplugins = {}++  for item in remote#host#PluginsForHost('python')+    let existing_rplugins[item.path] = 'python'+  endfor++  for item in remote#host#PluginsForHost('python3')+    let existing_rplugins[item.path] = 'python3'+  endfor++  let require_update = 0+  let notes = []++  for path in map(split(&runtimepath, ','), 'resolve(v:val)')+    let python_glob = glob(path.'/rplugin/python*', 1, 1)+    if empty(python_glob)+      continue+    endif++    let python_dir = python_glob[0]+    let python_version = fnamemodify(python_dir, ':t')++    for script in glob(python_dir.'/*.py', 1, 1)+          \ + glob(python_dir.'/*/__init__.py', 1, 1)+      let contents = join(readfile(script))+      if contents =~# '\<\%(from\|import\)\s\+neovim\>'+        if script =~# '/__init__\.py$'+          let script = fnamemodify(script, ':h')+        endif++        if !has_key(existing_rplugins, script)+          let msg = printf('""%s"" is not registered.', fnamemodify(path, ':t'))+          if python_version == 'pythonx'+            if !has('python2') && !has('python3')+              let msg .= ' (python2 and python3 not available)'+            endif+          elseif !has(python_version)+            let msg .= printf(' (%s not available)', python_version)+          else+            let require_update = 1+          endif++          call add(notes, msg)+        endif++        break+      endif+    endfor+  endfor++  if require_update+    call health#report_warn('Out of date', ['Run `:UpdateRemotePlugins`'])+  else+    call health#report_ok('Up to date')+  endif++  call health#report_notes(notes)+endfunction+++function! s:diagnose_python(version) abort+  let python_bin_name = 'python'.(a:version == 2 ? '' : '3')+  let pyenv = resolve(exepath('pyenv'))+  let pyenv_root = exists('$PYENV_ROOT') ? resolve($PYENV_ROOT) : 'n'+  let venv = exists('$VIRTUAL_ENV') ? resolve($VIRTUAL_ENV) : ''+  let host_prog_var = python_bin_name.'_host_prog'+  let host_skip_var = python_bin_name.'_host_skip_check'+  let python_bin = ''+  let python_multiple = []+  let notes = []++  call health#report_start('Python ' . a:version . ' Configuration')++  if exists('g:'.host_prog_var)+    call health#report_info(printf('Using: g:%s = ""%s""', host_prog_var, get(g:, host_prog_var)))+  endif++  let [python_bin_name, pythonx_errs] = provider#pythonx#Detect(a:version)+  if empty(python_bin_name)+    call health#report_warn('No Python interpreter was found with the neovim '+            \ . 'module.  Using the first available for diagnostics.')++    "" TODO: Not sure what to do about these errors, or if this is the right+    "" type.+    if !empty(pythonx_errs)+      call health#report_warn(pythonx_errs)+    endif+    let old_skip = get(g:, host_skip_var, 0)+    let g:[host_skip_var] = 1+    let [python_bin_name, pythonx_errs] = provider#pythonx#Detect(a:version)+    let g:[host_skip_var] = old_skip+  endif++  if !empty(python_bin_name)+    if exists('g:'.host_prog_var)+      let python_bin = exepath(python_bin_name)+    endif+    let python_bin_name = fnamemodify(python_bin_name, ':t')+  endif++  if !empty(pythonx_errs)+    call add(notes, pythonx_errs)+  endif++  if !empty(python_bin_name) && empty(python_bin) && empty(pythonx_errs)+    if !exists('g:'.host_prog_var)+      call health#report_warn(printf('""g:%s"" is not set.  Searching for '+            \ . '%s in the environment.', host_prog_var, python_bin_name))+    endif++    if !empty(pyenv)+      if empty(pyenv_root)+        call health#report_warn(+              \ 'pyenv was found, but $PYENV_ROOT is not set.'+              \ ['Did you follow the final install instructions?']+              \ )+      else+        call health#report_ok(printf('pyenv found: ""%s""', pyenv))+      endif++      let python_bin = s:trim(system(+            \ printf('""%s"" which %s 2>/dev/null', pyenv, python_bin_name)))++      if empty(python_bin)+        call health#report_warn(printf('pyenv couldn''t find %s.', python_bin_name))+      endif+    endif++    if empty(python_bin)+      let python_bin = exepath(python_bin_name)++      if exists('$PATH')+        for path in split($PATH, ':')+          let path_bin = path.'/'.python_bin_name+          if path_bin != python_bin && index(python_multiple, path_bin) == -1+                \ && executable(path_bin)+            call add(python_multiple, path_bin)+          endif+        endfor++        if len(python_multiple)+          "" This is worth noting since the user may install something+          "" that changes $PATH, like homebrew.+          call health#report_info(printf('There are multiple %s executables found.  '+                \ . 'Set ""g:%s"" to avoid surprises.', python_bin_name, host_prog_var))+        endif++        if python_bin =~# '\<shims\>'+          call health#report_warn(printf('""%s"" appears to be a pyenv shim.', python_bin), [+                      \ 'The ""pyenv"" executable is not in $PATH,',+                      \ 'Your pyenv installation is broken. You should set '+                      \ . '""g:'.host_prog_var.'"" to avoid surprises.',+                      \ ])+        endif+      endif+    endif+  endif++  if !empty(python_bin)+    if empty(venv) && !empty(pyenv) && !exists('g:'.host_prog_var)+          \ && !empty(pyenv_root) && resolve(python_bin) !~# '^'.pyenv_root.'/'+      call health#report_warn('pyenv is not set up optimally.', [+            \ printf('Suggestion: Create a virtualenv specifically '+            \ . 'for Neovim using pyenv and use ""g:%s"".  This will avoid '+            \ . 'the need to install Neovim''s Python client in each '+            \ . 'version/virtualenv.', host_prog_var)+            \ ])+    elseif !empty(venv) && exists('g:'.host_prog_var)+      if !empty(pyenv_root)+        let venv_root = pyenv_root+      else+        let venv_root = fnamemodify(venv, ':h')+      endif++      if resolve(python_bin) !~# '^'.venv_root.'/'+        call health#report_warn('Your virtualenv is not set up optimally.', [+              \ printf('Suggestion: Create a virtualenv specifically '+              \ . 'for Neovim and use ""g:%s"".  This will avoid '+              \ . 'the need to install Neovim''s Python client in each '+              \ . 'virtualenv.', host_prog_var)+              \ ])+      endif+    endif+  endif++  if empty(python_bin) && !empty(python_bin_name)+    "" An error message should have already printed.+    call health#report_error(printf('""%s"" was not found.', python_bin_name))+  elseif !empty(python_bin) && !s:check_bin(python_bin)+    let python_bin = ''+  endif++  "" Check if $VIRTUAL_ENV is active+  let virtualenv_inactive = 0++  if exists('$VIRTUAL_ENV')+    if !empty(pyenv)+      let pyenv_prefix = resolve(s:trim(system(['""' . pyenv . '""', 'prefix'])))+      if $VIRTUAL_ENV != pyenv_prefix+        let virtualenv_inactive = 1+      endif+    elseif !empty(python_bin_name) && exepath(python_bin_name) !~# '^'.$VIRTUAL_ENV.'/'+      let virtualenv_inactive = 1+    endif+  endif++  if virtualenv_inactive+    let suggestions = [+          \ 'If you are using Zsh, see: http://vi.stackexchange.com/a/7654/5229',+          \ ]+    call health#report_warn(+          \ '$VIRTUAL_ENV exists but appears to be inactive. '+          \ . 'This could lead to unexpected results.',+          \ suggestions)+  endif++  "" Diagnostic output+  call health#report_info('Executable:' . (empty(python_bin) ? 'Not found' : python_bin))+  if len(python_multiple)+    for path_bin in python_multiple+      call health#report_info('Other python executable: ' . path_bin)+    endfor+  endif++  if !empty(python_bin)+    let [pyversion, current, latest, status] = s:version_info(python_bin)+    if a:version != str2nr(pyversion)+      call health#report_warn('Got an unexpected version of Python.' .+                  \ ' This could lead to confusing error messages.')+    endif+    if a:version == 3 && str2float(pyversion) < 3.3+      call health#report_warn('Python 3.3+ is recommended.')+    endif++    call health#report_info('Python Version: ' . pyversion)+    call health#report_info(printf('%s-neovim Version: %s', python_bin_name, current))++    if current == 'not found'+      let suggestions = [+            \ 'Use the command `pip' . a:version . 'install neovim`',+            \ ]+      call health#report_error(+            \ 'Neovim Python client is not installed.',+            \ suggestions)+    endif++    if latest == 'unknown'+      call health#report_warn('Unable to fetch latest Neovim Python client version.')+    endif++    if status == 'outdated'+      call health#report_warn('Latest Neovim Python client versions: ('.latest.')')+    else+      call health#report_ok('Latest Neovim Python client is installed: ('.status.')')+    endif+  endif++  call health#report_notes(notes)","It was left over from before essentially. I think this is covered by using `health#report_info` now, or by warning with a list of warnings. I removed it and the original function definition.",X
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/4932,69036059,2016-06-29T21:57:12Z,runtime/autoload/health.vim,"@@ -1,433 +1,181 @@-function! s:trim(s) abort-  return substitute(a:s, '^\_s*\|\_s*$', '', 'g')-endfunction+"" Dictionary where we keep all of the healtch check functions we've found.+"" They will only be run if they are true+let g:health_checkers = get(g:, 'health_checkers', {})+let s:current_checker = get(s:, 'current_checker', '')++""""+"" Function to run the health checkers+"" It manages the output and any file local settings+function! health#check(bang) abort+  let l:report = '# Checking health' +  if g:health_checkers == {}+    call s:add_checker(health#_default_checkers())+  endif -"" Simple version comparison.-function! s:version_cmp(a, b) abort-  let a = split(a:a, '\.')-  let b = split(a:b, '\.')+  for l:checker in items(g:health_checkers)+    "" Disabled checkers will not run their registered check functions+    if l:checker[1]+      let s:current_checker = l:checker[0]+      let l:report .= ""\n\n--------------------------------------------------------------------------------\n""+      let l:report .= printf(""\nChecker %s says:\n"", s:current_checker) -  for i in range(len(a))-    if a[i] > b[i]-      return 1-    elseif a[i] < b[i]-      return -1+      let l:report .= capture('silent! call ' . l:checker[0] . '()')     endif   endfor -  return 0-endfunction---"" Fetch the contents of a URL.-function! s:download(url) abort-  let content = ''-  if executable('curl')-    let content = system('curl -sL ""'.a:url.'""')-  endif+  let l:report .= ""\n--------------------------------------------------------------------------------\n"" -  if empty(content) && executable('python')-    let script = ""-          \try:\n-          \    from urllib.request import urlopen\n-          \except ImportError:\n-          \    from urllib2 import urlopen\n-          \\n-          \try:\n-          \    response = urlopen('"".a:url.""')\n-          \    print(response.read().decode('utf8'))\n-          \except Exception:\n-          \    pass\n-          \""-    let content = system('python -c ""'.script.'"" 2>/dev/null')+  if a:bang+    new+    setlocal bufhidden=wipe+    set syntax=health+    set filetype=health+    call setline(1, split(report, ""\n""))+    setlocal nomodified+  else+    echo report+    echo ""\nTip: Use ""+    echohl Identifier+    echon ':CheckHealth!'+    echohl None+    echon ' to open this in a new buffer.'   endif--  return content endfunction --"" Get the latest Neovim Python client version from PyPI.  The result is-"" cached.-function! s:latest_pypi_version()-  if exists('s:pypi_version')-    return s:pypi_version-  endif--  let s:pypi_version = 'unknown'-  let pypi_info = s:download('https://pypi.python.org/pypi/neovim/json')-  if !empty(pypi_info)-    let pypi_data = json_decode(pypi_info)-    let s:pypi_version = get(get(pypi_data, 'info', {}), 'version', 'unknown')-    return s:pypi_version-  endif+"" Report functions {{{++"" Pass arguments through+"" fun! Foo(arg, ...)+""     if a:0+""         exe 'call Bar(a:arg1, a:arg2, ' . join(map(range(a:0), '""a:000["" . v:val . ""]""'), ', ') . ')'+""     else+""         call Bar(a:arg, ""foo"")+""     endif+"" endfunction++""""+"" This function starts a report.+"" It should represent a general area of tests that can be understood+"" from the argument {name}+"" To start a new report, use this function again+function! health#report_start(name) abort+  echo '  - Checking: ' . a:name endfunction --"" Get version information using the specified interpreter.  The interpreter is-"" used directly in case breaking changes were introduced since the last time-"" Neovim's Python client was updated.-function! s:version_info(python) abort-  let pypi_version = s:latest_pypi_version()-  let python_version = s:trim(system(-        \ printf('""%s"" -c ""import sys; print(''.''.join(str(x) '-        \ . 'for x in sys.version_info[:3]))""', a:python)))-  if empty(python_version)-    let python_version = 'unknown'-  endif-  -  let nvim_path = s:trim(system(printf('""%s"" -c ""import sys, neovim;'-        \ . 'print(neovim.__file__)"" 2>/dev/null', a:python)))-  if empty(nvim_path)-    return [python_version, 'not found', pypi_version, 'unknown']-  endif--  let nvim_version = 'unknown'-  let base = fnamemodify(nvim_path, ':h')-  for meta in glob(base.'-*/METADATA', 1, 1) + glob(base.'-*/PKG-INFO', 1, 1)-    for meta_line in readfile(meta)-      if meta_line =~# '^Version:'-        let nvim_version = matchstr(meta_line, '^Version: \zs\S\+')-      endif-    endfor-  endfor--  let version_status = 'unknown'-  if nvim_version != 'unknown' && pypi_version != 'unknown'-    if s:version_cmp(nvim_version, pypi_version) == -1-      let version_status = 'outdated'-    else-      let version_status = 'up to date'+""""+"" Format a message for a specific report item+function! s:format_report_message(status, msg, ...) abort+  let l:output = '    - ' . a:status . ': ' . a:msg++  "" Check optional parameters+  if a:0 > 0+    "" Suggestions go in the first optional parameter and must be a list.+    if type(a:1) == type([])+      "" Report each suggestion+      for l:suggestion in a:1+        let l:output .= ""\n      - SUGGESTION: "" . l:suggestion+      endfor","If we're already forcing the caller to send the suggestions as a list, we can avoid prepending `SUGGESTION` to each line. Instead, it could be formatted like this:```SUGGESTIONS:  * {suggestion 1...}  * {suggestion 2...}  * {suggestion 3...}```",X
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/4932,69036373,2016-06-29T21:59:26Z,runtime/autoload/health.vim,"@@ -1,433 +1,181 @@-function! s:trim(s) abort-  return substitute(a:s, '^\_s*\|\_s*$', '', 'g')-endfunction+"" Dictionary where we keep all of the healtch check functions we've found.+"" They will only be run if they are true+let g:health_checkers = get(g:, 'health_checkers', {})+let s:current_checker = get(s:, 'current_checker', '')++""""+"" Function to run the health checkers+"" It manages the output and any file local settings+function! health#check(bang) abort+  let l:report = '# Checking health' +  if g:health_checkers == {}+    call s:add_checker(health#_default_checkers())+  endif -"" Simple version comparison.-function! s:version_cmp(a, b) abort-  let a = split(a:a, '\.')-  let b = split(a:b, '\.')+  for l:checker in items(g:health_checkers)+    "" Disabled checkers will not run their registered check functions+    if l:checker[1]+      let s:current_checker = l:checker[0]+      let l:report .= ""\n\n--------------------------------------------------------------------------------\n""+      let l:report .= printf(""\nChecker %s says:\n"", s:current_checker) -  for i in range(len(a))-    if a[i] > b[i]-      return 1-    elseif a[i] < b[i]-      return -1+      let l:report .= capture('silent! call ' . l:checker[0] . '()')     endif   endfor -  return 0-endfunction---"" Fetch the contents of a URL.-function! s:download(url) abort-  let content = ''-  if executable('curl')-    let content = system('curl -sL ""'.a:url.'""')-  endif+  let l:report .= ""\n--------------------------------------------------------------------------------\n"" -  if empty(content) && executable('python')-    let script = ""-          \try:\n-          \    from urllib.request import urlopen\n-          \except ImportError:\n-          \    from urllib2 import urlopen\n-          \\n-          \try:\n-          \    response = urlopen('"".a:url.""')\n-          \    print(response.read().decode('utf8'))\n-          \except Exception:\n-          \    pass\n-          \""-    let content = system('python -c ""'.script.'"" 2>/dev/null')+  if a:bang+    new+    setlocal bufhidden=wipe+    set syntax=health+    set filetype=health+    call setline(1, split(report, ""\n""))+    setlocal nomodified+  else+    echo report+    echo ""\nTip: Use ""+    echohl Identifier+    echon ':CheckHealth!'+    echohl None+    echon ' to open this in a new buffer.'   endif--  return content endfunction --"" Get the latest Neovim Python client version from PyPI.  The result is-"" cached.-function! s:latest_pypi_version()-  if exists('s:pypi_version')-    return s:pypi_version-  endif--  let s:pypi_version = 'unknown'-  let pypi_info = s:download('https://pypi.python.org/pypi/neovim/json')-  if !empty(pypi_info)-    let pypi_data = json_decode(pypi_info)-    let s:pypi_version = get(get(pypi_data, 'info', {}), 'version', 'unknown')-    return s:pypi_version-  endif+"" Report functions {{{++"" Pass arguments through+"" fun! Foo(arg, ...)+""     if a:0+""         exe 'call Bar(a:arg1, a:arg2, ' . join(map(range(a:0), '""a:000["" . v:val . ""]""'), ', ') . ')'+""     else+""         call Bar(a:arg, ""foo"")+""     endif+"" endfunction++""""+"" This function starts a report.+"" It should represent a general area of tests that can be understood+"" from the argument {name}+"" To start a new report, use this function again+function! health#report_start(name) abort+  echo '  - Checking: ' . a:name endfunction --"" Get version information using the specified interpreter.  The interpreter is-"" used directly in case breaking changes were introduced since the last time-"" Neovim's Python client was updated.-function! s:version_info(python) abort-  let pypi_version = s:latest_pypi_version()-  let python_version = s:trim(system(-        \ printf('""%s"" -c ""import sys; print(''.''.join(str(x) '-        \ . 'for x in sys.version_info[:3]))""', a:python)))-  if empty(python_version)-    let python_version = 'unknown'-  endif-  -  let nvim_path = s:trim(system(printf('""%s"" -c ""import sys, neovim;'-        \ . 'print(neovim.__file__)"" 2>/dev/null', a:python)))-  if empty(nvim_path)-    return [python_version, 'not found', pypi_version, 'unknown']-  endif--  let nvim_version = 'unknown'-  let base = fnamemodify(nvim_path, ':h')-  for meta in glob(base.'-*/METADATA', 1, 1) + glob(base.'-*/PKG-INFO', 1, 1)-    for meta_line in readfile(meta)-      if meta_line =~# '^Version:'-        let nvim_version = matchstr(meta_line, '^Version: \zs\S\+')-      endif-    endfor-  endfor--  let version_status = 'unknown'-  if nvim_version != 'unknown' && pypi_version != 'unknown'-    if s:version_cmp(nvim_version, pypi_version) == -1-      let version_status = 'outdated'-    else-      let version_status = 'up to date'+""""+"" Format a message for a specific report item+function! s:format_report_message(status, msg, ...) abort+  let l:output = '    - ' . a:status . ': ' . a:msg++  "" Check optional parameters+  if a:0 > 0+    "" Suggestions go in the first optional parameter and must be a list.+    if type(a:1) == type([])","If we require it to be a list, rather than silently ignoring non-list input, throw an error or else convert it to a string (`string(a:1)`).",X
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/4932,69037113,2016-06-29T22:04:51Z,runtime/autoload/health.vim,"@@ -1,433 +1,181 @@-function! s:trim(s) abort-  return substitute(a:s, '^\_s*\|\_s*$', '', 'g')-endfunction+"" Dictionary where we keep all of the healtch check functions we've found.+"" They will only be run if they are true+let g:health_checkers = get(g:, 'health_checkers', {})+let s:current_checker = get(s:, 'current_checker', '')++""""+"" Function to run the health checkers+"" It manages the output and any file local settings+function! health#check(bang) abort+  let l:report = '# Checking health' +  if g:health_checkers == {}+    call s:add_checker(health#_default_checkers())+  endif -"" Simple version comparison.-function! s:version_cmp(a, b) abort-  let a = split(a:a, '\.')-  let b = split(a:b, '\.')+  for l:checker in items(g:health_checkers)+    "" Disabled checkers will not run their registered check functions+    if l:checker[1]+      let s:current_checker = l:checker[0]+      let l:report .= ""\n\n--------------------------------------------------------------------------------\n""+      let l:report .= printf(""\nChecker %s says:\n"", s:current_checker) -  for i in range(len(a))-    if a[i] > b[i]-      return 1-    elseif a[i] < b[i]-      return -1+      let l:report .= capture('silent! call ' . l:checker[0] . '()')     endif   endfor -  return 0-endfunction---"" Fetch the contents of a URL.-function! s:download(url) abort-  let content = ''-  if executable('curl')-    let content = system('curl -sL ""'.a:url.'""')-  endif+  let l:report .= ""\n--------------------------------------------------------------------------------\n"" -  if empty(content) && executable('python')-    let script = ""-          \try:\n-          \    from urllib.request import urlopen\n-          \except ImportError:\n-          \    from urllib2 import urlopen\n-          \\n-          \try:\n-          \    response = urlopen('"".a:url.""')\n-          \    print(response.read().decode('utf8'))\n-          \except Exception:\n-          \    pass\n-          \""-    let content = system('python -c ""'.script.'"" 2>/dev/null')+  if a:bang+    new+    setlocal bufhidden=wipe+    set syntax=health+    set filetype=health+    call setline(1, split(report, ""\n""))+    setlocal nomodified+  else+    echo report+    echo ""\nTip: Use ""+    echohl Identifier+    echon ':CheckHealth!'+    echohl None+    echon ' to open this in a new buffer.'   endif--  return content endfunction --"" Get the latest Neovim Python client version from PyPI.  The result is-"" cached.-function! s:latest_pypi_version()-  if exists('s:pypi_version')-    return s:pypi_version-  endif--  let s:pypi_version = 'unknown'-  let pypi_info = s:download('https://pypi.python.org/pypi/neovim/json')-  if !empty(pypi_info)-    let pypi_data = json_decode(pypi_info)-    let s:pypi_version = get(get(pypi_data, 'info', {}), 'version', 'unknown')-    return s:pypi_version-  endif+"" Report functions {{{++"" Pass arguments through+"" fun! Foo(arg, ...)+""     if a:0+""         exe 'call Bar(a:arg1, a:arg2, ' . join(map(range(a:0), '""a:000["" . v:val . ""]""'), ', ') . ')'+""     else+""         call Bar(a:arg, ""foo"")+""     endif+"" endfunction++""""+"" This function starts a report.+"" It should represent a general area of tests that can be understood+"" from the argument {name}+"" To start a new report, use this function again+function! health#report_start(name) abort+  echo '  - Checking: ' . a:name endfunction --"" Get version information using the specified interpreter.  The interpreter is-"" used directly in case breaking changes were introduced since the last time-"" Neovim's Python client was updated.-function! s:version_info(python) abort-  let pypi_version = s:latest_pypi_version()-  let python_version = s:trim(system(-        \ printf('""%s"" -c ""import sys; print(''.''.join(str(x) '-        \ . 'for x in sys.version_info[:3]))""', a:python)))-  if empty(python_version)-    let python_version = 'unknown'-  endif-  -  let nvim_path = s:trim(system(printf('""%s"" -c ""import sys, neovim;'-        \ . 'print(neovim.__file__)"" 2>/dev/null', a:python)))-  if empty(nvim_path)-    return [python_version, 'not found', pypi_version, 'unknown']-  endif--  let nvim_version = 'unknown'-  let base = fnamemodify(nvim_path, ':h')-  for meta in glob(base.'-*/METADATA', 1, 1) + glob(base.'-*/PKG-INFO', 1, 1)-    for meta_line in readfile(meta)-      if meta_line =~# '^Version:'-        let nvim_version = matchstr(meta_line, '^Version: \zs\S\+')-      endif-    endfor-  endfor--  let version_status = 'unknown'-  if nvim_version != 'unknown' && pypi_version != 'unknown'-    if s:version_cmp(nvim_version, pypi_version) == -1-      let version_status = 'outdated'-    else-      let version_status = 'up to date'+""""+"" Format a message for a specific report item+function! s:format_report_message(status, msg, ...) abort+  let l:output = '    - ' . a:status . ': ' . a:msg++  "" Check optional parameters+  if a:0 > 0+    "" Suggestions go in the first optional parameter and must be a list.+    if type(a:1) == type([])+      "" Report each suggestion+      for l:suggestion in a:1+        let l:output .= ""\n      - SUGGESTION: "" . l:suggestion+      endfor     endif   endif -  return [python_version, nvim_version, pypi_version, version_status]+  return output endfunction --"" Check the Python interpreter's usability.-function! s:check_bin(bin, notes) abort-  if !filereadable(a:bin)-    call add(a:notes, printf('Error: ""%s"" was not found.', a:bin))-    return 0-  elseif executable(a:bin) != 1-    call add(a:notes, printf('Error: ""%s"" is not executable.', a:bin))-    return 0-  endif-  return 1+""""+"" This function reports general information about the state of the environment+"" Use {msg} to represent the information you wish to record about the+"" environment+function! health#report_info(msg) abort+  echo s:format_report_message('INFO', a:msg) endfunction --"" Text wrapping that returns a list of lines-function! s:textwrap(text, width) abort-  let pattern = '.*\%(\s\+\|\_$\)\zs\%<'.a:width.'c'-  return map(split(a:text, pattern), 's:trim(v:val)')+""""+"" This function reports a succesful check within a report+"" Use {msg} to represent the check that has passed+function! health#report_ok(msg) abort+  echo s:format_report_message('SUCCESS', a:msg) endfunction --"" Echo wrapped notes-function! s:echo_notes(notes) abort-  if empty(a:notes)-    return+""""+"" This function represents a check that has not gone correctly within a report+"" However, even with the unsuccesful check, it makes sense to continue+"" checking other health items. Use {msg} to represent the failed health check+"" and optionally a list of suggestions on how to fix it.+function! health#report_warn(msg, ...) abort+  if a:0 > 0 && type(a:1) == type([])+    echo s:format_report_message('WARNING', a:msg, a:1)+  else+    echo s:format_report_message('WARNING', a:msg)   endif--  echo '  Messages:'-  for msg in a:notes-    if msg =~# ""\n""-      let msg_lines = []-      for msgl in filter(split(msg, ""\n""), 'v:val !~# ''^\s*$''')-        call extend(msg_lines, s:textwrap(msgl, 74))-      endfor-    else-      let msg_lines = s:textwrap(msg, 74)-    endif--    if !len(msg_lines)-      continue-    endif-    echo '    *' msg_lines[0]-    if len(msg_lines) > 1-      echo join(map(msg_lines[1:], '""      "".v:val'), ""\n"")-    endif-  endfor endfunction --"" Load the remote plugin manifest file and check for unregistered plugins-function! s:diagnose_manifest() abort-  echo 'Checking: Remote Plugins'-  let existing_rplugins = {}--  for item in remote#host#PluginsForHost('python')-    let existing_rplugins[item.path] = 'python'-  endfor--  for item in remote#host#PluginsForHost('python3')-    let existing_rplugins[item.path] = 'python3'-  endfor--  let require_update = 0-  let notes = []--  for path in map(split(&rtp, ','), 'resolve(v:val)')-    let python_glob = glob(path.'/rplugin/python*', 1, 1)-    if empty(python_glob)-      continue-    endif--    let python_dir = python_glob[0]-    let python_version = fnamemodify(python_dir, ':t')--    for script in glob(python_dir.'/*.py', 1, 1)-          \ + glob(python_dir.'/*/__init__.py', 1, 1)-      let contents = join(readfile(script))-      if contents =~# '\<\%(from\|import\)\s\+neovim\>'-        if script =~# '/__init__\.py$'-          let script = fnamemodify(script, ':h')-        endif--        if !has_key(existing_rplugins, script)-          let msg = printf('""%s"" is not registered.', fnamemodify(path, ':t'))-          if python_version == 'pythonx'-            if !has('python2') && !has('python3')-              let msg .= ' (python2 and python3 not available)'-            endif-          elseif !has(python_version)-            let msg .= printf(' (%s not available)', python_version)-          else-            let require_update = 1-          endif--          call add(notes, msg)-        endif--        break-      endif-    endfor-  endfor--  echo '  Status: '-  if require_update-    echon 'Out of date'-    call add(notes, 'Run :UpdateRemotePlugins')+""""+"" This function represents a check that has failed and because of it does not+"" make sense to continue testing the health of the health checker.+"" You can optionally give a list of suggestions as a second argument on how to+"" fix it where applicable.+function! health#report_error(msg, ...) abort+  if a:0 > 0 && type(a:1) == type([])+    echo s:format_report_message('ERROR', a:msg, a:1)   else-    echon 'Up to date'+    echo s:format_report_message('ERROR', a:msg)   endif--  call s:echo_notes(notes) endfunction +"" }}}+"" Health checker management {{{ -function! s:diagnose_python(version) abort-  let python_bin_name = 'python'.(a:version == 2 ? '' : '3')-  let pyenv = resolve(exepath('pyenv'))-  let pyenv_root = exists('$PYENV_ROOT') ? resolve($PYENV_ROOT) : ''-  let venv = exists('$VIRTUAL_ENV') ? resolve($VIRTUAL_ENV) : ''-  let host_prog_var = python_bin_name.'_host_prog'-  let host_skip_var = python_bin_name.'_host_skip_check'-  let python_bin = ''-  let python_multiple = []-  let notes = []--  if exists('g:'.host_prog_var)-    call add(notes, printf('Using: g:%s = ""%s""', host_prog_var, get(g:, host_prog_var)))-  endif--  let [python_bin_name, pythonx_errs] = provider#pythonx#Detect(a:version)-  if empty(python_bin_name)-    call add(notes, 'Warning: No Python interpreter was found with the neovim '-          \ . 'module.  Using the first available for diagnostics.')-    if !empty(pythonx_errs)-      call add(notes, pythonx_errs)-    endif-    let old_skip = get(g:, host_skip_var, 0)-    let g:[host_skip_var] = 1-    let [python_bin_name, pythonx_errs] = provider#pythonx#Detect(a:version)-    let g:[host_skip_var] = old_skip-  endif--  if !empty(python_bin_name)-    if exists('g:'.host_prog_var)-      let python_bin = exepath(python_bin_name)-    endif-    let python_bin_name = fnamemodify(python_bin_name, ':t')-  endif--  if !empty(pythonx_errs)-    call add(notes, pythonx_errs)-  endif--  if !empty(python_bin_name) && empty(python_bin) && empty(pythonx_errs)-    if !exists('g:'.host_prog_var)-      call add(notes, printf('Warning: ""g:%s"" is not set.  Searching for '-            \ . '%s in the environment.', host_prog_var, python_bin_name))-    endif--    if !empty(pyenv)-      if empty(pyenv_root)-        call add(notes, 'Warning: pyenv was found, but $PYENV_ROOT '-              \ . 'is not set.  Did you follow the final install '-              \ . 'instructions?')-      else-        call add(notes, printf('Notice: pyenv found: ""%s""', pyenv))-      endif--      let python_bin = s:trim(system(-            \ printf('""%s"" which %s 2>/dev/null', pyenv, python_bin_name)))--      if empty(python_bin)-        call add(notes, printf('Warning: pyenv couldn''t find %s.', python_bin_name))-      endif-    endif--    if empty(python_bin)-      let python_bin = exepath(python_bin_name)--      if exists('$PATH')-        for path in split($PATH, ':')-          let path_bin = path.'/'.python_bin_name-          if path_bin != python_bin && index(python_multiple, path_bin) == -1-                \ && executable(path_bin)-            call add(python_multiple, path_bin)-          endif-        endfor--        if len(python_multiple)-          "" This is worth noting since the user may install something-          "" that changes $PATH, like homebrew.-          call add(notes, printf('Suggestion: There are multiple %s executables found.  '-                \ . 'Set ""g:%s"" to avoid surprises.', python_bin_name, host_prog_var))-        endif--        if python_bin =~# '\<shims\>'-          call add(notes, printf('Warning: ""%s"" appears to be a pyenv shim.  '-                \ . 'This could mean that a) the ""pyenv"" executable is not in '-                \ . '$PATH, b) your pyenv installation is broken.  '-                \ . 'You should set ""g:%s"" to avoid surprises.',-                \ python_bin, host_prog_var))-        endif-      endif-    endif-  endif--  if !empty(python_bin)-    if !empty(pyenv) && !exists('g:'.host_prog_var) && !empty(pyenv_root)-          \ && resolve(python_bin) !~# '^'.pyenv_root.'/'-      call add(notes, printf('Suggestion: Create a virtualenv specifically '-            \ . 'for Neovim using pyenv and use ""g:%s"".  This will avoid '-            \ . 'the need to install Neovim''s Python client in each '-            \ . 'version/virtualenv.', host_prog_var))-    endif--    if !empty(venv) && exists('g:'.host_prog_var)-      if !empty(pyenv_root)-        let venv_root = pyenv_root-      else-        let venv_root = fnamemodify(venv, ':h')-      endif--      if resolve(python_bin) !~# '^'.venv_root.'/'-        call add(notes, printf('Suggestion: Create a virtualenv specifically '-              \ . 'for Neovim and use ""g:%s"".  This will avoid '-              \ . 'the need to install Neovim''s Python client in each '-              \ . 'virtualenv.', host_prog_var))-      endif-    endif-  endif--  if empty(python_bin) && !empty(python_bin_name)-    "" An error message should have already printed.-    call add(notes, printf('Error: ""%s"" was not found.', python_bin_name))-  elseif !empty(python_bin) && !s:check_bin(python_bin, notes)-    let python_bin = ''-  endif--  "" Check if $VIRTUAL_ENV is active-  let virtualenv_inactive = 0--  if exists('$VIRTUAL_ENV')-    if !empty(pyenv)-      let pyenv_prefix = resolve(s:trim(system(printf('""%s"" prefix', pyenv))))-      if $VIRTUAL_ENV != pyenv_prefix-        let virtualenv_inactive = 1-      endif-    elseif !empty(python_bin_name) && exepath(python_bin_name) !~# '^'.$VIRTUAL_ENV.'/'-      let virtualenv_inactive = 1-    endif-  endif--  if virtualenv_inactive-    call add(notes, 'Warning: $VIRTUAL_ENV exists but appears to be '-          \ . 'inactive.  This could lead to unexpected results.  If you are '-          \ . 'using Zsh, see: http://vi.stackexchange.com/a/7654/5229')+""""+"" s:add_single_checker is a function to handle adding a checker of name+"" {checker_name} to the list of health_checkers. It also enables it.+function! s:add_single_checker(checker_name) abort+  if has_key(g:health_checkers, a:checker_name)+    "" TODO: What to do if it's already there?+    return+  else+      let g:health_checkers[a:checker_name] = v:true   endif+endfunction -  "" Diagnostic output-  echo 'Checking: Python' a:version-  echo '  Executable:' (empty(python_bin) ? 'Not found' : python_bin)-  if len(python_multiple)-    for path_bin in python_multiple-      echo '     (other):' path_bin+""""+"" s:add_checker is a function to register at least one healthcheckers.+"" {checker_name} can be specified by either a list of strings or a single string.+"" The string should be the name of the function to check, which should follow+"" the naming convention of `health#plugin_name#check`+function! s:add_checker(checker_name) abort "" {{{+  if type(a:checker_name) == type('')+    call s:add_single_checker(a:checker_name)+  elseif type(a:checker_name) == type([])+    for checker in a:checker_name+      call s:add_single_checker(checker)     endfor   endif+endfunction "" }}} -  if !empty(python_bin)-    let [pyversion, current, latest, status] = s:version_info(python_bin)-    if a:version != str2nr(pyversion)-      call add(notes, 'Warning: Got an unexpected version of Python.  '-            \ . 'This could lead to confusing error messages.  Please '-            \ . 'consider this before reporting bugs to plugin developers.')-    endif-    if a:version == 3 && str2float(pyversion) < 3.3-      call add(notes, 'Warning: Python 3.3+ is recommended.')-    endif--    echo '  Python Version:' pyversion-    echo printf('  %s-neovim Version: %s', python_bin_name, current)--    if current == 'not found'-      call add(notes, 'Error: Neovim Python client is not installed.')-    endif--    if latest == 'unknown'-      call add(notes, 'Warning: Unable to fetch latest Neovim Python client version.')-    endif--    if status == 'outdated'-      echon ' (latest: '.latest.')'-    else-      echon ' ('.status.')'-    endif+function! health#disable_checker(checker_name) abort "" {{{+  if has_key(g:health_checkers, a:checker_name)+    let g:health_checkers[a:checker_name] = v:false+  else+    "" TODO: What to do if it's not already there?+    return   endif+endfunction "" }}} -  call s:echo_notes(notes)-endfunction+function! s:change_file_name_to_health_checker(name) abort "" {{{+  return substitute(substitute(substitute(a:name, "".*autoload/"", """", """"), ""\\.vim"", ""#check"", """"), ""/"", ""#"", ""g"")+endfunction "" }}} +function! health#_default_checkers() abort "" {{{+  "" Get all of the files that are in autoload/health/ folders with a vim+  "" suffix+  let checker_files = globpath(&runtimepath, 'autoload/health/*.vim', 0, 1)","We definitely want the `{nosuf}` parameter to be `1`, not `0`--otherwise `'wildignore'` et. al. applies to the search, which makes it dependent on the user's configuration.",X
112971,jamessan,https://api.github.com/repos/neovim/neovim/pulls/4991,69335256,2016-07-01T17:58:20Z,test/functional/viml/lang_spec.lua,"@@ -0,0 +1,22 @@+local helpers = require('test.functional.helpers')(after_each)+local clear, eval, eq = helpers.clear, helpers.eval, helpers.eq+local execute, source = helpers.execute, helpers.source++describe('turkish', function()+  before_each(clear)++  it('applies locale to \'i\' in `<SID>` comparison', function()+    execute('lang ctype tr_TR.UTF-8')+    if string.find(eval('v:errmsg'), '^E197: ') then+      pending(""Locale tr_TR.UTF-8 not supported"")",Should have a `return` after the pending line so we don't execute the rest of the test ([example](https://github.com/neovim/neovim/blob/d21690a66e7eb5ebef18046c7a79ef898966d786/test/functional/ex_cmds/grep_spec.lua#L11-L12)).,X
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/4980,69384008,2016-07-03T00:14:22Z,runtime/autoload/provider/ruby.vim,"@@ -1,12 +1,18 @@ "" The Ruby provider helper-if exists('s:loaded_ruby_provider')+if exists('g:loaded_ruby_provider')   finish endif+let g:loaded_ruby_provider = 1 -let s:loaded_ruby_provider = 1+function! provider#ruby#Detect() abort+  return exepath('neovim-ruby-host')","The python provider does not install on PATH, instead it invokes python and uses python import to work with the python module: https://github.com/alexgenco/neovim/blob/808090b0b58228d49c113682491339183a24c378/runtime/autoload/provider/pythonx.vim#L88-L94What's the reason for installing `neovim-ruby-host` on PATH? Would it be inconvenient to using an approach similar to the python provider?",X
149870,stephenprater,https://api.github.com/repos/neovim/neovim/pulls/4980,69384040,2016-07-03T00:20:49Z,runtime/autoload/provider/ruby.vim,"@@ -16,19 +22,46 @@ function! provider#ruby#Require(host) abort    try     let channel_id = rpcstart(provider#ruby#Prog(), args)--    if rpcrequest(channel_id, 'poll') == 'ok'+    if rpcrequest(channel_id, 'poll') ==# 'ok'       return channel_id     endif   catch     echomsg v:throwpoint     echomsg v:exception   endtry--  throw remote#host#LoadErrorForHost(a:host.orig_name,-        \ '$NVIM_RUBY_LOG_FILE')+  throw remote#host#LoadErrorForHost(a:host.orig_name, '$NVIM_RUBY_LOG_FILE') endfunction -function! provider#ruby#Prog() abort-  return 'neovim-ruby-host'+function! provider#ruby#Call(method, args)+  if s:err != ''+    echoerr s:err+    return+  endif++  if !exists('s:host')+    let s:rpcrequest = function('rpcrequest')","well it's called as a ""closure"" down on 54 - but I'm not sure why it does that.  I think I may have written this long ago - `s:host` needs to be captured, but I don't know why we need a different handle on the rpcrequest function.",X
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/4980,69385862,2016-07-03T05:32:33Z,runtime/doc/provider.txt,"@@ -88,6 +88,30 @@ the |:CheckHealth| command to diagnose your setup. 		  save to a file or copy to the clipboard.  ==============================================================================+Ruby integration		    	      *provider-ruby*++Nvim supports the Vim legacy |ruby-vim| interface via external Ruby+interpreters connected via |RPC|.+++RUBY QUICKSTART ~++To use Vim Ruby plugins with Nvim, just install the latest `neovim` RubyGem: >+    $ gem install neovim+++RUBY PROVIDER CONFIGURATION ~+						*g:loaded_ruby_provider*+To disable Ruby support: >+    let g:loaded_ruby_provider = 1+++TROUBLESHOOTING					*ruby-trouble*++If you have trouble with a plugin that uses the `neovim` Ruby client, use the+|:CheckHealth| command to diagnose your setup.",To be honest I think we should remove `python-trouble` and move `:CheckHealth` somewhere else (don't need to do that in this PR though). In general we just want users to start reaching for `:CheckHealth` by habit. So there's no need to mention troubleshooting for any specific component.,X
4117685,KillTheMule,https://api.github.com/repos/neovim/neovim/pulls/5005,69451748,2016-07-04T12:38:28Z,src/nvim/option.c,"@@ -2440,11 +2440,9 @@ did_set_string_option (     if (briopt_check(curwin) == FAIL)       errmsg = e_invarg;   }","Well, technically it's in the wrong block, but it's directly above the item it relates to... the other choice is```} else if (...) {// 'isident', 'iskeyword', 'isprint or 'isfname' option: refill g_chartab[]// If the new option is invalid, use old value.  'lisp' option: refill// g_chartab[] for '-' char```which is ok too, I guess. I looked into `shada.c` and `tui.c` and have found this style, but in those cases the comments seemed more related to the content of the block, not the condition of the block.So yeah, that's probably the thing to do here :)",
4117685,KillTheMule,https://api.github.com/repos/neovim/neovim/pulls/5005,69455219,2016-07-04T13:06:18Z,src/nvim/option.c,"@@ -2440,11 +2440,9 @@ did_set_string_option (     if (briopt_check(curwin) == FAIL)       errmsg = e_invarg;   }","It's not auto-formatting if it's done manually :P Still though, there's an `if` directly after it, and you don't want to break up the conditions by the comment, so I'd still prefer the first suggestion, even if the comment is technically in the wrong block.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/4973,69670471,2016-07-06T03:16:38Z,src/nvim/fileio.c,"@@ -4514,9 +4515,14 @@ int vim_rename(char_u *from, char_u *to)     if (STRLEN(from) >= MAXPATHL - 5)       return -1;     STRCPY(tempname, from);-    for (n = 123; n < 99999; ++n) {-      sprintf((char *)path_tail(tempname), ""%d"", n);-      if (!os_file_exists(tempname)) {+    for (n = 123; n < 99999; n++) {+      // the 'n' in snprintf is calculated by subtracting the difference+      // between the tail pointer and the start of the array from the+      // total buffer length+      char * tail = (char *)path_tail(tempname);+      snprintf(tail, (MAXPATHL + 1) - (tail - (char *)tempname - 1), ""%d"", n);","the comment is too long, and the mention of ""n"" is confusing given the presence of the `n` parameter which is unrelated to the 'n' mentioned in the comment. Better to leave the comment out, it mostly restates what the code is doing.",X
12422195,ryangalamb,https://api.github.com/repos/neovim/neovim/pulls/5014,70170259,2016-07-09T18:07:39Z,src/nvim/terminal.c,"@@ -793,6 +794,57 @@ static VTermKey convert_key(int key, VTermModifier *statep)     case K_KMULTIPLY: return VTERM_KEY_KP_MULT;     case K_KDIVIDE:   return VTERM_KEY_KP_DIVIDE; +    case K_S_F1:      *statep |= VTERM_MOD_SHIFT;","I thought about that, but if we took that approach, we'd still need to check all the `K_S_*` keys individually in the big switch since the `K_S_*` keys count as different keys from the `K_*` ones.If I understand your suggestion correctly, such a function would only let us go from```case K_S_F1:      *statep |= VTERM_MOD_SHIFT;case K_F1:        return VTERM_KEY_FUNCTION(1);```to```case K_S_F1:case K_F1:        return VTERM_KEY_FUNCTION(1);```",X
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/5031,70189860,2016-07-10T22:54:18Z,src/nvim/editor/arbmark.c,"@@ -0,0 +1,156 @@+/*+ * Same function but names are not limited to one char+ * There is also no ex_command, just viml functions+ */++#include ""nvim/vim.h""+#include ""nvim/globals.h""+#include ""nvim/mark.h""+#include ""nvim/memory.h""+#include ""nvim/map.h""+#include ""nvim/lib/kvec.h""+#include ""nvim/editor/arbmark.h""++# define FOR_ALL_ARBMARKS(buf) \+  kbitr_t = itr;                                              \+  arbmark_T = *arbmark;                                       \+  for (;kb_itr_valid(&itr)                                    \+       ;kb_itr_next(arbmark_T, buf->b_arbmarks_tree; &itr)){++static arbmark_T *_find_pos(pos_t pos, bool FORWARD);+static int _arbmark_create(buf_T *buf, cstr_t *name,  pos_T *pos);+static int _arbmark_update(buf_T *buf, arbmark_T *arbmark, pos_T *pos);+static int _arbmark_delete(buf_T *buf, cstr_t *name);+static arbmark_T *get_arbmark(buf_T *buf, cstr_t *name);+static int pos_lt(pos_T *pos, pos_T *pos2);+static int pos_eq(pos_T *pos, pos_T *pos2);",Everything here should be generated. Just if you add a new directory you need to add it to the directory list in src/nvim/CMakeLists.txt.,X
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/5031,70189881,2016-07-10T22:55:35Z,src/nvim/editor/arbmark.c,"@@ -0,0 +1,156 @@+/*+ * Same function but names are not limited to one char+ * There is also no ex_command, just viml functions+ */++#include ""nvim/vim.h""+#include ""nvim/globals.h""+#include ""nvim/mark.h""+#include ""nvim/memory.h""+#include ""nvim/map.h""+#include ""nvim/lib/kvec.h""+#include ""nvim/editor/arbmark.h""","I would suggest not introducing `editor/` namespace--it is redundant. We have `api/` to separate non-""editor"" functionality, all top-level modules are implicitly part of the core editor.Also consider renaming the file `mark_extended.{h,c}` so that it sorts next to `mark.{h,c}`.",X
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/5031,70189885,2016-07-10T22:55:58Z,src/nvim/editor/arbmark.c,"@@ -0,0 +1,156 @@+/*+ * Same function but names are not limited to one char+ * There is also no ex_command, just viml functions+ */++#include ""nvim/vim.h""+#include ""nvim/globals.h""+#include ""nvim/mark.h""+#include ""nvim/memory.h""+#include ""nvim/map.h""+#include ""nvim/lib/kvec.h""+#include ""nvim/editor/arbmark.h""++# define FOR_ALL_ARBMARKS(buf) \+  kbitr_t = itr;                                              \+  arbmark_T = *arbmark;                                       \+  for (;kb_itr_valid(&itr)                                    \+       ;kb_itr_next(arbmark_T, buf->b_arbmarks_tree; &itr)){++static arbmark_T *_find_pos(pos_t pos, bool FORWARD);+static int _arbmark_create(buf_T *buf, cstr_t *name,  pos_T *pos);+static int _arbmark_update(buf_T *buf, arbmark_T *arbmark, pos_T *pos);+static int _arbmark_delete(buf_T *buf, cstr_t *name);","Starting `static` functions with underscore is a useless action, making them static is enough.",X
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/5031,70190063,2016-07-10T23:06:34Z,src/nvim/editor/arbmark.c,"@@ -0,0 +1,156 @@+/*+ * Same function but names are not limited to one char+ * There is also no ex_command, just viml functions+ */++#include ""nvim/vim.h""+#include ""nvim/globals.h""+#include ""nvim/mark.h""+#include ""nvim/memory.h""+#include ""nvim/map.h""+#include ""nvim/lib/kvec.h""+#include ""nvim/editor/arbmark.h""++# define FOR_ALL_ARBMARKS(buf) \+  kbitr_t = itr;                                              \+  arbmark_T = *arbmark;                                       \+  for (;kb_itr_valid(&itr)                                    \+       ;kb_itr_next(arbmark_T, buf->b_arbmarks_tree; &itr)){++static arbmark_T *_find_pos(pos_t pos, bool FORWARD);+static int _arbmark_create(buf_T *buf, cstr_t *name,  pos_T *pos);+static int _arbmark_update(buf_T *buf, arbmark_T *arbmark, pos_T *pos);+static int _arbmark_delete(buf_T *buf, cstr_t *name);+static arbmark_T *get_arbmark(buf_T *buf, cstr_t *name);+static int pos_lt(pos_T *pos, pos_T *pos2);+static int pos_eq(pos_T *pos, pos_T *pos2);",@justinmk He is missing `#include` with generated functions. And he is missing it because until `editor/` subdirectory is added to the list nothing is going to be generated.,X
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/5031,70190094,2016-07-10T23:08:43Z,src/nvim/editor/arbmark.c,"@@ -0,0 +1,156 @@+/*+ * Same function but names are not limited to one char+ * There is also no ex_command, just viml functions+ */++#include ""nvim/vim.h""+#include ""nvim/globals.h""+#include ""nvim/mark.h""+#include ""nvim/memory.h""+#include ""nvim/map.h""+#include ""nvim/lib/kvec.h""+#include ""nvim/editor/arbmark.h""","@justinmk I also do not like name `arbmark.c`. But with `mark_extended` what should be the function prefix, `mark_extended` itself is too long? I can suggest `extmark`.",X
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/5031,70190608,2016-07-10T23:37:15Z,test/functional/api/arbmark_spec.lua,"@@ -0,0 +1,18 @@+-- Sanity checks for buffer_* API calls via msgpack-rpc","I have no idea what is supposed to be placed into functional/viml. dict_notifications_spec should be probably in eval. viml/function_spec should be in eval (and I have no idea what `api_info` is doing in this file, I would place it separately because `function_spec` is too generic; this is fine if you are testing generic function-related features like MAX_FUNC_ARGS handling, but this is no place for testing specific functions), as well as viml/errorlist_spec: other functions are tested there. Not sure about viml/lang_spec and viml/completion_spec: first may be in eval, second is such a feature that can have its own directory.",X
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/5031,70191455,2016-07-11T00:22:47Z,test/functional/api/arbmark_spec.lua,"@@ -0,0 +1,18 @@+-- Sanity checks for buffer_* API calls via msgpack-rpc",Moving `viml/*` to `eval/` is fine with me. I think they were created by coincidence long ago.,X
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/5031,70192376,2016-07-11T01:01:51Z,src/nvim/editor/arbmark.c,"@@ -0,0 +1,156 @@+/*+ * Same function but names are not limited to one char+ * There is also no ex_command, just viml functions+ */++#include ""nvim/vim.h""+#include ""nvim/globals.h""+#include ""nvim/mark.h""+#include ""nvim/memory.h""+#include ""nvim/map.h""+#include ""nvim/lib/kvec.h""+#include ""nvim/editor/arbmark.h""++# define FOR_ALL_ARBMARKS(buf) \+  kbitr_t = itr;                                              \+  arbmark_T = *arbmark;                                       \+  for (;kb_itr_valid(&itr)                                    \+       ;kb_itr_next(arbmark_T, buf->b_arbmarks_tree; &itr)){++static arbmark_T *_find_pos(pos_t pos, bool FORWARD);+static int _arbmark_create(buf_T *buf, cstr_t *name,  pos_T *pos);+static int _arbmark_update(buf_T *buf, arbmark_T *arbmark, pos_T *pos);+static int _arbmark_delete(buf_T *buf, cstr_t *name);+static arbmark_T *get_arbmark(buf_T *buf, cstr_t *name);+static int pos_lt(pos_T *pos, pos_T *pos2);+static int pos_eq(pos_T *pos, pos_T *pos2);","@timeyyy Check other files, they have include guarded by INCLUDE_GENERATED_DECLARATIONS, usually right after typedef���s. But as I said, as long as you have this in _new_ editor/ subdirectory src/nvim/CMakeLists.txt needs to be edited for declarations generator to generate anything. This also applies to `*.h` file, and it also should not have function declarations.",X
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/5031,70192515,2016-07-11T01:05:33Z,src/nvim/editor/arbmark.c,"@@ -0,0 +1,156 @@+/*+ * Same function but names are not limited to one char+ * There is also no ex_command, just viml functions+ */++#include ""nvim/vim.h""+#include ""nvim/globals.h""+#include ""nvim/mark.h""+#include ""nvim/memory.h""+#include ""nvim/map.h""+#include ""nvim/lib/kvec.h""+#include ""nvim/editor/arbmark.h""++# define FOR_ALL_ARBMARKS(buf) \+  kbitr_t = itr;                                              \+  arbmark_T = *arbmark;                                       \+  for (;kb_itr_valid(&itr)                                    \+       ;kb_itr_next(arbmark_T, buf->b_arbmarks_tree; &itr)){++static arbmark_T *_find_pos(pos_t pos, bool FORWARD);+static int _arbmark_create(buf_T *buf, cstr_t *name,  pos_T *pos);+static int _arbmark_update(buf_T *buf, arbmark_T *arbmark, pos_T *pos);+static int _arbmark_delete(buf_T *buf, cstr_t *name);+static arbmark_T *get_arbmark(buf_T *buf, cstr_t *name);+static int pos_lt(pos_T *pos, pos_T *pos2);+static int pos_eq(pos_T *pos, pos_T *pos2);++/* Create or update an arbmark, */+int arbmark_set(buf_T *buf, char_u *name, pos_T *pos)","BTW, this ought to be `char *`. `char_u *` is deprecated, for strings you should use `char *`, for sequence of numbers `uint8_t *` (though mostly need to cast individual characters to uint8_t when appropriate). And, I guess, this should be `const char *`.",X
972014,mhinz,https://api.github.com/repos/neovim/neovim/pulls/5036,70231065,2016-07-11T10:01:19Z,src/nvim/ex_cmds.c,"@@ -4822,8 +4822,8 @@ static void helptags_one(char_u *dir, char_u *ext, char_u *tagfname,    // Find all *.txt files.   size_t dirlen = STRLEN(dir);-  STRCPY(NameBuff, dir);-  STRCAT(NameBuff, ""/**/*"");+  STRLCPY(NameBuff, dir, sizeof(NameBuff));+  STRCAT(NameBuff, ""/**/*"");  // NOLINT","I generally agree, but when I tried to do The Right Thing instead of just matching the text `/*`, running `python clint.py src/ex_cmds.c` took longer than 7 minutes (that's when I killed it) opposed to 1 second before the change.Not sure if there's an easy way to speed this up, a better approach, or if we should go for a simpler regexp (which also means more false-positives):``` py_RE_PATTERN_OLD_STYLE_COMMENT_LEADER = re.compile(r'''        (?:          [^'""]+    # Anything but quote leaders          |          ""[^""]*""   # Any string enclosed in double quotes          |          '[^']*'   # Any string enclosed in single quotes        )*        /\*         # Old-style comment leader        ''', re.VERBOSE)```",X
1690608,phanimahesh,https://api.github.com/repos/neovim/neovim/pulls/5036,70247026,2016-07-11T12:21:59Z,src/nvim/ex_cmds.c,"@@ -4822,8 +4822,8 @@ static void helptags_one(char_u *dir, char_u *ext, char_u *tagfname,    // Find all *.txt files.   size_t dirlen = STRLEN(dir);-  STRCPY(NameBuff, dir);-  STRCAT(NameBuff, ""/**/*"");+  STRLCPY(NameBuff, dir, sizeof(NameBuff));+  STRCAT(NameBuff, ""/**/*"");  // NOLINT","The `+` there makes a difference because it is logically right next to `*`, just outside the group. It is a very bad idea to have two greedy operators right next to each other. You are right that greedy inner match is good in case of success. But to detect failure they try all combinations of splitting the string between them before the regexp gives up. It grows ridiculously fast.I forgot the exact math, but imagine fibonacci like sequence, where each number is sum of all preceding numbers, not just two. For a string of length n it grows as the nth element in this sequence.",X
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/5031,70266140,2016-07-11T14:19:48Z,src/nvim/editor/arbmark.c,"@@ -0,0 +1,156 @@+/*+ * Same function but names are not limited to one char+ * There is also no ex_command, just viml functions+ */++#include ""nvim/vim.h""+#include ""nvim/globals.h""+#include ""nvim/mark.h""+#include ""nvim/memory.h""+#include ""nvim/map.h""+#include ""nvim/lib/kvec.h""+#include ""nvim/editor/arbmark.h""","It might be worth pointing out here that API functions will soon be accessible from VimL, though with different naming and type-checking conventions than native VimL builtins. The benefit is that the generated wrappers will make (most of) the type-checking and conversion for you.",X
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/5031,70310906,2016-07-11T18:29:25Z,src/nvim/api/mark_extended.c,"@@ -0,0 +1,163 @@+/*+ * Same function but names are not limited to one char+ * There is also no ex_command, just viml functions+ */++#include ""nvim/vim.h""+#include ""nvim/globals.h""      // FOR_ALL_BUFFERS+#include ""nvim/mark.h""         // SET_FMARK+#include ""nvim/memory.h""+#include ""nvim/map.h""          // pmap ...+#include ""nvim/lib/kbtree.h""   // kbitr ...+#include ""nvim/api/mark_extended.h""++#ifdef INCLUDE_GENERATED_DECLARATIONS+# include ""api/extmark.c.generated.h""+#endif++#define FOR_ALL_EXTMARKS(buf) \+  kbitr_t itr; \+  ExtendedMark *extmark; \+  for (;kb_itr_valid(&itr); kb_itr_next(ExtendedMark, buf->b_extmarks_tree, &itr)){++/* Create or update an extmark, */+int extmark_set(buf_T *buf, cstr_t *name, pos_T *pos)","You don���t need to cast `char *` to `cstr_t`. Function should accept `char *`, `cstr_t` exists purely for technical reasons.",X
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/5031,70331433,2016-07-11T20:34:24Z,src/nvim/api/mark_extended.c,"@@ -0,0 +1,163 @@+/*+ * Same function but names are not limited to one char+ * There is also no ex_command, just viml functions+ */++#include ""nvim/vim.h""+#include ""nvim/globals.h""      // FOR_ALL_BUFFERS+#include ""nvim/mark.h""         // SET_FMARK+#include ""nvim/memory.h""+#include ""nvim/map.h""          // pmap ...+#include ""nvim/lib/kbtree.h""   // kbitr ...+#include ""nvim/api/mark_extended.h""++#ifdef INCLUDE_GENERATED_DECLARATIONS+# include ""api/extmark.c.generated.h""+#endif++#define FOR_ALL_EXTMARKS(buf) \+  kbitr_t itr; \+  ExtendedMark *extmark; \+  for (;kb_itr_valid(&itr); kb_itr_next(ExtendedMark, buf->b_extmarks_tree, &itr)){++/* Create or update an extmark, */+int extmark_set(buf_T *buf, cstr_t *name, pos_T *pos)","@bfredl  Last part (nonexisting vs initializer) is exactly what I mean. Also this does not remove issue with double allocations vs _no_ allocations and useless indirection (existing kh API is already fine, also allocated `struct` containing a single pointer value which is _also_ allocated?!).",X
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/5031,70332382,2016-07-11T20:39:58Z,src/nvim/api/mark_extended.c,"@@ -0,0 +1,163 @@+/*+ * Same function but names are not limited to one char+ * There is also no ex_command, just viml functions+ */++#include ""nvim/vim.h""+#include ""nvim/globals.h""      // FOR_ALL_BUFFERS+#include ""nvim/mark.h""         // SET_FMARK+#include ""nvim/memory.h""+#include ""nvim/map.h""          // pmap ...+#include ""nvim/lib/kbtree.h""   // kbitr ...+#include ""nvim/api/mark_extended.h""++#ifdef INCLUDE_GENERATED_DECLARATIONS+# include ""api/extmark.c.generated.h""+#endif++#define FOR_ALL_EXTMARKS(buf) \+  kbitr_t itr; \+  ExtendedMark *extmark; \+  for (;kb_itr_valid(&itr); kb_itr_next(ExtendedMark, buf->b_extmarks_tree, &itr)){++/* Create or update an extmark, */+int extmark_set(buf_T *buf, cstr_t *name, pos_T *pos)","I also have an impression that what I already said was not the only issue with map interface, but cannot remember anything else. Perhaps one of the issues was that public API is too complex: when you declare a new hash using `KHASH_���` you get nice names like `kh_init_foo`. When you declare a new hash using map interface you need to use `map_new(Type1, Type2)`. Worse, you need to typedef Type1 and Type2 in some cases I would not typedef and this is absolutely not needed when using khash.",X
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/5026,70389142,2016-07-12T07:30:51Z,runtime/doc/nvim_terminal_emulator.txt,"@@ -113,4 +113,25 @@ The terminal cursor can be highlighted via |hl-TermCursor| and |hl-TermCursorNC|.  ==============================================================================+5. Status Variables				    *terminal-emulator-status*",Missing entry at the top in the section listing.,
111942,tweekmonster,https://api.github.com/repos/neovim/neovim/pulls/5050,70444458,2016-07-12T14:04:53Z,runtime/doc/remote_plugin.txt,"@@ -108,7 +108,9 @@ every time a remote plugin is installed, updated, or deleted. Vimscript file containing declarations for all Vimscript entities (commands/autocommands/functions) defined by all remote plugins, with each entity associated with the host and plugin path. The manifest is a generated-extension to the user's vimrc (it even has the vimrc filename prepended).+extension to the user's |vimrc| (it even has the vimrc filename prepended).","Yes if the vimrc is found, but I wasn't sure how to word it without getting too technical when the vimrc isn't found.",
111942,tweekmonster,https://api.github.com/repos/neovim/neovim/pulls/5050,70559701,2016-07-13T03:23:37Z,runtime/autoload/remote/host.vim,"@@ -118,18 +118,26 @@ function! remote#host#RegisterPlugin(host, path, specs) abort endfunction  -function! s:GetManifest() abort+function! s:GetInitScript() abort   let prefix = exists('$MYVIMRC')         \ ? $MYVIMRC         \ : matchstr(get(split(capture('scriptnames'), '\n'), 0, ''), '\f\+$')-  return fnamemodify(expand(prefix, 1), ':h')+  if empty(prefix) || fnamemodify(prefix, ':p') =~# '^'.$VIMRUNTIME+    if exists('$XDG_CONFIG_HOME') && isdirectory($XDG_CONFIG_HOME)+      let prefix = $XDG_CONFIG_HOME.'/nvim/init.vim'+    else+      let prefix = '~/nvim'+    endif+  endif+  let v:rplugin_init = fnamemodify(expand(prefix, 1), ':h')         \.'/.'.fnamemodify(prefix, ':t').'-rplugin~'","I like that more.  I could also have it rename the old file if it exists unless you can think of a reason that would be bad.Come to think of it, the `~` at the end might make people think it's a backup file if they happen to come across it.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/5050,70561106,2016-07-13T03:49:35Z,runtime/autoload/remote/host.vim,"@@ -118,18 +118,26 @@ function! remote#host#RegisterPlugin(host, path, specs) abort endfunction  -function! s:GetManifest() abort+function! s:GetInitScript() abort   let prefix = exists('$MYVIMRC')         \ ? $MYVIMRC         \ : matchstr(get(split(capture('scriptnames'), '\n'), 0, ''), '\f\+$')-  return fnamemodify(expand(prefix, 1), ':h')+  if empty(prefix) || fnamemodify(prefix, ':p') =~# '^'.$VIMRUNTIME+    if exists('$XDG_CONFIG_HOME') && isdirectory($XDG_CONFIG_HOME)+      let prefix = $XDG_CONFIG_HOME.'/nvim/init.vim'+    else+      let prefix = '~/nvim'+    endif+  endif+  let v:rplugin_init = fnamemodify(expand(prefix, 1), ':h')         \.'/.'.fnamemodify(prefix, ':t').'-rplugin~'","> I like that more. I could also have it rename the old file if it exists unless you can think of a reason that would be bad.That would be slick, but I'm ok with just mentioning it at https://github.com/neovim/neovim/wiki/Following-HEAD",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/5045,70568885,2016-07-13T06:13:51Z,runtime/doc/various.txt,"@@ -14,11 +14,13 @@ Various commands					*various*  							*CTRL-L* CTRL-L			Clear and redraw the screen.  The redraw may happen-			later, after processing typeahead.+			later, after processing typeahead. Terminal buffers+			fit the embedded terminal into the current window.  							*:redr* *:redraw* :redr[aw][!]		Redraw the screen right now.  When ! is included it is-			cleared first.+			cleared first and terminal buffers fit the embedded+			terminal into the current window.","here and above, instead of ""fit the embedded terminal into the current window"", a bit more direct/compact wording could be ""visible terminals are resized to their windows"". (Just to confirm: non-visible terminals should not be resized, right?)By the way: if a terminal is shown in multiple windows, which one takes precedence (incl. if none are focused)? I think it should choose the focused window, or the biggest window if none are focused.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/5050,70661224,2016-07-13T16:38:04Z,runtime/autoload/remote/host.vim,"@@ -118,36 +118,86 @@ function! remote#host#RegisterPlugin(host, path, specs) abort endfunction  -function! s:GetManifest() abort+"" Get the path to the rplugin manifest file and ensure the directory is+"" writeable.  Preferred locations are checked before falling back to sensible+"" locations.+function! s:GetManifestPath() abort+  let manifest_base = ''++  if has('win32') || has('win64')+    let preferred = ['$LOCALAPPDATA', '~/AppData/Local']+  else+    let preferred = [+          \ '$XDG_DATA_HOME', '~/.local/share',+          \ '$XDG_CONFIG_HOME', '~/.config']+  endif++  "" Try the preferred locations first.+  for dest in preferred+    if !exists(dest)+      continue+    endif++    let dest = fnamemodify(expand(dest), ':p')+    if !empty(dest) && isdirectory(dest) && filewritable(dest) == 2+      let dest .= 'nvim/'++      if isdirectory(dest) && filewritable(dest) != 2+        continue+      endif++      call mkdir(dest, 'p', 700)+      let manifest_base = dest+      break+    endif+  endfor++  "" Try the $MYVIMRC directory.+  if empty(manifest_base) && exists('$MYVIMRC') && !empty($MYVIMRC)+    let manifest_base = fnamemodify($MYVIMRC, ':p:h').'/'+    if filewritable(manifest_base) != 2+      let manifest_base = ''+    endif+  endif++  "" Final resort.+  if empty(manifest_base)+    let manifest_base = fnamemodify('~', ':p:h').'/'+  endif++  return manifest_base.'.nvim_rplugin.vim'",no need to hide the file (dot prefix) since it is in `~/local/shared/...`.,X
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/4915,70874832,2016-07-14T20:12:27Z,src/nvim/ex_cmds.c,"@@ -3533,7 +3533,7 @@ void do_sub(exarg_T *eap)          // 3. Substitute the string. Don't do this while incsubstitution and         //    there's no word to replace by eg : "":%s/pattern""-        if (!(eap->is_live && sub[0] == '\0' && !last_is_slash)) {+        if (!eap->is_live || sub[0] != '\0' || last_is_slash) {","Hmm, `last_is_slash` is wrong in any case, we should check for any delimiter, maybe like this``` diff-  const bool last_is_slash = !(eap->arg == NUL-                               || eap->arg[STRLEN(eap->arg) - 1] != '/');+  bool has_second_delim = false;   cmd = eap->arg;   if (!global_busy) {@@ -2989,6 +2988,7 @@ void do_sub(exarg_T *eap)         which_pat = RE_SEARCH;              /* use last '/' pattern */       pat = (char_u *)"""";                   /* empty search pattern */       delimiter = *cmd++;                   /* remember delimiter character */+      has_second_delim = true;     } else {          /* find the end of the regexp */       if (p_altkeymap && curwin->w_p_rl)         lrF_sub(cmd);@@ -2996,8 +2996,10 @@ void do_sub(exarg_T *eap)       delimiter = *cmd++;                   /* remember delimiter character */       pat = cmd;                            /* remember start of search pat */       cmd = skip_regexp(cmd, delimiter, p_magic, &eap->arg);-      if (cmd[0] == delimiter)              /* end delimiter found */+      if (cmd[0] == delimiter) {             /* end delimiter found */         *cmd++ = NUL;                       /* replace it with a NUL */+        has_second_delim = true;+      }     }     /*@@ -3536,7 +3538,7 @@ void do_sub(exarg_T *eap)         // 3. Substitute the string. Don't do this while incsubstitution and         //    there's no word to replace by eg : "":%s/pattern""-        if (!(eap->is_live && sub[0] == '\0' && !last_is_slash)) {+        if (!(eap->is_live && !has_second_delim)) {           if (do_count) {             // prevent accidentally changing the buffer by a function             save_ma = curbuf->b_p_ma;@@ -3874,7 +3876,7 @@ skip:   if (!kl_empty(lmatch)) {     // we did incsubstitute only if we had no word to replace by     // by and no ending slash-    if (!(eap->is_live && sub[0] == '\0' && !last_is_slash)) {+    if (!(eap->is_live && !has_second_delim)) {       sub_done = 1;     }     if (pat != NULL && *p_ics != NUL && eap->is_live) ```",X
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/4932,71035121,2016-07-15T20:20:02Z,runtime/autoload/health/nvim.vim,"@@ -3,9 +3,20 @@ let s:bad_responses = [             \ 'unable to parse python response',             \ 'unable to parse',             \ 'unable to get pypi response',-            \ 'unable to get neovim executable'+            \ 'unable to get neovim executable',+            \ 'unable to find neovim version'             \ ] +""""+"" Check if the string is a bad response+function! s:is_bad_response(s) abort+    if index(s:bad_responses, a:s) >= 0+        return v:true+    else+        return v:false+    endif","just ```return index(s:bad_responses, a:s) >= 0```",X
4466899,tjdevries,https://api.github.com/repos/neovim/neovim/pulls/4932,71035416,2016-07-15T20:22:29Z,runtime/autoload/health/nvim.vim,"@@ -3,9 +3,20 @@ let s:bad_responses = [             \ 'unable to parse python response',             \ 'unable to parse',             \ 'unable to get pypi response',-            \ 'unable to get neovim executable'+            \ 'unable to get neovim executable',+            \ 'unable to find neovim version'","I think it's good now, The problem was that when I changed things to using the list, as Shougo mentioned I should, for system calls, it broke several calls, but I couldn't figure out where. So while I was debugging, I just added this, and then figured it'd probably be more helpful to just leave it. I can try and remove all of it, but it seems like in the end that just takes more work. I will make the change you mentioned above,",X
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/5076,71467541,2016-07-20T05:32:21Z,Makefile,"@@ -89,7 +89,7 @@ oldtest: | nvim helptags 	+$(SINGLE_MAKE) -C src/nvim/testdir $(MAKEOVERRIDES)  helptags: | nvim-	+$(BUILD_CMD) -C build runtime/doc/tags","@fwalch it exists at https://github.com/neovim/neovim/blob/77937c4edd0e559ec66811ea20b103c329627a83/runtime/CMakeLists.txt#L81   , unless I am mistaken. Though your way is less obfuscated.",
6589866,brcolow,https://api.github.com/repos/neovim/neovim/pulls/4932,71467568,2016-07-20T05:32:47Z,runtime/doc/pi_health.txt,"@@ -3,16 +3,64 @@ Author: TJ DeVries <devries.timothyj@gmail.com>  ==============================================================================-1. Usage+1. Contents					 *health.vim-contents* -The health checker system is a way to get a snapshot of the important-information in a system.+	1. Contents ..: |health.vim-contents|+	2. Health.vim introduction ..: |health.vim-intro|+	3. Health.vim manual ..: |health.vim-manual|+		3.1 Health.vim commands ..: |health.vim-commands| -1.1 Commands+==============================================================================+2. Health.vim introduction			*health.vim-intro*++Debugging common issues is a time consuming task that many developers would+like to eliminate, and where elimination is impossible, minimize. Many common+questions and difficulties could be answered by a simple check of an+environment variable or a setting that the user has made. However, even with+FAQs and other manuals, it can be difficult to suggest the path a user should+take without knowing some information about their system.++Health.vim aims to solve this problem in two ways for both core and plugin+maintainers.++The way this is done is to provide an interface for that users will know to+check first before posting questsion in the issue tracker, dev list, etc. This","typo in ""questsion"". Also...instead of ""dev list"" maybe say gitter or chatroom?",
111942,tweekmonster,https://api.github.com/repos/neovim/neovim/pulls/5087,71471718,2016-07-20T06:25:45Z,src/nvim/mouse.c,"@@ -303,6 +304,73 @@ int jump_to_mouse(int flags,     mouse_past_bottom = true;   } +  // Adjust the clicked column position if there are concealed characters+  // before the current column.  But only when it's absolutely necessary.","I was thinking this, but I was trying to avoid adding new functions since this is my first stab at Neovim's source.  What are your thoughts on having a `syn_is_concealed()` or something that returns the match ID if the column is concealed?  It felt bad repeating the check.",
339435,fwalch,https://api.github.com/repos/neovim/neovim/pulls/5076,71587910,2016-07-20T19:10:41Z,Makefile,"@@ -89,7 +89,7 @@ oldtest: | nvim helptags 	+$(SINGLE_MAKE) -C src/nvim/testdir $(MAKEOVERRIDES)  helptags: | nvim-	+$(BUILD_CMD) -C build runtime/doc/tags","Hm.. I guess I was just confused because I didn't see any output from running it. Also, `make clean && cd build && make runtime/doc/tags` doesn't work, while `make clean && cd build && make helptags` does.. although that dependency (on nvim) is already contained in the top-level Makefile.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/4915,71604125,2016-07-20T20:50:59Z,src/nvim/ex_cmds.c,"@@ -6117,5 +6123,6 @@ void do_inc_sub(exarg_T *eap)     close_windows(livebuf, false);     close_buffer(NULL, livebuf, DOBUF_WIPE, false);   }+  curbuf->b_p_ul = b_p_ul_save;","minor nitpick: I would have placed this right after `restore_search_patterns` which also is a ""restore"" line. As now it is placed in the middle of the redraw logic.",X
112971,jamessan,https://api.github.com/repos/neovim/neovim/pulls/5094,71608869,2016-07-20T21:19:50Z,test/functional/legacy/036_regexp_character_classes_spec.lua,"@@ -270,9 +270,9 @@ describe('character classes in regexp', function()   end)   it('is working', function()     source([[-      1 s/\%#=0\^\t...//g-      2 s/\%#=1\^\t...//g-      3 s/\%#=2\^\t...//g]])+      1 s/\%#=0\%1l^\t...//g+      2 s/\%#=1\%2l^\t...//g+      3 s/\%#=2\%3l^\t...//g]])     diff(nlines(3, ctrl1..punct1..digits..punct2..punct3..lower..punct4..",`ctrl1` won't be in the lines because the `:s` commands removed it (along with the first space in punct1).,X
221465,fmoralesc,https://api.github.com/repos/neovim/neovim/pulls/5097,71915271,2016-07-22T17:30:26Z,runtime/doc/map.txt,"@@ -71,6 +71,7 @@ modes. :ino[remap] {lhs} {rhs}		|mapmode-i|	*:ino* *:inoremap* :ln[oremap] {lhs} {rhs}		|mapmode-l|	*:ln*  *:lnoremap* :cno[remap] {lhs} {rhs}		|mapmode-c|	*:cno* *:cnoremap*+:tno[remap] {lhs} {rhs}   |mapmode-t| *:tno* *:tnoremap*","There is no _mapmode-t_, so it needs to be added (see lines 291). It should be mentioned also at the end of the list in line 318. ",X
10180857,nhooyr,https://api.github.com/repos/neovim/neovim/pulls/4449,71962005,2016-07-23T00:17:22Z,runtime/autoload/man.vim,"@@ -11,127 +22,207 @@ catch /E145:/   "" Ignore the error in restricted mode endtry -"" Load man page {page} from {section}-""   call man#get_page([{section}, ]{page})-function man#get_page(...) abort-  let invoked_from_man = (&filetype ==# 'man')--  if a:0 == 0-    echoerr 'argument required'+function! man#get_page(count, editcmd, ...) abort+  if a:0 > 2+    call s:error('too many arguments')     return-  elseif a:0 > 2-    echoerr 'too many arguments'+  elseif a:0 == 0+    call s:error('what manual page do you want?')     return+  elseif a:0 == 1+    let [page, sect] = s:parse_page_and_sect_fpage(a:000[0])+    if empty(sect) && a:count != 10+      let sect = a:count+    endif+  else+    let sect = tolower(a:000[0])+    let page = a:000[1]   endif -  let sect = get(a:000, 0)-  let page = get(a:000, 1, sect)+  let out = systemlist(s:man_cmd.s:man_find_arg.' '.s:man_args(sect, page))+  if empty(out) || out[0] == ''+    call s:error('no manual entry for '.page.(empty(sect)?'':'('.sect.')'))+    return+  elseif page !~# '\/' "" if page is not a path, parse the page and section from the path+    "" use the last line because if we had something like printf(man) then man+    "" would be read as the manpage because man's path is at out[0]+    let [page, sect] = s:parse_page_and_sect_path(out[len(out)-1])+  endif -  let [page, sect] = s:parse_page_and_section(sect, page)+  call s:push_tag() -  if !empty(sect) && s:find_page(sect, page) == 0-    let sect = ''-  endif+  call s:read_page(sect, page, a:editcmd)+endfunction -  if s:find_page(sect, page) == 0-    echo 'No manual entry for '.page-    return+"" move to previous position in the stack+function! man#pop_tag() abort+  if !empty(s:tag_stack)+    let tag = remove(s:tag_stack, -1)+    execute tag['buf'].'b'+    call cursor(tag['lnum'], tag['col'])   endif+endfunction -  exec 'let s:man_tag_buf_'.s:man_tag_depth.' = '.bufnr('%')-  exec 'let s:man_tag_lin_'.s:man_tag_depth.' = '.line('.')-  exec 'let s:man_tag_col_'.s:man_tag_depth.' = '.col('.')-  let s:man_tag_depth = s:man_tag_depth + 1+"" save current position in the stack+function! s:push_tag() abort+  let s:tag_stack += [{+        \ 'buf':  bufnr('%'),+        \ 'lnum': line('.'),+        \ 'col':  col('.'),+        \ }]+endfunction -  let editcmd = 'edit'-  "" Use an existing 'man' window, else open a new one.-  if &filetype !=# 'man'+"" find the closest man window above/left+function! s:find_man(cmd) abort+  if g:man_find_window != 1 || &filetype ==# 'man'+    return a:cmd+  endif+  if winnr('$') > 1     let thiswin = winnr()-    wincmd b-    if winnr() > 1-      exec thiswin . 'wincmd w'-      while 1-        if &filetype ==# 'man'-          break-        endif-        wincmd w-        if thiswin == winnr()-          break-        endif-      endwhile-    endif+    while 1+      if &filetype ==# 'man'+        return 'edit'+      endif+      wincmd w+      if thiswin == winnr()+        return a:cmd+      endif+    endwhile+  endif+  return a:cmd+endfunction -    if &filetype !=# 'man'-      let editcmd = 'tabnew'-    endif+"" parses the page and sect out of 'page(sect)'+function! s:parse_page_and_sect_fpage(fpage) abort+  let ret = split(a:fpage, '(')+  if len(ret) > 1+    let iret = split(ret[1], ')')+    return [ret[0], tolower(iret[0])]+  else+    return [ret[0], '']   endif+endfunction -  silent exec editcmd.' man://'.page.(empty(sect)?'':'('.sect.')')+"" parses the page and sect out of 'path/page.sect'+function! s:parse_page_and_sect_path(path) abort+  let tail = fnamemodify(a:path, ':t')+  if fnamemodify(tail, ':e') =~# s:man_extensions+    let tail = fnamemodify(tail, ':r')+  endif+  "" TODO(nhooyr) all substitutes to matchlist/matchstr maybe?+  let page = substitute(tail, '^\(\f\+\)\..\+$', '\1', '')+  let sect = substitute(tail, '^\f\+\.\(.\+\)$', '\1', '')+  return [page, sect]+endfunction +function! s:read_page(sect, page, cmd)+  silent execute s:find_man(a:cmd) 'man://'.a:page.(empty(a:sect)?'':'('.a:sect.')')   setlocal modifiable-  silent keepjumps norm! 1G""_dG-  if empty($MANWIDTH)-    let $MANWIDTH = winwidth(0)-  endif-  silent exec 'r!/usr/bin/man '.s:cmd(sect, page).' | col -b'-  "" Remove blank lines from top and bottom.+  "" remove all the text, incase we already loaded the manpage before+  silent keepjumps %delete _+  let $MANWIDTH = winwidth(0)-1+  "" read manpage into buffer+  silent execute 'r!'.s:man_cmd.s:man_args(a:sect, a:page)+  call man#normalize_page()+  setlocal filetype=man+endfunction++function! man#normalize_page()+  "" remove all those backspaces+  execute ""silent keepjumps %substitute,.\b,,g""+  "" remove blank lines from top and bottom.   while getline(1) =~# '^\s*$'     silent keepjumps 1delete _   endwhile+  "" TODO(nhooyr) is deleting the bottom lines necessary?+  "" I think only deleting the first line is necessary when using r! to+  "" read manpage in.   while getline('$') =~# '^\s*$'     silent keepjumps $delete _   endwhile-  setlocal nomodified-  setlocal filetype=man+  keepjumps 1+endfunction -  if invoked_from_man || editcmd ==# 'tabnew'-    call s:set_window_local_options()+function! s:man_args(sect, page) abort+  if !empty(a:sect)+    return s:man_sect_arg.' '.shellescape(a:sect).' '.shellescape(a:page)   endif+  return shellescape(a:page) endfunction -function s:set_window_local_options() abort-  setlocal colorcolumn=0 foldcolumn=0 nonumber-  setlocal nolist norelativenumber nofoldenable+function! s:error(msg) abort+  redrawstatus!+  echon 'man.vim: '+  echohl ErrorMsg+  echon a:msg+  echohl None endfunction -function man#pop_page() abort-  if s:man_tag_depth > 0-    let s:man_tag_depth = s:man_tag_depth - 1-    exec ""let s:man_tag_buf=s:man_tag_buf_"".s:man_tag_depth-    exec ""let s:man_tag_lin=s:man_tag_lin_"".s:man_tag_depth-    exec ""let s:man_tag_col=s:man_tag_col_"".s:man_tag_depth-    exec s:man_tag_buf.""b""-    exec s:man_tag_lin-    exec ""norm! "".s:man_tag_col.""|""-    exec ""unlet s:man_tag_buf_"".s:man_tag_depth-    exec ""unlet s:man_tag_lin_"".s:man_tag_depth-    exec ""unlet s:man_tag_col_"".s:man_tag_depth-    unlet s:man_tag_buf s:man_tag_lin s:man_tag_col+function! man#complete(ArgLead, CmdLine, CursorPos) abort+  let args = split(a:CmdLine)+  let l = len(args)+  "" if the cursor (|) is at ':Man printf(|' then+  "" make sure to display the section. See s:get_candidates+  let fpage = 0+  "" if already completed a manpage, we return+  if (l > 1 && args[1] =~# ')\f*$') || l > 3+    return+  elseif l == 3+    "" cursor (|) is at ':Man 3 printf |'+    if empty(a:ArgLead)+      return+    endif+    let sect = tolower(args[1])+    let page = a:ArgLead+  elseif l == 2+    "" cursor (|) is at ':Man 3 |'+    if empty(a:ArgLead)+      let page = ''+      let sect = tolower(args[1])+    elseif a:ArgLead =~# '^\f\+(\f*$'+      "" cursor (|) is at ':Man printf(|'+      let tmp = split(a:ArgLead, '(')+      let page = tmp[0]+      let sect = tolower(substitute(get(tmp, 1, ''), ')$', '', ''))+      let fpage = 1+    else+      "" cursor (|) is at ':Man printf|'+      let page = a:ArgLead+      let sect = ''+    endif+  else+    let page = ''+    let sect = ''   endif+  return s:get_candidates(page, sect, fpage) endfunction -"" Expects a string like 'access' or 'access(2)'.-function s:parse_page_and_section(sect, str) abort-  try-    let [page, sect] = matchlist(a:str, '\v\C([-.[:alnum:]_]+)%(\(([-.[:alnum:]_]+)\))?')[1:2]-    if empty(sect)-      let sect = a:sect+function! s:get_candidates(page, sect, fpage) abort+  let candidates = globpath(s:MANDIRS(),'*/'.a:page.'*.'.a:sect.'*', 0, 1)+  let find = '\(.\+\)\.\%('.s:man_extensions.'\)\@!\'+  "" if the page is a path, complete files+  if empty(a:sect) && a:page =~# '\/'+    ""TODO(nhooyr) why does this complete the last one automatically",I found a bug in both neovim and vim's completion mechanism. See nhooyr/neoman.vim#17. Should I post it onto the vim mailing list first or should I create a neovim issue?,
10180857,nhooyr,https://api.github.com/repos/neovim/neovim/pulls/4449,71965893,2016-07-23T03:04:14Z,runtime/plugin/man.vim,"@@ -1,6 +1,11 @@-if get(g:, 'loaded_man', 0)+if exists('g:loaded_man')   finish endif let g:loaded_man = 1 -command! -count=0 -nargs=+ Man call man#get_page(<count>, <f-args>)+let g:man_find_window = get(g:, 'man_find_window', 1 )++command! -count=10 -complete=customlist,man#complete -nargs=* Man call","In `man.vim` count is set to 0 and used as an extra argument. Two problems with this approach. First, because count is only a number you can never use a letter in the section names. `Man 1ssl cms` will throw an error on OSX even though it is a valid manpage because an extra argument was sent to man.vim: `Man 0 1ssl cms` (this is how the arguments will be sent to `man.vim`). If you use a number section it looks like `Man 3 printf`.Second, this default value of 0 on count is used to indicate an empty section. On some systems 0 is actually a section (https://en.wikipedia.org/wiki/Man_page#Manual_sections) so you can never actually specify section 0 because it will always be interpreted as empty.To solve the first problem I made count a separate parameter. To solve the second problem I've made the default value of count 10 but imo that's an inelegant solution. Anyone have a better idea?",X
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/5027,71985406,2016-07-24T09:30:26Z,src/nvim/tui/input.c,"@@ -320,6 +322,66 @@ static bool handle_forced_escape(TermInput *input)   return false; } +static void set_bg_deferred(void **argv)+{+  char *bgvalue = argv[0];+  set_string_default(""bg"", bgvalue, false);+  if (!option_was_set((char_u *)""bg"")) {+    set_option_value((char_u *)""bg"", 0, (char_u *)bgvalue, 0);+  }+}++static bool handle_background_color(TermInput *input)+{+  size_t count = 0;+  size_t component = 0;+  uint16_t rgb[] = { 0, 0, 0 };+  uint16_t rgb_max[] = { 0, 0, 0 };+  bool eat_backslash = false;+  bool done = false;+  bool bad = false;+  if (rbuffer_size(input->read_stream.buffer) >= 9+      && !rbuffer_cmp(input->read_stream.buffer, ""\x1b]11;rgb:"", 9)) {+    rbuffer_consumed(input->read_stream.buffer, 9);+    RBUFFER_EACH(input->read_stream.buffer, c, i) {+      count = i + 1;+      if (eat_backslash) {+        done = true;+        break;+      } else if (c == '\x07') {+        done = true;+        break;+      } else if (c == '\x1b') {+        eat_backslash = true;+      } else if (bad) {+        // ignore+      } else if (c == '/') {+        if (component < 3) {",Is the sequence not already bad if we see three `'/'`? Should `bad` be set?,X
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/5031,72249588,2016-07-26T13:35:57Z,src/nvim/mark_extended.h,"@@ -0,0 +1,65 @@+#ifndef NVIM_EXTMARK_H+#define NVIM_EXTMARK_H++#include ""nvim/mark_extended_defs.h""+#include ""nvim/lib/kbtree.h""+#include ""nvim/lib/kvec.h""+#include ""nvim/map.h""++typedef PMap(cstr_t) StringMap2; // TODO do these have to be seperate?++typedef struct ExtendedMark ExtendedMark;+struct ExtendedMark {+  StringMap2 *names; // key = namespace, value = id","Not sure, the common case I assume would be a position having just one or two marks, it seems wrong optimize specifically for the case of a position having plenty of marks. Also it seems semantically wrong: what if you have `""text[ns1:mark1]moretext[ns1:mark2]yetmore""`and delete `moretext`? now ""ns1"" would expect to find both mark1 and 2 at the same position, which this representation forbids.For now, I would suggest just storing these as separate objects. If it _later_ turns out that multiple marks at the same position are common, we can try the solution: store the first (and maybe second) name directly in the same struct, allocate an array as soon as two(three) or more marks appears on the same position.",X
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/5031,72253065,2016-07-26T13:54:19Z,src/nvim/mark_extended.h,"@@ -0,0 +1,65 @@+#ifndef NVIM_EXTMARK_H+#define NVIM_EXTMARK_H++#include ""nvim/mark_extended_defs.h""+#include ""nvim/lib/kbtree.h""+#include ""nvim/lib/kvec.h""+#include ""nvim/map.h""++typedef PMap(cstr_t) StringMap2; // TODO do these have to be seperate?++typedef struct ExtendedMark ExtendedMark;+struct ExtendedMark {+  StringMap2 *names; // key = namespace, value = id","> the representation doesn't forbit it, Technically no, but it would just be needless complexity to manage both levels (multiple ""physical"" marks per position, multiple ""logical"" marks per ""physical"" mark)",X
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/5031,72325150,2016-07-26T19:59:20Z,src/nvim/mark_extended.c,"@@ -0,0 +1,318 @@+/* A normal mark that you would find in other text editors+ * The marks exists seperatley to vim marks, there are no+ * special marks for insert cursort etc+ *+ * Marks are stored in a btree for fast searching+ * A map of pointers to the marks is used for fast lookup+ *+ * For moving marks see : http://blog.atom.io/2015/06/16/optimizing-an-important-atom-primitive.html+ *+ */++#include ""nvim/vim.h""+#include ""nvim/mark_extended.h""+#include ""nvim/memory.h""+#include ""nvim/globals.h""      // FOR_ALL_BUFFERS+#include ""nvim/mark.h""         // SET_FMARK+#include ""nvim/map.h""          // pmap ...+#include ""nvim/lib/kbtree.h""   // kbitr ...++#ifdef INCLUDE_GENERATED_DECLARATIONS+# include ""mark_extended.c.generated.h""+#endif++/* bool extmark_create_namespace(buf_T *buf, char *ns */+/* { */+/* } */++/* Create or update an extmark */+/* returns two on succesful update */+/* returns three if namespace isn't found */ //TODO+int extmark_set(buf_T *buf, char *ns, char *name, linenr_T row, colnr_T col)+{+  ExtendedMark *extmark = extmark_get(buf, ns, name);+  if (!extmark){+    return extmark_create(buf, ns, name, row, col);+  }+  else {+    extmark_update(extmark, buf, ns, name, row,  col);+    return 2;+  }+}++/* returns 0 on missing name */+int extmark_unset(buf_T *buf, char *ns, char *name)+{+  ExtendedMark *extmark = extmark_get(buf, ns, name);+  if (!extmark){+    return FAIL;+  }+  return extmark_delete(extmark, buf, ns, name);+}++/* Get all mark names ordered by position*/+ExtmarkNames *extmark_names(buf_T *buf, char *ns)+{+  char *name;+  ExtmarkNames *array = (ExtmarkNames *)xmalloc(sizeof(ExtmarkNames));+  kv_init(*array);+  FOR_EXTMARKS_IN_NS(buf, ns)+    name = (char *)pmap_get(cstr_t)(extmark->names, ns);+    kv_push(*array, name);+  END_FOR_EXTMARKS_IN_NS+  return array;+}++/* Returns the postion of the given mark  */+pos_T *extmark_index(buf_T *buf, char *ns, char *name) {+  ExtendedMark *extmark = extmark_get(buf, ns, name);+  if (!extmark){+    return NULL;+  }+  return &(extmark->fmark.mark);+}++/* Given a mark, finds the next mark */+ExtendedMark *extmark_next(buf_T *buf, char *ns, pos_T *pos)+{+  return extmark_neighbour(buf, ns, pos, 1);+}++/* Given a name finds the previous mark */+ExtendedMark *extmark_prev(buf_T *buf, char *ns, pos_T *pos)+{+  return extmark_neighbour(buf, ns, pos, 0);+}++ExtmarkArray *extmark_nextrange(buf_T *buf, char *ns, pos_T *lower, pos_T *upper)+{+  return extmark_neighbour_range(buf, ns, lower, upper, 1);+}++/* Returns the position of marks between a range, */+/* marks found at the start or end index will be included, */+/* if upper.lnum or upper.col are negative the buffer */+/* will be searched to the end, */+/* go_forward can be set to control the order of the array */+static ExtmarkArray *extmark_neighbour_range(buf_T *buf, char *ns, pos_T *lower, pos_T *upper, bool go_forward)+{+  ExtmarkArray *array = (ExtmarkArray *)xmalloc(sizeof(ExtmarkArray));+  kv_init(*array);+  int cmp;++  FOR_EXTMARKS_IN_NS(buf, ns)+    if (pos_cmp(*lower, *upper) == 1) {+      break;+    }+    cmp = pos_cmp(*lower, extmark->fmark.mark);+    if (cmp != 1) {+      kv_push(*array, extmark);+    }+    else if (cmp == 1) {+      break;+    }+  END_FOR_EXTMARKS_IN_NS++  /* Swap the elements in the array */+  /* if (!go_forward) { */+      /* ExtendedMark holder; */+      /* int n = (int)sizeof(array); */+      /* int end = n-1; */+      /* for (int i = 0; i < n/2; i++) { */+          /* holder = kv_A(*array, i); */+          /* array[i] = array[end]; */+          /* array[end] = holder; */+          /* end --; */+      /* } */+  /* } */+  return array;+}++/* Returns the mark, nearest to the passed in mark*/+static ExtendedMark *extmark_neighbour(buf_T *buf, char *ns, pos_T *input, bool go_forward)+{+  int cmp;+  if (go_forward) {+    FOR_ALL_EXTMARKS(buf)+      cmp = pos_cmp(extmark->fmark.mark, *input);+      if (cmp == 1) {+        return extmark;+      }+    END_FOR_ALL_EXTMARKS+  } else {+    FOR_ALL_EXTMARKS_WITH_PREV(buf)+      cmp = pos_cmp(extmark->fmark.mark, *input);+      if (cmp == 1) {+        return prev;+      }+    END_FOR_ALL_EXTMARKS_WITH_PREV+  }+  return NULL;+}+int called=0;+static bool extmark_create(buf_T *buf, char* ns, char *name, linenr_T row, colnr_T col)+{+  /* Initialize as first mark on this buffer*/+  called ++;+  if (!buf->b_extmarks) {+    buf->b_extmarks = pmap_new(cstr_t)();+    buf->b_extmarks_tree = kb_init(extmarks, KB_DEFAULT_SIZE);+  }+  StringMap *ns_map = pmap_get(cstr_t)(buf->b_extmarks, (cstr_t)ns);+  /* Initialize a new namespace */+  /* if (!ns_map || !kh_size(ns_map->table)) { */+  ns = xstrdup(ns);+  if (!ns_map) {+    ns_map = pmap_new(cstr_t)();+    pmap_put(cstr_t)(buf->b_extmarks, (cstr_t)ns, ns_map);+  }++  name = xstrdup(name);+  ExtendedMark *extmark = (ExtendedMark *)xmalloc(sizeof(ExtendedMark));+  /* extmark->fmark.mark = gen_relative(buf, ns, row, col); */+  extmark->fmark.mark.lnum = row;+  extmark->fmark.mark.col = col;+  extmark->names = pmap_new(cstr_t)();+  pmap_put(cstr_t)(extmark->names, (cstr_t)ns, &name);++  kb_put(extmarks, buf->b_extmarks_tree,  *extmark);","Here is the thing: a pointer is also a value. The kb_tree api is not very convenient for this use case, but it works. Here is a sketch: (I have not tested it)```typedef struct {    pos_T key;    ... more data ..} elem_t;#define elem_cmp(a, b) (pos_cmp(a->key, b->key))KBTREE_INIT(test, elem_t, elem_cmp)static elem_t *insert_elem(bktree_t(test) *b, pos_T pos, bool* is_new) {    elem_t t, *p , **pp;    t.key = pos;    pp = kb_get(test, b, &t);    // IMPORTANT: put() only works if key is absent    if (pp) {        *is_new = false;        return *pp;    }    p = xmalloc(sizeof(*p));    p->key = pos;    kb_put(test, b, p);    *is_new = true;    return p;}```",X
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/4449,72343016,2016-07-26T21:40:52Z,runtime/ftplugin/man.vim,"@@ -4,8 +4,10 @@ endif let b:did_ftplugin = 1  if expand('%') !~# '^man:\/\/'-  call man#normalize_page()-  silent execute 'file '.'man://'.tolower(matchstr(getline(1), '^\S\+'))+  "" remove all those backspaces+  silent execute 'keepjumps %substitute,.\b,,ge'",I guess you need `:keeppatterns` here and elsewhere where substitute is used.,X
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/5132,72891165,2016-07-30T17:26:22Z,runtime/doc/eval.txt,"@@ -1809,7 +1809,7 @@ byteidx({expr}, {nr})		Number	byte index of {nr}'th char in {expr} byteidxcomp({expr}, {nr})	Number	byte index of {nr}'th char in {expr} call({func}, {arglist} [, {dict}]) 				any	call {func} with arguments {arglist}-capture({command})		String	capture output of {command}+execute({command})		String	execute and capture output of {command}",This list is alphabetically sorted.,
10180857,nhooyr,https://api.github.com/repos/neovim/neovim/pulls/5137,72906145,2016-07-31T15:36:04Z,LICENSE,"@@ -181,6 +181,33 @@ Neovim's license follows:       incurred by, or claims asserted against, such Contributor by reason       of your accepting any such warranty or additional liability. +	 END OF TERMS AND CONDITIONS++	 APPENDIX: How to apply the Apache License to your work.++	    To apply the Apache License to your work, attach the following+	    boilerplate notice, with the fields enclosed by brackets ""[]""+	    replaced with your own identifying information. (Don't include+	    the brackets!)  The text should be enclosed in the appropriate+	    comment syntax for the file format. We also recommend that a+	    file or class name and description of purpose be included on the+	    same ""printed page"" as the copyright notice for easier+	    identification within third-party archives.++	 Copyright [yyyy] [name of copyright owner]",See https://github.com/apple/swift/blob/master/LICENSE.txtSwift includes it.,
10180857,nhooyr,https://api.github.com/repos/neovim/neovim/pulls/5137,72906149,2016-07-31T15:36:21Z,LICENSE,"@@ -181,6 +181,33 @@ Neovim's license follows:       incurred by, or claims asserted against, such Contributor by reason       of your accepting any such warranty or additional liability. +	 END OF TERMS AND CONDITIONS","~~All it means is the end of terms and conditions. The appendix is still part of the license.~~ (edit: nevermind, the license clearly defines sections 1-9 as the license so its unnecessary)Even see http://choosealicense.com/licenses/apache-2.0/It says to copy the entire text into `LICENSE`.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/5094,72937837,2016-08-01T08:06:39Z,test/functional/legacy/036_regexp_character_classes_spec.lua,"@@ -268,4 +268,15 @@ describe('character classes in regexp', function()       ABCDEFGHIXYZ       ABCDEFGHIXYZ]])   end)+  it('""\\%1l^#.*"" does not match on a line starting with ""#"". (vim-patch:7.4.1035)', function()+    source([[+      1 s/\%#=0\%1l^\t...//g+      2 s/\%#=1\%2l^\t...//g+      3 s/\%#=2\%3l^\t...//g+      4 s/\%#=0\%4l^\t...//g+      5 s/\%#=1\%5l^\t...//g+      6 s/\%#=2\%6l^\t...//g]])+    diff(sixlines(string.sub(punct1, 1)..digits..punct2..upper..punct3..+      lower..punct4..ctrl2..iso_text))","Structure of the lua port of this test is hard to read, and longer than the old one... we should try to avoid that in ported tests.These changes look good though.",X
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/4944,73462470,2016-08-04T04:59:37Z,src/nvim/fileio.c,"@@ -493,22 +493,13 @@ readfile (     curbuf->b_flags &= ~(BF_NEW | BF_NEW_W);   } -  /*-   * Check readonly by trying to open the file for writing.-   * If this fails, we know that the file is readonly.-   */-  file_readonly = FALSE;+  // Check readonly.+  file_readonly = false;   if (!read_buffer && !read_stdin) {-    if (!newfile || readonlymode) {-      file_readonly = TRUE;-    } else if ((fd = os_open((char *)fname, O_RDWR, 0)) < 0) {-      // opening in readwrite mode failed => file is readonly-      file_readonly = TRUE;-    }-    if (file_readonly == TRUE) {-      // try to open readonly-      fd = os_open((char *)fname, O_RDONLY, 0);+    if (!newfile || readonlymode || !(os_getperm(fname) & 0222)) {","@Shougo Did you intentionally not use `perm`, to avoid the race condition mentioned in 4a138137f78907703aa9215b45f46b8f37d84ae5 ? Or why?",X
111942,tweekmonster,https://api.github.com/repos/neovim/neovim/pulls/5169,73685819,2016-08-05T12:42:53Z,runtime/autoload/man.vim,"@@ -190,6 +190,23 @@ function! s:open_page(sect, name)     silent keepjumps 1delete _   endwhile   setlocal filetype=man+  call man#create_toc()+endfunction++function! man#create_toc() abort+  if !exists('b:man_toc')+    "" Cache the TOC since user might switch in and out between the man pages.+    let b:man_toc = []+    for lnum in range(1, line('$'))+      let text = getline(lnum)+      if text =~# '^\%(\%(\S.*\)\=\S\|\%1l.*\|\s\{3\}\S.*\)$'","I originally used syntax for finding the lines because I was afraid of syntax changes, but it turned out to be pretty slow on large help files.  ![](http://sae.tweek.us/media/emoticons/emot-argh.gif)Was there a problem with tabs being matched?",X
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/5168,73719863,2016-08-05T16:22:27Z,runtime/plugin/man.vim,"@@ -5,6 +5,12 @@ if exists('g:loaded_man') endif let g:loaded_man = 1 -command! -complete=customlist,man#complete -nargs=* Man call man#open_page_command(<f-args>)+command! -count=0 -complete=customlist,man#complete -nargs=* Man call man#open_page_command(v:count, v:count1, <f-args>) -nnoremap <silent> <Plug>(Man) :<C-U>call man#open_page_mapping(v:count, v:count1, expand('<cWORD>'))<CR>+autocmd BufEnter man://*+      \ if exists('b:manwidth') && line('$') == 1 && empty(getline(1)) |+      \   unlet b:manwidth |+      \   silent execute 'Man' matchstr(expand('<amatch>'), 'man://\zs.*') |+      \ endif","This seems like a hack. Why is the buffer empty?If it's empty because it was unloaded, then wherever it was being unloaded it should instead be deleted (removed from the buffer list) so that it doesn't get re-used. We want to re-use existing `man://` buffers if they actually _exist_ (i.e. not unloaded), but otherwise this is a lot of trouble for no reason.",X
715238,equalsraf,https://api.github.com/repos/neovim/neovim/pulls/5130,73728060,2016-08-05T17:21:24Z,third-party/cmake/LibvtermCMakeLists.txt,"@@ -0,0 +1,72 @@+cmake_minimum_required(VERSION 2.8.11)+project(libvterm LANGUAGES C)","> But I can merge everything into a single file.Now that I look at it, not sure what is the correct way to create a new file with a specific contents from within the recipe file, e.g. file(write ...) is not very ergonomic for large files.",X
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/5130,73748787,2016-08-05T19:41:34Z,third-party/cmake/LibvtermCMakeLists.txt,"@@ -0,0 +1,72 @@+cmake_minimum_required(VERSION 2.8.11)+project(libvterm LANGUAGES C)","I am not familiar with all that's going on here, so take my opinion lightly. It's already uncomfortable  that we must maintain separate build files that aren't upstreamed. But then the addition of this new file introduces a pattern we aren't used to, so it's just another thing for people to grok when trying to follow the build system. ",X
41495,Shougo,https://api.github.com/repos/neovim/neovim/pulls/5159,73776772,2016-08-06T00:39:30Z,src/nvim/fileio.c,"@@ -493,22 +493,14 @@ readfile (     curbuf->b_flags &= ~(BF_NEW | BF_NEW_W);   } -  /*-   * Check readonly by trying to open the file for writing.-   * If this fails, we know that the file is readonly.-   */-  file_readonly = FALSE;+  // Check readonly.+  file_readonly = false;   if (!read_buffer && !read_stdin) {-    if (!newfile || readonlymode) {-      file_readonly = TRUE;-    } else if ((fd = os_open((char *)fname, O_RDWR, 0)) < 0) {-      // opening in readwrite mode failed => file is readonly-      file_readonly = TRUE;-    }-    if (file_readonly == TRUE) {-      // try to open readonly-      fd = os_open((char *)fname, O_RDONLY, 0);+    if (!newfile || readonlymode || !(perm & 0222)",perm variable is initialized only UNIX environment.I think it must be initialized in all environments.https://github.com/justinmk/neovim/blob/a8d1b5f721f51c1efbe6f55f3515f159ad0dfc8c/src/nvim/fileio.c#L427,X
41495,Shougo,https://api.github.com/repos/neovim/neovim/pulls/4944,73776805,2016-08-06T00:40:21Z,src/nvim/fileio.c,"@@ -493,22 +493,13 @@ readfile (     curbuf->b_flags &= ~(BF_NEW | BF_NEW_W);   } -  /*-   * Check readonly by trying to open the file for writing.-   * If this fails, we know that the file is readonly.-   */-  file_readonly = FALSE;+  // Check readonly.+  file_readonly = false;   if (!read_buffer && !read_stdin) {-    if (!newfile || readonlymode) {-      file_readonly = TRUE;-    } else if ((fd = os_open((char *)fname, O_RDWR, 0)) < 0) {-      // opening in readwrite mode failed => file is readonly-      file_readonly = TRUE;-    }-    if (file_readonly == TRUE) {-      // try to open readonly-      fd = os_open((char *)fname, O_RDONLY, 0);+    if (!newfile || readonlymode || !(os_getperm(fname) & 0222)) {","> @Shougo Did you intentionally not use perm, to avoid the race condition mentioned in 4a13813 ? Or why?It is intended.  Please read the comments.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/5182,73809334,2016-08-07T21:23:58Z,runtime/autoload/man.vim,"@@ -91,7 +91,7 @@ function! s:read_page(sect, name) abort   let b:manwidth = s:manwidth()   silent execute 'read!env MANWIDTH='.b:manwidth s:man_cmd s:man_args(a:sect, a:name)   "" remove all the backspaced text-  silent keeppatterns keepjumps %substitute,.\b,,ge+  silent keeppatterns keepjumps execute '%substitute,.\b,,e'.(&gdefault?'':'g')",Not sure but you might want to put `keeppatterns keepjumps` immediately before the substitute now.,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/5159,73810194,2016-08-07T22:17:14Z,src/nvim/fileio.c,"@@ -493,22 +493,14 @@ readfile (     curbuf->b_flags &= ~(BF_NEW | BF_NEW_W);   } -  /*-   * Check readonly by trying to open the file for writing.-   * If this fails, we know that the file is readonly.-   */-  file_readonly = FALSE;+  // Check readonly.+  file_readonly = false;   if (!read_buffer && !read_stdin) {-    if (!newfile || readonlymode) {-      file_readonly = TRUE;-    } else if ((fd = os_open((char *)fname, O_RDWR, 0)) < 0) {-      // opening in readwrite mode failed => file is readonly-      file_readonly = TRUE;-    }-    if (file_readonly == TRUE) {-      // try to open readonly-      fd = os_open((char *)fname, O_RDONLY, 0);+    if (!newfile || readonlymode || !(perm & 0222)","@Shougo Thanks for noticing that. Fixed at https://github.com/neovim/neovim/pull/5185. Even the Vim version of readfile() seems suspect. Under the conditions `(fd >= 0 && (read_stdin || read_buffer))`, the following code uses uninitialized `perm`:https://github.com/vim/vim/blob/30e12d259ee78272359f9da2655d0593a4f6a626/src/fileio.c#L2449However, those conditions may never be true, some brief testing shows the `os_open` call fails for special files (so `fd < 0`). This works:```nvim <(/dev/char/10:1)```",X
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/5185,73810852,2016-08-07T22:56:26Z,src/nvim/fileio.c,"@@ -503,13 +499,10 @@ readfile (     fd = os_open((char *)fname, O_RDONLY, 0);   } -  if (fd < 0) {                     /* cannot open at all */+  if (fd < 0) {                     // cannot open at all     msg_scroll = msg_save; #ifndef UNIX-    /*-     * On non-unix systems we can't open a directory, check here.-     */-    perm = os_getperm(fname);      /* check if the file exists */",This isn't needed anymore because:- on line 420 (guarded by `(!read_buffer && !read_stdin)` condition) we set it for all platforms- `fd` will be `0` unless line 499 is reached--which is _also_ guarded by `(!read_buffer && !read_stdin)` condition,X
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/5177,74027869,2016-08-09T09:41:09Z,test/functional/ui/screen_advanced_spec.lua,"@@ -0,0 +1,79 @@+local helpers = require('test.functional.helpers')(after_each)+local Screen = require('test.functional.ui.screen')+local clear, feed, insert = helpers.clear, helpers.feed, helpers.insert+local execute = helpers.execute+++describe('Screen rendering', function()+  local screen+  local colors = Screen.colors+  local hl_colors = {",I would suggest removing this and just use  `Screen.colors` directly (it is an anti-pattern from the pre-`snapshot_util()`-days that exist in a few of our existing screen tests. I will do a clean-up PR soon to remove it from existing tests.).,X
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/5177,74145887,2016-08-09T21:14:50Z,src/nvim/screen.c,"@@ -2073,6 +2073,212 @@ fill_foldcolumn (   } } +// Extracted:++static bool check_can_spell(win_T* wp) {+  return (wp->w_p_spell+      && *wp->w_s->b_p_spl != NUL+      && !GA_EMPTY(&wp->w_s->b_langp)+      && *(char **)(wp->w_s->b_langp.ga_data) != NULL);+}++static bool character_fits_at_col(int mb_c, int col, win_T* wp) {+  return !((wp->w_p_rl ? (col <= 0) : (col >= wp->w_width - 1))+    && (*mb_char2cells)(mb_c) == 2);+}++static int compare_lnum_to_cursor(int lnum, win_T* wp) {+  return wp->w_cursor.lnum - lnum;+}++static bool should_conceal_line(win_T* wp, int lnum, bool in_visual_area) {+  return (wp->w_p_cole > 0+    && (wp != curwin || lnum != wp->w_cursor.lnum || conceal_cursor_line(wp))+    && !(in_visual_area && vim_strchr(wp->w_p_cocu, 'v') == NULL));+}++static bool check_column_limit(int col, win_T* wp) {+  return (wp->w_p_rl ? (col >= 0) : (col < wp->w_width));+}++static int check_column_diff(int col, win_T* wp) {+  return (wp->w_p_rl ? col : wp->w_width - 1 - col);+}++static bool should_correct_column(win_T* wp, int lnum, int col) {+  return (wp == curwin+      && lnum == wp->w_cursor.lnum+      && conceal_cursor_line(wp) && (int)wp->w_virtcol <= col);+}++static int get_search_attr(win_T* wp, long if_col) {+  int attr = search_hl.attr;+  bool shl_flag = false;+  matchitem_T *cur = wp->w_match_head;+  match_T     *shl;+  while (cur != NULL || shl_flag == false) {+    if (shl_flag == false && ((cur != NULL && cur->priority > SEARCH_HL_PRIORITY) || cur == NULL)) {+      shl = &search_hl;+      shl_flag = true;+    } else+      shl = &cur->hl;+    if (if_col == (long)shl->startcol)+      attr = shl->attr;+    if (shl != &search_hl && cur != NULL)+      cur = cur->next;+  }+  return attr;+}++static int get_search_attr_cur(win_T* wp) {+  int attr = search_hl.attr_cur;+  bool shl_flag = false;+  matchitem_T *cur = wp->w_match_head;+  match_T     *shl;+  while (cur != NULL || shl_flag == false) {+    if (shl_flag == false && ((cur != NULL && cur->priority > SEARCH_HL_PRIORITY) || cur == NULL)) {+      shl = &search_hl;+      shl_flag = true;+    } else+      shl = &cur->hl;+    if (shl->attr_cur != 0)+      attr = shl->attr_cur;+    if (shl != &search_hl && cur != NULL)+      cur = cur->next;+  }+  return attr;+}++static bool init_syntax(int lnum, win_T* wp) {+  int save_did_emsg;+  if (syntax_present(wp) && !wp->w_s->b_syn_error) {+    save_did_emsg = did_emsg;+    did_emsg = FALSE;+    syntax_start(wp, lnum); // Prepare for syntax highlighting in this line.+    if (did_emsg) {         // On error, stop syntax highlighting.+      wp->w_s->b_syn_error = TRUE;+    } else {+      did_emsg = save_did_emsg;+      return true;+    }+  }+  return false;+}++struct VisualPos {+  int from; int to;+  bool in_visual;+  pos_T pos;+};++static struct VisualPos init_visual(int lnum, win_T* wp) {+  struct VisualPos res = {+    .from = -10, .to = MAXCOL,+    .in_visual = false,+    .pos = { 0 }+  };++  pos_T *top, *bot;+  if (ltoreq(curwin->w_cursor, VIsual)) {+    top = &curwin->w_cursor;+    bot = &VIsual;+  } else {                          /* Visual is before curwin->w_cursor */+    top = &VIsual;+    bot = &curwin->w_cursor;+  }++  if (lnum >= top->lnum && lnum <= bot->lnum)+    res.in_visual = true;++  if (VIsual_mode == Ctrl_V) {+    if (res.in_visual) { /* block mode */+      res.from = wp->w_old_cursor_fcol;+      res.to = wp->w_old_cursor_lcol;+    }+  } else { /* non-block mode */+    if (lnum > top->lnum && lnum <= bot->lnum) {+      res.from = 0;+    } else if (lnum == top->lnum) {+      if (VIsual_mode == 'V') { /* linewise */+        res.from = 0;+      } else {+        getvvcol(wp, top, (colnr_T *)&res.from, NULL, NULL);+        if (gchar_pos(top) == NUL)+          res.to = res.from + 1;+      }+    }+    if (VIsual_mode != 'V' && lnum == bot->lnum) {+      if (*p_sel == 'e' && bot->col == 0 && bot->coladd == 0 )+        { res.from = -10; res.to = MAXCOL; }+      else if (bot->col == MAXCOL)+        { res.to = MAXCOL; }+      else {++        res.pos = *bot;+        if (*p_sel == 'e') {+          getvvcol(wp, &(res.pos), (colnr_T *)&res.to, NULL, NULL);+        } else {+          getvvcol(wp, &(res.pos), NULL, NULL, (colnr_T *)&res.to);+          ++res.to;+        }+      }+    }+  }++  return res;+}++#define MB_IS_WIDE() (has_mbyte && (*mb_char2cells)(mb_c) > 1)","I don't think this macro add any clarity. Instead we can just remove the `has_mbyte &&` proactively, as it is an ""optimiziation"" (for `enc=latin1` which is deprecated in nvim) and not changing any logic.",X
972014,mhinz,https://api.github.com/repos/neovim/neovim/pulls/4723,74587220,2016-08-12T13:08:41Z,src/nvim/event/wstream.c,"@@ -54,10 +52,11 @@ void wstream_init(Stream *stream, size_t maxmem) /// /// @param stream The `Stream` instance /// @param cb The callback-void wstream_set_write_cb(Stream *stream, stream_write_cb cb)-  FUNC_ATTR_NONNULL_ALL+void wstream_set_write_cb(Stream *stream, stream_write_cb cb, void * data)",`void *data`,
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/4915,74655129,2016-08-12T20:25:33Z,test/functional/ui/incsubstitution_spec.lua,"@@ -0,0 +1,1159 @@+local helpers = require('test.functional.helpers')(after_each)+local Screen = require('test.functional.ui.screen')+local clear, feed, insert = helpers.clear, helpers.feed, helpers.insert+local execute, expect, eval = helpers.execute, helpers.expect, helpers.eval+local neq, source, eq = helpers.neq, helpers.source, helpers.eq+local meths, curbufmeths = helpers.meths, helpers.curbufmeths++local default_text = [[+  Inc substitution on+  two lines+]]++local function common_setup(screen, incsub, text)+  if screen then+    execute(""syntax on"")+    execute(""set nohlsearch"")+    execute(""hi IncSubstitute guifg=red guibg=yellow"")+    screen:attach()+    screen:set_default_attr_ignore( {{bold=true, foreground=Screen.colors.Blue}} )+    screen:set_default_attr_ids({+      [1]  = {foreground = Screen.colors.Fuchsia},+      [2]  = {foreground = Screen.colors.Brown, bold = true},+      [3]  = {foreground = Screen.colors.SlateBlue},+      [4]  = {bold = true, foreground = Screen.colors.SlateBlue},+      [5]  = {foreground = Screen.colors.DarkCyan},+      [6]  = {bold = true},+      [7]  = {underline = true, bold = true, foreground = Screen.colors.SlateBlue},+      [8]  = {foreground = Screen.colors.Slateblue, underline = true},+      [9]  = {background = Screen.colors.Yellow},+      [10] = {reverse = true},+      [11] = {reverse = true, bold=true},+      [12] = {foreground = Screen.colors.Red, background = Screen.colors.Yellow},+      [13] = {bold = true, foreground = Screen.colors.SeaGreen},+      [14] = {foreground = Screen.colors.White, background = Screen.colors.Red},+    })+  end++  if incsub then+    execute(""set incsubstitute=""..incsub)+  else+    execute(""set incsubstitute="")+  end++  if text then+    insert(text)+  end+end++describe('IncSubstitution preserves', function()+  before_each(clear)++  it(':ls functionality', function()+    local screen = Screen.new(30,10)+    common_setup(screen, ""split"", ""ABC"")++    execute(""%s/AB/BA/"")+    execute(""ls"")++    screen:expect([[+      ~                             |+      ~                             |+      ~                             |+      ~                             |+      ~                             |+      :ls                           |+        1 %a + ""[No Name]""          |+                line 1              |+      {13:Press ENTER or type command to}|+      {13: continue}^                     |+    ]])+  end)++  it('substitution with various delimiters', function()+    for _, case in pairs{"""", ""split"", ""nosplit""} do+      clear()+      insert(default_text)+      execute(""set incsubstitute="" .. case)++      local delims = { '/', '#', ';', '%', ',', '@', '!', ''}+      for _,delim in pairs(delims) do+        execute(""%s""..delim..""lines""..delim..""LINES""..delim..""g"")+        expect([[+          Inc substitution on+          two LINES+          ]])+        execute(""undo"")+      end+    end+  end)++  it('the undolevels setting', function()+    for _, case in pairs{"""", ""split"", ""nosplit""} do+      clear()+      execute(""set undolevels=139"")+      execute(""setlocal undolevels=34"")+      execute(""set incsubstitute="" .. case)+      insert(""as"")+      feed("":%s/as/glork/<enter>"")+      eq(meths.get_option('undolevels'), 139)+      eq(curbufmeths.get_option('undolevels'), 34)+    end+  end)++end)++describe('IncSubstitution preserves g+/g-', function()+  local cases = { """", ""split"", ""nosplit"" }++  local substrings = {+    "":%s/1"",+    "":%s/1/"",+    "":%s/1/<bs>"",+    "":%s/1/a"",+    "":%s/1/a<bs>"",+    "":%s/1/ax"",+    "":%s/1/ax<bs>"",+    "":%s/1/ax<bs><bs>"",+    "":%s/1/ax<bs><bs><bs>"",+    "":%s/1/ax/"",+    "":%s/1/ax/<bs>"",+    "":%s/1/ax/<bs>/"",+    "":%s/1/ax/g"",+    "":%s/1/ax/g<bs>"",+    "":%s/1/ax/g<bs><bs>""+  }++  local function test_sub(substring, split, redoable)+    clear()+    execute(""set incsubstitute="" .. split)++    insert(""1"")+    feed(""o2<esc>"")+    execute(""undo"")+    feed(""o3<esc>"")+    if redoable then+      feed(""o4<esc>"")+      execute(""undo"")+    end+    feed(substring.. ""<enter>"")+    execute(""undo"")++    feed(""g-"")+    expect([[+      1+      2]])++    feed(""g+"")+    expect([[+      1+      3]])+  end++  local function test_notsub(substring, split, redoable)+    clear()+    execute(""set incsubstitute="" .. split)++    insert(""1"")+    feed(""o2<esc>"")+    execute(""undo"")+    feed(""o3<esc>"")+    if redoable then+      feed(""o4<esc>"")+      execute(""undo"")+    end+    feed(substring .. ""<esc>"")++    feed(""g-"")+    expect([[+      1+      2]])++    feed(""g+"")+    expect([[+      1+      3]])++    if redoable then+      feed(""<c-r>"")+      expect([[+        1+        3+        4]])+    end+  end+++  local function test_threetree(substring, split)+    clear()+    execute(""set incsubstitute="" .. split)++    insert(""1"")+    feed(""o2<esc>"")+    feed(""o3<esc>"")+    feed(""uu"")+    feed(""oa<esc>"")+    feed(""ob<esc>"")+    feed(""uu"")+    feed(""oA<esc>"")+    feed(""oB<esc>"")++    -- This is the undo tree (x-Axis is timeline), we're at B now+    --    ----------------A - B+    --   /+    --  | --------a - b+    --  |/+    --  1 - 2 - 3++    feed(""2u"")+    feed(substring .. ""<esc>"")+    feed(""<c-r>"")+    expect([[+      1+      A]])++    feed(""g-"") -- go to b+    feed(""2u"")+    feed(substring .. ""<esc>"")+    feed(""<c-r>"")+    expect([[+      1+      a]])++    feed(""g-"") -- go to 3+    feed(""2u"")+    feed(substring .. ""<esc>"")+    feed(""<c-r>"")+    expect([[+      1+      2]])+  end+++  it(""at a non-leaf of the undo tree"", function()+    -- this does not work even in standard vim+    -- if fixed, easily combined with the test below+    if true then+      pending(""vim"")+      return+    end++--    for _, case in pairs(cases) do+--      for _, str in pairs(substrings) do+--        for _, redoable in pairs({true}) do+--          test_sub(str, case, redoable)+--        end+--      end+--    end+  end)++  it(""at a leaf of the undo tree"", function()+    for _, case in pairs(cases) do+      for _, str in pairs(substrings) do+        for _, redoable in pairs({false}) do+          test_sub(str, case, redoable)+        end+      end+    end+  end)++  it(""when interrupting substitution"", function()+    for _, case in pairs(cases) do+      for _, str in pairs(substrings) do+        for _, redoable in pairs({true,false}) do+          test_notsub(str, case, redoable)+        end+      end+    end+  end)++  it(""in a complex undo scenario"", function()+    for _, case in pairs(cases) do+      for _, str in pairs(substrings) do+        test_threetree(str, case)+      end+    end+  end)++  it('with undolevels=0', function()+    for _, case in pairs(cases) do+      clear()+      common_setup(nil, case, default_text)+      execute(""set undolevels=0"")++      feed(""1G0"")+      insert(""X"")+      feed("":%s/tw/MO/<esc>"")+      execute(""undo"")+      expect(default_text)+      execute(""undo"")+      expect(string.gsub(default_text, ""Inc"", ""XInc""))+      execute(""undo"")++      execute(""%s/tw/MO/g"")+      expect(string.gsub(default_text, ""tw"", ""MO""))+      execute(""undo"")+      expect(default_text)+      execute(""undo"")+      expect(string.gsub(default_text, ""tw"", ""MO""))+    end+  end)++  it('with undolevels=1', function()+    local screen = Screen.new(20,10)++    for _, case in pairs(cases) do+      clear()+      common_setup(screen, case, default_text)+      execute(""set undolevels=1"")++      feed(""1G0"")+      insert(""X"")+      feed(""IY<esc>"")+      feed("":%s/tw/MO/<esc>"")+      -- using execute(""undo"") here will result in a ""Press ENTER"" prompt+      feed(""u"")+      expect(string.gsub(default_text, ""Inc"", ""XInc""))+      feed(""u"")+      expect(default_text)++      feed("":%s/tw/MO/g<enter>"")+      feed("":%s/MO/GO/g<enter>"")+      feed("":%s/GO/NO/g<enter>"")+      feed(""u"")+      expect(string.gsub(default_text, ""tw"", ""GO""))+      feed(""u"")+      expect(string.gsub(default_text, ""tw"", ""MO""))+      feed(""u"")++      if case == ""split"" then+        screen:expect([[+          ^MOo lines           |+                              |+          ~                   |+          ~                   |+          ~                   |+          ~                   |+          ~                   |+          ~                   |+          ~                   |+          Already...st change |+        ]])+      else+        screen:expect([[+          Inc substitution on |+          ^MOo lines           |+                              |+          ~                   |+          ~                   |+          ~                   |+          ~                   |+          ~                   |+          ~                   |+          Already...st change |+        ]])+      end+    end+    screen:detach()+  end)++  it('with undolevels=2', function()+    local screen = Screen.new(20,10)++    for _, case in pairs(cases) do+      clear()+      common_setup(screen, case, default_text)+      execute(""set undolevels=2"")++      feed(""2GAx<esc>"")+      feed(""Ay<esc>"")+      feed(""Az<esc>"")+      feed("":%s/tw/AR<esc>"")+      -- using execute(""undo"") here will result in a ""Press ENTER"" prompt+      feed(""u"")+      expect(string.gsub(default_text, ""lines"", ""linesxy""))+      feed(""u"")+      expect(string.gsub(default_text, ""lines"", ""linesx""))+      feed(""u"")+      expect(default_text)+      feed(""u"")++      if case == ""split"" then+        screen:expect([[+          two line^s           |+                              |+          ~                   |+          ~                   |+          ~                   |+          ~                   |+          ~                   |+          ~                   |+          ~                   |+          Already...st change |+        ]])+      else+        screen:expect([[+          Inc substitution on |+          two line^s           |+                              |+          ~                   |+          ~                   |+          ~                   |+          ~                   |+          ~                   |+          ~                   |+          Already...st change |+        ]])+      end++      feed("":%s/tw/MO/g<enter>"")+      feed("":%s/MO/GO/g<enter>"")+      feed("":%s/GO/NO/g<enter>"")+      feed("":%s/NO/LO/g<enter>"")+      feed(""u"")+      expect(string.gsub(default_text, ""tw"", ""NO""))+      feed(""u"")+      expect(string.gsub(default_text, ""tw"", ""GO""))+      feed(""u"")+      expect(string.gsub(default_text, ""tw"", ""MO""))+      feed(""u"")++      if case == ""split"" then+        screen:expect([[+          ^MOo lines           |+                              |+          ~                   |+          ~                   |+          ~                   |+          ~                   |+          ~                   |+          ~                   |+          ~                   |+          Already...st change |+        ]])+      else+        screen:expect([[+          Inc substitution on |+          ^MOo lines           |+                              |+          ~                   |+          ~                   |+          ~                   |+          ~                   |+          ~                   |+          ~                   |+          Already...st change |+        ]])+      end+    end+    screen:detach()+  end)++  it('with undolevels=-1', function()+    local screen = Screen.new(20,10)++    for _, case in pairs(cases) do+      clear()+      common_setup(screen, case, default_text)++      execute(""set undolevels=-1"")+      feed("":%s/tw/MO/g<enter>"")+      -- using execute(""undo"") here will result in a ""Press ENTER"" prompt+      feed(""u"")+      if case == ""split"" then+        screen:expect([[+          ^MOo lines           |+                              |+          ~                   |+          ~                   |+          ~                   |+          ~                   |+          ~                   |+          ~                   |+          ~                   |+          Already...st change |+        ]])+      else+        screen:expect([[+          Inc substitution on |+          ^MOo lines           |+                              |+          ~                   |+          ~                   |+          ~                   |+          ~                   |+          ~                   |+          ~                   |+          Already...st change |+        ]])+      end+    end+    screen:detach()+  end)++end)++describe('IncSubstitution with incsubstitute=split', function()+  local screen++  before_each(function()+    clear()+    screen = Screen.new(30,15)+    common_setup(screen, ""split"", default_text .. default_text)+  end)++  after_each(function()+    if screen then screen:detach() end+  end)+++  it('shows split window when typing the pattern', function()+    feed("":%s/tw"")+    screen:expect([[+      Inc substitution on           |+      two lines                     |+                                    |+      ~                             |+      ~                             |+      {11:[No Name] [+]                 }|+       [2]two lines                 |+       [4]two lines                 |+                                    |+      ~                             |+      ~                             |+      ~                             |+      ~                             |+      {10:[inc_sub]                     }|+      :%s/tw^                        |+    ]])+  end)++  it('shows split window with empty replacement', function()+    feed("":%s/tw/"")+    screen:expect([[+      Inc substitution on           |+      o lines                       |+                                    |+      ~                             |+      ~                             |+      {11:[No Name] [+]                 }|+       [2]o lines                   |+       [4]o lines                   |+                                    |+      ~                             |+      ~                             |+      ~                             |+      ~                             |+      {10:[inc_sub]                     }|+      :%s/tw/^                       |+    ]])++    feed(""x<del>"")+    screen:expect([[+      Inc substitution on           |+      o lines                       |+                                    |+      ~                             |+      ~                             |+      {11:[No Name] [+]                 }|+       [2]o lines                   |+       [4]o lines                   |+                                    |+      ~                             |+      ~                             |+      ~                             |+      ~                             |+      {10:[inc_sub]                     }|+      :%s/tw/^                       |+    ]])++  end)++  it('shows split window when typing replacement', function()+    feed("":%s/tw/XX"")+    screen:expect([[+      Inc substitution on           |+      XXo lines                     |+                                    |+      ~                             |+      ~                             |+      {11:[No Name] [+]                 }|+       [2]{12:XX}o lines                 |+       [4]{12:XX}o lines                 |+                                    |+      ~                             |+      ~                             |+      ~                             |+      ~                             |+      {10:[inc_sub]                     }|+      :%s/tw/XX^                     |+    ]])+  end)++  it('does not show split window for :s/', function()+    feed(""2gg"")+    feed("":s/tw"")+    screen:expect([[+      Inc substitution on           |+      two lines                     |+      Inc substitution on           |+      two lines                     |+                                    |+      ~                             |+      ~                             |+      ~                             |+      ~                             |+      ~                             |+      ~                             |+      ~                             |+      ~                             |+      ~                             |+      :s/tw^                         |+    ]])+  end)++  it('highlights the pattern with :set hlsearch', function()+    execute(""set hlsearch"")+    feed("":%s/tw"")+    screen:expect([[+      Inc substitution on           |+      {9:tw}o lines                     |+                                    |+      ~                             |+      ~                             |+      {11:[No Name] [+]                 }|+       [2]{9:tw}o lines                 |+       [4]{9:tw}o lines                 |+                                    |+      ~                             |+      ~                             |+      ~                             |+      ~                             |+      {10:[inc_sub]                     }|+      :%s/tw^                        |+    ]])+  end)++  it('actually replaces text', function()+    feed("":%s/tw/XX/g<enter>"")++    screen:expect([[+      XXo lines                     |+      Inc substitution on           |+      ^XXo lines                     |+                                    |+      ~                             |+      ~                             |+      ~                             |+      ~                             |+      ~                             |+      ~                             |+      ~                             |+      ~                             |+      ~                             |+      ~                             |+      :%s/tw/XX/g                   |+    ]])+  end)++  it('shows correct line numbers with many lines', function()+    feed(""gg"")+    feed(""2yy"")+    feed(""1000p"")+    execute(""1,1000s/tw/BB/g"")++    feed("":%s/tw/X"")+    screen:expect([[+      Inc substitution on           |+      Xo lines                      |+      Xo lines                      |+      Inc substitution on           |+      Xo lines                      |+      {11:[No Name] [+]                 }|+       [1001]{12:X}o lines               |+       [1003]{12:X}o lines               |+       [1005]{12:X}o lines               |+       [1007]{12:X}o lines               |+       [1009]{12:X}o lines               |+       [1011]{12:X}o lines               |+       [1013]{12:X}o lines               |+      {10:[inc_sub]                     }|+      :%s/tw/X^                      |+    ]])+  end)++end)++describe('Incsubstitution with incsubstitute=nosplit', function()+  local screen = Screen.new(20,10)++  before_each(function()+    clear()+    common_setup(screen, ""nosplit"", default_text .. default_text)+  end)++  after_each(function()+    if screen then screen:detach() end+  end)++  it('does not show a split window anytime', function()+    execute(""set hlsearch"")++    feed("":%s/tw"")+    screen:expect([[+      Inc substitution on |+      {9:tw}o lines           |+      Inc substitution on |+      {9:tw}o lines           |+                          |+      ~                   |+      ~                   |+      ~                   |+      ~                   |+      :%s/tw^              |+    ]])++    feed(""/BM"")+    screen:expect([[+      Inc substitution on |+      BMo lines           |+      Inc substitution on |+      BMo lines           |+                          |+      ~                   |+      ~                   |+      ~                   |+      ~                   |+      :%s/tw/BM^           |+    ]])++    feed(""/"")+    screen:expect([[+      Inc substitution on |+      BMo lines           |+      Inc substitution on |+      BMo lines           |+                          |+      ~                   |+      ~                   |+      ~                   |+      ~                   |+      :%s/tw/BM/^          |+    ]])++    feed(""<enter>"")+    screen:expect([[+      Inc substitution on |+      BMo lines           |+      Inc substitution on |+      ^BMo lines           |+                          |+      ~                   |+      ~                   |+      ~                   |+      ~                   |+      :%s/tw/BM/          |+    ]])+  end)++end)++describe('Incsubstitution with a failing expression', function()+  local screen = Screen.new(20,10)+  local cases = { """", ""split"", ""nosplit"" }++  local function refresh(case)+    clear()+    common_setup(screen, case, default_text)+  end++  it('in the pattern does nothing for', function()+    for _, case in pairs(cases) do+      refresh(case)+      execute(""set incsubstitute="" .. case)+      feed("":silent! %s/tw\\(/LARD/<enter>"")+      expect(default_text)+    end+  end)++  it('in the replacement deletes the matches', function()+    for _, case in pairs(cases) do+      refresh(case)+      local replacements = { ""\\='LARD"", ""\\=xx_novar__xx"" }++      for _, repl in pairs(replacements) do+        execute(""set incsubstitute="" .. case)+        feed("":silent! %s/tw/"" .. repl .. ""/<enter>"")+        expect(string.gsub(default_text, ""tw"", """"))+        execute(""undo"")+      end+    end+  end)++end)++describe('Incsubstitution and cnoremap', function()+  local cases = { """",  ""split"", ""nosplit"" }++  local function refresh(case)+    clear()+    common_setup(nil, case, default_text)+  end++  it('work with remapped characters', function()+    for _, case in pairs(cases) do+      refresh(case)+      local command = ""%s/lines/LINES/g""++      for i = 1, string.len(command) do+        local c = string.sub(command, i, i)+        execute(""cnoremap "".. c .. "" "" .. c)+      end++      execute(command)+      expect([[+        Inc substitution on+        two LINES+        ]])+      end+  end)++  it('work then mappings move the cursor', function()+    for _, case in pairs(cases) do+      refresh(case)+      execute(""cnoremap ,S LINES/<left><left><left><left><left><left>"")++      feed("":%s/lines/,Sor three <enter>"")+      expect([[+        Inc substitution on+        two or three LINES+        ]])++      execute(""cnoremap ;S /X/<left><left><left>"")+      feed("":%s/;SI<enter>"")+      expect([[+        Xnc substitution on+        two or three LXNES+        ]])++      execute(""cnoremap ,T //Y/<left><left><left>"")+      feed("":%s,TX<enter>"")+      expect([[+        Ync substitution on+        two or three LYNES+        ]])++      execute(""cnoremap ;T s//Z/<left><left><left>"")+      feed("":%;TY<enter>"")+      expect([[+        Znc substitution on+        two or three LZNES+        ]])+      end+  end)++  it('work with a failing mapping', function()+    for _, case in pairs(cases) do+      refresh(case)+      execute(""cnoremap <expr> x execute('bwipeout!')[-1].'x'"")+      source([[+        func! DoIt()+          bwipeout!+        endfunc]])+      --execute(""cnoremap <expr> x DoIt()[-1].'x'"")++      feed("":%s/tw/tox<enter>"")++      -- error thrown b/c of the mapping+      neq(nil, string.find(eval('v:errmsg'), '^E523:'))+      -- the substitution after the error only works for ics=split/nosplit+      -- which seems like the right thing to do in all cases, but we probably+      -- don't want to change the default, so all in all this seems alright+      if case == '' then+        expect(default_text)+      else+        expect(string.gsub(default_text, ""tw"", ""tox""))+      end+    end+  end)++  it('work when temporarily moving the cursor', function()+    for _, case in pairs(cases) do+      refresh(case)+      execute(""cnoremap <expr> x cursor(1, 1)[-1].'x'"")++      feed("":%s/tw/tox/g<enter>"")+      expect(string.gsub(default_text, ""tw"", ""tox""))+    end+  end)++  it('work when a mapping disables incsub', function()+    for _, case in pairs(cases) do+      refresh(case)+      execute(""cnoremap <expr> x execute('set incsubstitute=')[-1]"")++      feed("":%s/tw/toxa/g<enter>"")+      expect(string.gsub(default_text, ""tw"", ""toa""))+    end+  end)++  it('work with a complex mapping', function()+    for _, case in pairs(cases) do+      refresh(case)+      source([[cnoremap x <C-\>eextend(g:, {'fo': getcmdline()})+      \.fo<CR><C-c>:new<CR>:bw!<CR>:<C-r>=remove(g:, 'fo')<CR>x]])++      feed("":%s/tw/tox"")+      feed(""/<enter>"")+      expect(string.gsub(default_text, ""tw"", ""tox""))+    end+  end)++end)++-- *** AUTOCMDS+-- Right now, none fire when opening or closing the incsub buffer+--+-- If that behavior is changed, add tests (suggestions by ZyX-l):+-- * If any are run when window is opened, then tests which check what if these+--   autocommands close the window.+-- * If any are run when window is opened, then+--   tests which check what if these autocommands wipe out buffer without closing+--   the window.+-- * If any are run when window is opened, then tests which check+--   what if these autocommands switch buffer without closing the window or+--   wiping buffer out.+-- * If any are run when window is opened, then tests which+--   check what if these autocommands wipe out buffer where substitution is+--   being made.+-- * If any are run when window is opened, then tests which check what+--   if these autocommands close window where substitution is being made (but+--   not window with temporary view)++describe('Incsubstitute: autocommands', function()+  before_each(clear)++  -- keys are events to be tested+  -- values are arrays like { open = 1, close = 2} which would mean+  -- the event is expected to fire for buffer number 1 when the incsub +  -- window is opend, and for buffer number 2 when the incsub window is+  -- closed+  local eventsExpected = {+    BufAdd = {},+    BufDelete = {open = 2},+    BufEnter = {open = 1},+    BufFilePost = {},+    BufFilePre = {},+    BufHidden = {open = 2},+    BufLeave = {open = 2},+    BufNew = {},+    BufNewFile = {},+    BufRead = {},+    BufReadCmd = {},+    BufReadPre = {},+    BufUnload = {open = 2},+    BufWinEnter = {},+    BufWinLeave = {open = 2},+    BufWipeout = {open = 2},+    BufWrite = {},+    BufWriteCmd = {},+    BufWritePost = {},+    Syntax = {},+    FileType = {},+    WinEnter = {open = 1},+    WinLeave = {open = 2},+    CmdwinEnter = {},+    CmdwinLeave = {open = 1},+  }++  local function register_autocmd(event)+    execute(""let g:"" .. event .. ""_fired=0"")+    execute(""autocmd "" .. event .. "" * let g:"" .. event .. ""_fired=expand('<abuf>')"")",What if event was fired more then once? I think this should be set to a list in first execute and use `call add(���)` here.,X
111942,tweekmonster,https://api.github.com/repos/neovim/neovim/pulls/5156,74661741,2016-08-12T21:16:53Z,runtime/doc/options.txt,"@@ -3267,7 +3267,7 @@ A jump table for the options with a short description can be found at |Q_op|. 				     >:SignColumn,B:SpellBad,P:SpellCap, 				     R:SpellRare,L:SpellLocal,-:Conceal, 				     +:Pmenu,=:PmenuSel,x:PmenuSbar,-				     X:PmenuThumb"")+				     X:PmenuThumb,q:QuickFixLine"")","Yeah I saw that PR after it was pointed out in Gitter.  I agree with your sentiment in hindsight.  But, before `snapshot_util()` was pointed out to me, screen testing was a little bit difficult to comprehend. The output for highlights that aren't configured made it even more confusing.At the time of writing, my view was that if I need to test a particular highlight, I only want to focus on the appearance of that highlight and more broad tests for highlighting would cover the ones I wasn't testing.  For this PR in particular, I didn't want to care about the `qf` syntax highlighting for line numbers and filenames.I actually think that the output of `snapshot_util()` should be what's displayed for failed test, but followed with a list of the highlights instead of them being inline with the screen text.",X
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/5156,74662909,2016-08-12T21:26:18Z,runtime/doc/options.txt,"@@ -3267,7 +3267,7 @@ A jump table for the options with a short description can be found at |Q_op|. 				     >:SignColumn,B:SpellBad,P:SpellCap, 				     R:SpellRare,L:SpellLocal,-:Conceal, 				     +:Pmenu,=:PmenuSel,x:PmenuSbar,-				     X:PmenuThumb"")+				     X:PmenuThumb,q:QuickFixLine"")","> I actually think that the output of snapshot_util() should be what's displayed for failed test, but followed with a list of the highlights instead of them being inline with the screen text.But that is exactly the output of `snapshot_util()` _today_. There is no need whatsoever to ""focus on"" or ""care about"" relevant or irrelevant highlights (in the part of generating the actual expects, I mean), just copy the entire list of highlights to the set_default.",X
111942,tweekmonster,https://api.github.com/repos/neovim/neovim/pulls/5156,74668105,2016-08-12T22:12:46Z,runtime/doc/options.txt,"@@ -3267,7 +3267,7 @@ A jump table for the options with a short description can be found at |Q_op|. 				     >:SignColumn,B:SpellBad,P:SpellCap, 				     R:SpellRare,L:SpellLocal,-:Conceal, 				     +:Pmenu,=:PmenuSel,x:PmenuSbar,-				     X:PmenuThumb"")+				     X:PmenuThumb,q:QuickFixLine"")","> but maybe the expect() error output should remain a little bit cumbersome just to have an excuse for mentioning snapshot_util() in the error messageHah, fair enough.  Docs would definitely help.  I've gotten by by tag jumping and reading what I can that way, but often miss the big block of text at the top of the file.And yeah, @mhinz pointed out `snapshot_util()` to me and I got confused when I found no other use of it.The takeaway from all this is that I'm removing the `'highlight'` changes later tonight ����As a side note, this has been useful for editing the screen tests: `match ErrorMsg /\[\[\_.\{-}\zs\^/`",X
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/4723,74688410,2016-08-13T15:47:35Z,runtime/doc/eval.txt,"@@ -4418,6 +4420,10 @@ jobsend({job}, {data})					{Nvim} *jobsend()* 			:call jobsend(j, [""abc"", ""123\n456"", """"]) < 		will send ""abc<NL>123<NUL>456<NL>"". +		If the job was started with the rpc option this function+		cannot be used, instead use |rpcnotify()| and |rpcrequest()|+		to communicate with the job.","Doesn't need to block this PR, but this is a case where more generic language could help UX. We could:- deprecate `jobsend`, `rpcnotify`, `rpcrequest`- introduce `chansend({job/chan}, {raw=boolean}, {data})` and `channotify({job/chan}, ...)`**Alternative suggestion:** Remove distinction between ""rpc/channel"" and ""job"". Just call everything a job.- Jobs may have channels.- Jobs that have channels work with a superset of `job*()` functions and parameters.- Deprecate `rpc*` functions.  Introduce `jobnotify` function if necessary.",X
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/5210,74697819,2016-08-14T08:25:06Z,src/nvim/ex_docmd.c,"@@ -5311,6 +5333,87 @@ uc_check_code (     break;   } +  case ct_MODS:+  {+    result = quote ? 2 : 0;+    if (buf != NULL) {+      if (quote) {+        *buf++ = '""';+      }+      *buf = '\0';+    }++    bool multi_mods = false;++    // :aboveleft and :leftabove+    if (cmdmod.split & WSP_ABOVE) {+      result += add_cmd_modifier(buf, ""aboveleft"", &multi_mods);+    }+    // :belowright and :rightbelow+    if (cmdmod.split & WSP_BELOW) {+      result += add_cmd_modifier(buf, ""belowright"", &multi_mods);+    }+    // :botright+    if (cmdmod.split & WSP_BOT) {+      result += add_cmd_modifier(buf, ""botright"", &multi_mods);+    }++    typedef struct {+      bool *set;+      char *name;+    } mod_entry_T;+    static mod_entry_T mod_entries[] = {+      { &cmdmod.browse, ""browse"" },+      { (bool *)&cmdmod.confirm, ""confirm"" },",Is the value pointed to not dependent on endianness and we could read the wrong value when dereferencing?,X
111942,tweekmonster,https://api.github.com/repos/neovim/neovim/pulls/5189,74701928,2016-08-14T13:45:17Z,src/nvim/message_pane.c,"@@ -0,0 +1,302 @@+#include ""nvim/vim.h""+#include ""nvim/ascii.h""+#include ""nvim/buffer.h""+#include ""nvim/message.h""+#include ""nvim/ex_cmds.h""+#include ""nvim/fileio.h""+#include ""nvim/option.h""+#include ""nvim/memline.h""+#include ""nvim/macros.h""+#include ""nvim/move.h""+#include ""nvim/misc1.h""+#include ""nvim/window.h""+#include ""nvim/buffer_defs.h""+#include ""nvim/message_pane.h""+#include ""nvim/os/time.h""++#define MSGPANE_SEP_FILL '-'+#define MSGPANE_SEP (char_u *)""-- ""+#define MSGPANE_SEP_LEN STRLEN(MSGPANE_SEP)++#ifdef INCLUDE_GENERATED_DECLARATIONS+# include ""message_pane.c.generated.h""+#endif+++static buf_T *msgpane_buf = NULL;+static MessagePaneEntry *history[MAX_MSGPANE_HIST];+static int history_len = 0;+++/// Return true if the message pane exists.+static bool msgpane_exists(void)+{+  return msgpane_buf != NULL && buf_valid(msgpane_buf);+}++/// Create a message pane buffer.+static bool msgpane_create(void)+{+  if (msgpane_exists()) {+    return true;+  }++  msgpane_buf = buflist_new((char_u *)""nvim://messages"", NULL, 1, BLN_LISTED);+  msgpane_buf->b_messages = true;","Ah, because `buflist_new()` could return NULL, right?  (just woke up)",X
111942,tweekmonster,https://api.github.com/repos/neovim/neovim/pulls/5189,74704317,2016-08-14T16:01:46Z,runtime/doc/eval.txt,"@@ -7470,6 +7486,7 @@ localmap		Compiled with local mappings and abbr. |:map-local| mac			Macintosh version of Vim. macunix			Macintosh version of Vim, using Unix files (OS-X). menu			Compiled with support for |:menu|.+msgpane			Compiled with support for 'messagepane'.",I copied a pattern.  I don't know if it's needed in the docs.  I wanted to have `has('msgpane')` so plugin developers could have some expectation of how messages are presented.,
111942,tweekmonster,https://api.github.com/repos/neovim/neovim/pulls/5189,74704386,2016-08-14T16:06:32Z,src/nvim/buffer.c,"@@ -309,7 +309,7 @@ close_buffer (   // buffers.   // The caller must take care of NOT deleting/freeing when 'bufhidden' is   // ""hide"" (otherwise we could never free or delete a buffer).-  if (!buf->terminal) {+  if (!buf->terminal && !buf->b_messages) {","The main thing I was going for by following the terminal checks is I didn't want the message buffer to be editable at all.  I think that if a user could change certain buffer settings, it could lead to some bad behavior from writing messages to a buffer that the user expects to be controlling.Is there a better way to go about that?",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/5198,74755613,2016-08-15T12:43:02Z,src/nvim/path.c,"@@ -2186,9 +2186,16 @@ static int path_get_absolute_path(const char_u *fname, char_u *buf,  /// Check if the given file is absolute. ///-/// This just checks if the file name starts with '/' or '~'. /// @return `TRUE` if ""fname"" is absolute. int path_is_absolute_path(const char_u *fname) {+#ifdef WIN32+  // A name like ""d:/foo"" and ""//server/share"" is absolute+  return (isalpha(fname[0]) && fname[1] == ':'","AFAIR `isalpha` is locale-dependent and may return true unexpectedly if locale happens to be non-UTF-8 (and, theoretically, it may return unexpected false if locale is not `C`, but I doubt you will find any locale which rejects latin letters). I would suggest using not C library, but our `ascii_isalpha` function from `src/nvim/lib/ascii.h`.",X
715238,equalsraf,https://api.github.com/repos/neovim/neovim/pulls/5198,74768565,2016-08-15T14:22:47Z,src/nvim/path.c,"@@ -2186,9 +2186,16 @@ static int path_get_absolute_path(const char_u *fname, char_u *buf,  /// Check if the given file is absolute. ///-/// This just checks if the file name starts with '/' or '~'. /// @return `TRUE` if ""fname"" is absolute. int path_is_absolute_path(const char_u *fname) {+#ifdef WIN32+  // A name like ""d:/foo"" and ""//server/share"" is absolute+  return (isalpha(fname[0]) && fname[1] == ':'","I would prefer to deal with this one separately. The use of isalpha is similar to what is done in vim/vim and there are a least a couple other locations, unrelated to this PR, where isalpha is used.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/5225,74790504,2016-08-15T16:36:05Z,.ci/msys_test.bat,"@@ -0,0 +1,7 @@+:: FIXME(equalsraf) currently not all tests work on Windows+:: for now just run what we can+mingw32-make functionaltest TEST_FILE=test\functional\eval\printf_spec.lua VERBOSE=1 || goto :error","> I'm trying to get this to work but TEST_TAG=windows doesn't seem to have any effect (no tests are run). I assumed the only thing I had to do was add #windows in describe but maybe I was wrong.That's the way it supposed to be supposed to be (and it works for me locally on linux). If we expect more than say half of the test files to work on windows soon, it might be better to blacklist the non-working with `pending()`. This will mean we gradually _remove_ blacklists as more and more tests work on windows, which might feel better as the tests look cleaner as windows coverage improves.",
715238,equalsraf,https://api.github.com/repos/neovim/neovim/pulls/5225,75006991,2016-08-16T19:51:38Z,test/functional/ui/syntax_conceal_spec.lua,"@@ -3,6 +3,14 @@ local Screen = require('test.functional.ui.screen') local clear, feed, execute = helpers.clear, helpers.feed, helpers.execute local insert = helpers.insert +do+  clear()+  if helpers.os_name() == 'windows' then+    pending('FIXME: Windows', function() end)+    return+  end+end","Not sure I can call pending in that context, https://ci.appveyor.com/project/equalsraf/neovim/build/1114/job/t2e8u4yf440fyuqp#L8667 - [helpers.lua](https://github.com/equalsraf/neovim/blob/5163c133a7b7e31e54e0eed75c4105e0f083fe71/test/functional/helpers.lua#L435)",
4117685,KillTheMule,https://api.github.com/repos/neovim/neovim/pulls/5226,75012742,2016-08-16T20:26:06Z,src/nvim/ex_cmds.h,"@@ -26,6 +28,37 @@ typedef struct {   list_T *additional_elements;  ///< Additional data left from ShaDa file. } SubReplacementString; ++// Defs for inc_sub functionality++// List of matches in a line+#define _noop(x)+KLIST_INIT(colnr_T, colnr_T, _noop)","I checked that out a bit, it would mean hand-writing the for-loops, which is certainly doable. Also, I'd have to deallocate manually in the case of `MatchedLine`, since there's no way to initialize with a custom deallocator as with klist.Should I still do it? I think I can manage, but I'm uncertain if deallocating manually is a good tradeoff.",X
41495,Shougo,https://api.github.com/repos/neovim/neovim/pulls/5175,75056414,2016-08-17T03:04:38Z,src/nvim/eval.c,"@@ -9994,8 +9994,8 @@ static void f_getcompletion(typval_T *argvars, typval_T *rettv) {   char_u        *pat;   expand_T      xpc;-  int           options = WILD_KEEP_ALL | WILD_SILENT | WILD_USE_NL-    | WILD_LIST_NOTFOUND | WILD_NO_BEEP;+  int           options = WILD_SILENT | WILD_USE_NL | WILD_ADD_SLASH+    | WILD_NO_BEEP;","It cannot.  Because, it is too long line.```src/nvim/eval.c:9997:  Lines should be <= 80 characters long  [whitespace/line_length] [2]```",X
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/4723,75173437,2016-08-17T17:58:04Z,src/nvim/event/stream.h,"@@ -44,13 +44,15 @@ struct stream {   uv_file fd;   stream_read_cb read_cb;   stream_write_cb write_cb;+  void *cb_data;   stream_close_cb close_cb, internal_close_cb;+  void *close_cb_data, *internal_data;   size_t fpos;   size_t curmem;   size_t maxmem;   size_t pending_reqs;   size_t num_bytes;-  void *data, *internal_data;+  void *data;",`data` is not used anymore.,X
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/4723,75177094,2016-08-17T18:17:13Z,src/nvim/eval.c,"@@ -11724,16 +11728,33 @@ static void f_jobclose(typval_T *argvars, typval_T *rettv)   if (argvars[1].v_type == VAR_STRING) {     char *stream = (char *)argvars[1].vval.v_string;     if (!strcmp(stream, ""stdin"")) {-      process_close_in(proc);+      if (data->rpc) {+        EMSG(_(""Invalid on rpc job, use jobclose(id, 'rpc')""));+      } else {+        process_close_in(proc);+      }     } else if (!strcmp(stream, ""stdout"")) {-      process_close_out(proc);+      if (data->rpc) {+        EMSG(_(""Invalid on rpc job, use jobclose(id, 'rpc')""));+      } else {+        process_close_out(proc);+      }     } else if (!strcmp(stream, ""stderr"")) {       process_close_err(proc);+    } else if (!strcmp(stream, ""rpc"")) {+      if (data->rpc) {+        channel_close(data->id);+      }",No error message if `data->rpc` is false?,X
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/4723,75181204,2016-08-17T18:37:43Z,src/nvim/eval.c,"@@ -14158,32 +14189,28 @@ static void f_rpcstart(typval_T *argvars, typval_T *rettv)    // The last item of argv must be NULL   argv[i] = NULL;-  uint64_t channel_id = channel_from_process(argv); -  if (!channel_id) {-    EMSG(_(e_api_spawn_failed));-  }--  rettv->vval.v_number = (varnumber_T)channel_id;+  TerminalJobData *data = common_job_init(argv, NULL, NULL, NULL,+                                          NULL, false, true, false, NULL);+  common_job_start(data, rettv); } -// ""rpcstop()"" function+// ""rpcstop()"" function (DEPRECATED)",`eval.txt` mentioned `rpcstart()` as deprecated.,X
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/4723,75188895,2016-08-17T19:22:50Z,src/nvim/eval.c,"@@ -14158,32 +14189,28 @@ static void f_rpcstart(typval_T *argvars, typval_T *rettv)    // The last item of argv must be NULL   argv[i] = NULL;-  uint64_t channel_id = channel_from_process(argv); -  if (!channel_id) {-    EMSG(_(e_api_spawn_failed));-  }--  rettv->vval.v_number = (varnumber_T)channel_id;+  TerminalJobData *data = common_job_init(argv, NULL, NULL, NULL,+                                          NULL, false, true, false, NULL);+  common_job_start(data, rettv); } -// ""rpcstop()"" function+// ""rpcstop()"" function (DEPRECATED)","I'll remove the deprecation. We cannot fully deprecate it yet as it is the only way to close a socket (which currently can only be opened from outside nvim, so I don't expect it to be used much yet ). We should fix it in a further PR allowing full socket IO.",X
4117685,KillTheMule,https://api.github.com/repos/neovim/neovim/pulls/5226,75201634,2016-08-17T20:35:06Z,src/nvim/ex_cmds.h,"@@ -31,30 +32,19 @@ typedef struct {  // Defs for inc_sub functionality -// List of matches in a line-#define _noop(x)-KLIST_INIT(colnr_T, colnr_T, _noop)-typedef klist_t(colnr_T) klist_colnr_T;-#undef _noop+// List of matches on a single line+typedef kvec_t(colnr_T) kvec_colnr_T;  /// Structure to backup and display matched lines in incsubstitution typedef struct {   linenr_T lnum;   long nmatch;   char_u *line;-  klist_colnr_T *start_col;+  kvec_colnr_T start_col; } MatchedLine;  // List of matched lines-#define _dealloc_MatchedLine(x) \-do { \-  if (x->data.line) { xfree(x->data.line); } \-  if (x->data.start_col) { kl_destroy(colnr_T, x->data.start_col); } \-  } while (0)--KLIST_INIT(MatchedLine, MatchedLine, _dealloc_MatchedLine)-typedef klist_t(MatchedLine) klist_MatchedLine;-#undef _dealloc_MatchedLine+typedef kvec_t(MatchedLine) kvec_MatchedLine;","The macro definition is [here](https://github.com/neovim/neovim/blob/master/src/nvim/lib/kvec.h#L52). Macros are just text replacements, so I'd redefine the struct everytime. Wouldn't that mean that after``` Ckvec_t(int) A;kvec_t(int) B```the two variables A and B have a different type? Can I have this struct definitition in the signature of a function?I'll give it a shot :)",X
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/5226,75202491,2016-08-17T20:39:49Z,src/nvim/ex_cmds.h,"@@ -31,30 +32,19 @@ typedef struct {  // Defs for inc_sub functionality -// List of matches in a line-#define _noop(x)-KLIST_INIT(colnr_T, colnr_T, _noop)-typedef klist_t(colnr_T) klist_colnr_T;-#undef _noop+// List of matches on a single line+typedef kvec_t(colnr_T) kvec_colnr_T;","It should be `ColNrVec` according to the style guide, not `���_T`.@bfredl Using `kvec_t(colnr_T)` is not a good idea, you can���t pass `kvec_t(colnr_T) *foo` to `void bar(kvec_t(colnr_T) foo)`:```echo $'struct { int a; } *foo; int main(int argc, char **argv, char **environ){ struct { int a; } bar; foo = &bar; }' | clang -Wall -pedantic -std=c99 -xc -<stdin>:1:101: warning: incompatible pointer types assigning to 'struct (anonymous struct at <stdin>:1:1) *' from 'struct (anonymous struct at <stdin>:1:74) *' [-Wincompatible-pointer-types]struct { int a; } *foo; int main(int argc, char **argv, char **environ){ struct { int a; } bar; foo = &bar; }                                                                                                    ^ ~~~~1 warning generated.```",X
4117685,KillTheMule,https://api.github.com/repos/neovim/neovim/pulls/5226,75204217,2016-08-17T20:49:26Z,src/nvim/ex_cmds.h,"@@ -31,30 +32,19 @@ typedef struct {  // Defs for inc_sub functionality -// List of matches in a line-#define _noop(x)-KLIST_INIT(colnr_T, colnr_T, _noop)-typedef klist_t(colnr_T) klist_colnr_T;-#undef _noop+// List of matches on a single line+typedef kvec_t(colnr_T) kvec_colnr_T;  /// Structure to backup and display matched lines in incsubstitution typedef struct {   linenr_T lnum;   long nmatch;   char_u *line;-  klist_colnr_T *start_col;+  kvec_colnr_T start_col; } MatchedLine;  // List of matched lines-#define _dealloc_MatchedLine(x) \-do { \-  if (x->data.line) { xfree(x->data.line); } \-  if (x->data.start_col) { kl_destroy(colnr_T, x->data.start_col); } \-  } while (0)--KLIST_INIT(MatchedLine, MatchedLine, _dealloc_MatchedLine)-typedef klist_t(MatchedLine) klist_MatchedLine;-#undef _dealloc_MatchedLine+typedef kvec_t(MatchedLine) kvec_MatchedLine;","No I'm really bad at naming (ever heard of Leonardo of Quirm?), so I'm happy to use your suggestions. I obviously just contracted `kvec_t(colnr_T)` to something without brackets...",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/5226,75206899,2016-08-17T21:04:29Z,src/nvim/ex_cmds.h,"@@ -31,30 +32,19 @@ typedef struct {  // Defs for inc_sub functionality -// List of matches in a line-#define _noop(x)-KLIST_INIT(colnr_T, colnr_T, _noop)-typedef klist_t(colnr_T) klist_colnr_T;-#undef _noop+// List of matches on a single line+typedef kvec_t(colnr_T) kvec_colnr_T;","@ZyX-I but we don't pass a pointer to the `kvec_t(colnr_T)`, it belongs to the enclosing MatchedLine struct, and we already use kvec_t without a typedef in this kind of case.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/5226,75212486,2016-08-17T21:38:41Z,src/nvim/ex_cmds.h,"@@ -26,6 +29,26 @@ typedef struct {   list_T *additional_elements;  ///< Additional data left from ShaDa file. } SubReplacementString; ++// Defs for inc_sub functionality++// List of matches on a single line+typedef kvec_t(colnr_T) ColNrVec;","this one you could still remove, as it's part of a bigger struct and not directly addressed, unlike `MatchedLineVec`",X
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/4432,75582354,2016-08-20T17:50:16Z,src/nvim/popupmnu.c,"@@ -68,19 +73,62 @@ void pum_display(pumitem_T *array, int size, int selected)   int above_row = cmdline_row;   int redo_count = 0; +  if (!pum_is_visible) {+    // To keep the code simple, we only allow changing the+    // draw mode when the popup menu is not being displayed+    pum_external = pum_wants_external;+  }+ redo:+  // Pretend the pum is already there to avoid that must_redraw is set when+  // 'cuc' is on.+  pum_is_visible = true;+  validate_cursor_col();+  pum_is_visible = false;++  // anchor position: the start of the completed word+  row = curwin->w_wrow + curwin->w_winrow;+  if (curwin->w_p_rl) {+    col = curwin->w_wincol + curwin->w_width - curwin->w_wcol - 1;+  } else {+    col = curwin->w_wincol + curwin->w_wcol;+  }++  if (pum_external) {+    Array args = ARRAY_DICT_INIT;+    if (array_changed) {+      Array arr = ARRAY_DICT_INIT;+      for (i = 0; i < size; ++i) {+        Array item = ARRAY_DICT_INIT;+        ADD(item, STRING_OBJ(cstr_to_string((char *)array[i].pum_text)));+        ADD(item, STRING_OBJ(cstr_to_string((char *)array[i].pum_kind)));+        ADD(item, STRING_OBJ(cstr_to_string((char *)array[i].pum_extra)));+        ADD(item, STRING_OBJ(cstr_to_string((char *)array[i].pum_info)));+        ADD(arr, ARRAY_OBJ(item));+      }+      ADD(args, ARRAY_OBJ(arr));+      ADD(args, INTEGER_OBJ(selected));+      ADD(args, INTEGER_OBJ(row));+      ADD(args, INTEGER_OBJ(col));+      ui_event(""popupmenu_show"", args);+    } else {+      ADD(args, INTEGER_OBJ(selected));+      ui_event(""popupmenu_select"", args);+    }+    pum_is_visible = true;+    return;+  }+   def_width = PUM_DEF_WIDTH;   max_width = 0;   kind_width = 0;   extra_width = 0;    // Pretend the pum is already there to avoid that must_redraw is set when   // 'cuc' is on.","this pattern is used a couple times, maybe wrap it in a function.",X
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/5232,75582890,2016-08-20T18:33:06Z,src/nvim/edit.c,"@@ -3530,21 +3530,20 @@ int ins_compl_add_tv(typval_T *tv, int dir)   char_u      *(cptext[CPT_COUNT]);    if (tv->v_type == VAR_DICT && tv->vval.v_dict != NULL) {-    word = get_dict_string(tv->vval.v_dict, (char_u *)""word"", FALSE);-    cptext[CPT_ABBR] = get_dict_string(tv->vval.v_dict,-        (char_u *)""abbr"", FALSE);-    cptext[CPT_MENU] = get_dict_string(tv->vval.v_dict,-        (char_u *)""menu"", FALSE);-    cptext[CPT_KIND] = get_dict_string(tv->vval.v_dict,-        (char_u *)""kind"", FALSE);-    cptext[CPT_INFO] = get_dict_string(tv->vval.v_dict,-        (char_u *)""info"", FALSE);-    if (get_dict_string(tv->vval.v_dict, (char_u *)""icase"", FALSE) != NULL)-      icase = get_dict_number(tv->vval.v_dict, (char_u *)""icase"");-    if (get_dict_string(tv->vval.v_dict, (char_u *)""dup"", FALSE) != NULL)-      adup = get_dict_number(tv->vval.v_dict, (char_u *)""dup"");-    if (get_dict_string(tv->vval.v_dict, (char_u *)""empty"", FALSE) != NULL)-      aempty = get_dict_number(tv->vval.v_dict, (char_u *)""empty"");+    word = get_dict_string(tv->vval.v_dict, ""word"", false);+    cptext[CPT_ABBR] = get_dict_string(tv->vval.v_dict, ""abbr"", false);+    cptext[CPT_MENU] = get_dict_string(tv->vval.v_dict, ""menu"", false);+    cptext[CPT_KIND] = get_dict_string(tv->vval.v_dict, ""kind"", false);+    cptext[CPT_INFO] = get_dict_string(tv->vval.v_dict, ""info"", false);+    if (get_dict_string(tv->vval.v_dict, ""icase"", false) != NULL) {","It's because `icase` used to be initialized to `p_ic`: https://github.com/vim/vim/commit/39f05630adc017f00ea551b827fd1d5ef21a0a3aThat was the only case originally, then the pattern just got copied over and over as new cases were added. `get_dict_number` hasn't changed in 12 years.```git checkout @~200 && git log -L :get_dict_number:src/eval.c```---Trivia: looking at the logs I noticed the completion function used to be called `expand_occult`, and ""occult completion"" was the original name for the completion feature: http://vim.1045645.n5.nabble.com/Occult-completion-td1195634.html",X
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/5232,75582903,2016-08-20T18:34:06Z,src/nvim/edit.c,"@@ -3530,21 +3530,20 @@ int ins_compl_add_tv(typval_T *tv, int dir)   char_u      *(cptext[CPT_COUNT]);    if (tv->v_type == VAR_DICT && tv->vval.v_dict != NULL) {-    word = get_dict_string(tv->vval.v_dict, (char_u *)""word"", FALSE);-    cptext[CPT_ABBR] = get_dict_string(tv->vval.v_dict,-        (char_u *)""abbr"", FALSE);-    cptext[CPT_MENU] = get_dict_string(tv->vval.v_dict,-        (char_u *)""menu"", FALSE);-    cptext[CPT_KIND] = get_dict_string(tv->vval.v_dict,-        (char_u *)""kind"", FALSE);-    cptext[CPT_INFO] = get_dict_string(tv->vval.v_dict,-        (char_u *)""info"", FALSE);-    if (get_dict_string(tv->vval.v_dict, (char_u *)""icase"", FALSE) != NULL)-      icase = get_dict_number(tv->vval.v_dict, (char_u *)""icase"");-    if (get_dict_string(tv->vval.v_dict, (char_u *)""dup"", FALSE) != NULL)-      adup = get_dict_number(tv->vval.v_dict, (char_u *)""dup"");-    if (get_dict_string(tv->vval.v_dict, (char_u *)""empty"", FALSE) != NULL)-      aempty = get_dict_number(tv->vval.v_dict, (char_u *)""empty"");+    word = get_dict_string(tv->vval.v_dict, ""word"", false);+    cptext[CPT_ABBR] = get_dict_string(tv->vval.v_dict, ""abbr"", false);+    cptext[CPT_MENU] = get_dict_string(tv->vval.v_dict, ""menu"", false);+    cptext[CPT_KIND] = get_dict_string(tv->vval.v_dict, ""kind"", false);+    cptext[CPT_INFO] = get_dict_string(tv->vval.v_dict, ""info"", false);+    if (get_dict_string(tv->vval.v_dict, ""icase"", false) != NULL) {","Though only `icase = get_dict_number(tv->vval.v_dict, ""icase"")` should be enough. Booleans defaulting to false/zero is the general pattern, if needed a comment could be added.",X
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/4432,75592212,2016-08-21T09:35:17Z,src/nvim/api/ui.c,"@@ -88,21 +91,46 @@ void ui_attach(uint64_t channel_id, Integer width, Integer height,   ui->suspend = remote_ui_suspend;   ui->set_title = remote_ui_set_title;   ui->set_icon = remote_ui_set_icon;+  ui->event = remote_ui_event;++  for (size_t i = 0; i < options.size; i++) {+    ui_set_option(ui, options.items[i].key, options.items[i].value, err);+    if (err->set) {+      xfree(ui);+      xfree(data);",The allocation of `data` could be delayed after setting the options.,X
112971,jamessan,https://api.github.com/repos/neovim/neovim/pulls/5231,75600285,2016-08-21T18:06:16Z,src/nvim/ex_cmds.c,"@@ -3510,19 +3585,26 @@ void do_sub(exarg_T *eap)         /*          * 3. substitute the string.          */-        if (do_count) {-          /* prevent accidentally changing the buffer by a function */+        if (subflags.do_count) {+          // prevent accidentally changing the buffer by a function           save_ma = curbuf->b_p_ma;-          curbuf->b_p_ma = FALSE;+          curbuf->b_p_ma = false;           sandbox++;         }-        /* get length of substitution part */+        // Save flags for recursion.  They can change for e.g.+        // :s/^/\=execute(""s#^#gn"")+        subflags_T subflags_save = subflags;+        // get length of substitution part         sublen = vim_regsub_multi(&regmatch,-            sub_firstlnum - regmatch.startpos[0].lnum,-            sub, sub_firstline, FALSE, p_magic, TRUE);-        if (do_count) {+                                  sub_firstlnum - regmatch.startpos[0].lnum,+                                  sub, sub_firstline, false, p_magic, true);+        // Don't keep flags set by a recursive call+        subflags = subflags_save;","Yup.``` sh$ git clean -fxd src/nvim$ vim src/nvim/ex_cmds.c$ git diffdiff --git i/src/nvim/ex_cmds.c w/src/nvim/ex_cmds.cindex b769199..696bebd 100644--- i/src/nvim/ex_cmds.c+++ w/src/nvim/ex_cmds.c@@ -3599,12 +3599,10 @@ void do_sub(exarg_T *eap)                                   sub_firstlnum - regmatch.startpos[0].lnum,                                   sub, sub_firstline, false, p_magic, true);         // Don't keep flags set by a recursive call-        subflags = subflags_save;+        //subflags = subflags_save;         if (subflags.do_count) {           curbuf->b_p_ma = save_ma;-          if (sandbox > 0) {             sandbox--;-          }           goto skip;         }$ makeninja  -C .depsninja: Entering directory `.deps'[2/2] cd /home/jamessan/src/github.com/neovim/.deps && /usr/bin/cmake -E touch .third-partyninja  -C buildninja: Entering directory `build'[40/43] Building C object src/nvim/CMakeFiles/nvim.dir/ex_cmds.c.o../src/nvim/ex_cmds.c: In function ���do_sub���:../src/nvim/ex_cmds.c:3596:20: warning: unused variable ���subflags_save��� [-Wunused-variable]         subflags_T subflags_save = subflags;                    ^~~~~~~~~~~~~[43/43] cd /home/jamessan/src/github.com/neovim/build/runtime && /usr/bin/cmake -E copy_directory ...n/src/github.com/neovim/build/bin/nvim -u NONE -i NONE -e --headless -c helptags\ ++t\ doc -c quit$ make -C src/nvim/testdir test_regexp_utf8.resmake: Entering directory '/home/jamessan/src/github.com/neovim/src/nvim/testdir'echo 'set $_exitcode = -1\nrun\nif $_exitcode != -1\n  quit\nend' > .gdbinitVIMRUNTIME=../../../runtime; export VIMRUNTIME;  ../../../build/bin/nvim -u unix.vim -U NONE --noplugin -u NONE -S runtest.vim test_regexp_utf8.vimMakefile:178: recipe for target 'test_regexp_utf8.res' failedmake: *** [test_regexp_utf8.res] Error 1make: Leaving directory '/home/jamessan/src/github.com/neovim/src/nvim/testdir'```",X
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/4432,75602743,2016-08-21T20:25:22Z,src/nvim/ui.c,"@@ -156,15 +167,18 @@ void ui_refresh(void)   }    int width = INT_MAX, height = INT_MAX;+  bool pum_external = true;    for (size_t i = 0; i < ui_count; i++) {     UI *ui = uis[i];     width = ui->width < width ? ui->width : width;     height = ui->height < height ? ui->height : height;+    pum_external &= ui->pum_external;","well `&&=` doesn't exist, and as `bool` is semantically 1-bit it works correctly. But if the style guide or otherwise forbids it I will change it.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/5031,75861622,2016-08-23T13:11:31Z,src/nvim/api/buffer.c,"@@ -636,6 +634,297 @@ ArrayOf(Integer, 2) buffer_get_mark(Buffer buffer, String name, Error *err)   return rv; } +/// Returns mark info at the given position or mark index+///+/// @param buffer The buffer handle+/// @param namespace a identifier returned previously with namespace_create+/// @param id [row, col] or mark_id of mark+/// @param[out] err Details of an error that may have occurred+/// @return [mark_id, row, col]+ArrayOf(Object) buffer_mark_index(Buffer buffer, Integer namespace, Object id, Error *err)","They will be confused in either case. It's confusing to have inconsistent convention.  `buf_get_mark_index` is at least a bit more ""discoverable"" since it will appear immediately next to `buf_get_mark` in documentation, code-completion, API function list, etc.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/5031,75862369,2016-08-23T13:15:50Z,src/nvim/api/buffer.c,"@@ -636,6 +634,297 @@ ArrayOf(Integer, 2) buffer_get_mark(Buffer buffer, String name, Error *err)   return rv; } +/// Returns mark info at the given position or mark index+///+/// @param buffer The buffer handle+/// @param namespace a identifier returned previously with namespace_create+/// @param id [row, col] or mark_id of mark+/// @param[out] err Details of an error that may have occurred+/// @return [mark_id, row, col]+ArrayOf(Object) buffer_mark_index(Buffer buffer, Integer namespace, Object id, Error *err)+{+  Array rv = ARRAY_DICT_INIT;+  ExtendedMark *extmark = extmark_from_id_or_pos(buffer, namespace, id, err);++  if (!extmark) {+    return rv;+  }+  ADD(rv, INTEGER_OBJ((Integer)extmark->mark_id));+  ADD(rv, INTEGER_OBJ((Integer)extmark->line->lnum));+  ADD(rv, INTEGER_OBJ((Integer)extmark->col));+  return rv;+}++/// Returns an ordered list of mark info+///+/// @param buffer The buffer handle+/// @param[out] err Details of an error that may have occurred+/// @return [[mark_id, row, col], ...]+ArrayOf(Object) buffer_mark_ids(Buffer buffer, Integer namespace, Error *err)+{+  Array rv = ARRAY_DICT_INIT;+  buf_T *buf = find_buffer_by_handle(buffer, err);++  if (!buf) {+    return rv;+  }++  ExtmarkArray *all_extmarks = extmark_ids(buf, (uint64_t)namespace);+  ExtendedMark *extmark = NULL;+  Array mark = ARRAY_DICT_INIT;+  for (size_t i = 0; i < kv_size(*all_extmarks); i++) {+    mark.size = 0;+    mark.capacity = 0;+    mark.items = 0;+    extmark = kv_A(*all_extmarks, i);+    ADD(mark, INTEGER_OBJ((Integer)extmark->mark_id));+    ADD(mark, INTEGER_OBJ(extmark->line->lnum));+    ADD(mark, INTEGER_OBJ(extmark->col));+    ADD(rv, ARRAY_OBJ(mark));+  }+  return rv;+}++/// Returns mark info of the mark following the given index+/// If there are no following marks returns [-1, -1, -1]+///+/// @param buffer The buffer handle+/// @param namespace a identifier returned previously with namespace_create+/// @param id The mark's id+/// @param[out] err Details of an error that may have occurred+/// @return [id, row, col]+ArrayOf(Integer, 3) buffer_mark_next(Buffer buffer, Integer namespace, Object id, Error *err)+{+  Array rv = ARRAY_DICT_INIT;+  buf_T *buf = find_buffer_by_handle(buffer, err);++  ExtendedMark *extmark = extmark_from_id_or_pos(buffer, namespace, id, err);+  if (!extmark) {+    return rv;+  }++  bool match = 0;+  ExtendedMark *next = extmark_next(buf, (uint64_t)namespace, extmark->line->lnum, extmark->col, match);+  if (!next) {+    ADD(rv, INTEGER_OBJ(-1));+    ADD(rv, INTEGER_OBJ(-1));+    ADD(rv, INTEGER_OBJ(-1));+  } else {+    ADD(rv, INTEGER_OBJ((Integer)next->mark_id));+    ADD(rv, INTEGER_OBJ(next->line->lnum));+    ADD(rv, INTEGER_OBJ(next->col));+  }+  return rv;+}++/// Returns mark info inbetween and including the bounds+/// If there are no following marks returns [-1, -1, -1] // TODO+/// To search untill the end of the buffer do an upper bound of -1 //TODO+///+/// @param buffer The buffer handle+/// @param namespace a identifier returned previously with namespace_create+/// @param lower [row, col] or mark_id of lower bound+/// @param uower [row, col] or mark_id of upper bound+/// @param[out] err Details of an error that may have occurred+/// @return [[mark_id, row, col], ...]+ArrayOf(Object) buffer_mark_nextrange(Buffer buffer, Integer namespace, Object lower, Object upper, Error *err)+{+  Array rv = ARRAY_DICT_INIT;+  buf_T *buf = find_buffer_by_handle(buffer, err);++  ExtendedMark *l_extmark = extmark_from_id_or_pos(buffer, namespace, lower, err);+  ExtendedMark *u_extmark = extmark_from_id_or_pos(buffer, namespace, upper, err);+  if(!l_extmark || !u_extmark) {+    return rv;+  }+  ExtmarkArray *extmarks_in_range = extmark_nextrange(buf, (uint64_t)namespace,+                                           l_extmark->line->lnum, l_extmark->col,+                                           u_extmark->line->lnum, u_extmark->col);++  if (!extmarks_in_range) {+    ADD(rv, INTEGER_OBJ(-9));+    return rv;+  }++  Array mark = ARRAY_DICT_INIT;+  ExtendedMark *extmark;+  for (size_t i = 0; i < kv_size(*extmarks_in_range); i++) {+    mark.size = 0;+    mark.capacity = 0;+    mark.items = 0;+    extmark = kv_A(*extmarks_in_range, i);+    ADD(mark, INTEGER_OBJ( (Integer)extmark->mark_id) );+    ADD(mark, INTEGER_OBJ(extmark->line->lnum));+    ADD(mark, INTEGER_OBJ(extmark->col));+    ADD(rv, ARRAY_OBJ(mark));+  }+  return rv;+}++/// Setup a new namepsace for holding you marks+///+/// @param namespace String name for the namespace+/// @param[out] err Details of an error that may have occurred+/// @return integer id to be used with future mark_ calls, or 0 if name exists+Integer buffer_mark_ns_init(String namespace, Error *err)+{+  uint64_t ns_id = extmark_ns_create(namespace.data);+  if (!ns_id) {+    api_set_error(err, Validation, _(""Namespace already exists""));+    return 0;+  }+  return ns_id;+}++/// Returns a list of mark namespaces in nvim+///+/// @param[out] err Details of an error that may have occurred+/// @return [[string name, int id], ...]+ArrayOf(Object) buffer_mark_ns_ids(Error *err)+{+  Array rv = ARRAY_DICT_INIT;+  Array ns_array = ARRAY_DICT_INIT;++  /* TODO can delete? */+  if (!NAMESPACES) {+    return rv;+  }++  cstr_t key;+  uint64_t value;+  map_foreach(NAMESPACES, key, value, {+    ns_array.size = 0;+    ns_array.capacity = 0;+    ns_array.items = 0;+    ADD(ns_array, STRING_OBJ(cstr_to_string(key)));+    ADD(ns_array, INTEGER_OBJ(value));+    ADD(rv, ARRAY_OBJ(ns_array));+  });+  return rv;+}+++/// Returns mark info of the mark preceding the given index+/// If there are no previous marks returns [-1, -1, -1] // TODO","> some viml functions return 0 to mean everything is okWhich VimL functions? In VimL `0` means ""false"".In syscalls `0` often means ""OK"", but we are designing a higher-level API here. If there is no _technical_ reason to let `0` have some other semantics (e.g. 0-indexed list), we should probably default to letting it mean ""nil"".",X
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/5031,75864997,2016-08-23T13:30:25Z,src/nvim/api/buffer.c,"@@ -636,6 +634,297 @@ ArrayOf(Integer, 2) buffer_get_mark(Buffer buffer, String name, Error *err)   return rv; } +/// Returns mark info at the given position or mark index+///+/// @param buffer The buffer handle+/// @param namespace a identifier returned previously with namespace_create+/// @param id [row, col] or mark_id of mark+/// @param[out] err Details of an error that may have occurred+/// @return [mark_id, row, col]+ArrayOf(Object) buffer_mark_index(Buffer buffer, Integer namespace, Object id, Error *err)+{+  Array rv = ARRAY_DICT_INIT;+  ExtendedMark *extmark = extmark_from_id_or_pos(buffer, namespace, id, err);++  if (!extmark) {+    return rv;+  }+  ADD(rv, INTEGER_OBJ((Integer)extmark->mark_id));+  ADD(rv, INTEGER_OBJ((Integer)extmark->line->lnum));+  ADD(rv, INTEGER_OBJ((Integer)extmark->col));+  return rv;+}++/// Returns an ordered list of mark info+///+/// @param buffer The buffer handle+/// @param[out] err Details of an error that may have occurred+/// @return [[mark_id, row, col], ...]+ArrayOf(Object) buffer_mark_ids(Buffer buffer, Integer namespace, Error *err)+{+  Array rv = ARRAY_DICT_INIT;+  buf_T *buf = find_buffer_by_handle(buffer, err);++  if (!buf) {+    return rv;+  }++  ExtmarkArray *all_extmarks = extmark_ids(buf, (uint64_t)namespace);+  ExtendedMark *extmark = NULL;+  Array mark = ARRAY_DICT_INIT;+  for (size_t i = 0; i < kv_size(*all_extmarks); i++) {+    mark.size = 0;+    mark.capacity = 0;+    mark.items = 0;+    extmark = kv_A(*all_extmarks, i);+    ADD(mark, INTEGER_OBJ((Integer)extmark->mark_id));+    ADD(mark, INTEGER_OBJ(extmark->line->lnum));+    ADD(mark, INTEGER_OBJ(extmark->col));+    ADD(rv, ARRAY_OBJ(mark));+  }+  return rv;+}++/// Returns mark info of the mark following the given index+/// If there are no following marks returns [-1, -1, -1]+///+/// @param buffer The buffer handle+/// @param namespace a identifier returned previously with namespace_create+/// @param id The mark's id+/// @param[out] err Details of an error that may have occurred+/// @return [id, row, col]+ArrayOf(Integer, 3) buffer_mark_next(Buffer buffer, Integer namespace, Object id, Error *err)+{+  Array rv = ARRAY_DICT_INIT;+  buf_T *buf = find_buffer_by_handle(buffer, err);++  ExtendedMark *extmark = extmark_from_id_or_pos(buffer, namespace, id, err);+  if (!extmark) {+    return rv;+  }++  bool match = 0;+  ExtendedMark *next = extmark_next(buf, (uint64_t)namespace, extmark->line->lnum, extmark->col, match);+  if (!next) {+    ADD(rv, INTEGER_OBJ(-1));+    ADD(rv, INTEGER_OBJ(-1));+    ADD(rv, INTEGER_OBJ(-1));+  } else {+    ADD(rv, INTEGER_OBJ((Integer)next->mark_id));+    ADD(rv, INTEGER_OBJ(next->line->lnum));+    ADD(rv, INTEGER_OBJ(next->col));+  }+  return rv;+}++/// Returns mark info inbetween and including the bounds+/// If there are no following marks returns [-1, -1, -1] // TODO+/// To search untill the end of the buffer do an upper bound of -1 //TODO+///+/// @param buffer The buffer handle+/// @param namespace a identifier returned previously with namespace_create+/// @param lower [row, col] or mark_id of lower bound+/// @param uower [row, col] or mark_id of upper bound+/// @param[out] err Details of an error that may have occurred+/// @return [[mark_id, row, col], ...]+ArrayOf(Object) buffer_mark_nextrange(Buffer buffer, Integer namespace, Object lower, Object upper, Error *err)+{+  Array rv = ARRAY_DICT_INIT;+  buf_T *buf = find_buffer_by_handle(buffer, err);++  ExtendedMark *l_extmark = extmark_from_id_or_pos(buffer, namespace, lower, err);+  ExtendedMark *u_extmark = extmark_from_id_or_pos(buffer, namespace, upper, err);+  if(!l_extmark || !u_extmark) {+    return rv;+  }+  ExtmarkArray *extmarks_in_range = extmark_nextrange(buf, (uint64_t)namespace,+                                           l_extmark->line->lnum, l_extmark->col,+                                           u_extmark->line->lnum, u_extmark->col);++  if (!extmarks_in_range) {+    ADD(rv, INTEGER_OBJ(-9));+    return rv;+  }++  Array mark = ARRAY_DICT_INIT;+  ExtendedMark *extmark;+  for (size_t i = 0; i < kv_size(*extmarks_in_range); i++) {+    mark.size = 0;+    mark.capacity = 0;+    mark.items = 0;+    extmark = kv_A(*extmarks_in_range, i);+    ADD(mark, INTEGER_OBJ( (Integer)extmark->mark_id) );+    ADD(mark, INTEGER_OBJ(extmark->line->lnum));+    ADD(mark, INTEGER_OBJ(extmark->col));+    ADD(rv, ARRAY_OBJ(mark));+  }+  return rv;+}++/// Setup a new namepsace for holding you marks+///+/// @param namespace String name for the namespace+/// @param[out] err Details of an error that may have occurred+/// @return integer id to be used with future mark_ calls, or 0 if name exists+Integer buffer_mark_ns_init(String namespace, Error *err)+{+  uint64_t ns_id = extmark_ns_create(namespace.data);+  if (!ns_id) {+    api_set_error(err, Validation, _(""Namespace already exists""));+    return 0;+  }+  return ns_id;+}++/// Returns a list of mark namespaces in nvim+///+/// @param[out] err Details of an error that may have occurred+/// @return [[string name, int id], ...]+ArrayOf(Object) buffer_mark_ns_ids(Error *err)+{+  Array rv = ARRAY_DICT_INIT;+  Array ns_array = ARRAY_DICT_INIT;++  /* TODO can delete? */+  if (!NAMESPACES) {+    return rv;+  }++  cstr_t key;+  uint64_t value;+  map_foreach(NAMESPACES, key, value, {+    ns_array.size = 0;+    ns_array.capacity = 0;+    ns_array.items = 0;+    ADD(ns_array, STRING_OBJ(cstr_to_string(key)));+    ADD(ns_array, INTEGER_OBJ(value));+    ADD(rv, ARRAY_OBJ(ns_array));+  });+  return rv;+}+++/// Returns mark info of the mark preceding the given index+/// If there are no previous marks returns [-1, -1, -1] // TODO","as long as mark ids are unsigned then the first value should be -1 to indicate missing. But  I still think we should consider only have `buffer_mark_range(ns, lower, upper, which)`  wherewhich = 0 : return all marks in rangewhich = +n: return the n first marks in rangewhich = -n: return the n last marks in rangeso mark_prev i.e. reduces to `mark_range(namespace, [0,0], id, -1)` and returns a list with either 1 or 0 items.",X
6135075,timeyyy,https://api.github.com/repos/neovim/neovim/pulls/5031,75958575,2016-08-23T21:52:24Z,src/nvim/api/buffer.c,"@@ -636,6 +634,297 @@ ArrayOf(Integer, 2) buffer_get_mark(Buffer buffer, String name, Error *err)   return rv; } +/// Returns mark info at the given position or mark index+///+/// @param buffer The buffer handle+/// @param namespace a identifier returned previously with namespace_create+/// @param id [row, col] or mark_id of mark+/// @param[out] err Details of an error that may have occurred+/// @return [mark_id, row, col]+ArrayOf(Object) buffer_mark_index(Buffer buffer, Integer namespace, Object id, Error *err)","beforewith `mark_set`, `mark_xyz`, I can hit tab and see a list of all functions that are mark_but now that it's `set_mark` etc that's not possible.It's nothing really i'm just grumbling :)",X
715238,equalsraf,https://api.github.com/repos/neovim/neovim/pulls/3303,76155354,2016-08-24T23:01:22Z,src/nvim/os/env.c,"@@ -557,6 +557,27 @@ char *vim_getenv(const char *name)     if (p_hf != NULL && vim_strchr(p_hf, '$') == NULL) {       vim_path = (char *)p_hf;     }++#ifdef WIN32+    // Find runtime path relative to the nvim binary i.e. ../share/runtime+    char exe_name[MAXPATHL];+    char abs_runtime_path[MAXPATHL];+    if (vim_path == NULL) {+      if (os_exepath(exe_name, MAXPATHL) == 0) {+        // Remove trailing bin/nvim.exe",But it is actually removing the last two path components (presumably bin/nvim.exe).,X
10180857,nhooyr,https://api.github.com/repos/neovim/neovim/pulls/5169,76361506,2016-08-26T04:00:54Z,runtime/ftplugin/qf.vim,"@@ -14,3 +14,10 @@ let b:undo_ftplugin = ""set stl<""  "" Display the command that produced the list in the quickfix window: setlocal stl=%t%{exists('w:quickfix_title')?\ '\ '.w:quickfix_title\ :\ ''}\ %=%-15(%l,%c%V%)\ %P++autocmd Syntax <buffer>+      \ if exists('w:quickfix_title') && w:quickfix_title =~# '^:\%(Man\|Help\) TOC$' |+      \   syntax match qfHideTOC ""^.*| "" conceal containedin=ALL |+      \   setlocal concealcursor=nvi |",Why not set this to `nvic`? Doesn't make sense for the file name to pop up if I search the list.,X
116470,jbradaric,https://api.github.com/repos/neovim/neovim/pulls/5257,76532180,2016-08-28T13:44:42Z,src/nvim/eval.c,"@@ -8018,26 +8019,47 @@ static void f_bufnr(typval_T *argvars, typval_T *rettv)     rettv->vval.v_number = -1; } -/*- * ""bufwinnr(nr)"" function- */-static void f_bufwinnr(typval_T *argvars, typval_T *rettv)+static void buf_win_common(typval_T *argvars, typval_T *rettv, bool get_nr) {-  (void)get_tv_number(&argvars[0]);         /* issue errmsg if type error */-  ++emsg_off;+  int error = false;+  (void)get_tv_number_chk(&argvars[0], &error);  // issue errmsg if type error+  if (error) {  // the argument has an invalid type+    rettv->vval.v_number = -1;+    return;+  }++  emsg_off++;","@oni-link An error will be shown if there are no matches or if there are multiple matches for the buffer pattern. For example, if we have buffers `foo1.txt` and `foo2.txt`, `bufwinid('foo')` will show an error. The error is shown in the `buflist_findpat` function.All this was in the original code, but it might be useful to show these errors to the user, the same as when the function receives an argument of the wrong type.",
111942,tweekmonster,https://api.github.com/repos/neovim/neovim/pulls/5169,76533460,2016-08-28T14:59:29Z,runtime/autoload/man.vim,"@@ -97,6 +97,23 @@ function! s:read_page(sect, name) abort     silent keepjumps 1delete _   endwhile   setlocal filetype=man+  call man#create_toc()+endfunction++function! man#create_toc() abort+  if !exists('b:man_toc')+    "" Cache the TOC since user might switch in and out between the man pages.+    let b:man_toc = []+    for lnum in range(1, line('$'))+      let text = getline(lnum)+      if text =~# '^\%(\%(\S.*\)\=\S\|\%1l.*\| \{3\}\S.*\)$'+        let text = substitute(getline(lnum), '\s\+', ' ', 'g')","There were cases of right-aligned text or ""table"" column headers on some lines.  It would make the horizontal scrolling long.",
10180857,nhooyr,https://api.github.com/repos/neovim/neovim/pulls/5169,76533571,2016-08-28T15:06:45Z,runtime/autoload/man.vim,"@@ -97,6 +97,23 @@ function! s:read_page(sect, name) abort     silent keepjumps 1delete _   endwhile   setlocal filetype=man+  call man#create_toc()+endfunction++function! man#create_toc() abort+  if !exists('b:man_toc')+    "" Cache the TOC since user might switch in and out between the man pages.+    let b:man_toc = []+    for lnum in range(1, line('$'))+      let text = getline(lnum)+      if text =~# '^\%(\%(\S.*\)\=\S\|\%1l.*\| \{3\}\S.*\)$'+        let text = substitute(getline(lnum), '\s\+', ' ', 'g')","~~IIRC, whitespace is trimmed in the location list automatically so that isn't necessary.~~I understand now.Oo, if you ignore the title and last line, are there any other right aligned headers?",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/5249,76657612,2016-08-29T18:15:23Z,runtime/autoload/man.vim,"@@ -121,21 +122,33 @@ function! s:extract_sect_and_name_ref(ref) abort   return [tolower(split(left[1], ')')[0]), left[0]] endfunction -function! s:verify_exists(sect, name) abort-  let path = system(s:man_cmd.' '.s:man_find_arg.' '.s:man_args(a:sect, a:name))-  if path !~# '^\/'-    if empty(a:sect)-      throw 'no manual entry for '.a:name-    endif+function! s:get_path(sect, name) abort+  if empty(a:sect)     let path = system(s:man_cmd.' '.s:man_find_arg.' '.shellescape(a:name))     if path !~# '^\/'-      throw 'no manual entry for '.a:name.'('.a:sect.') or '.a:name+      throw 'no manual entry for '.a:name     endif+    return path   endif-  if a:name =~# '\/'-    "" We do not need to extract the section/name from the path if the name is-    "" just a path.-    return ['', a:name, path]+  "" The '-s' flag is very useful.+  "" We do not need to worry about stuff like 'printf(echo)'+  "" (two manpages would be interpreted by man without -s)+  "" We do not need to check if the sect starts with '-'+  "" Lastly, the 3pcap section on macOS doesn't work without -s+  return system(s:man_cmd.' '.s:man_find_arg.' -s '.shellescape(a:sect).' '.shellescape(a:name))","`shellescape()` wouldn't be necessary if a list were passed to `system()` instead of a string. `s:man_cmd` could be stored as a list instead of a string, then the list can be `extend()`'d here.",X
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/5249,76659849,2016-08-29T18:26:27Z,runtime/doc/filetype.txt,"@@ -547,6 +549,10 @@ q                         :quit if invoked as $MANPAGER, otherwise :close. Variables: *g:no_man_maps*             Do not create mappings in manpage buffers. *g:ft_man_folding_enable*   Fold manpages with foldmethod=indent foldnestmax=1.+*b:man_default_sections*    A comma seperated list of default sections to priortize+                          for the current buffer.","typo; also I recommend omitting articles (a, the) unless it greatly increases clarity. They're usually just noise in these types of annotated lists.```Comma-separated list of preferred sections.```""current buffer"" never needs mention for a `b:` variable.",X
10180857,nhooyr,https://api.github.com/repos/neovim/neovim/pulls/5249,76674882,2016-08-29T19:53:29Z,runtime/autoload/man.vim,"@@ -121,21 +122,33 @@ function! s:extract_sect_and_name_ref(ref) abort   return [tolower(split(left[1], ')')[0]), left[0]] endfunction -function! s:verify_exists(sect, name) abort-  let path = system(s:man_cmd.' '.s:man_find_arg.' '.s:man_args(a:sect, a:name))-  if path !~# '^\/'-    if empty(a:sect)-      throw 'no manual entry for '.a:name-    endif+function! s:get_path(sect, name) abort+  if empty(a:sect)     let path = system(s:man_cmd.' '.s:man_find_arg.' '.shellescape(a:name))     if path !~# '^\/'-      throw 'no manual entry for '.a:name.'('.a:sect.') or '.a:name+      throw 'no manual entry for '.a:name     endif+    return path   endif-  if a:name =~# '\/'-    "" We do not need to extract the section/name from the path if the name is-    "" just a path.-    return ['', a:name, path]+  "" The '-s' flag is very useful.+  "" We do not need to worry about stuff like 'printf(echo)'+  "" (two manpages would be interpreted by man without -s)+  "" We do not need to check if the sect starts with '-'+  "" Lastly, the 3pcap section on macOS doesn't work without -s+  return system(s:man_cmd.' '.s:man_find_arg.' -s '.shellescape(a:sect).' '.shellescape(a:name))",How would I redirect stderr to /dev/null if I pass a list?,
112971,jamessan,https://api.github.com/repos/neovim/neovim/pulls/5249,76720324,2016-08-30T02:02:35Z,runtime/autoload/man.vim,"@@ -54,44 +54,43 @@ function! man#open_page(count, count1, mods, ...) abort   call s:push_tag()   let bufname = 'man://'.name.(empty(sect)?'':'('.sect.')')   if a:mods !~# 'tab' && s:find_man()-    if s:manwidth() ==# getbufvar(bufname, 'manwidth')-      silent execute 'buf' bufname-      call man#set_window_local_options()-      keepjumps 1-      return-    endif     noautocmd execute 'edit' bufname-  elseif s:manwidth() ==# getbufvar(bufname, 'manwidth')-    execute a:mods 'split' bufname-    call man#set_window_local_options()-    keepjumps 1-    return   else     noautocmd execute a:mods 'split' bufname   endif+  let b:man_sect = sect   call s:read_page(path) endfunction  function! man#read_page(ref) abort   try-    let [sect, name] = s:extract_sect_and_name_ref(a:ref)-    "" The third element is the path.-    call s:read_page(s:verify_exists(sect, name)[2])+    let [sect, name] = man#extract_sect_and_name_ref(a:ref)+    let [b:man_sect, name, path] = s:verify_exists(sect, name)   catch-    call s:error(v:exception)+    "" call to s:error() is unnecessary     return   endtry+  call s:read_page(path) endfunction  function! s:read_page(path) abort   setlocal modifiable   setlocal noreadonly   keepjumps %delete _-  let b:manwidth = s:manwidth()   "" Ensure Vim is not recursively invoked (man-db does this)   "" by forcing man to use cat as the pager.   "" More info here http://comments.gmane.org/gmane.editors.vim.devel/29085-  silent execute 'read !env MANPAGER=cat MANWIDTH='.b:manwidth s:man_cmd a:path+  let cmd = 'read !env MANPAGER=cat'+  if empty($MANWIDTH)+    "" Do not set $MANWIDTH globally.+    silent execute cmd 'MANWIDTH='.winwidth(0) s:man_cmd a:path",Any logical element of a command-line which may have characters that need escaping should use `shellescape`.  Think of it in terms of building up an argv list.  You need to use `shellescape` to ensure that something is treated as a single element of that argv list.,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/5249,77440104,2016-09-03T17:26:03Z,runtime/autoload/man.vim,"@@ -54,44 +54,43 @@ function! man#open_page(count, count1, mods, ...) abort   call s:push_tag()   let bufname = 'man://'.name.(empty(sect)?'':'('.sect.')')   if a:mods !~# 'tab' && s:find_man()-    if s:manwidth() ==# getbufvar(bufname, 'manwidth')-      silent execute 'buf' bufname-      call man#set_window_local_options()-      keepjumps 1-      return-    endif     noautocmd execute 'edit' bufname-  elseif s:manwidth() ==# getbufvar(bufname, 'manwidth')-    execute a:mods 'split' bufname-    call man#set_window_local_options()-    keepjumps 1-    return   else     noautocmd execute a:mods 'split' bufname   endif+  let b:man_sect = sect   call s:read_page(path) endfunction  function! man#read_page(ref) abort   try-    let [sect, name] = s:extract_sect_and_name_ref(a:ref)-    "" The third element is the path.-    call s:read_page(s:verify_exists(sect, name)[2])+    let [sect, name] = man#extract_sect_and_name_ref(a:ref)+    let [b:man_sect, name, path] = s:verify_exists(sect, name)   catch-    call s:error(v:exception)+    "" call to s:error() is unnecessary     return   endtry+  call s:read_page(path) endfunction  function! s:read_page(path) abort   setlocal modifiable   setlocal noreadonly   keepjumps %delete _-  let b:manwidth = s:manwidth()   "" Ensure Vim is not recursively invoked (man-db does this)   "" by forcing man to use cat as the pager.   "" More info here http://comments.gmane.org/gmane.editors.vim.devel/29085-  silent execute 'read !env MANPAGER=cat MANWIDTH='.b:manwidth s:man_cmd a:path+  let cmd = 'read !env MANPAGER=cat'","By using `system()` instead of using `:read !...` here, I was able to get rid of the big redraw that happens every time a manpage is loaded. Was there a reason system() was not used here, or that's just how it always was?",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/5289,77440697,2016-09-03T18:05:27Z,src/nvim/ex_cmds_defs.h,"@@ -126,39 +126,36 @@ struct exarg {   struct condstack *cstack;     ///< condition stack for "":if"" etc. }; -#define FORCE_BIN 1             /* "":edit ++bin file"" */-#define FORCE_NOBIN 2           /* "":edit ++nobin file"" */--/* Values for ""flags"" */-#define EXFLAG_LIST     0x01    /* 'l': list */-#define EXFLAG_NR       0x02    /* '#': number */-#define EXFLAG_PRINT    0x04    /* 'p': print */--/*- * used for completion on the command line- */-typedef struct expand {-  int xp_context;                       /* type of expansion */-  char_u      *xp_pattern;              /* start of item to expand */-  int xp_pattern_len;                   /* bytes in xp_pattern before cursor */-  char_u      *xp_arg;                  /* completion function */-  int xp_scriptID;                      /* SID for completion function */-  int xp_backslash;                     /* one of the XP_BS_ values */+#define FORCE_BIN 1             // "":edit ++bin file""+#define FORCE_NOBIN 2           // "":edit ++nobin file""++// Values for ""flags""+#define EXFLAG_LIST     0x01    // 'l': list+#define EXFLAG_NR       0x02    // '#': number+#define EXFLAG_PRINT    0x04    // 'p': print++// used for completion on the command line+struct expand {+  int xp_context;      // type of expansion+  char_u *xp_pattern;  // start of item to expand+  int xp_pattern_len;  // bytes in xp_pattern before cursor+  char_u *xp_arg;      // completion function+  int xp_scriptID;     // SID for completion function+  int xp_backslash;    // one of the XP_BS_ values","just a small suggestion: typically it's good to leave some extra whitespace in case a new, longer-named member is added here, to avoid having to re-align all of the comments. E.g., these comments could be aligned with line 135 above.",
849178,kranki,https://api.github.com/repos/neovim/neovim/pulls/5289,77447938,2016-09-04T07:24:14Z,test/unit/option_spec.lua,"@@ -0,0 +1,61 @@+local helpers = require(""test.unit.helpers"")++local to_cstr = helpers.to_cstr+local eq      = helpers.eq++local option = helpers.cimport(""./src/nvim/option.h"")+local globals = helpers.cimport(""./src/nvim/globals.h"")++local check_ff_value = function(ff)+  return option.check_ff_value(to_cstr(ff))+end++local get_sts_value = function()+  return option.get_sts_value()+end++describe('check_ff_value', function()++  it('views empty string as valid', function()+    eq(1, check_ff_value(""""))+  end)++  it('views ""unix"" as valid', function()+    eq(1, check_ff_value(""unix""))+  end)++  it('views ""dos"" as valid', function()+    eq(1, check_ff_value(""dos""))+  end)++  it('views ""mac"" as valid', function()+    eq(1, check_ff_value(""mac""))+  end)++  it('views ""foo"" as invalid', function()+    eq(0, check_ff_value(""foo""))+  end)+end)++describe('get_sts_value', function()+  it([[returns 'softtabstop' when it is non-negative]], function()+    globals.curbuf.b_p_sts = 5+    eq(5, get_sts_value())+    globals.curbuf.b_p_sts = 0+    eq(0, get_sts_value())+  end)++  it([[returns ""effective shiftwidth"" when 'softtabstop' is negative]], function()+    local shiftwidth = 2+    globals.curbuf.b_p_sw = shiftwidth+    local tabstop = 5+    globals.curbuf.b_p_ts = tabstop++    globals.curbuf.b_p_sts = -2+    eq(shiftwidth, get_sts_value())++    shiftwidth = 0+    globals.curbuf.b_p_sw = shiftwidth+    eq(tabstop, get_sts_value())+  end)",I think  changing to `expected_shiftwidth` and `expected_tabstop` would add very little here. The reader already expects the first parameter of `eq` to be the expected value and second the actual.,
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/5119,77448706,2016-09-04T08:24:44Z,src/nvim/CMakeLists.txt,"@@ -199,7 +200,7 @@ add_custom_command(OUTPUT ${GENERATED_UNICODE_TABLES} )  add_custom_command(OUTPUT ${GENERATED_API_DISPATCH} ${API_METADATA}-    COMMAND ${LUA_PRG} ${DISPATCH_GENERATOR} ${PROJECT_SOURCE_DIR}/scripts ${API_HEADERS} ${GENERATED_API_DISPATCH} ${API_METADATA}+  COMMAND ${LUA_PRG} ${DISPATCH_GENERATOR} ${API_SOURCE_DIR} ${API_HEADERS} ${GENERATED_API_DISPATCH} ${API_METADATA}","Seems unnecessary to have a variable for every subdir, no? if we should follow the existing pattern`set(DEPRECATED_DISPATCH_FILE ${PROJECT_SOURCE_DIR}/src/nvim/api/deprecated_dispatch.lua` but when thinking on it why not have `set(NVIM_SOURCE_DIR ${PROJECT_SOURCE_DIR}/src/nvim)` and then write `${NVIM_SOURCE_DIR}/api/deprecated_dispatch.lua`, `${NVIM_SOURCE_DIR}/ex_cmds.lua` etc in the build rules?",X
339435,fwalch,https://api.github.com/repos/neovim/neovim/pulls/5278,77452918,2016-09-04T13:54:09Z,src/nvim/os/stdpaths.c,"@@ -8,28 +8,35 @@  /// Names of the environment variables, mapped to XDGVarType values static const char *xdg_env_vars[] = {+#ifdef WIN32+  [kXDGConfigHome] = ""LOCALAPPDATA"",+  [kXDGDataHome] = ""LOCALAPPDATA"",+  [kXDGCacheHome] = ""TEMP"",+  [kXDGRuntimeDir] = NULL,+  [kXDGConfigDirs] = NULL,+  [kXDGDataDirs] = NULL,","Do we need another fallback on `~\\Appdata\\Local`, or can the Windows fallback just be `os_getenv('$LOCALAPPDATA')`?",X
339435,fwalch,https://api.github.com/repos/neovim/neovim/pulls/5119,77454837,2016-09-04T16:01:46Z,src/nvim/CMakeLists.txt,"@@ -199,7 +200,7 @@ add_custom_command(OUTPUT ${GENERATED_UNICODE_TABLES} )  add_custom_command(OUTPUT ${GENERATED_API_DISPATCH} ${API_METADATA}-    COMMAND ${LUA_PRG} ${DISPATCH_GENERATOR} ${PROJECT_SOURCE_DIR}/scripts ${API_HEADERS} ${GENERATED_API_DISPATCH} ${API_METADATA}+  COMMAND ${LUA_PRG} ${DISPATCH_GENERATOR} ${API_SOURCE_DIR} ${API_HEADERS} ${GENERATED_API_DISPATCH} ${API_METADATA}",From http://www.cmake.org/Wiki/CMake_Useful_Variables:> CMAKE_CURRENT_LIST_DIR >     (since 2.8.3) this is the directory of the listfile currently being processed.,
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/5292,77460231,2016-09-04T23:07:21Z,test/functional/ex_cmds/cd_spec.lua,"@@ -269,3 +269,25 @@ for _, cmd in ipairs {'getcwd', 'haslocaldir'} do   end) end +-- Test what happens when a directory does not exist+describe('Printing the working directory when it does not exist', function ()+  local temp_dir = 'Xtest-functional-ex_cmds-cd_spec.temp'+  before_each(function()+    clear()+    lfs.mkdir(temp_dir)+  end)++  after_each(function()+    lfs.rmdir(temp_dir)+  end)++  it('returns an empty string', function()+    execute('cd ' .. temp_dir)+    helpers.wait()+    lfs.rmdir(temp_dir)+    local working_dir = cwd()+    eq('', working_dir)","I usually write such things as something like `eq(0, exc_exec('let wd = getcwd()'))`: this makes it obvious that I check for absence of exceptions and not rely on implementation details of various helper functions.",X
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/5295,77460892,2016-09-04T23:50:08Z,runtime/autoload/health/nvim.vim,"@@ -414,15 +413,20 @@ function! s:check_ruby() abort     let prog_vers = 'not found'     call health#report_error('Missing Neovim RubyGem', suggestions)   else+    silent let latest_gem   = systemlist(""gem list -ra '^neovim$' | "" .+          \ ""awk -F'[()]' '{print $2}' | "" .+          \ 'cut -d, -f1')[0]","If no results are found (e.g. no internet connection), `[0]` will cause 'index out of range' error. This avoids it:``` vimlet latest_gem = get(systemlist(...), 0, 'unknown')```",X
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/5119,77462552,2016-09-05T01:09:37Z,src/nvim/CMakeLists.txt,"@@ -339,4 +345,81 @@ add_library(nvim-test MODULE EXCLUDE_FROM_ALL ${NEOVIM_GENERATED_SOURCES} target_link_libraries(nvim-test ${NVIM_LINK_LIBRARIES}) set_property(TARGET nvim-test APPEND_STRING PROPERTY COMPILE_FLAGS -DUNIT_TESTING) +# Helper targets that verify that specific headers can be included alone (i.e.+# do not depend on other includes)+set(HEADER_CHECK_FILES)+set(NO_SINGLE_CHECK_HEADERS",consider renaming this to `HEADER_CHECK_SKIPPED` for parallel form with `HEADER_CHECK_TARGETS` et al.,
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/2905,77537128,2016-09-05T15:31:41Z,src/nvim/mbyte.c,"@@ -600,10 +358,7 @@ int bomb_size(void)   if (curbuf->b_p_bomb && !curbuf->b_p_bin) {     if (*curbuf->b_p_fenc == NUL) {       if (enc_utf8) {","If `enc_utf8` is always true, this condition can be removed.",X
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/2905,77539431,2016-09-05T15:56:10Z,src/nvim/mbyte.c,"@@ -2461,12 +1967,9 @@ int mb_fix_col(int col, int row)   col = check_col(col);   row = check_row(row);   if (has_mbyte && ScreenLines != NULL && col > 0-      && ((enc_dbcs-          && ScreenLines[LineOffset[row] + col] != NUL-          && dbcs_screen_head_off(ScreenLines + LineOffset[row],-            ScreenLines + LineOffset[row] + col))-        || (enc_utf8 && ScreenLines[LineOffset[row] + col] == 0)))+      && (enc_utf8 && ScreenLines[LineOffset[row] + col] == 0)) {",This condition could be further simplified (`has_byte` and `enc_utf8` are `true`).,X
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/5280,77562562,2016-09-06T01:23:30Z,test/functional/shell/viml_system_spec.lua,"@@ -195,15 +231,10 @@ describe('system()', function()       end)     end   end)--  describe('command passed as a list', function()-    it('does not execute &shell', function()-      eq('* $NOTHING ~/file',-         eval(""system(['echo', '-n', '*', '$NOTHING', '~/file'])""))-    end)-  end)","Ha, I forgot we supported this (doesn't seem to be documented). It's useful, like a synchronous `jobstart()`. Though I guess it violates the analogy of `system()` from C stdlib.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/5308,77783293,2016-09-07T08:54:49Z,test/unit/strings_spec.lua,"@@ -98,3 +98,23 @@ describe('vim_strnsave_unquoted()', function()     eq('/Program\\nFiles/sh', vim_strnsave_unquoted('/Program""\\n""Files/sh'))   end) end)++describe(""reverse_text"", function()+  local reverse_text = function(str)+    return helpers.internalize(strings.reverse_text(to_cstr(str)))+  end++  it(""handles empty string"", function()+    eq("""", reverse_text(""""))+  end)++  it(""handles simple cases"", function()+    eq(""a"", reverse_text(""a""))+    eq(""ba"", reverse_text(""ab""))+  end)++  it(""handles multibyte characters"", function()+    eq(""b��"", reverse_text(""��b""))+    eq(""Y��t��n y��"", reverse_text(""��y n��t��Y""))+  end)","I would also try with combining chars (that don't exists precomposed), like p���� , maybe written as ""aap\xcc\x9a\xcd\x93bb"" as some terminals won't render it correctly.Also some string with invalid/incomplete utf like ""ab\xe0"", it might be ""garbage in/garbage out"" (or not even reversible, no pun intended), but it shouldn't be ""garbage in/nvim crashes"" (AFAIK `mb_ptr2len` already handles this as sanely as possible, but more tests for it wouldn't hurt)",
849178,kranki,https://api.github.com/repos/neovim/neovim/pulls/2905,77793350,2016-09-07T09:58:21Z,src/nvim/globals.h,"@@ -778,44 +778,15 @@ EXTERN int vr_lines_changed INIT(= 0);      /* #Lines changed by ""gR"" so far */ # define DBCS_2BYTE     1       /* 2byte- */ # define DBCS_DEBUG     -1 -EXTERN int enc_dbcs INIT(= 0);                  /* One of DBCS_xxx values if-                                                   DBCS encoding */-EXTERN int enc_unicode INIT(= 0);       /* 2: UCS-2 or UTF-16, 4: UCS-4 */-EXTERN bool enc_utf8 INIT(= false);             /* UTF-8 encoded Unicode */-EXTERN int enc_latin1like INIT(= TRUE);         /* 'encoding' is latin1 comp. */-EXTERN int has_mbyte INIT(= 0);                 /* any multi-byte encoding */+EXTERN int enc_dbcs INIT(= 0);       ///< Deprecated: always zero+EXTERN bool enc_utf8 INIT(= true);   ///< UTF-8 encoded Unicode (always true)+EXTERN bool has_mbyte INIT(= true);  ///< Any multi-byte encoding (always true)",Could these be `const`. Maybe some tool could then point dead code. At least flexelint (PC-lint) can but it isn't free.,
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/2905,77797701,2016-09-07T10:33:31Z,src/nvim/globals.h,"@@ -778,44 +778,15 @@ EXTERN int vr_lines_changed INIT(= 0);      /* #Lines changed by ""gR"" so far */ # define DBCS_2BYTE     1       /* 2byte- */ # define DBCS_DEBUG     -1 -EXTERN int enc_dbcs INIT(= 0);                  /* One of DBCS_xxx values if-                                                   DBCS encoding */-EXTERN int enc_unicode INIT(= 0);       /* 2: UCS-2 or UTF-16, 4: UCS-4 */-EXTERN bool enc_utf8 INIT(= false);             /* UTF-8 encoded Unicode */-EXTERN int enc_latin1like INIT(= TRUE);         /* 'encoding' is latin1 comp. */-EXTERN int has_mbyte INIT(= 0);                 /* any multi-byte encoding */+EXTERN int enc_dbcs INIT(= 0);       ///< Deprecated: always zero+EXTERN bool enc_utf8 INIT(= true);   ///< UTF-8 encoded Unicode (always true)+EXTERN bool has_mbyte INIT(= true);  ///< Any multi-byte encoding (always true)","let's make them `#define` and see what happens. Maybe we get too many dead code warnings, gcc doesn't, let see what clang says. Anyway ""grep"" might be enough as a tool to find dead code :)",X
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/5318,78278998,2016-09-10T15:33:56Z,CMakeLists.txt,"@@ -328,7 +328,11 @@ if((CLANG_ASAN_UBSAN OR CLANG_MSAN OR CLANG_TSAN) AND NOT CMAKE_C_COMPILER_ID MA   message(FATAL_ERROR ""Sanitizers are only supported for Clang."") endif() -option(ENABLE_JEMALLOC ""enable jemalloc"" ON)+if(CMAKE_SYSTEM_NAME STREQUAL ""OpenBSD"")+  option(ENABLE_JEMALLOC ""enable jemalloc"" OFF)+else()+  option(ENABLE_JEMALLOC ""enable jemalloc"" ON)+endif()","I see now that `option(... OFF)` only sets the default value, doesn't override a provided value--my mistake.Though if someone wants to fix the issue, they could modify the CMakeLists.txt. In the meantime it's nice to have a `message()` for visibility. ",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/2789,78280020,2016-09-10T16:43:57Z,src/nvim/os/shell.c,"@@ -59,7 +104,8 @@ char **shell_build_argv(const char *cmd, const char *extra_args)    if (cmd) {     i += tokenize(p_shcf, rv + i);   // Split 'shellcmdflag'-    rv[i++] = xstrdup(cmd);          // Push a copy of the command.+    rv[i++] = shell_escape(cmd);     // Process command string with","Doing this here will affect `tv_to_argv` which is used by `f_jobstart`--but only if the first arg is String, so that seems fine. It also affects `f_termopen()`, not sure about that (and I don't care too much because we should deprecate that function and enhance `jobstart()` to replace it).So, ���� ",X
715238,equalsraf,https://api.github.com/repos/neovim/neovim/pulls/5318,78280709,2016-09-10T17:26:31Z,src/nvim/CMakeLists.txt,"@@ -120,9 +120,13 @@ if(NOT MSVC)   set_source_files_properties(     ${CONV_SOURCES} PROPERTIES COMPILE_FLAGS ""${COMPILE_FLAGS} -Wno-conversion"")   # gperf generates ANSI-C with incorrect linkage, ignore it.+  check_c_compiler_flag(-Wno-static-in-inline HAS_WNO_STATIC_IN_INLINE_FLAG)+  if(HAS_WNO_STATIC_IN_INLINE_FLAG)+    set_source_files_properties(+      eval.c PROPERTIES COMPILE_FLAGS ""${COMPILE_FLAGS} -Wno-static-in-inline"")+  endif()   set_source_files_properties(-    eval.c PROPERTIES COMPILE_FLAGS ""${COMPILE_FLAGS} -Wno-static-in-inline -Wno-conversion"")-+    eval.c PROPERTIES COMPILE_FLAGS ""${COMPILE_FLAGS} -Wno-conversion"")","I expected the second **set** to include the current **C_COMPILE_FLAGS** + the new option. Lets see, in OpenBSD i get[ 58%] Building C object src/nvim/CMakeFiles/nvim.dir/eval.c.ocd /home/raf/Code/neovim/build/src/nvim && /usr/bin/cc  -DHAVE_CONFIG_H -DINCLUDE_GENERATED_DECLARATIONS -I/home/raf/Code/neovim/build/config -I/home/raf/Code/neovim/src -isystem /home/raf/Code/neovim/.deps/usr/include -isystem /usr/local/include -I/home/raf/Code/neovim/build/src/nvim/auto -I/home/raf/Code/neovim/build/include  -Wconversion -O2 -g   -Wall -Wextra -pedantic -Wno-unused-parameter -Wstrict-prototypes -std=gnu99 -fstack-protector-strong  **-Wno-conversion** -o CMakeFiles/nvim.dir/eval.c.o   -c /home/raf/Code/neovim/src/nvim/eval.cthat seems correct. In Linux I get[ 50%] Building C object src/nvim/CMakeFiles/nvim.dir/eval.c.ocd /home/raf/Code/neovim/build/src/nvim && /usr/bin/cc  -DHAVE_CONFIG_H -DINCLUDE_GENERATED_DECLARATIONS -D_GNU_SOURCE -I/home/raf/Code/neovim/build/config -I/home/raf/Code/neovim/src -isystem /home/raf/Code/neovim/.deps/usr/include -I/home/raf/Code/neovim/build/src/nvim/auto -I/home/raf/Code/neovim/build/include  -Wconversion -Og -g   -Wall -Wextra -pedantic -Wno-unused-parameter -Wstrict-prototypes -std=gnu99 -Wvla -fstack-protector-strong -fdiagnostics-color=auto  **-Wno-conversion** -o CMakeFiles/nvim.dir/eval.c.o   -c /home/raf/Code/neovim/src/nvim/eval.cwhich is missing Wno-static-in-inline. Pushing a fix shortly.",X
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/5318,78290724,2016-09-11T09:01:31Z,src/nvim/CMakeLists.txt,"@@ -120,9 +120,14 @@ if(NOT MSVC)   set_source_files_properties(     ${CONV_SOURCES} PROPERTIES COMPILE_FLAGS ""${COMPILE_FLAGS} -Wno-conversion"")   # gperf generates ANSI-C with incorrect linkage, ignore it.-  set_source_files_properties(-    eval.c PROPERTIES COMPILE_FLAGS ""${COMPILE_FLAGS} -Wno-static-in-inline -Wno-conversion"")-+  check_c_compiler_flag(-Wno-static-in-inline HAS_WNO_STATIC_IN_INLINE_FLAG)","When someone looks at this in two years time it will look like ""we need to keep this, as we support compilers that don't have `-Wno-static-in-inline`"" which is not the case; recent (as in ""not ancient"") gcc compilers don't have this flag either but are still fine without this workaround. What we really are guarding against, and what we only need to keep this along for, is compiling with gcc <= 4.3. But anyway, isn't openbsd shipping a nine (9) year old gcc their way of saying ""you are really supposed to use clang if you can""?",X
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/5318,78293035,2016-09-11T11:32:33Z,src/nvim/CMakeLists.txt,"@@ -120,9 +120,14 @@ if(NOT MSVC)   set_source_files_properties(     ${CONV_SOURCES} PROPERTIES COMPILE_FLAGS ""${COMPILE_FLAGS} -Wno-conversion"")   # gperf generates ANSI-C with incorrect linkage, ignore it.-  set_source_files_properties(-    eval.c PROPERTIES COMPILE_FLAGS ""${COMPILE_FLAGS} -Wno-static-in-inline -Wno-conversion"")-+  check_c_compiler_flag(-Wno-static-in-inline HAS_WNO_STATIC_IN_INLINE_FLAG)","What 4.4 added was not support for a ""single optional flag"", rather the _general_ realization that unknown `-Wno-` can be safely ignored. If the guard checks against `gcc <= 4.3` then it is obvious when this check later could be removed.  Also if we later need to add some new `-Wno-` which not all compilers have, it's then clear we could add it to the same guard, rather than adding yet another `check_c_compiler_flag` and making this logic even more complex. ",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/5319,78295353,2016-09-11T13:35:13Z,test/functional/terminal/highlight_spec.lua,"@@ -206,4 +206,53 @@ describe('synIDattr()', function()     eq('252', eval('synIDattr(hlID(""Normal""), ""fg"")'))     eq('79', eval('synIDattr(hlID(""Keyword""), ""fg"")'))   end)++  it('returns ""Normal"" values for group using special fg/bg names', function()+    execute('highlight Normal ctermfg=145 ctermbg=16 guifg=#ff0000 guibg=Black')+    execute('highlight Visual ctermfg=bg ctermbg=fg guifg=bg guibg=fg guisp=bg')+    eq(eval('synIDattr(hlID(""Normal""), ""bg"")'),+      eval('synIDattr(hlID(""Visual""), ""fg"")'))+    eq(eval('synIDattr(hlID(""Normal""), ""bg#"")'),+      eval('synIDattr(hlID(""Visual""), ""fg#"")'))+    eq(eval('synIDattr(hlID(""Normal""), ""fg"")'),+      eval('synIDattr(hlID(""Visual""), ""bg"")'))+    eq(eval('synIDattr(hlID(""Normal""), ""fg#"")'),+      eval('synIDattr(hlID(""Visual""), ""bg#"")'))+    eq('bg', eval('synIDattr(hlID(""Visual""), ""fg"", ""gui"")'))+    eq('bg', eval('synIDattr(hlID(""Visual""), ""fg#"", ""gui"")'))+    eq('fg', eval('synIDattr(hlID(""Visual""), ""bg"", ""gui"")'))+    eq('fg', eval('synIDattr(hlID(""Visual""), ""bg#"", ""gui"")'))+    eq('bg', eval('synIDattr(hlID(""Visual""), ""sp"", ""gui"")'))+    eq('bg', eval('synIDattr(hlID(""Visual""), ""sp#"", ""gui"")'))+  end)++  it('returns ""Normal"" values for group using special fg/bg names \z+    if RGB-capable UI is attached', function()","a long line would be preferable to the `\z` hack :) Or try to shorten the description:```it('fg/bg special colors resolve to ""Normal"" values in RGB-capable UI',```",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/5328,78300296,2016-09-11T18:53:33Z,runtime/doc/filetype.txt,"@@ -542,6 +542,17 @@ CTRL-T                    Jump back to the location that the manpage was                           opened from. q                         :quit if invoked as $MANPAGER, otherwise :close. +Global mappings:+K                         Jump to the manpage for the <cword> under the+                          cursor. Takes a count for the section.++If you want to define a mapping on another key, do: >+    :nmap <silent> K :Man<CR>++Replace K with your key and you can include modifiers so if you want+it to open the page in a vertical split: >+    :nmap <silent> K :vertical Man<CR>","This is mentioned on line 536, I think we can consider it covered.Defining a mapping is a basic usage of the editor. It seems like an anti-pattern to explain basic operations over and over in every single plugin doc. If there's some piece of essential information here, sure, we should mention it. But not defining a mapping...",X
849178,kranki,https://api.github.com/repos/neovim/neovim/pulls/5308,78508991,2016-09-13T07:30:42Z,test/unit/strings_spec.lua,"@@ -98,3 +98,40 @@ describe('vim_strnsave_unquoted()', function()     eq('/Program\\nFiles/sh', vim_strnsave_unquoted('/Program""\\n""Files/sh'))   end) end)++describe(""reverse_text"", function()+  local reverse_text = function(str)+    return helpers.internalize(strings.reverse_text(to_cstr(str)))+  end++  it(""handles empty string"", function()+    eq("""", reverse_text(""""))+  end)++  it(""handles simple cases"", function()+    eq(""a"", reverse_text(""a""))+    eq(""ba"", reverse_text(""ab""))+  end)++  it(""handles multibyte characters"", function()+    eq(""b��"", reverse_text(""��b""))+    eq(""Y��t��n y��"", reverse_text(""��y n��t��Y""))+  end)++  it(""handles combining chars"", function()+    local utf8_COMBINING_RING_ABOVE = ""\204\138""+    local utf8_COMBINING_RING_BELOW = ""\204\165""+    eq(""bba"" .. utf8_COMBINING_RING_ABOVE .. utf8_COMBINING_RING_BELOW .. ""aa"", +       reverse_text(""aaa"" .. utf8_COMBINING_RING_ABOVE .. utf8_COMBINING_RING_BELOW .. ""bb""))+  end)++  local utf8_REPLACEMENT_CHARACTER = ""\239\191\189""++  it(""replaces invalid utf with the replacement character U+FFFD"", function()+    eq(utf8_REPLACEMENT_CHARACTER .. ""ba"", reverse_text(""ab\192""))+  end)++  it(""replaces an incomplete utf continuation sequence"", function()+    eq(utf8_REPLACEMENT_CHARACTER .. ""ba"", reverse_text(""ab\194""))+  end)+end)",https://en.wikipedia.org/wiki/UTF-8#Invalid_byte_sequencesI'm wondering what the correct strategy for handling invalid utf is? Not just in `reverse_text` but neovim in general. I made example tests for handling invalid bytes and incomplete continuation seq by replacing them. Another strategy is to error on these. @bfredl ?,
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/5329,78560863,2016-09-13T13:42:49Z,src/nvim/bytes.c,"@@ -0,0 +1,21 @@+// Low-level functions with minimal dependencies, side-effects, etc.++#include <assert.h>+#include <inttypes.h>++#include ""nvim/vim.h""+#include ""nvim/bytes.h""++#ifdef INCLUDE_GENERATED_DECLARATIONS+# include ""bytes.c.generated.h""+#endif++/// Writes time_t to ""buf[8]"".+void time_to_bytes(time_t time_, uint8_t buf[8])","Maybe, but this function don't really wrap any stdlib function. It might be reasonable to extract the more byte-manipulation functions in `memory.c` (from the basic allocation/freeing wrapper functions) to `bytes.c`, but then again, `memory.c` isn't really that big or bloated. But anyway that could be later PR, I just thought this function seemed very lonely for the moment :)",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/5336,78717027,2016-09-14T09:43:07Z,src/nvim/api/buffer.c,"@@ -432,19 +432,52 @@ Object nvim_buf_get_var(Buffer buffer, String name, Error *err) /// @param name The variable name /// @param value The variable value /// @param[out] err Details of an error that may have occurred+void nvim_buf_set_var(Buffer buffer, String name, Object value, Error *err)+{+  buf_T *buf = find_buffer_by_handle(buffer, err);++  if (!buf) {+    return;+  }++  dict_set_value(buf->b_vars, name, value, false, false, err);+}++/// Removes a buffer-scoped (b:) variable+///+/// @param buffer The buffer handle+/// @param name The variable name+/// @param[out] err Details of an error that may have occurred+void nvim_buf_del_var(Buffer buffer, String name, Error *err)+{+  buf_T *buf = find_buffer_by_handle(buffer, err);++  if (!buf) {+    return;+  }++  dict_set_value(buf->b_vars, name, NIL, true, false, err);+}++/// Sets a buffer-scoped (b:) variable+///+/// @param buffer The buffer handle+/// @param name The variable name+/// @param value The variable value+/// @param[out] err Details of an error that may have occurred /// @return The old value or nil if there was no previous value. /// ///         @warning It may return nil if there was no previous value ///                  or if previous value was `v:null`.-Object nvim_buf_set_var(Buffer buffer, String name, Object value, Error *err)+Object buffer_set_var(Buffer buffer, String name, Object value, Error *err)",mark `@deprecated` ? (same for the others),
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/5336,78717810,2016-09-14T09:49:01Z,src/nvim/api/buffer.c,"@@ -453,20 +486,18 @@ Object nvim_buf_set_var(Buffer buffer, String name, Object value, Error *err) /// @param name The variable name /// @param[out] err Details of an error that may have occurred /// @return The old value or nil if there was no previous value.-///-///         @warning It may return nil if there was no previous value-///                  or if previous value was `v:null`.-Object nvim_buf_del_var(Buffer buffer, String name, Error *err)+Object buffer_del_var(Buffer buffer, String name, Error *err)",is the `@return` doc correct? (similar for the others),
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/5336,78767775,2016-09-14T15:06:34Z,src/nvim/api/buffer.c,"@@ -432,19 +432,52 @@ Object nvim_buf_get_var(Buffer buffer, String name, Error *err) /// @param name The variable name /// @param value The variable value /// @param[out] err Details of an error that may have occurred+void nvim_buf_set_var(Buffer buffer, String name, Object value, Error *err)+{+  buf_T *buf = find_buffer_by_handle(buffer, err);++  if (!buf) {+    return;+  }++  dict_set_value(buf->b_vars, name, value, false, false, err);+}++/// Removes a buffer-scoped (b:) variable+///+/// @param buffer The buffer handle+/// @param name The variable name+/// @param[out] err Details of an error that may have occurred+void nvim_buf_del_var(Buffer buffer, String name, Error *err)+{+  buf_T *buf = find_buffer_by_handle(buffer, err);++  if (!buf) {+    return;+  }++  dict_set_value(buf->b_vars, name, NIL, true, false, err);+}++/// Sets a buffer-scoped (b:) variable+///+/// @param buffer The buffer handle+/// @param name The variable name+/// @param value The variable value+/// @param[out] err Details of an error that may have occurred /// @return The old value or nil if there was no previous value. /// ///         @warning It may return nil if there was no previous value ///                  or if previous value was `v:null`.-Object nvim_buf_set_var(Buffer buffer, String name, Object value, Error *err)+Object buffer_set_var(Buffer buffer, String name, Object value, Error *err)","I thought about it, but ain't functions with these names implicitly deprecated? When implementing the doc generation the plan is to not generate docs for these, or alternatively place them in a ""deprecated"" section. But anyway, it shouldn't hurt to be extra clear, so I'll add it.",X
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/5333,78796365,2016-09-14T17:34:43Z,src/nvim/eval.c,"@@ -16768,6 +16768,14 @@ static void f_wildmenumode(typval_T *argvars, typval_T *rettv, FunPtr fptr)     rettv->vval.v_number = 1; } +/// ""win_findbuf()"" function+static void f_win_findbuf(typval_T *argvars, typval_T *rettv, FunPtr fptr)+{+  if (rettv_list_alloc(rettv) != FAIL) {","Again the same error. `rettv_list_alloc` does _not_ return OK or FAIL, it returns `list_T*`. And in any case this should not check for FAIL or NULL as long as memory allocation functions do not return `NULL`.",X
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/5339,78852362,2016-09-14T22:05:54Z,test/functional/ui/output_spec.lua,"@@ -22,6 +22,7 @@ describe(""shell command :!"", function()    after_each(function()     screen:detach()+    session.command('call jobstop(b:terminal_job_id)')","sending ctrl-c in `after_each`  (before `screen:detach()`) seems to fix the problem:```child_session.feed_data(""\3"")  -- ctrl-c```",
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/5335,79255643,2016-09-16T21:37:41Z,src/nvim/version.c,"@@ -118,56 +284,56 @@ static int included_patches[] = {   // 2160,   // 2159,   // 2158,-  // 2157,-  // 2156,-  // 2155,-  // 2154,-  // 2153,+  // 2157 NA+  // 2156 NA+  // 2155 NA+  // 2154 NA+  // 2153 NA   // 2152,   // 2151,-  // 2150,+  // 2150 NA   // 2149,   // 2148,   // 2147,   // 2146,-  // 2145,+  // 2145 NA   // 2144,   // 2143,   // 2142,   // 2141,-  // 2140,+  // 2140 NA   // 2139,-  // 2138,+  // 2138 NA   // 2137,   // 2136,   // 2135,   // 2134,-  // 2133,+  // 2133 NA   // 2132,-  // 2131,-  // 2130,-  // 2129,+  // 2131 NA+  // 2130 NA+  // 2129 NA   // 2128,   // 2127,   // 2126,   // 2125,   // 2124,   // 2123,-  // 2122,+  // 2122 NA   // 2121,   // 2120,   // 2119,-  // 2118,+  // 2118 NA   // 2117,-  // 2116,+  // 2116 NA   // 2115,   // 2114,",Is listed as `NA` in commit message.,
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/5358,79311823,2016-09-18T18:16:29Z,src/nvim/eval.c,"@@ -514,6 +514,10 @@ void eval_init(void)    for (size_t i = 0; i < ARRAY_SIZE(vimvars); i++) {     p = &vimvars[i];+    if (STRLEN(p->vv_name) > 16) {+      EMSG(""INTERNAL: name too long, increase size of dictitem16_T"");+      getout(1);","Calling `getout()` here is not safe. For example pointer `p_mouse` is dereferenced, but it is only initialized after `eval_init()` (in `set_init_1()`).If a name is too long:``` cProgram received signal SIGSEGV, Segmentation fault.0x0000000000556f65 in setmouse () at /home/oni-link/git/neovim/src/nvim/mouse.c:461461   if (*p_mouse == NUL)(gdb) bt#0  0x0000000000556f65 in setmouse () at /home/oni-link/git/neovim/src/nvim/mouse.c:461#1  0x0000000000549660 in wait_return (redraw=0) at /home/oni-link/git/neovim/src/nvim/message.c:782#2  0x0000000000525ee2 in getout (exitval=1) at /home/oni-link/git/neovim/src/nvim/main.c:616#3  0x0000000000472400 in eval_init () at /home/oni-link/git/neovim/src/nvim/eval.c:520#4  0x0000000000525340 in early_init () at /home/oni-link/git/neovim/src/nvim/main.c:181#5  0x0000000000525431 in main (argc=1, argv=0x7fffffffd918) at /home/oni-link/git/neovim/src/nvim/main.c:237```If name length is not a problem:``` c(gdb) watch p_mouseHardware watchpoint 1: p_mouse(gdb) rStarting program: /home/oni-link/git/neovim/build/bin/nvim [Thread debugging using libthread_db enabled]Using host libthread_db library ""/lib64/libthread_db.so.1"".Hardware watchpoint 1: p_mouseOld value = (char_u *) 0x0New value = (char_u *) 0x6fd3b2 ""a""set_option_default (opt_idx=185, opt_flags=0, compatible=0) at /home/oni-link/git/neovim/src/nvim/option.c:825825         options[opt_idx].flags &= ~P_ALLOCED;(gdb) bt#0  set_option_default (opt_idx=185, opt_flags=0, compatible=0) at /home/oni-link/git/neovim/src/nvim/option.c:825#1  0x00000000005828f4 in set_options_default (opt_flags=0) at /home/oni-link/git/neovim/src/nvim/option.c:868#2  0x0000000000582336 in set_init_1 () at /home/oni-link/git/neovim/src/nvim/option.c:702#3  0x0000000000525380 in early_init () at /home/oni-link/git/neovim/src/nvim/main.c:210#4  0x0000000000525431 in main (argc=1, argv=0x7fffffffd918) at /home/oni-link/git/neovim/src/nvim/main.c:237```",X
116470,jbradaric,https://api.github.com/repos/neovim/neovim/pulls/5358,79313154,2016-09-18T19:22:24Z,src/nvim/eval.c,"@@ -514,6 +514,10 @@ void eval_init(void)    for (size_t i = 0; i < ARRAY_SIZE(vimvars); i++) {     p = &vimvars[i];+    if (STRLEN(p->vv_name) > 16) {+      EMSG(""INTERNAL: name too long, increase size of dictitem16_T"");+      getout(1);",@fwalch I've just tried it and Vim also segfaults if a variable name is longer than 16 characters.,
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/4568,80360355,2016-09-24T12:56:57Z,src/nvim/api/vim.c,"@@ -663,6 +663,110 @@ Array nvim_get_api_info(uint64_t channel_id)   return rv; } +/// Call many api functions atomically+///+/// This has two main usages: Firstly, to perform several requests from an+/// async context atomically, i.e. without processing requests from other rpc+/// clients or redrawing or allowing user interaction in between. Note that api+/// methods that could fire autocommands or do event processing still might do+/// so. For instance invoking the :sleep command might call timer callbacks.+/// Secondly, it can be used to reduce rpc overhead (roundtrips) when doing+/// many requests in sequence.+///+/// @param calls an array of calls, where each call is described by an array+/// with at least three elements: the request name, an array of arguments, and+/// a boolean indicating if the return value should be sent back.+///+/// @return an array with three elements. The first is the number of calls that+/// where performed without errors. If it is the same as the length of ""calls"",+/// all calls were successful, otherwise it is the number of the last attempted+/// call resulting in an error. The second is an array of return values, for+/// calls when the third boolean flag was set to true. The third is NIL if all+/// calls succeeded. If a call resulted in an error, it is a two-element array+/// with the error code and message.+Array nvim_multi_request(uint64_t channel_id, Array calls, Error *err)+  FUNC_API_NOEVAL+{+  Array rv = ARRAY_DICT_INIT;+  Array results = ARRAY_DICT_INIT;+  // make place for the number of successful requests+  Error nested_error = ERROR_INIT;++  size_t i;  // also used for freeing the variables+  for (i = 0; i < calls.size; i++) {+    if (calls.items[i].type != kObjectTypeArray) {+      api_set_error(err,+                    Validation,+                    _(""All items in calls array must be arrays""));+      goto end;+    }+    Array call = calls.items[i].data.array;+    if (call.size != 3) {+      api_set_error(err,+                    Validation,+                    _(""All items in calls array must be arrays of size 3""));+      goto end;+    }++    if (call.items[0].type != kObjectTypeString) {+      api_set_error(err,+                    Validation,+                    _(""name must be String""));+      goto end;+    }+    String name = call.items[0].data.string;++    if (call.items[1].type != kObjectTypeArray) {+      api_set_error(err,+                    Validation,+                    _(""args must be Array""));+      goto end;+    }+    Array args = call.items[1].data.array;++    Boolean retval = false;+    if (call.items[2].type == kObjectTypeBoolean) {+      retval = call.items[2].data.boolean;+    } else if (call.items[2].type == kObjectTypeInteger) {+      retval = (unsigned)call.items[2].data.integer;+    } else {+      api_set_error(err,+                    Validation,+                    _(""return must be Boolean""));+      goto end;+    }++    MsgpackRpcRequestHandler handler = msgpack_rpc_get_handler_for(name.data,+                                                                   name.size);+    Object result = handler.fn(channel_id, UINT64_MAX, args, &nested_error);+    if (nested_error.set) {+      // error handled after loop+      break;+    }++    if (retval) {+      ADD(results, result);","yes, the comlete multi_request is then interrupted, so there is no ambiguity what calls the present elements in `results` come from.",
112971,jamessan,https://api.github.com/repos/neovim/neovim/pulls/5372,80371334,2016-09-25T00:10:04Z,scripts/genunicodetables.lua,"@@ -17,18 +17,22 @@ --    which don't have ambiguous or double width, and emoji_all has all Emojis. if arg[1] == '--help' then   print('Usage:')-  print('  genunicodetables.lua UnicodeData.txt CaseFolding.txt ' ..-        'EastAsianWidth.txt emoji-data.txt')-  print('                       unicode_tables.generated.h')+  print('  genunicodetables.lua unicode/ unicode_tables.generated.h')   os.exit(0) end -local unicodedata_fname = arg[1]-local casefolding_fname = arg[2]-local eastasianwidth_fname = arg[3]-local emoji_fname = arg[4]+local basedir = arg[1]:gsub('[/\\]$', '')","> On *nix it is valid to have directory like /foo/bar\, so this gsub is generally not correct.You're right.  We already know what the path separator is.  It should only be matching/replacing that.> why you think it may receive ���/? CMakeLists.txt does not contain such path.CMakeLists.txt isn't the only way to call this.  I'm just trying to make sure it handles possible input correctly.  I could use penlight's pl.path.join, but adding another dependency seems heavy handed for this one thing.",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/5372,80371579,2016-09-25T00:29:20Z,scripts/genunicodetables.lua,"@@ -17,18 +17,22 @@ --    which don't have ambiguous or double width, and emoji_all has all Emojis. if arg[1] == '--help' then   print('Usage:')-  print('  genunicodetables.lua UnicodeData.txt CaseFolding.txt ' ..-        'EastAsianWidth.txt emoji-data.txt')-  print('                       unicode_tables.generated.h')+  print('  genunicodetables.lua unicode/ unicode_tables.generated.h')   os.exit(0) end -local unicodedata_fname = arg[1]-local casefolding_fname = arg[2]-local eastasianwidth_fname = arg[3]-local emoji_fname = arg[4]+local basedir = arg[1]:gsub('[/\\]$', '')","> CMakeLists.txt isn't the only way to call this. I'm just trying to make sure it handles possible input correctly. I could use penlight's pl.path.join, but adding another dependency seems heavy handed for this one thing.Then why not protect against double slashes, `file://`-like URLs, more then one slash at the end, forward slashes in place of backward, etc? Supplying correct input is a caller���s responsibility.I do not see any reasons to have this `gsub()` up until receiving proves that1. It causes any problems.2. Person who called this script like that will file an issue here (i.e. somebody thinks these problems need to be fixed).I would expect more problems with using forward slash in place of backward in a path separator (what does cmake supply to genunicodetables.lua on Windows?) then with double path separator.BTW in `wine` `type` program has no problems with double path separators.",X
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/5119,80386490,2016-09-25T16:47:55Z,src/nvim/CMakeLists.txt,"@@ -204,14 +206,19 @@ add_custom_command(OUTPUT ${GENERATED_UNICODE_TABLES} )  add_custom_command(OUTPUT ${GENERATED_API_DISPATCH} ${API_METADATA}-    COMMAND ${LUA_PRG} ${DISPATCH_GENERATOR} ${CMAKE_CURRENT_LIST_DIR} ${API_HEADERS} ${GENERATED_API_DISPATCH} ${API_METADATA}+  COMMAND ${LUA_PRG} ${DISPATCH_GENERATOR} ${CMAKE_CURRENT_LIST_DIR}/api ${API_HEADERS} ${GENERATED_API_DISPATCH} ${API_METADATA}","it already knows the leaf filename, why not the entire path in the source directory? Someone reading `gendispatch.lua` (with the other scripts) would like to know where the file is, this is easier if it is consistent with other scripts and use `nvimsrcdir`, instead of `libdir` which doesn't say much. Also if some script later wants to use `.lua` files in several sub-directories the existing pattern is simpler.",X
112971,jamessan,https://api.github.com/repos/neovim/neovim/pulls/5358,80822835,2016-09-28T00:17:05Z,src/nvim/eval.c,"@@ -514,6 +514,10 @@ void eval_init(void)    for (size_t i = 0; i < ARRAY_SIZE(vimvars); i++) {     p = &vimvars[i];+    if (STRLEN(p->vv_name) > 16) {+      EMSG(""INTERNAL: name too long, increase size of dictitem16_T"");+      getout(1);",Does it really matter?  This code is just here to flag an issue when a new item is added to the vimvars array.  The entire point is that you're supposed to notice that the variable name is too long and the array size should be changed.Why not just change the if to `assert(STRLEN(p->vv_name) <= 16);`?  Then the getout and EMSG aren't needed.,X
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/5393,80871369,2016-09-28T09:02:15Z,src/nvim/api/private/dispatch.c,"@@ -0,0 +1,47 @@+#include <inttypes.h>+#include <stdbool.h>+#include <stdint.h>+#include <assert.h>+#include <msgpack.h>++#include ""nvim/map.h""+#include ""nvim/log.h""+#include ""nvim/vim.h""+#include ""nvim/msgpack_rpc/helpers.h""+#include ""nvim/api/private/dispatch.h""+#include ""nvim/api/private/helpers.h""+#include ""nvim/api/private/defs.h""++#include ""nvim/api/buffer.h""+#include ""nvim/api/tabpage.h""+#include ""nvim/api/ui.h""+#include ""nvim/api/vim.h""+#include ""nvim/api/window.h""++static Map(String, MsgpackRpcRequestHandler) *methods = NULL;++static void msgpack_rpc_add_method_handler(String method, MsgpackRpcRequestHandler handler)+{+  map_put(String, MsgpackRpcRequestHandler)(methods, method, handler);+}++MsgpackRpcRequestHandler msgpack_rpc_get_handler_for(const char *name,+                                                     size_t name_len)+{+  String m = {+    .data=(char *)name,+    .size=name_len, //TODO(bfredl): was the max_fname_len check important?","Aren't optimizations supposed to be done for code paths that are likely to happen? While invalid method calls could happen, a client calling nvim with a superlong invalid method name sounds like an incredibly rare event, and would already have wasted cpu cycles on the client side (and just by parsing the msgpack in nvim)... Anyway either gperf or triehash will handle this for us when we switch to it here.",X
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/5386,81206990,2016-09-29T18:43:19Z,src/nvim/api/private/helpers.c,"@@ -808,6 +811,17 @@ static void init_type_metadata(Dictionary *metadata)    PUT(*metadata, ""types"", DICTIONARY_OBJ(types)); }+static void init_api_level_metadata(Dictionary *metadata)+{+  Dictionary version = ARRAY_DICT_INIT;+  PUT(version, ""current"", INTEGER_OBJ(NVIM_API_CURRENT));+  PUT(version, ""compatibility"", INTEGER_OBJ(NVIM_API_COMPATIBILITY));+#ifdef NVIM_VERSION_PRERELEASE+  PUT(version, ""prerelease"", BOOLEAN_OBJ(true));","The point is that (the state I want to call) `[2, ""pre""]` is neither the same as `[1, ""stable""]` nor `[2, ""stable""]`. If we don't include it, we need to make a decision one way or the other. You seem to prefer the latter. But then there is no simple way to determine ""what is the latest stable version?"" > in either case you need to verify that the stable API is the same as the last snapshot you used of the prerelease API.I suppose most plugins/hosts, no matter the strategy towards master versions, could _in principle_ make a decision purely by inspecting the detailed method metadata, _without_ using the global version data at all at runtime. My point is simply that _both_ plugins that wants to only use stable _and_ those that wants to try use unstable api level (if available) should be allowed to do so based on the global fields without deep inspection. Saying that it ""only be useful"" for one or the other, is missing the big picture IMHO. If one only imagines one plugin then the granularity might not make sense. The point is rather that different plugins might want to put the decision boundary differently, even if it is likely no single plugin will ever alone distinguish all of 1-stable, 2-pre and 2-release. ",
112971,jamessan,https://api.github.com/repos/neovim/neovim/pulls/5386,81211612,2016-09-29T19:04:44Z,src/nvim/api/private/helpers.c,"@@ -808,6 +811,17 @@ static void init_type_metadata(Dictionary *metadata)    PUT(*metadata, ""types"", DICTIONARY_OBJ(types)); }+static void init_api_level_metadata(Dictionary *metadata)+{+  Dictionary version = ARRAY_DICT_INIT;+  PUT(version, ""current"", INTEGER_OBJ(NVIM_API_CURRENT));+  PUT(version, ""compatibility"", INTEGER_OBJ(NVIM_API_COMPATIBILITY));+#ifdef NVIM_VERSION_PRERELEASE+  PUT(version, ""prerelease"", BOOLEAN_OBJ(true));","If someone is developing a plugin against unreleased API, then they need to be following Neovim development closely to stay on top of any changes we may make before the API is released.  Therefore, they're aware that the API hasn't been released and should use it accordingly.If they are then releasing the plugin that's using the unreleased API, then they need to pick up the cookie pieces if/when it crumbles.I don't think providing extra metadata to help delineate whether the API is released or yet is necessary.  It's a technical measure for a social problem.",X
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/5386,81221837,2016-09-29T20:01:01Z,src/nvim/api/private/helpers.c,"@@ -808,6 +811,17 @@ static void init_type_metadata(Dictionary *metadata)    PUT(*metadata, ""types"", DICTIONARY_OBJ(types)); }+static void init_api_level_metadata(Dictionary *metadata)+{+  Dictionary version = ARRAY_DICT_INIT;+  PUT(version, ""current"", INTEGER_OBJ(NVIM_API_CURRENT));+  PUT(version, ""compatibility"", INTEGER_OBJ(NVIM_API_COMPATIBILITY));+#ifdef NVIM_VERSION_PRERELEASE+  PUT(version, ""prerelease"", BOOLEAN_OBJ(true));","> I don't think providing extra metadata to help delineate whether the API is released or yet is necessary. It's a technical measure for a social problem.Sigh, no one has ever claimed that this is the best solution to some specific ""social"" problem.  The point is simply to provide the plugin/host with _information_ so they can make a decision the way they prefer (also including, not using global information at all and instead do a deep inspection), without setting a policy for _all_ plugins.Again, we we don't include this, we need to make a  decision to either specify the old stable level or the in-dev level,  _either_ way a delineation is being done. I've heard good arguments for both. IMO that adds up to letting api clients get all the information. But _either_ way a decision to take some ""technical measure"" is being made, I'm just proposing the one that forces the least assumptions on clients.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/5386,81237421,2016-09-29T21:21:58Z,src/nvim/api/private/helpers.c,"@@ -808,6 +811,17 @@ static void init_type_metadata(Dictionary *metadata)    PUT(*metadata, ""types"", DICTIONARY_OBJ(types)); }+static void init_api_level_metadata(Dictionary *metadata)+{+  Dictionary version = ARRAY_DICT_INIT;+  PUT(version, ""current"", INTEGER_OBJ(NVIM_API_CURRENT));+  PUT(version, ""compatibility"", INTEGER_OBJ(NVIM_API_COMPATIBILITY));+#ifdef NVIM_VERSION_PRERELEASE+  PUT(version, ""prerelease"", BOOLEAN_OBJ(true));","> When a release is made, ""pre-release"" is disabled.Can add that step to [release.sh](https://github.com/neovim/neovim/blob/master/scripts/release.sh#L48).",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/5396,81240822,2016-09-29T21:41:37Z,src/nvim/os/shell.c,"@@ -309,19 +309,44 @@ static void system_data_cb(Stream *stream, RBuffer *buf, size_t count,   dbuf->len += nread; } +char *_output = NULL;+ /// Continue to append data to last screen line. /// /// @param output       Data to append to screen lines. /// @param remaining    Size of data. /// @param new_line     If true, next data output will be on a new line.-static void append_to_screen_end(char *output, size_t remaining, bool new_line)+static void append_to_screen_end(void *source, char *output, size_t remaining, bool new_line) {+  static void *last_source = NULL;   // Column of last row to start appending data to.   static colnr_T last_col = 0;+  char skip_msg[] = { '.', '\0', '\0' };    size_t off = 0;   int last_row = (int)Rows - 1; +  if (last_source != source) {+    last_source = source;+  } else {+    // count the lines+    size_t lines = 0;+    for (char *p = output; p < (output + remaining); p++) {+      if (*p == NL) {+        lines++;+      }+    }","An idea for a more sophisticated ""throttle trigger"", might be the keep a count of the pending `thread_events` per-queue and then maybe drop them until processing catches up. But maybe the arbitrary limit  (this PR) is good enough: it's probably not useful for anyone to see more than 1000 lines blasted in the pager, in _any_ UI (TUI or GUI). So the approach I was thinking here was to ""snip"" long outputs: print the last ~500 lines (as well as the first ~500 lines).",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/5396,81241443,2016-09-29T21:45:12Z,src/nvim/tui/tui.c,"@@ -583,6 +588,17 @@ static void tui_flush(UI *ui)   TUIData *data = ui->data;   UGrid *grid = &data->grid; ++  int nrevents = queue_count(data->loop->thread_events);+  // QUEUE *q = QUEUE_HEAD(&queue->headtail);+  // while(true) {+  // }+  ILOG(""thread_events=%d"", nrevents);","Yep, I'll add a condition or remove this. `yes` can generate MB of data in a couple seconds, and GB in just a few minutes.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/5386,81243207,2016-09-29T21:55:46Z,src/nvim/api/private/helpers.c,"@@ -808,6 +811,17 @@ static void init_type_metadata(Dictionary *metadata)    PUT(*metadata, ""types"", DICTIONARY_OBJ(types)); }+static void init_api_level_metadata(Dictionary *metadata)+{+  Dictionary version = ARRAY_DICT_INIT;+  PUT(version, ""current"", INTEGER_OBJ(NVIM_API_CURRENT));+  PUT(version, ""compatibility"", INTEGER_OBJ(NVIM_API_COMPATIBILITY));+#ifdef NVIM_VERSION_PRERELEASE+  PUT(version, ""prerelease"", BOOLEAN_OBJ(true));","Maybe I was unclear, but I meant the stable version available in the nvim binary queried. ""Global"" here means as opposed to method-local metadata, not the status of the nvim project as opposed to one present binary.",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/5119,81476761,2016-10-02T19:59:58Z,test/unit/eval/typval_spec.lua,"@@ -1057,39 +1057,108 @@ describe('typval.c', function()         eq(empty_list, typvalt2lua(rettv4))       end)     end)-  end)-  describe('join()', function()-    local function list_join(l, sep, ret)-      local ga = ga_alloc()-      eq(ret or OK, lib.tv_list_join(ga, l, sep))-      if ga.ga_data == nil then return ''-      else return ffi.string(ga.ga_data)+    describe('join()', function()+      local function list_join(l, sep, ret)+        local ga = ga_alloc()+        eq(ret or OK, lib.tv_list_join(ga, l, sep))+        if ga.ga_data == nil then return ''+        else return ffi.string(ga.ga_data)+        end       end-    end-    itp('works', function()-      local l-      l = list('boo', 'far')-      eq('boo far', list_join(l, ' '))-      eq('boofar', list_join(l, ''))--      l = list('boo')-      eq('boo', list_join(l, ' '))--      l = list()-      eq('', list_join(l, ' '))--      l = list({}, 'far')-      eq('{} far', list_join(l, ' '))--      local recursive_list = {}-      recursive_list[1] = recursive_list-      l = ffi.gc(list(recursive_list, 'far'), nil)-      eq('[[...@0]] far', list_join(l, ' '))--      local recursive_l = l.lv_first.li_tv.vval.v_list-      local recursive_li = recursive_l.lv_first-      lib.tv_list_item_remove(recursive_l, recursive_li)-      lib.tv_list_free(l, true)+      itp('works', function()+        local l+        l = list('boo', 'far')+        eq('boo far', list_join(l, ' '))+        eq('boofar', list_join(l, ''))++        l = list('boo')+        eq('boo', list_join(l, ' '))++        l = list()+        eq('', list_join(l, ' '))++        l = list({}, 'far')+        eq('{} far', list_join(l, ' '))++        local recursive_list = {}+        recursive_list[1] = recursive_list+        l = ffi.gc(list(recursive_list, 'far'), nil)+        eq('[[...@0]] far', list_join(l, ' '))++        local recursive_l = l.lv_first.li_tv.vval.v_list+        local recursive_li = recursive_l.lv_first+        lib.tv_list_item_remove(recursive_l, recursive_li)+        lib.tv_list_free(l, true)+      end)+    end)+    describe('equal()', function()+      itp('compares empty and NULL lists correctly', function()+        local l = list()+        local l2 = list()++        -- NULL lists are not equal to empty lists+        eq(false, lib.tv_list_equal(l, nil, true, false))+        eq(false, lib.tv_list_equal(nil, l, false, false))+        eq(false, lib.tv_list_equal(nil, l, false, true))+        eq(false, lib.tv_list_equal(l, nil, true, true))++        -- Yet NULL lists are equal themselves","No. If there is one NULL list then ���NULL list is equal to itself���. If there are ���many��� NULL lists that for some reason can be considered different (semantically in first place, there really can only be a single NULL list) then ���are equal themselves��� because ���different��� lists are compared.Your variant sounds like ���there are many NULL lists, but we are comparing only same lists���. My variant sounds like ���there are many NULL lists, we may be comparing different lists���. I like second variant more then ���there is one NULL list which is compared to itself��� (first variant from this comment) and consider your correction incorrect. Also because there is ���As well as empty lists��� below: both alternative variants make this phrase incorrect (empty lists are compared not only to themselves) and require altering it.",X
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/5436,82040742,2016-10-05T18:36:33Z,src/nvim/tui/tui.c,"@@ -910,12 +910,23 @@ static void fix_terminfo(TUIData *data)   unibi_set_if_empty(ut, unibi_clr_eos, ""\x1b[J""); } -static void flush_buf(UI *ui)+static void flush_buf_raw(UI *ui) {   uv_write_t req;   uv_buf_t buf;   TUIData *data = ui->data; +  buf.base = data->buf;+  buf.len = data->bufpos;+  uv_write(&req, (uv_stream_t *)&data->output_handle, &buf, 1, NULL);+  uv_run(&data->write_loop, UV_RUN_DEFAULT);+  data->bufpos = 0;+}++static void flush_buf(UI *ui)+{+  TUIData *data = ui->data;+   if (!data->busy) {","Since the cursor fiddling is already guarded by a boolean check, we could add a `bool toggle_cursor` parameter to `flush_buf`. IMO that's less awkward than having a ""raw"" variant of the function.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/5396,82166478,2016-10-06T11:22:14Z,test/functional/ui/output_spec.lua,"@@ -39,4 +40,17 @@ describe(""shell command :!"", function()       {3:-- TERMINAL --}                                    |     ]])   end)++  it(""throttles output >~20KB"", function()+    child_session.feed_data("":!for i in $(seq 2 1800); do echo XXXXXXXXXX; done\n"")+    screen:expect([[+      XXXXXXXXXX                                        |+      XXXXXXXXXX                                        |+      XXXXXXXXXX                                        |+      XXXXXXXXXX                                        |+      ..                                                |+      {10:Press ENTER or type command to continue}{1: }          |+      {3:-- TERMINAL --}                                    |","~~This test is a bit fragile, I'm not sure only two dots will appear on all platforms, it depends on the buffer size.~~~~If this is too fragile, I may need to add a function to `screen.lua` that checks for a pattern without asserting the exact screen state.~~ **Update:** Added `any` parameter to `screen:expect()` to allow checking that a partial string appears in the screen state.",X
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/5396,82183147,2016-10-06T13:07:58Z,test/functional/ui/screen.lua,"@@ -207,7 +207,15 @@ function Screen:try_resize(columns, rows)   uimeths.try_resize(columns, rows) end -function Screen:expect(expected, attr_ids, attr_ignore, condition)+-- Asserts that `expected` eventually matches the screen state.+--+-- expected:    Expected screen state (string).+-- attr_ids:    Text attribute definitions.+-- attr_ignore: Ignored text attributes.+-- condition:   Function asserting some arbitrary condition.+-- any:         true: Succeed if `expected` matches ANY screen line(s).+--              false (default): `expected` must match screen exactly.+function Screen:expect(expected, attr_ids, attr_ignore, condition, any)",Added `any` parameter.,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/5410,82364527,2016-10-07T10:23:40Z,src/nvim/api/private/helpers.c,"@@ -368,11 +368,10 @@ static inline void typval_encode_list_start(EncodedData *const edata,                                             const size_t len)   FUNC_ATTR_ALWAYS_INLINE FUNC_ATTR_NONNULL_ALL {-  const Object obj = OBJECT_INIT;   kv_push(edata->stack, ARRAY_OBJ(((Array) {     .capacity = len,     .size = 0,-    .items = xmalloc(len * sizeof(*obj.data.array.items)),+    .items = xmalloc(len * sizeof(*((Object)OBJECT_INIT).data.array.items)),",How about `sizeof(((Object *)NULL)->data.array.items)` ? http://stackoverflow.com/a/3864612/152142,
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/5396,82501458,2016-10-08T12:03:41Z,src/nvim/os/shell.c,"@@ -309,15 +318,134 @@ static void system_data_cb(Stream *stream, RBuffer *buf, size_t count,   dbuf->len += nread; } +/// Tracks output received for the current executing shell command. To avoid+/// flooding the UI, output is periodically skipped and a pulsing ""..."" is+/// shown instead. Tracking depends on the synchronous/blocking nature of "":!"".+//+/// Purpose:+///   1. CTRL-C is more responsive. #1234 #5396+///   2. Improves performance of :! (UI, esp. TUI, is the bottleneck).+///   3. Avoids OOM during long-running, spammy :!.+///+/// Vim does not need this hack because:+///   1. :! in terminal-Vim runs in cooked mode, so CTRL-C is caught by the+///      terminal and raises SIGINT out-of-band.+///   2. :! in terminal-Vim uses a tty (Nvim uses pipes), so commands+///      (e.g. `git grep`) may page themselves.+///+/// @param size Length of data, used with internal state to decide whether+///             output should be skipped. size=0 resets the internal state and+///             returns the previous decision.+///+/// @returns true if output was skipped and pulse was displayed.+///          Returns the previous decision if size=0.+static bool out_data_throttle(size_t size)+{+  static uint64_t   started     = 0;  // Start time of the current throttle.+  static size_t     received    = 0;  // Bytes observed since last throttle.+  static size_t     visit       = 0;  // ""Pulse"" count of the current throttle.+  static size_t     max_visits  = 0;+  static char       pulse_msg[] = { ' ', ' ', ' ', '\0' };++  if (!size) {+    // bool previous_decision = (visit > 0);+    started = received = visit = 0;+    max_visits = 20;+    return true;+  }++  received += size;+  if (received < OUT_DATA_THRESHOLD+      // Display at least the first chunk of output even if it is big.+      || (!started && received < size + 1000)) {+    return false;+  } else if (!visit) {+    started = os_hrtime();+  } else if (visit >= max_visits) {+    uint64_t since = os_hrtime() - started;+    if (since < NS_1_SECOND) {+      // Adjust max_visits based on the current relative performance.+      // Each ""pulse"" period should last >=1 second so that it is perceptible.+      max_visits = (2 * max_visits);+    } else {+      received = visit = 0;+      return false;+    }+  }++  visit++;+  // Pulse ""..."" at the bottom of the screen.+  size_t tick = (visit == max_visits)+                ? 3  // Force all dots ""..."" on last visit.+                : (visit + 1) % 4;+  pulse_msg[0] = (tick == 0) ? ' ' : '.';+  pulse_msg[1] = (tick == 0 || 1 == tick) ? ' ' : '.';+  pulse_msg[2] = (tick == 0 || 1 == tick || 2 == tick) ? ' ' : '.';+  if (visit == 1) {+    screen_del_lines(0, 0, 1, (int)Rows, NULL);+  }+  int lastrow = (int)Rows - 1;+  screen_puts_len((char_u *)pulse_msg, ARRAY_SIZE(pulse_msg), lastrow, 0, 0);+  ui_flush();+  return true;+}++/// Saves or prints a chunk of throttled (skipped) output. Used to ensure the+/// last ~page of output for a shell-command is always displayed.+///+/// Init mode: Resets the internal state.+///   output = NULL+///   size   = 0+/// Print mode: Displays the previous saved data.+///   output = NULL+///   size   = SIZE_MAX+///+/// @param  output  Data to save, or NULL to invoke a special mode.+/// @param  size    Length of `output`.+static void out_data_throttled_save_or_print(char *output, size_t size)+{+#define MAX_CHUNK_SIZE (OUT_DATA_THRESHOLD / 2)+  static char    last_skipped[MAX_CHUNK_SIZE];  // Saved output.+  static size_t  last_skipped_len = 0;++  assert(output != NULL || (size == 0 || size == SIZE_MAX));++  if (output == NULL && size == 0) {          // Init mode+    last_skipped_len = 0;+    return;+  }++  if (output == NULL && size == SIZE_MAX) {   // Print mode+    out_data_append_to_screen(last_skipped, last_skipped_len, false);+    return;+  }++  if (size >= MAX_CHUNK_SIZE) {               // Save mode+    size_t start = size - MAX_CHUNK_SIZE;+    memcpy(last_skipped, output + start, MAX_CHUNK_SIZE);+    last_skipped_len = MAX_CHUNK_SIZE;+  } else if (size > 0) {+    // Length of the old data that can be kept.+    size_t old_keep_len = MAX_CHUNK_SIZE - size;+    size_t old_keep_start = last_skipped_len - old_keep_len;+    // Shift the kept part of the old data to the start.+    memmove(last_skipped, last_skipped + old_keep_start, old_keep_len);+    // Copy the entire new data to the remaining space.+    memcpy(last_skipped + old_keep_len, output, size);+    last_skipped_len = old_keep_len + size;+  }+}+ /// Continue to append data to last screen line. ///-/// @param output       Data to append to screen lines.+/// @param output       Data to append to screen lines, or NULL to append the+///                     last throttled (skipped) output.",`output=NULL`  does not append throttled data.,X
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/5396,82503008,2016-10-08T14:06:24Z,src/nvim/os/shell.c,"@@ -309,15 +318,134 @@ static void system_data_cb(Stream *stream, RBuffer *buf, size_t count,   dbuf->len += nread; } +/// Tracks output received for the current executing shell command. To avoid+/// flooding the UI, output is periodically skipped and a pulsing ""..."" is+/// shown instead. Tracking depends on the synchronous/blocking nature of "":!"".+//+/// Purpose:+///   1. CTRL-C is more responsive. #1234 #5396+///   2. Improves performance of :! (UI, esp. TUI, is the bottleneck).+///   3. Avoids OOM during long-running, spammy :!.+///+/// Vim does not need this hack because:+///   1. :! in terminal-Vim runs in cooked mode, so CTRL-C is caught by the+///      terminal and raises SIGINT out-of-band.+///   2. :! in terminal-Vim uses a tty (Nvim uses pipes), so commands+///      (e.g. `git grep`) may page themselves.+///+/// @param size Length of data, used with internal state to decide whether+///             output should be skipped. size=0 resets the internal state and+///             returns the previous decision.+///+/// @returns true if output was skipped and pulse was displayed.+///          Returns the previous decision if size=0.+static bool out_data_throttle(size_t size)+{+  static uint64_t   started     = 0;  // Start time of the current throttle.+  static size_t     received    = 0;  // Bytes observed since last throttle.+  static size_t     visit       = 0;  // ""Pulse"" count of the current throttle.+  static size_t     max_visits  = 0;+  static char       pulse_msg[] = { ' ', ' ', ' ', '\0' };++  if (!size) {+    // bool previous_decision = (visit > 0);+    started = received = visit = 0;+    max_visits = 20;+    return true;+  }++  received += size;+  if (received < OUT_DATA_THRESHOLD+      // Display at least the first chunk of output even if it is big.+      || (!started && received < size + 1000)) {+    return false;+  } else if (!visit) {+    started = os_hrtime();+  } else if (visit >= max_visits) {+    uint64_t since = os_hrtime() - started;+    if (since < NS_1_SECOND) {+      // Adjust max_visits based on the current relative performance.+      // Each ""pulse"" period should last >=1 second so that it is perceptible.+      max_visits = (2 * max_visits);+    } else {+      received = visit = 0;+      return false;+    }+  }++  visit++;+  // Pulse ""..."" at the bottom of the screen.+  size_t tick = (visit == max_visits)+                ? 3  // Force all dots ""..."" on last visit.+                : (visit + 1) % 4;+  pulse_msg[0] = (tick == 0) ? ' ' : '.';+  pulse_msg[1] = (tick == 0 || 1 == tick) ? ' ' : '.';+  pulse_msg[2] = (tick == 0 || 1 == tick || 2 == tick) ? ' ' : '.';+  if (visit == 1) {+    screen_del_lines(0, 0, 1, (int)Rows, NULL);+  }+  int lastrow = (int)Rows - 1;+  screen_puts_len((char_u *)pulse_msg, ARRAY_SIZE(pulse_msg), lastrow, 0, 0);+  ui_flush();+  return true;+}++/// Saves or prints a chunk of throttled (skipped) output. Used to ensure the+/// last ~page of output for a shell-command is always displayed.+///+/// Init mode: Resets the internal state.+///   output = NULL+///   size   = 0+/// Print mode: Displays the previous saved data.+///   output = NULL+///   size   = SIZE_MAX+///+/// @param  output  Data to save, or NULL to invoke a special mode.+/// @param  size    Length of `output`.+static void out_data_throttled_save_or_print(char *output, size_t size)+{+#define MAX_CHUNK_SIZE (OUT_DATA_THRESHOLD / 2)+  static char    last_skipped[MAX_CHUNK_SIZE];  // Saved output.+  static size_t  last_skipped_len = 0;++  assert(output != NULL || (size == 0 || size == SIZE_MAX));++  if (output == NULL && size == 0) {          // Init mode+    last_skipped_len = 0;+    return;+  }++  if (output == NULL && size == SIZE_MAX) {   // Print mode+    out_data_append_to_screen(last_skipped, last_skipped_len, false);+    return;+  }++  if (size >= MAX_CHUNK_SIZE) {               // Save mode+    size_t start = size - MAX_CHUNK_SIZE;+    memcpy(last_skipped, output + start, MAX_CHUNK_SIZE);+    last_skipped_len = MAX_CHUNK_SIZE;+  } else if (size > 0) {+    // Length of the old data that can be kept.+    size_t old_keep_len = MAX_CHUNK_SIZE - size;+    size_t old_keep_start = last_skipped_len - old_keep_len;","@oni-link Thanks for noticing that, see 07dc5592b2e0b952f9a8aa7d72001eefd073aeb9. This fixed behavior I noticed with certain output patterns.",X
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/5396,82507750,2016-10-08T18:50:03Z,src/nvim/os/shell.c,"@@ -309,15 +318,141 @@ static void system_data_cb(Stream *stream, RBuffer *buf, size_t count,   dbuf->len += nread; } +/// Tracks output received for the current executing shell command, and displays+/// a pulsing ""..."" when output should be skipped. Tracking depends on the+/// synchronous/blocking nature of "":!"".+//+/// Purpose:+///   1. CTRL-C is more responsive. #1234 #5396+///   2. Improves performance of :! (UI, esp. TUI, is the bottleneck).+///   3. Avoids OOM during long-running, spammy :!.+///+/// Vim does not need this hack because:+///   1. :! in terminal-Vim runs in cooked mode, so CTRL-C is caught by the+///      terminal and raises SIGINT out-of-band.+///   2. :! in terminal-Vim uses a tty (Nvim uses pipes), so commands+///      (e.g. `git grep`) may page themselves.+///+/// @param size Length of data, used with internal state to decide whether+///             output should be skipped. size=0 resets the internal state and+///             returns the previous decision.+///+/// @returns true if output should be skipped and pulse was displayed.+///          Returns the previous decision if size=0.+static bool out_data_decide_throttle(size_t size)+{+  static uint64_t   started     = 0;  // Start time of the current throttle.+  static size_t     received    = 0;  // Bytes observed since last throttle.+  static size_t     visit       = 0;  // ""Pulse"" count of the current throttle.+  static size_t     max_visits  = 0;+  static char       pulse_msg[] = { ' ', ' ', ' ', '\0' };++  if (!size) {+    bool previous_decision = (visit > 0);+    started = received = visit = 0;+    max_visits = 20;+    return previous_decision;+  }++  received += size;+  if (received < OUT_DATA_THRESHOLD+      // Display at least the first chunk of output even if it is big.+      || (!started && received < size + 1000)) {+    return false;+  } else if (!visit) {+    started = os_hrtime();+  } else if (visit >= max_visits+             // Gobble up small chunks even if we maxed out. Avoids the case+             // where the final displayed chunk is very tiny.+             && (size > 256 || visit >= max_visits + 20)) {+    uint64_t since = os_hrtime() - started;+    if (since < NS_1_SECOND) {+      // Adjust max_visits based on the current relative performance.+      // Each ""pulse"" period should last >=1 second so that it is perceptible.+      max_visits = (2 * max_visits);+    } else {+      received = visit = 0;+      return false;+    }+  }++  visit++;+  // Pulse ""..."" at the bottom of the screen.+  size_t tick = (visit == max_visits)+                ? 3  // Force all dots ""..."" on last visit.+                : (visit % 4);+  pulse_msg[0] = (tick == 0) ? ' ' : '.';+  pulse_msg[1] = (tick == 0 || 1 == tick) ? ' ' : '.';+  pulse_msg[2] = (tick == 0 || 1 == tick || 2 == tick) ? ' ' : '.';+  if (visit == 1) {+    screen_del_lines(0, 0, 1, (int)Rows, NULL);+  }+  int lastrow = (int)Rows - 1;+  screen_puts_len((char_u *)pulse_msg, ARRAY_SIZE(pulse_msg), lastrow, 0, 0);+  ui_flush();+  return true;+}++/// Saves output in a quasi-ring-buffer. Used to ensure the last ~page of+/// output for a shell-command is always displayed.+///+/// Init mode: Resets the internal state.+///   output = NULL+///   size   = 0+/// Print mode: Displays the current saved data.+///   output = NULL+///   size   = SIZE_MAX+///+/// @param  output  Data to save, or NULL to invoke a special mode.+/// @param  size    Length of `output`.+static void out_data_ring(char *output, size_t size)+{+#define MAX_CHUNK_SIZE (OUT_DATA_THRESHOLD / 2)+  static char    last_skipped[MAX_CHUNK_SIZE];  // Saved output.+  static size_t  last_skipped_len = 0;++  assert(output != NULL || (size == 0 || size == SIZE_MAX));++  if (output == NULL && size == 0) {          // Init mode+    last_skipped_len = 0;+    return;+  }++  if (output == NULL && size == SIZE_MAX) {   // Print mode+    out_data_append_to_screen(last_skipped, last_skipped_len, false);+    return;+  }++  // This is basically a ring-buffer...+  if (size >= MAX_CHUNK_SIZE) {               // Save mode+    size_t start = size - MAX_CHUNK_SIZE;+    memcpy(last_skipped, output + start, MAX_CHUNK_SIZE);+    last_skipped_len = MAX_CHUNK_SIZE;+  } else if (size > 0) {+    // Length of the old data that can be kept.+    size_t keep_len   = (MAX_CHUNK_SIZE - size) > last_skipped_len+                        ? last_skipped_len+                        : (MAX_CHUNK_SIZE - size);+    size_t keep_start = last_skipped_len > keep_len+                        ? last_skipped_len - keep_len+                        : 0;+    // Shift the kept part of the old data to the start.+    memmove(last_skipped, last_skipped + keep_start, keep_len);+    // Copy the entire new data to the remaining space.","This could be written a bit shorter:``` c    size_t keep_len   = MIN(last_skipped_len, MAX_CHUNK_SIZE-size);    size_t keep_start = last_skipped_len - keep_len;    // Shift the kept part of the old data to the start.    if (keep_start) {      memmove(last_skipped, last_skipped + keep_start, keep_len);    }```and making `OUT_DATA_THRESHOLD` unsigned to prevent a compiler warning because of the code change:``` c#define OUT_DATA_THRESHOLD  1024 * 10U       // 10KB, ""a few screenfuls"" of data.```",X
2418402,HarmtH,https://api.github.com/repos/neovim/neovim/pulls/5445,82522153,2016-10-09T13:09:42Z,src/nvim/ex_cmds.c,"@@ -2116,6 +2116,16 @@ do_ecmd (     }   } +  // Make re-editing a terminal buffer a no-op+  if (!other_file && curbuf->terminal != NULL) {+      // this is needed for when we are called by do_argfile() and the new+      // argument index becomes the terminal buffer we are already editing+      check_arg_idx(curwin);+      maketitle();","The title shows the index in the argument list (e.g. (2 of 5)), because we can have switched to a new entry (when this function was called from `do_argfile()`), we need to update the title.",
2418402,HarmtH,https://api.github.com/repos/neovim/neovim/pulls/5445,82522206,2016-10-09T13:12:17Z,src/nvim/ex_cmds.c,"@@ -2116,6 +2116,16 @@ do_ecmd (     }   } +  // Make re-editing a terminal buffer a no-op+  if (!other_file && curbuf->terminal != NULL) {+      // this is needed for when we are called by do_argfile() and the new+      // argument index becomes the terminal buffer we are already editing+      check_arg_idx(curwin);+      maketitle();",Normally the index in the argument list isn't switched when the buffer is not reloaded or changed.,X
112971,jamessan,https://api.github.com/repos/neovim/neovim/pulls/5457,82867714,2016-10-11T19:14:43Z,src/nvim/window.c,"@@ -487,7 +487,7 @@ static void cmd_with_count(char *cmd, char_u *bufp, size_t bufsize,   size_t len = xstrlcpy((char *)bufp, cmd, bufsize);    if (Prenum > 0 && len < bufsize) {-    vim_snprintf((char *)bufp + len, bufsize - len, ""%"" PRId64, Prenum);+    vim_snprintf((char *)bufp + len, bufsize - len, ""%ld"", Prenum);",Just the `Prenum` parameter in the `cmd_with_count` function?  That should be fine.  I'll test it out.,
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/4568,83157831,2016-10-13T07:34:33Z,src/nvim/api/private/defs.h,"@@ -30,10 +30,14 @@ typedef enum {   kMessageTypeNotification } MessageType; -/// Used as the message ID of notifications.+/// Used as response id of notifications. Api methods are allowed to not+/// calculate the return value, as it will be discarded anyway. #define NO_RESPONSE UINT64_MAX -/// Used as channel_id when the call is local+/// Used as response id when the call is local or part of a multi-request.+#define INTERNAL_RESPONSE (UINT64_MAX-1u)","Actually is is not possible for a API method to receive the `response_id` (like it is with the `channel_id`), it is just an always unused argument to `handle_nvim_[method]`. I'll just remove it for now.",
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/5396,83535106,2016-10-15T16:27:37Z,src/nvim/os/shell.c,"@@ -309,15 +318,140 @@ static void system_data_cb(Stream *stream, RBuffer *buf, size_t count,   dbuf->len += nread; } +/// Tracks output received for the current executing shell command, and displays+/// a pulsing ""..."" when output should be skipped. Tracking depends on the+/// synchronous/blocking nature of "":!"".+//+/// Purpose:+///   1. CTRL-C is more responsive. #1234 #5396+///   2. Improves performance of :! (UI, esp. TUI, is the bottleneck).+///   3. Avoids OOM during long-running, spammy :!.+///+/// Vim does not need this hack because:+///   1. :! in terminal-Vim runs in cooked mode, so CTRL-C is caught by the+///      terminal and raises SIGINT out-of-band.+///   2. :! in terminal-Vim uses a tty (Nvim uses pipes), so commands+///      (e.g. `git grep`) may page themselves.+///+/// @param size Length of data, used with internal state to decide whether+///             output should be skipped. size=0 resets the internal state and+///             returns the previous decision.+///+/// @returns true if output should be skipped and pulse was displayed.+///          Returns the previous decision if size=0.+static bool out_data_decide_throttle(size_t size)+{+  static uint64_t   started     = 0;  // Start time of the current throttle.+  static size_t     received    = 0;  // Bytes observed since last throttle.+  static size_t     visit       = 0;  // ""Pulse"" count of the current throttle.+  static size_t     max_visits  = 0;+  static char       pulse_msg[] = { ' ', ' ', ' ', '\0' };++  if (!size) {+    bool previous_decision = (visit > 0);+    started = received = visit = 0;+    max_visits = 20;+    return previous_decision;+  }++  received += size;+  if (received < OUT_DATA_THRESHOLD+      // Display at least the first chunk of output even if it is big.+      || (!started && received < size + 1000)) {+    return false;+  } else if (!visit) {+    started = os_hrtime();+  } else if (visit >= max_visits && size < 256 && max_visits < 999) {+    // Gobble up small chunks even if we maxed out. Avoids the case where the+    // final displayed chunk is very tiny.+    max_visits = visit + 1;+  } else if (visit >= max_visits) {+    uint64_t since = os_hrtime() - started;+    if (since < NS_1_SECOND) {+      // Adjust max_visits based on the current relative performance.+      // Each ""pulse"" period should last >=1 second so that it is perceptible.+      max_visits = (2 * max_visits);+    } else {+      received = visit = 0;+      return false;+    }+  }","If I use this script,``` bash#!/bin/bash# Produce enough output to reach the tresholdfor i in {1..10000}do    echo ""1: $i""done# Produce every second small chunk of outputfor i in {1..1000}do    echo ""2: $i""    sleep 1done```the only output I see is:```(cut out)1: 12531: 1254...   <- this is pulsing```With `max_visits` big it can take some time until  `visit>=max_visits` and output is shown.Would have expected to see small chunks of output if they are slow.",X
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/5450,83559617,2016-10-16T20:35:58Z,src/nvim/charset.c,"@@ -1740,11 +1760,15 @@ char_u* skiptowhite_esc(char_u *p) { /// @return Number read from the string. intmax_t getdigits(char_u **pp) {-  errno = 0;-  intmax_t number = strtoimax((char *)*pp, (char **)pp, 10);-  if (number == INTMAX_MAX || number == INTMAX_MIN) {-    assert(errno != ERANGE);-  }+  int ret;+  intmax_t number;++  ret = getdigits_safe(pp, &number);++  // prevent ""unused variable"" warning if we are not doing a debug build+  (void) ret;+  assert(ret == 0);","to avoid the unused variable warning, could do instead``` cif (ret != 0) {    abort();}```",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/5450,83560222,2016-10-16T21:04:13Z,src/nvim/charset.c,"@@ -1732,6 +1732,26 @@ char_u* skiptowhite_esc(char_u *p) {   return p; } +/// Get a number from a string and skip over it, signalling overflows+///+/// @param[out]  pp  A pointer to a pointer to char_u.+///                  It will be advanced past the read number.+/// @param[out]  nr  Number read from the string.+///+/// @return 0 on success, -1 on error+int getdigits_safe(char_u **pp, intmax_t *nr)+{+  errno = 0;+  *nr = strtoimax((char *)(*pp), (char **)pp, 10);++  if ((*nr == INTMAX_MIN || *nr == INTMAX_MAX)+      && errno == ERANGE) {+    return -1;+  }++  return 0;","OK/FAIL/NOTDONE (from `vim.h`) is not a boolean, any objection to that? Most important is to try to keep the pattern the same. OK=1, if we return 0 in some places to mean ""ok"", that can be unsettling.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/5386,83585108,2016-10-17T06:51:02Z,test/functional/eval/api_functions_spec.lua,"@@ -1,11 +1,33 @@ local helpers = require('test.functional.helpers')(after_each) local Screen = require('test.functional.ui.screen') local lfs = require('lfs')+local mpack = require('mpack') local neq, eq, execute = helpers.neq, helpers.eq, helpers.execute local clear, curbufmeths = helpers.clear, helpers.curbufmeths local exc_exec, expect, eval = helpers.exc_exec, helpers.expect, helpers.eval local insert = helpers.insert +local read_mpack_file = function(fname)+  local fd = io.open(fname, 'rb')+  local data = fd:read('*a')+  fd:close()+  local unpack = mpack.Unpacker()+  return unpack(data)+end++-- ignore metadata in API function spec+local remove_function_metadata = function(fspec)+  fspec['can_fail'] = nil","`can_fail` `async`, `recieves_channel_id` are now gone from public metadata and don't need to be removed here here. `since` and `method` shouldn't change, so these should not be removed.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/5386,83585466,2016-10-17T06:55:45Z,test/functional/eval/api_functions_spec.lua,"@@ -1,11 +1,33 @@ local helpers = require('test.functional.helpers')(after_each) local Screen = require('test.functional.ui.screen') local lfs = require('lfs')+local mpack = require('mpack') local neq, eq, execute = helpers.neq, helpers.eq, helpers.execute local clear, curbufmeths = helpers.clear, helpers.curbufmeths local exc_exec, expect, eval = helpers.exc_exec, helpers.expect, helpers.eval local insert = helpers.insert +local read_mpack_file = function(fname)","I think all these additions does not belong in `eval/`, rather in `api/vim_spec.lua` or perhaps better a new `api/compatibility_spec.lua` .",X
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/5386,83605022,2016-10-17T09:20:47Z,test/functional/eval/api_functions_spec.lua,"@@ -1,11 +1,33 @@ local helpers = require('test.functional.helpers')(after_each) local Screen = require('test.functional.ui.screen') local lfs = require('lfs')+local mpack = require('mpack') local neq, eq, execute = helpers.neq, helpers.eq, helpers.execute local clear, curbufmeths = helpers.clear, helpers.curbufmeths local exc_exec, expect, eval = helpers.exc_exec, helpers.expect, helpers.eval local insert = helpers.insert +local read_mpack_file = function(fname)+  local fd = io.open(fname, 'rb')+  local data = fd:read('*a')+  fd:close()+  local unpack = mpack.Unpacker()+  return unpack(data)+end++-- ignore metadata in API function spec+local remove_function_metadata = function(fspec)+  fspec['can_fail'] = nil","Is it really worth keeping 0.mpack then if we just ignore the differences to 1.mpack?  Seems better then to just test at release of level 1 that no changes are done to the level-0 methods, in they keys we decided to keep. The fact that these are present in 1.mpack should be enough to fail the test if the methods are later changed in level-2 (or removed without bumping `compatibility`).We are considering it an allowed breaking change if some client relied on the now removed keys from the 0.1.5 metadata. So level 0 does not really mean ""the api/metadata as released at 0.1.5"", rather it simply means all the methods that were deprecated already at the first well-specified`*` and versioned release of the api metadata, which is level 1. `*` A remaining TODO is of course to add some documentation for the keys to the docs.",X
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/5495,83649747,2016-10-17T14:04:55Z,src/nvim/window.c,"@@ -506,11 +506,23 @@ static void cmd_with_count(char *cmd, char_u *bufp, size_t bufsize,  *  * return FAIL for failure, OK otherwise  */-int win_split(int size, int flags)+int win_split(int size, int flags) {",Is this called in too many places to add the parameter directly to it?,X
112971,jamessan,https://api.github.com/repos/neovim/neovim/pulls/5450,84310427,2016-10-20T15:33:51Z,src/nvim/buffer.c,"@@ -4528,16 +4528,20 @@ chk_modeline (           e = s + 4;         else           e = s + 3;-        vers = getdigits_int(&e);+        if (getdigits_safe(&e, &vers) < 0) {","This is a change in behavior from Vim.  This causes nvim to skip the modeline entirely, where as Vim ends up getting `vers = -1` since it downcasts the long to an int and then uses that in the comparison on line 4539.  The comparison succeeds and the modeline is set.Now, one can question whether that's the correct behavior for Vim (and I would suggest bringing it up there), but that still leaves open how nvim should behave.  I'm in favor of ignoring the modeline, since I think it's better to be overcautious with modelines, but we should also be aware of and intentional about places where we deviate in behavior from Vim.",X
112971,jamessan,https://api.github.com/repos/neovim/neovim/pulls/5487,84311422,2016-10-20T15:38:02Z,src/nvim/window.c,"@@ -3768,8 +3769,18 @@ win_free (   hash_init(&wp->w_vars->dv_hashtab);   unref_var_dict(wp->w_vars); -  if (prevwin == wp)-    prevwin = NULL;+  {+    tabpage_T *ttp;++    if (prevwin == wp) {+      prevwin = NULL;+    }+    for (ttp = first_tabpage; ttp != NULL; ttp = ttp->tp_next) {",Can you use the `FOR_ALL_TABS` macro here?  That avoids duplication of the tab page logic and the extra block just for declaring ttp.,X
715238,equalsraf,https://api.github.com/repos/neovim/neovim/pulls/5386,84676793,2016-10-24T12:35:49Z,test/functional/eval/api_functions_spec.lua,"@@ -1,11 +1,33 @@ local helpers = require('test.functional.helpers')(after_each) local Screen = require('test.functional.ui.screen') local lfs = require('lfs')+local mpack = require('mpack') local neq, eq, execute = helpers.neq, helpers.eq, helpers.execute local clear, curbufmeths = helpers.clear, helpers.curbufmeths local exc_exec, expect, eval = helpers.exc_exec, helpers.expect, helpers.eval local insert = helpers.insert +local read_mpack_file = function(fname)+  local fd = io.open(fname, 'rb')+  local data = fd:read('*a')+  fd:close()+  local unpack = mpack.Unpacker()+  return unpack(data)+end++-- ignore metadata in API function spec+local remove_function_metadata = function(fspec)+  fspec['can_fail'] = nil","> and versioned release of the api metadata, which is level 1.True, but dont have a 1.mpack yet.> A remaining TODO is of course to add some documentation for the keys to the docs.Added a couple quick mentions in the docs.",
1690608,phanimahesh,https://api.github.com/repos/neovim/neovim/pulls/5533,85063133,2016-10-26T07:29:50Z,src/nvim/buffer.c,"@@ -4610,6 +4618,25 @@ chk_modeline ( }  /*+ * checks the modeline is not longer","Use  `//` style only for newly added comments, and lines immediately surrounding any changes introduced. Run clint to get the list of changes required.The codebase is littered with `/* ...*/` style comments and updating all of them at once will make git-blaming very difficult, hence this policy was chosen to update things incrementally.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/5450,85094999,2016-10-26T10:40:23Z,src/nvim/buffer.c,"@@ -4528,16 +4528,20 @@ chk_modeline (           e = s + 4;         else           e = s + 3;-        vers = getdigits_int(&e);+        if (getdigits_safe(&e, &vers) < 0) {","I agree the modeline should be ignored, because most likely in that case it was not intended to be a modeline (or it's intended to be a very large version which will never match).",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/5543,85639548,2016-10-29T12:40:49Z,test/functional/shada/marks_spec.lua,"@@ -104,7 +104,7 @@ describe('ShaDa support code', function()    it('is able to dump and read back mark "" from a closed tab', function()     nvim_command('edit ' .. testfilename)-    nvim_command('edit ' .. testfilename_2)+    nvim_command('tabedit ' .. testfilename_2)     nvim_command('2')     nvim_command('q!')     nvim_command('qall')","From our discussion:- This `nvim_command()` request is being sent to a dead session. In general, the `helpers` methods silently fail if the session is dead. `eq(2, eval('1 + 1'))` is an explicit way to detect a dead session. But we should change lua-client and/or the lua test helpers to be more vocal about this situation.- On the debian infrastructure the tests died here, and that's how this was found. We don't know why it behaves differently on that machine.",X
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/5269,85660861,2016-10-30T14:25:16Z,src/nvim/eval.c,"@@ -10583,6 +10583,7 @@ static void f_has(typval_T *argvars, typval_T *rettv, FunPtr fptr)     ""linebreak"",     ""lispindent"",     ""listcmds"",+    ""liveupdate"",","Normally we don't add named features for new nvim-specific features, as nvim will always be compiled with all features (with a few exceptions). Instead a plugin should check for the thing the feature adds, an api function in this case. This is possible in principle by inspecting the api metadata, but maybe we should make this simpler by overloading `exist()` (`exist('+')` does not work as not all api functions are vimL functions, like this won't be).",X
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/5550,85697661,2016-10-31T08:18:00Z,src/nvim/api/private/helpers.c,"@@ -615,15 +615,34 @@ bool object_to_vim(Object obj, typval_T *tv, Error *err)     case kObjectTypeBuffer:     case kObjectTypeWindow:     case kObjectTypeTabpage:-    case kObjectTypeInteger:-      if (obj.data.integer > INT_MAX || obj.data.integer < INT_MIN) {+    case kObjectTypeInteger: {",can't we just always store the handle as int64 in the `obj.data` union and then add casts as necessary? (most cases are already be handled by `gendispatch.lua`),
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/5550,85888267,2016-11-01T08:10:20Z,src/nvim/api/private/helpers.c,"@@ -615,15 +615,34 @@ bool object_to_vim(Object obj, typval_T *tv, Error *err)     case kObjectTypeBuffer:     case kObjectTypeWindow:     case kObjectTypeTabpage:-    case kObjectTypeInteger:-      if (obj.data.integer > INT_MAX || obj.data.integer < INT_MIN) {+    case kObjectTypeInteger: {","How is it more invasive? As I said the common case is already handled in `gendispatch.lua` like this: `(handle_T)data.integer`. It is also safer: a problem like this fixes could easily be silently introduced again by another PR later without warning, while the compiler would give a warning when a cast is missing or pointer types become incompatible (which will happen for `msgpack_rpc_to_X` in `msgpack_rpc/helpers.c`)Isn't having just one integer size in the union, at least per signedness (even if the discriminator distinguishes between types with different _logical_ sizes) standard practice to avoid extra checking like this? msgpack-c does it at least.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/2905,85934075,2016-11-01T14:05:35Z,runtime/doc/mbyte.txt,"@@ -70,29 +70,24 @@ See |mbyte-locale| for details.  ENCODING -If your locale works properly, Vim will try to set the 'encoding' option-accordingly.  If this doesn't work you can overrule its value: >+Nvim always uses UTF-8 internally. Thus 'encoding' option is always set+to ""utf-8"" and cannot be changed. -	:set encoding=utf-8+All the text that is used inside Vim will be in UTF-8. Not only the text in+the buffers, but also in registers, variables, etc. -See |encoding-values| for a list of acceptable values.--The result is that all the text that is used inside Vim will be in this-encoding.  Not only the text in the buffers, but also in registers, variables,-etc. 'encoding' is read-only after startup because changing it would make the-existing text invalid.--You can edit files in another encoding than what 'encoding' is set to.  Vim+You can edit files in different encodings than UTF-8.  Nvim will convert the file when you read it and convert it back when you write it. See 'fileencoding', 'fileencodings' and |++enc|.   DISPLAY AND FONTS -If you are working in a terminal (emulator) you must make sure it accepts the-same encoding as which Vim is working with.+If you are working in a terminal (emulator) you must make sure it accepts+UTF-8, the encoding which Vim is working with. Otherwise only ASCII can","I thought we punted 'termencoding' long ago. As for wording, it could be tightened up:```If you are working in a terminal (emulator) it must accept UTF-8. |'encoding'|```",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/2905,85934841,2016-11-01T14:09:08Z,runtime/doc/mbyte.txt,"@@ -70,29 +70,24 @@ See |mbyte-locale| for details.  ENCODING -If your locale works properly, Vim will try to set the 'encoding' option-accordingly.  If this doesn't work you can overrule its value: >+Nvim always uses UTF-8 internally. Thus 'encoding' option is always set+to ""utf-8"" and cannot be changed. -	:set encoding=utf-8+All the text that is used inside Vim will be in UTF-8. Not only the text in+the buffers, but also in registers, variables, etc. -See |encoding-values| for a list of acceptable values.--The result is that all the text that is used inside Vim will be in this-encoding.  Not only the text in the buffers, but also in registers, variables,-etc. 'encoding' is read-only after startup because changing it would make the-existing text invalid.--You can edit files in another encoding than what 'encoding' is set to.  Vim+You can edit files in different encodings than UTF-8.  Nvim will convert the file when you read it and convert it back when you write it. See 'fileencoding', 'fileencodings' and |++enc|.   DISPLAY AND FONTS -If you are working in a terminal (emulator) you must make sure it accepts the-same encoding as which Vim is working with.+If you are working in a terminal (emulator) you must make sure it accepts+UTF-8, the encoding which Vim is working with. Otherwise only ASCII can","It is not odd, it just adds relevant information. `'termencoding'`was removed #2631 a while ago, and was non-functional even longer before (since the first big tui refactor, I think). Given the complete lack of complaints of the form ""nvim is broken in my latin1 terminal!"" since we stopped detecting `'encoding'` from the envirionment, I don't think adding it back will be neccessary.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/5269,85936821,2016-11-01T14:19:16Z,src/nvim/api/dispatch_deprecated.lua,"@@ -7,6 +7,7 @@ local deprecated_aliases = {   nvim_buf_get_number=""buffer_get_number"",   nvim_buf_get_option=""buffer_get_option"",   nvim_buf_get_var=""buffer_get_var"",+  nvim_buf_live_updates=""buffer_live_updates"",","No, this is for older functions that was part of 0.1.5 as 0.1.6 changed the naming convention and this has nothing to be backwards-compatible to. python-client 0.1.11 will be released soon, well before this is merged. But we will need to add helper functions in python-client to make it feasible to use this in rplugins (if different python plugins subscribe to the same buffer).",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/5226,86111465,2016-11-02T10:31:17Z,src/nvim/buffer.c,"@@ -1458,7 +1460,9 @@ buflist_new (     }     lastbuf = buf; -    buf->b_fnum = top_file_num++;+    // If bufnr is nonzero it is assumed to be a previously+    // reserved buffer number (handle)+    buf->handle = bufnr != 0 ? bufnr : top_file_num++;","~~`buf->b_fnum` is no longer being set, that doesn't seem right?~~ oh, `->handle` is `#define`'d to `->b_fnum`.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/5226,86111573,2016-11-02T10:32:01Z,src/nvim/buffer.c,"@@ -1335,11 +1336,12 @@ void do_autochdir(void) static int top_file_num = 1;            /* highest file number */  buf_T *-buflist_new (-    char_u *ffname,            /* full path of fname or relative */-    char_u *sfname,            /* short fname or NULL */-    linenr_T lnum,                  /* preferred cursor line */-    int flags                      /* BLN_ defines */+buflist_new(+    char_u *ffname,            // full path of fname or relative+    char_u *sfname,            // short fname or NULL+    linenr_T lnum,             // preferred cursor line+    int flags,                 // BLN_ defines+    handle_T bufnr","~~instead of this, was there discussion about maybe using `BLN_DUMMY`? (still investigating this myself)~~ Can we instead use the same `ffname` every time, so that `buflist_new()` finds the same existing incsub buffer?Hmm, even `q:` and `:copen` use a new bufnr each time. ",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/5226,86111979,2016-11-02T10:34:14Z,src/nvim/ex_cmds.c,"@@ -64,6 +65,12 @@  */ typedef struct sign sign_T; +// boolean to know if inc_sub needs to undo+static bool inc_sub_did_changes = false;++// reuse the same bufnr for inc_sub+static handle_T inc_sub_bufnr = 0;","~~Is this to ""save"" buffer numbers, or avoid re-creation of a new buffer? I'm wondering if `BLN_DUMMY` can be used, and maybe don't worry about saving buffer numbers.~~Can we instead use the same `ffname` every time, so that `buflist_new()` finds the same existing incsub buffer?",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/5226,86119904,2016-11-02T11:23:25Z,src/nvim/buffer.c,"@@ -1335,11 +1336,12 @@ void do_autochdir(void) static int top_file_num = 1;            /* highest file number */  buf_T *-buflist_new (-    char_u *ffname,            /* full path of fname or relative */-    char_u *sfname,            /* short fname or NULL */-    linenr_T lnum,                  /* preferred cursor line */-    int flags                      /* BLN_ defines */+buflist_new(+    char_u *ffname,            // full path of fname or relative+    char_u *sfname,            // short fname or NULL+    linenr_T lnum,             // preferred cursor line+    int flags,                 // BLN_ defines+    handle_T bufnr","> Can we instead use the same ffname every time, so that buflist_new() finds the same existing incsub buffer?No we wipe the buffer when we're done. If the buffer exists then the user could mess up the buffer by changing settings etc until the next time.> Hmm, even q: and :copen use a new bufnr each time.but ""each time"" is a lot more often for incsub, almost every keypress after `:%s`.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/5226,86136866,2016-11-02T13:11:13Z,src/nvim/buffer.c,"@@ -1335,11 +1336,12 @@ void do_autochdir(void) static int top_file_num = 1;            /* highest file number */  buf_T *-buflist_new (-    char_u *ffname,            /* full path of fname or relative */-    char_u *sfname,            /* short fname or NULL */-    linenr_T lnum,                  /* preferred cursor line */-    int flags                      /* BLN_ defines */+buflist_new(+    char_u *ffname,            // full path of fname or relative+    char_u *sfname,            // short fname or NULL+    linenr_T lnum,             // preferred cursor line+    int flags,                 // BLN_ defines+    handle_T bufnr","Hacking around, it looks like the code can be simplified a good amount by ""not worrying"" about the user accidentally editing this special buffer. I'd like to try to solve that more general problem rather than add the special cases for incsub buffer. There is already some internal notion in Vim for ""special buffers"", which we maybe can extend and formalize a bit instead of adding new parameters.Tests are passing, I'll push a PR on top of this PR later today.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/5557,86142997,2016-11-02T13:43:43Z,runtime/autoload/health/provider.vim,"@@ -53,7 +53,7 @@ function! s:check_clipboard() abort   if empty(clipboard_tool)     call health#report_warn(           \ ""No clipboard tool found. Using the system clipboard won't work."",-          \ ['See "":help clipboard""'])+          \ ['See |clipboard|.'])",Another case is here: https://github.com/mhinz/neovim/blob/d982c2ab9f2555b6f8827c951d952f19a2b823a6/runtime/autoload/provider/pythonx.vim#L124That can show up in CheckHealth as well as regular error message. Maybe use `substitute()` to wrap it in bars?,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/5557,86193361,2016-11-02T17:09:45Z,runtime/autoload/health.vim,"@@ -9,13 +9,20 @@ function! s:enhance_syntax() abort   highlight link healthInfo ModeMsg    syntax keyword healthSuccess SUCCESS-  highlight link healthSuccess Function+  highlight link healthSuccess ModeMsg    syntax keyword healthSuggestion SUGGESTIONS   highlight link healthSuggestion String +  syntax match healthHelp ""|.\{-}|"" contains=healthBar+  syntax match healthBar  ""|"" contained conceal+  highlight link healthHelp Identifier+   "" We do not care about markdown syntax errors in :CheckHealth output.   highlight! link markdownError Normal++  "" We don't need code blocks.+  syntax clear markdownCodeBlock","> The `\|` above is a orOh dear, I was in ""flags"" mode when I looked at that pattern. Sorry for the noise.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/5561,86656152,2016-11-05T02:18:12Z,src/nvim/buffer.c,"@@ -5263,18 +5263,14 @@ wipe_buffer ( /// /// @param bufnr    Switch to this buffer if it exists. If 0, a new buffer is ///                 always created.-buf_T *buf_get_special(handle_T bufnr, char *bufname, char *buftype)+buf_T *buf_open_special(handle_T bufnr, char *bufname, char *buftype) {   win_T     *save_curwin = NULL;   tabpage_T *save_curtab = NULL;-  buf_T     *save_curbuf = NULL;                                            \+  buf_T     *save_curbuf = NULL;   buf_T     *buf         = NULL; -  if (bufnr && (buf = buflist_findnr(bufnr))) {  // switch to existing buffer-    switch_to_win_for_buf(buf, &save_curwin, &save_curtab, &save_curbuf);-  } else {  // create new-    (void)do_ecmd((int)bufnr, NULL, NULL, NULL, ECMD_ONE, ECMD_HIDE, NULL);-  }+  (void)do_ecmd((int)bufnr, NULL, NULL, NULL, ECMD_ONE, ECMD_HIDE, NULL);",This seems to work fine when combined with `setlocal bufhidden=hide` to prevent unloading the buffer.The `switch_to_win_for_buf()` approach caused a double-free and other invalid access pain arising from some unknown interaction where the fragile order-of-operations for buffer creation/re-use falls apart.,X
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/5269,86954681,2016-11-08T09:48:10Z,runtime/doc/msgpack_rpc.txt,"@@ -413,4 +413,162 @@ of update. 	The popupmenu is hidden.  ==============================================================================+7. Live Updates				      *live-updates* *rpc-live-updates*++A dedicated API has been created to allow co-processes to be notified in+real-time when the user changes a buffer in any way. (It is difficult and+innefficient to do this using |TextChanged| and other autocommands.)++							*live-updates-enabling*+Setting Up~++Use |jobstart()| to start up your co-process. >","The norm will be that these will be used through the rplugin infrastructure, that allows multiple remote plugins to share a single python process (and similarly for other languages, like ruby), and therefore `jobstart()` should not be mentioned here (it shouldn't be anyway, as this part is already explain earlier in the same file) Even for a plugin than wants its own process I think the norm should be to use the host infractucture, which will manage event dispatch for the plugin instead of relying on `next_message()` (or an hypotetical `poll_message()`), this will obviously make it easier also to change the plugin to share the host later, if the need for a separate process later is removed.",X
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/5582,87441543,2016-11-10T17:15:49Z,test/functional/ui/inccommand_spec.lua,"@@ -727,11 +727,11 @@ describe("":substitute, inccommand=split"", function()      feed(""x"")     screen:expect([[-      xo lines                      |       Inc substitution on           |       xo lines                      |","Reason for this change: Because the cursor started on the last line (after `insert()` in `common_setup()`), the temporary split (preview) bumps the visible lines. This didn't happen before because the `show_sub()` logic left the cursor on line 1--it wasn't restoring after preview.",X
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/4031,87883235,2016-11-14T20:14:49Z,src/nvim/tag.c,"@@ -1019,8 +1017,9 @@ static void prepare_pats(pat_T *pats, int has_re)         if (vim_strchr((char_u *)(p_magic ? "".[~*\\$"" : ""\\$""),                 pats->head[pats->headlen]) != NULL)           break;-    if (p_tl != 0 && pats->headlen > p_tl)      /* adjust for 'taglength' */-      pats->headlen = p_tl;+    if (p_tl != 0 && pats->headlen > (size_t)p_tl) {  // adjust for ""taglength""","Given that the purpose of the Wconversion changes is to avoid conversion mistakes, I think also changing lengths to `size_t` is an unncessary risk, especially where we have to cast signed values like this which may then result in a bad comparison.E.g. `:set tl=-1` is actually accepted. But that will cause this comparison to do something different than Vim, and then we have a time-consuming bug to track down.Similar problem caused bugs like [this](https://github.com/neovim/neovim/commit/2a6c5bb0c4b03a9da81dae64d37c9912e448eaf0).So, please leave the `size_t` changes out of the `-Wconversion` PRs except for cases that are more localized (not interacting with `p_foo` or other **user-facing** global values).",X
448087,jszakmeister,https://api.github.com/repos/neovim/neovim/pulls/5620,88333602,2016-11-16T21:22:44Z,src/nvim/po/CMakeLists.txt,"@@ -48,7 +48,7 @@ if(HAVE_WORKING_LIBINTL AND GETTEXT_FOUND AND XGETTEXT_PRG AND ICONV_PRG)         -DXGETTEXT_PRG=${XGETTEXT_PRG}         -DPOT_FILE=${NVIM_POT}         -DSEARCH_DIR=${CMAKE_CURRENT_SOURCE_DIR}-        ""'-DSOURCES=${NEOVIM_RELATIVE_SOURCES}'""+        ""\""-DSOURCES=${NEOVIM_RELATIVE_SOURCES}\""""","Yes, that's right... there's embedded semicolons due to it being a list, and without the quotes, the shell will treat the extra files as commands.  Nevermind.  What you have is good. :-)",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/5595,88673918,2016-11-18T15:12:02Z,src/nvim/shada.c,"@@ -1688,7 +1688,11 @@ static ShaDaWriteResult shada_pack_entry(msgpack_packer *const packer,           ? 0           : entry.data.sub_string.additional_elements->lv_len);       msgpack_pack_array(spacker, arr_size);-      PACK_BIN(cstr_as_string(entry.data.sub_string.sub));+      if (entry.data.sub_string.sub) {+        PACK_BIN(cstr_as_string(entry.data.sub_string.sub));+      } else {+        PACK_BIN(((String){ """", 0 }));","I wonder if this logic better in the `PACK_BIN` to cover all/future cases. Can really the sub string be NULL but not the search pattern, for instance? In principle the `msgpack_pack_bin_body()` in `PACK_BIN` could be guarded with `if (s_.size > 0)` as there is no data to write, the header is written by the `pack_bin()` above. ( This will have the right ""semantics""  in that nonzero size + NULL pointer will still be a crash).",X
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/5640,89005867,2016-11-21T22:41:31Z,src/nvim/edit.c,"@@ -606,7 +606,10 @@ static int insert_execute(VimState *state, int key)   s->c = key;    // Don't want K_EVENT with cursorhold for the second key, e.g., after CTRL-V.-  did_cursorhold = true;+  // but not in CTRL-X mode, a script can't restore the state //+  if (ctrl_x_mode == 0) {+    did_cursorhold = true;","This is not applicable for Nvim.  We always set `did_cursorhold = true` above, unconditionally.",
911252,Hinidu,https://api.github.com/repos/neovim/neovim/pulls/5266,90128298,2016-11-29T22:21:48Z,src/nvim/lib/kbtree.h,"@@ -0,0 +1,396 @@+#ifndef __AC_KBTREE_H","I'm not the lawyer but it looks illegal to use this source code without the original [copyright](https://github.com/attractivechaos/klib/blob/master/kbtree.h#L1-L26). For example [khash.h](https://github.com/neovim/neovim/blob/master/src/nvim/lib/khash.h), [klist.h](https://github.com/neovim/neovim/blob/master/src/nvim/lib/klist.h) and [kvec.h](https://github.com/neovim/neovim/blob/master/src/nvim/lib/kvec.h) have their respective copyrights.",
6589866,brcolow,https://api.github.com/repos/neovim/neovim/pulls/243,90141784,2016-11-29T23:49:24Z,src/nvim/viml/executor/vim.lua,"@@ -0,0 +1,2296 @@+-- {{{1 Record existing globals for testing+local copy_table = function(tbl)+  local new_tbl = {}+  for k, v in pairs(tbl) do+    new_tbl[k] = v+  end+  return new_tbl+end++local globals_at_start = copy_table(_G)+local recorded_vim_global = nil++-- {{{1 Global declarations+local err+local op+local vim_type+local is_func, is_dict, is_list, is_float+local repr+local iter+local scalar, container+local number, string, list, dict, float, func+local bound_func+local scope, def_scope, b_scope, a_scope, v_scope, f_scope+local state, assign+local subscript+local scope_name_idx, length_idx, type_idx, locks_idx, val_idx+local BASE_TYPE_NUMBER, BASE_TYPE_STRING, BASE_TYPE_FUNCREF, BASE_TYPE_LIST+local BASE_TYPE_DICTIONARY, BASE_TYPE_FLOAT+local get_number, get_float, get_string, get_boolean+local get_cmp_t+-- {{{1 Utility functions+local unpack = unpack or table.unpack++local get_local_option = function(state, other, name)+  return other.options[name] or state.options[name]+end++local non_nil = function(wrapped)+  return function(state, ...)+    for i = 1,select('#', ...) do+      if select(i, ...) == nil then+        return nil+      end+    end+    return wrapped(state, ...)+  end+end++local join_tables = function(tbl1, tbl2)+  local ret = {}+  for k, v in pairs(tbl1) do+    ret[k] = v+  end+  for k, v in pairs(tbl2) do+    ret[k] = v+  end+  return ret+end++local print_table+print_table = function(tbl, indent, printed)+  for k, v in pairs(tbl) do+    print(('%s%-20s: %s'):format(indent, tostring(k), tostring(v)))+    if type(v) == 'table' and not printed[v] then+      printed[v] = true+      print_table(v, indent .. '  ', printed)+    end+  end+end++local compare_tables_recursive+compare_tables_recursive = function(tbl1, tbl2)+  for k, _ in pairs(tbl1) do+    if tbl2[k] == nil then+      return true, 'missing2', k+    end+  end+  for k, v in pairs(tbl2) do+    if tbl1[k] == nil then+      return true, 'missing1', k+    end+    if tbl1[k] ~= v then+      if type(v) == 'table' then+        if type(tbl1[k]) ~= 'table' then+          return true, 'differs', k+        else+          local differs, what, key, diff = compare_tables_recursive(tbl1[k], v)+          if differs then+            return true, what, tostring(k) .. '/' .. tostring(key), diff+          end+        end+      else+        return true, 'differs', k, (tostring(tbl1[k]) .. '~=' .. tostring(v))+      end+    end+  end+  return false, nil, nil+end++-- {{{1 State manipulations+local new_script_scope = function(state)+  return scope:new(state, 's')+end++local top++state = {+  new = function()+    local state = {+      -- values that need to be altered when entering/exiting some scopes+      is_trying = false,+      abort = false,+      is_silent = false,+      a = nil,+      l = nil,+      sid = nil,+      current_scope = nil,+      call_stack = {},+      exception = '',+      throwpoint = '',+      code = nil,+      fname = nil,+    }+    -- Values that do not need to be altered when exiting scope.+    state.global = {+      options = {},+      buffer = {b = b_scope:new(state), options = {}},+      window = {w = scope:new(state, 'w'), options = {}},+      tabpage = {t = scope:new(state, 't')},+      registers = {},+      v = v_scope:new(state),+      g = def_scope:new(state, 'g'),+      user_functions = f_scope:new(state),+      user_commands = {},+    }+    state.current_scope = state.global.g+    return state+  end,++  get_top = function()+    if top == nil then+      top = state:new()+    end+    return top+  end,++  enter_try = function(old_state)+    local state = copy_table(old_state)+    state.is_trying = true+    return state+  end,++  enter_catch = function(old_state, err)+    local state = copy_table(old_state)+    local etype, fname, lnr, exception = err:match('^%z(.-)%z(.-)%z(.-)%z(.*)$')+    assert(etype == 'exception')+    state.exception = exception+    if fname:sub(1, 1) == '<' then+      state.throwpoint = ''+    else+      state.throwpoint = fname .. ', line ' .. lnr+    end+    return state+  end,++  enter_function = function(old_state, self, fcall, abort)+    local state = copy_table(old_state)+    state.a = a_scope:new(state)+    state.l = def_scope:new(state, 'l')+    state.l.self = self+    state.current_scope = state.l+    state.call_stack = copy_table(state.call_stack)+    state.abort = abort+    table.insert(state.call_stack, fcall)+    return state+  end,++  enter_script = function(old_state, s, sid)+    local state = copy_table(old_state)+    state.s = s+    state.sid = sid+    return state+  end,++  enter_code = function(old_state, code, fname)+    local state = copy_table(old_state)+    state.code = code+    state.fname = fname+    return state+  end,+}++-- {{{1 Functions returning specific types+get_number = function(state, val, position)+  local t = vim_type(val)+  return t.as_number(state, val, position)+end++get_string = function(state, val, position)+  local t = vim_type(val)+  return t.as_string(state, val, position)+end++get_float = function(state, val, position)+  local t = vim_type(val)+  return (t.as_float or t.as_number)(state, val, position)+end++get_boolean = function(state, val, position)+  local num = get_number(state, val, position)+  return num and num ~= 0+end++repr = function(state, val, val_position, for_echo, refs)+  if not val then+    return nil+  end+  local t = vim_type(val)+  if t.container then+    if refs[val] then+      if for_echo then+        return t.already_represented_container+      else+        err.err(state, val_position, true,+                'E724: Recursive data type detected')+        -- Despite the error Vim string() still returns something+        return '{E724}'+      end+    else+      refs[val] = true+    end+  end+  return t.repr(state, val, val_position, for_echo, refs)+end++iter = function(state, lst, lst_position)+  local t = vim_type(lst)+  return t.next, t.new_it_state(state, lst, lst_position), lst+end++-- {{{1 Types+-- {{{2 Related constants+-- Special values that cannot be assigned from VimL+type_idx = true+locks_idx = false+val_idx = 0+scope_name_idx = -1+length_idx = -2++BASE_TYPE_NUMBER     = 0+BASE_TYPE_STRING     = 1+BASE_TYPE_FUNCREF    = 2+BASE_TYPE_LIST       = 3+BASE_TYPE_DICTIONARY = 4+BASE_TYPE_FLOAT      = 5++local VAR_LOCKED = 1+local VAR_FIXED = 2++local IDX_GET   = 0+local IDX_SLICE = 1+local IDX_UNLET = 2++-- {{{2 Utility functions+local add_type_table = function(func)+  return function(self, ...)+    local ret = func(...)+    if ret then+      ret[type_idx] = self+    end+    return ret+  end+end++local num_convert_2 = function(func, converter)+  return function(state, val1, val1_position, val2, val2_position)+    local n1 = converter(state, val1, val1_position)+    if n1 == nil then+      return nil+    end+    local n2 = converter(state, val2, val2_position)+    if n2 == nil then+      return nil+    end+    return func(n1, n2)+  end+end++-- From https://mail.python.org/pipermail/python-dev/2003-October/039445.html+local bisimilar_tables = function(ic, tbl1, tbl2, is_dict)+  local bisim = {}+  local pending_last = {}+  local consider = function(val1, val2, is_dict)+    if bisim[val1] then+      if bisim[val1][val2] then+        return nil+      else+        bisim[val1][val2] = true+      end+    else+      bisim[val1] = {[val2]=true}+    end+    pending_last.next = {val1=val1, val2=val2, is_dict=is_dict, next=nil}+    pending_last = pending_last.next+  end+  local consider_new = function(v1, v2)+    if v1 == v2 then+      -- Do not bother comparing same lists or dictionaries+      return true+    end+    local t1 = vim_type(v1)+    local t2 = vim_type(v2)+    if t1.type_number ~= t2.type_number then+      return false+    elseif t1.container then+      consider(v1, v2, t1.type_number == BASE_TYPE_DICTIONARY)+      return true+    else+      return get_cmp_t(t1, t2).raw_cmp(ic, v1, v2) == 0+    end+  end+  if tbl1 == tbl2 then+    -- Do not bother comparing same lists or dictionaries+    return true+  end+  consider(tbl1, tbl2, is_dict)+  local pending = pending_last+  while pending do+    local val1 = pending.val1+    local val2 = pending.val2+    if pending.is_dict then+      for k, _ in pairs(val2) do+        if type(k) == 'string' then+          if val1[k] == nil then+            return false+          end+        end+      end+      for k, v1 in pairs(val1) do+        if type(k) == 'string' then+          local v2 = val2[k]+          if v2 == nil then+            return false+          end+          if not consider_new(v1, v2) then+            return false+          end+        end+      end+    else+      if val1.length ~= val2.length then+        return false+      end+      for i = 1,val1.length do+        if not consider_new(val1[i], val2[i]) then+          return false+        end+      end+    end+    pending = pending.next+  end+  return true+end++local copymethods = {+  [type_idx] = function(v)+    return v+  end,+  [locks_idx] = function(v)+    return {}+  end,+}++local copy_value = function(val, copymethods)+  if type(val) ~= 'table' then+    return val+  end+  local ret = {}+  local copied = {[val]=ret}+  local tocopy = {table=val, ret=ret, next=nil}+  local tocopy_last = tocopy+  while tocopy do+    local cur_tbl = tocopy.table+    local cur_ret = tocopy.ret+    for k, v in pairs(cur_tbl) do+      if type(v) ~= 'table' then+        cur_ret[k] = v+      elseif copymethods[k] then+        cur_ret[k] = copymethods[k](v)+      elseif copied[v] then+        cur_ret[k] = copied[v]+      else+        local new_ret = {}+        cur_ret[k] = new_ret+        copied[v] = new_ret+        tocopy_last.next = {table=v, ret=new_ret, next=nil}+        tocopy_last = tocopy_last.next+      end+    end+    tocopy = tocopy.next+  end+  return ret+end++-- {{{2 Any type base+local type_base = {+-- {{{3 Support for iterations+  next = function(_, _)+    return nil+  end,+  new_it_state = function(state, lst, lst_position)+    return err.err(state, lst_position, true, 'E714: List required')+  end,+-- {{{3 Querying support+  call = function(state, fun, fun_position, ...)+    return err.err(state, fun_position, true, 'E15: Can only call a Funcref')+  end,+  get_slice_indicies = function(state, length, idx_type, get_index,+                                idx1, idx1_position,+                                idx2, idx2_position)+    idx1 = get_index(state, length, idx1, idx1_position, idx_type)+    if idx1 == nil then+      return nil, nil+    end+    idx2 = get_index(state, length, idx2, idx2_position, idx_type)+    if idx2 == nil then+      return nil, nil+    end+    if idx_type == IDX_UNLET then+      if idx1 > length then+        return err.err(state, idx1_position, true,+                       'E684: List index out of range: %i', idx1 - 1), nil+      end+      if idx2 < 1 then+        return err.err(state, idx2_position, true,+                       'E684: List index out of range: %i',+                       idx1 - length - 1), nil+      end+      if idx1 > idx2 then+        return err.err(state, idx1_position, true,+                       'E684: First index is greater than the second'), nil+      end+      if idx2 > length then+        idx2 = length+      end+      if idx1 < 1 then+        idx1 = 1+      end+    end+    return idx1, idx2+  end,+-- }}}3+}++-- {{{2 Scalar type base+scalar = join_tables(type_base, {+-- {{{3 Assignment support+  assign_subscript = function(state, val, val_position, ...)+    return err.err(state, val_position, true,+                   'E689: Can only index a List or Dictionary')+  end,+  assign_subscript_function = function(state, unique, val, val_position, ...)+    return scalar.assign_subscript(state, val, val_position, ...)+  end,+  assign_slice = function(state, val, val_position, ...)+    return scalar.assign_subscript(state, val, val_position, ...)+  end,+  delete_subscript = function(state, val, val_position, ...)+    return scalar.assign_subscript(state, val, val_position, ...)+  end,+  delete_slice = function(state, val, val_position, ...)+    return scalar.assign_subscript(state, val, val_position, ...)+  end,+-- {{{3 Querying support+  subscript = function(state, val, val_position, idx, idx_position)+    local str = get_string(state, val, val_position)+    if str == nil then+      return nil+    end+    local idx = scalar.get_index(state, #str, idx, idx_position, IDX_GET)+    if idx == nil then+      return nil+    end+    return str:sub(idx, idx)+  end,+  get_index = function(state, length, idx, idx_position, idx_type)+    local ret = get_number(state, idx, idx_position)+    if idx_type == IDX_GET then+      if ret < 0 then+        -- When string.sub receives (0, 0) as argument it returns empty string+        return 0+      else+        return ret + 1+      end+    else+      ret = ret < 0 and ret + length + 1 or ret + 1+      if ret <= 0 then+        return false+      end+      return ret+    end+  end,+  slice = function(state, val, val_position, ...)+    local str = get_string(state, val, val_position)+    if str == nil then+      return nil+    end+    local idx1, idx2 = scalar.get_slice_indicies(state, #str, IDX_SLICE,+                                                 scalar.get_index, ...)+    if idx1 == nil then+      return nil+    elseif idx1 == false or idx2 == false then+      return ''+    else+      return str:sub(idx1, idx2)+    end+  end,+-- {{{3 string()+  container = false,+-- {{{3 Locks support+  set_container_lock = function(...)+  end,+  set_key_lock = function(state, depth, t, val, val_position, key, key_position,+                          lock)+    return scalar.assign_subscript(state, val, val_position)+  end,+  set_slice_lock = function(state, depth, t, val, val_position,+                                             idx1, idx1_position,+                                             idx2, idx1_position)+    return scalar.assign_subscript(state, val, val_position)+  end,+-- {{{3 Operators support+  num_op_priority = 1,+  add = num_convert_2(function(n1, n2)+    return n1 + n2+  end, get_number),+  subtract = num_convert_2(function(n1, n2)+    return n1 - n2+  end, get_number),+  multiply = num_convert_2(function(n1, n2)+    return n1 * n2+  end, get_number),+  divide = num_convert_2(function(n1, n2)+    if n2 == 0 then+      -- According to :h expr-/+      if n1 == 0 then+        return -0x80000000+      elseif n1 > 0 then+        return  0x7fffffff+      else+        return -0x7fffffff+      end+    else+      local ret = n1 / n2+      return math.floor(math.abs(ret)) * ((ret >= 0) and 1 or -1)+    end+  end, get_number),+  modulo = num_convert_2(function(n1, n2)+    if n2 == 0 then+      return 0+    end+    return (n1 % n2) * ((n1 < 0 and -1 or 1) * (n2 < 0 and -1 or 1))+  end, get_number),+  negate = function(state, val, val_position)+    local n = get_number(state, val, val_position)+    return n and -n+  end,+  promote_integer = get_number,+-- }}}3+})++scalar.mod_add = scalar.add++-- {{{2 Container type base+local numop = function(state, val1, val1_position, val2, val2_position)+  -- One of the following calls must fail for container type+  return (get_float(state, val1, val1_position)+          and get_float(state, val2, val2_position))+end++container = join_tables(type_base, {+-- {{{3 string()+  container = true,+-- {{{3 Locks support+  check_container_lock = function(state, t, val, val_position, key)+    if val[locks_idx][locks_idx] then+      local message+      if val[locks_idx][locks_idx] == VAR_FIXED then+        -- Note: only scope dictionaries may have fixed keys or be fixed +        -- themselves. Thus container does not have ""fixed_message"" or +        -- ""fixed_dict_message"" keys.+        message = t.fixed_dict_message+      else+        message = 'E741: Value is locked: %s'+      end+      if type(key) == 'number' then+        key = key - 1+      end+      return  err.err(state, val_position, true, message, key)+    end+    return true+  end,+  check_key_lock = function(state, t, val, key, key_position)+    if val[locks_idx][key] then+      local message+      if val[locks_idx][key] == VAR_FIXED then+        message = t.fixed_message+      else+        message = 'E741: Value is locked: %s'+      end+      if type(key) == 'number' then+        key = key - 1+      end+      return err.err(state, key_position, true, message, key)+    end+    return true+  end,+  check_locks = function(state, t, val, val_position, key, key_position)+    local is_locked, new_key+    if val[key] then+      -- When trying to add a new key check whether container itself is locked.+      return t.check_key_lock(state, t, val, key, key_position), false+    else+      -- When trying to overwrite existing value check whether specific value is +      -- locked.+      return t.check_container_lock(state, t, val, val_position, key), true+    end+  end,+  set_key_lock = function(state, depth, t, val, val_position, key, key_position,+                          lock)+    if not val[key] then+      return true+    end+    if val[locks_idx][key] ~= VAR_FIXED then+      val[locks_idx][key] = lock+    end+    vim_type(val[key]).set_container_lock(state, depth, val[key], lock, {})+    return true+  end,+-- {{{3 Copy support+  copy = function(val)+    local ret = copy_table(val)+    ret[locks_idx] = {}+    return ret+  end,+-- {{{3 Operators support+  num_op_priority = 10,+  add = numop,+  subtract = numop,+  multiply = numop,+  divide = numop,+  modulo = numop,+  negate = numop,+  promote_integer = numop,+-- }}}3+})++container.mod_add = container.add++-- {{{2 Basic types+-- {{{3 Number+number = join_tables(scalar, {+  type_number = BASE_TYPE_NUMBER,+-- {{{4 string()+  repr = function(state, num, num_position, for_echo, refs)+    return (('%i'):format(num))+  end,+-- {{{4 Type conversions+  as_number = function(state, num, num_position)+    return num+  end,+  as_string = function(state, num, num_position)+    return tostring(num)+  end,+  as_float = function(state, num, num_position)+    return num+  end,+-- {{{4 Operators support+  cmp_priority = 1,+  raw_cmp = function(ic, n1, n2)+    return (n1 > n2 and 1) or ((n1 == n2 and 0) or -1)+  end,+  cmp = function(state, ic, eq, val1, val1_position, val2, val2_position)+    local n1 = get_number(state, val1, val1_position)+    if n1 == nil then+      return nil+    end+    local n2 = get_number(state, val2, val2_position)+    if n2 == nil then+      return nil+    end+    return number.raw_cmp(ic, n1, n2)+  end,+  negate = function(state, num, num_position)+    return -num+  end,+  promote_integer = function(state, num, num_position)+    return num+  end,+-- }}}4+})++-- {{{3 String+string = join_tables(scalar, {+  type_number = BASE_TYPE_STRING,+-- {{{4 string()+  repr = function(state, str, str_position, for_echo, refs)+    if for_echo == true then+      return str+    else+      return ""'"" .. str:gsub(""'"", ""''"") .. ""'""+    end+  end,+-- {{{4 Type conversions+  as_number = function(state, str, str_position)+    return tonumber(str:match('^%-?0[xX]%x+')) or+           tonumber(str:match('^%-?%d+')) or+           0+  end,+  as_string = function(state, str, str_position)+    return str+  end,+  as_float = function(state, num, num_position)+    return num+  end,+-- {{{4 Operators support+  cmp_priority = 0,+  raw_cmp = function(ic, s1, s2)+    if ic then+      return stricmp(s1, s2)+    else+      return (s1 > s2 and 1) or ((s1 == s2 and 0) or -1)+    end+  end,+  cmp = function(state, ic, eq, val1, val1_position, val2, val2_position)+    local s1 = get_string(state, val1, val1_position)+    if s1 == nil then+      return nil+    end+    local s2 = get_string(state, val2, val2_position)+    if s2 == nil then+      return nil+    end+    return string.raw_cmp(ic, s1, s2)+  end,+-- }}}4+})++-- {{{3 List+list = join_tables(container, {+-- {{{4 New+  type_number = BASE_TYPE_LIST,+  new = add_type_table(function(state, ...)+    return {[locks_idx]={}, length=select('#', ...), iterators={}, ...}+  end),+-- {{{4 Modification support+  insert = function(state, lst, lst_position, idx, idx_position,+                           val, val_position)+    local idx = list.get_index(state, lst.length, idx, idx_position, IDX_GET)+    if idx == nil then+      return nil+    end+    local t = vim_type(lst)+    if not t.check_container_lock(state, t, lst, lst_position, idx) then+      return nil+    end+    local locks = lst[locks_idx]+    for i = lst.length,idx,-1 do+      lst[i + 1] = lst[i]+      locks[i + 1] = locks[i]+    end+    lst[idx] = val+    locks[idx] = nil+  end,+  append = function(state, lst, lst_position, val, val_position)+    local t = vim_type(lst)+    if not t.check_container_lock(state, t, lst, lst_position, -1) then+      return nil+    end+    lst[lst.length + 1] = val+    lst.length = lst.length + 1+  end,+-- {{{4 Assignment support+  assign_subscript = function(state, lst, lst_position, idx, idx_position, val)+    local idx = list.get_index(state, lst.length, idx, idx_position, IDX_GET)+    if idx == nil then+      return nil+    end+    local t = vim_type(lst)+    -- When performing regular assignment lock on specific item is not ignored.+    if not t.check_locks(state, t, lst, lst_position, idx, idx_position) then+      return nil+    end+    lst[idx] = val+    return true+  end,+  assign_slice = function(state, lst,  lst_position,+                                 idx1, idx1_position,+                                 idx2, idx2_position,+                                 val)+    -- FIXME Use val position in error messages+    if not is_list(val) then+      if is_func(val) and lst_position:sub(-9) == ':function' then+        return err.err(state, lst_position, true,+                       'E475: Cannot assign function to a slice')+      else+        return err.err(state, lst_position, true,+                       'E709: [:] requires a List value')+      end+    end+    local idx1, idx2 = list.get_slice_indicies(+      state, lst.length, IDX_GET, list.get_index,+      idx1, idx1_position,+      idx2, idx2_position+    )+    if idx1 == nil then+      return nil+    end+    local t = vim_type(lst)+    if not t.check_container_lock(state, t, lst, lst_position, idx1) then+      return nil+    end+    local tgt_length = idx2 - idx1 + 1+    -- FIXME Use val position in error messages+    if val.length < tgt_length then+      return err.err(state, lst_position, true,+                     'E711: List value has not enough items')+    elseif val.length > tgt_length then+      return err.err(state, lst_position, true,+                     'E710: List value has too many items')+    end+    local locks = lst[locks_idx]+    for i = idx1,idx2 do+      lst[i] = val[i - idx1 + 1]+      -- When performing slice assignment locks on specific items are ignored +      -- (may be a bug though). Lock on the whole list is not.+      locks[i] = nil+    end+    return true+  end,+  delete_slice = function(state, lst, lst_position, idx1, idx1_position,+                                                    idx2, idx2_position)+    local idx1, idx2 = list.get_slice_indicies(+      state, lst.length, IDX_UNLET, list.get_index,+      idx1, idx1_position,+      idx2, idx2_position+    )+    if idx1 == nil then+      return nil+    end+    local slicelen = idx2 - idx1 + 1+    local movelen = lst.length - idx2+    local locks = lst[locks_idx]+    for i = 1,movelen do+      lst[idx1 + i - 1] = lst[idx2 + i]+      locks[idx1 + i - 1] = locks[idx1 + i]+      lst[idx2 + i] = nil+      locks[idx2 + i] = nil+    end+    for i = idx1+movelen,idx2 do+      lst[i] = nil+      locks[i] = nil+    end+    lst.length = lst.length - slicelen+    return true+  end,+-- {{{4 Querying support+  get_index = function(state, length, idx, idx_position, idx_type)+    local ret = get_number(state, idx, idx_position)+    ret = ret < 0 and ret + length + 1 or ret + 1+    if idx_type == IDX_GET and (ret > length or ret <= 0) then+      return err.err(state, idx_position, true,+                     'E684: List index out of range: %i', idx)+    end+    return ret+  end,+  subscript = function(state, lst, lst_position, idx, idx_position)+    local length = lst.length+    local idx = list.get_index(state, length, idx, idx_position, IDX_GET)+    return lst[idx]+  end,+  slice = function(state, lst, lst_position, ...)+    local length = lst.length+    local idx1, idx2 = list.get_slice_indicies(state, length, IDX_SLICE,+                                               list.get_index, ...)+    if idx1 == nil then+      return nil+    end+    local ret = list:new(state)+    if idx1 > idx2 or idx1 > length or idx1 <= 0 then+      return ret+    elseif idx2 > length then+      idx2 = length+    end+    for i = idx1,idx2 do+      ret[i - idx1 + 1] = lst[i]+    end+    return ret+  end,+  raw_slice_to_end = function(lst, idx)+    local ret = list:new(state)+    for i = idx,lst.length do+      ret[i - idx + 1] = lst[i]+    end+    ret.length = lst.length - idx + 1+    return ret+  end,+-- {{{4 Support for iterations+  next = function(it_state, _)+    local i = it_state.i+    if i >= it_state.maxi then+      return nil+    end+    it_state.i = it_state.i + 1+    return i, it_state.lst[i + 1]+  end,+  new_it_state = function(state, lst, lst_position)+    local it_state = {+      i = 0,+      maxi = lst.length,+      lst = lst,+    }+    table.insert(lst.iterators, it_state)+    return it_state+  end,+-- {{{4 string()+  already_represented_container = '[...]',+  repr = function(state, lst, lst_position, for_echo, refs)+    local ret = '['+    local length = lst.length+    local add_comma = false+    for i = 1,length do+      if add_comma then+        ret = ret .. ', '+      else+        add_comma = true+      end+      local chunk = repr(state, lst[i], lst_position, for_echo and 'list', refs)+      if chunk == nil then+        return nil+      end+      ret = ret .. chunk+    end+    ret = ret .. ']'+    return ret+  end,+-- {{{4 Type conversions+  as_number = function(state, lst, lst_position)+    return err.err(state, lst_position, true, 'E745: Using List as a Number')+  end,+  as_string = function(state, lst, lst_position)+    return err.err(state, lst_position, true, 'E730: Using List as a String')+  end,+-- {{{4 Locks support+  set_container_lock = function(state, depth, lst, lock, already_set)+    -- lock may be either nil or VAR_LOCKED+    if already_set[lst] then+      return+    end+    already_set[lst] = true+    local locks = lst[locks_idx]+    if not depth or depth > 1 then+      for i = 1,lst.length do+        local v = lst[i]+        if locks[i] ~= VAR_FIXED then+          locks[i] = lock+        end+        local t = vim_type(v)+        t.set_container_lock(state, depth and depth - 1, v, lock, already_set)+      end+    end+    if locks[locks_idx] ~= VAR_FIXED then+      locks[locks_idx] = lock+    end+  end,+  set_slice_lock = function(state, depth, t, lst, lst_position,+                                             idx1, idx1_position,+                                             idx2, idx2_position, lock)+    local idx1, idx2 = list.get_slice_indicies(+      state, lst.length, IDX_UNLET, list.get_index,+      idx1, idx1_position,+      idx2, idx2_position+    )+    if idx1 == nil then+      return nil+    end+    local already_set = {}+    for i = idx1,idx2 do+      lst[locks_idx][i] = lock+      local v = lst[i]+      vim_type(v).set_container_lock(state, depth, v, lock, already_set)+    end+    return true+  end,+-- {{{4 Operators support+  cmp_priority = 10,+  cmp = function(state, ic, eq, val1, val1_position, val2, val2_position)+    if not (is_list(val1) and is_list(val2)) then+      return err.err(state, val2_position, true,+                     'E691: Can only compare List with List')+    elseif not eq then+      return err.err(state, val1_position, true,+                     'E692: Invalid operation for Lists')+    end+    return bisimilar_tables(ic, val1, val2, false) and 0 or 1+  end,+  num_op_priority = 3,+  do_add = function(state, copy_ret, val1, val1_position, val2, val2_position)+    if not (is_list(val1) and is_list(val2)) then+      -- Error out+      if is_list(val1) then+        return list.as_number(state, val1, val1_position)+      else+        return list.as_number(state, val2, val2_position)+      end+    end+    if not copy_ret then+      local t = vim_type(val1)+      if not list.check_container_lock(state, t, val1, val1_position, nil) then+        return nil+      end+    end+    local length1 = val1.length+    local ret = copy_ret and copy_table(val1) or val1+    for i, v in ipairs(val2) do+      ret[length1 + i] = v+    end+    ret.length = length1 + val2.length+    return ret+  end,+  add = function(state, ...)+    return list.do_add(state, true, ...)+  end,+  mod_add = function(state, ...)+    return list.do_add(state, false, ...)+  end,+-- }}}4+})++-- {{{3 Dictionary+dict = join_tables(container, {+-- {{{4 New+  type_number = BASE_TYPE_DICTIONARY,+  can_be_self = true,+  new = add_type_table(function(state, ...)+    if select('#', ...) % 2 ~= 0 then+      return err.err(state, position, true,+                     'Internal error: odd number of arguments to dict:new')+    end+    local ret = {[length_idx]=select('#', ...)/2, [locks_idx]={}}+    for i = 1,ret[length_idx] do+      local key = select(2*i - 1, ...)+      local val = select(2*i, ...)+      if not (key and val) then+        return nil+      end+      ret[get_string(state, key)] = val+    end+    return ret+  end),+-- {{{4 Modification support+-- {{{4 Assignment support+  assign_subscript = function(state, dct, dct_position, key, key_position, val)+    if key == '' then+      return err.err(state, key_position, true,+                     'E713: Cannot use empty key for dictionary')",This was changed in https://github.com/vim/vim/commit/0921ecff1c5a74541bad6c073e8ade32247403d8,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/5651,90429010,2016-12-01T11:29:32Z,src/nvim/eval.c,"@@ -17769,6 +17771,8 @@ void set_vcount(long count, long count1, int set_prevcount) /// @param[in]  val  Value to set to. void set_vim_var_nr(const VimVarIndex idx, const varnumber_T val) {+  clear_tv(&vimvars[idx].vv_tv);+  vimvars[idx].vv_type = VAR_NUMBER;",similar change needed in `set_vim_var_special`,X
112971,jamessan,https://api.github.com/repos/neovim/neovim/pulls/5488,91302217,2016-12-07T14:24:50Z,test/functional/ui/mouse_spec.lua,"@@ -153,7 +153,8 @@ describe('Mouse input', function()     end)      it('in tabline to the left moves tab left', function()-      if os.getenv(""TRAVIS"") and helpers.os_name() == ""osx"" then+      if os.getenv(""TRAVIS"") and (helpers.os_name() == ""osx""",How about having a general way to disable flaky checks and then have .travis.yml export an environment variable under these conditions to cause the flaky tests to be disabled?  That would also allow me to disable the flaky tests on some of the more touchy Debian buildds.,X
112971,jamessan,https://api.github.com/repos/neovim/neovim/pulls/5488,91302253,2016-12-07T14:25:02Z,test/functional/ui/mouse_spec.lua,"@@ -153,7 +153,8 @@ describe('Mouse input', function()     end)      it('in tabline to the left moves tab left', function()-      if os.getenv(""TRAVIS"") and helpers.os_name() == ""osx"" then+      if os.getenv(""TRAVIS"") and (helpers.os_name() == ""osx""+          or os.getenv(""CLANG_SANITIZER"") == ""ASAN_UBSAN"") then         pending(""[Fails on Travis macOS. #4874]"", function() end)",The message is no longer accurate.,X
41495,Shougo,https://api.github.com/repos/neovim/neovim/pulls/5640,91631669,2016-12-08T23:32:40Z,src/nvim/testdir/test_autocmd.vim,"@@ -6,3 +6,20 @@ func Test_vim_did_enter()   "" This script will never reach the main loop, can't check if v:vim_did_enter   "" becomes one. endfunc++if !has('timers')+  finish+endif++func ExitInsertMode(id)+  call feedkeys(""\<Esc>"")+endfunc++func Test_cursorhold_insert()+  let g:triggered = 0+  au CursorHoldI * let g:triggered += 1+  set updatetime=20+  call timer_start(100, 'ExitInsertMode')+  call feedkeys('a', 'x!')+  call assert_equal(1, g:triggered)+endfunc","> This is not applicable for Nvim. We always set `did_cursorhold = true` above, unconditionally.So, I think it is NA.",X
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/5734,91834958,2016-12-10T13:06:31Z,runtime/autoload/man.vim,"@@ -67,14 +67,51 @@ function! man#read_page(ref) abort   call s:read_page(path) endfunction +"" Handler for s:system() function.+function! s:system_handler(jobid, data, event) abort+  if a:event == 'stdout' || a:event == 'stderr'","we want to ignore stderr for man.vim, right? So that should be removed from the condition",X
10180857,nhooyr,https://api.github.com/repos/neovim/neovim/pulls/5734,91839038,2016-12-10T17:39:46Z,runtime/autoload/man.vim,"@@ -71,16 +65,56 @@ function! man#read_page(ref) abort   call s:read_page(path) endfunction +"" Handler for s:system() function.+function! s:system_handler(jobid, data, event) abort+  if a:event == 'stdout'+    let self.output .= join(a:data, ""\n"")+  elseif a:event == 'exit'+    let s:shell_error = a:data+  endif+endfunction++"" Run a system command and timeout after 30 seconds.+function! s:system(cmd, ...) abort+  let stdin = a:0 ? a:1 : ''+  let opts = {+        \ 'output': '',+        \ 'on_stdout': function('s:system_handler'),+        \ 'on_exit': function('s:system_handler'),+        \ }+  let jobid = jobstart(a:cmd, opts)++  if jobid < 1+    throw printf('Command error %d: %s', jobid, +        \ type(a:cmd) == type([]) ? join(a:cmd) : a:cmd)+  endif++  if !empty(stdin)+    call jobsend(jobid, stdin)+  endif++  let res = jobwait([jobid], 30000)+  if res[0] == -1+    call jobstop(jobid)+    throw printf('Command timed out: %s',+        \ type(a:cmd) == type([]) ? join(a:cmd) : a:cmd)","No need to handle this either (here, below and above) because we are only going to send a list as the command.",X
10180857,nhooyr,https://api.github.com/repos/neovim/neovim/pulls/5734,91864477,2016-12-11T20:32:05Z,runtime/autoload/man.vim,"@@ -112,7 +154,7 @@ endfunction  function! s:get_path(sect, name) abort   if empty(a:sect)-    let path = system(s:man_cmd.' '.s:man_find_arg.' '.shellescape(a:name))+    let path = s:system(['man', s:man_find_arg, a:name])     if path !~# '^\/'","We shouldn't need this anymore, s:system() will throw an exception because man's error status will be non zero if it does not find a manpage.",X
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/5737,91868801,2016-12-11T23:20:53Z,src/nvim/path.c,"@@ -407,8 +407,9 @@ void add_pathsep(char *p) /// @param fname is the filename to save /// @param force is a flag to expand `fname` even if it looks absolute ///-/// @return [allocated] Copy of absolute path to `fname` or NULL when-///                     `fname` is NULL.+/// @return [allocated]+///   - Copy of absolute path to `fname` (truncated if longer than MAXPATHL)+///   - NULL when `fname` is NULL or `vim_FullName()` fails","We can't return NULL for failure, for reason mentioned in https://github.com/neovim/neovim/pull/5737#discussion_r91745980. Some call sites _expect_ the full, un-expanded path to be returned. We could examine all the calls to FullName_save(), but that could be a big refactor project, and would entail replacing `FullName_save()` with a new function so that we don't get confused when merging patches from Vim.",X
24446350,ooora,https://api.github.com/repos/neovim/neovim/pulls/5734,91887593,2016-12-12T06:10:35Z,runtime/autoload/man.vim,"@@ -57,30 +53,70 @@ function! man#open_page(count, count1, mods, ...) abort     noautocmd execute 'silent' a:mods 'split' fnameescape(bufname)   endif   let b:man_sect = sect-  call s:read_page(path)+  call s:put_page(page) endfunction  function! man#read_page(ref) abort   try     let [sect, name] = man#extract_sect_and_name_ref(a:ref)     let [b:man_sect, name, path] = s:verify_exists(sect, name)+    let page = s:get_page(path)   catch     "" call to s:error() is unnecessary     return   endtry-  call s:read_page(path)+  call s:put_page(page)+endfunction++"" Handler for s:system() function.+function! s:system_handler(jobid, data, event) abort+  if a:event == 'stdout'+    let self.stdout .= join(a:data, ""\n"")+  elseif a:event == 'stderr'+    let self.stderr .= join(a:data, ""\n"")+  else+    let s:shell_error = a:data+  endif endfunction -function! s:read_page(path) abort+"" Run a system command and timeout after 30 seconds.+function! s:system(cmd, ...) abort+  let opts = {+        \ 'stdout': '',+        \ 'stderr': '',+        \ 'on_stdout': function('s:system_handler'),",I would leave it the same function. If we where doing more complex handling then sure.,
112971,jamessan,https://api.github.com/repos/neovim/neovim/pulls/5734,92097135,2016-12-13T04:41:39Z,runtime/autoload/man.vim,"@@ -57,30 +53,75 @@ function! man#open_page(count, count1, mods, ...) abort     noautocmd execute 'silent' a:mods 'split' fnameescape(bufname)   endif   let b:man_sect = sect-  call s:read_page(path)+  call s:put_page(page) endfunction  function! man#read_page(ref) abort   try     let [sect, name] = man#extract_sect_and_name_ref(a:ref)     let [b:man_sect, name, path] = s:verify_exists(sect, name)+    let page = s:get_page(path)   catch     "" call to s:error() is unnecessary     return   endtry-  call s:read_page(path)+  call s:put_page(page) endfunction -function! s:read_page(path) abort+"" Handler for s:system() function.+function! s:system_handler(jobid, data, event) abort","This should be `function! s:system_handler(jobid, data, event) dict abort`.  The `dict` is required as of the partials patch merge.",X
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/5737,92275102,2016-12-13T21:53:23Z,src/nvim/path.c,"@@ -1650,29 +1646,37 @@ bool vim_isAbsName(char_u *name) /// Save absolute file name to ""buf[len]"". /// /// @param      fname is the filename to evaluate-/// @param[out] buf   is the buffer for returning the absolute path for `fname`+/// @param[out] buf   is the buffer for returning:+///                     - `fname` truncated if longer than `len`+///                     - `fname` if `fname` is a URL+///                     - the absolute path for `fname`+///                     - `fname` if getting the absolute path fails /// @param      len   is the length of `buf` /// @param      force is a flag to force expanding even if the path is absolute /// /// @return           FAIL for failure, OK otherwise int vim_FullName(const char *fname, char *buf, size_t len, bool force)   FUNC_ATTR_NONNULL_ARG(2) {-  int retval = OK;-  int url;-   *buf = NUL;   if (fname == NULL)     return FAIL; -  url = path_with_url(fname);-  if (!url)-    retval = path_get_absolute_path((char_u *)fname, (char_u *)buf, len, force);-  if (url || retval == FAIL) {-    /* something failed; use the file name (truncate when too long) */+  if (strlen(fname) > (len - 1)) {+    // use the truncated filename     xstrlcpy(buf, fname, len);+    return FAIL;   }-  return retval;++  if (path_with_url(fname)) {+    xstrlcpy(buf, fname, len);+  } else if (path_get_absolute_path((char_u *)fname, (char_u *)buf, len, force)+             == FAIL) {+      // something failed; use the filename+      xstrlcpy(buf, fname, len);","There are now 3 paths in this function that return `xstrlcpy(buf, fname, len);`. Seems like the old approach of assigning a `retval` saves duplication, and is arguably clearer.",X
4928168,nfnty,https://api.github.com/repos/neovim/neovim/pulls/5737,92294059,2016-12-13T23:49:21Z,src/nvim/path.c,"@@ -1650,29 +1646,37 @@ bool vim_isAbsName(char_u *name) /// Save absolute file name to ""buf[len]"". /// /// @param      fname is the filename to evaluate-/// @param[out] buf   is the buffer for returning the absolute path for `fname`+/// @param[out] buf   is the buffer for returning:+///                     - `fname` truncated if longer than `len`+///                     - `fname` if `fname` is a URL+///                     - the absolute path for `fname`+///                     - `fname` if getting the absolute path fails /// @param      len   is the length of `buf` /// @param      force is a flag to force expanding even if the path is absolute /// /// @return           FAIL for failure, OK otherwise int vim_FullName(const char *fname, char *buf, size_t len, bool force)   FUNC_ATTR_NONNULL_ARG(2) {-  int retval = OK;-  int url;-   *buf = NUL;   if (fname == NULL)     return FAIL; -  url = path_with_url(fname);-  if (!url)-    retval = path_get_absolute_path((char_u *)fname, (char_u *)buf, len, force);-  if (url || retval == FAIL) {-    /* something failed; use the file name (truncate when too long) */+  if (strlen(fname) > (len - 1)) {+    // use the truncated filename     xstrlcpy(buf, fname, len);+    return FAIL;   }-  return retval;++  if (path_with_url(fname)) {+    xstrlcpy(buf, fname, len);+  } else if (path_get_absolute_path((char_u *)fname, (char_u *)buf, len, force)+             == FAIL) {+      // something failed; use the filename+      xstrlcpy(buf, fname, len);","The branches do completely different things, which makes this much more readable:1. Truncates too long path and returns `FAIL`2. Copies URL and returns `OK`3. Copies absolute path and returns `OK`4. Copies path and returns `FAIL`The compiler can easily optimize this.",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/5770,92361709,2016-12-14T10:14:31Z,src/nvim/shada.c,"@@ -2318,6 +2318,55 @@ static inline ShaDaWriteResult shada_read_when_writing(   return ret; } +/// Get list of buffers to write to the shada file+///+/// @param[in] khash_t(bufset)   Buffers which are ignored+///+/// @return ShadaEntry  kSDItemBufferList of buffers to save","Do not remember seeing type after return. I would write something like ���list of buffers to save[, kSDItemBufferList entry].���: type is known from function signature.",X
24446350,ooora,https://api.github.com/repos/neovim/neovim/pulls/5734,92410871,2016-12-14T15:04:35Z,runtime/autoload/man.vim,"@@ -57,30 +53,77 @@ function! man#open_page(count, count1, mods, ...) abort     noautocmd execute 'silent' a:mods 'split' fnameescape(bufname)   endif   let b:man_sect = sect-  call s:read_page(path)+  call s:put_page(page) endfunction  function! man#read_page(ref) abort   try     let [sect, name] = man#extract_sect_and_name_ref(a:ref)     let [b:man_sect, name, path] = s:verify_exists(sect, name)+    let page = s:get_page(path)   catch     "" call to s:error() is unnecessary     return   endtry-  call s:read_page(path)+  call s:put_page(page)+endfunction++"" Handler for s:system() function.+function! s:system_handler(jobid, data, event) dict abort+  if a:event == 'stdout'+    let self.stdout .= join(a:data, ""\n"")+  elseif a:event == 'stderr'+    let self.stderr .= join(a:data, ""\n"")+  else+    let self.exit_code = a:data+  endif+endfunction++"" Run a system command and timeout after 30 seconds.+function! s:system(cmd, ...) abort+  let opts = {+        \ 'stdout': '',+        \ 'stderr': '',+        \ 'exit_code': 0,+        \ 'on_stdout': function('s:system_handler'),+        \ 'on_stderr': function('s:system_handler'),","@justinmk, the reason s:system() is defined the way it is in man.vim is so that health/provider.vim could also use it. I worked on a patch yesterday to do this, but i'm not sure if I should create another PR just for this patch since it is a big refactor. (I had to change the way error reporting was gathered. [return values vs exceptions) The only reason to include the patch in this PR is to fix the fact that I removed a 2>/dev/null from line 419 in health/provider.vim.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/5734,92417250,2016-12-14T15:31:12Z,runtime/autoload/man.vim,"@@ -57,30 +53,77 @@ function! man#open_page(count, count1, mods, ...) abort     noautocmd execute 'silent' a:mods 'split' fnameescape(bufname)   endif   let b:man_sect = sect-  call s:read_page(path)+  call s:put_page(page) endfunction  function! man#read_page(ref) abort   try     let [sect, name] = man#extract_sect_and_name_ref(a:ref)     let [b:man_sect, name, path] = s:verify_exists(sect, name)+    let page = s:get_page(path)   catch     "" call to s:error() is unnecessary     return   endtry-  call s:read_page(path)+  call s:put_page(page)+endfunction++"" Handler for s:system() function.+function! s:system_handler(jobid, data, event) dict abort+  if a:event == 'stdout'+    let self.stdout .= join(a:data, ""\n"")+  elseif a:event == 'stderr'+    let self.stderr .= join(a:data, ""\n"")+  else+    let self.exit_code = a:data+  endif+endfunction++"" Run a system command and timeout after 30 seconds.+function! s:system(cmd, ...) abort+  let opts = {+        \ 'stdout': '',+        \ 'stderr': '',+        \ 'exit_code': 0,+        \ 'on_stdout': function('s:system_handler'),+        \ 'on_stderr': function('s:system_handler'),","We want to avoid big refactors and we want to avoid spending lots of time on this. We don't care about sharing the function, that's why I mentioned [it will be temporary](https://github.com/neovim/neovim/pull/5734#issuecomment-266091542).Let's just fix the bug(s) and avoid spending tons of time on this.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/5772,92485521,2016-12-14T20:48:00Z,test/functional/core/job_spec.lua,"@@ -303,6 +303,26 @@ describe('jobs', function()     ]])   end) +  it('requires funcrefs for script-local (s:) functions', function()",[This example](https://github.com/justinmk/neovim/blob/b29c5dd3848d3621dfbb00f8f940506cc1048fd1/runtime/doc/job_control.txt#L97) still works. That's also why I didn't update `:help jobstart()` which mentions:> on_stdout: stdout event handler **(function name or Funcref)**,
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/5772,92502667,2016-12-14T22:18:07Z,runtime/doc/job_control.txt,"@@ -102,23 +102,23 @@ function. Here's a more object-oriented version of the above: >     let Shell = {} -    function Shell.on_stdout(job_id, data)+    function Shell.on_stdout(job_id, data) dict","In my plugins I am trying to follow the following convention: `function dict.func(���)` means that function will not be using `self` dictionary, `dict` in signature means that `self` will be used. This is because my plugins use dictionary functions like `s:F.foo` everywhere, except for some user (not developer!) API or for technical reasons (in cases when anonymous functions are way too tricky to use).",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/5772,92547353,2016-12-15T05:40:17Z,runtime/doc/job_control.txt,"@@ -102,23 +102,23 @@ function. Here's a more object-oriented version of the above: >     let Shell = {} -    function Shell.on_stdout(job_id, data)+    function Shell.on_stdout(job_id, data) dict","I guess each of these handlers needs 3 parameters, too, so the doc is still wrong. ",X
972014,mhinz,https://api.github.com/repos/neovim/neovim/pulls/5775,92622880,2016-12-15T14:50:25Z,scripts/vim-patch.sh,"@@ -366,6 +366,14 @@ review_commit() {     echo ""��� Could not detect the Vim patch number.""     echo ""  This script assumes that the PR contains only commits""     echo ""  with 'vim-patch:XXX' in their title.""+    echo+    printf -- ""$(head -n 4 <<< ""${nvim_patch}"")\n\n""+    local reply+    read -p ""Continue reviewing (y/N)? "" -n 1 -r reply+    if [[ ! ""${reply}"" =~ ^[Nn]$ ]]; then+      echo+      return+    fi     exit 1   fi ","Oh, I thought the intention was to review the non-`vim-patch` commit anyway. My bad.",
112971,jamessan,https://api.github.com/repos/neovim/neovim/pulls/5771,93325048,2016-12-20T21:05:28Z,src/nvim/eval.c,"@@ -6831,6 +6835,202 @@ static int get_dict_tv(char_u **arg, typval_T *rettv, int evaluate)   return OK; } +/// Get function arguments.+static int get_function_args(char_u **argp, char_u endchar, garray_T *newargs,+                             int *varargs, int skip)+{+  bool    mustend = false;+  char_u  *arg = *argp;+  char_u  *p = arg;+  int     c;+  int     i;++  if (newargs != NULL) {+    ga_init(newargs, (int)sizeof(char_u *), 3);+  }++  if (varargs != NULL) {+    *varargs = false;+  }++  // Isolate the arguments: ""arg1, arg2, ...)""+  while (*p != endchar) {+    if (p[0] == '.' && p[1] == '.' && p[2] == '.') {+      if (varargs != NULL) {+        *varargs = true;+      }+      p += 3;+      mustend = true;+    } else {+      arg = p;+      while (ASCII_ISALNUM(*p) || *p == '_') {+        p++;+      }+      if (arg == p || isdigit(*arg)+          || (p - arg == 9 && STRNCMP(arg, ""firstline"", 9) == 0)+          || (p - arg == 8 && STRNCMP(arg, ""lastline"", 8) == 0)) {+        if (!skip) {+          EMSG2(_(""E125: Illegal argument: %s""), arg);+        }+        break;+      }+      if (newargs != NULL) {+        ga_grow(newargs, 1);+        c = *p;+        *p = NUL;+        arg = vim_strsave(arg);+        if (arg == NULL) {+          goto err_ret;+        }++        // Check for duplicate argument name.+        for (i = 0; i < newargs->ga_len; i++) {+          if (STRCMP(((char_u **)(newargs->ga_data))[i], arg) == 0) {+            EMSG2(_(""E853: Duplicate argument name: %s""), arg);+            xfree(arg);+            goto err_ret;+          }+        }+        ((char_u **)(newargs->ga_data))[newargs->ga_len] = arg;+        newargs->ga_len++;++        *p = c;+      }+      if (*p == ',') {+        p++;+      } else {+        mustend = true;+      }+    }+    p = skipwhite(p);+    if (mustend && *p != endchar) {+      if (!skip) {+        EMSG2(_(e_invarg2), *argp);+      }+      break;+    }+  }+  if (*p != endchar) {+    goto err_ret;+  }+  p++;  // skip ""endchar""++  *argp = p;+  return OK;++err_ret:+  if (newargs != NULL) {+    ga_clear_strings(newargs);+  }+  return FAIL;+}++/// Parse a lambda expression and get a Funcref from ""*arg"".+/// Return OK or FAIL.  Returns NOTDONE for dict or {expr}.+static int get_lambda_tv(char_u **arg, typval_T *rettv, int evaluate)+{+  garray_T   newargs;+  garray_T   newlines;+  ufunc_T    *fp = NULL;+  int        varargs;+  int        ret;+  char_u     name[20];+  char_u     *start = skipwhite(*arg + 1);+  char_u     *s, *e;+  static int lambda_no = 0;++  // TODO(mike): What lengths should be used here?+  ga_init(&newargs, (int)sizeof(char_u *), 80);+  ga_init(&newlines, (int)sizeof(char_u *), 80);++  // First, check if this is a lambda expression. ""->"" must exists.+  ret = get_function_args(&start, '-', NULL, NULL, true);+  if (ret == FAIL || *start != '>') {+    return NOTDONE;+  }++  // Parse the arguments again.+  *arg = skipwhite(*arg + 1);+  ret = get_function_args(arg, '-', &newargs, &varargs, false);+  if (ret == FAIL || **arg != '>') {+    goto errret;+  }++  // Get the start and the end of the expression.+  *arg = skipwhite(*arg + 1);+  s = *arg;+  ret = skip_expr(arg);+  if (ret == FAIL) {+    goto errret;+  }+  e = *arg;+  *arg = skipwhite(*arg);+  if (**arg != '}') {+    goto errret;+  }+  (*arg)++;++  if (evaluate) {+    int len;+    char_u *p;++    fp = (ufunc_T *)xmalloc((unsigned)(sizeof(ufunc_T) + 20));+    if (fp == NULL) {+      goto errret;+    }++    snprintf((char *)name, sizeof(name), ""<lambda>%d"", lambda_no++);","The original code has `++lambda_no`, so we're going to be naming lambdas differently.  If this comes up in testing, then that's a change we would have to track.It'd be better to change this to```clambda_no++;snprintf((char *)name, sizeof(name), ""<lambda>%d"", lambda_no);```",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/5830,93881411,2016-12-26T19:04:35Z,src/nvim/os/time.c,"@@ -46,26 +47,42 @@ void os_delay(uint64_t milliseconds, bool ignoreinput)     }     LOOP_PROCESS_EVENTS_UNTIL(&main_loop, NULL, (int)milliseconds, got_int);   } else {-    os_microdelay(milliseconds * 1000);+    os_microdelay(milliseconds * 1000u, ignoreinput);   } } -/// Sleeps for a certain amount of microseconds+/// Sleeps for a certain amount of microseconds. /// /// @param microseconds Number of microseconds to sleep-void os_microdelay(uint64_t microseconds)+/// @param ignoreinput If true, ignore pressed keys during the waiting period.+///                    If false, waiting is aborted on key press.+void os_microdelay(uint64_t microseconds, bool ignoreinput) {-  uint64_t elapsed = 0;-  uint64_t ns = microseconds * 1000;  // convert to nanoseconds+  uint64_t elapsed = 0u;   uint64_t base = uv_hrtime(); +  /* Convert microseconds to nanoseconds. If uint64_t would overflow, set+   * nanoseconds to UINT64_MAX. */+  const uint64_t nanoseconds = (microseconds < UINT64_MAX/1000u ? microseconds * 1000u :+      UINT64_MAX);+   uv_mutex_lock(&delay_mutex); -  while (elapsed < ns) {-    if (uv_cond_timedwait(&delay_cond, &delay_mutex, ns - elapsed)-        == UV_ETIMEDOUT)+  while (elapsed < nanoseconds) {++    /* If the key input is ignored, we simply wait the full delay. If not, we+     * check every 10 milliseconds for input and break the waiting loop if input+     * is available. */+    const uint64_t nanoseconds_delta = (ignoreinput ? nanoseconds - elapsed : 10000u);++    if ((uv_cond_timedwait(&delay_cond, &delay_mutex, nanoseconds_delta)+        == UV_ETIMEDOUT) && os_char_avail()) {","Doesn't this make `os_microdelay()` dependent on `os_char_avail()` in all cases? I'm not certain, but I wonder if that could be undesirable or surprising. Perhaps the condition should be:```cif ((uv_cond_timedwait(&delay_cond, &delay_mutex, nanoseconds_delta)    == UV_ETIMEDOUT) && (ignoreinput || os_char_avail())) {```Even if that's unncessary for some reason, it seems to clarify intent.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/5830,93883481,2016-12-26T20:21:20Z,src/nvim/os/time.c,"@@ -46,26 +47,45 @@ void os_delay(uint64_t milliseconds, bool ignoreinput)     }     LOOP_PROCESS_EVENTS_UNTIL(&main_loop, NULL, (int)milliseconds, got_int);   } else {-    os_microdelay(milliseconds * 1000);+    os_microdelay(milliseconds * 1000u, ignoreinput);   } } -/// Sleeps for a certain amount of microseconds+/// Sleeps for a certain amount of microseconds. /// /// @param microseconds Number of microseconds to sleep-void os_microdelay(uint64_t microseconds)+/// @param ignoreinput If true, ignore all input (including SIGINT/CTRL-C).+///                    If false, waiting is aborted on any input.+void os_microdelay(uint64_t microseconds, bool ignoreinput) {-  uint64_t elapsed = 0;-  uint64_t ns = microseconds * 1000;  // convert to nanoseconds+  uint64_t elapsed = 0u;   uint64_t base = uv_hrtime(); +  // Convert microseconds to nanoseconds. If uint64_t would overflow, set+  // nanoseconds to UINT64_MAX.+  const uint64_t nanoseconds = (microseconds < UINT64_MAX/1000u)+                               ? microseconds * 1000u+                               : UINT64_MAX;+   uv_mutex_lock(&delay_mutex); -  while (elapsed < ns) {-    if (uv_cond_timedwait(&delay_cond, &delay_mutex, ns - elapsed)-        == UV_ETIMEDOUT)+  while (elapsed < nanoseconds) {++    // If the key input is ignored, we simply wait the full delay. If not, we+    // check every 10 milliseconds for input and break the waiting loop if input+    // is available.+    const uint64_t nanoseconds_delta = (ignoreinput)+                                       ? nanoseconds - elapsed+                                       : MIN(nanoseconds - elapsed, 10000000u);++    if ((uv_cond_timedwait(&delay_cond, &delay_mutex, nanoseconds_delta)+        == UV_ETIMEDOUT) && (ignoreinput || os_char_avail())) {",I think I was wrong about this. Shouldn't the condition be:    uv_cond_timedwait(...) == UV_ETIMEDOUT || (!ignoreinput && os_char_avail()),
10683473,DarkDeepBlue,https://api.github.com/repos/neovim/neovim/pulls/5830,93883676,2016-12-26T20:29:25Z,src/nvim/os/time.c,"@@ -46,26 +47,45 @@ void os_delay(uint64_t milliseconds, bool ignoreinput)     }     LOOP_PROCESS_EVENTS_UNTIL(&main_loop, NULL, (int)milliseconds, got_int);   } else {-    os_microdelay(milliseconds * 1000);+    os_microdelay(milliseconds * 1000u, ignoreinput);","Is this a problem? Currently I can see six instances where it might make any difference.```search.c2148:        os_delay(p_mat * 100L, false);syntax.c7523:  os_delay(cnt == 99 ? 40L : (long)cnt * 50L, false);if_cscope.c1897:      os_delay(50L, false);       /* sleep 50 ms */1928:          os_delay(50L, false);           /* sleep 50ms */normal.c628:  os_delay(3000L, false);             // wait up to three secondsedit.c1868:      os_delay(2000L, false);```",X
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/5830,93886959,2016-12-26T23:29:41Z,src/nvim/os/time.c,"@@ -46,26 +47,45 @@ void os_delay(uint64_t milliseconds, bool ignoreinput)     }     LOOP_PROCESS_EVENTS_UNTIL(&main_loop, NULL, (int)milliseconds, got_int);   } else {-    os_microdelay(milliseconds * 1000);+    os_microdelay(milliseconds * 1000u, ignoreinput);   } } -/// Sleeps for a certain amount of microseconds+/// Sleeps for a certain amount of microseconds. /// /// @param microseconds Number of microseconds to sleep-void os_microdelay(uint64_t microseconds)+/// @param ignoreinput If true, ignore all input (including SIGINT/CTRL-C).+///                    If false, waiting is aborted on any input.+void os_microdelay(uint64_t microseconds, bool ignoreinput) {-  uint64_t elapsed = 0;-  uint64_t ns = microseconds * 1000;  // convert to nanoseconds+  uint64_t elapsed = 0u;   uint64_t base = uv_hrtime(); +  // Convert microseconds to nanoseconds. If uint64_t would overflow, set+  // nanoseconds to UINT64_MAX.+  const uint64_t nanoseconds = (microseconds < UINT64_MAX/1000u)+                               ? microseconds * 1000u+                               : UINT64_MAX;+   uv_mutex_lock(&delay_mutex); -  while (elapsed < ns) {-    if (uv_cond_timedwait(&delay_cond, &delay_mutex, ns - elapsed)-        == UV_ETIMEDOUT)+  while (elapsed < nanoseconds) {++    // If the key input is ignored, we simply wait the full delay. If not, we+    // check every 10 milliseconds for input and break the waiting loop if input+    // is available.+    const uint64_t nanoseconds_delta = (ignoreinput)+                                       ? nanoseconds - elapsed+                                       : MIN(nanoseconds - elapsed, 10000000u);++    if ((uv_cond_timedwait(&delay_cond, &delay_mutex, nanoseconds_delta)+        == UV_ETIMEDOUT) && (ignoreinput || os_char_avail())) {","With `ignoreinput == false` and `uv_cond_timedwait(...) == UV_ETIMEDOUT || (!ignoreinput && os_char_avail())` we could leave the loop on the first uninterrupted `10` milliseconds. Input would not be checked.With the unchanged condition:If `uv_cond_timedwait()` returns early every time, input would never be checked. So we could wait the full timeand never notice new input.",X
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/5830,93887121,2016-12-26T23:40:57Z,src/nvim/os/time.c,"@@ -46,26 +47,45 @@ void os_delay(uint64_t milliseconds, bool ignoreinput)     }     LOOP_PROCESS_EVENTS_UNTIL(&main_loop, NULL, (int)milliseconds, got_int);   } else {-    os_microdelay(milliseconds * 1000);+    os_microdelay(milliseconds * 1000u, ignoreinput);   } } -/// Sleeps for a certain amount of microseconds+/// Sleeps for a certain amount of microseconds. /// /// @param microseconds Number of microseconds to sleep-void os_microdelay(uint64_t microseconds)+/// @param ignoreinput If true, ignore all input (including SIGINT/CTRL-C).+///                    If false, waiting is aborted on any input.+void os_microdelay(uint64_t microseconds, bool ignoreinput) {-  uint64_t elapsed = 0;-  uint64_t ns = microseconds * 1000;  // convert to nanoseconds+  uint64_t elapsed = 0u;   uint64_t base = uv_hrtime(); +  // Convert microseconds to nanoseconds. If uint64_t would overflow, set+  // nanoseconds to UINT64_MAX.+  const uint64_t nanoseconds = (microseconds < UINT64_MAX/1000u)+                               ? microseconds * 1000u+                               : UINT64_MAX;+   uv_mutex_lock(&delay_mutex); -  while (elapsed < ns) {-    if (uv_cond_timedwait(&delay_cond, &delay_mutex, ns - elapsed)-        == UV_ETIMEDOUT)+  while (elapsed < nanoseconds) {++    // If the key input is ignored, we simply wait the full delay. If not, we+    // check every 10 milliseconds for input and break the waiting loop if input+    // is available.+    const uint64_t nanoseconds_delta = (ignoreinput)+                                       ? nanoseconds - elapsed+                                       : MIN(nanoseconds - elapsed, 10000000u);++    if ((uv_cond_timedwait(&delay_cond, &delay_mutex, nanoseconds_delta)+        == UV_ETIMEDOUT) && (ignoreinput || os_char_avail())) {",The condition `(ignoreinput || nanoseconds_delta <= 10000000u)` is always true.,X
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/5826,93961353,2016-12-27T19:10:26Z,src/nvim/eval/typval_encode.c.h,"@@ -0,0 +1,713 @@+/// @file eval/typval_encode.c.h+///+/// Contains set of macros used to convert (possibly recursive) typval_T into+/// something else. For these macros to work the following macros must be+/// defined:++/// @def TYPVAL_ENCODE_CONV_NIL+/// @brief Macros used to convert NIL value+///+/// Is called both for special dictionary (unless #TYPVAL_ENCODE_ALLOW_SPECIALS+/// is false) and `v:null`. Accepts no arguments, but still must be+/// a function-like macros.++/// @def TYPVAL_ENCODE_CONV_BOOL+/// @brief Macros used to convert boolean value+///+/// Is called both for special dictionary (unless #TYPVAL_ENCODE_ALLOW_SPECIALS+/// is false) and `v:true`/`v:false`.+///+/// @param  num  Boolean value to convert. Value is an expression which+///              evaluates to some integer.++/// @def TYPVAL_ENCODE_CONV_NUMBER+/// @brief Macros used to convert integer+///+/// @param  num  Integer to convert, must accept both varnumber_T and int64_t.++/// @def TYPVAL_ENCODE_CONV_UNSIGNED_NUMBER+/// @brief Macros used to convert unsigned integer+///+/// Not used if #TYPVAL_ENCODE_ALLOW_SPECIALS is false, but still must be+/// defined.+///+/// @param  num  Integer to convert, must accept uint64_t.++/// @def TYPVAL_ENCODE_CONV_FLOAT+/// @brief Macros used to convert floating-point number+///+/// @param  flt  Number to convert, must accept float_T.++/// @def TYPVAL_ENCODE_CONV_STRING+/// @brief Macros used to convert plain string+///+/// Is used to convert VAR_STRING objects as well as BIN strings represented as+/// special dictionary.+///+/// @param  buf  String to convert. Is a char[] buffer, not NUL-terminated.+/// @param  len  String length.++/// @def TYPVAL_ENCODE_CONV_STR_STRING+/// @brief Like #TYPVAL_ENCODE_CONV_STRING, but for STR strings+///+/// Is used to convert dictionary keys and STR strings represented as special+/// dictionaries.++/// @def TYPVAL_ENCODE_CONV_EXT_STRING+/// @brief Macros used to convert EXT string+///+/// Is used to convert EXT strings represented as special dictionaries. Never+/// actually used if #TYPVAL_ENCODE_ALLOW_SPECIALS is false, but still must be+/// defined.+///+/// @param  buf  String to convert. Is a char[] buffer, not NUL-terminated.+/// @param  len  String length.+/// @param  type  EXT type.++/// @def TYPVAL_ENCODE_CONV_FUNC+/// @brief Macros used to convert a function reference+///+/// @param  fun  Function name.++/// @def TYPVAL_ENCODE_CONV_FUNC_START+/// @brief Macros used when starting to convert a funcref or a partial+///+/// @param  fun  Function name.+/// @param  is_partial  True if converted function is a partial.+/// @param  pt  Pointer to partial or NULL.++/// @def TYPVAL_ENCODE_CONV_FUNC_BEFORE_ARGS+/// @brief Macros used before starting to convert partial arguments+///+/// @param  len  Number of arguments. Zero for absent arguments or when+///              converting a funcref.++/// @def TYPVAL_ENCODE_CONV_FUNC_BEFORE_SELF+/// @brief Macros used before starting to convert self dictionary+///+/// @param  len  Number of arguments. May be zero for empty dictionary or -1 for+///              missing self dictionary, also when converting function+///              reference.++/// @def TYPVAL_ENCODE_CONV_FUNC_END+/// @brief Macros used after converting a funcref or a partial+///+/// Accepts no arguments, but still must be a function-like macros.++/// @def TYPVAL_ENCODE_CONV_EMPTY_LIST+/// @brief Macros used to convert an empty list+///+/// Accepts no arguments, but still must be a function-like macros.++/// @def TYPVAL_ENCODE_CONV_EMPTY_DICT+/// @brief Macros used to convert an empty dictionary+///+/// Accepts no arguments, but still must be a function-like macros.++/// @def TYPVAL_ENCODE_CONV_LIST_START+/// @brief Macros used before starting to convert non-empty list+///+/// @param  len  List length. Is an expression which evaluates to an integer.++/// @def TYPVAL_ENCODE_CONV_LIST_BETWEEN_ITEMS+/// @brief Macros used after finishing converting non-last list item+///+/// Accepts no arguments, but still must be a function-like macros.++/// @def TYPVAL_ENCODE_CONV_LIST_END+/// @brief Macros used after converting non-empty list+///+/// Accepts no arguments, but still must be a function-like macros.++/// @def TYPVAL_ENCODE_CONV_DICT_START+/// @brief Macros used before starting to convert non-empty dictionary+///+/// @param  len  Dictionary length. Is an expression which evaluates to an+///              integer.++/// @def TYPVAL_ENCODE_CONV_SPECIAL_DICT_KEY_CHECK+/// @brief Macros used to check special dictionary key+///+/// @param  label  Label for goto in case check was not successfull.+/// @param  key  typval_T key to check.++/// @def TYPVAL_ENCODE_CONV_DICT_AFTER_KEY+/// @brief Macros used after finishing converting dictionary key+///+/// Accepts no arguments, but still must be a function-like macros.++/// @def TYPVAL_ENCODE_CONV_DICT_BETWEEN_ITEMS+/// @brief Macros used after finishing converting non-last dictionary value+///+/// Accepts no arguments, but still must be a function-like macros.++/// @def TYPVAL_ENCODE_CONV_DICT_END+/// @brief Macros used after converting non-empty dictionary+///+/// Accepts no arguments, but still must be a function-like macros.++/// @def TYPVAL_ENCODE_CONV_RECURSE+/// @brief Macros used when self-containing container is detected+///+/// @param  val  Container for which this situation was detected.+/// @param  conv_type  Type of the stack entry, @see MPConvStackValType.++/// @def TYPVAL_ENCODE_ALLOW_SPECIALS+/// @brief Macros that specifies whether special dictionaries are special+///+/// Must be something that evaluates to boolean, most likely `true` or `false`.+/// If it is false then special dictionaries are not treated specially.++/// @def TYPVAL_ENCODE_SCOPE+/// @brief Scope of the main function: either nothing or `static`++/// @def TYPVAL_ENCODE_NAME+/// @brief Name of the target converter+///+/// After including this file it will define function+/// `encode_vim_to_{TYPVAL_ENCODE_NAME}` with scope #TYPVAL_ENCODE_SCOPE and+/// static functions `_typval_encode_{TYPVAL_ENCODE_NAME}_convert_one_value` and+/// `_typval_encode_{TYPVAL_ENCODE_NAME}_check_self_reference`.++/// @def TYPVAL_ENCODE_FIRST_ARG_TYPE+/// @brief Type of the first argument, which will be used to return the results+///+/// Is expected to be a pointer type.++/// @def TYPVAL_ENCODE_FIRST_ARG_NAME+/// @brief Name of the first argument+///+/// This name will only be used by one of the above macros which are defined by+/// the caller. Functions defined here do not use first argument directly.+#ifndef NVIM_EVAL_TYPVAL_ENCODE_C_H+#define NVIM_EVAL_TYPVAL_ENCODE_C_H+#undef NVIM_EVAL_TYPVAL_ENCODE_C_H++#include <stddef.h>+#include <inttypes.h>+#include <assert.h>++#include ""nvim/lib/kvec.h""+#include ""nvim/eval_defs.h""+#include ""nvim/eval/encode.h""+#include ""nvim/func_attr.h""+#include ""nvim/eval/typval_encode.h""++static inline int _TYPVAL_ENCODE_CHECK_SELF_REFERENCE(+    TYPVAL_ENCODE_FIRST_ARG_TYPE TYPVAL_ENCODE_FIRST_ARG_NAME,+    void *const val, int *const val_copyID,+    const MPConvStack *const mpstack, const int copyID,+    const MPConvStackValType conv_type,+    const char *const objname)+  REAL_FATTR_NONNULL_ARG(2, 3, 4, 7) REAL_FATTR_WARN_UNUSED_RESULT+  REAL_FATTR_ALWAYS_INLINE;++/// Function for checking whether container references itself+///+/// @param  TYPVAL_ENCODE_FIRST_ARG_NAME  First argument.+/// @param[in,out]  val  Container to check.+/// @param  val_copyID  Pointer to the container attribute that holds copyID.+///                     After checking whether value of this attribute is+///                     copyID (variable) it is set to copyID.+/// @param[in]  mpstack  Stack with values to convert. Read-only, used for error+///                      reporting.+/// @param[in]  copyID  CopyID used by the caller.+/// @param[in]  conv_type  Type of the conversion, @see MPConvStackValType.+/// @param[in]  objname  Object name, used for error reporting.+///+/// @return NOTDONE in case of success, what to return in case of failure.+static inline int _TYPVAL_ENCODE_CHECK_SELF_REFERENCE(+    TYPVAL_ENCODE_FIRST_ARG_TYPE TYPVAL_ENCODE_FIRST_ARG_NAME,+    void *const val, int *const val_copyID,+    const MPConvStack *const mpstack, const int copyID,+    const MPConvStackValType conv_type,+    const char *const objname)+{+  if (*val_copyID == copyID) {+    TYPVAL_ENCODE_CONV_RECURSE(val, conv_type);+    return OK;+  }+  *val_copyID = copyID;+  return NOTDONE;+}++static int _TYPVAL_ENCODE_CONVERT_ONE_VALUE(+    TYPVAL_ENCODE_FIRST_ARG_TYPE TYPVAL_ENCODE_FIRST_ARG_NAME,+    MPConvStack *const mpstack, MPConvStackVal *const cur_mpsv,+    typval_T *const tv, const int copyID,+    const char *const objname)+  REAL_FATTR_NONNULL_ARG(2, 4, 6) REAL_FATTR_WARN_UNUSED_RESULT;++/// Convert single value+///+/// Only scalar values are converted immediately, everything else is pushed onto+/// the stack.+///+/// @param  TYPVAL_ENCODE_FIRST_ARG_NAME  First argument, defined by the+///                                       includer. Only meaningful to macros+///                                       defined by the includer.+/// @param  mpstack  Stack with values to convert. Values which are not+///                  converted completely by this function (i.e.+///                  non-scalars) are pushed here.+/// @param  cur_mpsv  Currently converted value from stack.+/// @param  tv  Converted value.+/// @param[in]  copyID  CopyID.+/// @param[in]  objname  Object name, used for error reporting.+///+/// @return OK in case of success, FAIL in case of failure.+static int _TYPVAL_ENCODE_CONVERT_ONE_VALUE(+    TYPVAL_ENCODE_FIRST_ARG_TYPE TYPVAL_ENCODE_FIRST_ARG_NAME,+    MPConvStack *const mpstack, MPConvStackVal *const cur_mpsv,+    typval_T *const tv, const int copyID,+    const char *const objname)+{+  switch (tv->v_type) {+    case VAR_STRING: {+      TYPVAL_ENCODE_CONV_STRING(tv->vval.v_string, tv_strlen(tv));+      break;+    }+    case VAR_NUMBER: {+      TYPVAL_ENCODE_CONV_NUMBER(tv->vval.v_number);+      break;+    }+    case VAR_FLOAT: {+      TYPVAL_ENCODE_CONV_FLOAT(tv->vval.v_float);+      break;+    }+    case VAR_FUNC: {+      TYPVAL_ENCODE_CONV_FUNC_START(tv->vval.v_string, false, NULL);+      TYPVAL_ENCODE_CONV_FUNC_BEFORE_ARGS(0);+      TYPVAL_ENCODE_CONV_FUNC_BEFORE_SELF(-1);+      TYPVAL_ENCODE_CONV_FUNC_END();+      break;+    }+    case VAR_PARTIAL: {+      partial_T *const pt = tv->vval.v_partial;+      (void)pt;+      TYPVAL_ENCODE_CONV_FUNC_START(pt->pt_name, true, pt);+      _mp_push(*mpstack, ((MPConvStackVal) {+        .type = kMPConvPartial,+        .tv = tv,+        .data = {+          .p = {+            .stage = kMPConvPartialArgs,+            .pt = tv->vval.v_partial,+          },+        },+      }));+      break;+    }+    case VAR_LIST: {+      if (tv->vval.v_list == NULL || tv->vval.v_list->lv_len == 0) {+        TYPVAL_ENCODE_CONV_EMPTY_LIST();+        break;+      }+      _TYPVAL_ENCODE_DO_CHECK_SELF_REFERENCE(tv->vval.v_list, lv_copyID, copyID,+                                             kMPConvList);+      TYPVAL_ENCODE_CONV_LIST_START(tv->vval.v_list->lv_len);+      _mp_push(*mpstack, ((MPConvStackVal) {+        .type = kMPConvList,+        .tv = tv,+        .data = {+          .l = {+            .list = tv->vval.v_list,+            .li = tv->vval.v_list->lv_first,+          },+        },+      }));+      break;+    }+    case VAR_SPECIAL: {+      switch (tv->vval.v_special) {+        case kSpecialVarNull: {+          TYPVAL_ENCODE_CONV_NIL();+          break;+        }+        case kSpecialVarTrue:+        case kSpecialVarFalse: {+          TYPVAL_ENCODE_CONV_BOOL(tv->vval.v_special == kSpecialVarTrue);+          break;+        }+      }+      break;+    }+    case VAR_DICT: {+      if (tv->vval.v_dict == NULL+          || tv->vval.v_dict->dv_hashtab.ht_used == 0) {+        TYPVAL_ENCODE_CONV_EMPTY_DICT();+        break;+      }+      const dictitem_T *type_di;+      const dictitem_T *val_di;+      if (TYPVAL_ENCODE_ALLOW_SPECIALS+          && tv->vval.v_dict->dv_hashtab.ht_used == 2+          && (type_di = dict_find((dict_T *)tv->vval.v_dict,+                                  (char_u *)""_TYPE"", -1)) != NULL+          && type_di->di_tv.v_type == VAR_LIST+          && (val_di = dict_find((dict_T *)tv->vval.v_dict,+                                 (char_u *)""_VAL"", -1)) != NULL) {+        size_t i;+        for (i = 0; i < ARRAY_SIZE(eval_msgpack_type_lists); i++) {+          if (type_di->di_tv.vval.v_list == eval_msgpack_type_lists[i]) {+            break;+          }+        }+        if (i == ARRAY_SIZE(eval_msgpack_type_lists)) {+          goto _convert_one_value_regular_dict;+        }+        switch ((MessagePackType)i) {+          case kMPNil: {+            TYPVAL_ENCODE_CONV_NIL();+            break;+          }+          case kMPBoolean: {+            if (val_di->di_tv.v_type != VAR_NUMBER) {+              goto _convert_one_value_regular_dict;+            }+            TYPVAL_ENCODE_CONV_BOOL(val_di->di_tv.vval.v_number);+            break;+          }+          case kMPInteger: {+            const list_T *val_list;+            varnumber_T sign;+            varnumber_T highest_bits;+            varnumber_T high_bits;+            varnumber_T low_bits;+            // List of 4 integers; first is signed (should be 1 or -1, but+            // this is not checked), second is unsigned and have at most+            // one (sign is -1) or two (sign is 1) non-zero bits (number of+            // bits is not checked), other unsigned and have at most 31+            // non-zero bits (number of bits is not checked).+            if (val_di->di_tv.v_type != VAR_LIST+                || (val_list = val_di->di_tv.vval.v_list) == NULL+                || val_list->lv_len != 4+                || val_list->lv_first->li_tv.v_type != VAR_NUMBER+                || (sign = val_list->lv_first->li_tv.vval.v_number) == 0+                || val_list->lv_first->li_next->li_tv.v_type != VAR_NUMBER+                || (highest_bits =+                    val_list->lv_first->li_next->li_tv.vval.v_number) < 0+                || val_list->lv_last->li_prev->li_tv.v_type != VAR_NUMBER+                || (high_bits =+                    val_list->lv_last->li_prev->li_tv.vval.v_number) < 0+                || val_list->lv_last->li_tv.v_type != VAR_NUMBER+                || (low_bits = val_list->lv_last->li_tv.vval.v_number) < 0) {+              goto _convert_one_value_regular_dict;+            }+            uint64_t number = ((uint64_t)(((uint64_t)highest_bits) << 62)+                               | (uint64_t)(((uint64_t)high_bits) << 31)+                               | (uint64_t)low_bits);+            if (sign > 0) {+              TYPVAL_ENCODE_CONV_UNSIGNED_NUMBER(number);+            } else {+              TYPVAL_ENCODE_CONV_NUMBER(-number);+            }+            break;+          }+          case kMPFloat: {+            if (val_di->di_tv.v_type != VAR_FLOAT) {+              goto _convert_one_value_regular_dict;+            }+            TYPVAL_ENCODE_CONV_FLOAT(val_di->di_tv.vval.v_float);+            break;+          }+          case kMPString:+          case kMPBinary: {+            const bool is_string = ((MessagePackType)i == kMPString);+            if (val_di->di_tv.v_type != VAR_LIST) {+              goto _convert_one_value_regular_dict;+            }+            size_t len;+            char *buf;+            if (!encode_vim_list_to_buf(val_di->di_tv.vval.v_list, &len,+                                        &buf)) {+              goto _convert_one_value_regular_dict;+            }+            if (is_string) {+              TYPVAL_ENCODE_CONV_STR_STRING(buf, len);+            } else {+              TYPVAL_ENCODE_CONV_STRING(buf, len);+            }+            xfree(buf);+            break;+          }+          case kMPArray: {+            if (val_di->di_tv.v_type != VAR_LIST) {+              goto _convert_one_value_regular_dict;+            }+            _TYPVAL_ENCODE_DO_CHECK_SELF_REFERENCE(val_di->di_tv.vval.v_list,+                                                   lv_copyID, copyID,+                                                   kMPConvList);+            TYPVAL_ENCODE_CONV_LIST_START(val_di->di_tv.vval.v_list->lv_len);+            _mp_push(*mpstack, ((MPConvStackVal) {+              .tv = tv,+              .type = kMPConvList,+              .data = {+                .l = {+                  .list = val_di->di_tv.vval.v_list,+                  .li = val_di->di_tv.vval.v_list->lv_first,+                },+              },+            }));+            break;+          }+          case kMPMap: {+            if (val_di->di_tv.v_type != VAR_LIST) {+              goto _convert_one_value_regular_dict;+            }+            list_T *const val_list = val_di->di_tv.vval.v_list;+            if (val_list == NULL || val_list->lv_len == 0) {+              TYPVAL_ENCODE_CONV_EMPTY_DICT();+              break;+            }+            for (const listitem_T *li = val_list->lv_first; li != NULL;+                 li = li->li_next) {+              if (li->li_tv.v_type != VAR_LIST+                  || li->li_tv.vval.v_list->lv_len != 2) {+                goto _convert_one_value_regular_dict;+              }+            }+            _TYPVAL_ENCODE_DO_CHECK_SELF_REFERENCE(val_list, lv_copyID, copyID,+                                                   kMPConvPairs);+            TYPVAL_ENCODE_CONV_DICT_START(val_list->lv_len);+            _mp_push(*mpstack, ((MPConvStackVal) {+              .tv = tv,+              .type = kMPConvPairs,+              .data = {+                .l = {+                  .list = val_list,+                  .li = val_list->lv_first,+                },+              },+            }));+            break;+          }+          case kMPExt: {+            const list_T *val_list;+            varnumber_T type;+            if (val_di->di_tv.v_type != VAR_LIST+                || (val_list = val_di->di_tv.vval.v_list) == NULL+                || val_list->lv_len != 2+                || (val_list->lv_first->li_tv.v_type != VAR_NUMBER)+                || (type = val_list->lv_first->li_tv.vval.v_number) > INT8_MAX+                || type < INT8_MIN+                || (val_list->lv_last->li_tv.v_type != VAR_LIST)) {+              goto _convert_one_value_regular_dict;+            }+            size_t len;+            char *buf;+            if (!encode_vim_list_to_buf(val_list->lv_last->li_tv.vval.v_list,+                                        &len, &buf)) {+              goto _convert_one_value_regular_dict;+            }+            TYPVAL_ENCODE_CONV_EXT_STRING(buf, len, type);+            xfree(buf);+            break;+          }+        }+        break;+      }+_convert_one_value_regular_dict:+      _TYPVAL_ENCODE_DO_CHECK_SELF_REFERENCE(tv->vval.v_dict, dv_copyID, copyID,+                                             kMPConvDict);+      TYPVAL_ENCODE_CONV_DICT_START(tv->vval.v_dict->dv_hashtab.ht_used);+      _mp_push(*mpstack, ((MPConvStackVal) {+        .tv = tv,+        .type = kMPConvDict,+        .data = {+          .d = {+            .dict = tv->vval.v_dict,+            .hi = tv->vval.v_dict->dv_hashtab.ht_array,+            .todo = tv->vval.v_dict->dv_hashtab.ht_used,+          },+        },+      }));+      break;+    }+    case VAR_UNKNOWN: {+      EMSG2(_(e_intern2), STR(_TYPVAL_ENCODE_CONVERT_ONE_VALUE) ""()"");+      return FAIL;+    }+  }+  return OK;+}++TYPVAL_ENCODE_SCOPE int _TYPVAL_ENCODE_ENCODE(+    TYPVAL_ENCODE_FIRST_ARG_TYPE TYPVAL_ENCODE_FIRST_ARG_NAME,+    typval_T *const tv, const char *const objname)+  REAL_FATTR_NONNULL_ARG(2, 3) REAL_FATTR_WARN_UNUSED_RESULT;++/// Convert the whole typval+///+/// @param  TYPVAL_ENCODE_FIRST_ARG_NAME  First argument, defined by the+///                                       includer. Only meaningful to macros+///                                       defined by the includer.+/// @param  tv  Converted value.+/// @param[in]  objname  Object name, used for error reporting.+///+/// @return OK in case of success, FAIL in case of failure.+TYPVAL_ENCODE_SCOPE int _TYPVAL_ENCODE_ENCODE(+    TYPVAL_ENCODE_FIRST_ARG_TYPE TYPVAL_ENCODE_FIRST_ARG_NAME,+    typval_T *const tv, const char *const objname)+{+  const int copyID = get_copyID();+  MPConvStack mpstack;+  _mp_init(mpstack);+  if (_TYPVAL_ENCODE_CONVERT_ONE_VALUE(TYPVAL_ENCODE_FIRST_ARG_NAME, &mpstack,+                                       NULL,+                                       tv, copyID, objname)+      == FAIL) {+    goto encode_vim_to__error_ret;+  }+  while (_mp_size(mpstack)) {+    MPConvStackVal *cur_mpsv = &_mp_last(mpstack);+    typval_T *cur_tv = NULL;+    switch (cur_mpsv->type) {+      case kMPConvDict: {+        if (!cur_mpsv->data.d.todo) {+          (void)_mp_pop(mpstack);+          cur_mpsv->data.d.dict->dv_copyID = copyID - 1;+          TYPVAL_ENCODE_CONV_DICT_END();+          continue;+        } else if (cur_mpsv->data.d.todo+                   != cur_mpsv->data.d.dict->dv_hashtab.ht_used) {+          TYPVAL_ENCODE_CONV_DICT_BETWEEN_ITEMS();+        }+        while (HASHITEM_EMPTY(cur_mpsv->data.d.hi)) {+          cur_mpsv->data.d.hi++;+        }+        dictitem_T *const di = HI2DI(cur_mpsv->data.d.hi);+        cur_mpsv->data.d.todo--;+        cur_mpsv->data.d.hi++;+        TYPVAL_ENCODE_CONV_STR_STRING(&di->di_key[0],+                                      strlen((char *)&di->di_key[0]));+        TYPVAL_ENCODE_CONV_DICT_AFTER_KEY();+        cur_tv = &di->di_tv;+        break;+      }+      case kMPConvList: {+        if (cur_mpsv->data.l.li == NULL) {+          (void)_mp_pop(mpstack);+          cur_mpsv->data.l.list->lv_copyID = copyID - 1;+          TYPVAL_ENCODE_CONV_LIST_END();+          continue;+        } else if (cur_mpsv->data.l.li != cur_mpsv->data.l.list->lv_first) {+          TYPVAL_ENCODE_CONV_LIST_BETWEEN_ITEMS();+        }+        cur_tv = &cur_mpsv->data.l.li->li_tv;+        cur_mpsv->data.l.li = cur_mpsv->data.l.li->li_next;+        break;+      }+      case kMPConvPairs: {+        if (cur_mpsv->data.l.li == NULL) {+          (void)_mp_pop(mpstack);+          cur_mpsv->data.l.list->lv_copyID = copyID - 1;+          TYPVAL_ENCODE_CONV_DICT_END();+          continue;+        } else if (cur_mpsv->data.l.li != cur_mpsv->data.l.list->lv_first) {+          TYPVAL_ENCODE_CONV_DICT_BETWEEN_ITEMS();+        }+        const list_T *const kv_pair = cur_mpsv->data.l.li->li_tv.vval.v_list;+        TYPVAL_ENCODE_CONV_SPECIAL_DICT_KEY_CHECK(+            encode_vim_to__error_ret, kv_pair->lv_first->li_tv);+        if (_TYPVAL_ENCODE_CONVERT_ONE_VALUE(TYPVAL_ENCODE_FIRST_ARG_NAME,+                                             &mpstack, cur_mpsv,+                                             &kv_pair->lv_first->li_tv,+                                             copyID,+                                             objname) == FAIL) {+          goto encode_vim_to__error_ret;+        }+        TYPVAL_ENCODE_CONV_DICT_AFTER_KEY();+        cur_tv = &kv_pair->lv_last->li_tv;+        cur_mpsv->data.l.li = cur_mpsv->data.l.li->li_next;+        break;+      }+      case kMPConvPartial: {+        partial_T *const pt = cur_mpsv->data.p.pt;+        switch (cur_mpsv->data.p.stage) {+          case kMPConvPartialArgs: {+            TYPVAL_ENCODE_CONV_FUNC_BEFORE_ARGS(pt == NULL ? 0 : pt->pt_argc);+            cur_mpsv->data.p.stage = kMPConvPartialSelf;+            if (pt != NULL && pt->pt_argc > 0) {+              TYPVAL_ENCODE_CONV_LIST_START(pt->pt_argc);","In case of **freeing** a partial this does look wrong. For what list is the refcount decreased?The partial does not have an argument list, but an array of type `typval_T` values. So perhaps instead of using `TYPVAL_ENCODE_CONV_LIST_START()` we could use something like `TYPVAL_ENCODE_CONV_FUNC_LIST_START()`  here that does nothing when freeing and otherwise does what`TYPVAL_ENCODE_CONV_LIST_START()` does?",X
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/5826,93961484,2016-12-27T19:11:59Z,src/nvim/eval/typval_encode.c.h,"@@ -0,0 +1,713 @@+/// @file eval/typval_encode.c.h+///+/// Contains set of macros used to convert (possibly recursive) typval_T into+/// something else. For these macros to work the following macros must be+/// defined:++/// @def TYPVAL_ENCODE_CONV_NIL+/// @brief Macros used to convert NIL value+///+/// Is called both for special dictionary (unless #TYPVAL_ENCODE_ALLOW_SPECIALS+/// is false) and `v:null`. Accepts no arguments, but still must be+/// a function-like macros.++/// @def TYPVAL_ENCODE_CONV_BOOL+/// @brief Macros used to convert boolean value+///+/// Is called both for special dictionary (unless #TYPVAL_ENCODE_ALLOW_SPECIALS+/// is false) and `v:true`/`v:false`.+///+/// @param  num  Boolean value to convert. Value is an expression which+///              evaluates to some integer.++/// @def TYPVAL_ENCODE_CONV_NUMBER+/// @brief Macros used to convert integer+///+/// @param  num  Integer to convert, must accept both varnumber_T and int64_t.++/// @def TYPVAL_ENCODE_CONV_UNSIGNED_NUMBER+/// @brief Macros used to convert unsigned integer+///+/// Not used if #TYPVAL_ENCODE_ALLOW_SPECIALS is false, but still must be+/// defined.+///+/// @param  num  Integer to convert, must accept uint64_t.++/// @def TYPVAL_ENCODE_CONV_FLOAT+/// @brief Macros used to convert floating-point number+///+/// @param  flt  Number to convert, must accept float_T.++/// @def TYPVAL_ENCODE_CONV_STRING+/// @brief Macros used to convert plain string+///+/// Is used to convert VAR_STRING objects as well as BIN strings represented as+/// special dictionary.+///+/// @param  buf  String to convert. Is a char[] buffer, not NUL-terminated.+/// @param  len  String length.++/// @def TYPVAL_ENCODE_CONV_STR_STRING+/// @brief Like #TYPVAL_ENCODE_CONV_STRING, but for STR strings+///+/// Is used to convert dictionary keys and STR strings represented as special+/// dictionaries.++/// @def TYPVAL_ENCODE_CONV_EXT_STRING+/// @brief Macros used to convert EXT string+///+/// Is used to convert EXT strings represented as special dictionaries. Never+/// actually used if #TYPVAL_ENCODE_ALLOW_SPECIALS is false, but still must be+/// defined.+///+/// @param  buf  String to convert. Is a char[] buffer, not NUL-terminated.+/// @param  len  String length.+/// @param  type  EXT type.++/// @def TYPVAL_ENCODE_CONV_FUNC+/// @brief Macros used to convert a function reference+///+/// @param  fun  Function name.++/// @def TYPVAL_ENCODE_CONV_FUNC_START+/// @brief Macros used when starting to convert a funcref or a partial+///+/// @param  fun  Function name.+/// @param  is_partial  True if converted function is a partial.+/// @param  pt  Pointer to partial or NULL.++/// @def TYPVAL_ENCODE_CONV_FUNC_BEFORE_ARGS+/// @brief Macros used before starting to convert partial arguments+///+/// @param  len  Number of arguments. Zero for absent arguments or when+///              converting a funcref.++/// @def TYPVAL_ENCODE_CONV_FUNC_BEFORE_SELF+/// @brief Macros used before starting to convert self dictionary+///+/// @param  len  Number of arguments. May be zero for empty dictionary or -1 for+///              missing self dictionary, also when converting function+///              reference.++/// @def TYPVAL_ENCODE_CONV_FUNC_END+/// @brief Macros used after converting a funcref or a partial+///+/// Accepts no arguments, but still must be a function-like macros.++/// @def TYPVAL_ENCODE_CONV_EMPTY_LIST+/// @brief Macros used to convert an empty list+///+/// Accepts no arguments, but still must be a function-like macros.++/// @def TYPVAL_ENCODE_CONV_EMPTY_DICT+/// @brief Macros used to convert an empty dictionary+///+/// Accepts no arguments, but still must be a function-like macros.++/// @def TYPVAL_ENCODE_CONV_LIST_START+/// @brief Macros used before starting to convert non-empty list+///+/// @param  len  List length. Is an expression which evaluates to an integer.++/// @def TYPVAL_ENCODE_CONV_LIST_BETWEEN_ITEMS+/// @brief Macros used after finishing converting non-last list item+///+/// Accepts no arguments, but still must be a function-like macros.++/// @def TYPVAL_ENCODE_CONV_LIST_END+/// @brief Macros used after converting non-empty list+///+/// Accepts no arguments, but still must be a function-like macros.++/// @def TYPVAL_ENCODE_CONV_DICT_START+/// @brief Macros used before starting to convert non-empty dictionary+///+/// @param  len  Dictionary length. Is an expression which evaluates to an+///              integer.++/// @def TYPVAL_ENCODE_CONV_SPECIAL_DICT_KEY_CHECK+/// @brief Macros used to check special dictionary key+///+/// @param  label  Label for goto in case check was not successfull.+/// @param  key  typval_T key to check.++/// @def TYPVAL_ENCODE_CONV_DICT_AFTER_KEY+/// @brief Macros used after finishing converting dictionary key+///+/// Accepts no arguments, but still must be a function-like macros.++/// @def TYPVAL_ENCODE_CONV_DICT_BETWEEN_ITEMS+/// @brief Macros used after finishing converting non-last dictionary value+///+/// Accepts no arguments, but still must be a function-like macros.++/// @def TYPVAL_ENCODE_CONV_DICT_END+/// @brief Macros used after converting non-empty dictionary+///+/// Accepts no arguments, but still must be a function-like macros.++/// @def TYPVAL_ENCODE_CONV_RECURSE+/// @brief Macros used when self-containing container is detected+///+/// @param  val  Container for which this situation was detected.+/// @param  conv_type  Type of the stack entry, @see MPConvStackValType.++/// @def TYPVAL_ENCODE_ALLOW_SPECIALS+/// @brief Macros that specifies whether special dictionaries are special+///+/// Must be something that evaluates to boolean, most likely `true` or `false`.+/// If it is false then special dictionaries are not treated specially.++/// @def TYPVAL_ENCODE_SCOPE+/// @brief Scope of the main function: either nothing or `static`++/// @def TYPVAL_ENCODE_NAME+/// @brief Name of the target converter+///+/// After including this file it will define function+/// `encode_vim_to_{TYPVAL_ENCODE_NAME}` with scope #TYPVAL_ENCODE_SCOPE and+/// static functions `_typval_encode_{TYPVAL_ENCODE_NAME}_convert_one_value` and+/// `_typval_encode_{TYPVAL_ENCODE_NAME}_check_self_reference`.++/// @def TYPVAL_ENCODE_FIRST_ARG_TYPE+/// @brief Type of the first argument, which will be used to return the results+///+/// Is expected to be a pointer type.++/// @def TYPVAL_ENCODE_FIRST_ARG_NAME+/// @brief Name of the first argument+///+/// This name will only be used by one of the above macros which are defined by+/// the caller. Functions defined here do not use first argument directly.+#ifndef NVIM_EVAL_TYPVAL_ENCODE_C_H+#define NVIM_EVAL_TYPVAL_ENCODE_C_H+#undef NVIM_EVAL_TYPVAL_ENCODE_C_H++#include <stddef.h>+#include <inttypes.h>+#include <assert.h>++#include ""nvim/lib/kvec.h""+#include ""nvim/eval_defs.h""+#include ""nvim/eval/encode.h""+#include ""nvim/func_attr.h""+#include ""nvim/eval/typval_encode.h""++static inline int _TYPVAL_ENCODE_CHECK_SELF_REFERENCE(+    TYPVAL_ENCODE_FIRST_ARG_TYPE TYPVAL_ENCODE_FIRST_ARG_NAME,+    void *const val, int *const val_copyID,+    const MPConvStack *const mpstack, const int copyID,+    const MPConvStackValType conv_type,+    const char *const objname)+  REAL_FATTR_NONNULL_ARG(2, 3, 4, 7) REAL_FATTR_WARN_UNUSED_RESULT+  REAL_FATTR_ALWAYS_INLINE;++/// Function for checking whether container references itself+///+/// @param  TYPVAL_ENCODE_FIRST_ARG_NAME  First argument.+/// @param[in,out]  val  Container to check.+/// @param  val_copyID  Pointer to the container attribute that holds copyID.+///                     After checking whether value of this attribute is+///                     copyID (variable) it is set to copyID.+/// @param[in]  mpstack  Stack with values to convert. Read-only, used for error+///                      reporting.+/// @param[in]  copyID  CopyID used by the caller.+/// @param[in]  conv_type  Type of the conversion, @see MPConvStackValType.+/// @param[in]  objname  Object name, used for error reporting.+///+/// @return NOTDONE in case of success, what to return in case of failure.+static inline int _TYPVAL_ENCODE_CHECK_SELF_REFERENCE(+    TYPVAL_ENCODE_FIRST_ARG_TYPE TYPVAL_ENCODE_FIRST_ARG_NAME,+    void *const val, int *const val_copyID,+    const MPConvStack *const mpstack, const int copyID,+    const MPConvStackValType conv_type,+    const char *const objname)+{+  if (*val_copyID == copyID) {+    TYPVAL_ENCODE_CONV_RECURSE(val, conv_type);+    return OK;+  }+  *val_copyID = copyID;+  return NOTDONE;+}++static int _TYPVAL_ENCODE_CONVERT_ONE_VALUE(+    TYPVAL_ENCODE_FIRST_ARG_TYPE TYPVAL_ENCODE_FIRST_ARG_NAME,+    MPConvStack *const mpstack, MPConvStackVal *const cur_mpsv,+    typval_T *const tv, const int copyID,+    const char *const objname)+  REAL_FATTR_NONNULL_ARG(2, 4, 6) REAL_FATTR_WARN_UNUSED_RESULT;++/// Convert single value+///+/// Only scalar values are converted immediately, everything else is pushed onto+/// the stack.+///+/// @param  TYPVAL_ENCODE_FIRST_ARG_NAME  First argument, defined by the+///                                       includer. Only meaningful to macros+///                                       defined by the includer.+/// @param  mpstack  Stack with values to convert. Values which are not+///                  converted completely by this function (i.e.+///                  non-scalars) are pushed here.+/// @param  cur_mpsv  Currently converted value from stack.+/// @param  tv  Converted value.+/// @param[in]  copyID  CopyID.+/// @param[in]  objname  Object name, used for error reporting.+///+/// @return OK in case of success, FAIL in case of failure.+static int _TYPVAL_ENCODE_CONVERT_ONE_VALUE(+    TYPVAL_ENCODE_FIRST_ARG_TYPE TYPVAL_ENCODE_FIRST_ARG_NAME,+    MPConvStack *const mpstack, MPConvStackVal *const cur_mpsv,+    typval_T *const tv, const int copyID,+    const char *const objname)+{+  switch (tv->v_type) {+    case VAR_STRING: {+      TYPVAL_ENCODE_CONV_STRING(tv->vval.v_string, tv_strlen(tv));+      break;+    }+    case VAR_NUMBER: {+      TYPVAL_ENCODE_CONV_NUMBER(tv->vval.v_number);+      break;+    }+    case VAR_FLOAT: {+      TYPVAL_ENCODE_CONV_FLOAT(tv->vval.v_float);+      break;+    }+    case VAR_FUNC: {+      TYPVAL_ENCODE_CONV_FUNC_START(tv->vval.v_string, false, NULL);+      TYPVAL_ENCODE_CONV_FUNC_BEFORE_ARGS(0);+      TYPVAL_ENCODE_CONV_FUNC_BEFORE_SELF(-1);+      TYPVAL_ENCODE_CONV_FUNC_END();+      break;+    }+    case VAR_PARTIAL: {+      partial_T *const pt = tv->vval.v_partial;+      (void)pt;+      TYPVAL_ENCODE_CONV_FUNC_START(pt->pt_name, true, pt);+      _mp_push(*mpstack, ((MPConvStackVal) {+        .type = kMPConvPartial,+        .tv = tv,+        .data = {+          .p = {+            .stage = kMPConvPartialArgs,+            .pt = tv->vval.v_partial,+          },+        },+      }));+      break;+    }+    case VAR_LIST: {+      if (tv->vval.v_list == NULL || tv->vval.v_list->lv_len == 0) {+        TYPVAL_ENCODE_CONV_EMPTY_LIST();+        break;+      }+      _TYPVAL_ENCODE_DO_CHECK_SELF_REFERENCE(tv->vval.v_list, lv_copyID, copyID,+                                             kMPConvList);+      TYPVAL_ENCODE_CONV_LIST_START(tv->vval.v_list->lv_len);+      _mp_push(*mpstack, ((MPConvStackVal) {+        .type = kMPConvList,+        .tv = tv,+        .data = {+          .l = {+            .list = tv->vval.v_list,+            .li = tv->vval.v_list->lv_first,+          },+        },+      }));+      break;+    }+    case VAR_SPECIAL: {+      switch (tv->vval.v_special) {+        case kSpecialVarNull: {+          TYPVAL_ENCODE_CONV_NIL();+          break;+        }+        case kSpecialVarTrue:+        case kSpecialVarFalse: {+          TYPVAL_ENCODE_CONV_BOOL(tv->vval.v_special == kSpecialVarTrue);+          break;+        }+      }+      break;+    }+    case VAR_DICT: {+      if (tv->vval.v_dict == NULL+          || tv->vval.v_dict->dv_hashtab.ht_used == 0) {+        TYPVAL_ENCODE_CONV_EMPTY_DICT();+        break;+      }+      const dictitem_T *type_di;+      const dictitem_T *val_di;+      if (TYPVAL_ENCODE_ALLOW_SPECIALS+          && tv->vval.v_dict->dv_hashtab.ht_used == 2+          && (type_di = dict_find((dict_T *)tv->vval.v_dict,+                                  (char_u *)""_TYPE"", -1)) != NULL+          && type_di->di_tv.v_type == VAR_LIST+          && (val_di = dict_find((dict_T *)tv->vval.v_dict,+                                 (char_u *)""_VAL"", -1)) != NULL) {+        size_t i;+        for (i = 0; i < ARRAY_SIZE(eval_msgpack_type_lists); i++) {+          if (type_di->di_tv.vval.v_list == eval_msgpack_type_lists[i]) {+            break;+          }+        }+        if (i == ARRAY_SIZE(eval_msgpack_type_lists)) {+          goto _convert_one_value_regular_dict;+        }+        switch ((MessagePackType)i) {+          case kMPNil: {+            TYPVAL_ENCODE_CONV_NIL();+            break;+          }+          case kMPBoolean: {+            if (val_di->di_tv.v_type != VAR_NUMBER) {+              goto _convert_one_value_regular_dict;+            }+            TYPVAL_ENCODE_CONV_BOOL(val_di->di_tv.vval.v_number);+            break;+          }+          case kMPInteger: {+            const list_T *val_list;+            varnumber_T sign;+            varnumber_T highest_bits;+            varnumber_T high_bits;+            varnumber_T low_bits;+            // List of 4 integers; first is signed (should be 1 or -1, but+            // this is not checked), second is unsigned and have at most+            // one (sign is -1) or two (sign is 1) non-zero bits (number of+            // bits is not checked), other unsigned and have at most 31+            // non-zero bits (number of bits is not checked).+            if (val_di->di_tv.v_type != VAR_LIST+                || (val_list = val_di->di_tv.vval.v_list) == NULL+                || val_list->lv_len != 4+                || val_list->lv_first->li_tv.v_type != VAR_NUMBER+                || (sign = val_list->lv_first->li_tv.vval.v_number) == 0+                || val_list->lv_first->li_next->li_tv.v_type != VAR_NUMBER+                || (highest_bits =+                    val_list->lv_first->li_next->li_tv.vval.v_number) < 0+                || val_list->lv_last->li_prev->li_tv.v_type != VAR_NUMBER+                || (high_bits =+                    val_list->lv_last->li_prev->li_tv.vval.v_number) < 0+                || val_list->lv_last->li_tv.v_type != VAR_NUMBER+                || (low_bits = val_list->lv_last->li_tv.vval.v_number) < 0) {+              goto _convert_one_value_regular_dict;+            }+            uint64_t number = ((uint64_t)(((uint64_t)highest_bits) << 62)+                               | (uint64_t)(((uint64_t)high_bits) << 31)+                               | (uint64_t)low_bits);+            if (sign > 0) {+              TYPVAL_ENCODE_CONV_UNSIGNED_NUMBER(number);+            } else {+              TYPVAL_ENCODE_CONV_NUMBER(-number);+            }+            break;+          }+          case kMPFloat: {+            if (val_di->di_tv.v_type != VAR_FLOAT) {+              goto _convert_one_value_regular_dict;+            }+            TYPVAL_ENCODE_CONV_FLOAT(val_di->di_tv.vval.v_float);+            break;+          }+          case kMPString:+          case kMPBinary: {+            const bool is_string = ((MessagePackType)i == kMPString);+            if (val_di->di_tv.v_type != VAR_LIST) {+              goto _convert_one_value_regular_dict;+            }+            size_t len;+            char *buf;+            if (!encode_vim_list_to_buf(val_di->di_tv.vval.v_list, &len,+                                        &buf)) {+              goto _convert_one_value_regular_dict;+            }+            if (is_string) {+              TYPVAL_ENCODE_CONV_STR_STRING(buf, len);+            } else {+              TYPVAL_ENCODE_CONV_STRING(buf, len);+            }+            xfree(buf);+            break;+          }+          case kMPArray: {+            if (val_di->di_tv.v_type != VAR_LIST) {+              goto _convert_one_value_regular_dict;+            }+            _TYPVAL_ENCODE_DO_CHECK_SELF_REFERENCE(val_di->di_tv.vval.v_list,+                                                   lv_copyID, copyID,+                                                   kMPConvList);+            TYPVAL_ENCODE_CONV_LIST_START(val_di->di_tv.vval.v_list->lv_len);+            _mp_push(*mpstack, ((MPConvStackVal) {+              .tv = tv,+              .type = kMPConvList,+              .data = {+                .l = {+                  .list = val_di->di_tv.vval.v_list,+                  .li = val_di->di_tv.vval.v_list->lv_first,+                },+              },+            }));+            break;+          }+          case kMPMap: {+            if (val_di->di_tv.v_type != VAR_LIST) {+              goto _convert_one_value_regular_dict;+            }+            list_T *const val_list = val_di->di_tv.vval.v_list;+            if (val_list == NULL || val_list->lv_len == 0) {+              TYPVAL_ENCODE_CONV_EMPTY_DICT();+              break;+            }+            for (const listitem_T *li = val_list->lv_first; li != NULL;+                 li = li->li_next) {+              if (li->li_tv.v_type != VAR_LIST+                  || li->li_tv.vval.v_list->lv_len != 2) {+                goto _convert_one_value_regular_dict;+              }+            }+            _TYPVAL_ENCODE_DO_CHECK_SELF_REFERENCE(val_list, lv_copyID, copyID,+                                                   kMPConvPairs);+            TYPVAL_ENCODE_CONV_DICT_START(val_list->lv_len);+            _mp_push(*mpstack, ((MPConvStackVal) {+              .tv = tv,+              .type = kMPConvPairs,+              .data = {+                .l = {+                  .list = val_list,+                  .li = val_list->lv_first,+                },+              },+            }));+            break;+          }+          case kMPExt: {+            const list_T *val_list;+            varnumber_T type;+            if (val_di->di_tv.v_type != VAR_LIST+                || (val_list = val_di->di_tv.vval.v_list) == NULL+                || val_list->lv_len != 2+                || (val_list->lv_first->li_tv.v_type != VAR_NUMBER)+                || (type = val_list->lv_first->li_tv.vval.v_number) > INT8_MAX+                || type < INT8_MIN+                || (val_list->lv_last->li_tv.v_type != VAR_LIST)) {+              goto _convert_one_value_regular_dict;+            }+            size_t len;+            char *buf;+            if (!encode_vim_list_to_buf(val_list->lv_last->li_tv.vval.v_list,+                                        &len, &buf)) {+              goto _convert_one_value_regular_dict;+            }+            TYPVAL_ENCODE_CONV_EXT_STRING(buf, len, type);+            xfree(buf);+            break;+          }+        }+        break;+      }+_convert_one_value_regular_dict:+      _TYPVAL_ENCODE_DO_CHECK_SELF_REFERENCE(tv->vval.v_dict, dv_copyID, copyID,+                                             kMPConvDict);+      TYPVAL_ENCODE_CONV_DICT_START(tv->vval.v_dict->dv_hashtab.ht_used);+      _mp_push(*mpstack, ((MPConvStackVal) {+        .tv = tv,+        .type = kMPConvDict,+        .data = {+          .d = {+            .dict = tv->vval.v_dict,+            .hi = tv->vval.v_dict->dv_hashtab.ht_array,+            .todo = tv->vval.v_dict->dv_hashtab.ht_used,+          },+        },+      }));+      break;+    }+    case VAR_UNKNOWN: {+      EMSG2(_(e_intern2), STR(_TYPVAL_ENCODE_CONVERT_ONE_VALUE) ""()"");+      return FAIL;+    }+  }+  return OK;+}++TYPVAL_ENCODE_SCOPE int _TYPVAL_ENCODE_ENCODE(+    TYPVAL_ENCODE_FIRST_ARG_TYPE TYPVAL_ENCODE_FIRST_ARG_NAME,+    typval_T *const tv, const char *const objname)+  REAL_FATTR_NONNULL_ARG(2, 3) REAL_FATTR_WARN_UNUSED_RESULT;++/// Convert the whole typval+///+/// @param  TYPVAL_ENCODE_FIRST_ARG_NAME  First argument, defined by the+///                                       includer. Only meaningful to macros+///                                       defined by the includer.+/// @param  tv  Converted value.+/// @param[in]  objname  Object name, used for error reporting.+///+/// @return OK in case of success, FAIL in case of failure.+TYPVAL_ENCODE_SCOPE int _TYPVAL_ENCODE_ENCODE(+    TYPVAL_ENCODE_FIRST_ARG_TYPE TYPVAL_ENCODE_FIRST_ARG_NAME,+    typval_T *const tv, const char *const objname)+{+  const int copyID = get_copyID();+  MPConvStack mpstack;+  _mp_init(mpstack);+  if (_TYPVAL_ENCODE_CONVERT_ONE_VALUE(TYPVAL_ENCODE_FIRST_ARG_NAME, &mpstack,+                                       NULL,+                                       tv, copyID, objname)+      == FAIL) {+    goto encode_vim_to__error_ret;+  }+  while (_mp_size(mpstack)) {+    MPConvStackVal *cur_mpsv = &_mp_last(mpstack);+    typval_T *cur_tv = NULL;+    switch (cur_mpsv->type) {+      case kMPConvDict: {+        if (!cur_mpsv->data.d.todo) {+          (void)_mp_pop(mpstack);+          cur_mpsv->data.d.dict->dv_copyID = copyID - 1;+          TYPVAL_ENCODE_CONV_DICT_END();+          continue;+        } else if (cur_mpsv->data.d.todo+                   != cur_mpsv->data.d.dict->dv_hashtab.ht_used) {+          TYPVAL_ENCODE_CONV_DICT_BETWEEN_ITEMS();+        }+        while (HASHITEM_EMPTY(cur_mpsv->data.d.hi)) {+          cur_mpsv->data.d.hi++;+        }+        dictitem_T *const di = HI2DI(cur_mpsv->data.d.hi);+        cur_mpsv->data.d.todo--;+        cur_mpsv->data.d.hi++;+        TYPVAL_ENCODE_CONV_STR_STRING(&di->di_key[0],+                                      strlen((char *)&di->di_key[0]));+        TYPVAL_ENCODE_CONV_DICT_AFTER_KEY();+        cur_tv = &di->di_tv;+        break;+      }+      case kMPConvList: {+        if (cur_mpsv->data.l.li == NULL) {+          (void)_mp_pop(mpstack);+          cur_mpsv->data.l.list->lv_copyID = copyID - 1;+          TYPVAL_ENCODE_CONV_LIST_END();+          continue;+        } else if (cur_mpsv->data.l.li != cur_mpsv->data.l.list->lv_first) {+          TYPVAL_ENCODE_CONV_LIST_BETWEEN_ITEMS();+        }+        cur_tv = &cur_mpsv->data.l.li->li_tv;+        cur_mpsv->data.l.li = cur_mpsv->data.l.li->li_next;+        break;+      }+      case kMPConvPairs: {+        if (cur_mpsv->data.l.li == NULL) {+          (void)_mp_pop(mpstack);+          cur_mpsv->data.l.list->lv_copyID = copyID - 1;+          TYPVAL_ENCODE_CONV_DICT_END();+          continue;+        } else if (cur_mpsv->data.l.li != cur_mpsv->data.l.list->lv_first) {+          TYPVAL_ENCODE_CONV_DICT_BETWEEN_ITEMS();+        }+        const list_T *const kv_pair = cur_mpsv->data.l.li->li_tv.vval.v_list;+        TYPVAL_ENCODE_CONV_SPECIAL_DICT_KEY_CHECK(+            encode_vim_to__error_ret, kv_pair->lv_first->li_tv);+        if (_TYPVAL_ENCODE_CONVERT_ONE_VALUE(TYPVAL_ENCODE_FIRST_ARG_NAME,+                                             &mpstack, cur_mpsv,+                                             &kv_pair->lv_first->li_tv,+                                             copyID,+                                             objname) == FAIL) {+          goto encode_vim_to__error_ret;+        }+        TYPVAL_ENCODE_CONV_DICT_AFTER_KEY();+        cur_tv = &kv_pair->lv_last->li_tv;+        cur_mpsv->data.l.li = cur_mpsv->data.l.li->li_next;+        break;+      }+      case kMPConvPartial: {+        partial_T *const pt = cur_mpsv->data.p.pt;+        switch (cur_mpsv->data.p.stage) {+          case kMPConvPartialArgs: {+            TYPVAL_ENCODE_CONV_FUNC_BEFORE_ARGS(pt == NULL ? 0 : pt->pt_argc);+            cur_mpsv->data.p.stage = kMPConvPartialSelf;+            if (pt != NULL && pt->pt_argc > 0) {+              TYPVAL_ENCODE_CONV_LIST_START(pt->pt_argc);+              _mp_push(mpstack, ((MPConvStackVal) {+                .type = kMPConvPartialList,+                .tv = NULL,+                .data = {+                  .a = {+                    .arg = pt->pt_argv,+                    .argv = pt->pt_argv,+                    .todo = (size_t)pt->pt_argc,+                  },+                },+              }));+            }+            break;+          }+          case kMPConvPartialSelf: {+            cur_mpsv->data.p.stage = kMPConvPartialEnd;+            dict_T *const dict = pt == NULL ? NULL : pt->pt_dict;+            if (dict != NULL) {+              TYPVAL_ENCODE_CONV_FUNC_BEFORE_SELF(dict->dv_hashtab.ht_used);+              const int te_csr_ret = _TYPVAL_ENCODE_CHECK_SELF_REFERENCE(+                  TYPVAL_ENCODE_FIRST_ARG_NAME,+                  dict, &dict->dv_copyID, &mpstack, copyID, kMPConvDict,+                  objname);+              if (te_csr_ret != NOTDONE) {+                if (te_csr_ret == FAIL) {+                  goto encode_vim_to__error_ret;+                } else {+                  continue;+                }+              }+              TYPVAL_ENCODE_CONV_DICT_START(dict->dv_hashtab.ht_used);+              _mp_push(mpstack, ((MPConvStackVal) {+                .type = kMPConvDict,+                .tv = NULL,+                .data = {+                  .d = {+                    .dict = dict,+                    .hi = dict->dv_hashtab.ht_array,+                    .todo = dict->dv_hashtab.ht_used,+                  },+                },+              }));+            } else {+              TYPVAL_ENCODE_CONV_FUNC_BEFORE_SELF(-1);+            }+            break;+          }+          case kMPConvPartialEnd: {+            TYPVAL_ENCODE_CONV_FUNC_END();+            (void)_mp_pop(mpstack);+            break;+          }+        }+        continue;+      }+      case kMPConvPartialList: {+        if (!cur_mpsv->data.a.todo) {+          (void)_mp_pop(mpstack);+          TYPVAL_ENCODE_CONV_LIST_END();",Likewise here. When freeing we don't have a list.,X
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/5798,94014728,2016-12-28T10:02:22Z,contrib/nvim_api_docs.py,"@@ -0,0 +1,527 @@+#!/usr/bin/env python+""""""Parses Doxygen XML output to generate Neovim's API documentation.++This would be easier using lxml and XSLT, but:++  1. This should avoid needing Python dependencies, especially ones that are+     C modules that have library dependencies (lxml requires libxml and+     libxslt).+  2. I wouldn't know how to deal with nested indentation in <para> tags using+     XSLT.++Each function documentation is formatted with the following rules:++  - Maximum width of 78 characters (`text_width`).+  - Spaces for indentation.+  - Function signature and helptag are on the same line.+    - Helptag is right aligned.+    - Signature and helptag must have a minimum of 8 characters between+      them.+    - If the signature is too long, it is placed on the line after the+      helptag.  The signature wraps at `text_width - 8` characters with+      subsequent lines indented to the open parenthesis.+  - Documentation body will be indented by 16 spaces.+    - Subsection bodies are indented an additional 4 spaces.+  - Documentation body consists of the function description, parameter details,+    return description, and C declaration.+  - Parameters are omitted for the `void` and `Error *` types, or if the+    parameter is marked as [out].+  - Each function documentation is separated by a single line.++The C declaration is added to the end to show actual argument types.+""""""+import os+import re+import sys+import shutil+import textwrap+import subprocess++from xml.dom import minidom++# Text at the top of the doc file.+preamble = '''+Note: This documentation is generated from Neovim's API source code.+'''++text_width = 78+script_path = os.path.abspath(__file__)+base_dir = os.path.dirname(os.path.dirname(script_path))+src_dir = os.path.join(base_dir, 'src/nvim/api')+out_dir = os.path.join(base_dir, 'tmp/api_doc')+filter_cmd = '%s %s' % (sys.executable, script_path)+seen_funcs = set()++# Tracks `xrefsect` titles.  As of this writing, used only for separating+# deprecated functions.+xrefs = set()+++# XML Parsing Utilities {{{+def find_first(parent, name):+    """"""Finds the first matching node within parent.""""""+    sub = parent.getElementsByTagName(name)+    if not sub:+        return None+    return sub[0]+++def get_children(parent, name):+    """"""Yield matching child nodes within parent.""""""+    for child in parent.childNodes:+        if child.nodeType == child.ELEMENT_NODE and child.nodeName == name:+            yield child+++def get_child(parent, name):+    """"""Get the first matching child node.""""""+    for child in get_children(parent, name):+        return child+    return None+++def clean_text(text):+    """"""Cleans text.++    Only cleans superfluous whitespace at the moment.+    """"""+    return ' '.join(text.split()).strip()+++def clean_lines(text):+    """"""Removes superfluous lines.++    The beginning and end of the string is trimmed.  Empty lines are collapsed.+    """"""+    return re.sub(r'\A\n\s*\n*|\n\s*\n*\Z', '', re.sub(r'(\n\s*\n+)+', '\n\n', text))+++def get_text(parent):+    """"""Combine all text in a node.""""""+    if parent.nodeType == parent.TEXT_NODE:+        return parent.data++    out = ''+    for node in parent.childNodes:+        if node.nodeType == node.TEXT_NODE:+            out += clean_text(node.data)+        elif node.nodeType == node.ELEMENT_NODE:+            out += ' ' + get_text(node)+    return out+++def doc_wrap(text, prefix='', width=70, func=False):+    """"""Wraps text to `width`.++    The first line is prefixed with `prefix`, and subsequent lines are aligned.+    If `func` is True, only wrap at commas.+    """"""+    if not width:+        return text++    indent_space = ' ' * len(prefix)++    if func:+        lines = [prefix]+        for part in text.split(', '):+            if part[-1] not in ');':+                part += ', '+            if len(lines[-1]) + len(part) > width:+                lines.append(indent_space)+            lines[-1] += part+        return '\n'.join(x.rstrip() for x in lines).rstrip()++    return '\n'.join(textwrap.wrap(text.strip(), width=width,+                                   initial_indent=prefix,+                                   subsequent_indent=indent_space))+++def parse_params(parent, width=62):+    """"""Parse Doxygen `parameterlist`.""""""+    name_length = 0+    items = []+    for child in parent.childNodes:+        if child.nodeType == child.TEXT_NODE:+            continue++        name_node = find_first(child, 'parametername')+        if name_node.getAttribute('direction') == 'out':+            continue++        name = '{%s}' % get_text(name_node)+        name_length = max(name_length, len(name) + 2)++        desc = ''+        desc_node = get_child(child, 'parameterdescription')+        if desc_node:+            desc = parse_parblock(desc_node, width=None)+        items.append((name.strip(), desc.strip()))++    out = 'Parameters:~\n'+    for name, desc in items:+        name = '    %s' % name.ljust(name_length)+        out += doc_wrap(desc, prefix=name, width=width) + '\n'+    return out.strip()+++def parse_para(parent, width=62):+    """"""Parse doxygen `para` tag.++    I assume <para> is a paragraph block or ""a block of text"".  It can contain+    text nodes, or other tags.+    """"""+    line = ''+    lines = []+    for child in parent.childNodes:+        if child.nodeType == child.TEXT_NODE:+            line += child.data+        elif child.nodeName == 'computeroutput':+            line += '`%s`' % get_text(child)+        else:+            if line:+                lines.append(doc_wrap(line, width=width))+                line = ''++            if child.nodeName == 'parameterlist':+                lines.append(parse_params(child, width=width))+            elif child.nodeName == 'xrefsect':+                title = get_text(get_child(child, 'xreftitle'))+                xrefs.add(title)+                xrefdesc = parse_para(get_child(child, 'xrefdescription'))+                lines.append(doc_wrap(xrefdesc, prefix='%s: ' % title,+                                      width=width) + '\n')+            elif child.nodeName == 'simplesect':+                kind = child.getAttribute('kind')+                if kind == 'return':+                    lines.append('%s:~' % kind.title())+                    lines.append(doc_wrap(parse_para(child),+                                          prefix='    ',+                                          width=width))+            else:+                lines.append(get_text(child))++    if line:+        lines.append(doc_wrap(line, width=width))+    return clean_lines('\n'.join(lines).strip())+++def parse_parblock(parent, width=62):+    """"""Parses a nested block of `para` tags.++    Named after the \parblock command, but not directly related.+    """"""+    paragraphs = []+    for child in parent.childNodes:+        if child.nodeType == child.TEXT_NODE:+            paragraphs.append(doc_wrap(child.data, width=width))+        elif child.nodeName == 'para':+            paragraphs.append(parse_para(child, width=width))+        else:+            paragraphs.append(doc_wrap(get_text(child), width=width))+        paragraphs.append('')+    return clean_lines('\n'.join(paragraphs).strip())+# }}}+++def parse_source_xml(filename):+    """"""Collects API functions.++    This returns two strings:+      1. The API functions+      2. The deprecated API functions++    The caller decides what to do with the deprecated documentation.+    """"""+    global xrefs+    xrefs = set()+    functions = []+    deprecated_functions = []++    dom = minidom.parse(filename)+    for member in dom.getElementsByTagName('memberdef'):+        if member.getAttribute('static') == 'yes' or \+                member.getAttribute('kind') != 'function':+            continue++        loc = find_first(member, 'location')+        if 'private' in loc.getAttribute('file'):+            continue++        return_type = get_text(get_child(member, 'type'))+        if return_type == '':+            continue++        if return_type.startswith(('ArrayOf', 'DictionaryOf')):+            parts = return_type.strip('_').split('_')+            return_type = '%s(%s)' % (parts[0], ', '.join(parts[1:]))++        name = get_text(get_child(member, 'name'))++        vimtag = '*%s()*' % name+        args = []+        type_length = 0++        for param in get_children(member, 'param'):+            arg_type = get_text(get_child(param, 'type')).strip()+            arg_name = ''+            declname = get_child(param, 'declname')+            if declname:+                arg_name = get_text(declname).strip()++            if arg_type.endswith('*'):+                arg_type = arg_type.strip('* ')+                arg_name = '*' + arg_name+            type_length = max(type_length, len(arg_type))+            args.append((arg_type, arg_name))++        c_args = []+        for arg_type, arg_name in args:+            c_args.append('    ' + (+                '%s %s' % (arg_type.ljust(type_length), arg_name)).strip())++        c_decl = textwrap.indent('%s %s(\n%s\n);' % (return_type, name,+                                                     ',\n'.join(c_args)),+                                 '    ')++        prefix = '%s(' % name+        suffix = '%s)' % ', '.join('{%s}' % a[1] for a in args+                                   if a[0] not in ('void', 'Error'))++        # Minimum 8 chars between signature and vimtag+        lhs = (text_width - 8) - len(prefix)++        if len(prefix) + len(suffix) > lhs:+            signature = vimtag.rjust(text_width) + '\n'+            signature += doc_wrap(suffix, width=text_width-8, prefix=prefix,+                                  func=True)+        else:+            signature = prefix + suffix+            signature += vimtag.rjust(text_width - len(signature))++        doc = ''+        desc = find_first(member, 'detaileddescription')+        if desc:+            doc = parse_parblock(desc)+            if 'DEBUG' in os.environ:+                print(textwrap.indent(+                    re.sub(r'\n\s*\n+', '\n',+                           desc.toprettyxml(indent='  ', newl='\n')), ' ' * 16))++        if not doc:+            doc = 'TODO: Documentation'++        if 'INCLUDE_C_DECL' in os.environ:+            doc += '\n\nC Declaration:~\n>\n'+            doc += c_decl+            doc += '\n<'++        func_doc = signature + '\n'+        func_doc += textwrap.indent(clean_lines(doc), ' ' * 16)+        func_doc = re.sub(r'^\s+([<>])$', r'\1', func_doc, flags=re.M)++        if 'Deprecated' in xrefs:+            deprecated_functions.append(func_doc)+        else:+            functions.append(func_doc)++        xrefs.clear()++    return '\n\n'.join(functions), '\n\n'.join(deprecated_functions)+++def gen_docs(config):+    """"""Generate documentation.++    Doxygen is called and configured through stdin.+    """"""+    p = subprocess.Popen(['doxygen', '-'], stdin=subprocess.PIPE)+    p.communicate(config.format(input=src_dir, output=out_dir,+                                filter=filter_cmd).encode('utf8'))+    if p.returncode:+        sys.exit(p.returncode)++    title_length = 0+    toc = []+    sections = []+    sep = '=' * text_width++    base = os.path.join(out_dir, 'xml')+    dom = minidom.parse(os.path.join(base, 'index.xml'))+    for compound in dom.getElementsByTagName('compound'):+        if compound.getAttribute('kind') != 'file':+            continue++        filename = get_text(find_first(compound, 'name'))+        if filename.endswith('.c'):+            functions, deprecated = parse_source_xml(+                os.path.join(base, '%s.xml' % compound.getAttribute('refid')))++            if functions or deprecated:+                name = os.path.splitext(os.path.basename(filename))[0]+                if name == 'ui':+                    name = name.upper()+                else:+                    name = name.title()++                title = '%d. %s Functions' % (len(toc) + 1, name)+                helptag = '*nvim-api-%s*' % name.lower()+                title_length = max(title_length, len(title))+                toc.append((title, helptag))++                doc = sep+                doc += '\n' + title + helptag.rjust(text_width - len(title))+                if functions:+                    doc += '\n\n' + functions++                if 'INCLUDE_DEPRECATED' in os.environ and deprecated:+                    doc += '\n\n\nDeprecated %s Functions:~\n\n' % name+                    doc += deprecated++                sections.append(doc)++    if not toc:+        return++    title_left = '*api-funcs.txt*'+    title_center = 'Neovim API Function Reference'+    title_right = '{Nvim}'+    margin = max(len(title_left), len(title_right))+    doc = (title_left.ljust(margin) ++           title_center.center(text_width - margin * 2) ++           title_right.rjust(margin)) + '\n'++    doc += '\n%s\n\n' % doc_wrap(preamble, width=text_width)+    doc += 'Contents:\n\n'++    for title, helptag in toc:+        doc += title.ljust(title_length) + '  ' + helptag.replace('*', '|') + '\n'++    doc += '\n'+    for section in sections:+        doc += section+        doc += '\n\n\n'++    doc = doc.rstrip() + '\n\n'+    doc += ' vim:tw=78:ts=8:ft=help:norl:'++    doc_file = os.path.join(base_dir, 'runtime/doc/api-functions.txt')+    with open(doc_file, 'wb') as fp:+        fp.write(doc.encode('utf8'))++    shutil.rmtree(out_dir)+++def filter_source(filename):+    """"""Filters the source to fix macros that confuse Doxygen.""""""+    with open(filename, 'rt') as fp:+        print(re.sub(r'^(ArrayOf|DictionaryOf)(\(.*?\))',+                     lambda m: m.group(1)+'_'.join(+                         re.split(r'[^\w]+', m.group(2))),+                     fp.read(), flags=re.M))+++# Doxygen Config {{{","Instead of duplicating, it wouldn't be possible to instead change the global Doxyfile in `src/` ? The filtering would also be useful for the html output, but it would then need to instead be done in `lua` or `sed` (or some other build dependency). ",X
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/5830,94129389,2016-12-29T12:04:49Z,src/nvim/os/time.c,"@@ -46,31 +47,70 @@ void os_delay(uint64_t milliseconds, bool ignoreinput)     }     LOOP_PROCESS_EVENTS_UNTIL(&main_loop, NULL, (int)milliseconds, got_int);   } else {-    os_microdelay(milliseconds * 1000);+    os_microdelay(milliseconds * 1000u, ignoreinput);   } } -/// Sleeps for a certain amount of microseconds+/// Sleeps for a certain amount of microseconds. ///-/// @param microseconds Number of microseconds to sleep-void os_microdelay(uint64_t microseconds)+/// @param microseconds Number of microseconds to sleep.+/// @param ignoreinput If true, ignore all input (including SIGINT/CTRL-C).+///                    If false, waiting is aborted on any input.+void os_microdelay(uint64_t microseconds, bool ignoreinput) {-  uint64_t elapsed = 0;-  uint64_t ns = microseconds * 1000;  // convert to nanoseconds+  uint64_t elapsed = 0u;   uint64_t base = uv_hrtime();+  const uint64_t input_check_interval = 100000000u;  // 100ms++  // Convert microseconds to nanoseconds. If uint64_t would overflow, set+  // nanoseconds to UINT64_MAX.+  const uint64_t nanoseconds = (microseconds < UINT64_MAX/1000u)+                               ? microseconds * 1000u+                               : UINT64_MAX;    uv_mutex_lock(&delay_mutex); -  while (elapsed < ns) {-    if (uv_cond_timedwait(&delay_cond, &delay_mutex, ns - elapsed)-        == UV_ETIMEDOUT)+  // If the input is ignored, we simply wait the full delay. If not, we+  // check every 'input_check_delay' milliseconds for input and break the+  // waiting loop if input is available.+  while (elapsed < nanoseconds) {+    // We split the waiting period in 'input_check_interval' long intervals in+    // case of 'ignoreinput == true' or wait the whole 'nanoseconds' if+    // 'ignoreinput == false'.+    const uint64_t nanoseconds_delta = (ignoreinput)+                                       ? nanoseconds - elapsed+                                       : MIN(nanoseconds - elapsed,+                                             input_check_interval);++    // Main waiting work happens here.+    if (UV_ETIMEDOUT != uv_cond_timedwait(&delay_cond, &delay_mutex,+                                          nanoseconds_delta)) {+      // In case of an error in uv_cond_timedwait() we continue quietly in+      // release mode and terminate with an error message in debug mode.","[Libuv](http://docs.libuv.org/en/v1.x/threading.html?highlight=uv_cond_timedwait) documentation says the libuv API largely follows the pthread API (in this case see `man pthread_cond_timedwait`) and finally the libuv source code ([unix](https://github.com/libuv/libuv/blob/v1.x/src/unix/thread.c#L502-L534), [win](https://github.com/libuv/libuv/blob/v1.x/src/win/thread.c#L595-L601)) limits the return values to `0` and `UV_ETIMEDOUT`.",X
111942,tweekmonster,https://api.github.com/repos/neovim/neovim/pulls/5798,94258748,2016-12-30T21:21:31Z,contrib/nvim_api_docs.py,"@@ -0,0 +1,527 @@+#!/usr/bin/env python+""""""Parses Doxygen XML output to generate Neovim's API documentation.++This would be easier using lxml and XSLT, but:++  1. This should avoid needing Python dependencies, especially ones that are+     C modules that have library dependencies (lxml requires libxml and+     libxslt).+  2. I wouldn't know how to deal with nested indentation in <para> tags using+     XSLT.++Each function documentation is formatted with the following rules:++  - Maximum width of 78 characters (`text_width`).+  - Spaces for indentation.+  - Function signature and helptag are on the same line.+    - Helptag is right aligned.+    - Signature and helptag must have a minimum of 8 characters between+      them.+    - If the signature is too long, it is placed on the line after the+      helptag.  The signature wraps at `text_width - 8` characters with+      subsequent lines indented to the open parenthesis.+  - Documentation body will be indented by 16 spaces.+    - Subsection bodies are indented an additional 4 spaces.+  - Documentation body consists of the function description, parameter details,+    return description, and C declaration.+  - Parameters are omitted for the `void` and `Error *` types, or if the+    parameter is marked as [out].+  - Each function documentation is separated by a single line.++The C declaration is added to the end to show actual argument types.+""""""+import os+import re+import sys+import shutil+import textwrap+import subprocess++from xml.dom import minidom++# Text at the top of the doc file.+preamble = '''+Note: This documentation is generated from Neovim's API source code.+'''++text_width = 78+script_path = os.path.abspath(__file__)+base_dir = os.path.dirname(os.path.dirname(script_path))+src_dir = os.path.join(base_dir, 'src/nvim/api')+out_dir = os.path.join(base_dir, 'tmp/api_doc')+filter_cmd = '%s %s' % (sys.executable, script_path)+seen_funcs = set()++# Tracks `xrefsect` titles.  As of this writing, used only for separating+# deprecated functions.+xrefs = set()+++# XML Parsing Utilities {{{+def find_first(parent, name):+    """"""Finds the first matching node within parent.""""""+    sub = parent.getElementsByTagName(name)+    if not sub:+        return None+    return sub[0]+++def get_children(parent, name):+    """"""Yield matching child nodes within parent.""""""+    for child in parent.childNodes:+        if child.nodeType == child.ELEMENT_NODE and child.nodeName == name:+            yield child+++def get_child(parent, name):+    """"""Get the first matching child node.""""""+    for child in get_children(parent, name):+        return child+    return None+++def clean_text(text):+    """"""Cleans text.++    Only cleans superfluous whitespace at the moment.+    """"""+    return ' '.join(text.split()).strip()+++def clean_lines(text):+    """"""Removes superfluous lines.++    The beginning and end of the string is trimmed.  Empty lines are collapsed.+    """"""+    return re.sub(r'\A\n\s*\n*|\n\s*\n*\Z', '', re.sub(r'(\n\s*\n+)+', '\n\n', text))+++def get_text(parent):+    """"""Combine all text in a node.""""""+    if parent.nodeType == parent.TEXT_NODE:+        return parent.data++    out = ''+    for node in parent.childNodes:+        if node.nodeType == node.TEXT_NODE:+            out += clean_text(node.data)+        elif node.nodeType == node.ELEMENT_NODE:+            out += ' ' + get_text(node)+    return out+++def doc_wrap(text, prefix='', width=70, func=False):+    """"""Wraps text to `width`.++    The first line is prefixed with `prefix`, and subsequent lines are aligned.+    If `func` is True, only wrap at commas.+    """"""+    if not width:+        return text++    indent_space = ' ' * len(prefix)++    if func:+        lines = [prefix]+        for part in text.split(', '):+            if part[-1] not in ');':+                part += ', '+            if len(lines[-1]) + len(part) > width:+                lines.append(indent_space)+            lines[-1] += part+        return '\n'.join(x.rstrip() for x in lines).rstrip()++    return '\n'.join(textwrap.wrap(text.strip(), width=width,+                                   initial_indent=prefix,+                                   subsequent_indent=indent_space))+++def parse_params(parent, width=62):+    """"""Parse Doxygen `parameterlist`.""""""+    name_length = 0+    items = []+    for child in parent.childNodes:+        if child.nodeType == child.TEXT_NODE:+            continue++        name_node = find_first(child, 'parametername')+        if name_node.getAttribute('direction') == 'out':+            continue++        name = '{%s}' % get_text(name_node)+        name_length = max(name_length, len(name) + 2)++        desc = ''+        desc_node = get_child(child, 'parameterdescription')+        if desc_node:+            desc = parse_parblock(desc_node, width=None)+        items.append((name.strip(), desc.strip()))++    out = 'Parameters:~\n'+    for name, desc in items:+        name = '    %s' % name.ljust(name_length)+        out += doc_wrap(desc, prefix=name, width=width) + '\n'+    return out.strip()+++def parse_para(parent, width=62):+    """"""Parse doxygen `para` tag.++    I assume <para> is a paragraph block or ""a block of text"".  It can contain+    text nodes, or other tags.+    """"""+    line = ''+    lines = []+    for child in parent.childNodes:+        if child.nodeType == child.TEXT_NODE:+            line += child.data+        elif child.nodeName == 'computeroutput':+            line += '`%s`' % get_text(child)+        else:+            if line:+                lines.append(doc_wrap(line, width=width))+                line = ''++            if child.nodeName == 'parameterlist':+                lines.append(parse_params(child, width=width))+            elif child.nodeName == 'xrefsect':+                title = get_text(get_child(child, 'xreftitle'))+                xrefs.add(title)+                xrefdesc = parse_para(get_child(child, 'xrefdescription'))+                lines.append(doc_wrap(xrefdesc, prefix='%s: ' % title,+                                      width=width) + '\n')+            elif child.nodeName == 'simplesect':+                kind = child.getAttribute('kind')+                if kind == 'return':+                    lines.append('%s:~' % kind.title())+                    lines.append(doc_wrap(parse_para(child),+                                          prefix='    ',+                                          width=width))+            else:+                lines.append(get_text(child))++    if line:+        lines.append(doc_wrap(line, width=width))+    return clean_lines('\n'.join(lines).strip())+++def parse_parblock(parent, width=62):+    """"""Parses a nested block of `para` tags.++    Named after the \parblock command, but not directly related.+    """"""+    paragraphs = []+    for child in parent.childNodes:+        if child.nodeType == child.TEXT_NODE:+            paragraphs.append(doc_wrap(child.data, width=width))+        elif child.nodeName == 'para':+            paragraphs.append(parse_para(child, width=width))+        else:+            paragraphs.append(doc_wrap(get_text(child), width=width))+        paragraphs.append('')+    return clean_lines('\n'.join(paragraphs).strip())+# }}}+++def parse_source_xml(filename):+    """"""Collects API functions.++    This returns two strings:+      1. The API functions+      2. The deprecated API functions++    The caller decides what to do with the deprecated documentation.+    """"""+    global xrefs+    xrefs = set()+    functions = []+    deprecated_functions = []++    dom = minidom.parse(filename)+    for member in dom.getElementsByTagName('memberdef'):+        if member.getAttribute('static') == 'yes' or \+                member.getAttribute('kind') != 'function':+            continue++        loc = find_first(member, 'location')+        if 'private' in loc.getAttribute('file'):+            continue++        return_type = get_text(get_child(member, 'type'))+        if return_type == '':+            continue++        if return_type.startswith(('ArrayOf', 'DictionaryOf')):+            parts = return_type.strip('_').split('_')+            return_type = '%s(%s)' % (parts[0], ', '.join(parts[1:]))++        name = get_text(get_child(member, 'name'))++        vimtag = '*%s()*' % name+        args = []+        type_length = 0++        for param in get_children(member, 'param'):+            arg_type = get_text(get_child(param, 'type')).strip()+            arg_name = ''+            declname = get_child(param, 'declname')+            if declname:+                arg_name = get_text(declname).strip()++            if arg_type.endswith('*'):+                arg_type = arg_type.strip('* ')+                arg_name = '*' + arg_name+            type_length = max(type_length, len(arg_type))+            args.append((arg_type, arg_name))++        c_args = []+        for arg_type, arg_name in args:+            c_args.append('    ' + (+                '%s %s' % (arg_type.ljust(type_length), arg_name)).strip())++        c_decl = textwrap.indent('%s %s(\n%s\n);' % (return_type, name,+                                                     ',\n'.join(c_args)),+                                 '    ')++        prefix = '%s(' % name+        suffix = '%s)' % ', '.join('{%s}' % a[1] for a in args+                                   if a[0] not in ('void', 'Error'))++        # Minimum 8 chars between signature and vimtag+        lhs = (text_width - 8) - len(prefix)++        if len(prefix) + len(suffix) > lhs:+            signature = vimtag.rjust(text_width) + '\n'+            signature += doc_wrap(suffix, width=text_width-8, prefix=prefix,+                                  func=True)+        else:+            signature = prefix + suffix+            signature += vimtag.rjust(text_width - len(signature))++        doc = ''+        desc = find_first(member, 'detaileddescription')+        if desc:+            doc = parse_parblock(desc)+            if 'DEBUG' in os.environ:+                print(textwrap.indent(+                    re.sub(r'\n\s*\n+', '\n',+                           desc.toprettyxml(indent='  ', newl='\n')), ' ' * 16))++        if not doc:+            doc = 'TODO: Documentation'++        if 'INCLUDE_C_DECL' in os.environ:+            doc += '\n\nC Declaration:~\n>\n'+            doc += c_decl+            doc += '\n<'++        func_doc = signature + '\n'+        func_doc += textwrap.indent(clean_lines(doc), ' ' * 16)+        func_doc = re.sub(r'^\s+([<>])$', r'\1', func_doc, flags=re.M)++        if 'Deprecated' in xrefs:+            deprecated_functions.append(func_doc)+        else:+            functions.append(func_doc)++        xrefs.clear()++    return '\n\n'.join(functions), '\n\n'.join(deprecated_functions)+++def gen_docs(config):+    """"""Generate documentation.++    Doxygen is called and configured through stdin.+    """"""+    p = subprocess.Popen(['doxygen', '-'], stdin=subprocess.PIPE)+    p.communicate(config.format(input=src_dir, output=out_dir,+                                filter=filter_cmd).encode('utf8'))+    if p.returncode:+        sys.exit(p.returncode)++    title_length = 0+    toc = []+    sections = []+    sep = '=' * text_width++    base = os.path.join(out_dir, 'xml')+    dom = minidom.parse(os.path.join(base, 'index.xml'))+    for compound in dom.getElementsByTagName('compound'):+        if compound.getAttribute('kind') != 'file':+            continue++        filename = get_text(find_first(compound, 'name'))+        if filename.endswith('.c'):+            functions, deprecated = parse_source_xml(+                os.path.join(base, '%s.xml' % compound.getAttribute('refid')))++            if functions or deprecated:+                name = os.path.splitext(os.path.basename(filename))[0]+                if name == 'ui':+                    name = name.upper()+                else:+                    name = name.title()++                title = '%d. %s Functions' % (len(toc) + 1, name)+                helptag = '*nvim-api-%s*' % name.lower()+                title_length = max(title_length, len(title))+                toc.append((title, helptag))++                doc = sep+                doc += '\n' + title + helptag.rjust(text_width - len(title))+                if functions:+                    doc += '\n\n' + functions++                if 'INCLUDE_DEPRECATED' in os.environ and deprecated:+                    doc += '\n\n\nDeprecated %s Functions:~\n\n' % name+                    doc += deprecated++                sections.append(doc)++    if not toc:+        return++    title_left = '*api-funcs.txt*'+    title_center = 'Neovim API Function Reference'+    title_right = '{Nvim}'+    margin = max(len(title_left), len(title_right))+    doc = (title_left.ljust(margin) ++           title_center.center(text_width - margin * 2) ++           title_right.rjust(margin)) + '\n'++    doc += '\n%s\n\n' % doc_wrap(preamble, width=text_width)+    doc += 'Contents:\n\n'++    for title, helptag in toc:+        doc += title.ljust(title_length) + '  ' + helptag.replace('*', '|') + '\n'++    doc += '\n'+    for section in sections:+        doc += section+        doc += '\n\n\n'++    doc = doc.rstrip() + '\n\n'+    doc += ' vim:tw=78:ts=8:ft=help:norl:'++    doc_file = os.path.join(base_dir, 'runtime/doc/api-functions.txt')+    with open(doc_file, 'wb') as fp:+        fp.write(doc.encode('utf8'))++    shutil.rmtree(out_dir)+++def filter_source(filename):+    """"""Filters the source to fix macros that confuse Doxygen.""""""+    with open(filename, 'rt') as fp:+        print(re.sub(r'^(ArrayOf|DictionaryOf)(\(.*?\))',+                     lambda m: m.group(1)+'_'.join(+                         re.split(r'[^\w]+', m.group(2))),+                     fp.read(), flags=re.M))+++# Doxygen Config {{{","> Instead of duplicating, it wouldn't be possible to instead change the global Doxyfile in src/ ?That's what I was doing when I started, but it takes longer if you're only interested in generating the API docs.  The other thing was that this script is only interested in the XML output for `src/nvim/api/` which meant that a lot of other XML files are generated that go unused.  I also wanted to delete the Doxygen output without worrying if it's going to be used after the script finishes.> The filtering would also be useful for the html output, but it would then need to instead be done in lua or sed (or some other build dependency).This went over my head.",X
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/5798,94273374,2016-12-31T12:57:08Z,runtime/doc/api-functions.txt,"@@ -0,0 +1,722 @@+*api-funcs.txt*         Neovim API Function Reference                   {Nvim}++Note: This documentation is generated from Neovim's API source code.++Contents:++1. Buffer Functions   |nvim-api-buffer|+2. Tabpage Functions  |nvim-api-tabpage|+3. UI Functions       |nvim-api-ui|+4. Vim Functions      |nvim-api-vim|+5. Window Functions   |nvim-api-window|++==============================================================================+1. Buffer Functions                                          *nvim-api-buffer*++nvim_buf_line_count({buffer})                          *nvim_buf_line_count()*+                Gets the buffer line count++                Parameters:~+                    {buffer}  Buffer handle++                Return:~+                    Line count++                                                        *nvim_buf_get_lines()*+nvim_buf_get_lines({channel_id}, {buffer}, {start}, {end},","The safest way would actually be to get the argument list from the metadata (available in `build/funcs_data.mpack`). This will also make it possible to expose more info like if the function is available in vimL or not. I guess this could be done in a follow PR, to not block this already very useful PR.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/5847,94275304,2016-12-31T16:15:50Z,runtime/autoload/man.vim,"@@ -309,17 +307,54 @@ function! s:format_candidate(path, psect) abort   endif endfunction +function! s:init_highlight_groups() abort+  highlight default manBold cterm=bold gui=bold+  highlight default manUnderline cterm=underline gui=underline+endfunction+augroup man_colorscheme+ autocmd!+ autocmd ColorScheme * call s:init_highlight_groups()+augroup END+call s:init_highlight_groups()++function! s:strip_backspaced_text(match) abort+  let s:stripped = substitute(a:match, '.\b', '', 'g')+  return s:stripped+endfunction++let s:src_id = nvim_buf_add_highlight(0, 0, '', 0, 0, 0)+function! man#highlight_backspaced_text() abort+  call nvim_buf_clear_highlight(0, s:src_id, 0, -1)+  while 1+    let pos = searchpos('\%(_\b[^_]\)\|\%(\(.\)\b\1\)', 'p')+    if pos[0] == 0+      break+    endif+    let pos[0] -= 1+    let pos[1] -= 1+    if pos[2] ==# 1+      let pattern = '\%(_\b[^_]\)\+'+      let group = 'manUnderline'+    else+      let pattern = '\%(\(.\)\b\1\)\+'+      let group = 'manBold'+    end+    execute 'silent keepjumps substitute/'.pattern.'/\=s:strip_backspaced_text(submatch(0))'",`keeppatterns` is also needed.,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/5847,94275370,2016-12-31T16:22:58Z,runtime/autoload/man.vim,"@@ -309,17 +307,54 @@ function! s:format_candidate(path, psect) abort   endif endfunction +function! s:init_highlight_groups() abort+  highlight default manBold cterm=bold gui=bold+  highlight default manUnderline cterm=underline gui=underline+endfunction+augroup man_colorscheme+ autocmd!+ autocmd ColorScheme * call s:init_highlight_groups()+augroup END+call s:init_highlight_groups()++function! s:strip_backspaced_text(match) abort+  let s:stripped = substitute(a:match, '.\b', '', 'g')+  return s:stripped+endfunction++let s:src_id = nvim_buf_add_highlight(0, 0, '', 0, 0, 0)+function! man#highlight_backspaced_text() abort+  call nvim_buf_clear_highlight(0, s:src_id, 0, -1)+  while 1+    let pos = searchpos('\%(_\b[^_]\)\|\%(\(.\)\b\1\)', 'p')","`searchpos()` has a ""timeout"" parameter, but it's not very useful in a while-loop. And calling `reltime()` in a loop will be too expensive. So maybe the loop should be limited to 1000 iterations.",
111942,tweekmonster,https://api.github.com/repos/neovim/neovim/pulls/5798,94280360,2017-01-01T06:25:46Z,runtime/doc/api-functions.txt,"@@ -0,0 +1,722 @@+*api-funcs.txt*         Neovim API Function Reference                   {Nvim}++Note: This documentation is generated from Neovim's API source code.++Contents:++1. Buffer Functions   |nvim-api-buffer|+2. Tabpage Functions  |nvim-api-tabpage|+3. UI Functions       |nvim-api-ui|+4. Vim Functions      |nvim-api-vim|+5. Window Functions   |nvim-api-window|++==============================================================================+1. Buffer Functions                                          *nvim-api-buffer*++nvim_buf_line_count({buffer})                          *nvim_buf_line_count()*+                Gets the buffer line count++                Parameters:~+                    {buffer}  Buffer handle++                Return:~+                    Line count++                                                        *nvim_buf_get_lines()*+nvim_buf_get_lines({channel_id}, {buffer}, {start}, {end},","Yeah that would be something to look at in a subsequent PR.  I didn't want to have any module dependencies for this script in case it needs to be ran by a developer.  But, if the CI bot is updated to generate the docs, then it wouldn't be a big deal.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/5798,94282161,2017-01-01T10:05:51Z,contrib/nvim_api_docs.py,"@@ -0,0 +1,527 @@+#!/usr/bin/env python+""""""Parses Doxygen XML output to generate Neovim's API documentation.++This would be easier using lxml and XSLT, but:++  1. This should avoid needing Python dependencies, especially ones that are+     C modules that have library dependencies (lxml requires libxml and+     libxslt).+  2. I wouldn't know how to deal with nested indentation in <para> tags using+     XSLT.++Each function documentation is formatted with the following rules:++  - Maximum width of 78 characters (`text_width`).+  - Spaces for indentation.+  - Function signature and helptag are on the same line.+    - Helptag is right aligned.+    - Signature and helptag must have a minimum of 8 characters between+      them.+    - If the signature is too long, it is placed on the line after the+      helptag.  The signature wraps at `text_width - 8` characters with+      subsequent lines indented to the open parenthesis.+  - Documentation body will be indented by 16 spaces.+    - Subsection bodies are indented an additional 4 spaces.+  - Documentation body consists of the function description, parameter details,+    return description, and C declaration.+  - Parameters are omitted for the `void` and `Error *` types, or if the+    parameter is marked as [out].+  - Each function documentation is separated by a single line.++The C declaration is added to the end to show actual argument types.+""""""+import os+import re+import sys+import shutil+import textwrap+import subprocess++from xml.dom import minidom++# Text at the top of the doc file.+preamble = '''+Note: This documentation is generated from Neovim's API source code.+'''++text_width = 78+script_path = os.path.abspath(__file__)+base_dir = os.path.dirname(os.path.dirname(script_path))+src_dir = os.path.join(base_dir, 'src/nvim/api')+out_dir = os.path.join(base_dir, 'tmp/api_doc')+filter_cmd = '%s %s' % (sys.executable, script_path)+seen_funcs = set()++# Tracks `xrefsect` titles.  As of this writing, used only for separating+# deprecated functions.+xrefs = set()+++# XML Parsing Utilities {{{+def find_first(parent, name):+    """"""Finds the first matching node within parent.""""""+    sub = parent.getElementsByTagName(name)+    if not sub:+        return None+    return sub[0]+++def get_children(parent, name):+    """"""Yield matching child nodes within parent.""""""+    for child in parent.childNodes:+        if child.nodeType == child.ELEMENT_NODE and child.nodeName == name:+            yield child+++def get_child(parent, name):+    """"""Get the first matching child node.""""""+    for child in get_children(parent, name):+        return child+    return None+++def clean_text(text):+    """"""Cleans text.++    Only cleans superfluous whitespace at the moment.+    """"""+    return ' '.join(text.split()).strip()+++def clean_lines(text):+    """"""Removes superfluous lines.++    The beginning and end of the string is trimmed.  Empty lines are collapsed.+    """"""+    return re.sub(r'\A\n\s*\n*|\n\s*\n*\Z', '', re.sub(r'(\n\s*\n+)+', '\n\n', text))+++def get_text(parent):+    """"""Combine all text in a node.""""""+    if parent.nodeType == parent.TEXT_NODE:+        return parent.data++    out = ''+    for node in parent.childNodes:+        if node.nodeType == node.TEXT_NODE:+            out += clean_text(node.data)+        elif node.nodeType == node.ELEMENT_NODE:+            out += ' ' + get_text(node)+    return out+++def doc_wrap(text, prefix='', width=70, func=False):+    """"""Wraps text to `width`.++    The first line is prefixed with `prefix`, and subsequent lines are aligned.+    If `func` is True, only wrap at commas.+    """"""+    if not width:+        return text++    indent_space = ' ' * len(prefix)++    if func:+        lines = [prefix]+        for part in text.split(', '):+            if part[-1] not in ');':+                part += ', '+            if len(lines[-1]) + len(part) > width:+                lines.append(indent_space)+            lines[-1] += part+        return '\n'.join(x.rstrip() for x in lines).rstrip()++    return '\n'.join(textwrap.wrap(text.strip(), width=width,+                                   initial_indent=prefix,+                                   subsequent_indent=indent_space))+++def parse_params(parent, width=62):+    """"""Parse Doxygen `parameterlist`.""""""+    name_length = 0+    items = []+    for child in parent.childNodes:+        if child.nodeType == child.TEXT_NODE:+            continue++        name_node = find_first(child, 'parametername')+        if name_node.getAttribute('direction') == 'out':+            continue++        name = '{%s}' % get_text(name_node)+        name_length = max(name_length, len(name) + 2)++        desc = ''+        desc_node = get_child(child, 'parameterdescription')+        if desc_node:+            desc = parse_parblock(desc_node, width=None)+        items.append((name.strip(), desc.strip()))++    out = 'Parameters:~\n'+    for name, desc in items:+        name = '    %s' % name.ljust(name_length)+        out += doc_wrap(desc, prefix=name, width=width) + '\n'+    return out.strip()+++def parse_para(parent, width=62):+    """"""Parse doxygen `para` tag.++    I assume <para> is a paragraph block or ""a block of text"".  It can contain+    text nodes, or other tags.+    """"""+    line = ''+    lines = []+    for child in parent.childNodes:+        if child.nodeType == child.TEXT_NODE:+            line += child.data+        elif child.nodeName == 'computeroutput':+            line += '`%s`' % get_text(child)+        else:+            if line:+                lines.append(doc_wrap(line, width=width))+                line = ''++            if child.nodeName == 'parameterlist':+                lines.append(parse_params(child, width=width))+            elif child.nodeName == 'xrefsect':+                title = get_text(get_child(child, 'xreftitle'))+                xrefs.add(title)+                xrefdesc = parse_para(get_child(child, 'xrefdescription'))+                lines.append(doc_wrap(xrefdesc, prefix='%s: ' % title,+                                      width=width) + '\n')+            elif child.nodeName == 'simplesect':+                kind = child.getAttribute('kind')+                if kind == 'return':+                    lines.append('%s:~' % kind.title())+                    lines.append(doc_wrap(parse_para(child),+                                          prefix='    ',+                                          width=width))+            else:+                lines.append(get_text(child))++    if line:+        lines.append(doc_wrap(line, width=width))+    return clean_lines('\n'.join(lines).strip())+++def parse_parblock(parent, width=62):+    """"""Parses a nested block of `para` tags.++    Named after the \parblock command, but not directly related.+    """"""+    paragraphs = []+    for child in parent.childNodes:+        if child.nodeType == child.TEXT_NODE:+            paragraphs.append(doc_wrap(child.data, width=width))+        elif child.nodeName == 'para':+            paragraphs.append(parse_para(child, width=width))+        else:+            paragraphs.append(doc_wrap(get_text(child), width=width))+        paragraphs.append('')+    return clean_lines('\n'.join(paragraphs).strip())+# }}}+++def parse_source_xml(filename):+    """"""Collects API functions.++    This returns two strings:+      1. The API functions+      2. The deprecated API functions++    The caller decides what to do with the deprecated documentation.+    """"""+    global xrefs+    xrefs = set()+    functions = []+    deprecated_functions = []++    dom = minidom.parse(filename)+    for member in dom.getElementsByTagName('memberdef'):+        if member.getAttribute('static') == 'yes' or \+                member.getAttribute('kind') != 'function':+            continue++        loc = find_first(member, 'location')+        if 'private' in loc.getAttribute('file'):+            continue++        return_type = get_text(get_child(member, 'type'))+        if return_type == '':+            continue++        if return_type.startswith(('ArrayOf', 'DictionaryOf')):+            parts = return_type.strip('_').split('_')+            return_type = '%s(%s)' % (parts[0], ', '.join(parts[1:]))++        name = get_text(get_child(member, 'name'))++        vimtag = '*%s()*' % name+        args = []+        type_length = 0++        for param in get_children(member, 'param'):+            arg_type = get_text(get_child(param, 'type')).strip()+            arg_name = ''+            declname = get_child(param, 'declname')+            if declname:+                arg_name = get_text(declname).strip()++            if arg_type.endswith('*'):+                arg_type = arg_type.strip('* ')+                arg_name = '*' + arg_name+            type_length = max(type_length, len(arg_type))+            args.append((arg_type, arg_name))++        c_args = []+        for arg_type, arg_name in args:+            c_args.append('    ' + (+                '%s %s' % (arg_type.ljust(type_length), arg_name)).strip())++        c_decl = textwrap.indent('%s %s(\n%s\n);' % (return_type, name,+                                                     ',\n'.join(c_args)),+                                 '    ')++        prefix = '%s(' % name+        suffix = '%s)' % ', '.join('{%s}' % a[1] for a in args+                                   if a[0] not in ('void', 'Error'))++        # Minimum 8 chars between signature and vimtag+        lhs = (text_width - 8) - len(prefix)++        if len(prefix) + len(suffix) > lhs:+            signature = vimtag.rjust(text_width) + '\n'+            signature += doc_wrap(suffix, width=text_width-8, prefix=prefix,+                                  func=True)+        else:+            signature = prefix + suffix+            signature += vimtag.rjust(text_width - len(signature))++        doc = ''+        desc = find_first(member, 'detaileddescription')+        if desc:+            doc = parse_parblock(desc)+            if 'DEBUG' in os.environ:+                print(textwrap.indent(+                    re.sub(r'\n\s*\n+', '\n',+                           desc.toprettyxml(indent='  ', newl='\n')), ' ' * 16))++        if not doc:+            doc = 'TODO: Documentation'++        if 'INCLUDE_C_DECL' in os.environ:+            doc += '\n\nC Declaration:~\n>\n'+            doc += c_decl+            doc += '\n<'++        func_doc = signature + '\n'+        func_doc += textwrap.indent(clean_lines(doc), ' ' * 16)+        func_doc = re.sub(r'^\s+([<>])$', r'\1', func_doc, flags=re.M)++        if 'Deprecated' in xrefs:+            deprecated_functions.append(func_doc)+        else:+            functions.append(func_doc)++        xrefs.clear()++    return '\n\n'.join(functions), '\n\n'.join(deprecated_functions)+++def gen_docs(config):+    """"""Generate documentation.++    Doxygen is called and configured through stdin.+    """"""+    p = subprocess.Popen(['doxygen', '-'], stdin=subprocess.PIPE)+    p.communicate(config.format(input=src_dir, output=out_dir,+                                filter=filter_cmd).encode('utf8'))+    if p.returncode:+        sys.exit(p.returncode)++    title_length = 0+    toc = []+    sections = []+    sep = '=' * text_width++    base = os.path.join(out_dir, 'xml')+    dom = minidom.parse(os.path.join(base, 'index.xml'))+    for compound in dom.getElementsByTagName('compound'):+        if compound.getAttribute('kind') != 'file':+            continue++        filename = get_text(find_first(compound, 'name'))+        if filename.endswith('.c'):+            functions, deprecated = parse_source_xml(+                os.path.join(base, '%s.xml' % compound.getAttribute('refid')))++            if functions or deprecated:+                name = os.path.splitext(os.path.basename(filename))[0]+                if name == 'ui':+                    name = name.upper()+                else:+                    name = name.title()++                title = '%d. %s Functions' % (len(toc) + 1, name)+                helptag = '*nvim-api-%s*' % name.lower()+                title_length = max(title_length, len(title))+                toc.append((title, helptag))++                doc = sep+                doc += '\n' + title + helptag.rjust(text_width - len(title))+                if functions:+                    doc += '\n\n' + functions++                if 'INCLUDE_DEPRECATED' in os.environ and deprecated:+                    doc += '\n\n\nDeprecated %s Functions:~\n\n' % name+                    doc += deprecated++                sections.append(doc)++    if not toc:+        return++    title_left = '*api-funcs.txt*'+    title_center = 'Neovim API Function Reference'+    title_right = '{Nvim}'+    margin = max(len(title_left), len(title_right))+    doc = (title_left.ljust(margin) ++           title_center.center(text_width - margin * 2) ++           title_right.rjust(margin)) + '\n'++    doc += '\n%s\n\n' % doc_wrap(preamble, width=text_width)+    doc += 'Contents:\n\n'++    for title, helptag in toc:+        doc += title.ljust(title_length) + '  ' + helptag.replace('*', '|') + '\n'++    doc += '\n'+    for section in sections:+        doc += section+        doc += '\n\n\n'++    doc = doc.rstrip() + '\n\n'+    doc += ' vim:tw=78:ts=8:ft=help:norl:'++    doc_file = os.path.join(base_dir, 'runtime/doc/api-functions.txt')+    with open(doc_file, 'wb') as fp:+        fp.write(doc.encode('utf8'))++    shutil.rmtree(out_dir)+++def filter_source(filename):+    """"""Filters the source to fix macros that confuse Doxygen.""""""+    with open(filename, 'rt') as fp:+        print(re.sub(r'^(ArrayOf|DictionaryOf)(\(.*?\))',+                     lambda m: m.group(1)+'_'.join(+                         re.split(r'[^\w]+', m.group(2))),+                     fp.read(), flags=re.M))+++# Doxygen Config {{{","Doxygen is never run automatically by our build system. I wouldn't expect packagers to run it either, as it generates internal dev docs and not user docs (nor after this PR either, as the release tarball will include up-to-date api docs). `build/` is already 100M without Doxygen, so it is not a order-of-magnitude explosion, and it will only affect when Doxygen is run for a good reason, it doesn't affect building/developing nvim in general. In the end, the ideal would be the same bot-ci script both updating the html docs and checking whether the api vimdocs need updating.> I assure you that every second that passed generating the full docs while I was tweaking/testing the formatting was felt and loathed.Yes, but futher on, one could temporarily change the input path even in the global config when tweaking output settings, to speed up the dev cycle.> the filter is very simpleThe point is not the filter being simple or complex, rather that it should apply to all Doxygen use, regardless of output format, as it fixes an issue in input processing.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/5847,94500863,2017-01-03T22:49:59Z,runtime/syntax/man.vim,"@@ -5,18 +5,30 @@ if exists('b:current_syntax')   finish endif -syntax case  ignore-syntax match manReference      display '[^()[:space:]]\+([0-9nx][a-z]*)'-syntax match manSectionHeading display '^\S.*$'-syntax match manTitle          display '^\%1l.*$'-syntax match manSubHeading     display '^ \{3\}\S.*$'-syntax match manOptionDesc     display '^\s\+\%(+\|-\)\S\+'+syntax match manBackspacedCharacter display conceal '.\b'+syntax match manBold                display contains=manBackspacedCharacter '\%(\([[:graph:]]\)\b\1\)\+'+syntax match manUnderline           display contains=manBackspacedCharacter '\%(_\b[^_]\)\+' -highlight default link manTitle          Title-highlight default link manSectionHeading Statement-highlight default link manOptionDesc     Constant-highlight default link manReference      PreProc-highlight default link manSubHeading     Function+if !exists('#man_highlight_groups')+  function! s:init_highlight_groups() abort+    let group = 'Keyword'+    while 1+      let values = execute('highlight '.group)+      if values =~# '='+        let values = substitute(values, '.* \(\w\+=.*\)', '\1', '')+        break+      endif+      let group = substitute(values, '.* to \(\w\+\)', '\1', '')",This is tricky to get right and I kinda winced when I saw it :) Maybe this helps though: https://github.com/justinmk/vim-sneak/blob/master/autoload/sneak/hl.vim#L19,
10180857,nhooyr,https://api.github.com/repos/neovim/neovim/pulls/5847,94541262,2017-01-04T07:59:17Z,runtime/syntax/man.vim,"@@ -5,18 +5,30 @@ if exists('b:current_syntax')   finish endif -syntax case  ignore-syntax match manReference      display '[^()[:space:]]\+([0-9nx][a-z]*)'-syntax match manSectionHeading display '^\S.*$'-syntax match manTitle          display '^\%1l.*$'-syntax match manSubHeading     display '^ \{3\}\S.*$'-syntax match manOptionDesc     display '^\s\+\%(+\|-\)\S\+'+syntax match manBackspacedCharacter display conceal '.\b'+syntax match manBold                display contains=manBackspacedCharacter '\%(\([[:graph:]]\)\b\1\)\+'+syntax match manUnderline           display contains=manBackspacedCharacter '\%(_\b[^_]\)\+' -highlight default link manTitle          Title-highlight default link manSectionHeading Statement-highlight default link manOptionDesc     Constant-highlight default link manReference      PreProc-highlight default link manSubHeading     Function+if !exists('#man_highlight_groups')+  function! s:init_highlight_groups() abort+    let group = 'Keyword'+    while 1+      let values = execute('highlight '.group)+      if values =~# '='+        let values = substitute(values, '.* \(\w\+=.*\)', '\1', '')+        break+      endif+      let group = substitute(values, '.* to \(\w\+\)', '\1', '')","Yea, linking to Keyword by default without bolding doesn't look too bad. https://dropbox.aubble.com/Screen%20Shot%202017-01-04%20at%202.58.53%20AM.png",
112971,jamessan,https://api.github.com/repos/neovim/neovim/pulls/5877,94593016,2017-01-04T14:36:28Z,src/nvim/testdir/test_digraph.vim,"@@ -243,6 +243,7 @@ func! Test_digraphs_option()   call Put_Dig_BS(""P"",""="")   call assert_equal(['��']+repeat([""���""],2)+['��'], getline(line('.')-3,line('.')))   "" Not a digraph: this is different from <c-k>!+  exe ""norm! 3o""",Could you instead add the Vim-default value for `'backspace'` to [src/nvim/testdir/runtest.vim](https://github.com/neovim/neovim/blob/695703ca97e9330e3dbbeb3153b57b4ca565d045/src/nvim/testdir/runtest.vim#L65-L67) so other tests don't have to account for this?,
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/5826,94608641,2017-01-04T15:57:28Z,src/nvim/eval/encode.c,"@@ -807,7 +821,9 @@ char *encode_tv2string(typval_T *tv, size_t *len) {   garray_T ga;   ga_init(&ga, (int)sizeof(char), 80);-  encode_vim_to_string(&ga, tv, ""encode_tv2string() argument"");+  const int evs_ret = encode_vim_to_string(&ga, tv,+                                           ""encode_tv2string() argument"");+  (void)evs_ret;","AFAIR `(void)func()` does not always work. Though I guess I can add assert here and to tv2echo (these may give error message sometimes, but not actually fail) and check and free the return in tv2json: last one in case of errors currently just returns incomplete output.",X
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/5905,95061845,2017-01-07T17:13:26Z,runtime/plugin/health.vim,"@@ -1 +1,7 @@-command! -nargs=* CheckHealth call health#check([<f-args>])+function! s:complete(lead, _line, _pos) abort+  return filter(map(glob($VIMRUNTIME.'/autoload/health/*', 1, 1),","@mhinz Best way to do this is using `globpath()` (do not forget to escape commas and backslashes). Second-best is concatenating with `fnameescape($VIMRUNTIME)` (does not work on Windows in some cases; AFAIR in some Neovim issue there was an agreement that such Vim issues should be fixed even if fixing them will break compatibility, but I do not know the state). This variant is inappropriate because it does not work if `$VIMRUNTIME` contains any glob character including things like `$word`.",X
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/5280,95422199,2017-01-10T18:06:12Z,src/nvim/eval.c,"@@ -16043,6 +16043,7 @@ static void get_system_output_as_rettv(typval_T *argvars, typval_T *rettv,   // get shell command to execute   char **argv = tv_to_argv(&argvars[0], NULL);   if (!argv) {+    set_vim_var_nr(VV_SHELL_ERROR, (long)-1);","In #5910 I changed this to only set `v:shell_error` if `tv_to_argv()` returns `executable==false`. The other failures are parameter validation, which should _not_ set `v:shell_error`.",X
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/4700,95696807,2017-01-11T23:30:51Z,src/nvim/ops.c,"@@ -5704,18 +5705,23 @@ size_t op_register_amount(void)  /// Set register to a given value ///-/// @param[in]  name  Register name.-/// @param[in]  reg   Register value.","Better save the previous line and make this line have one *less* space: aligning parameter name descriptions makes diffs larger and requires more work (I mean, to reformat if needed), so I no longer do this. AFAIK most other contributors do neither.",X
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/5928,95800103,2017-01-12T14:20:48Z,test/functional/autocmd/dirchanged_spec.lua,"@@ -0,0 +1,52 @@+local lfs = require('lfs')+local h = require('test.functional.helpers')(after_each)++local clear = h.clear+local eq = h.eq+local eval = h.eval+local execute = h.execute++describe('Event DirChanged ->', function()+  local wd = lfs.currentdir()+  local dirs = {+    wd .. '/Xtest-functional-autocmd-dirchanged.dir1',+    wd .. '/Xtest-functional-autocmd-dirchanged.dir2',+    wd .. '/Xtest-functional-autocmd-dirchanged.dir3',+  }++  setup(function()    for _, dir in pairs(dirs) do h.mkdir(dir) end end)+  teardown(function() for _, dir in pairs(dirs) do h.rmdir(dir) end end)++  before_each(clear)++  describe('""autocmd DirChanged', function()+    it('*"" sets v:event for all :cd variants', function()+      execute('autocmd DirChanged * let event = copy(v:event)')++      execute('lcd '..dirs[1])+      eq({path=dirs[1], scope='window'}, eval('event'))++      execute('tcd '..dirs[2])+      eq({path=dirs[2], scope='tab'}, eval('event'))++      execute('cd '..dirs[3])+      eq({path=dirs[3], scope='global'}, eval('event'))+    end)++    -- TODO(mhinz): Add more tests here if we start to make+    --              use of the autocmd pattern.","To test the API, could use `request(""nvim_set_current_dir"", ...)`, e.g. https://github.com/justinmk/neovim/blob/a85d116b1c4360da05ef1d6bc75e322b0b0b8e0d/test/functional/autocmd/bufenter_spec.lua#L16",
972014,mhinz,https://api.github.com/repos/neovim/neovim/pulls/5928,95806250,2017-01-12T14:50:54Z,src/nvim/ex_docmd.c,"@@ -6948,10 +6948,39 @@ void free_cd_dir(void)  #endif +void apply_autocmd_dirchanged(char_u *new_dir, CdScope scope)+{+  dict_T *dict = get_vim_var_dict(VV_EVENT);+  char buf[8];++  switch (scope) {+  case kCdScopeGlobal:+    snprintf(buf, sizeof buf, ""global"");+    break;+  case kCdScopeTab:+    snprintf(buf, sizeof buf, ""tab"");+    break;+  case kCdScopeWindow:+    snprintf(buf, sizeof buf, ""window"");","Still not a fan of `sizeof(foo)`, because `sizeof` is not a function, even if its usage is similar. But I'll be nice. ;]",
972014,mhinz,https://api.github.com/repos/neovim/neovim/pulls/5936,95892954,2017-01-12T21:52:04Z,src/nvim/option.c,"@@ -236,6 +236,7 @@ typedef struct vimoption { #define P_NO_ML        0x2000000U  ///< not allowed in modeline #define P_CURSWANT     0x4000000U  ///< update curswant required; not needed                                    ///< when there is a redraw flag+#define P_RWINONLY     0x10000000U ///< only redraw current window","Should be moved one line below, since it's twice as big as `P_NO_DEF_EXP`.",
972014,mhinz,https://api.github.com/repos/neovim/neovim/pulls/5936,95894187,2017-01-12T21:58:36Z,src/nvim/options.lua,"@@ -539,7 +539,7 @@ return {       full_name='cursorline', abbreviation='cul',       type='bool', scope={'window'},       vi_def=true,-      redraw={'current_window'},+      redraw={'current_window_only'},",Should be added to https://github.com/neovim/neovim/blob/master/src/nvim/options.lua#L20-L21,
112971,jamessan,https://api.github.com/repos/neovim/neovim/pulls/5928,95989408,2017-01-13T12:48:07Z,src/nvim/ex_docmd.c,"@@ -6952,7 +6952,7 @@ void free_cd_dir(void) /// Deal with the side effects of changing the current directory. /// /// @param scope  Scope of the function call (global, tab or window).",The `new_dir` parameter was added ... which isn't used?,X
9766,blueyed,https://api.github.com/repos/neovim/neovim/pulls/5936,96073914,2017-01-13T21:06:21Z,src/nvim/option.c,"@@ -238,6 +238,8 @@ typedef struct vimoption {                                    ///< when there is a redraw flag #define P_NO_DEF_EXP   0x8000000U  ///< Do not expand default value. +#define P_RWINONLY     0x10000000U  ///< only redraw current window+","@justinmk Good catch.Does this patch look good?```diffdiff --git i/src/nvim/option.c w/src/nvim/option.cindex 76667fa9..a4e7da77 100644--- i/src/nvim/option.c+++ w/src/nvim/option.c@@ -213,12 +213,12 @@ typedef struct vimoption { #define P_VI_DEF        0x400U   /* Use Vi default for Vim */ #define P_VIM           0x800U   /* Vim option */ -/* when option changed, what to display: */-#define P_RSTAT         0x1000U  /* redraw status lines */-#define P_RWIN          0x2000U  /* redraw current window */-#define P_RBUF          0x4000U  /* redraw current buffer */-#define P_RALL          0x6000U  /* redraw all windows */-#define P_RCLR          0x7000U  /* clear and redraw all */+// when option changed, what to display:+#define P_RSTAT         0x1000U  ///< redraw status lines+#define P_RWIN          0x2000U  ///< redraw current window and recompute text+#define P_RBUF          0x4000U  ///< redraw current buffer and recompute text+#define P_RALL          0x6000U  ///< redraw all windows+#define P_RCLR          0x7000U  ///< clear and redraw all  #define P_COMMA         0x8000U    ///< comma separated list #define P_ONECOMMA      0x18000U   ///< P_COMMA and cannot have two consecutive```What is the purpose/meaning of `///<` vs just `//`?",X
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/5753,96127103,2017-01-15T00:03:26Z,src/nvim/mark.c,"@@ -130,9 +130,21 @@ int setmark_pos(int c, pos_T *pos, int fnum)     return OK;   } +  buf_T *buf = curbuf;+  if (fnum != curbuf->b_fnum) {+      buf = firstbuf;+      while (buf != NULL && buf->b_fnum != fnum) {",I think `buflist_findnr()` can be used instead.,X
10683473,DarkDeepBlue,https://api.github.com/repos/neovim/neovim/pulls/5956,96178247,2017-01-16T08:10:02Z,src/nvim/fileio.c,"@@ -707,7 +707,7 @@ readfile (      * always using the GUI.      */     if (read_stdin) {-      mch_msg(_(""Nvim: Reading from stdin...\n""));+      mch_msg(_(""Nvim: Reading from stdin ...\n""));","Thanks for the hint. I will consider that in the future.In German at least the difference is that the former version means an interrupted word, while the latter version means an interrupted sentence. So, it was a pendantic change anyway.",
4070620,hardenedapple,https://api.github.com/repos/neovim/neovim/pulls/5782,96203242,2017-01-16T10:50:44Z,test/functional/normal/put_spec.lua,"@@ -0,0 +1,1012 @@+local helpers = require('test.functional.helpers')(after_each)++local clear = helpers.clear+local insert = helpers.insert+local feed = helpers.feed+local expect = helpers.expect+local eq = helpers.eq+local execute = helpers.execute+local curbuf_contents = helpers.curbuf_contents+local funcs = helpers.funcs+local dedent = helpers.dedent+local getreg = funcs.getreg++local function reset()+    clear()+    insert([[+    Line of words 1+    Line of words 2]])+    execute('goto 1')+    feed('itest_string.<esc>u')+    funcs.setreg('a', 'test_stringa', 'V')+    funcs.setreg('b', 'test_stringb\ntest_stringb\ntest_stringb', 'b')+    funcs.setreg('""', 'test_string""', 'v')+end++local function map(func, tab)+    local rettab = {}+    for k, v in pairs(tab) do+        rettab[k] = func(v)+    end+    return rettab+end++local function filter(filter_func, tab)+    local rettab = {}+    for _, entry in pairs(tab) do+        if not filter_func(entry) then+            table.insert(rettab, entry)+        end+    end+    return rettab+end++local function splitlines(string)+    local newline_start+    local newline_end, prev_newline_end = 0, 0+    local string_end = string:len()+    local rettab = {}+    while newline_end do+        newline_start, newline_end = string:find('\n', newline_end + 1)+        if not newline_start then+            table.insert(rettab, string:sub(prev_newline_end + 1, string_end))+        else+            table.insert(rettab, string:sub(prev_newline_end + 1, newline_start - 1))+        end+        prev_newline_end = newline_end+    end+    return rettab+end++-- We check the last inserted register "". in each of these tests because it is+-- implemented completely differently in do_put().+-- It is implemented differently so that control characters and imap'ped+-- characters work in the same manner when pasted as when inserted.+describe('put command', function()+    before_each(reset)++    local function visual_marks_zero()+        for _,v in pairs(funcs.getpos(""'<"")) do+            if v ~= 0 then+                return false+            end+        end+        for _,v in pairs(funcs.getpos(""'>"")) do+            if v ~= 0 then+                return false+            end+        end+        return true+    end++    -- {{{ Where test definitions are run+    local function run_test_variations(test_variations, extra_setup)+        reset()+        if extra_setup then extra_setup() end+        local init_contents = curbuf_contents()+        local init_cursorpos = funcs.getcurpos()+        local assert_no_change = function (exception_table, after_undo)+                    expect(init_contents)+                    -- When putting the "". register forwards, undo doesn't move+                    -- the cursor back to where it was before.+                    -- This is because it uses the command character 'a' to+                    -- start the insert, and undo after that leaves the cursor+                    -- one place to the right (unless we were at the end of the+                    -- line when we pasted).+                    if not (exception_table.undo_position and after_undo) then+                        eq(funcs.getcurpos(), init_cursorpos)+                    end+        end++        for _, test in pairs(test_variations) do+            it(test.description, function()+                reset()+                if extra_setup then extra_setup() end+                local orig_dotstr = funcs.getreg('.')+                helpers.ok(visual_marks_zero())+                -- Make sure every test starts from the same conditions+                assert_no_change(test.exception_table, false)+                local was_cli = test.test_action()+                test.test_assertions(test.exception_table, false)+                -- Check that undo twice puts us back to the original conditions+                -- (i.e. puts the cursor and text back to before)+                feed('u')+                assert_no_change(test.exception_table, true)++                -- Should not have changed the "". register+                -- If we paste the "". register with a count we can't avoid+                -- changing this register, hence avoid this check.+                if not test.exception_table.dot_reg_changed then+                    eq(funcs.getreg('.'), orig_dotstr)+                end++                -- Doing something, undoing it, and then redoing it should+                -- leave us in the same state as just doing it once.+                -- For :ex actions we want '@:', for normal actions we want '.'++                -- The '.' redo doesn't work for visual put so just exit if+                -- it was tested.+                -- We check that visual put was used by checking if the '< and+                -- '> marks were changed.+                if not visual_marks_zero() then+                    return+                end++                if test.exception_table.undo_position then+                    funcs.setpos('.', init_cursorpos)+                end+                if was_cli then+                    feed('@:')+                else+                    feed('.')+                end++                test.test_assertions(test.exception_table, true)+            end)+        end+    end -- run_test_variations()+    -- }}}++    local function create_test_defs(test_defs, command_base, command_creator, -- {{{+        expect_base, expect_creator)+        local rettab = {}+        local exceptions+        for _, v in pairs(test_defs) do+            if v[4] then+                exceptions = v[4]+            else+                exceptions = {}+            end+            table.insert(rettab,+            {+                test_action = command_creator(command_base, v[1]),+                test_assertions = expect_creator(expect_base, v[2]),+                description = v[3],+                exception_table = exceptions,+            })+        end+        return rettab+    end -- create_test_defs() }}}++    local function find_cursor_position(expect_string) -- {{{+        -- There must only be one occurance of the character 'x' in+        -- expect_string.+        -- This function removes that occurance, and returns the position that+        -- it was in.+        -- This returns the cursor position that would leave the 'x' in that+        -- place if we feed 'ix<esc>' and the string existed before it.+        for linenum, line in pairs(splitlines(expect_string)) do+            local column = line:find('x')+            if column then+                return {linenum, column}, expect_string:gsub('x', '')+            end+        end+    end -- find_cursor_position() }}}++    -- Action function creators {{{+    local function create_p_action(test_map, substitution)+        return function()+            local temp_val = test_map:gsub('p', substitution)+            feed(temp_val)+            return false+        end+    end++    local function create_put_action(command_base, substitution)+        return function()+            local temp_val = command_base:gsub('put', substitution)+            execute(temp_val)+            return true+        end+    end+    -- }}}++    -- Expect function creator {{{+    local function expect_creator(conversion_function, expect_base, conversion_table)+        local temp_expect_string = conversion_function(expect_base, conversion_table)+        local cursor_position, expect_string = find_cursor_position(temp_expect_string)+        return function(exception_table, after_redo)+            expect(expect_string)++            -- Have to use getcurpos() instead of curwinmeths.get_cursor() in+            -- order to account for virtualedit.+            -- We always want the curswant element in getcurpos(), which is+            -- sometimes different to the column element in+            -- curwinmeths.get_cursor().+            -- NOTE: The "".gp command leaves the cursor after the pasted text+            -- when running, but does not when the command is redone with the+            -- '.' command.+            if not (exception_table.redo_position and after_redo) then+                local actual_position = funcs.getcurpos()+                eq(cursor_position, {actual_position[2], actual_position[5]})+            end+        end+    end -- expect_creator() }}}++    -- Test definitions {{{+    local function copy_def(def)+        local rettab = { '', {}, '', nil }+        rettab[1] = def[1]+        for k,v in pairs(def[2]) do+            rettab[2][k] = v+        end+        rettab[3] = def[3]+        if def[4] then+            rettab[4] = {}+            for k,v in pairs(def[4]) do+                rettab[4][k] = v+            end+        end+        return rettab+    end++    local normal_command_defs = {+        {+            'p',+            {cursor_after = false, put_backwards = false, dot_register = false},+            'pastes after cursor with p',+        },+        {+            'gp',+            {cursor_after = true, put_backwards = false, dot_register = false},+            'leaves cursor after text with gp',+        },+        {+            '"".p',+            {cursor_after = false, put_backwards = false, dot_register = true},+            'works with the "". register',++        },+        {+            '"".gp',+            {cursor_after = true, put_backwards = false, dot_register = true},+            'gp works with the "". register',+            {redo_position = true},+        },+        {+            'P',+            {cursor_after = false, put_backwards = true, dot_register = false},+            'pastes before cursor with P',+        },+        {+            'gP',+            {cursor_after = true, put_backwards = true, dot_register = false},+            'gP pastes before cursor and leaves cursor after text',+        },+        {+            '"".P',+            {cursor_after = false, put_backwards = true, dot_register = true},+            'P works with "". register',+        },+        {+            '"".gP',+            {cursor_after = true, put_backwards = true, dot_register = true},+            'gP works with "". register',+            {redo_position = true},+        },+    }++    -- Add a definition applying a count for each definition above.+    -- Could do this for each transformation (p -> P, p -> gp etc), but I think+    -- it's neater this way (balance between being explicit and too verbose).+    for i = 1,#normal_command_defs do+        local cur = normal_command_defs[i]++        -- Make modified copy of current definition that includes a count.+        local newdef = copy_def(cur)+        newdef[2].count = 2+        cur[2].count = 1+        newdef[1] = '2' .. newdef[1]+        newdef[3] = 'double ' .. newdef[3]++        if cur[2].dot_register then+            if not cur[4] then+                newdef[4] = {}+            end+            newdef[4].dot_reg_changed = true+        end++        normal_command_defs[#normal_command_defs + 1] = newdef+    end++    local ex_command_defs = {+        {+            'put',+            {put_backwards = false, dot_register = false},+            'pastes linewise forwards with :put',+        },+        {+            'put!',+            {put_backwards = true, dot_register = false},+            'pastes linewise backwards with :put!',+        },+        {+            'put .',+            {put_backwards = false, dot_register = true},+            'pastes linewise with the dot register',+        },+        {+            'put! .',+            {put_backwards = true, dot_register = true},+            'pastes linewise backwards with the dot register',+        },+    }++    local function non_dotdefs(def_table)+        return filter(function(def) return def[2].dot_register end, def_table)+    end++    -- }}}++    -- Conversion functions {{{+    local function convert_characterwise(expect_base, conversion_table,+        virtualedit_end, visual_put)+        expect_base = dedent(expect_base)+        -- There is no difference between 'P' and 'p' when VIsual_active+        if not visual_put then+            if conversion_table.put_backwards then+                -- Special case for virtualedit at the end of a line.+                local replace_string+                if not virtualedit_end then+                    replace_string = 'test_stringx""%1'+                else+                    replace_string = 'test_stringx""'+                end+                expect_base = expect_base:gsub('(.)test_stringx""', replace_string)+            end+        end+        if conversion_table.count > 1 then+            local rep_string = 'test_string""'+            local extra_puts =  rep_string:rep(conversion_table.count - 1)+            expect_base = expect_base:gsub('test_stringx""', extra_puts .. 'test_stringx""')+        end+        if conversion_table.cursor_after then+            expect_base = expect_base:gsub('test_stringx""', 'test_string""x')+        end+        if conversion_table.dot_register then+            expect_base = expect_base:gsub('(test_stringx?)""', '%1.')+        end+        return expect_base+    end -- convert_characterwise()++    local function make_back(string)+        local prev_line+        local rettab = {}+        local string_found = false+        for _, line in pairs(splitlines(string)) do+            if line:find('test_string') then+                string_found = true+                table.insert(rettab, line)+            else+                if string_found then+                    if prev_line then+                        table.insert(rettab, prev_line)+                        prev_line = nil+                    end+                    table.insert(rettab, line)+                else+                    table.insert(rettab, prev_line)+                    prev_line = line+                end+            end+        end+        -- In case there are no lines after the text that was put.+        if prev_line and string_found then+            table.insert(rettab, prev_line)+        end+        return table.concat(rettab, '\n')+    end -- make_back()++    local function convert_linewise(expect_base, conversion_table, _, use_a, indent)+        expect_base = dedent(expect_base)+        if conversion_table.put_backwards then+            expect_base = make_back(expect_base)+        end+        local p_str = 'test_string""'+        if use_a then+            p_str = 'test_stringa'+        end++        if conversion_table.dot_register then+            expect_base = expect_base:gsub('x' .. p_str, 'xtest_string.')+            p_str = 'test_string.'+        end++        if conversion_table.cursor_after then+            expect_base = expect_base:gsub('x' .. p_str .. '\n', p_str .. '\nx')+        end++        -- The 'indent' argument is only used here because a single put with an+        -- indent doesn't require special handling. It doesn't require special+        -- handling because the cursor is never put before the indent, hence+        -- the modification of 'test_stringx""' gives the same overall answer as+        -- modifying '    test_stringx""'.++        -- Only happens when using normal mode command actions.+        if conversion_table.count and conversion_table.count > 1 then+            if not indent then+                indent = ''+            end+            local rep_string = indent .. p_str .. '\n'+            local extra_puts =  rep_string:rep(conversion_table.count - 1)+            local orig_string, new_string+            if conversion_table.cursor_after then+                orig_string = indent .. p_str .. '\nx'+                new_string = extra_puts .. orig_string+            else+                orig_string = indent .. 'x' .. p_str .. '\n'+                new_string = orig_string .. extra_puts+            end+            expect_base = expect_base:gsub(orig_string, new_string)+        end+        return expect_base+    end++    local function put_x_last(orig_line, p_str)+        local prev_end, cur_end, cur_start = 0, 0, 0+        while cur_start do+            prev_end = cur_end+            cur_start, cur_end = orig_line:find(p_str, prev_end)+        end+        -- Assume (because that is the only way I call it) that p_str matches+        -- the pattern 'test_string.'+        return orig_line:sub(1, prev_end - 1) .. 'x' .. orig_line:sub(prev_end)+    end++    local function convert_blockwise(expect_base, conversion_table,+                                        visual, use_b,+                                        trailing_whitespace)+        expect_base = dedent(expect_base)+        local p_str = 'test_string""'+        if use_b then+            p_str = 'test_stringb'+        end++        if conversion_table.dot_register then+            expect_base = expect_base:gsub('(x?)' .. p_str, '%1test_string.')+            -- Looks strange, but the dot is a special character in the pattern+            -- and a literal character in the replacement.+            expect_base = expect_base:gsub('test_stringx.', 'test_stringx.')+            p_str = 'test_string.'+        end++        -- No difference between 'p' and 'P' in visual mode.+        if not visual then+            if conversion_table.put_backwards then+                -- One for the line where the cursor is left, one for all other+                -- lines.+                expect_base = expect_base:gsub('([^x])' .. p_str, p_str .. '%1')+                expect_base = expect_base:gsub('([^x])x' .. p_str, 'x' .. p_str .. '%1')+                if not trailing_whitespace then+                    expect_base = expect_base:gsub(' \n', '\n')+                    expect_base = expect_base:gsub(' $', '')+                end+            end+        end++        if conversion_table.count and conversion_table.count > 1 then+            local p_pattern = p_str:gsub('%.', '%%.')+            expect_base = expect_base:gsub(p_pattern,+                                            p_str:rep(conversion_table.count))+            expect_base = expect_base:gsub('test_stringx([b"".])',+                                            p_str:rep(conversion_table.count - 1)+                                            .. '%0')+        end++        if conversion_table.cursor_after then+            if not visual then+                local prev_line+                local rettab = {}+                local prev_in_block = false+                for _, line in pairs(splitlines(expect_base)) do+                    if line:find('test_string') then+                        if prev_line then+                            prev_line = prev_line:gsub('x', '')+                            table.insert(rettab, prev_line)+                        end+                        prev_line = line+                        prev_in_block = true+                    else+                        if prev_in_block then+                            prev_line = put_x_last(prev_line, p_str)+                            table.insert(rettab, prev_line)+                            prev_in_block = false+                        end+                        table.insert(rettab, line)+                    end+                end+                if prev_line and prev_in_block then+                    table.insert(rettab, put_x_last(prev_line, p_str))+                end++                expect_base = table.concat(rettab, '\n')+            else+                expect_base = expect_base:gsub('x(.)', '%1x')+            end+        end++        return expect_base+    end+    -- }}}++    -- Convenience functions {{{+    local function run_normal_mode_tests(test_string, base_map, extra_setup,+        virtualedit_end, selection_string)+        local function convert_closure(e, c)+            return convert_characterwise(e, c, virtualedit_end, selection_string)+        end+        local function expect_normal_creator(expect_base, conversion_table)+            local test_expect = expect_creator(convert_closure, expect_base, conversion_table)+            return function(exception_table, after_redo)+                test_expect(exception_table, after_redo)+                if selection_string then+                    eq(getreg('""'), selection_string)+                else+                    eq(getreg('""'), 'test_string""')+                end+            end+        end+        run_test_variations(+            create_test_defs(+                normal_command_defs,+                base_map,+                create_p_action,+                test_string,+                expect_normal_creator+            ),+            extra_setup+        )+    end -- run_normal_mode_tests()++    local function convert_linewiseer(expect_base, conversion_table)+        return expect_creator(convert_linewise, expect_base, conversion_table)+    end++    local function run_linewise_tests(expect_base, base_command, extra_setup)+        local linewise_test_defs = create_test_defs(+                ex_command_defs, base_command,+                create_put_action, expect_base, convert_linewiseer)+        run_test_variations(linewise_test_defs, extra_setup)+    end -- run_linewise_tests()+    -- }}}++    -- Actual tests+    describe('default pasting', function()+        local expect_string = [[+        Ltest_stringx""ine of words 1+        Line of words 2]]+        run_normal_mode_tests(expect_string, 'p')++        run_linewise_tests([[+            Line of words 1+            xtest_string""+            Line of words 2]],+            'put'+        )+    end)++    describe('linewise register', function()+        -- put with 'p'+        local local_ex_command_defs = non_dotdefs(normal_command_defs)+        local base_expect_string = [[+        Line of words 1+        xtest_stringa+        Line of words 2]]+        local function local_convert_linewise(expect_base, conversion_table)+            return convert_linewise(expect_base, conversion_table, nil, true)+        end+        local function expect_lineput(expect_base, conversion_table)+            return expect_creator(local_convert_linewise, expect_base, conversion_table)+        end+        run_test_variations(+            create_test_defs(+                local_ex_command_defs,+                '""ap',+                create_p_action,+                base_expect_string,+                expect_lineput+            )+        )++        -- put with :put+        local linewise_put_defs = non_dotdefs(ex_command_defs)+        base_expect_string = [[+        Line of words 1+        xtest_stringa+        Line of words 2]]+        run_test_variations(+            create_test_defs(+                linewise_put_defs,+                'put a', create_put_action,+                base_expect_string, convert_linewiseer+            )+        )++    end)++    describe('blockwise register', function()+        -- put before with 'p'+        local blockwise_put_defs = non_dotdefs(normal_command_defs)+        local test_base = [[+        Lxtest_stringbine of words 1+        Ltest_stringbine of words 2+         test_stringb]]++        local function expect_block_creator(expect_base, conversion_table)+            return expect_creator(function(e,c) return convert_blockwise(e,c,nil,true) end,+                                        expect_base, conversion_table)+        end++        run_test_variations(+            create_test_defs(+                blockwise_put_defs,+                '""bp',+                create_p_action,+                test_base,+                expect_block_creator+            )+        )+    end)++    it('adds correct indentation when put with [p and ]p', function()+        feed('G>>""a]pix<esc>')+        -- luacheck: ignore+        expect([[+        Line of words 1+        	Line of words 2+        	xtest_stringa]])+        feed('uu""a[pix<esc>')+        -- luacheck: ignore+        expect([[+        Line of words 1+        	xtest_stringa+        	Line of words 2]])+    end)++    describe('linewise paste with autoindent', function()+        -- luacheck: ignore+        run_linewise_tests([[+              Line of words 1+              	Line of words 2+              xtest_string""]],+                'put'+            ,+            function()+                funcs.setline('$', '	Line of words 2')+                -- Set curswant to '8' to be at the end of the tab character+                -- This is where the cursor is put back after the 'u' command.+                funcs.setpos('.', {0, 2, 1, 0, 8})+                execute('set autoindent')+            end+        )+    end)++    describe('put inside tabs with virtualedit', function()+        local test_string = [[+        Line of words 1+           test_stringx""     Line of words 2]]+        run_normal_mode_tests(test_string, 'p', function()+            funcs.setline('$', '	Line of words 2')+            execute('set virtualedit=all')+            funcs.setpos('.', {0, 2, 1, 2, 3})+        end)+    end)++    describe('put after the line with virtualedit', function()+        local test_string = [[+        Line of words 1  test_stringx""+        	Line of words 2]]+        run_normal_mode_tests(test_string, 'p', function()+            funcs.setline('$', '	Line of words 2')+            execute('set virtualedit=all')+            funcs.setpos('.', {0, 1, 16, 1, 17})+        end, true)+    end)++    describe('Visual put', function()+        describe('basic put', function()+            local test_string = [[+            test_stringx"" words 1+            Line of words 2]]+            run_normal_mode_tests(test_string, 'v2ep', nil, nil, 'Line of')+        end)+        describe('over trailing newline', function()","I use `describe()` because the `run_test_variations()` function I use (through `run_normal_mode_tests()` in this case) calls `it()` for each of the generated test definitions i.e. `describe('basic put' ...)` groups the set of tests where each of `'p', 'gp', 'P', '"".p', '2p', 'gP', ...` is tested in the basic case of putting over a visual selection.Hence if I use an `it()` at the second level, I get the error `test/functional/normal/put_spec.lua:102: 'it' not supported inside current context block`.That's also why I don't use `before_each()` very much: most of my tests are generated and run in `run_test_variations()`, so I thought I may as well put the setup function calls in that `it()` call.It may be a little unclear (my bad), but it's how I make sure every put variation is tested in each situation. ",
972014,mhinz,https://api.github.com/repos/neovim/neovim/pulls/5782,96297069,2017-01-16T20:01:18Z,src/nvim/ops.c,"@@ -2637,12 +2637,71 @@ void do_put(int regname, yankreg_T *reg, int dir, long count, int flags)    * special characters (newlines, etc.).    */   if (regname == '.') {-    (void)stuff_inserted((dir == FORWARD ? (count == -1 ? 'o' : 'a') :-                          (count == -1 ? 'O' : 'i')), count, FALSE);-    /* Putting the text is done later, so can't really move the cursor to-     * the next character.  Use ""l"" to simulate it. */-    if ((flags & PUT_CURSEND) && gchar_cursor() != NUL)-      stuffcharReadbuff('l');+    bool non_linewise_vis = (VIsual_active && VIsual_mode != 'V');++    // PUT_LINE has special handling below which means we use 'i' to start.+    char command_start_char = non_linewise_vis ? 'c' :+        (flags & PUT_LINE ? 'i' : (dir == FORWARD ? 'a' : 'i'));++    // To avoid being the affect of 'autoindent' on linewise puts, we create a+    // new line with `:put _`.+    if (flags & PUT_LINE) { do_put('_', NULL, dir, 1, PUT_LINE); }",Never put condition and body on the same line.,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/5963,96623132,2017-01-18T12:22:48Z,test/functional/ui/screen.lua,"@@ -205,6 +205,8 @@ end  function Screen:try_resize(columns, rows)   uimeths.try_resize(columns, rows)+  -- Give ourselves a chance to _handle_resize+  self:sleep(0.1)","Does it allow [this pending test](https://github.com/neovim/neovim/blob/d3b4764dc137e0f6f2c219244e00fba92a64a384/test/functional/ui/screen_basic_spec.lua#L567) to be re-enabled?Instead of sleeping 100ms, can this use `helpers.retry()` to keep trying every 1ms until `_height` is correct?",
112971,jamessan,https://api.github.com/repos/neovim/neovim/pulls/5963,96625499,2017-01-18T12:38:15Z,test/functional/ui/screen.lua,"@@ -205,6 +205,8 @@ end  function Screen:try_resize(columns, rows)   uimeths.try_resize(columns, rows)+  -- Give ourselves a chance to _handle_resize+  self:sleep(0.1)","This is sleeping 0.1ms, unless the input parameter for sleep is misnamed. Basically, give a chance for other stuff to run, then continue.",
112971,jamessan,https://api.github.com/repos/neovim/neovim/pulls/5974,96695588,2017-01-18T17:58:40Z,test/functional/ui/screen_basic_spec.lua,"@@ -690,4 +689,12 @@ describe('Screen', function()       end)     end)   end)++  it('nvim_ui_attach() handles very large width/height #2180', function()+    screen:detach()+    screen = Screen.new(999, 999)","If the test isn't sensitive to timing, but just takes longer to run, there's no need to mark it.",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/5995,97244520,2017-01-23T02:21:50Z,src/nvim/ex_cmds.c,"@@ -1408,32 +1408,30 @@ char_u *make_filter_cmd(char_u *cmd, char_u *itmp, char_u *otmp)   }    if (itmp != NULL) {-    strncat(buf, "" < "", len);-    strncat(buf, (char *) itmp, len);+    strncat(buf, "" < "", len - 1);+    strncat(buf, (const char *)itmp, len - 1);","@jamessan Buffer is already filled by `vim_snprintf`/`strncpy`, so to actually supply correct length one needs to write different code with more complex calculations. Or do not bother at all, memory should���ve been allocated correctly:```C#define STRAPPEND(p, s, len) \    do {      const size_t len_ = (len);      memcpy(p, s, len_);      p += len_;    } while (0)char *p = buf;if (itmp || otmp) {  const char *const fmt = is_fish_shell ? ""begin; %s; end"" : ""(%s)"";  p += vim_snprintf(p, len, fmt, (const char *)cmd);} else {  STRAPPEND(p, cmd, len);}if (itmp) {  STRAPPEND(p, S_LEN("" < ""));  STRAPPEND(p, itmp, STRLEN(itmp));}```",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/5996,97334915,2017-01-23T15:00:22Z,src/nvim/memory.c,"@@ -389,6 +389,33 @@ size_t xstrlcpy(char *restrict dst, const char *restrict src, size_t size)   return ret; } +/// xstrlcat - Appends string src to the end of dst.+///+/// Compatible with *BSD strlcat: Appends at most (dstsize - strlen(dst) - 1)+/// characters. dst will be NUL-terminated.+///+/// Note: Replaces `vim_strcat`.+///+/// @param dst      Where to copy the string to+/// @param src      Where to copy the string from+/// @param dstsize  Size of destination buffer, must be greater than 0+/// @return         strlen(src) + MIN(dstsize, strlen(initial dst)).+///                 If retval >= dstsize, truncation occurs.+size_t xstrlcat(char *restrict dst, const char *restrict src, size_t dstsize)+  FUNC_ATTR_NONNULL_ALL+{+  assert(dstsize > 0);","You can���t safely call `strlen(dst)` on a `xmalloc(0)` output. Our code always allocates one byte in this case, but it is a question who will do initialization if many devs think that `xmalloc()` is almost the same thing as `malloc()`, with the exception of non-NULL return (and `man malloc` does not guarantee that `malloc(0)` will return something which may be read).",X
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/3048,97540343,2017-01-24T13:01:19Z,src/nvim/tui/tui.c,"@@ -350,6 +351,10 @@ static void tui_resize(UI *ui, int width, int height)   data->scroll_region.left = 0;   data->scroll_region.right = width - 1;   data->row = data->col = 0;+  // try to resize the terminal window+  char r[16];  // enough for 9999x9999+  snprintf(r, sizeof(r), ""\x1b[8;%d;%dt"", height, width);","@fmoralesc If I'm reading http://invisible-island.net/xterm/ctlseqs/ctlseqs.html correctly it seems we should use `4` instead of `8`. Do you recall why you choose `8`?```CSI Ps ; Ps ; Ps t          Window manipulation (from dtterm, as well as extensions).          ...            Ps = 4  ;  height ;  width -> Resize the xterm window to          given height and width in pixels.  Omitted parameters reuse          the current height or width.  Zero parameters use the dis-          play's height or width.            ...            Ps = 8  ;  height ;  width -> Resize the text area to given          height and width in characters.  Omitted parameters reuse the          current height or width.  Zero parameters use the display's          height or width.```",X
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/6017,98014361,2017-01-26T15:17:02Z,src/nvim/memory.c,"@@ -372,47 +372,49 @@ char *xstpncpy(char *restrict dst, const char *restrict src, size_t maxlen) /// /// @param dst    Buffer to store the result /// @param src    String to be copied-/// @param size   Size of `dst`+/// @param dsize  Size of `dst` /// @return       strlen(src). If retval >= dstsize, truncation occurs.-size_t xstrlcpy(char *restrict dst, const char *restrict src, size_t size)+size_t xstrlcpy(char *restrict dst, const char *restrict src, size_t dsize)   FUNC_ATTR_NONNULL_ALL {   size_t slen = strlen(src); -  if (size) {-    size_t len = MIN(slen, size - 1);+  if (dsize) {+    size_t len = MIN(slen, dsize - 1);     memcpy(dst, src, len);     dst[len] = '\0';   }    return slen;  // Does not include NUL. } -/// xstrlcat - Appends string src to the end of dst.+/// Appends `src` to string `dst` of size `dsize` (unlike strncat, dsize is the+/// full size of `dst`, not space left).  At most dsize-1 characters+/// will be copied.  Always NUL terminates. ///-/// Compatible with *BSD strlcat: Appends at most (dstsize - strlen(dst) - 1)-/// characters. dst will be NUL-terminated.+/// @see vim_strcat from Vim.+/// @see strlcat from OpenBSD. ///-/// Note: Replaces `vim_strcat`.-///-/// @param dst      Buffer to store the string-/// @param src      String to be copied-/// @param dstsize  Size of destination buffer, must be greater than 0-/// @return         strlen(src) + MIN(dstsize, strlen(initial dst)).-///                 If retval >= dstsize, truncation occurs.-size_t xstrlcat(char *restrict dst, const char *restrict src, size_t dstsize)+/// @param dst      String to be appended-to+/// @param src      String to put at the end of `dst`+/// @param dsize    Size of `dst`, must be greater than 0+/// @return         strlen(src) + MIN(dsize, strlen(initial dst)).+///                 If retval >= dsize, truncation occurs.+size_t xstrlcat(char *restrict dst, const char *restrict src, size_t dsize)   FUNC_ATTR_NONNULL_ALL {-  assert(dstsize > 0);-  size_t srclen = strlen(src);-  size_t dstlen = strlen(dst);-  size_t ret = srclen + dstlen;  // Total string length (excludes NUL)-  if (srclen) {-    size_t len = (ret >= dstsize) ? dstsize - 1 : ret;-    memcpy(dst + dstlen, src, len - dstlen);-    dst[len] = '\0';+  assert(dsize > 0);+  size_t dlen = strlen(dst);+  size_t slen = strlen(src);++  if (dlen + slen + 1 > dsize) {+    memmove(dst + dlen, src, dsize - dlen - 1);+    dst[dsize - 1] = '\0';+  } else {+    memmove(dst + dlen, src, slen + 1);   }-  return ret;  // Does not include NUL.++  return slen + MIN(dlen, dsize);  // Does not include NUL.",How can `dlen` be bigger than `dsize`?,X
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/6017,98050589,2017-01-26T17:51:54Z,src/nvim/memory.c,"@@ -372,47 +372,49 @@ char *xstpncpy(char *restrict dst, const char *restrict src, size_t maxlen) /// /// @param dst    Buffer to store the result /// @param src    String to be copied-/// @param size   Size of `dst`+/// @param dsize  Size of `dst` /// @return       strlen(src). If retval >= dstsize, truncation occurs.-size_t xstrlcpy(char *restrict dst, const char *restrict src, size_t size)+size_t xstrlcpy(char *restrict dst, const char *restrict src, size_t dsize)   FUNC_ATTR_NONNULL_ALL {   size_t slen = strlen(src); -  if (size) {-    size_t len = MIN(slen, size - 1);+  if (dsize) {+    size_t len = MIN(slen, dsize - 1);     memcpy(dst, src, len);     dst[len] = '\0';   }    return slen;  // Does not include NUL. } -/// xstrlcat - Appends string src to the end of dst.+/// Appends `src` to string `dst` of size `dsize` (unlike strncat, dsize is the+/// full size of `dst`, not space left).  At most dsize-1 characters+/// will be copied.  Always NUL terminates. ///-/// Compatible with *BSD strlcat: Appends at most (dstsize - strlen(dst) - 1)-/// characters. dst will be NUL-terminated.+/// @see vim_strcat from Vim.+/// @see strlcat from OpenBSD. ///-/// Note: Replaces `vim_strcat`.-///-/// @param dst      Buffer to store the string-/// @param src      String to be copied-/// @param dstsize  Size of destination buffer, must be greater than 0-/// @return         strlen(src) + MIN(dstsize, strlen(initial dst)).-///                 If retval >= dstsize, truncation occurs.-size_t xstrlcat(char *restrict dst, const char *restrict src, size_t dstsize)+/// @param dst      String to be appended-to+/// @param src      String to put at the end of `dst`+/// @param dsize    Size of `dst`, must be greater than 0+/// @return         strlen(src) + MIN(dsize, strlen(initial dst)).+///                 If retval >= dsize, truncation occurs.+size_t xstrlcat(char *restrict dst, const char *restrict src, size_t dsize)   FUNC_ATTR_NONNULL_ALL {-  assert(dstsize > 0);-  size_t srclen = strlen(src);-  size_t dstlen = strlen(dst);-  size_t ret = srclen + dstlen;  // Total string length (excludes NUL)-  if (srclen) {-    size_t len = (ret >= dstsize) ? dstsize - 1 : ret;-    memcpy(dst + dstlen, src, len - dstlen);-    dst[len] = '\0';+  assert(dsize > 0);+  size_t dlen = strlen(dst);+  size_t slen = strlen(src);++  if (dlen + slen + 1 > dsize) {+    memmove(dst + dlen, src, dsize - dlen - 1);+    dst[dsize - 1] = '\0';+  } else {+    memmove(dst + dlen, src, slen + 1);   }","@justinmk It makes replacing memcpy with memmove utterly useless: compiler may optimize both to the same code, with the same problems if memory areas actually overlap. And this PR assumes that `xstrlcat` may be used for overlapping areas.",X
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/6017,98053147,2017-01-26T18:04:25Z,src/nvim/memory.c,"@@ -372,47 +372,49 @@ char *xstpncpy(char *restrict dst, const char *restrict src, size_t maxlen) /// /// @param dst    Buffer to store the result /// @param src    String to be copied-/// @param size   Size of `dst`+/// @param dsize  Size of `dst` /// @return       strlen(src). If retval >= dstsize, truncation occurs.-size_t xstrlcpy(char *restrict dst, const char *restrict src, size_t size)+size_t xstrlcpy(char *restrict dst, const char *restrict src, size_t dsize)   FUNC_ATTR_NONNULL_ALL {   size_t slen = strlen(src); -  if (size) {-    size_t len = MIN(slen, size - 1);+  if (dsize) {+    size_t len = MIN(slen, dsize - 1);     memcpy(dst, src, len);     dst[len] = '\0';   }    return slen;  // Does not include NUL. } -/// xstrlcat - Appends string src to the end of dst.+/// Appends `src` to string `dst` of size `dsize` (unlike strncat, dsize is the+/// full size of `dst`, not space left).  At most dsize-1 characters+/// will be copied.  Always NUL terminates. ///-/// Compatible with *BSD strlcat: Appends at most (dstsize - strlen(dst) - 1)-/// characters. dst will be NUL-terminated.+/// @see vim_strcat from Vim.+/// @see strlcat from OpenBSD. ///-/// Note: Replaces `vim_strcat`.-///-/// @param dst      Buffer to store the string-/// @param src      String to be copied-/// @param dstsize  Size of destination buffer, must be greater than 0-/// @return         strlen(src) + MIN(dstsize, strlen(initial dst)).-///                 If retval >= dstsize, truncation occurs.-size_t xstrlcat(char *restrict dst, const char *restrict src, size_t dstsize)+/// @param dst      String to be appended-to+/// @param src      String to put at the end of `dst`+/// @param dsize    Size of `dst`, must be greater than 0+/// @return         strlen(src) + MIN(dsize, strlen(initial dst)).+///                 If retval >= dsize, truncation occurs.+size_t xstrlcat(char *restrict dst, const char *restrict src, size_t dsize)   FUNC_ATTR_NONNULL_ALL {","As a result I would write this as```Csize_t xstrlcat(char *const dst, const char *const src, const size_t dsize)  FUNC_ATTR_NONNULL_ALL{  assert(dsize > 0);  const size_t dlen = strlen(dst);  assert(dlen < dsize);  const size_t slen = strlen(src);  if (slen > dsize - dlen - 1) {    memmove(dst + dlen, src, dsize - dlen - 1);    dst[dsize - 1] = NUL;  } else {    memmove(dst + dlen, src, slen + 1);  }  return slen + dlen;}```: no `restrict`, condition from https://github.com/neovim/neovim/pull/6017/files#r98016797, no `MIN`, +1 assert and `const` everywhere.",X
112971,jamessan,https://api.github.com/repos/neovim/neovim/pulls/6017,98054885,2017-01-26T18:12:28Z,src/nvim/memory.c,"@@ -372,47 +372,49 @@ char *xstpncpy(char *restrict dst, const char *restrict src, size_t maxlen) /// /// @param dst    Buffer to store the result /// @param src    String to be copied-/// @param size   Size of `dst`+/// @param dsize  Size of `dst` /// @return       strlen(src). If retval >= dstsize, truncation occurs.-size_t xstrlcpy(char *restrict dst, const char *restrict src, size_t size)+size_t xstrlcpy(char *restrict dst, const char *restrict src, size_t dsize)   FUNC_ATTR_NONNULL_ALL {   size_t slen = strlen(src); -  if (size) {-    size_t len = MIN(slen, size - 1);+  if (dsize) {+    size_t len = MIN(slen, dsize - 1);     memcpy(dst, src, len);     dst[len] = '\0';   }    return slen;  // Does not include NUL. } -/// xstrlcat - Appends string src to the end of dst.+/// Appends `src` to string `dst` of size `dsize` (unlike strncat, dsize is the+/// full size of `dst`, not space left).  At most dsize-1 characters+/// will be copied.  Always NUL terminates. ///-/// Compatible with *BSD strlcat: Appends at most (dstsize - strlen(dst) - 1)-/// characters. dst will be NUL-terminated.+/// @see vim_strcat from Vim.+/// @see strlcat from OpenBSD. ///-/// Note: Replaces `vim_strcat`.-///-/// @param dst      Buffer to store the string-/// @param src      String to be copied-/// @param dstsize  Size of destination buffer, must be greater than 0-/// @return         strlen(src) + MIN(dstsize, strlen(initial dst)).-///                 If retval >= dstsize, truncation occurs.-size_t xstrlcat(char *restrict dst, const char *restrict src, size_t dstsize)+/// @param dst      String to be appended-to+/// @param src      String to put at the end of `dst`+/// @param dsize    Size of `dst`, must be greater than 0+/// @return         strlen(src) + MIN(dsize, strlen(initial dst)).+///                 If retval >= dsize, truncation occurs.+size_t xstrlcat(char *restrict dst, const char *restrict src, size_t dsize)   FUNC_ATTR_NONNULL_ALL {-  assert(dstsize > 0);-  size_t srclen = strlen(src);-  size_t dstlen = strlen(dst);-  size_t ret = srclen + dstlen;  // Total string length (excludes NUL)-  if (srclen) {-    size_t len = (ret >= dstsize) ? dstsize - 1 : ret;-    memcpy(dst + dstlen, src, len - dstlen);-    dst[len] = '\0';+  assert(dsize > 0);+  size_t dlen = strlen(dst);+  size_t slen = strlen(src);++  if (dlen + slen + 1 > dsize) {+    memmove(dst + dlen, src, dsize - dlen - 1);+    dst[dsize - 1] = '\0';+  } else {+    memmove(dst + dlen, src, slen + 1);   }","> Are we certain that restrict will catch all cases?`restrict` doesn't ""catch"" anything.  It doesn't make the compiler check if there is an overlap.  It's a hint to the compiler that it can perform optimizations based on the fact that the regions will _not_ overlap.The original `vim_strcat` was mixing `memmove` and `strcpy`, which have different semantics regarding overlap.The choice is either play it safe and assume Vim got lucky with any overlapping regions falling into the branch that used `memmove` (like ZyX is [suggesting]) or behave like the function we're emulating and require non-overlapping regions.[suggesting]: https://github.com/neovim/neovim/pull/6017#discussion_r98053147",X
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/4411,98370780,2017-01-30T01:25:46Z,runtime/doc/vim_diff.txt,"@@ -213,24 +213,28 @@ Additional differences:  - |shada-c| has no effect. - |shada-s| now limits size of every item and not just registers.-- When reading ShaDa files items are merged according to the timestamp.-  |shada-merging| - 'viminfo' option got renamed to 'shada'. Old option is kept as an alias for   compatibility reasons. - |:wviminfo| was renamed to |:wshada|, |:rviminfo| to |:rshada|.  Old   commands are still kept.-- When writing (|:wshada| without bang or at exit) it merges much more data,-  and does this according to the timestamp.  Vim merges only marks.-  |shada-merging| - ShaDa file format was designed with forward and backward compatibility in   mind. |shada-compatibility| - Some errors make ShaDa code keep temporary file in-place for user to decide   what to do with it.  Vim deletes temporary file in these cases.   |shada-error-handling|-- Vim keeps no timestamps at all, neither in viminfo file nor in the instance-  itself. - ShaDa file keeps search direction (|v:searchforward|), viminfo does not. +Lua interface (|if_lua.txt|):","With the current code I can resurrect `vim.buffer`, `vim.window`, `vim.command`, `vim.eval`, `vim.line`, `vim.open`: purely in lua. And create something which will look like what `vim.funcref` should look like (though I would rather implement this on top of references). But `vim.dict`, `vim.list` and `vim.type` are out or need to be implemented in C (basically copy implementation from Vim).Not sure about `vim.beep()`: there are many indirect/hacky ways to get a beep, but I do not know VimL or API function to get a beep directly. Though with my setup it may just as well be `function() end`, so I never bothered with learning something as useless as trying to emit a beep.",
10180857,nhooyr,https://api.github.com/repos/neovim/neovim/pulls/6033,98660236,2017-01-31T12:56:10Z,runtime/autoload/man.vim,"@@ -125,8 +125,8 @@ function! s:put_page(page) abort   setlocal noreadonly   silent keepjumps %delete _   silent put =a:page-  "" Remove all backspaced characters.-  execute 'silent keeppatterns keepjumps %substitute,.\b,,e'.(&gdefault?'':'g')+  "" Remove all backspaced/escape characters.+  execute 'silent keeppatterns keepjumps %substitute,.\b\|\e\[\d\+m,,e'.(&gdefault?'':'g')","I tested it again and it works fine. Also, in `:h /bar` it says `A pattern is one or more branches, separated by ""\|"".` so it shouldn't match `\b\[\d\+m`.",
112971,jamessan,https://api.github.com/repos/neovim/neovim/pulls/6033,98666677,2017-01-31T13:35:03Z,runtime/autoload/man.vim,"@@ -125,8 +125,8 @@ function! s:put_page(page) abort   setlocal noreadonly   silent keepjumps %delete _   silent put =a:page-  "" Remove all backspaced characters.-  execute 'silent keeppatterns keepjumps %substitute,.\b,,e'.(&gdefault?'':'g')+  "" Remove all backspaced/escape characters.+  execute 'silent keeppatterns keepjumps %substitute,.\b\|\e\[\d\+m,,e'.(&gdefault?'':'g')","Yeah, the current pattern will work fine.",
886074,teto,https://api.github.com/repos/neovim/neovim/pulls/6044,98993886,2017-02-01T21:02:15Z,src/nvim/tui/tui.c,"@@ -69,6 +70,9 @@ typedef struct {   bool can_use_terminal_scroll;   bool mouse_enabled;   bool busy;+  /* use int instead ? */+  // cursorentry_T cursor_shapes[SHAPE_IDX_COUNT]; /**!< is it fine to reuse cursorentry_T here ? */+  int cursor_shapes[SHAPE_IDX_COUNT]; /**!< is it fine to reuse cursorentry_T here ? */","At first in tui_cursor_style_set, I converted the data back to cursorentry_T as in nvim core, hence the `cursorentry_T cursor_shapes[SHAPE_IDX_COUNT]` but then I thought it might better to generate directly the control sequence characters ?",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/6038,99001501,2017-02-01T21:37:34Z,src/nvim/os/fs.c,"@@ -272,43 +293,55 @@ static bool is_executable(const char_u *name) static bool is_executable_in_path(const char_u *name, char_u **abspath)   FUNC_ATTR_NONNULL_ARG(1) {-  const char *path = os_getenv(""PATH"");-  if (path == NULL) {+  const char *path_env = os_getenv(""PATH"");+  if (path_env == NULL) {+    if (p_verbose >= 42) {+      smsg(""os_can_exe false 3"");+    }     return false;   } -  size_t buf_len = STRLEN(name) + STRLEN(path) + 2;+#ifdef WIN32+  // Prepend "".;"" to $PATH.+  size_t pathlen = strlen(path_env);+  char  *path    = memcpy(xmallocz(pathlen + 3), "".;"", 2);+  memcpy(path + 2, path_env, pathlen);+#else+  char *path = xstrdup(path_env);+#endif","For Windows, prepend `"".;""` to PATH, [as Vim does](https://github.com/vim/vim/blob/c4a249a736d40ec54794827ef95804c225d0e38f/src/os_win32.c#L1916                                              ).",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/6044,99025586,2017-02-01T23:49:57Z,src/nvim/cursor_shape.c,"@@ -36,11 +38,61 @@ static cursorentry_T shape_table[SHAPE_IDX_COUNT] =   {0, 0, 0, 100L, 100L, 100L, 0, 0, ""sm"", SHAPE_CURSOR}, }; -/*- * Parse the 'guicursor' option (""what"" is SHAPE_CURSOR) or 'mouseshape'- * (""what"" is SHAPE_MOUSE).- * Returns error message for an illegal option, NULL otherwise.- */++Dictionary cursor_shape_dict(void)+{+  /* Array args = ARRAY_DICT_INIT; */+  Dictionary all = ARRAY_DICT_INIT;+  char buf[30] = ""uninitialized"";++  /* shape_table */+  for (int i = 0; i < SHAPE_IDX_COUNT; i++) {++    ILOG(""Adding entry"");+    Dictionary dic = ARRAY_DICT_INIT;+    cursorentry_T *cur = &shape_table[i];+    /* I noticed msgp*/+    /* switch (cur->shape) { */+    /*   case SHAPE_BLOCK: STRCPY(buf, ""block""); */+    /*   case SHAPE_VER: STRCPY(buf, ""vertical""); */+    /*   case SHAPE_HOR: STRCPY(buf, ""horizontal""); */+    /*   default:; */+    /* }; */+    /* PUT(dic, ""shape"", STRING_OBJ(buf)); */","Yes. It's more a matter of not wanting to expose the internal order to the API, and then having to support those numbers forever more. It also is hopefully a better experience for API users.",
886074,teto,https://api.github.com/repos/neovim/neovim/pulls/6044,99028792,2017-02-02T00:16:23Z,src/nvim/ui.h,"@@ -22,6 +23,7 @@ struct ui_t {   void (*clear)(UI *ui);   void (*eol_clear)(UI *ui);   void (*cursor_goto)(UI *ui, int row, int col);+  void (*cursor_style_set)(UI *ui, Dictionary args); // or a Dictionary ?",I forgot to ask this one: I don't think Dictionary will be available to other UIs so what should I use ?(Dictionary defined in https://github.com/neovim/neovim/blob/9ef4be9aab6a9a16cf185ca17a2dabe87f8aa328/src/nvim/api/private/defs.h),
886074,teto,https://api.github.com/repos/neovim/neovim/pulls/6044,99029352,2017-02-02T00:21:13Z,src/nvim/tui/tui.c,"@@ -69,6 +70,9 @@ typedef struct {   bool can_use_terminal_scroll;   bool mouse_enabled;   bool busy;+  /* use int instead ? */+  // cursorentry_T cursor_shapes[SHAPE_IDX_COUNT]; /**!< is it fine to reuse cursorentry_T here ? */+  int cursor_shapes[SHAPE_IDX_COUNT]; /**!< is it fine to reuse cursorentry_T here ? */","As I see it, there are some members in cursorentry_T that don't make sense for the TUI (mshape/blinkoff ?). So I thought I could save a few bytes by generating directly in tui.c, upon cursor_shapes receptions the control sequence, register them with unibilium `unibi_add_str_ext`, keep the returned integer and discard the useless stuff. But if you intend to support blinkon/blinkoff in the TUI with timers, it makes sense to regenerate the full cursorentry_T.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/6044,99029806,2017-02-02T00:25:10Z,src/nvim/ui.h,"@@ -22,6 +23,7 @@ struct ui_t {   void (*clear)(UI *ui);   void (*eol_clear)(UI *ui);   void (*cursor_goto)(UI *ui, int row, int col);+  void (*cursor_style_set)(UI *ui, Dictionary args); // or a Dictionary ?","These parameters aren't directly mapped to RPC, there's some intermediate step. Notice how highlight_set has an HlAttrs parameter. So just use whatever is convenient internally.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/6044,99030598,2017-02-02T00:31:45Z,src/nvim/tui/tui.c,"@@ -69,6 +70,9 @@ typedef struct {   bool can_use_terminal_scroll;   bool mouse_enabled;   bool busy;+  /* use int instead ? */+  // cursorentry_T cursor_shapes[SHAPE_IDX_COUNT]; /**!< is it fine to reuse cursorentry_T here ? */+  int cursor_shapes[SHAPE_IDX_COUNT]; /**!< is it fine to reuse cursorentry_T here ? */","Oh. No, please don't do that. The TUI follows the same protocol as _all_ UIs. It cannot and must not receive different data than some other UI. Don't worry about saving bytes, especially because this is a rare event.The fewer special cases, the better. Consistency and clarity are the main goal. ",X
886074,teto,https://api.github.com/repos/neovim/neovim/pulls/6044,99033565,2017-02-02T00:56:36Z,src/nvim/tui/tui.c,"@@ -69,6 +70,9 @@ typedef struct {   bool can_use_terminal_scroll;   bool mouse_enabled;   bool busy;+  /* use int instead ? */+  // cursorentry_T cursor_shapes[SHAPE_IDX_COUNT]; /**!< is it fine to reuse cursorentry_T here ? */+  int cursor_shapes[SHAPE_IDX_COUNT]; /**!< is it fine to reuse cursorentry_T here ? */","Of course, the conversion happened once the TUI received all data. Looks like it complexifies things instead of making them simpler so forget about it xD",X
886074,teto,https://api.github.com/repos/neovim/neovim/pulls/6044,99033901,2017-02-02T00:59:25Z,src/nvim/ui.h,"@@ -22,6 +23,7 @@ struct ui_t {   void (*clear)(UI *ui);   void (*eol_clear)(UI *ui);   void (*cursor_goto)(UI *ui, int row, int col);+  void (*cursor_style_set)(UI *ui, Dictionary args); // or a Dictionary ?","I understood that correctly but your sugggestion in https://github.com/neovim/neovim/issues/2583#issuecomment-272988384 made me wonder.I can only think of pushing each cursorentry via several calls of : ```void (*cursor_style_set)(UI *ui,   int shape;                    /* one of the SHAPE_ defines */  int mshape,                   /* one of the MSHAPE defines */  int percentage,               /* percentage of cell for bar */  long blinkwait,               /* blinking, wait time before blinking starts */  long blinkon,                 /* blinking, on time */  long blinkoff,                /* blinking, off time */  int id,                       /* highlight group ID */  int id_lm,                    /* highlight group ID for :lmap mode */  char        *name,            /* mode name (fixed) */char used_for, /* SHAPE_MOUSE and/or SHAPE_CURSOR */)```",X
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/6044,99114068,2017-02-02T13:00:11Z,src/nvim/ui.h,"@@ -22,6 +23,7 @@ struct ui_t {   void (*clear)(UI *ui);   void (*eol_clear)(UI *ui);   void (*cursor_goto)(UI *ui, int row, int col);+  void (*cursor_style_set)(UI *ui, Dictionary args); // or a Dictionary ?","nvim-qt never sees any of this, it communicates via msgpack-RPC types. That's where the `api/ui.c` ""intermediate step"" comes into play.Only in-process UIs would be affected by the choice of type here. Currently VimR is the only example of that. The `private/` namespace is for the theoretical future where we have a ""pubic ABI"": `api/*` excluding `api/private/*`. But in the particular case of `api/private/defs.h`, it's included by `api/buffer.h` and friends:     #include ""nvim/api/private/defs.h""So Dictionary, Buffer, and the other API C types are (intentionally) exposed in the public ABI. The purpose of the `private/` namespace is to hide the implementation, not the types.",X
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/6044,99251849,2017-02-03T00:08:41Z,src/nvim/tui/tui.c,"@@ -434,6 +433,83 @@ static void tui_cursor_goto(UI *ui, int row, int col)   unibi_goto(ui, row, col); } +static cursorentry_T decode_cursor_entry(Dictionary args)+{+  cursorentry_T r;++  for (size_t i = 0; i < args.size; i++) {+    char *keyStr = args.items[i].key.data;+    Object value = args.items[i].value;++    if (strcmp(keyStr, ""cursor_shape"") == 0) {+      const char *shapeStr = args.items[i].value.data.string.data;+      if (strcmp(shapeStr, ""block"") == 0) {+        r.shape = SHAPE_BLOCK;+      } else if (strcmp(shapeStr, ""vertical"") == 0) {+        r.shape = SHAPE_VER;+      } else if (strcmp(shapeStr, ""horizontal"") == 0) {+        r.shape = SHAPE_HOR;+      } else {+        WLOG(""Unknown value %s"", shapeStr);+      }+    } else if (strcmp(keyStr, ""blinkon"") == 0) {+      r.blinkon = value.data.integer;+    } else if (strcmp(keyStr, ""blinkoff"") == 0) {+      r.blinkoff = value.data.integer;+    } else if (!strcmp(keyStr, ""hl_id"")) {+      r.id = (int)value.data.integer;+    }+  }+  return r;+}++static void tui_cursor_style_set(UI *ui, Dictionary args)+{+  TUIData *data = ui->data;+  static char *modes[] = {+    ""normal"",","Is this list TUI-specific, or should it live in cursor_shape.c?",X
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/6044,99267323,2017-02-03T02:32:16Z,src/nvim/cursor_shape.c,"@@ -7,40 +7,108 @@ #include ""nvim/charset.h"" #include ""nvim/strings.h"" #include ""nvim/syntax.h""+#include ""nvim/api/private/helpers.h""+#include ""nvim/ui.h"" -/*- * Handling of cursor and mouse pointer shapes in various modes.- */-+/// Handling of cursor and mouse pointer shapes in various modes. static cursorentry_T shape_table[SHAPE_IDX_COUNT] = {-  /* The values will be filled in from the 'guicursor' and 'mouseshape'-   * defaults when Vim starts.-   * Adjust the SHAPE_IDX_ defines when making changes! */-  {0, 0, 0, 700L, 400L, 250L, 0, 0, ""n"", SHAPE_CURSOR+SHAPE_MOUSE},-  {0, 0, 0, 700L, 400L, 250L, 0, 0, ""v"", SHAPE_CURSOR+SHAPE_MOUSE},-  {0, 0, 0, 700L, 400L, 250L, 0, 0, ""i"", SHAPE_CURSOR+SHAPE_MOUSE},-  {0, 0, 0, 700L, 400L, 250L, 0, 0, ""r"", SHAPE_CURSOR+SHAPE_MOUSE},-  {0, 0, 0, 700L, 400L, 250L, 0, 0, ""c"", SHAPE_CURSOR+SHAPE_MOUSE},-  {0, 0, 0, 700L, 400L, 250L, 0, 0, ""ci"", SHAPE_CURSOR+SHAPE_MOUSE},-  {0, 0, 0, 700L, 400L, 250L, 0, 0, ""cr"", SHAPE_CURSOR+SHAPE_MOUSE},-  {0, 0, 0, 700L, 400L, 250L, 0, 0, ""o"", SHAPE_CURSOR+SHAPE_MOUSE},-  {0, 0, 0, 700L, 400L, 250L, 0, 0, ""ve"", SHAPE_CURSOR+SHAPE_MOUSE},-  {0, 0, 0,   0L,   0L,   0L, 0, 0, ""e"", SHAPE_MOUSE},-  {0, 0, 0,   0L,   0L,   0L, 0, 0, ""s"", SHAPE_MOUSE},-  {0, 0, 0,   0L,   0L,   0L, 0, 0, ""sd"", SHAPE_MOUSE},-  {0, 0, 0,   0L,   0L,   0L, 0, 0, ""vs"", SHAPE_MOUSE},-  {0, 0, 0,   0L,   0L,   0L, 0, 0, ""vd"", SHAPE_MOUSE},-  {0, 0, 0,   0L,   0L,   0L, 0, 0, ""m"", SHAPE_MOUSE},-  {0, 0, 0,   0L,   0L,   0L, 0, 0, ""ml"", SHAPE_MOUSE},-  {0, 0, 0, 100L, 100L, 100L, 0, 0, ""sm"", SHAPE_CURSOR},","I didn't realize that the short strings ""n"", ""v"", etc. could be used to identify these entries. ~~Probably~~ Maybe those should be used (over RPC) instead of creating the long-form names? Or maybe the long-form helps usability.",X
1441126,waynr,https://api.github.com/repos/neovim/neovim/pulls/6078,100087225,2017-02-08T15:14:31Z,CMakeLists.txt,"@@ -387,29 +387,26 @@ endforeach()  # Find Lua interpreter include(LuaHelpers)-set(LUA_DEPENDENCIES lpeg mpack bit) if(NOT LUA_PRG)   foreach(CURRENT_LUA_PRG luajit lua5.1 lua5.2 lua)     # If LUA_PRG is set find_program() will not search     unset(LUA_PRG CACHE)-    unset(LUA_PRG_WORKS)     find_program(LUA_PRG ${CURRENT_LUA_PRG})      if(LUA_PRG)-      check_lua_deps(${LUA_PRG} ""${LUA_DEPENDENCIES}"" LUA_PRG_WORKS)","Did it work that way before? Directly below this line there was a check for `LUA_PRG_WORKS` that appears to break out of the `foreach` loop. It does this on the first pass of the loop for which both of the following conditions are true:* a suitable lua interpreter has been found* that suitable lua interpreter has the required modules installedI'm willing to fix that bug also, but it will have to wait until tonight (GMT-8)",X
1441126,waynr,https://api.github.com/repos/neovim/neovim/pulls/6078,100227924,2017-02-09T04:14:54Z,CMakeLists.txt,"@@ -387,29 +387,26 @@ endforeach()  # Find Lua interpreter include(LuaHelpers)-set(LUA_DEPENDENCIES lpeg mpack bit) if(NOT LUA_PRG)   foreach(CURRENT_LUA_PRG luajit lua5.1 lua5.2 lua)     # If LUA_PRG is set find_program() will not search     unset(LUA_PRG CACHE)-    unset(LUA_PRG_WORKS)     find_program(LUA_PRG ${CURRENT_LUA_PRG})      if(LUA_PRG)-      check_lua_deps(${LUA_PRG} ""${LUA_DEPENDENCIES}"" LUA_PRG_WORKS)","Something just occurred to me when I came back to this...being relatively unfamiliar with lua, I'm curious how often it is that lua packages end up being version-dependent? I ask because at least for the platform I am using at the moment, debian 9, the available lua packages seem to be independent of lua version.",
715238,equalsraf,https://api.github.com/repos/neovim/neovim/pulls/5957,100500423,2017-02-10T09:43:18Z,src/nvim/CMakeLists.txt,"@@ -306,6 +306,39 @@ if(WIN32)   install(DIRECTORY ${PROJECT_BINARY_DIR}/windows_runtime_deps/     DESTINATION ${CMAKE_INSTALL_BINDIR}) +  find_program(SWISS_PRG swiss.exe)",maybe its easier to do this copying of swiss.exe into *.exe in the third-party GetBindep install step bellow.,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/5957,100705384,2017-02-12T21:42:12Z,third-party/CMakeLists.txt,"@@ -173,6 +176,10 @@ endif() include(GetBinaryDeps)  if(WIN32)+  # curl.exe, ca-bundle.crt, tidy.exe, swiss.exe+  GetBinaryDep(TARGET wintools+    INSTALL_COMMAND ${CMAKE_COMMAND} -E copy_directory . ${DEPS_INSTALL_DIR}/bin)+","@equalsraf Thanks for the help, it's extremely appreciated. That is the direction I wanted to go, I ran into some build error and this was a temporary hack. Extracted to https://github.com/neovim/neovim/pull/6105",
12672140,enishina,https://api.github.com/repos/neovim/neovim/pulls/6099,100790185,2017-02-13T13:15:23Z,src/nvim/eval/typval_encode.h,"@@ -14,54 +14,7 @@ #include ""nvim/eval_defs.h"" #include ""nvim/func_attr.h"" -/// Type of the stack entry-typedef enum {-  kMPConvDict,  ///< Convert dict_T *dictionary.-  kMPConvList,  ///< Convert list_T *list.-  kMPConvPairs,  ///< Convert mapping represented as a list_T* of pairs.-  kMPConvPartial,  ///< Convert partial_T* partial.-  kMPConvPartialList,  ///< Convert argc/argv pair coming from a partial.-} MPConvStackValType;--/// Stage at which partial is being converted-typedef enum {-  kMPConvPartialArgs,  ///< About to convert arguments.-  kMPConvPartialSelf,  ///< About to convert self dictionary.-  kMPConvPartialEnd,  ///< Already converted everything.-} MPConvPartialStage;--/// Structure representing current VimL to messagepack conversion state-typedef struct {-  MPConvStackValType type;  ///< Type of the stack entry.-  typval_T *tv;  ///< Currently converted typval_T.-  int saved_copyID;  ///< copyID item used to have.-  union {-    struct {-      dict_T *dict;    ///< Currently converted dictionary.-      dict_T **dictp;  ///< Location where that dictionary is stored.-                       ///< Normally it is &.tv->vval.v_dict, but not when-                       ///< converting partials.-      hashitem_T *hi;  ///< Currently converted dictionary item.-      size_t todo;     ///< Amount of items left to process.-    } d;  ///< State of dictionary conversion.-    struct {-      list_T *list;    ///< Currently converted list.-      listitem_T *li;  ///< Currently converted list item.-    } l;  ///< State of list or generic mapping conversion.-    struct {-      MPConvPartialStage stage;  ///< Stage at which partial is being converted.-      partial_T *pt;  ///< Currently converted partial.-    } p;  ///< State of partial conversion.-    struct {-      typval_T *arg;    ///< Currently converted argument.-      typval_T *argv;    ///< Start of the argument list.-      size_t todo;  ///< Number of items left to process.-    } a;  ///< State of list or generic mapping conversion.-  } data;  ///< Data to convert.-} MPConvStackVal;--/// Stack used to convert VimL values to messagepack.-typedef kvec_withinit_t(MPConvStackVal, 8) MPConvStack;+#include ""nvim/eval/typval_encode_types.h""","eval.c includes directly typval_encode.h, and it only requires MPConvStackVal etc types.So I thought type definitions of MPConvStack* should be separated from typval_encode.h as typval_encode_types.h (should be typval_encode_defs.h), and eval.c should include it directly.I think this is the way you commented we should go.> Most likely before this headers will need to be seriously refactored: I suggested an idea somewhere that all types need to be moved to a separate headers ���_types.h or ���_defs.h (but it should be generally avoided to put non-types there) which may be arranged in dependency graph without cycles and other headers should include only them",X
12672140,enishina,https://api.github.com/repos/neovim/neovim/pulls/6099,100791999,2017-02-13T13:26:11Z,src/nvim/eval/typval_encode.c.h,"@@ -315,309 +324,318 @@ static int _TYPVAL_ENCODE_CONVERT_ONE_VALUE( /// @param[in]  objname  Object name, used for error reporting. /// /// @return OK in case of success, FAIL in case of failure.-static int _TYPVAL_ENCODE_CONVERT_ONE_VALUE(-    TYPVAL_ENCODE_FIRST_ARG_TYPE TYPVAL_ENCODE_FIRST_ARG_NAME,-    MPConvStack *const mpstack, MPConvStackVal *const cur_mpsv,-    typval_T *const tv, const int copyID,-    const char *const objname)-{-  switch (tv->v_type) {-    case VAR_STRING: {-      TYPVAL_ENCODE_CONV_STRING(tv, tv->vval.v_string, tv_strlen(tv));-      break;-    }-    case VAR_NUMBER: {-      TYPVAL_ENCODE_CONV_NUMBER(tv, tv->vval.v_number);-      break;-    }-    case VAR_FLOAT: {-      TYPVAL_ENCODE_CONV_FLOAT(tv, tv->vval.v_float);-      break;-    }-    case VAR_FUNC: {-      TYPVAL_ENCODE_CONV_FUNC_START(tv, tv->vval.v_string);-      TYPVAL_ENCODE_CONV_FUNC_BEFORE_ARGS(tv, 0);-      TYPVAL_ENCODE_CONV_FUNC_BEFORE_SELF(tv, -1);-      TYPVAL_ENCODE_CONV_FUNC_END(tv);-      break;-    }-    case VAR_PARTIAL: {-      partial_T *const pt = tv->vval.v_partial;-      (void)pt;-      TYPVAL_ENCODE_CONV_FUNC_START(tv, (pt == NULL ? NULL : pt->pt_name));-      _mp_push(*mpstack, ((MPConvStackVal) {-        .type = kMPConvPartial,-        .tv = tv,-        .saved_copyID = copyID - 1,-        .data = {-          .p = {-            .stage = kMPConvPartialArgs,-            .pt = tv->vval.v_partial,-          },-        },-      }));-      break;-    }-    case VAR_LIST: {-      if (tv->vval.v_list == NULL || tv->vval.v_list->lv_len == 0) {-        TYPVAL_ENCODE_CONV_EMPTY_LIST(tv);-        break;-      }-      const int saved_copyID = tv->vval.v_list->lv_copyID;-      _TYPVAL_ENCODE_DO_CHECK_SELF_REFERENCE(tv->vval.v_list, lv_copyID, copyID,-                                             kMPConvList);-      TYPVAL_ENCODE_CONV_LIST_START(tv, tv->vval.v_list->lv_len);-      assert(saved_copyID != copyID && saved_copyID != copyID - 1);-      _mp_push(*mpstack, ((MPConvStackVal) {-        .type = kMPConvList,-        .tv = tv,-        .saved_copyID = saved_copyID,-        .data = {-          .l = {-            .list = tv->vval.v_list,-            .li = tv->vval.v_list->lv_first,-          },-        },-      }));-      TYPVAL_ENCODE_CONV_REAL_LIST_AFTER_START(tv, _mp_last(*mpstack));-      break;-    }-    case VAR_SPECIAL: {-      switch (tv->vval.v_special) {-        case kSpecialVarNull: {-          TYPVAL_ENCODE_CONV_NIL(tv);-          break;-        }-        case kSpecialVarTrue:-        case kSpecialVarFalse: {-          TYPVAL_ENCODE_CONV_BOOL(tv, tv->vval.v_special == kSpecialVarTrue);-          break;-        }-      }-      break;-    }-    case VAR_DICT: {-      if (tv->vval.v_dict == NULL-          || tv->vval.v_dict->dv_hashtab.ht_used == 0) {-        TYPVAL_ENCODE_CONV_EMPTY_DICT(tv, tv->vval.v_dict);-        break;-      }-      const dictitem_T *type_di;-      const dictitem_T *val_di;-      if (TYPVAL_ENCODE_ALLOW_SPECIALS-          && tv->vval.v_dict->dv_hashtab.ht_used == 2-          && (type_di = dict_find((dict_T *)tv->vval.v_dict,-                                  (char_u *)""_TYPE"", -1)) != NULL-          && type_di->di_tv.v_type == VAR_LIST-          && (val_di = dict_find((dict_T *)tv->vval.v_dict,-                                 (char_u *)""_VAL"", -1)) != NULL) {-        size_t i;-        for (i = 0; i < ARRAY_SIZE(eval_msgpack_type_lists); i++) {-          if (type_di->di_tv.vval.v_list == eval_msgpack_type_lists[i]) {-            break;-          }-        }-        if (i == ARRAY_SIZE(eval_msgpack_type_lists)) {-          goto _convert_one_value_regular_dict;-        }-        switch ((MessagePackType)i) {-          case kMPNil: {-            TYPVAL_ENCODE_CONV_NIL(tv);-            break;-          }-          case kMPBoolean: {-            if (val_di->di_tv.v_type != VAR_NUMBER) {-              goto _convert_one_value_regular_dict;-            }-            TYPVAL_ENCODE_CONV_BOOL(tv, val_di->di_tv.vval.v_number);-            break;-          }-          case kMPInteger: {-            const list_T *val_list;-            varnumber_T sign;-            varnumber_T highest_bits;-            varnumber_T high_bits;-            varnumber_T low_bits;-            // List of 4 integers; first is signed (should be 1 or -1, but-            // this is not checked), second is unsigned and have at most-            // one (sign is -1) or two (sign is 1) non-zero bits (number of-            // bits is not checked), other unsigned and have at most 31-            // non-zero bits (number of bits is not checked).-            if (val_di->di_tv.v_type != VAR_LIST-                || (val_list = val_di->di_tv.vval.v_list) == NULL-                || val_list->lv_len != 4-                || val_list->lv_first->li_tv.v_type != VAR_NUMBER-                || (sign = val_list->lv_first->li_tv.vval.v_number) == 0-                || val_list->lv_first->li_next->li_tv.v_type != VAR_NUMBER-                || (highest_bits =-                    val_list->lv_first->li_next->li_tv.vval.v_number) < 0-                || val_list->lv_last->li_prev->li_tv.v_type != VAR_NUMBER-                || (high_bits =-                    val_list->lv_last->li_prev->li_tv.vval.v_number) < 0-                || val_list->lv_last->li_tv.v_type != VAR_NUMBER-                || (low_bits = val_list->lv_last->li_tv.vval.v_number) < 0) {-              goto _convert_one_value_regular_dict;-            }-            uint64_t number = ((uint64_t)(((uint64_t)highest_bits) << 62)-                               | (uint64_t)(((uint64_t)high_bits) << 31)-                               | (uint64_t)low_bits);-            if (sign > 0) {-              TYPVAL_ENCODE_CONV_UNSIGNED_NUMBER(tv, number);-            } else {-              TYPVAL_ENCODE_CONV_NUMBER(tv, -number);-            }-            break;-          }-          case kMPFloat: {-            if (val_di->di_tv.v_type != VAR_FLOAT) {-              goto _convert_one_value_regular_dict;-            }-            TYPVAL_ENCODE_CONV_FLOAT(tv, val_di->di_tv.vval.v_float);-            break;-          }-          case kMPString:-          case kMPBinary: {-            const bool is_string = ((MessagePackType)i == kMPString);-            if (val_di->di_tv.v_type != VAR_LIST) {-              goto _convert_one_value_regular_dict;-            }-            size_t len;-            char *buf;-            if (!encode_vim_list_to_buf(val_di->di_tv.vval.v_list, &len,-                                        &buf)) {-              goto _convert_one_value_regular_dict;-            }-            if (is_string) {-              TYPVAL_ENCODE_CONV_STR_STRING(tv, buf, len);-            } else {-              TYPVAL_ENCODE_CONV_STRING(tv, buf, len);-            }-            xfree(buf);-            break;-          }-          case kMPArray: {-            if (val_di->di_tv.v_type != VAR_LIST) {-              goto _convert_one_value_regular_dict;-            }-            const int saved_copyID = val_di->di_tv.vval.v_list->lv_copyID;-            _TYPVAL_ENCODE_DO_CHECK_SELF_REFERENCE(val_di->di_tv.vval.v_list,-                                                   lv_copyID, copyID,-                                                   kMPConvList);-            TYPVAL_ENCODE_CONV_LIST_START(tv,-                                          val_di->di_tv.vval.v_list->lv_len);-            assert(saved_copyID != copyID && saved_copyID != copyID - 1);-            _mp_push(*mpstack, ((MPConvStackVal) {-              .tv = tv,-              .type = kMPConvList,-              .saved_copyID = saved_copyID,-              .data = {-                .l = {-                  .list = val_di->di_tv.vval.v_list,-                  .li = val_di->di_tv.vval.v_list->lv_first,-                },-              },-            }));-            break;-          }-          case kMPMap: {-            if (val_di->di_tv.v_type != VAR_LIST) {-              goto _convert_one_value_regular_dict;-            }-            list_T *const val_list = val_di->di_tv.vval.v_list;-            if (val_list == NULL || val_list->lv_len == 0) {-              TYPVAL_ENCODE_CONV_EMPTY_DICT(tv, TYPVAL_ENCODE_NODICT_VAR);-              break;-            }-            for (const listitem_T *li = val_list->lv_first; li != NULL;-                 li = li->li_next) {-              if (li->li_tv.v_type != VAR_LIST-                  || li->li_tv.vval.v_list->lv_len != 2) {-                goto _convert_one_value_regular_dict;-              }-            }-            const int saved_copyID = val_di->di_tv.vval.v_list->lv_copyID;-            _TYPVAL_ENCODE_DO_CHECK_SELF_REFERENCE(val_list, lv_copyID, copyID,-                                                   kMPConvPairs);-            TYPVAL_ENCODE_CONV_DICT_START(tv, TYPVAL_ENCODE_NODICT_VAR,-                                          val_list->lv_len);-            assert(saved_copyID != copyID && saved_copyID != copyID - 1);-            _mp_push(*mpstack, ((MPConvStackVal) {-              .tv = tv,-              .type = kMPConvPairs,-              .saved_copyID = saved_copyID,-              .data = {-                .l = {-                  .list = val_list,-                  .li = val_list->lv_first,-                },-              },-            }));-            break;-          }-          case kMPExt: {-            const list_T *val_list;-            varnumber_T type;-            if (val_di->di_tv.v_type != VAR_LIST-                || (val_list = val_di->di_tv.vval.v_list) == NULL-                || val_list->lv_len != 2-                || (val_list->lv_first->li_tv.v_type != VAR_NUMBER)-                || (type = val_list->lv_first->li_tv.vval.v_number) > INT8_MAX-                || type < INT8_MIN-                || (val_list->lv_last->li_tv.v_type != VAR_LIST)) {-              goto _convert_one_value_regular_dict;-            }-            size_t len;-            char *buf;-            if (!encode_vim_list_to_buf(val_list->lv_last->li_tv.vval.v_list,-                                        &len, &buf)) {-              goto _convert_one_value_regular_dict;-            }-            TYPVAL_ENCODE_CONV_EXT_STRING(tv, buf, len, type);-            xfree(buf);-            break;-          }-        }-        break;-      }-_convert_one_value_regular_dict: {}-      const int saved_copyID = tv->vval.v_dict->dv_copyID;-      _TYPVAL_ENCODE_DO_CHECK_SELF_REFERENCE(tv->vval.v_dict, dv_copyID, copyID,-                                             kMPConvDict);-      TYPVAL_ENCODE_CONV_DICT_START(tv, tv->vval.v_dict,-                                    tv->vval.v_dict->dv_hashtab.ht_used);-      assert(saved_copyID != copyID && saved_copyID != copyID - 1);-      _mp_push(*mpstack, ((MPConvStackVal) {-        .tv = tv,-        .type = kMPConvDict,-        .saved_copyID = saved_copyID,-        .data = {-          .d = {-            .dict = tv->vval.v_dict,-            .dictp = &tv->vval.v_dict,-            .hi = tv->vval.v_dict->dv_hashtab.ht_array,-            .todo = tv->vval.v_dict->dv_hashtab.ht_used,-          },-        },-      }));-      TYPVAL_ENCODE_CONV_REAL_DICT_AFTER_START(tv, tv->vval.v_dict,-                                               _mp_last(*mpstack));-      break;-    }-    case VAR_UNKNOWN: {-      EMSG2(_(e_intern2), STR(_TYPVAL_ENCODE_CONVERT_ONE_VALUE) ""()"");-      return FAIL;-    }-  }-typval_encode_stop_converting_one_item:-  return OK;-  // Prevent ���unused label��� warnings.-  goto typval_encode_stop_converting_one_item;-}--TYPVAL_ENCODE_SCOPE int _TYPVAL_ENCODE_ENCODE(-    TYPVAL_ENCODE_FIRST_ARG_TYPE TYPVAL_ENCODE_FIRST_ARG_NAME,-    typval_T *const tv, const char *const objname)-  REAL_FATTR_NONNULL_ARG(2, 3) REAL_FATTR_WARN_UNUSED_RESULT;+#define DEFINE_TYPVAL_ENCODE_CONVERT_ONE_VALUE( \","I understand you cannot accept this.The intention of this change was to remove the cyclic dependency.The sources which include typval_encode.c.h are expected to define TYPVAL_ENCODE_FIRST_ARG_NAME, TYPVAL_ENCODE_FIRST_ARG_TYPE, TYPVAL_ENCODE_SCOPE, TYPVAL_ENCODE_ENCODE, and typval_encode.c.h referers them. This is a kind of cyclic dependency. If you let check_single_includes test run on it, this code cannot pass the test.Should we exclude this file from check_single_includes test targets?",X
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/6112,101074033,2017-02-14T16:13:48Z,src/nvim/api/buffer.c,"@@ -411,10 +411,13 @@ void nvim_buf_set_lines(uint64_t channel_id,  /// Gets a buffer-scoped (b:) variable. ///-/// @param buffer     Buffer handle-/// @param name       Variable name-/// @param[out] err   Error details, if any-/// @return Variable value+/// @note Use buffer_get_changedtick() for ���variable��� `b:changedtick`.+///       This method only gets variables from b: dictionary.","No, I think that `b:changedtick` should be deprecated. This is a *unique* variable with some hacks around it, normally such internals are exposed via functions (e.g. window identifiers are exposed via `win_getid()`, not via `w:` variable). If or when #243 proceeds most of VimL functions like this will be separate API calls.",X
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/6112,101079563,2017-02-14T16:34:15Z,src/nvim/api/buffer.c,"@@ -411,10 +411,13 @@ void nvim_buf_set_lines(uint64_t channel_id,  /// Gets a buffer-scoped (b:) variable. ///-/// @param buffer     Buffer handle-/// @param name       Variable name-/// @param[out] err   Error details, if any-/// @return Variable value+/// @note Use buffer_get_changedtick() for ���variable��� `b:changedtick`.+///       This method only gets variables from b: dictionary.","This is one of the forward compatibility matters: we don���t allow functions starting from lowercase letter, commands starting with lowercase letter or non-letter, etc because if we do we will face the situation when adding new function or command will break user plugins. For the same reason various variables should not be special. It is OK to create new namespaced variables like `b:nvim[_.]changedtick`: one rule like ���do not create new `.:nvim.*` variables��� is easy to remember and comprehend.`b:changedtick` as an existing interface is, of course, not the case, but making it work may be tricky. If you know how to set up things so that `copy(b:)['changedtick']` will get `b:changedtick` (*note*: `copy(b:)['changedtick']`, not yet another hack to make `nvim_buf_get_var` work as expected by special-casing `changedtick`: ideal solution should make it possible to retire all currently used changedtick-related hacks) it would be good. Otherwise it is better to deprecate `b:changedtick` and create a VimL function with an API counterpart.",X
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/6111,101087552,2017-02-14T17:04:41Z,src/nvim/eval.c,"@@ -18151,19 +18176,25 @@ static void f_writefile(typval_T *argvars, typval_T *rettv, FunPtr fptr)     }   } -  // Always open the file in binary mode, library functions have a mind of-  // their own about CR-LF conversion.-  char_u *fname = get_tv_string(&argvars[1]);-  FILE *fd;-  if (*fname == NUL || (fd = mch_fopen((char *)fname,-       append ? APPENDBIN : WRITEBIN)) == NULL) {-    EMSG2(_(e_notcreate), *fname == NUL ? (char_u *)_(""<empty>"") : fname);-    rettv->vval.v_number = -1;+  const char *const fname = (const char *)get_tv_string(&argvars[1]);+  FileDescriptor *fp;+  int error;+  rettv->vval.v_number = -1;+  if (*fname == NUL) {+    EMSG(_(""E482: Can't open file with an empty name""));+  } else if ((fp = file_open_new(&error, fname,+                                 ((append ? kFileAppend : kFileTruncate)+                                  | kFileCreate), 0666)) == NULL) {+    emsgf(_(""E482: Can't open file %s for writing: %s""),+          fname, os_strerror(error));   } else {-    if (write_list(fd, argvars[0].vval.v_list, binary) == false) {-      rettv->vval.v_number = -1;+    if (write_list(fp, argvars[0].vval.v_list, binary)) {+      rettv->vval.v_number = 0;+    }+    if ((error = file_free(fp)) != 0) {+      emsgf(_(""E80: Error when closing file %s: %s""),+            fname, os_strerror(error));","The use of `fname` here looks like UB, because `get_tv_string()` uses a static buffer for Number variables.`fname` is defined as a `const char *`, but the buffer content could be changed by the previous call to  `write_list()` if the list contains a Number variable. ",X
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/6112,101169571,2017-02-14T23:23:08Z,src/nvim/api/buffer.c,"@@ -411,10 +411,10 @@ void nvim_buf_set_lines(uint64_t channel_id,  /// Gets a buffer-scoped (b:) variable. ///-/// @param buffer     Buffer handle-/// @param name       Variable name-/// @param[out] err   Error details, if any-/// @return Variable value+/// @param buffer The buffer handle+/// @param name The variable name+/// @param[out] err Details of an error that may have occurred+/// @return The variable value","I intentionally removed ""The"" from all of the API parameter documentation. Except in cases where it avoids ambiguity, it's noise.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/6105,101545117,2017-02-16T15:29:18Z,src/nvim/CMakeLists.txt,"@@ -326,6 +307,34 @@ if(WIN32)       -DDST=${PROJECT_BINARY_DIR}/windows_runtime_deps       -P ${PROJECT_SOURCE_DIR}/cmake/WindowsDllCopy.cmake)   add_dependencies(nvim_runtime_deps nvim_dll_deps)++  add_custom_target(external_blobs+    COMMAND ${CMAKE_COMMAND} -E make_directory ${PROJECT_BINARY_DIR}/windows_runtime_deps/platforms++    COMMAND ${CMAKE_COMMAND} -E copy ""${DEPS_PREFIX}/bin/ca-bundle.crt""       ${PROJECT_BINARY_DIR}/windows_runtime_deps/","@equalsraf Here's what I'm doing instead of the `find_program()` + `WindowsDllCopy.cmake` approach (notice the deleted lines just above). It's a bit inelegant: because `find_program()` is not used, this is referencing `${DEPS_PREFIX}/bin/` which means this target has implicit knowledge about the `third-party/CMakeLists.txt` project.But I don't know a better way. `WindowsDllCopy.cmake` was running `dumpbin` on the `.exe` files, which seems  useless (and wrong) since they have nothing to do with the Neovim build, we only want these `.exe` files for inclusion with the end-user package.",X
715238,equalsraf,https://api.github.com/repos/neovim/neovim/pulls/6105,101556494,2017-02-16T16:08:30Z,src/nvim/CMakeLists.txt,"@@ -326,6 +307,34 @@ if(WIN32)       -DDST=${PROJECT_BINARY_DIR}/windows_runtime_deps       -P ${PROJECT_SOURCE_DIR}/cmake/WindowsDllCopy.cmake)   add_dependencies(nvim_runtime_deps nvim_dll_deps)++  add_custom_target(external_blobs+    COMMAND ${CMAKE_COMMAND} -E make_directory ${PROJECT_BINARY_DIR}/windows_runtime_deps/platforms++    COMMAND ${CMAKE_COMMAND} -E copy ""${DEPS_PREFIX}/bin/ca-bundle.crt""       ${PROJECT_BINARY_DIR}/windows_runtime_deps/","> WindowsDllCopy.cmake was running dumpbin on the .exe files, which seems useless (and wrongThe dumpbin step is used to determine the DLLs that need to be shipped with each .exe i.e. part of the list you added below by hand. The advantage was that this would work with any binary in path.swiss.exe seems to be self contained (does it have any DLL dependencies?). win32yank does need a couple DLLs.Concerning nvim-qt, if it is never used during the tests or build, then there is no need to put it in DEPS_INSTALL and mix it with the other files there, only to separate it later with a long list of copy commands. This is different from diff or win32yank that should be available for test runs. In fact you could run that GetBinaryDep install recipe right into the nvim target install dir (problem with that is third-party does not know the install path).  Since technically this is not a build dependency, maybe the recipe could just be in the main cmake project as a post-install target.",X
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/6114,101703803,2017-02-17T07:59:28Z,src/nvim/hashtab.c,"@@ -82,22 +82,42 @@ void hash_clear_all(hashtab_T *ht, unsigned int off) ///         used for that key. ///         WARNING: Returned pointer becomes invalid as soon as the hash table ///                  is changed in any way.-hashitem_T* hash_find(hashtab_T *ht, char_u *key)+hashitem_T *hash_find(hashtab_T *ht, const char_u *key) {-  return hash_lookup(ht, key, hash_hash(key));+  return hash_lookup(ht, (const char *)key, STRLEN(key), hash_hash(key));+}++/// Like hash_find, but key is not NUL-terminated+///+/// @param[in]  ht  Hashtab to look in.+/// @param[in]  key  Key of the looked-for item. Must not be NULL.+/// @param[in]  len  Key length.+///+/// @return Pointer to the hash item corresponding to the given key.+///         If not found, then return pointer to the empty item that would be+///         used for that key.+///+///         @warning Returned pointer becomes invalid as soon as the hash table+///                  is changed in any way.+hashitem_T *hash_find_len(hashtab_T *ht, const char *key, const size_t len)",It is not an optimization: it is needed to be able to use strings like `bar)` (part of `string(foo.bar)`) without either copying string somewhere or modifying input string. Though I do not remember where exactly this is used in this PR: `dict_find` (which is the function to receive `bar)` in the example) is still copying string over (but `tv_dict_find` from #5119  no longer does this).,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/6110,101779180,2017-02-17T15:27:03Z,src/nvim/strings.c,"@@ -541,3 +544,847 @@ char_u *concat_str(const char_u *restrict str1, const char_u *restrict str2)   return dest; } ++static const char *const e_printf =+    N_(""E766: Insufficient arguments for printf()"");++/// Get string argument from idxp entry in tvs+///+/// Will give an error message for VimL entry with invalid type or for+/// insufficient entries.+///+/// @param[in]  tvs  List of VimL values. List is terminated by VAR_UNKNOWN+///                  value.+/// @param[in,out]  idxp  Index in a list. Will be incremented. Indexing starts+///                       at 1.+///+/// @return Number value or 0 in case of error.+static varnumber_T tv_nr(typval_T *tvs, int *idxp)+  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT+{+  int idx = *idxp - 1;+  varnumber_T n = 0;++  if (tvs[idx].v_type == VAR_UNKNOWN) {+    EMSG(_(e_printf));+  } else {+    (*idxp)++;+    int err = false;+    n = (varnumber_T)get_tv_number_chk(&tvs[idx], &err);+    if (err) {+      n = 0;+    }+  }+  return n;+}++/// Get string argument from idxp entry in tvs+///+/// Will give an error message for VimL entry with invalid type or for+/// insufficient entries.+///+/// @param[in]  tvs  List of VimL values. List is terminated by VAR_UNKNOWN+///                  value.+/// @param[in,out]  idxp  Index in a list. Will be incremented.+///+/// @return String value or NULL in case of error.+static char *tv_str(typval_T *tvs, int *idxp)+  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT+{+  int idx = *idxp - 1;+  char        *s = NULL;++  if (tvs[idx].v_type == VAR_UNKNOWN) {+    EMSG(_(e_printf));+  } else {+    (*idxp)++;+    s = (char *)get_tv_string_chk(&tvs[idx]);+  }+  return s;+}++/// Get pointer argument from the next entry in tvs+///+/// Will give an error message for VimL entry with invalid type or for+/// insufficient entries.+///+/// @param[in]  tvs  List of typval_T values.+/// @param[in,out]  idxp  Pointer to the index of the current value.+///+/// @return Pointer stored in typval_T or NULL.+static const void *tv_ptr(const typval_T *const tvs, int *const idxp)+  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT+{+#define OFF(attr) offsetof(union typval_vval_union, attr)+  STATIC_ASSERT(+      OFF(v_string) == OFF(v_list)+      && OFF(v_string) == OFF(v_dict)+      && OFF(v_string) == OFF(v_partial)+      && sizeof(tvs[0].vval.v_string) == sizeof(tvs[0].vval.v_list)+      && sizeof(tvs[0].vval.v_string) == sizeof(tvs[0].vval.v_dict)+      && sizeof(tvs[0].vval.v_string) == sizeof(tvs[0].vval.v_partial),+      ""Strings, dictionaries, lists and partials are expected to be pointers, ""+      ""so that all three of them can be accessed via v_string"");+#undef OFF+  const int idx = *idxp - 1;+  if (tvs[idx].v_type == VAR_UNKNOWN) {+    EMSG(_(e_printf));+    return NULL;+  } else {+    (*idxp)++;+    return tvs[idx].vval.v_string;+  }+}++/// Get float argument from idxp entry in tvs+///+/// Will give an error message for VimL entry with invalid type or for+/// insufficient entries.+///+/// @param[in]  tvs  List of VimL values. List is terminated by VAR_UNKNOWN+///                  value.+/// @param[in,out]  idxp  Index in a list. Will be incremented.+///+/// @return Floating-point value or zero in case of error.+static float_T tv_float(typval_T *const tvs, int *const idxp)+  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT+{+  int idx = *idxp - 1;+  float_T f = 0;++  if (tvs[idx].v_type == VAR_UNKNOWN) {+    EMSG(_(e_printf));+  } else {+    (*idxp)++;+    if (tvs[idx].v_type == VAR_FLOAT) {+      f = tvs[idx].vval.v_float;+    } else if (tvs[idx].v_type == VAR_NUMBER) {+      f = tvs[idx].vval.v_number;+    } else {+      EMSG(_(""E807: Expected Float argument for printf()""));+    }+  }+  return f;+}++// This code was included to provide a portable vsnprintf() and snprintf().+// Some systems may provide their own, but we always use this one for+// consistency.+//+// This code is based on snprintf.c - a portable implementation of snprintf+// by Mark Martinec <mark.martinec@ijs.si>, Version 2.2, 2000-10-06.+// Included with permission.  It was heavily modified to fit in Vim.+// The original code, including useful comments, can be found here:+//+//     http://www.ijs.si/software/snprintf/+//+// This snprintf() only supports the following conversion specifiers:+// s, c, b, B, d, u, o, x, X, p  (and synonyms: i, D, U, O - see below)+// with flags: '-', '+', ' ', '0' and '#'.+// An asterisk is supported for field width as well as precision.+//+// Limited support for floating point was added: 'f', 'e', 'E', 'g', 'G'.+//+// Length modifiers 'h' (short int), 'l' (long int) and ""ll"" (long long int) are+// supported.+//+// The locale is not used, the string is used as a byte string.  This is only+// relevant for double-byte encodings where the second byte may be '%'.+//+// It is permitted for ""str_m"" to be zero, and it is permitted to specify NULL+// pointer for resulting string argument if ""str_m"" is zero (as per ISO C99).+//+// The return value is the number of characters which would be generated+// for the given input, excluding the trailing NUL. If this value+// is greater or equal to ""str_m"", not all characters from the result+// have been stored in str, output bytes beyond the (""str_m""-1) -th character+// are discarded. If ""str_m"" is greater than zero it is guaranteed+// the resulting string will be NUL-terminated.++// vim_vsnprintf() can be invoked with either ""va_list"" or a list of+// ""typval_T"".  When the latter is not used it must be NULL.++/// Append a formatted value to the string+///+/// @see vim_vsnprintf().+int vim_snprintf_add(char *str, size_t str_m, char *fmt, ...)+{+  const size_t len = strlen(str);+  size_t space;++  if (str_m <= len) {+    space = 0;+  } else {+    space = str_m - len;+  }+  va_list ap;+  va_start(ap, fmt);+  const int str_l = vim_vsnprintf(str + len, space, fmt, ap, NULL);+  va_end(ap);+  return str_l;+}++/// Write formatted value to the string+///+/// @param[out]  str  String to write to.+/// @param[in]  str_m  String length.+/// @param[in]  fmt  String format.+///+/// @return Number of bytes excluding NUL byte that would be written to the+///         string if str_m was greater or equal to the return value.+int vim_snprintf(char *str, size_t str_m, const char *fmt, ...)+{+  va_list ap;+  va_start(ap, fmt);+  const int str_l = vim_vsnprintf(str, str_m, fmt, ap, NULL);+  va_end(ap);+  return str_l;+}+++/// Write formatted value to the string+///+/// @param[out]  str  String to write to.+/// @param[in]  str_m  String length.+/// @param[in]  fmt  String format.+/// @param[in]  ap  Values that should be formatted. Ignored if tvs is not NULL.+/// @param[in]  tvs  Values that should be formatted, for printf() VimL+///                  function. Must be NULL in other cases.+///+/// @return Number of bytes excluding NUL byte that would be written to the+///         string if str_m was greater or equal to the return value.+int vim_vsnprintf(char *str, size_t str_m, const char *fmt, va_list ap,+                  typval_T *const tvs)+{+  size_t str_l = 0;+  bool str_avail = str_l < str_m;+  const char *p = fmt;+  int arg_idx = 1;++  if (!p) {+    p = """";+  }+  while (*p) {+    if (*p != '%') {+      // copy up to the next '%' or NUL without any changes+      size_t n = (size_t)(xstrchrnul(p + 1, '%') - p);+      if (str_avail) {+        size_t avail = str_m - str_l;+        memmove(str + str_l, p, MIN(n, avail));+        str_avail = n < avail;+      }+      p += n;+      assert(n <= SIZE_MAX - str_l);+      str_l += n;+    } else {+      size_t min_field_width = 0, precision = 0;+      int zero_padding = 0, precision_specified = 0, justify_left = 0;+      int alternate_form = 0, force_sign = 0;++      // if both ' ' and '+' flags appear, ' ' flag should be ignored+      int space_for_positive = 1;++      // allowed values: \0, h, l, 2 (for ll), z, L+      char length_modifier = '\0';++      // temporary buffer for simple numeric->string conversion+# define TMP_LEN 350    // 1e308 seems reasonable as the maximum printable+      char tmp[TMP_LEN];++      // string address in case of string argument+      const char *str_arg = NULL;++      // natural field width of arg without padding and sign+      size_t str_arg_l;++      // unsigned char argument value (only defined for c conversion);+      // standard explicitly states the char argument for the c+      // conversion is unsigned+      unsigned char uchar_arg;++      // number of zeros to be inserted for numeric conversions as+      // required by the precision or minimal field width+      size_t number_of_zeros_to_pad = 0;++      // index into tmp where zero padding is to be inserted+      size_t zero_padding_insertion_ind = 0;++      // current conversion specifier character+      char fmt_spec = '\0';++      p++;  // skip '%'++      // parse flags+      while (true) {+        switch (*p) {+          case '0': zero_padding = 1; p++; continue;+          case '-': justify_left = 1; p++; continue;+                    // if both '0' and '-' flags appear, '0' should be ignored+          case '+': force_sign = 1; space_for_positive = 0; p++; continue;+          case ' ': force_sign = 1; p++; continue;+                    // if both ' ' and '+' flags appear, ' ' should be ignored+          case '#': alternate_form = 1; p++; continue;+          case '\'': p++; continue;+          default: break;+        }+        break;+      }++      // parse field width+      if (*p == '*') {+        p++;+        const int j = tvs ? (int)tv_nr(tvs, &arg_idx) : va_arg(ap, int);+        if (j >= 0) {+          min_field_width = (size_t)j;+        } else {+          min_field_width = (size_t)-j;","This looks weird, but I remember scrutinizing it long ago. And this cast just makes it explicit now.",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/6099,101840773,2017-02-17T20:27:11Z,.ci/common/test.sh,"@@ -110,7 +110,16 @@ run_oldtests() { }  run_single_includes_tests() {-  ${MAKE_CMD} -C ""${BULID_DIR}"" check-single-includes+  ulimit -c unlimited+  if ! ${MAKE_CMD} -C ""${BUILD_DIR}"" check-single-includes; then+    asan_check ""${LOG_DIR}""+    valgrind_check ""${LOG_DIR}""+    check_core_dumps","These are useless: test only checks whether some things *compile*. It does not even run anything, and even if it did there is no reason for these executables to trigger any of the above errors: they are mere `int main() { return 0; }` with a few dead codes (`static inline` functions in headers) and a big bunch of various defines (typedefs, macros, globals).You can theoretically find a bug in compiler or CMake via `check_core_dumps`, but `check_core_dumps` is not the right function for this task (it assumes a single app, normally Neovim or luajit). `asan_check` and `valgrind_check` are simply useless, nobody bothered to run CMake or compilers under valgrind or compile them with sanitizers enabled.",X
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/6099,101907539,2017-02-19T02:47:59Z,src/nvim/CMakeLists.txt,"@@ -183,7 +189,7 @@ foreach(sfile ${NEOVIM_SOURCES}     DEPENDS ""${HEADER_GENERATOR}"" ""${sfile}""     )   list(APPEND NEOVIM_GENERATED_SOURCES ""${gf1}"")-  list(APPEND NEOVIM_GENERATED_SOURCES ""${gf2}"")","This code works only because `gf1` and `gf2` files are created by one command. Neovim executables and libraries *do* depend on `*.h.generated.h` files, but in your code they do not depend on ${NEOVIM_GENERATED_HEADERS}. I had two lines which appended to both NEOVIM_GENERATED_HEADERS and NEOVIM_GENERATED_SOURCES for a reason.Though it should be cleaner if all files listed in NEOVIM_GENERATED_HEADERS are excluded from NEOVIM_GENERATED_SOURCES up until NEOVIM_GENERATED_HEADERS is appended to NEOVIM_GENERATED_SOURCES when it stopped being populated.",X
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/6099,102357203,2017-02-22T00:38:57Z,src/nvim/CMakeLists.txt,"@@ -166,28 +176,25 @@ foreach(sfile ${NEOVIM_SOURCES}     set(f ""${d}/${f}"")     set(r ""${d}/${r}"")   endif()-  set(gf1 ""${GENERATED_DIR}/${r}.c.generated.h"")-  set(gf2 ""${GENERATED_INCLUDES_DIR}/${r}.h.generated.h"")-  set(gf3 ""${GENERATED_DIR}/${r}.i"")+  set(gf_c_h ""${GENERATED_DIR}/${r}.c.generated.h"")+  set(gf_h_h ""${GENERATED_INCLUDES_DIR}/${r}.h.generated.h"")+  set(gf_i ""${GENERATED_DIR}/${r}.i"") -  if(MSVC)-    set(PREPROC_OUTPUT /P /Fi${gf3})-  else()-    set(PREPROC_OUTPUT -E -o ${gf3})-  endif()+  get_preproc_output(PREPROC_OUTPUT ${gf_i})    add_custom_command(-    OUTPUT ""${gf1}"" ""${gf2}""+    OUTPUT ""${gf_c_h}"" ""${gf_h_h}""     COMMAND ${CMAKE_C_COMPILER} ${sfile} ${PREPROC_OUTPUT} ${gen_cflags} ${C_FLAGS_ARRAY}-    COMMAND ""${LUA_PRG}"" ""${HEADER_GENERATOR}"" ""${sfile}"" ""${gf1}"" ""${gf2}"" ""${gf3}""+    COMMAND ""${LUA_PRG}"" ""${HEADER_GENERATOR}"" ""${sfile}"" ""${gf_c_h}"" ""${gf_h_h}"" ""${gf_i}""     DEPENDS ""${HEADER_GENERATOR}"" ""${sfile}""     )-  list(APPEND NEOVIM_GENERATED_SOURCES ""${gf1}"")-  list(APPEND NEOVIM_GENERATED_SOURCES ""${gf2}"")+  list(APPEND NEOVIM_GENERATED_SOURCES ""${gf_c_h}"")+  list(APPEND NEOVIM_GENERATED_HEADERS ""${gf_h_h}"")   if(${d} MATCHES ""^api$"" AND NOT ${f} MATCHES ""^api/helpers.c$"")-    list(APPEND API_HEADERS ${gf2})+    list(APPEND API_HEADERS ${gf_h_h})   endif() endforeach()+list(APPEND NEOVIM_GENERATED_SOURCES ""${NEOVIM_GENERATED_HEADERS}"")","Then there are concerns ���this variable must always be present alongside with another one, why there are two?��� and ���description of ���what does this variable contain��� is harder to comprehend��� (���all generated sources��� vs ���generated sources with generated headers included in other headers excluded���).BTW, do not forget to remove duplicate headers from NEOVIM_GENERATED_SOURCES below in either case.",X
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/6111,102572782,2017-02-22T21:08:04Z,src/nvim/eval.c,"@@ -18143,27 +18172,42 @@ static void f_writefile(typval_T *argvars, typval_T *rettv, FunPtr fptr)   bool binary = false;   bool append = false;   if (argvars[2].v_type != VAR_UNKNOWN) {-    if (vim_strchr(get_tv_string(&argvars[2]), 'b')) {+    const char *const flags = (const char *)get_tv_string_chk(&argvars[2]);+    if (flags == NULL) {+      return;+    }+    if (strchr(flags, 'b')) {       binary = true;     }-    if (vim_strchr(get_tv_string(&argvars[2]), 'a')) {+    if (strchr(flags, 'a')) {       append = true;     }   } -  // Always open the file in binary mode, library functions have a mind of-  // their own about CR-LF conversion.-  char_u *fname = get_tv_string(&argvars[1]);-  FILE *fd;-  if (*fname == NUL || (fd = mch_fopen((char *)fname,-       append ? APPENDBIN : WRITEBIN)) == NULL) {-    EMSG2(_(e_notcreate), *fname == NUL ? (char_u *)_(""<empty>"") : fname);-    rettv->vval.v_number = -1;+  const char buf[NUMBUFLEN];+  const char *const fname = (const char *)get_tv_string_buf_chk(&argvars[1],+                                                                (char_u *)buf);+  if (fname == NULL) {+    return;+  }+  FileDescriptor *fp;+  int error;+  rettv->vval.v_number = -1;+  if (*fname == NUL) {+    EMSG(_(""E482: Can't open file with an empty name""));+  } else if ((fp = file_open_new(&error, fname,+                                 ((append ? kFileAppend : kFileTruncate)+                                  | kFileCreate), 0666)) == NULL) {+    emsgf(_(""E482: Can't open file %s for writing: %s""),+          fname, os_strerror(error));   } else {-    if (write_list(fd, argvars[0].vval.v_list, binary) == false) {-      rettv->vval.v_number = -1;+    if (write_list(fp, argvars[0].vval.v_list, binary)) {+      rettv->vval.v_number = 0;",This could be too early to signal a successful write. Flushing of the remaining `RBuffer` could fail in `file_free()` and writing to the file could be incomplete.,X
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/6099,102752107,2017-02-23T16:21:45Z,src/nvim/CMakeLists.txt,"@@ -166,28 +176,25 @@ foreach(sfile ${NEOVIM_SOURCES}     set(f ""${d}/${f}"")     set(r ""${d}/${r}"")   endif()-  set(gf1 ""${GENERATED_DIR}/${r}.c.generated.h"")-  set(gf2 ""${GENERATED_INCLUDES_DIR}/${r}.h.generated.h"")-  set(gf3 ""${GENERATED_DIR}/${r}.i"")+  set(gf_c_h ""${GENERATED_DIR}/${r}.c.generated.h"")+  set(gf_h_h ""${GENERATED_INCLUDES_DIR}/${r}.h.generated.h"")+  set(gf_i ""${GENERATED_DIR}/${r}.i"") -  if(MSVC)-    set(PREPROC_OUTPUT /P /Fi${gf3})-  else()-    set(PREPROC_OUTPUT -E -o ${gf3})-  endif()+  get_preproc_output(PREPROC_OUTPUT ${gf_i})    add_custom_command(-    OUTPUT ""${gf1}"" ""${gf2}""+    OUTPUT ""${gf_c_h}"" ""${gf_h_h}""     COMMAND ${CMAKE_C_COMPILER} ${sfile} ${PREPROC_OUTPUT} ${gen_cflags} ${C_FLAGS_ARRAY}-    COMMAND ""${LUA_PRG}"" ""${HEADER_GENERATOR}"" ""${sfile}"" ""${gf1}"" ""${gf2}"" ""${gf3}""+    COMMAND ""${LUA_PRG}"" ""${HEADER_GENERATOR}"" ""${sfile}"" ""${gf_c_h}"" ""${gf_h_h}"" ""${gf_i}""     DEPENDS ""${HEADER_GENERATOR}"" ""${sfile}""     )-  list(APPEND NEOVIM_GENERATED_SOURCES ""${gf1}"")-  list(APPEND NEOVIM_GENERATED_SOURCES ""${gf2}"")+  list(APPEND NEOVIM_GENERATED_SOURCES ""${gf_c_h}"")+  list(APPEND NEOVIM_GENERATED_HEADERS ""${gf_h_h}"")   if(${d} MATCHES ""^api$"" AND NOT ${f} MATCHES ""^api/helpers.c$"")-    list(APPEND API_HEADERS ${gf2})+    list(APPEND API_HEADERS ${gf_h_h})   endif() endforeach()+list(APPEND NEOVIM_GENERATED_SOURCES ""${NEOVIM_GENERATED_HEADERS}"")","This is nice I guess. Did not came up with such short form.BTW, first line of commit messases is advised not to go above 70 unicode code points: you may see github truncating commit summaries above this boundary. Git itself suggests even lesser summaries: up to 50 display cells because it expects to be optimized for 80-display-cell wide terminals, but our style guide considers this requirement outdated and not aligning well with suggestion ���write commit messages like `component: Commit summary`��� because `component` part may take too much space out of 50 cells.(Note: github limits exactly unicode codepoints, I did test this. `git help commit` talks about characters but given how this condition is normally justified on the internet I assume they actually mean ���display cells��� which only applies to terminals.)",X
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/6099,103078776,2017-02-25T13:23:58Z,src/nvim/CMakeLists.txt,"@@ -252,6 +268,17 @@ add_custom_command(OUTPUT ${GENERATED_OPTIONS}   DEPENDS ${OPTIONS_GENERATOR} ${OPTIONS_LIST_FILE} ) +# Make NEOVIM_GENERATED_FOR_SOURCES and NEOVIM_GENERATED_FOR_HEADERS mutually exclusive+# If a header in NEOVIM_GENERATED_FOR_HEADERS is also included in NEOVIM_GENERATED_SOURCES,+# the header should be included only in NEOVIM_GENERATED_HEADERS++foreach(hfile ${NEOVIM_GENERATED_FOR_HEADERS})+  list(FIND NEOVIM_GENERATED_FOR_SOURCES ${hfile} hfile_idx)+  if(NOT ${hfile_idx} EQUAL -1)+    list(REMOVE_AT NEOVIM_GENERATED_FOR_SOURCES ${hfile_idx})",And you still need to remove duplicate files.,X
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/6099,103078898,2017-02-25T13:29:38Z,src/nvim/CMakeLists.txt,"@@ -252,6 +268,17 @@ add_custom_command(OUTPUT ${GENERATED_OPTIONS}   DEPENDS ${OPTIONS_GENERATOR} ${OPTIONS_LIST_FILE} ) +# Make NEOVIM_GENERATED_FOR_SOURCES and NEOVIM_GENERATED_FOR_HEADERS mutually exclusive+# If a header in NEOVIM_GENERATED_FOR_HEADERS is also included in NEOVIM_GENERATED_SOURCES,+# the header should be included only in NEOVIM_GENERATED_HEADERS++foreach(hfile ${NEOVIM_GENERATED_FOR_HEADERS})+  list(FIND NEOVIM_GENERATED_FOR_SOURCES ${hfile} hfile_idx)+  if(NOT ${hfile_idx} EQUAL -1)+    list(REMOVE_AT NEOVIM_GENERATED_FOR_SOURCES ${hfile_idx})","AFAIK duplicate files in dependencies are fine for CMake, just it is semantically incorrect in the current state: there are no generated files I am aware of which are included in both headers and sources.",X
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/6044,103081125,2017-02-25T15:30:24Z,src/nvim/ui_bridge.c,"@@ -181,12 +182,19 @@ static void ui_bridge_cursor_goto_event(void **argv)  static void ui_bridge_cursor_styleset(UI *b, Dictionary args) {-  UI_CALL(b, cursor_styleset, 2, b, &args);+  Object copy = copy_object(DICTIONARY_OBJ(args));+  Object *a = xmalloc(sizeof(Object));+  *a = copy;+  UI_CALL(b, cursor_styleset, 2, b, a);","Also the `*a = copy` won't work because data  (`copy`) was allocated on the stack. You would need to use `memcpy(a, &copy, sizeof(Object))`.",X
12672140,enishina,https://api.github.com/repos/neovim/neovim/pulls/6099,103082787,2017-02-25T16:54:41Z,src/nvim/CMakeLists.txt,"@@ -252,6 +268,17 @@ add_custom_command(OUTPUT ${GENERATED_OPTIONS}   DEPENDS ${OPTIONS_GENERATOR} ${OPTIONS_LIST_FILE} ) +# Make NEOVIM_GENERATED_FOR_SOURCES and NEOVIM_GENERATED_FOR_HEADERS mutually exclusive+# If a header in NEOVIM_GENERATED_FOR_HEADERS is also included in NEOVIM_GENERATED_SOURCES,+# the header should be included only in NEOVIM_GENERATED_HEADERS++foreach(hfile ${NEOVIM_GENERATED_FOR_HEADERS})+  list(FIND NEOVIM_GENERATED_FOR_SOURCES ${hfile} hfile_idx)+  if(NOT ${hfile_idx} EQUAL -1)+    list(REMOVE_AT NEOVIM_GENERATED_FOR_SOURCES ${hfile_idx})","My intention to rename NEOVIM_GENERATED to NEOVIM_GENERATED_FOR was to let the name consistent with the content to let developers understand them easily. It was not intended to make them mutually exclusive. If a generated header file is included in headers, it should be appended to NEOVIM_GENERATED_FOR_HEADERS. And if it is also included in sources, it should also be appended to NEOVIM_GENERATED_FOR_SOURCES. That was the semantics I intended.And, if CMake permits duplicated files to build dependency trees, then these two lists don't need to be mutually exclusive.So, if you understand my intention and the semantics is not collapsed, I would like to remove the invariance that these two lists should be mutually exclusive.",X
12672140,enishina,https://api.github.com/repos/neovim/neovim/pulls/6099,103082870,2017-02-25T16:58:51Z,src/nvim/CMakeLists.txt,"@@ -252,6 +268,17 @@ add_custom_command(OUTPUT ${GENERATED_OPTIONS}   DEPENDS ${OPTIONS_GENERATOR} ${OPTIONS_LIST_FILE} ) +# Make NEOVIM_GENERATED_FOR_SOURCES and NEOVIM_GENERATED_FOR_HEADERS mutually exclusive+# If a header in NEOVIM_GENERATED_FOR_HEADERS is also included in NEOVIM_GENERATED_SOURCES,+# the header should be included only in NEOVIM_GENERATED_HEADERS++foreach(hfile ${NEOVIM_GENERATED_FOR_HEADERS})+  list(FIND NEOVIM_GENERATED_FOR_SOURCES ${hfile} hfile_idx)+  if(NOT ${hfile_idx} EQUAL -1)+    list(REMOVE_AT NEOVIM_GENERATED_FOR_SOURCES ${hfile_idx})",I'm confirming if CMake really permits duplicated files to build dependency graphs.,X
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/6099,103084756,2017-02-25T18:30:51Z,src/nvim/CMakeLists.txt,"@@ -361,17 +389,97 @@ elseif(CLANG_TSAN)   set_property(TARGET nvim APPEND_STRING PROPERTY LINK_FLAGS ""-fsanitize=thread "") endif() -add_library(libnvim STATIC EXCLUDE_FROM_ALL ${NEOVIM_GENERATED_SOURCES}+add_library(libnvim STATIC EXCLUDE_FROM_ALL ${NEOVIM_GENERATED_FOR_SOURCES} ${NEOVIM_GENERATED_FOR_HEADERS} ${NEOVIM_GENERATED_SOURCES}",Line has grown way too long. Also the similar one below.,X
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/6099,103084802,2017-02-25T18:33:14Z,src/nvim/CMakeLists.txt,"@@ -152,6 +154,21 @@ separate_arguments(C_FLAGS_ARRAY UNIX_COMMAND ${CMAKE_C_FLAGS}) separate_arguments(C_FLAGS_${build_type}_ARRAY UNIX_COMMAND ${CMAKE_C_FLAGS_${build_type}}) set(gen_cflags ${gen_cflags} ${C_FLAGS_${build_type}_ARRAY} ${C_FLAGS_ARRAY}) +function(get_preproc_output varname iname)+  if(MSVC)+    set(${varname} /P /Fi${iname} PARENT_SCOPE)+  else()+    set(${varname} -E -o ${iname} PARENT_SCOPE)+  endif()+endfunction()++# NEOVIM_GENERATED_FOR_HEADERS: header files generated to be included in headers+# NEOVIM_GENERATED_FOR_SOURCES: header files generated to be included in sources+# NEOVIM_GENERATED_SOURCES: generated source files+# These lists should be mutually exclusive+# If a generated file is included in both of headers and sources,+# the file for one should be duplicated for the other with different filepath.","So no advice to duplicate anything, it is looking like a bad code. Also do not remember any generated files normally included twice anywhere, even twice in headers (though AFAIR I did some similar hack to break dependency cycle somewhere, not sure whether it was removed or not).",X
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/6099,103085092,2017-02-25T18:41:17Z,src/nvim/CMakeLists.txt,"@@ -252,6 +268,17 @@ add_custom_command(OUTPUT ${GENERATED_OPTIONS}   DEPENDS ${OPTIONS_GENERATOR} ${OPTIONS_LIST_FILE} ) +# Make NEOVIM_GENERATED_FOR_SOURCES and NEOVIM_GENERATED_FOR_HEADERS mutually exclusive+# If a header in NEOVIM_GENERATED_FOR_HEADERS is also included in NEOVIM_GENERATED_SOURCES,+# the header should be included only in NEOVIM_GENERATED_HEADERS++foreach(hfile ${NEOVIM_GENERATED_FOR_HEADERS})+  list(FIND NEOVIM_GENERATED_FOR_SOURCES ${hfile} hfile_idx)+  if(NOT ${hfile_idx} EQUAL -1)+    list(REMOVE_AT NEOVIM_GENERATED_FOR_SOURCES ${hfile_idx})","> And, if CMake permits duplicated files to build dependency trees, then these two lists don't need to be mutually exclusive.Need to: yes. But as I said above I know no such files which are included in both. And as I said below I think this is a bad practice in first place. There are also a lot of cases when it is not only bad, it may as well make including header which included generated file in a `*.c` file which also include the same generated file on its own impossible (actually unless it is a generated `*.c.h` file or the like it would be always impossible), at least without taiting the preprocessor. `*.c` file which for some weird reason cannot include some particular header file without one `#undef` or `#define` per identifier defined in that generated file is not something anybody wants in the codebase.",X
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/6170,103269598,2017-02-27T17:55:47Z,runtime/doc/msgpack_rpc.txt,"@@ -413,5 +417,9 @@ of update. [""popupmenu_hide""] 	The popupmenu is hidden. +[""tabline"", curtab, tabs]","An event is something that happens. Let's name this something more granular, e.g. ""tabline_update"". That follows the pattern of the existing ""bg_update"" and similar events.",X
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/6170,103270783,2017-02-27T18:00:55Z,src/nvim/window.c,"@@ -5158,6 +5160,9 @@ static void last_status_rec(frame_T *fr, int statusline)  */ int tabline_height(void) {+  if (tabline_external) {","Can this query the UI structure instead of storing extra state in window.c? E.g. `ui_is_widget_external(kUITabline)`, where the parameter is a enum like:enum {kUITabline,kUIStatusline,kUICmdline,...}",X
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/6190,103306999,2017-02-27T20:42:41Z,runtime/doc/eval.txt,"@@ -89,14 +89,30 @@ To force conversion from String to Number, add zero to it: > To avoid a leading zero to cause octal conversion, or for using a different base, use |str2nr()|. +							*TRUE* *FALSE* For boolean operators Numbers are used.  Zero is FALSE, non-zero is TRUE.+You can also use |v:false| and |v:true|.  When TRUE is returned from a+function it is the Number one, FALSE is the number zero. -Note that in the command >+Note that in the command: > 	:if ""foo""-""foo"" is converted to 0, which means FALSE.  To test for a non-empty string,-use empty(): >+	:"" NOT executed+""foo"" is converted to 0, which means FALSE.  If the string starts with a+non-zero number it means TRUE: >+	:if ""8foo""+	:"" executed+To test for a non-empty string, use empty(): > 	:if !empty(""foo"")-<				*E745* *E728* *E703* *E729* *E730* *E731*+<+							*non-zero-arg*+Function arguments often behave slightly different from |TRUE|: If the+argument is present and it evaluates to a non-zero Number, |v:true| or a+non-empty String, then the value is considere to be TRUE.+Note that "" "" and ""0"" are also non-empty strings, thus cause the mode to be+cleared.  A List, Dictionary or Float is not a Number or String, thus+evaluates to FALSE.",a Float is not a Number. classic,X
886074,teto,https://api.github.com/repos/neovim/neovim/pulls/6073,103319059,2017-02-27T21:40:18Z,src/nvim/api/vim.c,"@@ -33,6 +34,22 @@ # include ""api/vim.c.generated.h"" #endif +/// @see foldCreate","Thanks for the tip ! I've still a few things to do before passing this to RFC.I am now looking at making the fold width autoadapt. I enable it with `set fdc=-1` to prevent the creation of a new variable. Is that ok ? If the PR gets too big, I could split it up anyway.",X
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/6149,103344459,2017-02-27T23:56:30Z,runtime/autoload/man.vim,"@@ -70,12 +72,14 @@ endfunction function! man#read_page(ref) abort   try     let [sect, name] = man#extract_sect_and_name_ref(a:ref)-    let [b:man_sect, name, path] = s:verify_exists(sect, name)+    let [sect, name, path] = s:verify_exists(sect, name)     let page = s:get_page(path)   catch-    "" call to s:error() is unnecessary+    "" call to s:error() does nothing because we were+    "" called from the BufReadCmd autocmd.","What matters is that an error was already shown. I don't know what changed to make s:error ""do nothing"" (nor do I see how that's possible, it clearly does something if called). The new comment is also 3x as long. What's wrong with the old comment?",X
10180857,nhooyr,https://api.github.com/repos/neovim/neovim/pulls/6149,103346334,2017-02-28T00:09:29Z,runtime/autoload/man.vim,"@@ -70,12 +72,14 @@ endfunction function! man#read_page(ref) abort   try     let [sect, name] = man#extract_sect_and_name_ref(a:ref)-    let [b:man_sect, name, path] = s:verify_exists(sect, name)+    let [sect, name, path] = s:verify_exists(sect, name)     let page = s:get_page(path)   catch-    "" call to s:error() is unnecessary+    "" call to s:error() does nothing because we were+    "" called from the BufReadCmd autocmd.","~~There was no error shown though. Try `tabe man://printsssdsds`. Even if you add a `s:error(v:exception)` call (though I'm not entirely sure why), no error is printed.~~Aha, I had `shortmess+=F` which hides the message. So we should have the call to `s:error` there.Do you think it's a bug that `shortmess+=F` is hiding messages from `:echo`?Help says```don't give the file info when editing a file, like :silentwas used for the command```but perhaps it shouldn't just `:silent`, but instead, only not print the file info message?",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/6170,103406608,2017-02-28T09:10:40Z,src/nvim/ui.c,"@@ -548,3 +555,31 @@ static void ui_mode_change(void)   conceal_check_cursur_line(); } +bool ui_is_widget_external(int widget)",parameter should be `UIWidget widget`,X
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/6170,103408130,2017-02-28T09:19:33Z,src/nvim/screen.c,"@@ -6888,6 +6889,30 @@ static void draw_tabline(void)   int use_sep_chars = (t_colors < 8                        ); +  if (ui_is_widget_external(kUITabline)) {","Let's factor this out to a new function, `draw_tabline_ext()`.```cif (ui_is_widget_external(kUITabline)) {  draw_tabline_ext();  return;}```If possible, try to follow a similar pattern for other externalized widgets.",X
886074,teto,https://api.github.com/repos/neovim/neovim/pulls/5878,103501025,2017-02-28T16:53:00Z,test/functional/legacy/listlbr_utf8_spec.lua,"@@ -1,209 +1,184 @@--- Test for linebreak and list option in utf-8 mode- local helpers = require('test.functional.helpers')(after_each)-local source = helpers.source-local feed = helpers.feed-local clear, expect = helpers.clear, helpers.expect+local Screen = require('test.functional.ui.screen') -describe('linebreak', function()-  setup(clear) -  it('is working', function()-    source([[-      set wildchar=^E-      10new-      vsp-      vert resize 20-      put =\""\tabcdef hijklmn\tpqrstuvwxyz\u00a01060ABCDEFGHIJKLMNOP \""-      norm! zt-      set ts=4 sw=4 sts=4 linebreak sbr=+ wrap-      fu! ScreenChar(width, lines)-      	let c=''-      	for j in range(1,a:lines)-      	    for i in range(1,a:width)-      	    	let c.=nr2char(screenchar(j, i))-      	    endfor-                 let c.=""\n""-      	endfor-      	return c-      endfu-      fu! DoRecordScreen()-      	wincmd l-      	$put =printf(\""\n%s\"", g:test)-      	$put =g:line-      	wincmd p-      endfu-      ""-      let g:test =""Test 1: set linebreak + set list + fancy listchars""-      exe ""set linebreak list listchars=nbsp:\u2423,tab:\u2595\u2014,trail:\u02d1,eol:\ub6""-      redraw!-      let line=ScreenChar(winwidth(0),4)-      call DoRecordScreen()-      ""-      let g:test =""Test 2: set nolinebreak list""-      set list nolinebreak-      redraw!-      let line=ScreenChar(winwidth(0),4)-      call DoRecordScreen()-      ""-      let g:test =""Test 3: set linebreak nolist""-      $put =\""\t*mask = nil;\""-      $-      norm! zt-      set nolist linebreak-      redraw!-      let line=ScreenChar(winwidth(0),4)-      call DoRecordScreen()-      ""-      let g:test =""Test 4: set linebreak list listchars and concealing""-      let c_defines=['#define ABCDE		1','#define ABCDEF		1','#define ABCDEFG		1','#define ABCDEFGH	1', '#define MSG_MODE_FILE			1','#define MSG_MODE_CONSOLE		2','#define MSG_MODE_FILE_AND_CONSOLE	3','#define MSG_MODE_FILE_THEN_CONSOLE	4']-      call append('$', c_defines)-      vert resize 40-      $-7-      norm! zt-      set list linebreak listchars=tab:>- cole=1-      syn match Conceal conceal cchar=>'AB\|MSG_MODE'-      redraw!-      let line=ScreenChar(winwidth(0),7)-      call DoRecordScreen()-      ""-      let g:test =""Test 5: set linebreak list listchars and concealing part2""-      let c_defines=['bbeeeeee		;	some text']-      call append('$', c_defines)-      $-      norm! zt-      set nowrap ts=2 list linebreak listchars=tab:>- cole=2 concealcursor=n-      syn clear-      syn match meaning    /;\s*\zs.*/-      syn match hasword    /^\x\{8}/    contains=word-      syn match word       /\<\x\{8}\>/ contains=beginword,endword contained-      syn match beginword  /\<\x\x/     contained conceal-      syn match endword    /\x\{6}\>/   contained-      hi meaning   guibg=blue-      hi beginword guibg=green-      hi endword   guibg=red-      redraw!-      let line=ScreenChar(winwidth(0),1)-      call DoRecordScreen()-      ""-      let g:test =""Test 6: Screenattributes for comment""-      $put =g:test-      call append('$', ' /*		 and some more */')-      exe ""set ft=c ts=7 linebreak list listchars=nbsp:\u2423,tab:\u2595\u2014,trail:\u02d1,eol:\ub6""-      syntax on-      hi SpecialKey term=underline ctermfg=red guifg=red-      let attr=[]-      nnoremap <expr> GG "":let attr += ['"".screenattr(screenrow(),screencol()).""']\n""-      $-      norm! zt0+local feed, execute, source, insert = helpers.feed, helpers.execute,+    helpers.source, helpers.insert+local session = helpers++describe(""linebreak"", function()+  local screen+  pending(""temporary"")++  before_each(function()+    session.clear()++    screen = Screen.new(20, 5)+    screen:attach()++    execute('set wildchar=<C-e>')+    execute('vert resize 20')+    execute('set ts=4 sw=4 sts=4 linebreak showbreak=+ wrap')+    execute(""set linebreak list listchars=nbsp:���,tab:������,trail:��,eol:��"")+  end)++  after_each(function()+    screen:detach()+  end)++  it(""set linebreak list with fancy listchars"", function()+    execute(""set linebreak list listchars=nbsp:���,tab:������,trail:��,eol:��"")+    feed(""i\tabcdef hijklmn\tpqrstuvwxyz��1060ABCDEFGHIJKLMNOP "")+    screen:expect([[+    ������������abcdef          |+    +hijklmn������������        |+    +pqrstuvwxyz���1060ABC|+    +DEFGHIJKLMNOP��^��    |+    -- INSERT --        |     ]])-    feed('GGlGGlGGlGGlGGlGGlGGlGGlGGlGGl')-    source([[-      call append('$', ['ScreenAttributes for test6:'])-      if attr[0] != attr[1] && attr[1] != attr[3] && attr[3] != attr[5]-         call append('$', ""Attribut 0 and 1 and 3 and 5 are different!"")-      else-         call append('$', ""Not all attributes are different"")-      endif-      set cpo&vim linebreak selection=exclusive-      let g:test =""Test 8: set linebreak with visual block mode and v_b_A and selection=exclusive and multibyte char""-      $put =g:test+  end)++  it(""set list nolinebreak"", function()+    execute(""set list nolinebreak"")+    feed(""i\tabcdef hijklmn\tpqrstuvwxyz��1060ABCDEFGHIJKLMNOP "")+    screen:expect([[+    ������������abcdef hijklmn������|+    +pqrstuvwxyz���1060ABC|+    +DEFGHIJKLMNOP��^��    |+    ~                   |+    -- INSERT --        |     ]])-    feed(""Golong line: <Esc>40afoobar <Esc>aTARGET��' at end<Esc>"")-    source([[-      exe ""norm! $3B\<C-v>eAx\<Esc>""-      ""-      let g:test =""Test 9: a multibyte sign and colorcolumn""-      let attr=[]-      let attr2=[]-      $put =''-      $put ='a b c'-      $put ='a b c'-      set list nolinebreak cc=3+  end)++  it(""set linebreak nolist"", function()+    execute(""set nolist linebreak"")+    feed(""i\t*mask = nil;"")+    -- execute(""norm! zt"")+    screen:expect([[+        *mask = nil;^    |+    ~                   |+    ~                   |+    ~                   |+    -- INSERT --        |     ]])-    feed(':sign define foo text=<C-v>uff0b<CR>')+  end)++  it(""set linebreak list listchars and concealing"", function()+    -- execute(""set list nolinebreak"")+    screen:try_resize(40, 9)+    -- $-7     source([[-      sign place 1 name=foo line=50 buffer=2-      norm! 2kztj-      let line1=line('.')+    let c_defines=['#define ABCDE		1','#define ABCDEF		1','#define ABCDEFG		1','#define ABCDEFGH	1', '#define MSG_MODE_FILE			1','#define MSG_MODE_CONSOLE		2','#define MSG_MODE_FILE_AND_CONSOLE	3']+    call append(0, c_defines)     ]])-    feed('0GGlGGlGGlGGl')-    source([[-      let line2=line('.')-      let attr2=attr-      let attr=[]+    execute(""set list linebreak listchars=tab:>- conceallevel=1"")+    execute(""verbose set sw? sts? ts?"")+    -- see :h syn-cchar+    execute(""syn match Conceal conceal cchar=>'AB\\|MSG_MODE'"")+    screen:expect([[+    #define >CDE>--->---1                   |+    #define >CDEF>-->---1                   |+    #define >CDEFG>->---1                   |+    #define >CDEFGH>----1                   |+    #define >_FILE>--------->--->---1       |+    #define >_CONSOLE>---------->---2       |+    #define >_FILE_AND_CONSOLE>---------3   |+    ^                                        |+                                            |     ]])-    feed('0GGlGGlGGlGGl')+    execute(""gg"")+  end)++  it(""set linebreak list listchars and concealing part2"", function()+    -- should conceal 'bb'+    screen:try_resize(40, 6)+    source([[+    let c_defines=['bbeeeeee		;	some text']+    call append(0, c_defines)+    $]])+    -- concealcursor=n => just in normal mode+    -- cole=2 => not displayed if no cchar+    execute(""set nowrap ts=2 list linebreak listchars=tab:>- cole=2 concealcursor=n"")     source([[-      redraw!-      let line=ScreenChar(winwidth(0),3)-      call DoRecordScreen()-      "" expected: attr[2] is different because of colorcolumn-      if attr[0] != attr2[0] || attr[1] != attr2[1] || attr[2] != attr2[2]-         call append('$', ""Screen attributes are different!"")-      else-         call append('$', ""Screen attributes are the same!"")-      endif+    syn clear+    syn match meaning    /;\s*\zs.*/+    syn match hasword    /^\x\{8}/    contains=word+    syn match word       /\<\x\{8}\>/ contains=beginword,endword contained+    syn match beginword  /\<\x\x/     contained conceal+    syn match endword    /\x\{6}\>/   contained+    hi meaning   guibg=blue+    hi beginword guibg=green+    hi endword   guibg=red     ]])+    helpers.wait()+    screen:expect(""eeeeee>--->-;>some text"",+    nil,nil,nil, true )+  end) -    -- Assert buffer contents.-    expect([[-      -      	abcdef hijklmn	pqrstuvwxyz��1060ABCDEFGHIJKLMNOP -      -      Test 1: set linebreak + set list + fancy listchars-      ������������abcdef          -      +hijklmn������������        -      +pqrstuvwxyz���1060ABC-      +DEFGHIJKLMNOP����    -      -      Test 2: set nolinebreak list-      ������������abcdef hijklmn������-      +pqrstuvwxyz���1060ABC-      +DEFGHIJKLMNOP����    -      ��                   -      	*mask = nil;-      -      Test 3: set linebreak nolist-          *mask = nil;    -      ~                   -      ~                   -      ~                   -      #define ABCDE		1-      #define ABCDEF		1-      #define ABCDEFG		1-      #define ABCDEFGH	1-      #define MSG_MODE_FILE			1-      #define MSG_MODE_CONSOLE		2-      #define MSG_MODE_FILE_AND_CONSOLE	3-      #define MSG_MODE_FILE_THEN_CONSOLE	4-      -      Test 4: set linebreak list listchars and concealing-      #define ABCDE>-->---1                   -      #define >CDEF>-->---1                   -      #define >CDEFG>->---1                   -      #define >CDEFGH>----1                   -      #define >_FILE>--------->--->---1       -      #define >_CONSOLE>---------->---2       -      #define >_FILE_AND_CONSOLE>---------3   -      bbeeeeee		;	some text-      -      Test 5: set linebreak list listchars and concealing part2-      eeeeee>--->-;>some text                 -      Test 6: Screenattributes for comment-       /*		 and some more */-      ScreenAttributes for test6:-      Attribut 0 and 1 and 3 and 5 are different!-      Test 8: set linebreak with visual block mode and v_b_A and selection=exclusive and multibyte char-      long line: foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar TARGET��x' at end+  -- TODO update with new neovim system to check attributes+  -- or remove it if done somewhere else+  -- it(""screenattributes for comment"", function()",seems like a bad test compared to screen:expect . do you still want me to upgrade it ? or simply remove it ?,X
244927,chrisbra,https://api.github.com/repos/neovim/neovim/pulls/5878,103524964,2017-02-28T18:49:26Z,test/functional/legacy/listlbr_utf8_spec.lua,"@@ -1,209 +1,184 @@--- Test for linebreak and list option in utf-8 mode- local helpers = require('test.functional.helpers')(after_each)-local source = helpers.source-local feed = helpers.feed-local clear, expect = helpers.clear, helpers.expect+local Screen = require('test.functional.ui.screen') -describe('linebreak', function()-  setup(clear) -  it('is working', function()-    source([[-      set wildchar=^E-      10new-      vsp-      vert resize 20-      put =\""\tabcdef hijklmn\tpqrstuvwxyz\u00a01060ABCDEFGHIJKLMNOP \""-      norm! zt-      set ts=4 sw=4 sts=4 linebreak sbr=+ wrap-      fu! ScreenChar(width, lines)-      	let c=''-      	for j in range(1,a:lines)-      	    for i in range(1,a:width)-      	    	let c.=nr2char(screenchar(j, i))-      	    endfor-                 let c.=""\n""-      	endfor-      	return c-      endfu-      fu! DoRecordScreen()-      	wincmd l-      	$put =printf(\""\n%s\"", g:test)-      	$put =g:line-      	wincmd p-      endfu-      ""-      let g:test =""Test 1: set linebreak + set list + fancy listchars""-      exe ""set linebreak list listchars=nbsp:\u2423,tab:\u2595\u2014,trail:\u02d1,eol:\ub6""-      redraw!-      let line=ScreenChar(winwidth(0),4)-      call DoRecordScreen()-      ""-      let g:test =""Test 2: set nolinebreak list""-      set list nolinebreak-      redraw!-      let line=ScreenChar(winwidth(0),4)-      call DoRecordScreen()-      ""-      let g:test =""Test 3: set linebreak nolist""-      $put =\""\t*mask = nil;\""-      $-      norm! zt-      set nolist linebreak-      redraw!-      let line=ScreenChar(winwidth(0),4)-      call DoRecordScreen()-      ""-      let g:test =""Test 4: set linebreak list listchars and concealing""-      let c_defines=['#define ABCDE		1','#define ABCDEF		1','#define ABCDEFG		1','#define ABCDEFGH	1', '#define MSG_MODE_FILE			1','#define MSG_MODE_CONSOLE		2','#define MSG_MODE_FILE_AND_CONSOLE	3','#define MSG_MODE_FILE_THEN_CONSOLE	4']-      call append('$', c_defines)-      vert resize 40-      $-7-      norm! zt-      set list linebreak listchars=tab:>- cole=1-      syn match Conceal conceal cchar=>'AB\|MSG_MODE'-      redraw!-      let line=ScreenChar(winwidth(0),7)-      call DoRecordScreen()-      ""-      let g:test =""Test 5: set linebreak list listchars and concealing part2""-      let c_defines=['bbeeeeee		;	some text']-      call append('$', c_defines)-      $-      norm! zt-      set nowrap ts=2 list linebreak listchars=tab:>- cole=2 concealcursor=n-      syn clear-      syn match meaning    /;\s*\zs.*/-      syn match hasword    /^\x\{8}/    contains=word-      syn match word       /\<\x\{8}\>/ contains=beginword,endword contained-      syn match beginword  /\<\x\x/     contained conceal-      syn match endword    /\x\{6}\>/   contained-      hi meaning   guibg=blue-      hi beginword guibg=green-      hi endword   guibg=red-      redraw!-      let line=ScreenChar(winwidth(0),1)-      call DoRecordScreen()-      ""-      let g:test =""Test 6: Screenattributes for comment""-      $put =g:test-      call append('$', ' /*		 and some more */')-      exe ""set ft=c ts=7 linebreak list listchars=nbsp:\u2423,tab:\u2595\u2014,trail:\u02d1,eol:\ub6""-      syntax on-      hi SpecialKey term=underline ctermfg=red guifg=red-      let attr=[]-      nnoremap <expr> GG "":let attr += ['"".screenattr(screenrow(),screencol()).""']\n""-      $-      norm! zt0+local feed, execute, source, insert = helpers.feed, helpers.execute,+    helpers.source, helpers.insert+local session = helpers++describe(""linebreak"", function()+  local screen+  pending(""temporary"")++  before_each(function()+    session.clear()++    screen = Screen.new(20, 5)+    screen:attach()++    execute('set wildchar=<C-e>')+    execute('vert resize 20')+    execute('set ts=4 sw=4 sts=4 linebreak showbreak=+ wrap')+    execute(""set linebreak list listchars=nbsp:���,tab:������,trail:��,eol:��"")+  end)++  after_each(function()+    screen:detach()+  end)++  it(""set linebreak list with fancy listchars"", function()+    execute(""set linebreak list listchars=nbsp:���,tab:������,trail:��,eol:��"")+    feed(""i\tabcdef hijklmn\tpqrstuvwxyz��1060ABCDEFGHIJKLMNOP "")+    screen:expect([[+    ������������abcdef          |+    +hijklmn������������        |+    +pqrstuvwxyz���1060ABC|+    +DEFGHIJKLMNOP��^��    |+    -- INSERT --        |     ]])-    feed('GGlGGlGGlGGlGGlGGlGGlGGlGGlGGl')-    source([[-      call append('$', ['ScreenAttributes for test6:'])-      if attr[0] != attr[1] && attr[1] != attr[3] && attr[3] != attr[5]-         call append('$', ""Attribut 0 and 1 and 3 and 5 are different!"")-      else-         call append('$', ""Not all attributes are different"")-      endif-      set cpo&vim linebreak selection=exclusive-      let g:test =""Test 8: set linebreak with visual block mode and v_b_A and selection=exclusive and multibyte char""-      $put =g:test+  end)++  it(""set list nolinebreak"", function()+    execute(""set list nolinebreak"")+    feed(""i\tabcdef hijklmn\tpqrstuvwxyz��1060ABCDEFGHIJKLMNOP "")+    screen:expect([[+    ������������abcdef hijklmn������|+    +pqrstuvwxyz���1060ABC|+    +DEFGHIJKLMNOP��^��    |+    ~                   |+    -- INSERT --        |     ]])-    feed(""Golong line: <Esc>40afoobar <Esc>aTARGET��' at end<Esc>"")-    source([[-      exe ""norm! $3B\<C-v>eAx\<Esc>""-      ""-      let g:test =""Test 9: a multibyte sign and colorcolumn""-      let attr=[]-      let attr2=[]-      $put =''-      $put ='a b c'-      $put ='a b c'-      set list nolinebreak cc=3+  end)++  it(""set linebreak nolist"", function()+    execute(""set nolist linebreak"")+    feed(""i\t*mask = nil;"")+    -- execute(""norm! zt"")+    screen:expect([[+        *mask = nil;^    |+    ~                   |+    ~                   |+    ~                   |+    -- INSERT --        |     ]])-    feed(':sign define foo text=<C-v>uff0b<CR>')+  end)++  it(""set linebreak list listchars and concealing"", function()+    -- execute(""set list nolinebreak"")+    screen:try_resize(40, 9)+    -- $-7     source([[-      sign place 1 name=foo line=50 buffer=2-      norm! 2kztj-      let line1=line('.')+    let c_defines=['#define ABCDE		1','#define ABCDEF		1','#define ABCDEFG		1','#define ABCDEFGH	1', '#define MSG_MODE_FILE			1','#define MSG_MODE_CONSOLE		2','#define MSG_MODE_FILE_AND_CONSOLE	3']+    call append(0, c_defines)     ]])-    feed('0GGlGGlGGlGGl')-    source([[-      let line2=line('.')-      let attr2=attr-      let attr=[]+    execute(""set list linebreak listchars=tab:>- conceallevel=1"")+    execute(""verbose set sw? sts? ts?"")+    -- see :h syn-cchar+    execute(""syn match Conceal conceal cchar=>'AB\\|MSG_MODE'"")+    screen:expect([[+    #define >CDE>--->---1                   |+    #define >CDEF>-->---1                   |+    #define >CDEFG>->---1                   |+    #define >CDEFGH>----1                   |+    #define >_FILE>--------->--->---1       |+    #define >_CONSOLE>---------->---2       |+    #define >_FILE_AND_CONSOLE>---------3   |+    ^                                        |+                                            |     ]])-    feed('0GGlGGlGGlGGl')+    execute(""gg"")+  end)++  it(""set linebreak list listchars and concealing part2"", function()+    -- should conceal 'bb'+    screen:try_resize(40, 6)+    source([[+    let c_defines=['bbeeeeee		;	some text']+    call append(0, c_defines)+    $]])+    -- concealcursor=n => just in normal mode+    -- cole=2 => not displayed if no cchar+    execute(""set nowrap ts=2 list linebreak listchars=tab:>- cole=2 concealcursor=n"")     source([[-      redraw!-      let line=ScreenChar(winwidth(0),3)-      call DoRecordScreen()-      "" expected: attr[2] is different because of colorcolumn-      if attr[0] != attr2[0] || attr[1] != attr2[1] || attr[2] != attr2[2]-         call append('$', ""Screen attributes are different!"")-      else-         call append('$', ""Screen attributes are the same!"")-      endif+    syn clear+    syn match meaning    /;\s*\zs.*/+    syn match hasword    /^\x\{8}/    contains=word+    syn match word       /\<\x\{8}\>/ contains=beginword,endword contained+    syn match beginword  /\<\x\x/     contained conceal+    syn match endword    /\x\{6}\>/   contained+    hi meaning   guibg=blue+    hi beginword guibg=green+    hi endword   guibg=red     ]])+    helpers.wait()+    screen:expect(""eeeeee>--->-;>some text"",+    nil,nil,nil, true )+  end) -    -- Assert buffer contents.-    expect([[-      -      	abcdef hijklmn	pqrstuvwxyz��1060ABCDEFGHIJKLMNOP -      -      Test 1: set linebreak + set list + fancy listchars-      ������������abcdef          -      +hijklmn������������        -      +pqrstuvwxyz���1060ABC-      +DEFGHIJKLMNOP����    -      -      Test 2: set nolinebreak list-      ������������abcdef hijklmn������-      +pqrstuvwxyz���1060ABC-      +DEFGHIJKLMNOP����    -      ��                   -      	*mask = nil;-      -      Test 3: set linebreak nolist-          *mask = nil;    -      ~                   -      ~                   -      ~                   -      #define ABCDE		1-      #define ABCDEF		1-      #define ABCDEFG		1-      #define ABCDEFGH	1-      #define MSG_MODE_FILE			1-      #define MSG_MODE_CONSOLE		2-      #define MSG_MODE_FILE_AND_CONSOLE	3-      #define MSG_MODE_FILE_THEN_CONSOLE	4-      -      Test 4: set linebreak list listchars and concealing-      #define ABCDE>-->---1                   -      #define >CDEF>-->---1                   -      #define >CDEFG>->---1                   -      #define >CDEFGH>----1                   -      #define >_FILE>--------->--->---1       -      #define >_CONSOLE>---------->---2       -      #define >_FILE_AND_CONSOLE>---------3   -      bbeeeeee		;	some text-      -      Test 5: set linebreak list listchars and concealing part2-      eeeeee>--->-;>some text                 -      Test 6: Screenattributes for comment-       /*		 and some more */-      ScreenAttributes for test6:-      Attribut 0 and 1 and 3 and 5 are different!-      Test 8: set linebreak with visual block mode and v_b_A and selection=exclusive and multibyte char-      long line: foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar TARGET��x' at end+  -- TODO update with new neovim system to check attributes+  -- or remove it if done somewhere else+  -- it(""screenattributes for comment"", function()",If i am not completly mistaken that is part of the new style Vim test test_listlbr_utf8.vim. I thought those are not converted?,X
886074,teto,https://api.github.com/repos/neovim/neovim/pulls/6162,103678766,2017-03-01T13:06:52Z,runtime/doc/msgpack_rpc.txt,"@@ -413,5 +417,30 @@ of update. [""popupmenu_hide""] 	The popupmenu is hidden. +[""cmdline_enter""]+	Enter the cmdline.++[""cmdline_leave""]+	Leave the cmdline.++[""cmdline_firstc"", firstc]+        The first character of the command, which could be : / ? etc. With+	the firstc, you know wheither it's a command or a search.+","Can't this be deduced from [""cmdline"", content, pos] as well ? or given as a parameter of `[""cmdline"", content, pos,submode={search/reverse-search/...}]`. In fact all the events could be merged into that single one.",X
112971,jamessan,https://api.github.com/repos/neovim/neovim/pulls/6195,103930866,2017-03-02T14:09:16Z,src/nvim/terminal.c,"@@ -619,6 +619,21 @@ static void buf_set_term_title(buf_T *buf, char *title)                &err); } +// Get the associated buffer for the terminal and return whether it's in a+// valid state to be used+static bool term_buf_valid(Terminal *term, buf_T **buf)+  FUNC_ATTR_NONNULL_ALL+{+  *buf = handle_get_buffer(term->buf_handle);+  bool valid = buf_valid(*buf);+  if (!valid) {+    // Destroyed by `close_buffer`. Do not do anything else.","It already does, through the call to `terminal_close()`.```cvoid close_buffer(win_T *win, buf_T *buf, int action, int abort_if_last){...  if (buf->terminal) {    terminal_close(buf->terminal, NULL);  }...}``````cvoid terminal_close(Terminal *term, char *msg){  if (term->closed) {    return;  }  term->forward_mouse = false;  term->closed = true;  buf_T *buf = handle_get_buffer(term->buf_handle);  if (!msg || exiting) {    // If no msg was given, this was called by close_buffer(buffer.c).  Or if    // exiting, we must inform the buffer the terminal no longer exists so that    // close_buffer() doesn't call this again.    term->buf_handle = 0;    if (buf) {      buf->terminal = NULL;    }...}```That comment may not be relevant anymore after e897ccad, so this could possibly be simplified to just```c*buf = handle_get_buffer(term->buf_handle);return buf_valid(*buf);```",X
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/6207,104208084,2017-03-03T17:58:53Z,test/functional/fixtures/readfile.txt,"@@ -0,0 +1,4 @@+a+++	a","Usually we use `helpers.write_file()` to create temporary files for tests (then clean them up in `after_each`), if the file is small enough. It helps test readability. Is there a reason that wouldn't work for this?",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/6162,104283700,2017-03-04T08:56:36Z,runtime/doc/msgpack_rpc.txt,"@@ -413,5 +417,30 @@ of update. [""popupmenu_hide""] 	The popupmenu is hidden. +[""cmdline_enter""]+	Enter the cmdline.++[""cmdline_leave""]+	Leave the cmdline.","I would argue they are not synonymous. If we get `mode_change` to support cmdline, it should indicate cmdline regardless of `cmdline_external`.  However these events are emitted only when `cmdline_external`, and the ui thus should draw the cmdline, though they should be called `show` and `hide` in consistency with popupmenu. ",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/6207,104324964,2017-03-05T21:28:26Z,test/functional/normal/fold_spec.lua,"@@ -44,4 +47,114 @@ describe('Folds', function()     8     9]])   end)+  it('updates correctly on :read', function()+    -- luacheck: ignore","Since this is becoming more common, let's make it granular (I think this wasn't supported in older version of luacheck, but it is now in the version we use). warning 621 is ""inconsistent indentation"", we can ignore it like this:    -- luacheck: ignore 621Full list of warnings: http://luacheck.readthedocs.io/en/stable/warnings.html",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/6221,104325538,2017-03-05T21:51:15Z,src/nvim/mark.c,"@@ -887,6 +887,18 @@ void ex_changes(exarg_T *eap)  */ void mark_adjust(linenr_T line1, linenr_T line2, long amount, long amount_after) {+  mark_adjust_internal(line1, line2, amount, amount_after, true);+}++void mark_adjust_nofold(linenr_T line1, linenr_T line2, long amount,","The doc for `mark_adjust` mentions:> Must be called before changed_*(), appended_lines() or deleted_lines().and it's a common pattern throughout the code. So the fact that `mark_adjust_nofold` _doesn't_ work like that could be surprising/confusing. To start with, the doc for `mark_adjust_nofold` should emphasize this situation, and I guess also mention the relationship to `foldSwapRange()`.",
4070620,hardenedapple,https://api.github.com/repos/neovim/neovim/pulls/6221,104358690,2017-03-06T07:59:54Z,src/nvim/ex_cmds.c,"@@ -801,21 +793,24 @@ int do_move(linenr_T line1, linenr_T line2, linenr_T dest)    * their final destination at the new text position -- webb    */   last_line = curbuf->b_ml.ml_line_count;-  mark_adjust(line1, line2, last_line - line2, 0L);-  changed_lines(last_line - num_lines + 1, 0, last_line + 1, num_lines);+  mark_adjust_nofold(line1, line2, last_line - line2, 0L);   if (dest >= line2) {-    mark_adjust(line2 + 1, dest, -num_lines, 0L);+    mark_adjust_nofold(line2 + 1, dest, -num_lines, 0L);+    foldSwapRange(&curwin->w_folds,+        line1, line2,+        dest + 1, dest + num_lines);     curbuf->b_op_start.lnum = dest - num_lines + 1;     curbuf->b_op_end.lnum = dest;   } else {-    mark_adjust(dest + 1, line1 - 1, num_lines, 0L);+    mark_adjust_nofold(dest + 1, line1 - 1, num_lines, 0L);+    foldSwapRange(&curwin->w_folds, dest + 1, line1 - 1,+        line1, line2);     curbuf->b_op_start.lnum = dest + 1;     curbuf->b_op_end.lnum = dest + num_lines;   }   curbuf->b_op_start.col = curbuf->b_op_end.col = 0;-  mark_adjust(last_line - num_lines + 1, last_line,+  mark_adjust_nofold(last_line - num_lines + 1, last_line,       -(last_line - dest - extra), 0L);-  changed_lines(last_line - num_lines + 1, 0, last_line + 1, -extra);","`changed_lines()` is needed after `mark_adjust_nofold()` -- it's called at the end of the `do_move()` function.This is similar to what happened originally (before the previous fix was done).Before, `mark_adjust()` was used to move marks around bit-by-bit, to get them in the correct place (because it's not a simple move everything down/up), then the extra lines from the initial copy were deleted, and `changed_lines()` was called.Now I've replaced `mark_adjust()` with `mark_adjust_nofolds()`, and dealt with the folds independently.This call to `changed_lines()` is a later addition that fixed part of the problem [see here](https://groups.google.com/forum/#!msg/vim_dev/5SD5E_hyGPk/-ojYGyeNbwYJ).The single call to `foldSwapRange()` puts the folds in the correct place (assuming no bugs ...) where it is in this paragraph doesn't actually matter, as nothing else in the block modifies or uses the fold positions. I put it in the existing `if/else` because I needed an `if/else` condition on the boolean that was already there.It may not be clear in the code, but the gist of what I've done is to completely separate the updating of the marks and folds.If you imagine three layers -- the text, the marks, and the folds -- then `mark_adjust()` moves both the marks and folds down/up at once, while `mark_adjust_nofold()` just moves marks and `foldSwapRange()` just swaps folds.As long as each layer lines up correctly in the end the order they're called doesn't matter, and you can call them as many times as you want.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/6019,104408669,2017-03-06T13:06:26Z,test/functional/api/buffer_spec.lua,"@@ -64,6 +67,28 @@ describe('api/buf', function()       curbuf_depr('set_line', 0, 'ab\0cd')       eq('ab\0cd', curbuf_depr('get_line', 0))     end)++    it(""set_line on alternate buffer doesn't give Vim error E315"", function()+      execute('set hidden')+      helpers.source([[+      function! SetLines()+        call nvim_buf_set_lines(1, 0, 1, v:false, ['test'])+      endfunction","Let's move this test to the      describe('{get,set}_lines', function()group. Currently it's in the ""deprecated"" section (old API)",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/6019,104422127,2017-03-06T14:15:51Z,test/functional/api/buffer_spec.lua,"@@ -64,6 +67,28 @@ describe('api/buf', function()       curbuf_depr('set_line', 0, 'ab\0cd')       eq('ab\0cd', curbuf_depr('get_line', 0))     end)++    it(""set_line on alternate buffer doesn't give Vim error E315"", function()+      execute('set hidden')+      helpers.source([[+      function! SetLines()+        call nvim_buf_set_lines(1, 0, 1, v:false, ['test'])+      endfunction","@hardenedapple Oh, because you're using `exc_exec` I guess. That's fine, let's just move it out of the deprecated group though.",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/6222,104453899,2017-03-06T16:18:09Z,src/nvim/strings.c,"@@ -588,18 +589,30 @@ static varnumber_T tv_nr(typval_T *tvs, int *idxp) ///                  value. /// @param[in,out]  idxp  Index in a list. Will be incremented. ///+/// @param[out]  tofree If ""tofree"" is NULL get_tv_string_chk() is used. Some+///                     types (e.g. List) are not converted to a string. If+///                     ""tofree"" is not NULL encode_tv2echo() is used. All+///                     types are converted to a string with the same format as+///                     "":echo"". The caller must free ""*tofree"".+/// /// @return String value or NULL in case of error.-static char *tv_str(typval_T *tvs, int *idxp)-  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT+static char *tv_str(typval_T *tvs, int *idxp, char_u **tofree)+  FUNC_ATTR_NONNULL_ARG(1) FUNC_ATTR_NONNULL_ARG(2)+  FUNC_ATTR_WARN_UNUSED_RESULT {   int idx = *idxp - 1;-  char        *s = NULL;+  char *s = NULL;    if (tvs[idx].v_type == VAR_UNKNOWN) {     EMSG(_(e_printf));   } else {     (*idxp)++;-    s = (char *)get_tv_string_chk(&tvs[idx]);+    if (tofree != NULL) {","Actually, not overengineering: Vim treats `%p` format specifier badly and I altered that in #6095. So Vim makes use of that extra argument being NULL (though its behaviour can hardly be considered useful), Neovim does not.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/6225,104509406,2017-03-06T20:05:53Z,test/unit/message_spec.lua,"@@ -0,0 +1,59 @@+local helpers = require(""test.unit.helpers"")++local ffi = helpers.ffi+local eq = helpers.eq+local to_cstr = helpers.to_cstr++local message = helpers.cimport('./src/nvim/message.h', './src/nvim/memory.h',+                                './src/nvim/strings.h')","consider renaming this to `cimported` (we do this in some other tests). I think long ago cimport() didn't support multiple arguments or something, but anyways `message.xmalloc()` looks a bit weird, `cimported.xmalloc()` is a reasonable pattern.",
886074,teto,https://api.github.com/repos/neovim/neovim/pulls/6168,104561858,2017-03-07T00:35:47Z,test/functional/ui/wildmode_spec.lua,"@@ -64,3 +65,77 @@ describe('command line completion', function()     ]])   end) end)++describe('External command line completion', function()+  local screen+  local items, selected++  before_each(function()+    clear()+    screen = Screen.new(25, 5)+    screen:attach({rgb=true, wildmenu_external=true})+    screen:set_on_event_handler(function(name, data)+      if name == ""wildmenu"" then+        items = data+      elseif name == ""wildmenu_select"" then+        selected = data[1]+      elseif name == ""wildmenu_hide"" then+        items = nil+      end+    end)","The wildmenu events may be best handled in screen.lua via functions Screen:_handle_wildmenu_select/Screen:_handle_wildmenu_hide etc as otherwise, any wildmenu events in other tests will make the test fail (as there will be no handler for the event).",
10180857,nhooyr,https://api.github.com/repos/neovim/neovim/pulls/5169,105065062,2017-03-09T01:01:57Z,runtime/ftplugin/qf.vim,"@@ -14,3 +14,12 @@ let b:undo_ftplugin = ""set stl<""  "" Display the command that produced the list in the quickfix window: setlocal stl=%t%{exists('w:quickfix_title')?\ '\ '.w:quickfix_title\ :\ ''}\ %=%-15(%l,%c%V%)\ %P++autocmd Syntax <buffer>","What happens if I open a help window, open the location list. then switch to a man buffer. Will this autocmd still run and will the syntax change from `'help'` to `'man'`?I'm not sure because you have `silent %delete _` in the command that is run, so I think the location list window is reused. And if so, then the syntax would be `'help'` and so the if statement would evaluate to false.I don't have a laptop for a while, so I can't test this.",
10180857,nhooyr,https://api.github.com/repos/neovim/neovim/pulls/5169,105065774,2017-03-09T01:07:08Z,runtime/ftplugin/help.vim,"@@ -18,5 +18,67 @@ if has(""conceal"")   setlocal cole=2 cocu=nc endif +function! s:create_toc() abort+  if !exists('b:help_toc')+    let b:help_toc = []+    let lnum = 2+    let last_line = line('$') - 1+    let last_added = 0+    let has_section = 0+    let has_sub_section = 0++    while lnum <= last_line+      let level = 0+      let add_text = ''+      let text = getline(lnum)++      if text =~# '^=\+$' && lnum + 1 < last_line+        "" A de-factor section heading.  Other headings are inferred.+        let has_section = 1+        let has_sub_section = 0+        let lnum = nextnonblank(lnum + 1)+        let text = getline(lnum)+        let add_text = text+        while add_text =~# '\*[^*]\+\*\s*$'+          let add_text = matchstr(add_text, '.*\ze\*[^*]\+\*\s*$')+        endwhile+      elseif text =~# '^[A-Z0-9][-A-ZA-Z0-9 .][-A-Z0-9 .():]*\%([ \t]\+\*.\+\*\)\?$'+        "" Any line that's yelling is important.+        let has_sub_section = 1+        let level = has_section+        let add_text = matchstr(text, '.\{-}\ze\s*\%([ \t]\+\*.\+\*\)\?$')+      elseif text =~# '\~$'+            \ && matchstr(text, '^\s*\zs.\{-}\ze\s*\~$') !~# '\t\|\s\{2,}'+            \ && getline(lnum - 1) =~# '^\s*<\?$\|^\s*\*.*\*$'+            \ && getline(lnum + 1) =~# '^\s*>\?$\|^\s*\*.*\*$'+        "" These lines could be headers or code examples.  We only want the+        "" ones that have subsequent lines at the same indent or more.+        let l = nextnonblank(lnum + 1)+        if getline(l) =~# '\*[^*]\+\*$'+          "" Ignore tag lines+          let l = nextnonblank(l + 1)+        endif++        if indent(lnum) <= indent(l)+          let level = has_section + has_sub_section+          let add_text = matchstr(text, '\S.*')+        endif+      endif++      let add_text = substitute(add_text, '\s\+$', '', 'g')+      if !empty(add_text) && last_added != lnum+        let last_added = lnum+        call add(b:help_toc, {'bufnr': bufnr('%'), 'lnum': lnum,+              \ 'text': repeat('  ', level) . add_text})+      endif+      let lnum += 1+    endwhile+  endif++  call setloclist(0, b:help_toc, ' ', 'Help TOC')",Is it documented that the fourth argument to `setloclist` sets the title?http://vimdoc.sourceforge.net/htmldoc/eval.html#setqflist()Doesn't mention it.,
111942,tweekmonster,https://api.github.com/repos/neovim/neovim/pulls/5169,105067102,2017-03-09T01:17:37Z,runtime/ftplugin/qf.vim,"@@ -14,3 +14,12 @@ let b:undo_ftplugin = ""set stl<""  "" Display the command that produced the list in the quickfix window: setlocal stl=%t%{exists('w:quickfix_title')?\ '\ '.w:quickfix_title\ :\ ''}\ %=%-15(%l,%c%V%)\ %P++autocmd Syntax <buffer>","When the location list is updated, the window is reused, but the buffer isn't.  `filetype` gets set again and it starts over.",X
111942,tweekmonster,https://api.github.com/repos/neovim/neovim/pulls/5169,105067805,2017-03-09T01:23:13Z,runtime/ftplugin/help.vim,"@@ -18,5 +18,67 @@ if has(""conceal"")   setlocal cole=2 cocu=nc endif +function! s:create_toc() abort+  if !exists('b:help_toc')+    let b:help_toc = []+    let lnum = 2+    let last_line = line('$') - 1+    let last_added = 0+    let has_section = 0+    let has_sub_section = 0++    while lnum <= last_line+      let level = 0+      let add_text = ''+      let text = getline(lnum)++      if text =~# '^=\+$' && lnum + 1 < last_line+        "" A de-factor section heading.  Other headings are inferred.+        let has_section = 1+        let has_sub_section = 0+        let lnum = nextnonblank(lnum + 1)+        let text = getline(lnum)+        let add_text = text+        while add_text =~# '\*[^*]\+\*\s*$'+          let add_text = matchstr(add_text, '.*\ze\*[^*]\+\*\s*$')+        endwhile+      elseif text =~# '^[A-Z0-9][-A-ZA-Z0-9 .][-A-Z0-9 .():]*\%([ \t]\+\*.\+\*\)\?$'+        "" Any line that's yelling is important.+        let has_sub_section = 1+        let level = has_section+        let add_text = matchstr(text, '.\{-}\ze\s*\%([ \t]\+\*.\+\*\)\?$')+      elseif text =~# '\~$'+            \ && matchstr(text, '^\s*\zs.\{-}\ze\s*\~$') !~# '\t\|\s\{2,}'+            \ && getline(lnum - 1) =~# '^\s*<\?$\|^\s*\*.*\*$'+            \ && getline(lnum + 1) =~# '^\s*>\?$\|^\s*\*.*\*$'+        "" These lines could be headers or code examples.  We only want the+        "" ones that have subsequent lines at the same indent or more.+        let l = nextnonblank(lnum + 1)+        if getline(l) =~# '\*[^*]\+\*$'+          "" Ignore tag lines+          let l = nextnonblank(l + 1)+        endif++        if indent(lnum) <= indent(l)+          let level = has_section + has_sub_section+          let add_text = matchstr(text, '\S.*')+        endif+      endif++      let add_text = substitute(add_text, '\s\+$', '', 'g')+      if !empty(add_text) && last_added != lnum+        let last_added = lnum+        call add(b:help_toc, {'bufnr': bufnr('%'), 'lnum': lnum,+              \ 'text': repeat('  ', level) . add_text})+      endif+      let lnum += 1+    endwhile+  endif++  call setloclist(0, b:help_toc, ' ', 'Help TOC')","Based on what was in the docs at the time this was originally worked on: https://github.com/neovim/neovim/blob/v0.1.7/runtime/doc/eval.txt#L6135-L6187Must've been updated to match Vim's.  It apparently still works, though.  I'll update it anyways.",
111942,tweekmonster,https://api.github.com/repos/neovim/neovim/pulls/5169,105071916,2017-03-09T01:58:11Z,runtime/ftplugin/qf.vim,"@@ -14,3 +14,12 @@ let b:undo_ftplugin = ""set stl<""  "" Display the command that produced the list in the quickfix window: setlocal stl=%t%{exists('w:quickfix_title')?\ '\ '.w:quickfix_title\ :\ ''}\ %=%-15(%l,%c%V%)\ %P++autocmd Syntax <buffer>",The original lines set by Vim.  It felt cleaner than using syntax and conceal.  I secretly hate the way the location list renders.,
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/5986,105305033,2017-03-10T00:25:49Z,src/nvim/os/fs.c,"@@ -391,6 +391,37 @@ int os_open(const char* path, int flags, int mode)   return r; } +/// Set a file to close on exec.+//+// @return -1 if failed to set, 0 otherwise.+int os_set_cloexec(const int fd)+{+#ifdef HAVE_FD_CLOEXEC+  int e;+  int fdflags = fcntl(fd, F_GETFD);+  if (fdflags < 0) {+    e = errno;+    ELOG(""Failed to get flags on descriptor %d: %s"", fd, strerror(errno));","Macro `ELOG()` only replaces this line with  `do_log()` and  adds some more parameters.So this should work with `errno` instead of `e`, because no other function is called before `strerror()`.",X
4070620,hardenedapple,https://api.github.com/repos/neovim/neovim/pulls/5986,105365816,2017-03-10T10:04:44Z,src/nvim/os/fs.c,"@@ -391,6 +391,37 @@ int os_open(const char* path, int flags, int mode)   return r; } +/// Set a file to close on exec.+//+// @return -1 if failed to set, 0 otherwise.+int os_set_cloexec(const int fd)+{+#ifdef HAVE_FD_CLOEXEC+  int e;+  int fdflags = fcntl(fd, F_GETFD);+  if (fdflags < 0) {+    e = errno;+    ELOG(""Failed to get flags on descriptor %d: %s"", fd, strerror(errno));","Can I just double check I understand -- (I think I do, but asking for clarification seems like it may save some time if I'm wrong).Were you originally saying that hypothetically, if the `ELOG` macro could set `errno`, then we would have to use `e` in the call to `strerror()`. Then in the second comment saying that since it doesn't, we're fine as we are.Or were you working on the thought that I was using the temporary variable to ensure the errno passed to `strerror()` was correct, and pointing out that that wasn't ensured by what I've done.I think you meant the former, but that may be because I'm coloured by knowing what I intended.What I intended to ensure here, was that whether or not `strerror()` changes `errno`, the `errno` set when `os_set_cloexec()` returns is the `errno` that relates to the `fcntl()` call (in case any user wants to use it).While checking just now if it's possible that `strerror()` changes `errno`, I noticed that in [posix 2004](http://pubs.opengroup.org/onlinepubs/009695399/,) the return value of `strerror()` when an error occurs isn't specified, so it could be `NULL`. I'll add a check for that.",X
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/5986,105374480,2017-03-10T10:55:57Z,src/nvim/os/fs.c,"@@ -391,6 +391,37 @@ int os_open(const char* path, int flags, int mode)   return r; } +/// Set a file to close on exec.+//+// @return -1 if failed to set, 0 otherwise.+int os_set_cloexec(const int fd)+{+#ifdef HAVE_FD_CLOEXEC+  int e;+  int fdflags = fcntl(fd, F_GETFD);+  if (fdflags < 0) {+    e = errno;+    ELOG(""Failed to get flags on descriptor %d: %s"", fd, strerror(errno));","> Were you originally saying that hypothetically, if the ELOG macro could set errno, then we would have to use e in the call to strerror(). Then in the second comment saying that since it doesn't, we're fine as we are.Yes, my concern was about the other parameters to `do_log()` that could change `errno`.> While checking just now if it's possible that strerror() changes errno, I noticed that in posix 2004 the return value of strerror() when an error occurs isn't specified, so it could be NULL. I'll add a check for that.Linux man page says C99 and POSIX.1-2008 require the return value of `strerror()` to be non-NULL. ",X
842846,tarruda,https://api.github.com/repos/neovim/neovim/pulls/6247,105386427,2017-03-10T12:21:42Z,src/nvim/os/input.c,"@@ -323,13 +325,25 @@ static unsigned int handle_mouse_event(char **ptr, uint8_t *buf,   return bufsize; } +bool input_blocking(void)+{+  return blocking;+}+ static bool input_poll(int ms) {   if (do_profiling == PROF_YES && ms) {     prof_inchar_enter();   } +  if ((ms == - 1 || ms > 0)+      && !(events_enabled || input_ready() || input_eof)","Because it has been quite some time since I've maintained this code, I'm not sure what are the implications of adding this `multiqueue_process_events()` call, but consider that `input_poll` is called no matter what state nvim is in, so it may not be safe to process events.In any case, this condition is the same as `(ms == - 1 || ms > 0) && !events_enabled && !input_ready() && !input_eof`, but `input_ready()` cannot be true for this function to be called(See `input_poll` below), so it could be simplified to `(ms == - 1 || ms > 0) && !events_enabled && !input_eof`",X
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/6247,105388489,2017-03-10T12:37:53Z,src/nvim/rbuffer.c,"@@ -34,17 +34,20 @@ void rbuffer_free(RBuffer *buf)   xfree(buf); } -size_t rbuffer_size(RBuffer *buf) FUNC_ATTR_NONNULL_ALL+size_t rbuffer_size(RBuffer *buf)+  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_PURE {   return buf->size; } -size_t rbuffer_capacity(RBuffer *buf) FUNC_ATTR_NONNULL_ALL+size_t rbuffer_capacity(RBuffer *buf)+  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_PURE {   return (size_t)(buf->end_ptr - buf->start_ptr); } -size_t rbuffer_space(RBuffer *buf) FUNC_ATTR_NONNULL_ALL+size_t rbuffer_space(RBuffer *buf)+  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_PURE","Thanks for mentioning that. I didn't know that pure is not allowed to be used if the parameter is used by multiple threads, that makes it extremely difficult to ever know if a function can safely be marked pure. @ZyX-I can you confirm?",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/6195,105513269,2017-03-10T23:57:58Z,test/functional/terminal/ex_terminal_spec.lua,"@@ -48,6 +49,39 @@ describe(':terminal', function()     eq(2, eval(""line('.')""))  -- cursor stays where we put it   end) +  it('does not crash when callback fires after terminal closes', function()+    screen:detach()+    screen = thelpers.screen_setup(0, '[""'..helpers.nvim_prog..'"", ""-u"", ""NONE"", ""-i"", ""NONE"", ""-N""]')+    thelpers.feed_data({':let g:split = 0',+                        ':au TermOpen * nnoremap <buffer> x :q<CR>',+                        ':nnoremap <silent> x :new <bar> let g:split += 1 <bar> call termopen([&shell])<CR>',+                        ':set updatetime=0',+                        ''})+    screen:expect([[+      {1: }                                                 |+      {4:~                                                 }|+      {4:~                                                 }|+      {4:~                                                 }|+      {5:[No Name]                                         }|+      :set updatetime=0                                 |+      {3:-- TERMINAL --}                                    |+    ]])+    local count = 500+    for _ = 1,count do+      thelpers.feed_data('xx')+      wait()+    end+    thelpers.feed_data({':echo g:split', ''})+    screen:expect([[+      {1: }                                                 |+      {4:~                                                 }|+      {4:~                                                 }|+      {4:~                                                 }|+      {5:[No Name]                                         }|+      ]]..tostring(count)..string.rep(' ', 50 - string.len(tostring(count)))..[[|+      {3:-- TERMINAL --}                                    |","We mostly just want to give ASAN a chance. So maybe 10 iterations instead of 500 is good enough.All of the screen redraws will cause screen:expect() to be really slow, and cause too many ""indetermistic"" screen states. Some of the envs on travis are choking. We only really care about waiting for the child nvim to process the data, so perhaps try screen:expect() with the ""any"" parameter:    screen:expect(tostring(count)..string.rep(' ', 50 - string.len(tostring(count))),       nil, nil, nil, true)",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/6195,105513458,2017-03-10T23:59:23Z,src/nvim/terminal.c,"@@ -639,6 +639,15 @@ static void buf_set_term_title(buf_T *buf, char *title)                &err); } +// Get the associated buffer for the terminal and return whether it's in a+// valid state to be used+static bool term_buf_valid(Terminal *term, buf_T **buf)+  FUNC_ATTR_NONNULL_ALL+{+  *buf = handle_get_buffer(term->buf_handle);+  return buf_valid(*buf);","perhaps return NULL in the false case, or `buf` in the true case. Then we don't need the `**buf` parameter.",X
112971,jamessan,https://api.github.com/repos/neovim/neovim/pulls/6195,105519929,2017-03-11T01:20:32Z,test/functional/terminal/ex_terminal_spec.lua,"@@ -48,6 +49,39 @@ describe(':terminal', function()     eq(2, eval(""line('.')""))  -- cursor stays where we put it   end) +  it('does not crash when callback fires after terminal closes', function()+    screen:detach()+    screen = thelpers.screen_setup(0, '[""'..helpers.nvim_prog..'"", ""-u"", ""NONE"", ""-i"", ""NONE"", ""-N""]')+    thelpers.feed_data({':let g:split = 0',+                        ':au TermOpen * nnoremap <buffer> x :q<CR>',+                        ':nnoremap <silent> x :new <bar> let g:split += 1 <bar> call termopen([&shell])<CR>',+                        ':set updatetime=0',+                        ''})+    screen:expect([[+      {1: }                                                 |+      {4:~                                                 }|+      {4:~                                                 }|+      {4:~                                                 }|+      {5:[No Name]                                         }|+      :set updatetime=0                                 |+      {3:-- TERMINAL --}                                    |+    ]])+    local count = 500+    for _ = 1,count do+      thelpers.feed_data('xx')+      wait()+    end+    thelpers.feed_data({':echo g:split', ''})+    screen:expect([[+      {1: }                                                 |+      {4:~                                                 }|+      {4:~                                                 }|+      {4:~                                                 }|+      {5:[No Name]                                         }|+      ]]..tostring(count)..string.rep(' ', 50 - string.len(tostring(count)))..[[|+      {3:-- TERMINAL --}                                    |","> We mostly just want to give ASAN a chance. So maybe 10 iterations instead of 500 is good enough.The conditions where it happens seem to be when there's a backlog of input being processed, so the queue is running faster than the terminal/shell can startup and teardown.  When I manually reproduce it, I stop pressing the x and nvim keeps chugging along for a few more seconds starting/killing terminals before it crashes.If there's a better way to simulate that stress to increases the chances of hitting the problem, I'm all ears.  If we're not that concerned with exactly hitting it and just want some coverage, then I'm also fine with lowering the counts and simplifying the logic.",
111942,tweekmonster,https://api.github.com/repos/neovim/neovim/pulls/5169,105533335,2017-03-11T13:32:02Z,runtime/ftplugin/qf_toc.vim,"@@ -0,0 +1,23 @@+function! s:setup_toc() abort",It's how `ftplugin.vim` loads them:```vimexe 'runtime! ftplugin/' . name . '.vim ftplugin/' . name . '_*.vim ftplugin/' . name . '/*.vim'```I did this for `help` and `qf` because I was adding substantial code and not completely rewriting them.  It just felt right.  I can put it back if you're not into it.,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/5169,105533719,2017-03-11T13:52:52Z,runtime/ftplugin/help_toc.vim,"@@ -0,0 +1,66 @@+if !exists('g:no_plugin_maps')+  function! s:show_toc() abort+    if !exists('b:qf_toc')","Can we inspect the location list instead of storing stuff in a `b:` variable? If the location list doesn't contain a TOC, just re-compute it.",X
111942,tweekmonster,https://api.github.com/repos/neovim/neovim/pulls/5169,105534670,2017-03-11T14:51:50Z,runtime/ftplugin/help_toc.vim,"@@ -0,0 +1,66 @@+if !exists('g:no_plugin_maps')+  function! s:show_toc() abort+    if !exists('b:qf_toc')","I'm open to this, but how would I know that the location list is the TOC for *this* help file without recomputing to make the comparison?  I assume getting the first location list item's `bufnr`, but I don't like that since quickfix is an unreliable source for state information.",X
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/6264,105562974,2017-03-12T17:12:38Z,src/nvim/option.c,"@@ -1490,7 +1490,7 @@ do_set (               new_value_alloced = true;               if (newval == NULL) {                 newval = empty_option;-              } else if (!(options[opt_idx].flags | P_NO_DEF_EXP)) {+              } else if (!(options[opt_idx].flags & P_NO_DEF_EXP)) {","? This does not look like there is anything wrong. Except that fix is probably testable and it looks like the current code should break test like https://github.com/ZyX-I/neovim/blob/f743b1b3cc951c27adea402227380d5b27d466de/test/functional/options/defaults_spec.lua#L222, but for options which both have something to expand in default value and no `P_NO_DEF_EXP` flag. E.g. `&helpfile`: this combination is rather uncommon and I failed to find other option which need default value expansion.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/5169,105576986,2017-03-13T01:39:09Z,runtime/ftplugin/help_toc.vim,"@@ -0,0 +1,66 @@+if !exists('g:no_plugin_maps')+  function! s:show_toc() abort+    if !exists('b:qf_toc')","Can the qf title be used? > I assume getting the first location list item's bufnr, but I don't like that since quickfix is an unreliable source for state information.That sounds good too. Unreliable because the user could edit it? The worst that happens is the TOC is recalculated, so the stakes are low...",
111942,tweekmonster,https://api.github.com/repos/neovim/neovim/pulls/5169,105587268,2017-03-13T04:04:59Z,runtime/ftplugin/help_toc.vim,"@@ -0,0 +1,66 @@+if !exists('g:no_plugin_maps')+  function! s:show_toc() abort+    if !exists('b:qf_toc')","> Can the qf title be used?I guess `bufname()` could be attached to it, but that can be a little long and not exactly informative (in a useful way) since man and help should only have one window, and therefore one TOC.Since the method now is to open the TOC when the key is pressed, I could just set a variable in the quickfix buffer that has the help/man's filename in it to track this.> Unreliable because the user could edit it?No.  A bit of a rant that's not directly related to this PR: It's just unreliable as a source of information regarding its relationship to another window.  Quickfix is meant to be programmatically filled, but setting the list is a one-way deal that strips away unknown dict keys that could've been used by a script to manage the list.  State info can't be attached until the quickfix window is opened, so, you can't just set the list then wait until the user has displayed it to script it further.Also, the addition of the `{what}` argument to the quickfix functions is half-assed.> The worst that happens is the TOC is recalculatedThe worst case is bad UX.  I wanted to avoid the recalculation because it can be slow, and it also resets the quickfix selection index.  A `<M-]>` when the TOC is already opened for the current file should just move the cursor back to the TOC for browsing/searching.",X
90633,vheon,https://api.github.com/repos/neovim/neovim/pulls/6257,105653147,2017-03-13T12:57:59Z,contrib/YouCompleteMe/ycm_extra_conf.py,"@@ -9,47 +9,57 @@ def DirectoryOfThisScript():  def GetDatabase():     compilation_database_folder = os.path.join(DirectoryOfThisScript(),-                                               '..', 'build')+                                               'build')     if os.path.exists(compilation_database_folder):         return ycm_core.CompilationDatabase(compilation_database_folder)     return None  -def IsHeaderFile(filename):-    extension = os.path.splitext(filename)[1]-    return extension == '.h'-- def GetCompilationInfoForFile(filename):     database = GetDatabase()     if not database:         return None-    if IsHeaderFile(filename):-        basename = os.path.splitext(filename)[0]-        c_file = basename + '.c'-        # for pure headers (no c file), default to main.c-        if not os.path.exists(c_file):-            c_file = os.path.join(DirectoryOfThisScript(), 'nvim', 'main.c')-        if os.path.exists(c_file):-            compilation_info = database.GetCompilationInfoForFile(c_file)-            if compilation_info.compiler_flags_:-                return compilation_info-        return None     return database.GetCompilationInfoForFile(filename)  +# It seems YCM does not resolve directories correctly. This function will+# adjust paths in the compiler flags to be absolute+def FixDirectories(args, compiler_working_dir):+    def adjust_path(path):+        return os.path.abspath(os.path.join(compiler_working_dir, path))++    adjust_next_arg = False+    new_args = []+    for arg in args:+        if adjust_next_arg:+            arg = adjust_path(arg)+            adjust_next_arg = False+        else:+            for dir_flag in ['-I', '-isystem', '-o', '-c']:+                if arg.startswith(dir_flag):+                    if arg != dir_flag:+                        # flag and path are concatenated in same arg+                        path = arg[len(dir_flag):]+                        new_path = adjust_path(path)+                        arg = '{0}{1}'.format(dir_flag, new_path)+                    else:+                        # path is specified in next argument+                        adjust_next_arg = True+        new_args.append(arg)+    return new_args++ def FlagsForFile(filename):     compilation_info = GetCompilationInfoForFile(filename)     if not compilation_info:         return None     # Add flags not needed for clang-the-binary,     # but needed for libclang-the-library (YCM uses this last one).-    flags = (list(compilation_info.compiler_flags_)-             if compilation_info.compiler_flags_-             else [])+    flags = FixDirectories((list(compilation_info.compiler_flags_)+                            if compilation_info.compiler_flags_+                            else []), compilation_info.compiler_working_dir_)     extra_flags = ['-Wno-newline-eof']-    final_flags = flags + extra_flags     return {-        'flags': final_flags,+        'flags': flags + extra_flags,         'do_cache': True",Note that this is the default and is no longer required :+1:,
40799,docwhat,https://api.github.com/repos/neovim/neovim/pulls/6272,105919230,2017-03-14T14:17:34Z,runtime/doc/eval.txt,"@@ -2041,6 +2041,7 @@ garbagecollect([{atexit}])	none	free memory, breaking cyclic references get({list}, {idx} [, {def}])	any	get item {idx} from {list} or {def} get({dict}, {key} [, {def}])	any	get item {key} from {dict} or {def} get({func}, {what})		any	get property of funcref/partial {func}+get_xdg_home({string})          String  get the XDG Base directory for {string}","XDG _does_ apply to Windows.  See [`stdpaths.c`](https://github.com/neovim/neovim/blob/2a366b674aa572e7cbdef257c5597cf62c9a6f5f/src/nvim/os/stdpaths.c#L30-L49).Though now that I think of it, it should probably be something closer to the `stdpaths_user_conf_subpath()` and it's `_data_` sibling since it outputs the `nvim-data` directory for Windows.I don't like `config_path()` because there is a data and cache directory too.",
111942,tweekmonster,https://api.github.com/repos/neovim/neovim/pulls/6272,105926803,2017-03-14T14:42:20Z,runtime/doc/eval.txt,"@@ -2041,6 +2041,7 @@ garbagecollect([{atexit}])	none	free memory, breaking cyclic references get({list}, {idx} [, {def}])	any	get item {idx} from {list} or {def} get({dict}, {key} [, {def}])	any	get item {key} from {dict} or {def} get({func}, {what})		any	get property of funcref/partial {func}+get_xdg_home({string})          String  get the XDG Base directory for {string}","I'm referring to the characters `xdg`.  On windows it's `%APPDATA%` or `%LOCALAPPDATA%`.  `XDG_DATA_HOME ` could've been `My Documents` on Windows.  The relationship between `XDG_*` and the Windows equivalents are purely a ""best fit"" decided by us.  The point is, `xdg` has no meaning on Windows.> I don't like config_path() because there is a data and cache directory too.That's why I said it was up for debate :-)My view is that it should be something that can be found using intuition.  The keywords `xdg` and `home` don't say ""the place where program configs and data is stored"" to me.",X
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/5266,105952461,2017-03-14T16:08:28Z,src/nvim/lib/kbtree.h,"@@ -0,0 +1,472 @@+/*-+ * Copyright 1997-1999, 2001, John-Mark Gurney.+ *           2008-2009, Attractive Chaos <attractor@live.co.uk>+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions+ * are met:+ *+ * 1. Redistributions of source code must retain the above copyright+ *    notice, this list of conditions and the following disclaimer.+ * 2. Redistributions in binary form must reproduce the above copyright+ *    notice, this list of conditions and the following disclaimer in the+ *    documentation and/or other materials provided with the distribution.+ *+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF+ * SUCH DAMAGE.+ */++#ifndef __AC_KBTREE_H+#define __AC_KBTREE_H++#include <stdlib.h>+#include <string.h>+#include <stdint.h>++#define KB_MAX_DEPTH 64++#define	__KB_KEY(type, x)	(x->key)+#define __KB_PTR(btr, x)	(x->ptr)++#define __KB_TREE_T(name,key_t,T)						\+    typedef struct kbnode_##name##_s kbnode_##name##_t;     \+    struct kbnode_##name##_s {              \+      int32_t n; \+      bool is_internal; \+      key_t key[2*T-1]; \+      kbnode_##name##_t *ptr[]; \+    } ; \+    \+    typedef struct { \+        kbnode_##name##_t *root; \+        int	n_keys, n_nodes; \+    } kbtree_##name##_t; \+    \+    typedef struct { \+        kbnode_##name##_t *x; \+        int i; \+    } kbpos_##name##_t; \+    typedef struct { \+        kbpos_##name##_t stack[KB_MAX_DEPTH], *p; \+    } kbitr_##name##_t; \+++#define __kb_destroy(kbnode_t,b) do {											\+		int i;                                                          \+        unsigned int max = 8;											\+		kbnode_t *x, **top, **stack = 0;								\+		if (b->root) {													\+			top = stack = (kbnode_t**)calloc(max, sizeof(kbnode_t*));	\+			*top++ = (b)->root;											\+			while (top != stack) {										\+				x = *--top;												\+				if (x->is_internal == 0) { free(x); continue; }			\+				for (i = 0; i <= x->n; ++i)								\+					if (__KB_PTR(b, x)[i]) {							\+						if (top - stack == (int)max) {		        	\+							max <<= 1;									\+							stack = (kbnode_t**)realloc(stack, max * sizeof(kbnode_t*)); \+							top = stack + (max>>1);						\+						}												\+						*top++ = __KB_PTR(b, x)[i];						\+					}													\+				free(x);												\+			}															\+		}																\+		free(stack);											\+	} while (0)++#define __KB_GET_AUX1(name, key_t, kbnode_t, __cmp)								\+	static inline int __kb_getp_aux_##name(const kbnode_t * __restrict x, key_t * __restrict k, int *r) \+	{																	\+		int tr, *rr, begin = 0, end = x->n;								\+		if (x->n == 0) return -1;										\+		rr = r? r : &tr;												\+		while (begin < end) {											\+			int mid = (begin + end) >> 1;								\+			if (__cmp(__KB_KEY(key_t, x)[mid], *k) < 0) begin = mid + 1; \+			else end = mid;												\+		}																\+		if (begin == x->n) { *rr = 1; return x->n - 1; }				\+		if ((*rr = __cmp(*k, __KB_KEY(key_t, x)[begin])) < 0) --begin;	\+		return begin;													\+	}++#define __KB_GET(name, key_t, kbnode_t)											\+	static key_t *kb_getp_##name(kbtree_##name##_t *b, key_t * __restrict k) \+	{																	\+		if (!b->root) { \+		    return 0; \+		} \+		int i, r = 0;													\+		kbnode_t *x = b->root;											\+		while (x) {														\+			i = __kb_getp_aux_##name(x, k, &r);							\+			if (i >= 0 && r == 0) return &__KB_KEY(key_t, x)[i];		\+			if (x->is_internal == 0) return 0;							\+			x = __KB_PTR(b, x)[i + 1];									\+		}																\+		return 0;														\+	}																	\+	static inline key_t *kb_get_##name(kbtree_##name##_t *b, key_t k) \+	{																	\+		return kb_getp_##name(b, &k);									\+	}++#define __KB_INTERVAL(name, key_t, kbnode_t)										\+	static void kb_intervalp_##name(kbtree_##name##_t *b, key_t * __restrict k, key_t **lower, key_t **upper)	\+	{																	\+		if (!b->root) { \+		    return; \+		} \+		int i, r = 0;													\+		kbnode_t *x = b->root;											\+		*lower = *upper = 0;											\+		while (x) {														\+			i = __kb_getp_aux_##name(x, k, &r);							\+			if (i >= 0 && r == 0) {										\+				*lower = *upper = &__KB_KEY(key_t, x)[i];				\+				return;													\+			}															\+			if (i >= 0) *lower = &__KB_KEY(key_t, x)[i];				\+			if (i < x->n - 1) *upper = &__KB_KEY(key_t, x)[i + 1];		\+			if (x->is_internal == 0) return;							\+			x = __KB_PTR(b, x)[i + 1];									\+		}																\+	}																	\+	static inline void kb_interval_##name(kbtree_##name##_t *b, key_t k, key_t **lower, key_t **upper) \+	{																	\+		kb_intervalp_##name(b, &k, lower, upper);						\+	}++#define __KB_PUT(name, key_t, kbnode_t, __cmp, T, ILEN)									\+	/* x must be an internal node */									\+	static void __kb_split_##name(kbtree_##name##_t *b, kbnode_t *x, int i, kbnode_t *y) \+	{																	\+		kbnode_t *z;													\+		z = (kbnode_t*)calloc(1, y->is_internal? ILEN : sizeof(kbnode_##name##_t));	\+		++b->n_nodes;													\+		z->is_internal = y->is_internal;								\+		z->n = T - 1;												\+		memcpy(__KB_KEY(key_t, z), __KB_KEY(key_t, y) + T, sizeof(key_t) * (T - 1)); \+		if (y->is_internal) memcpy(__KB_PTR(b, z), __KB_PTR(b, y) + T, sizeof(void*) * T); \+		y->n = T - 1;												\+		memmove(__KB_PTR(b, x) + i + 2, __KB_PTR(b, x) + i + 1, sizeof(void*) * (unsigned int)(x->n - i)); \+		__KB_PTR(b, x)[i + 1] = z;										\+		memmove(__KB_KEY(key_t, x) + i + 1, __KB_KEY(key_t, x) + i, sizeof(key_t) * (unsigned int)(x->n - i)); \+		__KB_KEY(key_t, x)[i] = __KB_KEY(key_t, y)[T - 1];			\+		++x->n;															\+	}																	\+	static key_t *__kb_putp_aux_##name(kbtree_##name##_t *b, kbnode_t *x, key_t * __restrict k) \+	{																	\+		int i = x->n - 1;												\+		key_t *ret;														\+		if (x->is_internal == 0) {										\+			i = __kb_getp_aux_##name(x, k, 0);							\+			if (i != x->n - 1)											\+				memmove(__KB_KEY(key_t, x) + i + 2, __KB_KEY(key_t, x) + i + 1, (unsigned int)(x->n - i - 1) * sizeof(key_t)); \+			ret = &__KB_KEY(key_t, x)[i + 1];							\+			*ret = *k;													\+			++x->n;														\+		} else {														\+			i = __kb_getp_aux_##name(x, k, 0) + 1;						\+			if (__KB_PTR(b, x)[i]->n == 2 * T - 1) {					\+				__kb_split_##name(b, x, i, __KB_PTR(b, x)[i]);			\+				if (__cmp(*k, __KB_KEY(key_t, x)[i]) > 0) ++i;			\+			}															\+			ret = __kb_putp_aux_##name(b, __KB_PTR(b, x)[i], k);		\+		}																\+		return ret; 													\+	}																	\+	static key_t *kb_putp_##name(kbtree_##name##_t *b, key_t * __restrict k) \+	{																	\+		if (!b->root) { \+			b->root = (kbnode_t*)calloc(1, ILEN);						\+			++b->n_nodes;													\+		} \+		kbnode_t *r, *s;												\+		++b->n_keys;													\+		r = b->root;													\+		if (r->n == 2 * T - 1) {										\+			++b->n_nodes;												\+			s = (kbnode_t*)calloc(1, ILEN);							\+			b->root = s; s->is_internal = 1; s->n = 0;					\+			__KB_PTR(b, s)[0] = r;										\+			__kb_split_##name(b, s, 0, r);								\+			r = s;														\+		}																\+		return __kb_putp_aux_##name(b, r, k);							\+	}																	\+	static inline void kb_put_##name(kbtree_##name##_t *b, key_t k) \+	{																	\+		kb_putp_##name(b, &k);											\+	}+++#define __KB_DEL(name, key_t, kbnode_t, T)											\+	static key_t __kb_delp_aux_##name(kbtree_##name##_t *b, kbnode_t *x, key_t * __restrict k, int s) \+	{																	\+		int yn, zn, i, r = 0;											\+		kbnode_t *xp, *y, *z;											\+		key_t kp;														\+		if (x == 0) return *k;											\+		if (s) { /* s can only be 0, 1 or 2 */							\+			r = x->is_internal == 0? 0 : s == 1? 1 : -1;				\+			i = s == 1? x->n - 1 : -1;									\+		} else i = __kb_getp_aux_##name(x, k, &r);						\+		if (x->is_internal == 0) {										\+			if (s == 2) ++i;											\+			kp = __KB_KEY(key_t, x)[i];									\+			memmove(__KB_KEY(key_t, x) + i, __KB_KEY(key_t, x) + i + 1, (unsigned int)(x->n - i - 1) * sizeof(key_t)); \+			--x->n;														\+			return kp;													\+		}																\+		if (r == 0) {													\+			if ((yn = __KB_PTR(b, x)[i]->n) >= T) {					\+				xp = __KB_PTR(b, x)[i];									\+				kp = __KB_KEY(key_t, x)[i];								\+				__KB_KEY(key_t, x)[i] = __kb_delp_aux_##name(b, xp, 0, 1); \+				return kp;												\+			} else if ((zn = __KB_PTR(b, x)[i + 1]->n) >= T) {		\+				xp = __KB_PTR(b, x)[i + 1];								\+				kp = __KB_KEY(key_t, x)[i];								\+				__KB_KEY(key_t, x)[i] = __kb_delp_aux_##name(b, xp, 0, 2); \+				return kp;												\+			} else if (yn == T - 1 && zn == T - 1) {				\+				y = __KB_PTR(b, x)[i]; z = __KB_PTR(b, x)[i + 1];		\+				__KB_KEY(key_t, y)[y->n++] = *k;						\+				memmove(__KB_KEY(key_t, y) + y->n, __KB_KEY(key_t, z), (unsigned int)z->n * sizeof(key_t)); \+				if (y->is_internal) memmove(__KB_PTR(b, y) + y->n, __KB_PTR(b, z), (unsigned int)(z->n + 1) * sizeof(void*)); \+				y->n += z->n;											\+				memmove(__KB_KEY(key_t, x) + i, __KB_KEY(key_t, x) + i + 1, (unsigned int)(x->n - i - 1) * sizeof(key_t)); \+				memmove(__KB_PTR(b, x) + i + 1, __KB_PTR(b, x) + i + 2, (unsigned int)(x->n - i - 1) * sizeof(void*)); \+				--x->n;													\+				free(z);												\+				return __kb_delp_aux_##name(b, y, k, s);				\+			}															\+		}																\+		++i;															\+		if ((xp = __KB_PTR(b, x)[i])->n == T - 1) {					\+			if (i > 0 && (y = __KB_PTR(b, x)[i - 1])->n >= T) {		\+				memmove(__KB_KEY(key_t, xp) + 1, __KB_KEY(key_t, xp), (unsigned int)xp->n * sizeof(key_t)); \+				if (xp->is_internal) memmove(__KB_PTR(b, xp) + 1, __KB_PTR(b, xp), (unsigned int)(xp->n + 1) * sizeof(void*)); \+				__KB_KEY(key_t, xp)[0] = __KB_KEY(key_t, x)[i - 1];		\+				__KB_KEY(key_t, x)[i - 1] = __KB_KEY(key_t, y)[y->n - 1]; \+				if (xp->is_internal) __KB_PTR(b, xp)[0] = __KB_PTR(b, y)[y->n]; \+				--y->n; ++xp->n;										\+			} else if (i < x->n && (y = __KB_PTR(b, x)[i + 1])->n >= T) { \+				__KB_KEY(key_t, xp)[xp->n++] = __KB_KEY(key_t, x)[i];	\+				__KB_KEY(key_t, x)[i] = __KB_KEY(key_t, y)[0];			\+				if (xp->is_internal) __KB_PTR(b, xp)[xp->n] = __KB_PTR(b, y)[0]; \+				--y->n;													\+				memmove(__KB_KEY(key_t, y), __KB_KEY(key_t, y) + 1, (unsigned int)y->n * sizeof(key_t)); \+				if (y->is_internal) memmove(__KB_PTR(b, y), __KB_PTR(b, y) + 1, (unsigned int)(y->n + 1) * sizeof(void*)); \+			} else if (i > 0 && (y = __KB_PTR(b, x)[i - 1])->n == T - 1) { \+				__KB_KEY(key_t, y)[y->n++] = __KB_KEY(key_t, x)[i - 1];	\+				memmove(__KB_KEY(key_t, y) + y->n, __KB_KEY(key_t, xp), (unsigned int)xp->n * sizeof(key_t));	\+				if (y->is_internal) memmove(__KB_PTR(b, y) + y->n, __KB_PTR(b, xp), (unsigned int)(xp->n + 1) * sizeof(void*)); \+				y->n += xp->n;											\+				memmove(__KB_KEY(key_t, x) + i - 1, __KB_KEY(key_t, x) + i, (unsigned int)(x->n - i) * sizeof(key_t)); \+				memmove(__KB_PTR(b, x) + i, __KB_PTR(b, x) + i + 1, (unsigned int)(x->n - i) * sizeof(void*)); \+				--x->n;													\+				free(xp);												\+				xp = y;													\+			} else if (i < x->n && (y = __KB_PTR(b, x)[i + 1])->n == T - 1) { \+				__KB_KEY(key_t, xp)[xp->n++] = __KB_KEY(key_t, x)[i];	\+				memmove(__KB_KEY(key_t, xp) + xp->n, __KB_KEY(key_t, y), (unsigned int)y->n * sizeof(key_t));	\+				if (xp->is_internal) memmove(__KB_PTR(b, xp) + xp->n, __KB_PTR(b, y), (unsigned int)(y->n + 1) * sizeof(void*)); \+				xp->n += y->n;											\+				memmove(__KB_KEY(key_t, x) + i, __KB_KEY(key_t, x) + i + 1, (unsigned int)(x->n - i - 1) * sizeof(key_t)); \+				memmove(__KB_PTR(b, x) + i + 1, __KB_PTR(b, x) + i + 2, (unsigned int)(x->n - i - 1) * sizeof(void*)); \+				--x->n;													\+				free(y);												\+			}															\+		}																\+		return __kb_delp_aux_##name(b, xp, k, s);						\+	}																	\+	static key_t kb_delp_##name(kbtree_##name##_t *b, key_t * __restrict k) \+	{																	\+		kbnode_t *x;													\+		key_t ret;														\+		ret = __kb_delp_aux_##name(b, b->root, k, 0);					\+		--b->n_keys;													\+		if (b->root->n == 0 && b->root->is_internal) {					\+			--b->n_nodes;												\+			x = b->root;												\+			b->root = __KB_PTR(b, x)[0];								\+			free(x);													\+		}																\+		return ret;														\+	}																	\+	static inline key_t kb_del_##name(kbtree_##name##_t *b, key_t k) \+	{																	\+		return kb_delp_##name(b, &k);									\+	}++#define __KB_ITR(name, key_t, kbnode_t) \+	static inline void kb_itr_first_##name(kbtree_##name##_t *b, kbitr_##name##_t *itr) \+	{ \+		itr->p = 0; \+		if (b->n_keys == 0) return; \+		itr->p = itr->stack; \+		itr->p->x = b->root; itr->p->i = 0; \+		while (itr->p->x->is_internal && __KB_PTR(b, itr->p->x)[0] != 0) { \+			kbnode_t *x = itr->p->x; \+			++itr->p; \+			itr->p->x = __KB_PTR(b, x)[0]; itr->p->i = 0; \+		} \+	} \+	static inline int kb_itr_next_##name(kbtree_##name##_t *b, kbitr_##name##_t *itr) \+	{ \+		if (itr->p < itr->stack) return 0; \+		for (;;) { \+			++itr->p->i; \+			while (itr->p->x && itr->p->i <= itr->p->x->n) { \+				itr->p[1].i = 0; \+				itr->p[1].x = itr->p->x->is_internal? __KB_PTR(b, itr->p->x)[itr->p->i] : 0; \+				++itr->p; \+			} \+			--itr->p; \+			if (itr->p < itr->stack) return 0; \+			if (itr->p->x && itr->p->i < itr->p->x->n) return 1; \+		} \+	} \+	static inline int kb_itr_prev_##name(kbtree_##name##_t *b, kbitr_##name##_t *itr) \+	{ \+		if (itr->p < itr->stack) return 0; \+		for (;;) { \+			while (itr->p->x && itr->p->i >= 0) { \+				itr->p[1].x = itr->p->x->is_internal? __KB_PTR(b, itr->p->x)[itr->p->i] : 0; \+				itr->p[1].i = itr->p[1].x ? itr->p[1].x->n : -1; \+				++itr->p; \+			} \+			--itr->p; \+			if (itr->p < itr->stack) return 0; \+			--itr->p->i; \+			if (itr->p->x && itr->p->i >= 0) return 1; \+		} \+	} \+	static int kb_itr_getp_##name(kbtree_##name##_t *b, key_t * __restrict k, kbitr_##name##_t *itr) \+	{ \+		if (b->n_keys == 0) { \+            itr->p = NULL; \+            return 0; \+        } \+		int i, r = 0; \+		itr->p = itr->stack; \+		itr->p->x = b->root; \+		while (itr->p->x) { \+			i = __kb_getp_aux_##name(itr->p->x, k, &r); \+			itr->p->i = i; \+			if (i >= 0 && r == 0) return 1; \+			++itr->p->i; \+			itr->p[1].x = itr->p->x->is_internal? __KB_PTR(b, itr->p->x)[i + 1] : 0; \+			++itr->p; \+		} \+		return 0; \+	} \+	static inline int kb_itr_get_##name(kbtree_##name##_t *b, key_t k, kbitr_##name##_t *itr) \+	{																	\+		return kb_itr_getp_##name(b,&k,itr); \+	} \+	static inline void kb_del_itr_##name(kbtree_##name##_t *b, kbitr_##name##_t *itr) \+	{ \+		key_t k = kb_itr_key(key_t, itr); \+		kb_delp_##name(b, &k); \+		kb_itr_getp_##name(b, &k, itr); \+	} ++#define KBTREE_INIT(name, key_t, __cmp, T) \+  KBTREE_INIT_IMPL(name, key_t, kbnode_##name##_t, __cmp, T, (sizeof(kbnode_##name##_t)+(2*T)*sizeof(void *)))+++#define KBTREE_INIT_IMPL(name, key_t, kbnode_t, __cmp, T, ILEN)			\+	__KB_TREE_T(name, key_t, T)							\+	__KB_GET_AUX1(name, key_t, kbnode_t, __cmp)			\+	__KB_GET(name, key_t, kbnode_t)						\+	__KB_INTERVAL(name, key_t, kbnode_t)					\+	__KB_PUT(name, key_t, kbnode_t, __cmp, T, ILEN)				\+	__KB_DEL(name, key_t, kbnode_t, T) \+	__KB_ITR(name, key_t, kbnode_t)++#define KB_DEFAULT_SIZE 512++#define kbtree_t(name) kbtree_##name##_t+#define kbitr_t(name) kbitr_##name##_t+#define kb_init(b) ((b)->n_keys = (b)->n_nodes = 0, (b)->root = 0)+#define kb_destroy(name, b) __kb_destroy(kbnode_##name##_t, b)+#define kb_get(name, b, k) kb_get_##name(b, k)+#define kb_put(name, b, k) kb_put_##name(b, k)+#define kb_del(name, b, k) kb_del_##name(b, k)+#define kb_interval(name, b, k, l, u) kb_interval_##name(b, k, l, u)+#define kb_getp(name, b, k) kb_getp_##name(b, k)+#define kb_putp(name, b, k) kb_putp_##name(b, k)+#define kb_delp(name, b, k) kb_delp_##name(b, k)+#define kb_intervalp(name, b, k, l, u) kb_intervalp_##name(b, k, l, u)++#define kb_itr_first(name, b, i) kb_itr_first_##name(b, i)+#define kb_itr_get(name, b, k, i) kb_itr_get_##name(b, k, i)+#define kb_itr_getp(name, b, k, i) kb_itr_getp_##name(b, k, i)+#define kb_itr_next(name, b, i) kb_itr_next_##name(b, i)+#define kb_itr_prev(name, b, i) kb_itr_prev_##name(b, i)+#define kb_del_itr(name, b, i) kb_del_itr_##name(b, i)+#define kb_itr_key(type, itr) __KB_KEY(type, (itr)->p->x)[(itr)->p->i]+#define kb_itr_valid(itr) ((itr)->p >= (itr)->stack)++#define kb_size(b) ((b)->n_keys)++#define kb_generic_cmp(a, b) (((b) < (a)) - ((a) < (b)))+#define kb_str_cmp(a, b) strcmp(a, b)++/* The following is *DEPRECATED*!!! Use the iterator interface instead! */++#if 0","No, guess we should remove it, as we've refactored the library anyway. ",X
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/6272,105953926,2017-03-14T16:13:50Z,runtime/doc/eval.txt,"@@ -3749,6 +3750,20 @@ get({func}, {what}) 			'dict'	The dictionary 			'args'	The list with arguments +get_xdg_home([{expr}])					*get_xdg_home()*+		Get the XDG Base directory for {expr}.++		These are the directories used by Neovim loading and saving+		config, data and cache files.++		Note: These do not contain the '/nvim' trailing path+		component.++		{expr} can be one of the following:+			'CONFIG'  The XDG_CONFIG_HOME directory.","The keys should be lowercase too. The env var names are irrelevant to this API: they aren't used at all if they are not defined. Only the semantic description is relevant, e.g.:```config    user configuration directory, e.g. ~/.configdata      user data directory, e.g. ...cache     cache data directory```",
12913701,mschilli87,https://api.github.com/repos/neovim/neovim/pulls/6277,106100532,2017-03-15T07:36:12Z,src/nvim/po/de.po,"@@ -19,132 +19,375 @@ msgstr """" ""Content-Type: text/plain; charset=ISO_8859-1\n"" ""Content-Transfer-Encoding: 8-bit\n"" -#: ../api/private/helpers.c:197-msgid ""Unable to get option value""+#: ../api/buffer.c:170 ../api/buffer.c:281+#, fuzzy+msgid ""Index out of bounds""+msgstr ""Index out of bounds""++#: ../api/buffer.c:186+msgid ""Line index is too high""+msgstr ""Zeilenindex ist zu gro���""++#: ../api/buffer.c:289+msgid ""Argument \""start\"" is higher than \""end\""""+msgstr ""Argument \""start\"" is gr������er als \""end\""""++#: ../api/buffer.c:304+msgid ""All items in the replacement array must be strings""+msgstr ""Alle List-Eintr���ge in Ersatzarray m���ssen Zeichenfolgen sein""","Why '*List*-Eintr.'? In English it isn't '*list* items' either.And even if, I think it should be '*Listen*eintr.'",
12913701,mschilli87,https://api.github.com/repos/neovim/neovim/pulls/6277,106102484,2017-03-15T07:52:10Z,src/nvim/po/de.po,"@@ -153,476 +396,1466 @@ msgstr """" ""erzwingen)""  #. wrap around (may cause duplicates)-#: ../buffer.c:1414+#: ../buffer.c:1618 msgid ""W14: Warning: List of file names overflow"" msgstr ""W14: Achtung: ���berlauf der Liste der Dateinamen"" -#: ../buffer.c:1546 ../quickfix.c:3328+#: ../buffer.c:1760 ../quickfix.c:4168 #, c-format msgid ""E92: Buffer %<PRId64> not found"" msgstr ""E92: Kein Puffer %<PRId64> gefunden"" -#: ../buffer.c:1789+#: ../buffer.c:2012 #, c-format msgid ""E93: More than one match for %s"" msgstr ""E93: Mehr als ein Treffer f���r %s"" -#: ../buffer.c:1791+#: ../buffer.c:2014 #, c-format msgid ""E94: No matching buffer for %s"" msgstr ""E94: Kein ���bereinstimmender Puffer f���r %s"" -#: ../buffer.c:2151+#: ../buffer.c:2383 #, c-format msgid ""line %<PRId64>"" msgstr ""Zeile %<PRId64>"" -#: ../buffer.c:2223+#: ../buffer.c:2453 msgid ""E95: Buffer with this name already exists"" msgstr ""E95: Ein Puffer mit diesem Namen existiert bereits"" -#: ../buffer.c:2488+#: ../buffer.c:2722 msgid "" [Modified]"" msgstr "" [Ver���ndert]"" -#: ../buffer.c:2491+#: ../buffer.c:2725 msgid ""[Not edited]"" msgstr ""[Nicht bearbeitet]"" -#: ../buffer.c:2494+#: ../buffer.c:2728 msgid ""[New file]"" msgstr ""[Neue Datei]"" -#: ../buffer.c:2495+#: ../buffer.c:2729 msgid ""[Read errors]"" msgstr ""[Lesefehler]"" -#: ../buffer.c:2496 ../buffer.c:3205 ../fileio.c:1855 ../screen.c:4822+#: ../buffer.c:2730 ../buffer.c:3614 ../fileio.c:1844 ../screen.c:4878 msgid ""[RO]"" msgstr ""[RO]"" -#: ../buffer.c:2497 ../fileio.c:1855+#: ../buffer.c:2731 ../fileio.c:1844 msgid ""[readonly]"" msgstr ""[Nur Lesen]"" -#: ../buffer.c:2514+#: ../buffer.c:2748 #, c-format msgid ""1 line --%d%%--"" msgstr ""1 Zeile --%d%%--"" -#: ../buffer.c:2516+#: ../buffer.c:2750 #, c-format msgid ""%<PRId64> lines --%d%%--"" msgstr ""%<PRId64> Zeilen --%d%%--"" -#: ../buffer.c:2520+#: ../buffer.c:2754 #, c-format msgid ""line %<PRId64> of %<PRId64> --%d%%-- col "" msgstr ""Zeile %<PRId64> von %<PRId64> --%d%%-- Spalte "" -#: ../buffer.c:2622 ../buffer.c:4275 ../memline.c:1530+#: ../buffer.c:2857 ../buffer.c:4822 ../memline.c:1509 msgid ""[No Name]"" msgstr ""[Unbenannt]""  #. must be a help buffer-#: ../buffer.c:2657+#: ../buffer.c:2892 msgid ""help"" msgstr ""Hilfe"" -#: ../buffer.c:3213 ../screen.c:4810+#: ../buffer.c:3622 ../screen.c:4866 msgid ""[Help]"" msgstr ""[Hilfe]"" -#: ../buffer.c:3242 ../screen.c:4814+#: ../buffer.c:3660 ../screen.c:4870 msgid ""[Preview]"" msgstr ""[Vorschau]"" -#: ../buffer.c:3514+#: ../buffer.c:4140 msgid ""All"" msgstr ""Alles"" -#: ../buffer.c:3514+#: ../buffer.c:4140 msgid ""Bot"" msgstr ""Ende"" -#: ../buffer.c:3516+#: ../buffer.c:4142 msgid ""Top"" msgstr ""Anfang"" -#: ../buffer.c:4227-msgid """"-""\n""-""# Buffer list:\n""-msgstr """"-""\n""-""# Liste der Puffer:\n""--#: ../buffer.c:4272+#: ../buffer.c:4819 msgid ""[Scratch]"" msgstr ""[Notizen]"" -#: ../buffer.c:4521+#: ../buffer.c:5071 msgid """" ""\n"" ""--- Signs ---"" msgstr """" ""\n"" ""--- Zeichen ---"" -#: ../buffer.c:4530+#: ../buffer.c:5080 #, c-format msgid ""Signs for %s:"" msgstr ""Zeichen f���r %s:"" -#: ../buffer.c:4535+#: ../buffer.c:5085 #, c-format msgid ""    line=%<PRId64>  id=%d  name=%s"" msgstr ""    Zeile=%<PRId64>  id=%d  Name=%s"" -#: ../diff.c:130+#: ../cursor_shape.c:69+msgid ""E545: Missing colon""+msgstr ""E545: Fehlender Doppelpunkt""++#: ../cursor_shape.c:71 ../cursor_shape.c:96+msgid ""E546: Illegal mode""+msgstr ""E546: Unzul���ssiger Modus""++#: ../cursor_shape.c:136+msgid ""E548: digit expected""+msgstr ""E548: Ziffer erwartet""++#: ../cursor_shape.c:140+msgid ""E549: Illegal percentage""+msgstr ""E549: Unzul���ssige Prozentangabe""++#: ../diff.c:132 #, c-format msgid ""E96: Can not diff more than %<PRId64> buffers"" msgstr ""E96: Keine Differenz f���r mehr als %<PRId64> Puffer"" -#: ../diff.c:737+#: ../diff.c:738 msgid ""E810: Cannot read or write temp files"" msgstr ""E810: Kann tempor���re Dateien nicht lesen oder schreiben"" -#: ../diff.c:739+#: ../diff.c:740 msgid ""E97: Cannot create diffs"" msgstr ""E97: Kann keine Differenz erstellen"" -#: ../diff.c:950+#: ../diff.c:947 msgid ""E816: Cannot read patch output"" msgstr ""E816: Patch-Ausgabe kann nicht gelesen werden"" -#: ../diff.c:1204+#: ../diff.c:1208 msgid ""E98: Cannot read diff output"" msgstr ""E98: Differenz-Ausgabe kann nicht gelesen werden"" -#: ../diff.c:2065+#: ../diff.c:2078 msgid ""E99: Current buffer is not in diff mode"" msgstr ""E99: Aktueller Puffer ist nicht im Differenz-Modus"" -#: ../diff.c:2084+#: ../diff.c:2097 msgid ""E793: No other buffer in diff mode is modifiable"" msgstr ""E793: Es gibt keine weiteren ���nderbaren Puffer im Differenz-Modus"" -#: ../diff.c:2086+#: ../diff.c:2099 msgid ""E100: No other buffer in diff mode"" msgstr ""E100: Kein weiterer Puffer ist im Differenz-Modus"" -#: ../diff.c:2096+#: ../diff.c:2110 msgid ""E101: More than two buffers in diff mode, don't know which one to use"" msgstr ""E101: Mehrdeutigkeit: Mehr als zwei Puffer im Differenz-Modus"" -#: ../diff.c:2125+#: ../diff.c:2139 #, c-format msgid ""E102: Can't find buffer \""%s\"""" msgstr ""E102: Kann Puffer \""%s\"" nicht finden"" -#: ../diff.c:2136+#: ../diff.c:2150 #, c-format msgid ""E103: Buffer \""%s\"" is not in diff mode"" msgstr ""E103: Puffer \""%s\"" ist nicht im Differenz-Modus"" -#: ../diff.c:2177+#: ../diff.c:2191 msgid ""E787: Buffer changed unexpectedly"" msgstr ""E787: Puffer unerwartet ver���ndert"" -#: ../digraph.c:1597+#: ../digraph.c:1606 msgid ""E104: Escape not allowed in digraph"" msgstr ""E104: 'Escape' ist in einem Digraphen nicht erlaubt"" -#: ../digraph.c:1758+#: ../digraph.c:1769 msgid ""E544: Keymap file not found"" msgstr ""E544: Datei f���r die Tastaturbelegung nicht gefunden"" -#: ../digraph.c:1782+#: ../digraph.c:1792 msgid ""E105: Using :loadkeymap not in a sourced file"" msgstr ""E105: :loadkeymap au���erhalb einer eingelesenen Datei"" -#: ../digraph.c:1818+#: ../digraph.c:1827 msgid ""E791: Empty keymap entry"" msgstr ""E791: Leerer Tastaturbelegungs-Eintrag"" -#: ../edit.c:83+#: ../edit.c:85 msgid "" Keyword completion (^N^P)"" msgstr "" Stichwort-Erg���nzung (^N^P)""  #. ctrl_x_mode == 0, ^P/^N compl.-#: ../edit.c:84+#: ../edit.c:86 msgid "" ^X mode (^]^D^E^F^I^K^L^N^O^Ps^U^V^Y)"" msgstr "" ^X-Modus (^]^D^E^F^I^K^L^N^O^Ps^U^V^Y)"" -#: ../edit.c:86+#: ../edit.c:88 msgid "" Whole line completion (^L^N^P)"" msgstr "" Zeilen-Erg���nzung (^L^N^P)"" -#: ../edit.c:87+#: ../edit.c:89 msgid "" File name completion (^F^N^P)"" msgstr "" Dateinamen-Erg���nzung (^F^N^P)"" -#: ../edit.c:88+#: ../edit.c:90 msgid "" Tag completion (^]^N^P)"" msgstr "" Tag-Erg���nzung  (^]^N^P)"" -#: ../edit.c:89+#: ../edit.c:91 msgid "" Path pattern completion (^N^P)"" msgstr "" Pfadmuster-Erg���nzung (^N^P)"" -#: ../edit.c:90+#: ../edit.c:92 msgid "" Definition completion (^D^N^P)"" msgstr "" Definitions-Erg���nzung (^D^N^P)"" -#: ../edit.c:92+#: ../edit.c:94 msgid "" Dictionary completion (^K^N^P)"" msgstr "" W���rterbuch-Erg���nzung (^K^N^P) "" -#: ../edit.c:93+#: ../edit.c:95 msgid "" Thesaurus completion (^T^N^P)"" msgstr "" Thesaurus-Erg���nzung (^T^N^P)"" -#: ../edit.c:94+#: ../edit.c:96 msgid "" Command-line completion (^V^N^P)"" msgstr "" Kommandozeilen-Erg���nzung (^V^N^P)"" -#: ../edit.c:95+#: ../edit.c:97 msgid "" User defined completion (^U^N^P)"" msgstr "" Benutzerdefinierte Erg���nzung (^U^N^P)"" -#: ../edit.c:96+#: ../edit.c:98 msgid "" Omni completion (^O^N^P)"" msgstr "" Omni-Erg���nzung (^O^N^P)"" -#: ../edit.c:97+#: ../edit.c:99 msgid "" Spelling suggestion (s^N^P)"" msgstr "" Vorschlag der Rechtschreibpr���fung (s^N^P)"" -#: ../edit.c:98+#: ../edit.c:100 msgid "" Keyword Local completion (^N^P)"" msgstr "" Lokale Schl���sselwort-Erg���nzung(^N^P)"" -#: ../edit.c:101+#: ../edit.c:104 msgid ""Hit end of paragraph"" msgstr ""Absatzende erreicht"" -#: ../edit.c:102+#: ../edit.c:105 msgid ""E839: Completion function changed window"" msgstr ""E839: Erg���nzungs-Funktion ver���nderte Fenster"" -#: ../edit.c:103+#: ../edit.c:106 msgid ""E840: Completion function deleted text"" msgstr ""E840: Erg���nzungs-Funktion l���schte Text"" -#: ../edit.c:1748+#: ../edit.c:1868 msgid ""'dictionary' option is empty"" msgstr ""Die Option 'dictionary' ist leer"" -#: ../edit.c:1749+#: ../edit.c:1869 msgid ""'thesaurus' option is empty"" msgstr ""Die Option 'thesaurus' ist leer"" -#: ../edit.c:2555+#: ../edit.c:2714 #, c-format msgid ""Scanning dictionary: %s"" msgstr ""Durchsuchen des W���rterbuchs: %s"" -#: ../edit.c:2979+#: ../edit.c:3143 msgid "" (insert) Scroll (^E/^Y)"" msgstr "" (Einf���gen) Scrollen (^E/^Y)"" -#: ../edit.c:2981+#: ../edit.c:3145 msgid "" (replace) Scroll (^E/^Y)"" msgstr "" (Ersetzen) Scrollen (^E/^Y)"" -#: ../edit.c:3486+#: ../edit.c:3663 #, c-format msgid ""Scanning: %s"" msgstr ""Durchsuche: %s"" -#: ../edit.c:3513+#: ../edit.c:3690 msgid ""Scanning tags."" msgstr ""Durchsuchen von Tags."" -#: ../edit.c:4418+#: ../edit.c:4639 msgid "" Adding"" msgstr "" F���ge hinzu""  #. showmode might reset the internal line pointers, so it must #. * be called before line = ml_get(), or when this address is no #. * longer needed.  -- Acevedo. #.-#: ../edit.c:4461+#: ../edit.c:4682 msgid ""-- Searching..."" msgstr ""-- Suche..."" -#: ../edit.c:4517+#: ../edit.c:4741 msgid ""Back at original"" msgstr ""Zur���ck am Ursprung"" -#: ../edit.c:4520+#: ../edit.c:4744 msgid ""Word from other line"" msgstr ""Wort aus anderer Zeile"" -#: ../edit.c:4523+#: ../edit.c:4747 msgid ""The only match"" msgstr ""Einziger Treffer"" -#: ../edit.c:4579+#: ../edit.c:4803 #, c-format msgid ""match %d of %d"" msgstr ""Treffer %d von %d"" -#: ../edit.c:4583+#: ../edit.c:4807 #, c-format msgid ""match %d"" msgstr ""Treffer %d"" -#: ../ex_cmds.c:119-#, c-format-msgid ""<%s>%s%s  %d,  Hex %02x,  Octal %03o""-msgstr ""<%s>%s%s  %d,  Hex %02x,  Oktal %03o""+#: ../eval.c:152+msgid ""E18: Unexpected characters in :let""+msgstr ""E18: Unerwartete Zeichen in :let"" -#: ../ex_cmds.c:142+#: ../eval.c:153 #, c-format-msgid ""> %d, Hex %04x, Octal %o""-msgstr ""> %d, Hex %04x, Oktal %o""+msgid ""E684: list index out of range: %<PRId64>""+msgstr ""E684: List-Index au���erhalb des zul���ssigen Bereichs: %<PRId64>"" -#: ../ex_cmds.c:143+#: ../eval.c:154 #, c-format-msgid ""> %d, Hex %08x, Octal %o""-msgstr ""> %d, Hex %08x, Oktal %o""--#: ../ex_cmds.c:679-msgid ""E134: Move lines into themselves""-msgstr ""E134: Verschiebe Zeilen in sich selbst""+msgid ""E121: Undefined variable: %s""+msgstr ""E121: Nicht definierte Variable: %s"" -#: ../ex_cmds.c:742-msgid ""1 line moved""-msgstr ""eine Zeile verschoben""+#: ../eval.c:155+msgid ""E111: Missing ']'""+msgstr ""E111: Fehlende ']'"" -#: ../ex_cmds.c:744+#: ../eval.c:156 #, c-format-msgid ""%<PRId64> lines moved""-msgstr ""%<PRId64> Zeilen verschoben""+msgid ""E686: Argument of %s must be a List""+msgstr ""E686: Argument von %s muss vom Typ List sein"" -#: ../ex_cmds.c:1170+#: ../eval.c:158 #, c-format-msgid ""%<PRId64> lines filtered""-msgstr ""%<PRId64> Zeilen gefiltert""+msgid ""E712: Argument of %s must be a List or Dictionary""+msgstr ""E712: Argument von %s muss vom Typ List oder Dictionary sein"" -#: ../ex_cmds.c:1189-msgid ""E135: *Filter* Autocommands must not change current buffer""-msgstr ""E135: *Filter*-Autokommandos d���rfen den aktuellen Puffer nicht ���ndern""+#: ../eval.c:159+msgid ""E713: Cannot use empty key for Dictionary""+msgstr ""E713: Schl���ssel f���r Dictionary darf nicht leer sein"" -#: ../ex_cmds.c:1239-msgid ""[No write since last change]\n""-msgstr ""[Kein Schreiben seit der letzten ���nderung]\n""+#: ../eval.c:160+msgid ""E714: List required""+msgstr ""E714: List ben���tigt""","I get that 'List' is supposed to be the (non-translated) data type name, but it just seems off and screams for 'Liste' instead. Maybe 'List-Objekt' or '&#96;List&#96;' would help?",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/6299,106532698,2017-03-16T21:12:23Z,test/functional/core/main_spec.lua,"@@ -0,0 +1,60 @@+local lfs = require('lfs')+local helpers = require('test.functional.helpers')(after_each)+local global_helpers = require('test.helpers')++local eq = helpers.eq+local neq = helpers.neq+local sleep = helpers.sleep+local nvim_prog = helpers.nvim_prog+local write_file = helpers.write_file++local popen_w = global_helpers.popen_w+local popen_r = global_helpers.popen_r++describe('Command-line option', function()+  describe('-s', function()+    local fname = 'Xtest-functional-core-main-s'+    local dollar_fname = '$' .. fname+    before_each(function()+      os.remove(fname)+      os.remove(dollar_fname)+    end)+    after_each(function()+      os.remove(fname)+      os.remove(dollar_fname)+    end)+    it('treats - as stdin', function()+      eq(nil, lfs.attributes(fname))+      local pipe = popen_w(+        nvim_prog, '-u', 'NONE', '-i', 'NONE', '--headless', '-s', '-',+        fname)+      pipe:write(':call setline(1, ""42"")\n')+      pipe:write(':wqall!\n')+      pipe:close()+      local max_sec = 10+      while max_sec > 0 do+        local attrs = lfs.attributes(fname)+        if attrs then+          eq(#('42\n'), attrs.size)+          break+        else+          max_sec = max_sec - 1+          sleep(1000)+        end+      end+      neq(0, max_sec)+    end)+    it('does not expand $VAR', function()","This test is there because `-S` is not working well with such names (`-S arg` uses a concat of `source` and `arg` without any escaping used). `-s` is treated different and does not have the problem, but this option looks similar to `-S`.",
112971,jamessan,https://api.github.com/repos/neovim/neovim/pulls/6287,106638063,2017-03-17T12:20:58Z,src/nvim/testdir/test_undo.vim,"@@ -0,0 +1,206 @@+"" Tests for the undo tree.+"" Since this script is sourced we need to explicitly break changes up in+"" undo-able pieces.  Do that by setting 'undolevels'.+"" Also tests :earlier and :later.++func Test_undotree()+  exe ""normal Aabc\<Esc>""+  set ul=100+  exe ""normal Adef\<Esc>""+  set ul=100+  undo+  let d = undotree()+  call assert_true(d.seq_last > 0)+  call assert_true(d.seq_cur > 0)+  call assert_true(d.seq_cur < d.seq_last)+  call assert_true(len(d.entries) > 0)+  "" TODO: check more members of d++  w! Xtest+  call assert_equal(d.save_last + 1, undotree().save_last)+  call delete('Xtest')+  bwipe Xtest+endfunc++func FillBuffer()+  for i in range(1,13)+    put=i+    "" Set 'undolevels' to split undo. +    exe ""setg ul="" . &g:ul+  endfor+endfunc++func Test_global_local_undolevels()+  new one+  set undolevels=5+  call FillBuffer()+  "" will only undo the last 5 changes, end up with 13 - (5 + 1) = 7 lines+  earlier 10+  call assert_equal(5, &g:undolevels)+  call assert_equal(-123456, &l:undolevels)+  call assert_equal('7', getline('$'))++  new two+  setlocal undolevels=2+  call FillBuffer()+  "" will only undo the last 2 changes, end up with 13 - (2 + 1) = 10 lines+  earlier 10+  call assert_equal(5, &g:undolevels)+  call assert_equal(2, &l:undolevels)+  call assert_equal('10', getline('$'))++  setlocal ul=10+  call assert_equal(5, &g:undolevels)+  call assert_equal(10, &l:undolevels)++  "" Setting local value in ""two"" must not change local value in ""one""+  wincmd p+  call assert_equal(5, &g:undolevels)+  call assert_equal(-123456, &l:undolevels)++  new three+  setglobal ul=50+  call assert_equal(50, &g:undolevels)+  call assert_equal(-123456, &l:undolevels)++  "" Drop created windows+  set ul&+  new+  only!+endfunc++func BackOne(expected)+  call feedkeys('g-', 'xt')+  call assert_equal(a:expected, getline(1))+endfunc++func Test_undo_del_chars()","> I renamed this to Test_undo_del_chars_skipped since that is Vim's way to skip tests.Actually, the way to do a skip is to throw an exception that starts with the word `skipped`.```vim  try    exe 'call ' . a:test  catch /^\cskipped/    call add(s:messages, '    Skipped')    call add(s:skipped, 'SKIPPED ' . a:test . ': ' . substitute(v:exception, '^\S*\s\+', '',  ''))  catch    call add(v:errors, 'Caught exception in ' . a:test . ': ' . v:exception . ' @ ' . v:throwpoint)  endtry```",
268102,msva,https://api.github.com/repos/neovim/neovim/pulls/6298,106693066,2017-03-17T16:38:32Z,src/nvim/fileio.c,"@@ -706,10 +706,9 @@ readfile (      * still be running, don't move the cursor to the last line, unless      * always using the GUI.      */-    if (read_stdin) {-      mch_msg(_(""Nvim: Reading from stdin...\n""));-    } else if (!read_buffer)+    if ((!read_stdin) && (!read_buffer)) {       filemess(curbuf, sfname, (char_u *)"""", 0);+    }","I don't know why it was added before, but I just made condition, which will be triggered in same conditions as before.There was ""if read stdin then throw warning, otherwise, if not read buffer, then filemess"".I did ""if not read stdin and not read buffer, then filemess"".So, `filemess` will be triggered in exact conditions as before: when both `(!read_stdin)` and `(!read_buffer)`...",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/6317,106813997,2017-03-19T18:14:33Z,src/nvim/CMakeLists.txt,"@@ -43,6 +44,7 @@ set(GENERATED_UNICODE_TABLES ${GENERATED_DIR}/unicode_tables.generated.h) include_directories(${GENERATED_DIR}) include_directories(${CACHED_GENERATED_DIR}) include_directories(${GENERATED_INCLUDES_DIR})+include_directories(""../../../utf8proc"")","��� and also include directories there. Additionally it should not be `../../../`, but I guess this is temporary.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/6317,106814137,2017-03-19T18:21:46Z,src/nvim/mbyte.c,"@@ -1328,28 +1239,12 @@ int utf_fold(int a)  */ int utf_toupper(int a) {-  /* If 'casemap' contains ""keepascii"" use ASCII style toupper(). */-  if (a < 128 && (cmp_flags & CMP_KEEPASCII))-    return TOUPPER_ASC(a);--#if defined(__STDC_ISO_10646__)-  /* If towupper() is available and handles Unicode, use it. */-  if (!(cmp_flags & CMP_INTERNAL))-    return towupper(a);-#endif--  /* For characters below 128 use locale sensitive toupper(). */-  if (a < 128)-    return TOUPPER_LOC(a);--  /* For any other characters use the above mapping table. */-  return utf_convert(a, toUpper, ARRAY_SIZE(toUpper));+  return utf8proc_toupper(a);",We need to check that this is locale-sensitive in the same conditions. Likely we need to keep the checks for `cmp_flags` for this.,
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/5266,106906850,2017-03-20T14:00:08Z,src/nvim/buffer.c,"@@ -5185,14 +5203,20 @@ void bufhl_clear_line_range(buf_T *buf,   if (!buf->b_bufhl_info) {     return;   }-  linenr_T line;   linenr_T first_changed = MAXLNUM, last_changed = -1;-  // In the case line_start - line_end << bufhl_info->size-  // it might be better to reverse this, i e loop over the lines-  // to clear on.-  bufhl_vec_T unused;-  map_foreach(buf->b_bufhl_info, line, unused, {-    (void)unused;+  // TODO: implement kb_itr_interval and jump directly to the first line+  kbitr_t itr;+  BufhlLine *l;+  for (kb_itr_first(bufhl, buf->b_bufhl_info, &itr);+       kb_itr_valid(&itr);+       kb_itr_next(bufhl, buf->b_bufhl_info, &itr)) {+    l = kb_itr_key(BufhlLine *, &itr);",given the struct refactor it looks we can just get rid of the type parameter.,X
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/5169,107382618,2017-03-22T10:50:18Z,runtime/ftplugin/help.vim,"@@ -18,5 +18,77 @@ if has(""conceal"")   setlocal cole=2 cocu=nc endif +if !exists('g:no_plugin_maps')+  function! s:show_toc() abort+    let bufname = bufname('%')+    let info = getloclist(0, {'winid': 1})+    if !empty(info) && getwinvar(info.winid, 'qf_toc') ==# bufname",Can we store the bufname in the getloclist `info` instead of `w:qf_toc`?,X
111942,tweekmonster,https://api.github.com/repos/neovim/neovim/pulls/5169,107498010,2017-03-22T18:37:37Z,runtime/ftplugin/help.vim,"@@ -18,5 +18,77 @@ if has(""conceal"")   setlocal cole=2 cocu=nc endif +if !exists('g:no_plugin_maps')+  function! s:show_toc() abort+    let bufname = bufname('%')+    let info = getloclist(0, {'winid': 1})+    if !empty(info) && getwinvar(info.winid, 'qf_toc') ==# bufname",How do you mean?  Arbitrary info can't be attached to qf lists (yet).,X
10180857,nhooyr,https://api.github.com/repos/neovim/neovim/pulls/5169,107616872,2017-03-23T09:06:45Z,runtime/syntax/man.vim,"@@ -18,6 +18,11 @@ highlight default link manOptionDesc     Constant highlight default link manReference      PreProc highlight default link manSubHeading     Function +if &filetype != 'man'+  "" Loaded by the location list TOC+  finish","Yes, it's for the syntax highlighting.https://github.com/tweekmonster/neovim/blob/173620e6105de6f258c3f2b0deeb5aa66b148fab/runtime/ftplugin/qf.vim#L34",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/5169,107678665,2017-03-23T14:16:38Z,runtime/syntax/man.vim,"@@ -18,6 +18,11 @@ highlight default link manOptionDesc     Constant highlight default link manReference      PreProc highlight default link manSubHeading     Function +if &filetype != 'man'+  "" Loaded by the location list TOC+  finish",">  It actually makes the syntax loadable by other syntaxes.Let's just change the comment then. Currently it specifically says ""Loaded by the location list TOC"" which is confusing.    "" Some other filetype is using syntax/man.vim",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/5169,107682981,2017-03-23T14:31:32Z,runtime/doc/filetype.txt,"@@ -544,6 +544,8 @@ CTRL-T                    Jump back to the location that the manpage was                           opened from. q                         :quit if invoked as $MANPAGER, otherwise :close. +To see the table of contents, type <M-]>.","For the man.vim case, this should be listed like the other mappings above.    META-]              Show the manpage outline in the |location-list|. ",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/6350,107977031,2017-03-24T18:57:54Z,src/nvim/testdir/Makefile,"@@ -61,6 +61,7 @@ NEW_TESTS ?= \ 	    test_timers.res \ 	    test_undo.res \ 	    test_usercommands.res \+	    test_utf8.res \","I noticed recently, if I'm not mistaken this will cause the test to run twice, since it's also listed in test_alot.vim.On the other hand, if tests aren't listed in `NEW_TESTS` then `TEST_FILE=test_foo.res make oldtest` won't find the test. Which doesn't seem terribly important to me, since `test_alot.vim` is supposed to be fast anyway.This is because our `src/nvim/testdir/Makefile` is a bit hacked up, it's quite diverged from Vim's (for various reasons).",X
112971,jamessan,https://api.github.com/repos/neovim/neovim/pulls/6350,107977646,2017-03-24T19:01:13Z,src/nvim/testdir/Makefile,"@@ -61,6 +61,7 @@ NEW_TESTS ?= \ 	    test_timers.res \ 	    test_undo.res \ 	    test_usercommands.res \+	    test_utf8.res \","Upstream handles this by having a (I forget the real term for this) conversion rule in their Makefile:```make.vim.res:        @echo ""$(RUN_VIMTEST)"" > vimcmd        $(RUN_VIMTEST) $(NO_INITS) -S runtest.vim $*.vim        @rm vimcmd```That allows all tests to be run independently while not automatically running them during general testing.",X
112971,jamessan,https://api.github.com/repos/neovim/neovim/pulls/6350,107977760,2017-03-24T19:01:53Z,src/nvim/testdir/Makefile,"@@ -61,6 +61,7 @@ NEW_TESTS ?= \ 	    test_timers.res \ 	    test_undo.res \ 	    test_usercommands.res \+	    test_utf8.res \","We have something similar, so I guess I didn't need to add it to `NEW_TESTS`.",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/6236,107983371,2017-03-24T19:33:02Z,src/nvim/api/vim.c,"@@ -695,6 +695,56 @@ Dictionary nvim_get_color_map(void)   return colors; } +/// Get the mappings for the corresponding scope and mode+///+/// @param mode+/// @param scope+Array nvim_get_keymap(String mode, String scope)+  FUNC_API_SINCE(2)+{+  Array mappings = ARRAY_DICT_INIT;+  mapblock_T *current_maphash;++  // Convert the string mode to the integer mode+  // that is stored within each mapblock+  int int_mode = get_map_mode((char_u **)(&(mode.data)), 0);+  int buffer_local = 0;++  if (strcmp(scope.data, ""buffer"") == 0) {+    buffer_local = 1;+  }++  int i = 0;+  for (i = 0; i < MAX_MAPHASH; i++) {+    // Get the correct maphash based on global or local hashes+    current_maphash = get_maphash(i, scope.data);++    if (current_maphash == NULL) {+      continue;+    }++    while (current_maphash) {","Should not it be```Cfor (mapblock_T *current_maphash = get_maphash(i, scope.data); current_maphash; current_maphash = current_maphash->m_next)```? And you definitely need no `if()` with `continue` at all, even with your code: while cycle just will not be executed. Also `current_maphash` variable declaration must be in the cycle, not at the start of the function.",X
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/6236,107983659,2017-03-24T19:34:40Z,src/nvim/api/vim.c,"@@ -695,6 +695,56 @@ Dictionary nvim_get_color_map(void)   return colors; } +/// Get the mappings for the corresponding scope and mode+///+/// @param mode+/// @param scope+Array nvim_get_keymap(String mode, String scope)+  FUNC_API_SINCE(2)+{+  Array mappings = ARRAY_DICT_INIT;+  mapblock_T *current_maphash;++  // Convert the string mode to the integer mode+  // that is stored within each mapblock+  int int_mode = get_map_mode((char_u **)(&(mode.data)), 0);+  int buffer_local = 0;","This is boolean: `const bool buffer_local = strcmp(scope.data, ""buffer"") == 0;`.",X
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/6236,107984352,2017-03-24T19:38:50Z,src/nvim/eval.c,"@@ -13358,26 +13358,31 @@ static void get_maparg(typval_T *argvars, typval_T *rettv, int exact)     rettv_dict_alloc(rettv);     if (rhs != NULL) {       // Return a dictionary.-      char_u *lhs = str2special_save(mp->m_keys, true);-      char *const mapmode = map_mode_to_chars(mp->m_mode);       dict_T *dict = rettv->vval.v_dict;--      dict_add_nr_str(dict, ""lhs"",     0L, lhs);-      dict_add_nr_str(dict, ""rhs"",     0L, mp->m_orig_str);-      dict_add_nr_str(dict, ""noremap"", mp->m_noremap ? 1L : 0L, NULL);-      dict_add_nr_str(dict, ""expr"",    mp->m_expr    ? 1L : 0L, NULL);-      dict_add_nr_str(dict, ""silent"",  mp->m_silent  ? 1L : 0L, NULL);-      dict_add_nr_str(dict, ""sid"",     (long)mp->m_script_ID, NULL);-      dict_add_nr_str(dict, ""buffer"",  (long)buffer_local, NULL);-      dict_add_nr_str(dict, ""nowait"",  mp->m_nowait  ? 1L : 0L, NULL);-      dict_add_nr_str(dict, ""mode"",    0L, (char_u *)mapmode);--      xfree(lhs);-      xfree(mapmode);+      mapblock_fill_dict(dict, mp, buffer_local);     }   } } +void mapblock_fill_dict(dict_T *dict, mapblock_T *mp, int buffer_local)","Additionally I would suggest using `dict_T *const` and `const mapblock_T *const`, especially the second (state that you are not going to modify the `mapblock_T`, `const` after `*` in this case is largerly irrelevant because it only states that variable will not be reassigned inside a function).",X
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/6236,108037100,2017-03-25T14:15:29Z,src/nvim/api/vim.c,"@@ -695,6 +696,73 @@ Dictionary nvim_get_color_map(void)   return colors; } +// Helper function for nvim_get_keymap and nvim_buf_get_keymap+// @param mode The abbreviation for the mode",Missing empty line after summary. Also I would suggest two spaces before and after parameter name.,X
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/6236,108037220,2017-03-25T14:21:06Z,src/nvim/api/vim.c,"@@ -695,6 +696,73 @@ Dictionary nvim_get_color_map(void)   return colors; } +// Helper function for nvim_get_keymap and nvim_buf_get_keymap+// @param mode The abbreviation for the mode+// @param buffer_id+//      -1: Global mapping+//      0: Current buffer+//      else: The desired buffer ID+//+// @returns An array of maparg() like dictionaries describing mappings+static Array get_keymap_helper(String mode, Integer buffer_id)+{+  Array mappings = ARRAY_DICT_INIT;+  dict_T *const dict = dict_alloc();++  // Convert the string mode to the integer mode+  // that is stored within each mapblock+  int int_mode = get_map_mode((char_u **)(&(mode.data)), 0);++  for (int i = 0; i < MAX_MAPHASH; i++) {+    for (mapblock_T *current_maphash = get_maphash(i, (long)buffer_id);+        current_maphash;+        current_maphash = current_maphash->m_next) {+      // Check for correct mode+      if ((int_mode & current_maphash->m_mode) != 0) {+        mapblock_fill_dict(+            dict,+            current_maphash,+            (long)buffer_id,+            false);++        ADD(mappings,+            vim_to_object((typval_T[]) {+                { .v_type = VAR_DICT, .vval.v_dict = dict }+              })+            );++        dict_clear(dict);+      }+    }+  }+  dict_free(dict);++  return mappings;+}++// Get a list of dictionaries describing global (i.e. non-buffer) mappings+// @param mode The abbreviation for the mode+// @returns An array of maparg() like dictionaries describing mappings+Array nvim_get_keymap(String mode)+  FUNC_API_SINCE(2)+{+  return get_keymap_helper(mode, -1);+}+++// Get a lit of dictionaries describing buffer-local mappings","Typo: `lit`, should be `list`.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/6358,108045371,2017-03-25T21:11:30Z,src/nvim/testdir/test_search.vim,"@@ -0,0 +1,242 @@+"" Test for the search command++func Test_search_cmdline()+  if !exists('+incsearch')+    return+  endif+  "" need to disable char_avail,+  "" so that expansion of commandline works+  call test_disable_char_avail(1)","Can be tested with a screen test. See `test/functional/ui/inccommand_spec.lua` , 'inccommand' is quite similar :)",
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/5119,108198183,2017-03-27T15:20:26Z,src/nvim/api/buffer.c,"@@ -395,10 +395,10 @@ void nvim_buf_set_lines(uint64_t channel_id,     mark_adjust((linenr_T)start, (linenr_T)(end - 1), MAXLNUM, extra);   } -  changed_lines((linenr_T)start, 0, (linenr_T)end, extra);+  changed_lines((linenr_T)start, 0, (linenr_T)end, (long)extra);","Can't we change the type of `extra` to `linenr_T` or `long`? Guranteed value range of `ssize_t` is `[-1, SSIZE_MAX]`, but the value saved in `extra` could be smaller than `-1`, see line 346.",X
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/5119,108278059,2017-03-27T20:56:53Z,src/nvim/eval/typval.c,"@@ -0,0 +1,2560 @@+#include <stdio.h>+#include <stddef.h>+#include <string.h>+#include <assert.h>+#include <stdbool.h>++#include ""nvim/lib/queue.h""+#include ""nvim/eval/typval.h""+#include ""nvim/eval/gc.h""+#include ""nvim/eval/executor.h""+#include ""nvim/eval/encode.h""+#include ""nvim/eval/typval_encode.h""+#include ""nvim/eval.h""+#include ""nvim/types.h""+#include ""nvim/assert.h""+#include ""nvim/memory.h""+#include ""nvim/globals.h""+#include ""nvim/hashtab.h""+#include ""nvim/vim.h""+#include ""nvim/ascii.h""+#include ""nvim/pos.h""+#include ""nvim/charset.h""+#include ""nvim/garray.h""+#include ""nvim/gettext.h""+#include ""nvim/macros.h""+#include ""nvim/mbyte.h""+#include ""nvim/message.h""+// TODO(ZyX-I): Move line_breakcheck out of misc1+#include ""nvim/misc1.h""  // For line_breakcheck++#ifdef INCLUDE_GENERATED_DECLARATIONS+# include ""eval/typval.c.generated.h""+#endif++bool tv_in_free_unref_items = false;++// TODO(ZyX-I): Remove DICT_MAXNEST, make users be non-recursive instead++#define DICT_MAXNEST 100++const char *const tv_empty_string = """";++//{{{1 Lists+//{{{2 List item++/// Allocate a list item+///+/// @warning Allocated item is not initialized, do not forget to initialize it+///          and specifically set lv_lock.+///+/// @return [allocated] new list item.+listitem_T *tv_list_item_alloc(void)+  FUNC_ATTR_NONNULL_RET FUNC_ATTR_MALLOC+{+  return xmalloc(sizeof(listitem_T));+}++/// Free a list item+///+/// Also clears the value. Does not touch watchers.+///+/// @param[out]  item  Item to free.+void tv_list_item_free(listitem_T *const item)+  FUNC_ATTR_NONNULL_ALL+{+  tv_clear(&item->li_tv);+  xfree(item);+}++/// Remove a list item from a List and free it+///+/// Also clears the value.+///+/// @param[out]  l  List to remove item from.+/// @param[in,out]  item  Item to remove.+void tv_list_item_remove(list_T *const l, listitem_T *const item)+  FUNC_ATTR_NONNULL_ALL+{+  tv_list_remove_items(l, item, item);+  tv_list_item_free(item);+}++//{{{2 List watchers++/// Add a watcher to a list+///+/// @param[out]  l  List to add watcher to.+/// @param[in]  lw  Watcher to add.+void tv_list_watch_add(list_T *const l, listwatch_T *const lw)+  FUNC_ATTR_NONNULL_ALL+{+  lw->lw_next = l->lv_watch;+  l->lv_watch = lw;+}++/// Remove a watcher from a list+///+/// Does not give a warning if watcher was not found.+///+/// @param[out]  l  List to remove watcher from.+/// @param[in]  lwrem  Watcher to remove.+void tv_list_watch_remove(list_T *const l, listwatch_T *const lwrem)+  FUNC_ATTR_NONNULL_ALL+{+  listwatch_T **lwp = &l->lv_watch;+  for (listwatch_T *lw = l->lv_watch; lw != NULL; lw = lw->lw_next) {+    if (lw == lwrem) {+      *lwp = lw->lw_next;+      break;+    }+    lwp = &lw->lw_next;+  }+}++/// Advance watchers to the next item+///+/// Used just before removing an item from a list.+///+/// @param[out]  l  List from which item is removed.+/// @param[in]  item  List item being removed.+void tv_list_watch_fix(list_T *const l, const listitem_T *const item)+  FUNC_ATTR_NONNULL_ALL+{+  for (listwatch_T *lw = l->lv_watch; lw != NULL; lw = lw->lw_next) {+    if (lw->lw_item == item) {+      lw->lw_item = item->li_next;+    }+  }+}++//{{{2 Alloc/free++/// Allocate an empty list+///+/// Caller should take care of the reference count.+///+/// @return [allocated] new list.+list_T *tv_list_alloc(void)+  FUNC_ATTR_NONNULL_RET FUNC_ATTR_MALLOC+{+  list_T *const list = xcalloc(1, sizeof(list_T));++  // Prepend the list to the list of lists for garbage collection.+  if (gc_first_list != NULL) {+    gc_first_list->lv_used_prev = list;+  }+  list->lv_used_prev = NULL;+  list->lv_used_next = gc_first_list;+  gc_first_list = list;+  return list;+}++/// Free items contained in a list+///+/// @param[in,out]  l  List to clear.+void tv_list_free_contents(list_T *const l)+  FUNC_ATTR_NONNULL_ALL+{+  for (listitem_T *item = l->lv_first; item != NULL; item = l->lv_first) {+    // Remove the item before deleting it.+    l->lv_first = item->li_next;+    tv_clear(&item->li_tv);+    xfree(item);+  }+  l->lv_len = 0;+  l->lv_idx_item = NULL;+  for (listwatch_T *lw = l->lv_watch; lw != NULL; lw = lw->lw_next) {+    lw->lw_item = NULL;+  }","They are supposed to be removed by the callers. If I am not mistaking, this may just be as well `assert(l->lv_watch == NULL)`: `free_for_info` which is the only user of `tv_list_watch_remove()` may only work with an allocated list and `tv_list_free_contents` is only called when freeing the list or when GCing it, in both cases it will be rendered unusable before `free_for_info` could do anything and lists are not supposed to be GCed if they are being referenced by `:for`.",X
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/5119,108466810,2017-03-28T16:14:58Z,src/nvim/eval/typval.c,"@@ -0,0 +1,2556 @@+#include <stdio.h>+#include <stddef.h>+#include <string.h>+#include <assert.h>+#include <stdbool.h>++#include ""nvim/lib/queue.h""+#include ""nvim/eval/typval.h""+#include ""nvim/eval/gc.h""+#include ""nvim/eval/executor.h""+#include ""nvim/eval/encode.h""+#include ""nvim/eval/typval_encode.h""+#include ""nvim/eval.h""+#include ""nvim/types.h""+#include ""nvim/assert.h""+#include ""nvim/memory.h""+#include ""nvim/globals.h""+#include ""nvim/hashtab.h""+#include ""nvim/vim.h""+#include ""nvim/ascii.h""+#include ""nvim/pos.h""+#include ""nvim/charset.h""+#include ""nvim/garray.h""+#include ""nvim/gettext.h""+#include ""nvim/macros.h""+#include ""nvim/mbyte.h""+#include ""nvim/message.h""+// TODO(ZyX-I): Move line_breakcheck out of misc1+#include ""nvim/misc1.h""  // For line_breakcheck++#ifdef INCLUDE_GENERATED_DECLARATIONS+# include ""eval/typval.c.generated.h""+#endif++bool tv_in_free_unref_items = false;++// TODO(ZyX-I): Remove DICT_MAXNEST, make users be non-recursive instead++#define DICT_MAXNEST 100++const char *const tv_empty_string = """";++//{{{1 Lists+//{{{2 List item++/// Allocate a list item+///+/// @warning Allocated item is not initialized, do not forget to initialize it+///          and specifically set lv_lock.+///+/// @return [allocated] new list item.+listitem_T *tv_list_item_alloc(void)+  FUNC_ATTR_NONNULL_RET FUNC_ATTR_MALLOC+{+  return xmalloc(sizeof(listitem_T));+}++/// Free a list item+///+/// Also clears the value. Does not touch watchers.+///+/// @param[out]  item  Item to free.+void tv_list_item_free(listitem_T *const item)+  FUNC_ATTR_NONNULL_ALL+{+  tv_clear(&item->li_tv);+  xfree(item);+}++/// Remove a list item from a List and free it+///+/// Also clears the value.+///+/// @param[out]  l  List to remove item from.+/// @param[in,out]  item  Item to remove.+void tv_list_item_remove(list_T *const l, listitem_T *const item)+  FUNC_ATTR_NONNULL_ALL+{+  tv_list_remove_items(l, item, item);+  tv_list_item_free(item);+}++//{{{2 List watchers++/// Add a watcher to a list+///+/// @param[out]  l  List to add watcher to.+/// @param[in]  lw  Watcher to add.+void tv_list_watch_add(list_T *const l, listwatch_T *const lw)+  FUNC_ATTR_NONNULL_ALL+{+  lw->lw_next = l->lv_watch;+  l->lv_watch = lw;+}++/// Remove a watcher from a list+///+/// Does not give a warning if watcher was not found.+///+/// @param[out]  l  List to remove watcher from.+/// @param[in]  lwrem  Watcher to remove.+void tv_list_watch_remove(list_T *const l, listwatch_T *const lwrem)+  FUNC_ATTR_NONNULL_ALL+{+  listwatch_T **lwp = &l->lv_watch;+  for (listwatch_T *lw = l->lv_watch; lw != NULL; lw = lw->lw_next) {+    if (lw == lwrem) {+      *lwp = lw->lw_next;+      break;+    }+    lwp = &lw->lw_next;+  }+}++/// Advance watchers to the next item+///+/// Used just before removing an item from a list.+///+/// @param[out]  l  List from which item is removed.+/// @param[in]  item  List item being removed.+void tv_list_watch_fix(list_T *const l, const listitem_T *const item)+  FUNC_ATTR_NONNULL_ALL+{+  for (listwatch_T *lw = l->lv_watch; lw != NULL; lw = lw->lw_next) {+    if (lw->lw_item == item) {+      lw->lw_item = item->li_next;+    }+  }+}++//{{{2 Alloc/free++/// Allocate an empty list+///+/// Caller should take care of the reference count.+///+/// @return [allocated] new list.+list_T *tv_list_alloc(void)+  FUNC_ATTR_NONNULL_RET FUNC_ATTR_MALLOC+{+  list_T *const list = xcalloc(1, sizeof(list_T));++  // Prepend the list to the list of lists for garbage collection.+  if (gc_first_list != NULL) {+    gc_first_list->lv_used_prev = list;+  }+  list->lv_used_prev = NULL;+  list->lv_used_next = gc_first_list;+  gc_first_list = list;+  return list;+}++/// Free items contained in a list+///+/// @param[in,out]  l  List to clear.+void tv_list_free_contents(list_T *const l)+  FUNC_ATTR_NONNULL_ALL+{+  for (listitem_T *item = l->lv_first; item != NULL; item = l->lv_first) {+    // Remove the item before deleting it.+    l->lv_first = item->li_next;+    tv_clear(&item->li_tv);+    xfree(item);+  }+  l->lv_len = 0;+  l->lv_idx_item = NULL;+  l->lv_last = NULL;+  assert(l->lv_watch == NULL);+}++/// Free a list itself, ignoring items it contains+///+/// Ignores the reference count.+///+/// @param[in,out]  l  List to free.+void tv_list_free_list(list_T *const l)+  FUNC_ATTR_NONNULL_ALL+{+  // Remove the list from the list of lists for garbage collection.+  if (l->lv_used_prev == NULL) {+    gc_first_list = l->lv_used_next;+  } else {+    l->lv_used_prev->lv_used_next = l->lv_used_next;+  }+  if (l->lv_used_next != NULL) {+    l->lv_used_next->lv_used_prev = l->lv_used_prev;+  }++  xfree(l);+}++/// Free a list, including all items it points to+///+/// Ignores the reference count. Does not do anything if+/// tv_in_free_unref_items is true.+///+/// @param[in,out]  l  List to free.+void tv_list_free(list_T *const l)+  FUNC_ATTR_NONNULL_ALL+{+  if (!tv_in_free_unref_items) {+    tv_list_free_contents(l);+    tv_list_free_list(l);+  }+}++/// Unreference a list+///+/// Decrements the reference count and frees when it becomes zero or less.+///+/// @param[in,out]  l  List to unreference.+void tv_list_unref(list_T *const l)+{+  if (l != NULL && --l->lv_refcount <= 0) {+    tv_list_free(l);+  }+}++//{{{2 Add/remove++/// Remove items ""item"" to ""item2"" from list ""l"".+///+/// @warning Does not free the listitem or the value!+///+/// @param[out]  l  List to remove from.+/// @param[in]  item  First item to remove.+/// @param[in]  item2  Last item to remove.+void tv_list_remove_items(list_T *const l, listitem_T *const item,+                          listitem_T *const item2)+  FUNC_ATTR_NONNULL_ALL+{+  // Notify watchers.+  for (listitem_T *ip = item; ip != item2->li_next; ip = ip->li_next) {+    l->lv_len--;+    tv_list_watch_fix(l, ip);+  }++  if (item2->li_next == NULL) {+    l->lv_last = item->li_prev;+  } else {+    item2->li_next->li_prev = item->li_prev;+  }+  if (item->li_prev == NULL) {+    l->lv_first = item2->li_next;+  } else {+    item->li_prev->li_next = item2->li_next;+  }+  l->lv_idx_item = NULL;+}++/// Insert list item+///+/// @param[out]  l  List to insert to.+/// @param[in,out]  ni  Item to insert.+/// @param[in]  item  Item to insert before. If NULL, inserts at the end of the","`item` needs to be in list `l`, is this obvious?",X
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/5119,108468556,2017-03-28T16:22:19Z,src/nvim/eval/typval.c,"@@ -0,0 +1,2556 @@+#include <stdio.h>+#include <stddef.h>+#include <string.h>+#include <assert.h>+#include <stdbool.h>++#include ""nvim/lib/queue.h""+#include ""nvim/eval/typval.h""+#include ""nvim/eval/gc.h""+#include ""nvim/eval/executor.h""+#include ""nvim/eval/encode.h""+#include ""nvim/eval/typval_encode.h""+#include ""nvim/eval.h""+#include ""nvim/types.h""+#include ""nvim/assert.h""+#include ""nvim/memory.h""+#include ""nvim/globals.h""+#include ""nvim/hashtab.h""+#include ""nvim/vim.h""+#include ""nvim/ascii.h""+#include ""nvim/pos.h""+#include ""nvim/charset.h""+#include ""nvim/garray.h""+#include ""nvim/gettext.h""+#include ""nvim/macros.h""+#include ""nvim/mbyte.h""+#include ""nvim/message.h""+// TODO(ZyX-I): Move line_breakcheck out of misc1+#include ""nvim/misc1.h""  // For line_breakcheck++#ifdef INCLUDE_GENERATED_DECLARATIONS+# include ""eval/typval.c.generated.h""+#endif++bool tv_in_free_unref_items = false;++// TODO(ZyX-I): Remove DICT_MAXNEST, make users be non-recursive instead++#define DICT_MAXNEST 100++const char *const tv_empty_string = """";++//{{{1 Lists+//{{{2 List item++/// Allocate a list item+///+/// @warning Allocated item is not initialized, do not forget to initialize it+///          and specifically set lv_lock.+///+/// @return [allocated] new list item.+listitem_T *tv_list_item_alloc(void)+  FUNC_ATTR_NONNULL_RET FUNC_ATTR_MALLOC+{+  return xmalloc(sizeof(listitem_T));+}++/// Free a list item+///+/// Also clears the value. Does not touch watchers.+///+/// @param[out]  item  Item to free.+void tv_list_item_free(listitem_T *const item)+  FUNC_ATTR_NONNULL_ALL+{+  tv_clear(&item->li_tv);+  xfree(item);+}++/// Remove a list item from a List and free it+///+/// Also clears the value.+///+/// @param[out]  l  List to remove item from.+/// @param[in,out]  item  Item to remove.+void tv_list_item_remove(list_T *const l, listitem_T *const item)+  FUNC_ATTR_NONNULL_ALL+{+  tv_list_remove_items(l, item, item);+  tv_list_item_free(item);+}++//{{{2 List watchers++/// Add a watcher to a list+///+/// @param[out]  l  List to add watcher to.+/// @param[in]  lw  Watcher to add.+void tv_list_watch_add(list_T *const l, listwatch_T *const lw)+  FUNC_ATTR_NONNULL_ALL+{+  lw->lw_next = l->lv_watch;+  l->lv_watch = lw;+}++/// Remove a watcher from a list+///+/// Does not give a warning if watcher was not found.+///+/// @param[out]  l  List to remove watcher from.+/// @param[in]  lwrem  Watcher to remove.+void tv_list_watch_remove(list_T *const l, listwatch_T *const lwrem)+  FUNC_ATTR_NONNULL_ALL+{+  listwatch_T **lwp = &l->lv_watch;+  for (listwatch_T *lw = l->lv_watch; lw != NULL; lw = lw->lw_next) {+    if (lw == lwrem) {+      *lwp = lw->lw_next;+      break;+    }+    lwp = &lw->lw_next;+  }+}++/// Advance watchers to the next item+///+/// Used just before removing an item from a list.+///+/// @param[out]  l  List from which item is removed.+/// @param[in]  item  List item being removed.+void tv_list_watch_fix(list_T *const l, const listitem_T *const item)+  FUNC_ATTR_NONNULL_ALL+{+  for (listwatch_T *lw = l->lv_watch; lw != NULL; lw = lw->lw_next) {+    if (lw->lw_item == item) {+      lw->lw_item = item->li_next;+    }+  }+}++//{{{2 Alloc/free++/// Allocate an empty list+///+/// Caller should take care of the reference count.+///+/// @return [allocated] new list.+list_T *tv_list_alloc(void)+  FUNC_ATTR_NONNULL_RET FUNC_ATTR_MALLOC+{+  list_T *const list = xcalloc(1, sizeof(list_T));++  // Prepend the list to the list of lists for garbage collection.+  if (gc_first_list != NULL) {+    gc_first_list->lv_used_prev = list;+  }+  list->lv_used_prev = NULL;+  list->lv_used_next = gc_first_list;+  gc_first_list = list;+  return list;+}++/// Free items contained in a list+///+/// @param[in,out]  l  List to clear.+void tv_list_free_contents(list_T *const l)+  FUNC_ATTR_NONNULL_ALL+{+  for (listitem_T *item = l->lv_first; item != NULL; item = l->lv_first) {+    // Remove the item before deleting it.+    l->lv_first = item->li_next;+    tv_clear(&item->li_tv);+    xfree(item);+  }+  l->lv_len = 0;+  l->lv_idx_item = NULL;+  l->lv_last = NULL;+  assert(l->lv_watch == NULL);+}++/// Free a list itself, ignoring items it contains+///+/// Ignores the reference count.+///+/// @param[in,out]  l  List to free.+void tv_list_free_list(list_T *const l)+  FUNC_ATTR_NONNULL_ALL+{+  // Remove the list from the list of lists for garbage collection.+  if (l->lv_used_prev == NULL) {+    gc_first_list = l->lv_used_next;+  } else {+    l->lv_used_prev->lv_used_next = l->lv_used_next;+  }+  if (l->lv_used_next != NULL) {+    l->lv_used_next->lv_used_prev = l->lv_used_prev;+  }++  xfree(l);+}++/// Free a list, including all items it points to+///+/// Ignores the reference count. Does not do anything if+/// tv_in_free_unref_items is true.+///+/// @param[in,out]  l  List to free.+void tv_list_free(list_T *const l)+  FUNC_ATTR_NONNULL_ALL+{+  if (!tv_in_free_unref_items) {+    tv_list_free_contents(l);+    tv_list_free_list(l);+  }+}++/// Unreference a list+///+/// Decrements the reference count and frees when it becomes zero or less.+///+/// @param[in,out]  l  List to unreference.+void tv_list_unref(list_T *const l)+{+  if (l != NULL && --l->lv_refcount <= 0) {+    tv_list_free(l);+  }+}++//{{{2 Add/remove++/// Remove items ""item"" to ""item2"" from list ""l"".+///+/// @warning Does not free the listitem or the value!+///+/// @param[out]  l  List to remove from.+/// @param[in]  item  First item to remove.+/// @param[in]  item2  Last item to remove.+void tv_list_remove_items(list_T *const l, listitem_T *const item,+                          listitem_T *const item2)+  FUNC_ATTR_NONNULL_ALL+{+  // Notify watchers.+  for (listitem_T *ip = item; ip != item2->li_next; ip = ip->li_next) {+    l->lv_len--;+    tv_list_watch_fix(l, ip);+  }++  if (item2->li_next == NULL) {+    l->lv_last = item->li_prev;+  } else {+    item2->li_next->li_prev = item->li_prev;+  }+  if (item->li_prev == NULL) {+    l->lv_first = item2->li_next;+  } else {+    item->li_prev->li_next = item2->li_next;+  }+  l->lv_idx_item = NULL;+}++/// Insert list item+///+/// @param[out]  l  List to insert to.+/// @param[in,out]  ni  Item to insert.+/// @param[in]  item  Item to insert before. If NULL, inserts at the end of the",This looks obvious: how would you insert to a list before an item not in a list?,X
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/5119,108473514,2017-03-28T16:43:51Z,src/nvim/eval/typval.c,"@@ -0,0 +1,2556 @@+#include <stdio.h>+#include <stddef.h>+#include <string.h>+#include <assert.h>+#include <stdbool.h>++#include ""nvim/lib/queue.h""+#include ""nvim/eval/typval.h""+#include ""nvim/eval/gc.h""+#include ""nvim/eval/executor.h""+#include ""nvim/eval/encode.h""+#include ""nvim/eval/typval_encode.h""+#include ""nvim/eval.h""+#include ""nvim/types.h""+#include ""nvim/assert.h""+#include ""nvim/memory.h""+#include ""nvim/globals.h""+#include ""nvim/hashtab.h""+#include ""nvim/vim.h""+#include ""nvim/ascii.h""+#include ""nvim/pos.h""+#include ""nvim/charset.h""+#include ""nvim/garray.h""+#include ""nvim/gettext.h""+#include ""nvim/macros.h""+#include ""nvim/mbyte.h""+#include ""nvim/message.h""+// TODO(ZyX-I): Move line_breakcheck out of misc1+#include ""nvim/misc1.h""  // For line_breakcheck++#ifdef INCLUDE_GENERATED_DECLARATIONS+# include ""eval/typval.c.generated.h""+#endif++bool tv_in_free_unref_items = false;++// TODO(ZyX-I): Remove DICT_MAXNEST, make users be non-recursive instead++#define DICT_MAXNEST 100++const char *const tv_empty_string = """";++//{{{1 Lists+//{{{2 List item++/// Allocate a list item+///+/// @warning Allocated item is not initialized, do not forget to initialize it+///          and specifically set lv_lock.+///+/// @return [allocated] new list item.+listitem_T *tv_list_item_alloc(void)+  FUNC_ATTR_NONNULL_RET FUNC_ATTR_MALLOC+{+  return xmalloc(sizeof(listitem_T));+}++/// Free a list item+///+/// Also clears the value. Does not touch watchers.+///+/// @param[out]  item  Item to free.+void tv_list_item_free(listitem_T *const item)+  FUNC_ATTR_NONNULL_ALL+{+  tv_clear(&item->li_tv);+  xfree(item);+}++/// Remove a list item from a List and free it+///+/// Also clears the value.+///+/// @param[out]  l  List to remove item from.+/// @param[in,out]  item  Item to remove.+void tv_list_item_remove(list_T *const l, listitem_T *const item)+  FUNC_ATTR_NONNULL_ALL+{+  tv_list_remove_items(l, item, item);+  tv_list_item_free(item);+}++//{{{2 List watchers++/// Add a watcher to a list+///+/// @param[out]  l  List to add watcher to.+/// @param[in]  lw  Watcher to add.+void tv_list_watch_add(list_T *const l, listwatch_T *const lw)+  FUNC_ATTR_NONNULL_ALL+{+  lw->lw_next = l->lv_watch;+  l->lv_watch = lw;+}++/// Remove a watcher from a list+///+/// Does not give a warning if watcher was not found.+///+/// @param[out]  l  List to remove watcher from.+/// @param[in]  lwrem  Watcher to remove.+void tv_list_watch_remove(list_T *const l, listwatch_T *const lwrem)+  FUNC_ATTR_NONNULL_ALL+{+  listwatch_T **lwp = &l->lv_watch;+  for (listwatch_T *lw = l->lv_watch; lw != NULL; lw = lw->lw_next) {+    if (lw == lwrem) {+      *lwp = lw->lw_next;+      break;+    }+    lwp = &lw->lw_next;+  }+}++/// Advance watchers to the next item+///+/// Used just before removing an item from a list.+///+/// @param[out]  l  List from which item is removed.+/// @param[in]  item  List item being removed.+void tv_list_watch_fix(list_T *const l, const listitem_T *const item)+  FUNC_ATTR_NONNULL_ALL+{+  for (listwatch_T *lw = l->lv_watch; lw != NULL; lw = lw->lw_next) {+    if (lw->lw_item == item) {+      lw->lw_item = item->li_next;+    }+  }+}++//{{{2 Alloc/free++/// Allocate an empty list+///+/// Caller should take care of the reference count.+///+/// @return [allocated] new list.+list_T *tv_list_alloc(void)+  FUNC_ATTR_NONNULL_RET FUNC_ATTR_MALLOC+{+  list_T *const list = xcalloc(1, sizeof(list_T));++  // Prepend the list to the list of lists for garbage collection.+  if (gc_first_list != NULL) {+    gc_first_list->lv_used_prev = list;+  }+  list->lv_used_prev = NULL;+  list->lv_used_next = gc_first_list;+  gc_first_list = list;+  return list;+}++/// Free items contained in a list+///+/// @param[in,out]  l  List to clear.+void tv_list_free_contents(list_T *const l)+  FUNC_ATTR_NONNULL_ALL+{+  for (listitem_T *item = l->lv_first; item != NULL; item = l->lv_first) {+    // Remove the item before deleting it.+    l->lv_first = item->li_next;+    tv_clear(&item->li_tv);+    xfree(item);+  }+  l->lv_len = 0;+  l->lv_idx_item = NULL;+  l->lv_last = NULL;+  assert(l->lv_watch == NULL);+}++/// Free a list itself, ignoring items it contains+///+/// Ignores the reference count.+///+/// @param[in,out]  l  List to free.+void tv_list_free_list(list_T *const l)+  FUNC_ATTR_NONNULL_ALL+{+  // Remove the list from the list of lists for garbage collection.+  if (l->lv_used_prev == NULL) {+    gc_first_list = l->lv_used_next;+  } else {+    l->lv_used_prev->lv_used_next = l->lv_used_next;+  }+  if (l->lv_used_next != NULL) {+    l->lv_used_next->lv_used_prev = l->lv_used_prev;+  }++  xfree(l);+}++/// Free a list, including all items it points to+///+/// Ignores the reference count. Does not do anything if+/// tv_in_free_unref_items is true.+///+/// @param[in,out]  l  List to free.+void tv_list_free(list_T *const l)+  FUNC_ATTR_NONNULL_ALL+{+  if (!tv_in_free_unref_items) {+    tv_list_free_contents(l);+    tv_list_free_list(l);+  }+}++/// Unreference a list+///+/// Decrements the reference count and frees when it becomes zero or less.+///+/// @param[in,out]  l  List to unreference.+void tv_list_unref(list_T *const l)+{+  if (l != NULL && --l->lv_refcount <= 0) {+    tv_list_free(l);+  }+}++//{{{2 Add/remove++/// Remove items ""item"" to ""item2"" from list ""l"".+///+/// @warning Does not free the listitem or the value!+///+/// @param[out]  l  List to remove from.+/// @param[in]  item  First item to remove.+/// @param[in]  item2  Last item to remove.+void tv_list_remove_items(list_T *const l, listitem_T *const item,+                          listitem_T *const item2)+  FUNC_ATTR_NONNULL_ALL+{+  // Notify watchers.+  for (listitem_T *ip = item; ip != item2->li_next; ip = ip->li_next) {+    l->lv_len--;+    tv_list_watch_fix(l, ip);+  }++  if (item2->li_next == NULL) {+    l->lv_last = item->li_prev;+  } else {+    item2->li_next->li_prev = item->li_prev;+  }+  if (item->li_prev == NULL) {+    l->lv_first = item2->li_next;+  } else {+    item->li_prev->li_next = item2->li_next;+  }+  l->lv_idx_item = NULL;+}++/// Insert list item+///+/// @param[out]  l  List to insert to.+/// @param[in,out]  ni  Item to insert.+/// @param[in]  item  Item to insert before. If NULL, inserts at the end of the","If `item` is the first element in another list, we would only have access to the old items of `l` with `l->lv_last`. `l->lv_first` would point to the list items of the other list (and `ni`).",X
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/5119,108482559,2017-03-28T17:22:02Z,src/nvim/eval/typval.c,"@@ -0,0 +1,2556 @@+#include <stdio.h>+#include <stddef.h>+#include <string.h>+#include <assert.h>+#include <stdbool.h>++#include ""nvim/lib/queue.h""+#include ""nvim/eval/typval.h""+#include ""nvim/eval/gc.h""+#include ""nvim/eval/executor.h""+#include ""nvim/eval/encode.h""+#include ""nvim/eval/typval_encode.h""+#include ""nvim/eval.h""+#include ""nvim/types.h""+#include ""nvim/assert.h""+#include ""nvim/memory.h""+#include ""nvim/globals.h""+#include ""nvim/hashtab.h""+#include ""nvim/vim.h""+#include ""nvim/ascii.h""+#include ""nvim/pos.h""+#include ""nvim/charset.h""+#include ""nvim/garray.h""+#include ""nvim/gettext.h""+#include ""nvim/macros.h""+#include ""nvim/mbyte.h""+#include ""nvim/message.h""+// TODO(ZyX-I): Move line_breakcheck out of misc1+#include ""nvim/misc1.h""  // For line_breakcheck++#ifdef INCLUDE_GENERATED_DECLARATIONS+# include ""eval/typval.c.generated.h""+#endif++bool tv_in_free_unref_items = false;++// TODO(ZyX-I): Remove DICT_MAXNEST, make users be non-recursive instead++#define DICT_MAXNEST 100++const char *const tv_empty_string = """";++//{{{1 Lists+//{{{2 List item++/// Allocate a list item+///+/// @warning Allocated item is not initialized, do not forget to initialize it+///          and specifically set lv_lock.+///+/// @return [allocated] new list item.+listitem_T *tv_list_item_alloc(void)+  FUNC_ATTR_NONNULL_RET FUNC_ATTR_MALLOC+{+  return xmalloc(sizeof(listitem_T));+}++/// Free a list item+///+/// Also clears the value. Does not touch watchers.+///+/// @param[out]  item  Item to free.+void tv_list_item_free(listitem_T *const item)+  FUNC_ATTR_NONNULL_ALL+{+  tv_clear(&item->li_tv);+  xfree(item);+}++/// Remove a list item from a List and free it+///+/// Also clears the value.+///+/// @param[out]  l  List to remove item from.+/// @param[in,out]  item  Item to remove.+void tv_list_item_remove(list_T *const l, listitem_T *const item)+  FUNC_ATTR_NONNULL_ALL+{+  tv_list_remove_items(l, item, item);+  tv_list_item_free(item);+}++//{{{2 List watchers++/// Add a watcher to a list+///+/// @param[out]  l  List to add watcher to.+/// @param[in]  lw  Watcher to add.+void tv_list_watch_add(list_T *const l, listwatch_T *const lw)+  FUNC_ATTR_NONNULL_ALL+{+  lw->lw_next = l->lv_watch;+  l->lv_watch = lw;+}++/// Remove a watcher from a list+///+/// Does not give a warning if watcher was not found.+///+/// @param[out]  l  List to remove watcher from.+/// @param[in]  lwrem  Watcher to remove.+void tv_list_watch_remove(list_T *const l, listwatch_T *const lwrem)+  FUNC_ATTR_NONNULL_ALL+{+  listwatch_T **lwp = &l->lv_watch;+  for (listwatch_T *lw = l->lv_watch; lw != NULL; lw = lw->lw_next) {+    if (lw == lwrem) {+      *lwp = lw->lw_next;+      break;+    }+    lwp = &lw->lw_next;+  }+}++/// Advance watchers to the next item+///+/// Used just before removing an item from a list.+///+/// @param[out]  l  List from which item is removed.+/// @param[in]  item  List item being removed.+void tv_list_watch_fix(list_T *const l, const listitem_T *const item)+  FUNC_ATTR_NONNULL_ALL+{+  for (listwatch_T *lw = l->lv_watch; lw != NULL; lw = lw->lw_next) {+    if (lw->lw_item == item) {+      lw->lw_item = item->li_next;+    }+  }+}++//{{{2 Alloc/free++/// Allocate an empty list+///+/// Caller should take care of the reference count.+///+/// @return [allocated] new list.+list_T *tv_list_alloc(void)+  FUNC_ATTR_NONNULL_RET FUNC_ATTR_MALLOC+{+  list_T *const list = xcalloc(1, sizeof(list_T));++  // Prepend the list to the list of lists for garbage collection.+  if (gc_first_list != NULL) {+    gc_first_list->lv_used_prev = list;+  }+  list->lv_used_prev = NULL;+  list->lv_used_next = gc_first_list;+  gc_first_list = list;+  return list;+}++/// Free items contained in a list+///+/// @param[in,out]  l  List to clear.+void tv_list_free_contents(list_T *const l)+  FUNC_ATTR_NONNULL_ALL+{+  for (listitem_T *item = l->lv_first; item != NULL; item = l->lv_first) {+    // Remove the item before deleting it.+    l->lv_first = item->li_next;+    tv_clear(&item->li_tv);+    xfree(item);+  }+  l->lv_len = 0;+  l->lv_idx_item = NULL;+  l->lv_last = NULL;+  assert(l->lv_watch == NULL);+}++/// Free a list itself, ignoring items it contains+///+/// Ignores the reference count.+///+/// @param[in,out]  l  List to free.+void tv_list_free_list(list_T *const l)+  FUNC_ATTR_NONNULL_ALL+{+  // Remove the list from the list of lists for garbage collection.+  if (l->lv_used_prev == NULL) {+    gc_first_list = l->lv_used_next;+  } else {+    l->lv_used_prev->lv_used_next = l->lv_used_next;+  }+  if (l->lv_used_next != NULL) {+    l->lv_used_next->lv_used_prev = l->lv_used_prev;+  }++  xfree(l);+}++/// Free a list, including all items it points to+///+/// Ignores the reference count. Does not do anything if+/// tv_in_free_unref_items is true.+///+/// @param[in,out]  l  List to free.+void tv_list_free(list_T *const l)+  FUNC_ATTR_NONNULL_ALL+{+  if (!tv_in_free_unref_items) {+    tv_list_free_contents(l);+    tv_list_free_list(l);+  }+}++/// Unreference a list+///+/// Decrements the reference count and frees when it becomes zero or less.+///+/// @param[in,out]  l  List to unreference.+void tv_list_unref(list_T *const l)+{+  if (l != NULL && --l->lv_refcount <= 0) {+    tv_list_free(l);+  }+}++//{{{2 Add/remove++/// Remove items ""item"" to ""item2"" from list ""l"".+///+/// @warning Does not free the listitem or the value!+///+/// @param[out]  l  List to remove from.+/// @param[in]  item  First item to remove.+/// @param[in]  item2  Last item to remove.+void tv_list_remove_items(list_T *const l, listitem_T *const item,+                          listitem_T *const item2)+  FUNC_ATTR_NONNULL_ALL+{+  // Notify watchers.+  for (listitem_T *ip = item; ip != item2->li_next; ip = ip->li_next) {+    l->lv_len--;+    tv_list_watch_fix(l, ip);+  }++  if (item2->li_next == NULL) {+    l->lv_last = item->li_prev;+  } else {+    item2->li_next->li_prev = item->li_prev;+  }+  if (item->li_prev == NULL) {+    l->lv_first = item2->li_next;+  } else {+    item->li_prev->li_next = item2->li_next;+  }+  l->lv_idx_item = NULL;+}++/// Insert list item+///+/// @param[out]  l  List to insert to.+/// @param[in,out]  ni  Item to insert.+/// @param[in]  item  Item to insert before. If NULL, inserts at the end of the","I know that you can do weird things if you pass random pointers around. This still does not make sense to take a list, an item from the other list and expect this function to do something sane with its description.",X
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/6366,108812739,2017-03-29T23:37:25Z,src/nvim/log.h,"@@ -69,6 +69,32 @@  #endif +#if __linux__ && MIN_LOG_LEVEL <= DEBUG_LOG_LEVEL+#  include <execinfo.h>+#  define DLOG_CALL_STACK(prefix) \","I would think this wouldn't be used except for temporary debugging calls, right? So it could be `MIN_LOG_LEVEL <= INFO_LOG_LEVEL`, and named `LOG_CALLSTACK`. ",X
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/6406,108963373,2017-03-30T15:48:05Z,src/nvim/eval/decode.c,"@@ -973,7 +973,13 @@ int msgpack_to_vim(const msgpack_object mobj, typval_T *const rettv)       }       break;     }-    case MSGPACK_OBJECT_FLOAT: {+#ifdef NVIM_MSGPACK_HAS_FLOAT32",Can't we test `MSGPACK_VERSION_*` instead? https://github.com/msgpack/msgpack-c/blob/master/include/msgpack/version.hThat also avoids the extra cmake code.,X
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/6409,109163578,2017-03-31T13:49:31Z,ci/common/suite.sh,"@@ -1,3 +1,7 @@+# HACK: get newline for use in strings given that ""\n"" and $'' do not work.+NL=""$(printf '\nE')""",This works only as long as you run it on the zero level of indentation. Move NL definition to some function and this is no longer an option.,X
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/6418,109284884,2017-04-01T13:21:05Z,test/unit/testtest_spec.lua,"@@ -0,0 +1,19 @@+local helpers = require('test.unit.helpers')(after_each)+local assert = require('luassert')++local itp = helpers.gen_itp(it)++local sc = helpers.sc++-- All of the below tests must fail. Check how exactly they fail.+if os.getenv('NVIM_TEST_RUN_TESTTEST') ~= '1' then+  return+end","Let's just put `return` here, with a comment. That avoids another env var. Commenting-out the `return` is the same amount of temporary work as setting `NVIM_TEST_RUN_TESTTEST`, with less noise in the documentation (and environment)",X
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/6418,109290117,2017-04-01T17:48:43Z,test/unit/testtest_spec.lua,"@@ -0,0 +1,19 @@+local helpers = require('test.unit.helpers')(after_each)+local assert = require('luassert')++local itp = helpers.gen_itp(it)++local sc = helpers.sc++-- All of the below tests must fail. Check how exactly they fail.+if os.getenv('NVIM_TEST_RUN_TESTTEST') ~= '1' then+  return+end","Amount of work is not the same at all:1. I run tests in one terminal, develop in another. To run this file I need to get command from history with environment variable temporary set in the command, this is almost no work needed. Not the same if you do commenting/uncommenting: switch to another terminal, uncomment, save, switch back, run, switch, comment, save.2. Commenting/uncommenting is very prone to forgetting to uncomment back and make the change inside a commit.",X
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/6236,109318052,2017-04-02T19:47:36Z,src/nvim/api/vim.c,"@@ -695,6 +696,73 @@ Dictionary nvim_get_color_map(void)   return colors; } +// Helper function for nvim_get_keymap and nvim_buf_get_keymap+// @param mode The abbreviation for the mode+// @param buffer_id+//      -1: Global mapping+//      0: Current buffer+//      else: The desired buffer ID+//+// @returns An array of maparg() like dictionaries describing mappings+static Array get_keymap_helper(String mode, Integer buffer_id)","Avoid naming anything ""helper"". All code is presumably helpful, so it doesn't add information. Just `keymap_array()` is an OK name for this, analogous to `cursor_shape_dict()`.",X
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/6236,109325017,2017-04-03T00:24:48Z,src/nvim/eval.c,"@@ -13358,26 +13358,38 @@ static void get_maparg(typval_T *argvars, typval_T *rettv, int exact)     rettv_dict_alloc(rettv);     if (rhs != NULL) {       // Return a dictionary.-      char_u *lhs = str2special_save(mp->m_keys, true);-      char *const mapmode = map_mode_to_chars(mp->m_mode);-      dict_T *dict = rettv->vval.v_dict;--      dict_add_nr_str(dict, ""lhs"",     0L, lhs);-      dict_add_nr_str(dict, ""rhs"",     0L, mp->m_orig_str);-      dict_add_nr_str(dict, ""noremap"", mp->m_noremap ? 1L : 0L, NULL);-      dict_add_nr_str(dict, ""expr"",    mp->m_expr    ? 1L : 0L, NULL);-      dict_add_nr_str(dict, ""silent"",  mp->m_silent  ? 1L : 0L, NULL);-      dict_add_nr_str(dict, ""sid"",     (long)mp->m_script_ID, NULL);-      dict_add_nr_str(dict, ""buffer"",  (long)buffer_local, NULL);-      dict_add_nr_str(dict, ""nowait"",  mp->m_nowait  ? 1L : 0L, NULL);-      dict_add_nr_str(dict, ""mode"",    0L, (char_u *)mapmode);--      xfree(lhs);-      xfree(mapmode);+      mapblock_fill_dict(rettv->vval.v_dict, mp, buffer_local, true);     }   } } +/// Fill a dictionary with all applicable maparg() like dictionaries+///+/// @param  dict  The dictionary to be filled+/// @param  mp  The maphash that contains the mapping information+/// @param  buffer_value  The ""buffer"" value+/// @param  compatible  True for compatible with old maparg() dict+void mapblock_fill_dict(dict_T *const dict, const mapblock_T *const mp, long buffer_value, bool compatible)+  FUNC_ATTR_NONNULL_ALL+{+  char_u *lhs = str2special_save(mp->m_keys, true);+  char *const mapmode = map_mode_to_chars(mp->m_mode);++  dict_add_nr_str(dict, ""lhs"",     0L, lhs);+  dict_add_nr_str(dict, ""rhs"",     0L, mp->m_orig_str);+  dict_add_nr_str(dict, ""noremap"", mp->m_noremap ? 1L : 0L, NULL);+  dict_add_nr_str(dict, ""expr"",    mp->m_expr    ? 1L : 0L, NULL);+  dict_add_nr_str(dict, ""silent"",  mp->m_silent  ? 1L : 0L, NULL);+  dict_add_nr_str(dict, ""sid"",     (long)mp->m_script_ID, NULL);+  dict_add_nr_str(dict, ""buffer"",  buffer_value, NULL);++  dict_add_nr_str(dict, ""nowait"",  mp->m_nowait  ? 1L : 0L, NULL);+  dict_add_nr_str(dict, ""mode"",    0L, (char_u *)mapmode);","And you need to rebase, `dict_add_nr_str` function is no longer there. Now have `tv_dict_add���` functions, separate for strings and numbers.",X
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/6236,109412961,2017-04-03T13:13:47Z,test/functional/api/map_spec.lua,"@@ -0,0 +1,99 @@+","consider naming the file `keymap_spec`, to parallel the API function names",X
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/6383,109415685,2017-04-03T13:26:45Z,src/nvim/os/pty_process_win.c,"@@ -182,6 +195,19 @@ static void pty_process_connect_cb(uv_connect_t *req, int status)   req->handle = NULL; } +static void wait_eof_timer_cb(uv_timer_t *wait_eof_timer)+  FUNC_ATTR_NONNULL_ALL+{+  PtyProcess *ptyproc =+    (PtyProcess *)((uv_handle_t *)wait_eof_timer->data);","we don't cast `void *` pointers, instead just:    PtyProcess *ptyproc = wait_eof_timer->data;",X
886074,teto,https://api.github.com/repos/neovim/neovim/pulls/6322,109508630,2017-04-03T19:52:37Z,runtime/doc/eval.txt,"@@ -5449,6 +5449,30 @@ max({list})	Return the maximum value of all items in {list}. 		be used as a Number this results in an error. 		An empty |List| results in zero. +menu_get({path}, {modes})				*dump_menu()*+		Returns a |Dictionary| with all the submenu of {path} (set to +		an empty string to match all menus). Only the commands matching {modes} are +		returned ('a' for all, 'i' for insert see |creating-menus|).++    For instance, executing:+<+    nnoremenu &Test.Test inormal+    inoremenu Test.Test insert+    vnoremenu Test.Test x+    echo menu_get("""")+>+should produce:+<+[+{'hidden': 0, 'submenus':+  [{'hidden': 0, 'name': 'Test', 'priority': 500, 'shortcut': 0, 'implementations':+ {'s': {'noremap': 1, 'enabled': 1, 'silent': 0, 'sid': 1, 'rhs': 'x'}, 'v': {'noremap': 1, 'enabled': 1, 's+ilent': 0, 'sid': 1, 'rhs': 'x'}, 'i': {'noremap': 1, 'enabled': 1, 'silent': 0, 'sid': 1, 'rhs': 'insert'},+ 'n': {'noremap': 1, 'enabled': 1, 'silent': 0, 'sid': 1, 'rhs': 'inormal'}}}], 'name': 'Test', 'priority':+500, 'shortcut': 84}+]","ZyX-l suggested to add an example, too bad we can't generate it from the code. is there any vim-prettify that I could use to properly format this part ?",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/6236,109575121,2017-04-04T04:29:39Z,test/functional/api/keymap_spec.lua,"@@ -0,0 +1,243 @@++local helpers = require('test.functional.helpers')(after_each)+local clear = helpers.clear+local eq = helpers.eq+local eval = helpers.eval+local funcs = helpers.funcs+local nvim = helpers.nvim+local source = helpers.source++local function local_copy(t)+  local copy = {}+  for k,v in pairs(t) do+    copy[k] = v+  end+  return copy+end++describe('get_keymap', function()+  before_each(clear)++  -- Basic mapping and table to be used to describe results+  local foo_bar_string = 'nnoremap foo bar'+  local foo_bar_map_table = {+      lhs='foo',+      silent=0,+      rhs='bar',+      expr=0,+      sid=0,+      buffer=0,+      nowait=0,+      mode='n',+      noremap=1,+    }++  it('returns empty list when no map', function()+    eq({}, nvim('get_keymap', 'n'))+  end)++  it('returns list of all applicable mappings', function()+    nvim('command', foo_bar_string)+    -- Only one mapping available+    -- Should be the same as the dictionary we supplied earlier+    -- and the dictionary you would get from maparg+    -- since this is a global map, and not script local+    eq({foo_bar_map_table}, nvim('get_keymap', 'n'))+    eq(+      {funcs.maparg('foo', 'n', false, true)},+      nvim('get_keymap', 'n')+    )++    -- Add another mapping+    nvim('command', 'nnoremap foo_longer bar_longer')+    local foolong_bar_map_table = local_copy(foo_bar_map_table)+    foolong_bar_map_table['lhs'] = 'foo_longer'+    foolong_bar_map_table['rhs'] = 'bar_longer'++    eq(+      {foolong_bar_map_table, foo_bar_map_table},+      nvim('get_keymap', 'n')+    )++    -- Remove a mapping+    nvim('command', 'unmap foo_longer')+    eq(+      {foo_bar_map_table},+      nvim('get_keymap', 'n')+    )+  end)++  it('works for other modes', function()+    -- Add two mappings, one in insert and one normal+    -- We'll only check the insert mode one+    nvim('command', 'nnoremap not_going to_check')++    nvim('command', 'inoremap foo bar')+    -- The table will be the same except for the mode+    local insert_table = local_copy(foo_bar_map_table)+    insert_table['mode'] = 'i'++    eq({insert_table}, nvim('get_keymap', 'i'))+  end)++  it('works for other modes with modifiers', function()+    -- Add two mappings, one in insert and one normal+    -- We'll only check the insert mode one+    nvim('command', 'nnoremap not_going to_check')++    nvim('command', 'inoremap <nowait> foo bar')+    -- The table will be the same except for the mode+    local insert_table = local_copy(foo_bar_map_table)+    insert_table['mode'] = 'i'+    insert_table['nowait'] = 1++    eq({insert_table}, nvim('get_keymap', 'i'))+  end)++  it('considers scope', function()+    -- change the map slightly and add a <nowait> option to the map+    nvim('command', 'nnoremap foo_longer bar_longer')+    local foolong_bar_map_table = local_copy(foo_bar_map_table)+    foolong_bar_map_table['lhs'] = 'foo_longer'+    foolong_bar_map_table['rhs'] = 'bar_longer'++    local foo_bar_buffer_string = 'nnoremap <buffer> foo bar'+    local buffer_table = local_copy(foo_bar_map_table)+    buffer_table['buffer'] = 1++    nvim('command', foo_bar_buffer_string)++    -- The buffer mapping should not show up+    eq({foolong_bar_map_table}, nvim('get_keymap', 'n'))+    eq({buffer_table}, nvim('buf_get_keymap', 0, 'n'))+  end)++  it('considers scope for overlapping maps', function()+    nvim('command', 'nnoremap foo bar')++    local buffer_table = local_copy(foo_bar_map_table)+    buffer_table['buffer'] = 1++    nvim('command', 'nnoremap <buffer> foo bar')++    eq({foo_bar_map_table}, nvim('get_keymap', 'n'))+    eq({buffer_table}, nvim('buf_get_keymap', 0, 'n'))+  end)++  -- Test toggle switches for basic options+  -- @param  option  The key represented in the `maparg()` result dict+  local function global_and_buffer_test(map,+                                        option,+                                        option_token,+                                        global_on_result,+                                        buffer_on_result,+                                        global_off_result,+                                        buffer_off_result,+                                        new_windows)++    local function make_new_windows(number_of_windows)+      if new_windows == nil then+        return nil+      end++      for _=1,number_of_windows do+        nvim('command', 'new')+      end+    end++    local mode = string.sub(map, 1,1)+    -- Don't run this for the <buffer> mapping, since it doesn't make sense+    if option_token ~= '<buffer>' then+      it(string.format( 'returns %d for the key ""%s"" when %s is used globally with %s (%s)',+          global_on_result, option, option_token, map, mode), function()+        make_new_windows(new_windows)+        nvim('command', map .. ' ' .. option_token .. ' foo bar')+        local result = nvim('get_keymap', mode)[1][option]+        eq(global_on_result, result)+      end)+    end++    it(string.format('returns %d for the key ""%s"" when %s is used for buffers with %s (%s)',+        buffer_on_result, option, option_token, map, mode), function()+      make_new_windows(new_windows)+      nvim('command', map .. ' <buffer> ' .. option_token .. ' foo bar')+      local result = nvim('buf_get_keymap', 0, mode)[1][option]+      eq(buffer_on_result, result)+    end)++    -- Don't run these for the <buffer> mapping, since it doesn't make sense+    if option_token ~= '<buffer>' then+      it(string.format('returns %d for the key ""%s"" when %s is not used globally with %s (%s)',+          global_off_result, option, option_token, map, mode), function()+        make_new_windows(new_windows)+        nvim('command', map .. ' baz bat')+        local result = nvim('get_keymap', mode)[1][option]+        eq(global_off_result, result)+      end)++      it(string.format('returns %d for the key ""%s"" when %s is not used for buffers with %s (%s)',+          buffer_off_result, option, option_token, map, mode), function()+        make_new_windows(new_windows)+        nvim('command', map .. ' <buffer> foo bar')++        local result = nvim('buf_get_keymap', 0, mode)[1][option]+        eq(buffer_off_result, result)+      end)+    end+  end++  -- Standard modes and backwards compatible+  local mode_list = {'nnoremap', 'nmap', 'imap', 'inoremap', 'cnoremap'}+  for mode in pairs(mode_list) do+    global_and_buffer_test(mode_list[mode], 'silent', '<silent>', 1, 1, 0, 0)+    global_and_buffer_test(mode_list[mode], 'nowait', '<nowait>', 1, 1, 0, 0)+    global_and_buffer_test(mode_list[mode], 'expr', '<expr>', 1, 1, 0, 0)+  end++  -- noremap will now be 2 if script was used, which is not backwards compatible+  global_and_buffer_test('nmap', 'noremap', '<script>', 2, 2, 0, 0)+  global_and_buffer_test('nnoremap', 'noremap', '<script>', 2, 2, 1, 1)++  -- buffer will return the buffer ID, which is not backwards compatible+  -- Three of these tests won't run+  global_and_buffer_test('nnoremap', 'buffer', '<buffer>', nil, 3, nil, nil, 2)++  it('returns script numbers for global maps', function()+    source([[+    function! s:maparg_test_function() abort+      return 'testing'+    endfunction++    nnoremap fizz :call <SID>maparg_test_function()<CR>+    ]])+    eq(1, nvim('get_keymap', 'n')[1]['sid'])+    eq('testing', nvim('call_function', '<SNR>1_maparg_test_function', {}))+  end)++  it('returns script numbers for buffer maps', function()+    source([[+    function! s:maparg_test_function() abort+      return 'testing'+    endfunction++    nnoremap <buffer> fizz :call <SID>maparg_test_function()<CR>+    ]])+    eq(1, nvim('buf_get_keymap', 0, 'n')[1]['sid'])+    eq('testing', nvim('call_function', '<SNR>1_maparg_test_function', {}))+  end)++  it('works with <F12> and others', function()+    source([[+    let g:maparg_test_var = 0++    nnoremap <F12> :let g:maparg_test_var = 1<CR>+    ]])+    eq(0, eval('g:maparg_test_var'))+    source([[+    call feedkeys(""\<F12>"")+    ]])","There is `[helpers.]feed('<F12>')`, though checking that mapping works is not required. `source` is an overkill unless you do need this: it is working with a temporary file thus is slow and should be omitted when possible.",X
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/6370,109869213,2017-04-05T09:28:53Z,src/nvim/getchar.c,"@@ -1577,729 +1577,843 @@ vungetc ( /* unget one character (can only be done once!) */   old_mouse_col = mouse_col; } -/// get a character:-/// 1. from the stuffbuffer-///    This is used for abbreviated commands like ""D"" -> ""d$"".-///    Also used to redo a command for ""."".-/// 2. from the typeahead buffer-///    Stores text obtained previously but not used yet.-///    Also stores the result of mappings.-///    Also used for the "":normal"" command.-/// 3. from the user-///    This may do a blocking wait if ""advance"" is TRUE.-///-/// if ""advance"" is TRUE (vgetc()):-///    really get the character.-///    KeyTyped is set to TRUE in the case the user typed the key.-///    KeyStuffed is TRUE if the character comes from the stuff buffer.-/// if ""advance"" is FALSE (vpeekc()):-///    just look whether there is a character available.-///-/// When ""no_mapping"" is zero, checks for mappings in the current mode.-/// Only returns one byte (of a multi-byte character).-/// K_SPECIAL and CSI may be escaped, need to get two more bytes then.-static int vgetorpeek(int advance)+static void do_insert_message(bool mode_deleted, int c, int advance) {-  int c, c1;-  int keylen;-  char_u      *s;-  mapblock_T  *mp;-  mapblock_T  *mp2;-  mapblock_T  *mp_match;-  int mp_match_len = 0;-  int timedout = FALSE;                     /* waited for more than 1 second-                                                for mapping to complete */-  int mapdepth = 0;                 /* check for recursive mapping */-  int mode_deleted = FALSE;             /* set when mode has been deleted */-  int local_State;+  // The ""INSERT"" message is taken care of here:+  //     if we return an ESC to exit insert mode, the message is deleted+  //     if we don't return an ESC but deleted the message before, redisplay it+  if (advance && p_smd && msg_silent == 0 && (State & INSERT)) {+    if (c == ESC && !mode_deleted && !no_mapping && mode_displayed) {+      if (typebuf.tb_len && !KeyTyped) {+        redraw_cmdline = true;              // delete mode later+      } else {+        unshowmode(false);+      }+    } else if (c != ESC && mode_deleted) {+      if (typebuf.tb_len && !KeyTyped) {+        redraw_cmdline = true;              // show mode later+      } else {+        showmode();+      }+    }+  }+}++static long calc_waittime(int keylen)+{+  if (typebuf.tb_len == 0) {+    return -1L;+  } else if (!p_timeout) {+    return -1L;+  } else if (!p_ttimeout && keylen == KEYLEN_PART_KEY) {+    return -1L;+  } else if (keylen == KEYLEN_PART_KEY && p_ttm >= 0) {+    return p_ttm;+  }++  return p_tm;+}++static int handle_int(int advance)+{+  // flush all input+  int c = inchar(typebuf.tb_buf, typebuf.tb_buflen - 1, 0L,+                 typebuf.tb_change_cnt);+  // If inchar() returns true (script file was active) or we+  // are inside a mapping, get out of insert mode.+  // Otherwise we behave like having gotten a CTRL-C.+  // As a result typing CTRL-C in insert mode will+  // really insert a CTRL-C.+  if ((c || typebuf.tb_maplen)+      && (State & (INSERT + CMDLINE))) {+    c = ESC;+  } else {+    c = Ctrl_C;+  }+  flush_buffers(true);                  // flush all typeahead++  if (advance) {+    // Also record this character, it might be needed to+    // get out of Insert mode.+    *typebuf.tb_buf = (char_u)c;+    gotchars(typebuf.tb_buf, 1);+  }+  cmd_silent = false;++  return c;+}++// Returns `true` if have toggled the 'paste' option, and hence should continue+// on to find the next character.+// Only changes *keylenp if it finds the start of the bytes required to toggle+// 'paste'. In that case *keylenp is set to KEYLEN_PART_KEY.+// If it finds no match in the typebuffer, because the typebuffer has+// characters that are different than required for toggling paste (i.e. not+// because the typebuffer finishes before a match has been completed).+static bool check_togglepaste(mapblock_T *mp, int *keylenp)+{+  if (mp != NULL || (State & (INSERT|NORMAL)) == 0) {+    return false;+  }++  // Check for a key that can toggle the 'paste' option   int mlen;-  int max_mlen;-  int i;-  int new_wcol, new_wrow;-  int n;-  int nolmaplen;-  int old_wcol, old_wrow;-  int wait_tb_len;+  bool match = typebuf_match_len(ui_toggle, &mlen);+  if (!match && mlen != typebuf.tb_len && *p_pt != NUL) {+    // didn't match ui_toggle_key and didn't try the whole typebuf,+    // check the 'pastetoggle'+    match = typebuf_match_len(p_pt, &mlen);+  }+  if (match) {+    // write chars to script file(s)+    if (mlen > typebuf.tb_maplen) {+      gotchars(typebuf.tb_buf + typebuf.tb_off + typebuf.tb_maplen,+               (size_t)(mlen - typebuf.tb_maplen));+    } -  /*-   * This function doesn't work very well when called recursively.  This may-   * happen though, because of:-   * 1. The call to add_to_showcmd().	char_avail() is then used to check if-   * there is a character available, which calls this function.  In that-   * case we must return NUL, to indicate no character is available.-   * 2. A GUI callback function writes to the screen, causing a-   * wait_return().-   * Using "":normal"" can also do this, but it saves the typeahead buffer,-   * thus it should be OK.  But don't get a key from the user then.-   */-  if (vgetc_busy > 0-      && ex_normal_busy == 0-      )-    return NUL;+    del_typebuf(mlen, 0);  // Remove the chars.+    set_option_value(""paste"", !p_paste, NULL, 0);+    if (!(State & INSERT)) {+      msg_col = 0;+      msg_row = (int)Rows - 1;+      msg_clr_eos();                          // clear ruler+    }+    status_redraw_all();+    redraw_statuslines();+    showmode();+    setcursor();+    return true;+  }+  // Need more chars for partly match.+  if (mlen == typebuf.tb_len) {+    *keylenp = KEYLEN_PART_KEY;+  } -  local_State = get_real_state();+  return false;+} -  ++vgetc_busy;+// Checks ""keylen"" to see if we've found a valid map in the typebuffer.+// If so, expand it in the typebuffer, increment *mapdepthp (and check we+// haven't exceeded the map recursion limit) and return `true`.+// If not, return false.+static bool expand_matched_map(mapblock_T *mp, const int keylen, int *mapdepthp)+{+  if (keylen < 0 || keylen > typebuf.tb_len) {+    return false;+  } -  if (advance)-    KeyStuffed = FALSE;+  // complete match+  int save_m_expr;+  int save_m_noremap;+  int save_m_silent;+  char_u *save_m_keys;+  char_u *save_m_str;++  // write chars to script file(s)+  if (keylen > typebuf.tb_maplen) {+    gotchars(typebuf.tb_buf + typebuf.tb_off + typebuf.tb_maplen,+             (size_t)(keylen - typebuf.tb_maplen));+  } -  init_typebuf();-  start_stuff();-  if (advance && typebuf.tb_maplen == 0)-    Exec_reg = FALSE;-  do {-    /*-     * get a character: 1. from the stuffbuffer-     */-    if (typeahead_char != 0) {-      c = typeahead_char;-      if (advance)-        typeahead_char = 0;+  cmd_silent = (typebuf.tb_silent > 0);+  del_typebuf(keylen, 0);             // remove the mapped keys++  // Put the replacement string in front of mapstr.+  // The depth check catches "":map x y"" and "":map y x"".+  if (++(*mapdepthp) >= p_mmd) {+    EMSG(_(""E223: recursive mapping""));+    if (State & CMDLINE) {+      redrawcmdline();     } else {-      c = read_readbuffers(advance);+      setcursor();     }-    if (c != NUL && !got_int) {-      if (advance) {-        /* KeyTyped = FALSE;  When the command that stuffed something-         * was typed, behave like the stuffed command was typed.-         * needed for CTRL-W CTRl-] to open a fold, for example. */-        KeyStuffed = TRUE;-      }-      if (typebuf.tb_no_abbr_cnt == 0)-        typebuf.tb_no_abbr_cnt = 1;             /* no abbreviations now */-    } else {-      /*-       * Loop until we either find a matching mapped key, or we-       * are sure that it is not a mapped key.-       * If a mapped key sequence is found we go back to the start to-       * try re-mapping.-       */-      for (;; ) {-        /*-         * os_breakcheck() is slow, don't use it too often when-         * inside a mapping.  But call it each time for typed-         * characters.-         */-        if (typebuf.tb_maplen)-          line_breakcheck();-        else-          os_breakcheck();                      /* check for CTRL-C */-        keylen = 0;-        if (got_int) {-          /* flush all input */-          c = inchar(typebuf.tb_buf, typebuf.tb_buflen - 1, 0L,-              typebuf.tb_change_cnt);-          /*-           * If inchar() returns TRUE (script file was active) or we-           * are inside a mapping, get out of insert mode.-           * Otherwise we behave like having gotten a CTRL-C.-           * As a result typing CTRL-C in insert mode will-           * really insert a CTRL-C.-           */-          if ((c || typebuf.tb_maplen)-              && (State & (INSERT + CMDLINE)))-            c = ESC;-          else-            c = Ctrl_C;-          flush_buffers(TRUE);                  /* flush all typeahead */--          if (advance) {-            /* Also record this character, it might be needed to-             * get out of Insert mode. */-            *typebuf.tb_buf = (char_u)c;-            gotchars(typebuf.tb_buf, 1);-          }-          cmd_silent = FALSE;+    flush_buffers(false);+    *mapdepthp = 0;                     // for next one+    return true;+  } -          break;-        } else if (typebuf.tb_len > 0) {-          /*-           * Check for a mappable key sequence.-           * Walk through one maphash[] list until we find an-           * entry that matches.-           *-           * Don't look for mappings if:-           * - no_mapping set: mapping disabled (e.g. for CTRL-V)-           * - maphash_valid not set: no mappings present.-           * - typebuf.tb_buf[typebuf.tb_off] should not be remapped-           * - in insert or cmdline mode and 'paste' option set-           * - waiting for ""hit return to continue"" and CR or SPACE-           *	 typed-           * - waiting for a char with --more---           * - in Ctrl-X mode, and we get a valid char for that mode-           */-          mp = NULL;-          max_mlen = 0;-          c1 = typebuf.tb_buf[typebuf.tb_off];-          if (no_mapping == 0 && maphash_valid-              && (no_zero_mapping == 0 || c1 != '0')-              && (typebuf.tb_maplen == 0-                  || (p_remap-                      && (typebuf.tb_noremap[typebuf.tb_off]-                          & (RM_NONE|RM_ABBR)) == 0))-              && !(p_paste && (State & (INSERT + CMDLINE)))-              && !(State == HITRETURN && (c1 == CAR || c1 == ' '))-              && State != ASKMORE-              && State != CONFIRM-              && !((ctrl_x_mode != 0 && vim_is_ctrl_x_key(c1))-                   || ((compl_cont_status & CONT_LOCAL)-                       && (c1 == Ctrl_N || c1 == Ctrl_P)))-              ) {-            if (c1 == K_SPECIAL) {-              nolmaplen = 2;-            } else {-              LANGMAP_ADJUST(c1, (State & (CMDLINE | INSERT)) == 0-                             && get_real_state() != SELECTMODE);-              nolmaplen = 0;-            }-            /* First try buffer-local mappings. */-            mp = curbuf->b_maphash[MAP_HASH(local_State, c1)];-            mp2 = maphash[MAP_HASH(local_State, c1)];-            if (mp == NULL) {-              /* There are no buffer-local mappings. */-              mp = mp2;-              mp2 = NULL;-            }-            /*-             * Loop until a partly matching mapping is found or-             * all (local) mappings have been checked.-             * The longest full match is remembered in ""mp_match"".-             * A full match is only accepted if there is no partly-             * match, so ""aa"" and ""aaa"" can both be mapped.-             */-            mp_match = NULL;-            mp_match_len = 0;-            for (; mp != NULL;-                 mp->m_next == NULL ? (mp = mp2, mp2 = NULL) :-                 (mp = mp->m_next)) {-              /*-               * Only consider an entry if the first character-               * matches and it is for the current state.-               * Skip "":lmap"" mappings if keys were mapped.-               */-              if (mp->m_keys[0] == c1-                  && (mp->m_mode & local_State)-                  && ((mp->m_mode & LANGMAP) == 0-                      || typebuf.tb_maplen == 0)) {-                int nomap = nolmaplen;-                int c2;-                /* find the match length of this mapping */-                for (mlen = 1; mlen < typebuf.tb_len; ++mlen) {-                  c2 = typebuf.tb_buf[typebuf.tb_off + mlen];-                  if (nomap > 0)-                    --nomap;-                  else if (c2 == K_SPECIAL)-                    nomap = 2;-                  else-                    LANGMAP_ADJUST(c2, TRUE);-                  if (mp->m_keys[mlen] != c2)-                    break;-                }--                /* Don't allow mapping the first byte(s) of a-                 * multi-byte char.  Happens when mapping-                 * <M-a> and then changing 'encoding'. Beware-                 * that 0x80 is escaped. */-                char_u *p1 = mp->m_keys;-                char_u *p2 = mb_unescape(&p1);--                if (has_mbyte && p2 != NULL && MB_BYTE2LEN(c1) > MB_PTR2LEN(p2))-                  mlen = 0;-                /*-                 * Check an entry whether it matches.-                 * - Full match: mlen == keylen-                 * - Partly match: mlen == typebuf.tb_len-                 */-                keylen = mp->m_keylen;-                if (mlen == keylen-                    || (mlen == typebuf.tb_len-                        && typebuf.tb_len < keylen)) {-                  /*-                   * If only script-local mappings are-                   * allowed, check if the mapping starts-                   * with K_SNR.-                   */-                  s = typebuf.tb_noremap + typebuf.tb_off;-                  if (*s == RM_SCRIPT-                      && (mp->m_keys[0] != K_SPECIAL-                          || mp->m_keys[1] != KS_EXTRA-                          || mp->m_keys[2]-                          != (int)KE_SNR))-                    continue;-                  /*-                   * If one of the typed keys cannot be-                   * remapped, skip the entry.-                   */-                  for (n = mlen; --n >= 0; )-                    if (*s++ & (RM_NONE|RM_ABBR))-                      break;-                  if (n >= 0)-                    continue;--                  if (keylen > typebuf.tb_len) {-                    if (!timedout && !(mp_match != NULL-                                       && mp_match->m_nowait)) {-                      /* break at a partly match */-                      keylen = KEYLEN_PART_MAP;-                      break;-                    }-                  } else if (keylen > mp_match_len) {-                    /* found a longer match */-                    mp_match = mp;-                    mp_match_len = keylen;-                  }-                } else-                /* No match; may have to check for-                 * termcode at next character. */-                if (max_mlen < mlen)-                  max_mlen = mlen;-              }-            }+  // In Select mode and a Visual mode mapping is used:+  // Switch to Visual mode temporarily.  Append K_SELECT+  // to switch back to Select mode.+  if (VIsual_active && VIsual_select+      && (mp->m_mode & VISUAL)) {+    VIsual_select = false;+    (void)ins_typebuf(K_SELECT_STRING, REMAP_NONE, 0, true, false);+  } -            /* If no partly match found, use the longest full-             * match. */-            if (keylen != KEYLEN_PART_MAP) {-              mp = mp_match;-              keylen = mp_match_len;-            }-          }+  // Copy the values from *mp that are used, because+  // evaluating the expression may invoke a function+  // that redefines the mapping, thereby making *mp+  // invalid.+  save_m_expr = mp->m_expr;+  save_m_noremap = mp->m_noremap;+  save_m_silent = mp->m_silent;+  save_m_keys = NULL;              // only saved when needed+  save_m_str = NULL;              // only saved when needed++  // Handle "":map <expr>"": evaluate the {rhs} as an+  // expression.  Also save and restore the command line+  // for ""normal :"".+  char_u *s;+  if (mp->m_expr) {+    int save_vgetc_busy = vgetc_busy;++    vgetc_busy = 0;+    save_m_keys = vim_strsave(mp->m_keys);+    save_m_str = vim_strsave(mp->m_str);+    s = eval_map_expr(save_m_str, NUL);+    vgetc_busy = save_vgetc_busy;+  } else {+    s = mp->m_str;+  } -          // Check for a key that can toggle the 'paste' option-          if (mp == NULL && (State & (INSERT|NORMAL))) {-            bool match = typebuf_match_len(ui_toggle, &mlen);-            if (!match && mlen != typebuf.tb_len && *p_pt != NUL) {-              // didn't match ui_toggle_key and didn't try the whole typebuf,-              // check the 'pastetoggle'-              match = typebuf_match_len(p_pt, &mlen);-            }-            if (match) {-              // write chars to script file(s)-              if (mlen > typebuf.tb_maplen) {-                gotchars(typebuf.tb_buf + typebuf.tb_off + typebuf.tb_maplen,-                         (size_t)(mlen - typebuf.tb_maplen));-              }+  // Insert the 'to' part in the typebuf.tb_buf.+  // If 'from' field is the same as the start of the+  // 'to' field, don't remap the first character (but do+  // allow abbreviations).+  // If m_noremap is set, don't remap the whole 'to'+  // part.+  if (s != NULL) {+    int noremap;++    if (save_m_noremap != REMAP_YES) {+      noremap = save_m_noremap;+    } else if (STRNCMP(s,+                       save_m_keys != NULL ? save_m_keys : mp->m_keys,+                       (size_t)keylen) != 0) {+      noremap = REMAP_YES;+    } else {+      noremap = REMAP_SKIP;+    }+    ins_typebuf(s, noremap, 0, true, cmd_silent || save_m_silent);+    if (save_m_expr) {+      xfree(s);+    }+  }+  xfree(save_m_keys);+  xfree(save_m_str);+  return true;+} -              del_typebuf(mlen, 0);  // Remove the chars.-              set_option_value(""paste"", !p_paste, NULL, 0);-              if (!(State & INSERT)) {-                msg_col = 0;-                msg_row = (int)Rows - 1;-                msg_clr_eos();                          // clear ruler-              }-              status_redraw_all();-              redraw_statuslines();-              showmode();-              setcursor();-              continue;-            }-            /* Need more chars for partly match. */-            if (mlen == typebuf.tb_len)-              keylen = KEYLEN_PART_KEY;-            else if (max_mlen < mlen)-              /* no match, may have to check for termcode at-               * next character */-              max_mlen = mlen + 1;-          }+// keylen is changed (but I think this could be the return value)+// mp is set from NULL (this may also be the return value [I know I have to+// choose one])+// mp_match_len is changed.+static mapblock_T *find_typed_map(const bool timedout, const int local_State,+                                  int *keylenp)+{+  int temp_c = typebuf.tb_buf[typebuf.tb_off]; -          if ((mp == NULL || max_mlen >= mp_match_len)-              && keylen != KEYLEN_PART_MAP && keylen != KEYLEN_PART_KEY) {-            // No matching mapping found or found a non-matching mapping that-            // matches at least what the matching mapping matched-            keylen = 0;-            // If there was no mapping, use the character from the typeahead-            // buffer right here. Otherwise, use the mapping (loop around).-            if (mp == NULL) {-              // get a character: 2. from the typeahead buffer-              c = typebuf.tb_buf[typebuf.tb_off] & 255;-              if (advance) {                  // remove chars from tb_buf-                cmd_silent = (typebuf.tb_silent > 0);-                if (typebuf.tb_maplen > 0) {-                  KeyTyped = false;-                } else {-                  KeyTyped = true;-                  // write char to script file(s)-                  gotchars(typebuf.tb_buf + typebuf.tb_off, 1);-                }-                KeyNoremap = typebuf.tb_noremap[typebuf.tb_off];-                del_typebuf(1, 0);-              }-              break;  // got character, break for loop-            } else {-              keylen = mp_match_len;-            }-          }+  if (no_mapping != 0 || !maphash_valid+      || (no_zero_mapping != 0 && temp_c == '0')) {+    return NULL;+  } -          /* complete match */-          if (keylen >= 0 && keylen <= typebuf.tb_len) {-            int save_m_expr;-            int save_m_noremap;-            int save_m_silent;-            char_u *save_m_keys;-            char_u *save_m_str;--            // write chars to script file(s)-            if (keylen > typebuf.tb_maplen) {-              gotchars(typebuf.tb_buf + typebuf.tb_off + typebuf.tb_maplen,-                       (size_t)(keylen - typebuf.tb_maplen));-            }+  if (typebuf.tb_maplen != 0) {+    if (!p_remap+        || (typebuf.tb_noremap[typebuf.tb_off] & (RM_NONE|RM_ABBR)) != 0) {+      return NULL;+    }+  } -            cmd_silent = (typebuf.tb_silent > 0);-            del_typebuf(keylen, 0);             /* remove the mapped keys */+  if (p_paste && (State & (INSERT + CMDLINE))) {+    return NULL;+  } -            /*-             * Put the replacement string in front of mapstr.-             * The depth check catches "":map x y"" and "":map y x"".-             */-            if (++mapdepth >= p_mmd) {-              EMSG(_(""E223: recursive mapping""));-              if (State & CMDLINE)-                redrawcmdline();-              else-                setcursor();-              flush_buffers(FALSE);-              mapdepth = 0;                     /* for next one */-              c = -1;-              break;-            }+  if (State == HITRETURN && (temp_c == CAR || temp_c == ' ')) {+    return NULL;+  } -            /*-             * In Select mode and a Visual mode mapping is used:-             * Switch to Visual mode temporarily.  Append K_SELECT-             * to switch back to Select mode.-             */-            if (VIsual_active && VIsual_select-                && (mp->m_mode & VISUAL)) {-              VIsual_select = FALSE;-              (void)ins_typebuf(K_SELECT_STRING, REMAP_NONE,-                  0, TRUE, FALSE);-            }+  if (State == ASKMORE || State == CONFIRM) {+    return NULL;+  } -            /* Copy the values from *mp that are used, because-             * evaluating the expression may invoke a function-             * that redefines the mapping, thereby making *mp-             * invalid. */-            save_m_expr = mp->m_expr;-            save_m_noremap = mp->m_noremap;-            save_m_silent = mp->m_silent;-            save_m_keys = NULL;              /* only saved when needed */-            save_m_str = NULL;              /* only saved when needed */+  if (ctrl_x_mode != 0 && vim_is_ctrl_x_key(temp_c)) {+    return NULL;+  } -            /*-             * Handle "":map <expr>"": evaluate the {rhs} as an-             * expression.  Also save and restore the command line-             * for ""normal :"".-             */-            if (mp->m_expr) {-              int save_vgetc_busy = vgetc_busy;+  if ((compl_cont_status & CONT_LOCAL)+      && (temp_c == Ctrl_N || temp_c == Ctrl_P)) {+    return NULL;+  } -              vgetc_busy = 0;-              save_m_keys = vim_strsave(mp->m_keys);-              save_m_str = vim_strsave(mp->m_str);-              s = eval_map_expr(save_m_str, NUL);-              vgetc_busy = save_vgetc_busy;-            } else-              s = mp->m_str;+  int keylen = *keylenp;+  mapblock_T *mp = NULL;+  mapblock_T *mp2 = NULL;+  int nolmaplen;+  if (temp_c == K_SPECIAL) {+    nolmaplen = 2;+  } else {+    LANGMAP_ADJUST(temp_c, (State & (CMDLINE | INSERT)) == 0+                   && local_State != SELECTMODE);+    nolmaplen = 0;+  }+  // First try buffer-local mappings.+  mp = curbuf->b_maphash[MAP_HASH(local_State, temp_c)];+  mp2 = maphash[MAP_HASH(local_State, temp_c)];+  if (mp == NULL) {+    // There are no buffer-local mappings.+    mp = mp2;+    mp2 = NULL;+  }+  // Loop until a partly matching mapping is found or+  // all (local) mappings have been checked.+  // The longest full match is remembered in ""mp_match"".+  // A full match is only accepted if there is no partly+  // match, so ""aa"" and ""aaa"" can both be mapped.+  mapblock_T *mp_match = NULL;+  int mp_match_len = 0;+  for (; mp != NULL;+       mp->m_next == NULL ? (mp = mp2, mp2 = NULL) : (mp = mp->m_next)) {+    // Only consider an entry if the first character+    // matches and it is for the current state.+    // Skip "":lmap"" mappings if keys were mapped.+    if (mp->m_keys[0] != temp_c+        || ((mp->m_mode & local_State) == 0)+        || (((mp->m_mode & LANGMAP) != 0)+            && typebuf.tb_maplen != 0)) {+      continue;+    }+    int nomap = nolmaplen;+    int c2;+    // find the match length of this mapping+    int mlen = 1;+    for (mlen = 1; mlen < typebuf.tb_len; mlen++) {+      c2 = typebuf.tb_buf[typebuf.tb_off + mlen];+      if (nomap > 0) {+        nomap--;+      } else if (c2 == K_SPECIAL) {+        nomap = 2;+      } else {+        LANGMAP_ADJUST(c2, true);+      }+      if (mp->m_keys[mlen] != c2) {+        break;+      }+    } -            /*-             * Insert the 'to' part in the typebuf.tb_buf.-             * If 'from' field is the same as the start of the-             * 'to' field, don't remap the first character (but do-             * allow abbreviations).-             * If m_noremap is set, don't remap the whole 'to'-             * part.-             */-            if (s == NULL)-              i = FAIL;-            else {-              int noremap;--              if (save_m_noremap != REMAP_YES)-                noremap = save_m_noremap;-              else if (-                STRNCMP(s, save_m_keys != NULL-                    ? save_m_keys : mp->m_keys,-                    (size_t)keylen)-                != 0)-                noremap = REMAP_YES;-              else-                noremap = REMAP_SKIP;-              i = ins_typebuf(s, noremap,-                  0, TRUE, cmd_silent || save_m_silent);-              if (save_m_expr)-                xfree(s);-            }-            xfree(save_m_keys);-            xfree(save_m_str);-            if (i == FAIL) {-              c = -1;-              break;-            }-            continue;-          }+    // Don't allow mapping the first byte(s) of a+    // multi-byte char.  Happens when mapping+    // <M-a> and then changing 'encoding'. Beware+    // that 0x80 is escaped.+    char_u *p1 = mp->m_keys;+    char_u *p2 = mb_unescape(&p1);++    if (has_mbyte && p2 != NULL && MB_BYTE2LEN(temp_c) > MB_PTR2LEN(p2)) {+      mlen = 0;+    }+    // Check an entry whether it matches.+    // - Full match: mlen == keylen+    // - Partly match: mlen == typebuf.tb_len+    keylen = mp->m_keylen;+    if (mlen == keylen+        || (mlen == typebuf.tb_len && typebuf.tb_len < keylen)) {+      // If only script-local mappings are+      // allowed, check if the mapping starts+      // with K_SNR.+      char_u *s = typebuf.tb_noremap + typebuf.tb_off;+      if (*s == RM_SCRIPT+          && (mp->m_keys[0] != K_SPECIAL+              || mp->m_keys[1] != KS_EXTRA+              || mp->m_keys[2] != (int)KE_SNR)) {+        continue;+      }+      // If one of the typed keys cannot be+      // remapped, skip the entry.+      int n;+      for (n = mlen; n > 0; n--) {+        if (*s++ & (RM_NONE|RM_ABBR)) {+          break;         }+      }+      if (n > 0) {+        continue;+      } -        /*-         * get a character: 3. from the user - handle <Esc> in Insert mode-         */-        /*-         * special case: if we get an <ESC> in insert mode and there-         * are no more characters at once, we pretend to go out of-         * insert mode.  This prevents the one second delay after-         * typing an <ESC>.  If we get something after all, we may-         * have to redisplay the mode. That the cursor is in the wrong-         * place does not matter.-         */-        c = 0;-        new_wcol = curwin->w_wcol;-        new_wrow = curwin->w_wrow;-        if (       advance-                   && typebuf.tb_len == 1-                   && typebuf.tb_buf[typebuf.tb_off] == ESC-                   && !no_mapping-                   && ex_normal_busy == 0-                   && typebuf.tb_maplen == 0-                   && (State & INSERT)-                   && (p_timeout-                       || (keylen == KEYLEN_PART_KEY && p_ttimeout))-                   && (c = inchar(typebuf.tb_buf + typebuf.tb_off-                           + typebuf.tb_len, 3, 25L,-                           typebuf.tb_change_cnt)) == 0) {-          colnr_T col = 0, vcol;-          char_u      *ptr;--          if (mode_displayed) {-            unshowmode(TRUE);-            mode_deleted = TRUE;-          }-          validate_cursor();-          old_wcol = curwin->w_wcol;-          old_wrow = curwin->w_wrow;--          /* move cursor left, if possible */-          if (curwin->w_cursor.col != 0) {-            if (curwin->w_wcol > 0) {-              if (did_ai) {-                /*-                 * We are expecting to truncate the trailing-                 * white-space, so find the last non-white-                 * character -- webb-                 */-                col = vcol = curwin->w_wcol = 0;-                ptr = get_cursor_line_ptr();-                while (col < curwin->w_cursor.col) {-                  if (!ascii_iswhite(ptr[col]))-                    curwin->w_wcol = vcol;-                  vcol += lbr_chartabsize(ptr, ptr + col,-                      (colnr_T)vcol);-                  if (has_mbyte)-                    col += (*mb_ptr2len)(ptr + col);-                  else-                    ++col;-                }-                curwin->w_wrow = curwin->w_cline_row-                                 + curwin->w_wcol / curwin->w_width;-                curwin->w_wcol %= curwin->w_width;-                curwin->w_wcol += curwin_col_off();-                col = 0;                        /* no correction needed */-              } else {-                --curwin->w_wcol;-                col = curwin->w_cursor.col - 1;-              }-            } else if (curwin->w_p_wrap && curwin->w_wrow) {-              --curwin->w_wrow;-              curwin->w_wcol = curwin->w_width - 1;-              col = curwin->w_cursor.col - 1;+      if (keylen > typebuf.tb_len) {+        if (!timedout && !(mp_match != NULL && mp_match->m_nowait)) {+          // break at a partly match+          keylen = KEYLEN_PART_MAP;+          break;+        }+      } else if (keylen > mp_match_len) {+        // found a longer match+        mp_match = mp;+        mp_match_len = keylen;+      }+    }+  }++  // If no partly match found, use the longest full+  // match.+  if (keylen != KEYLEN_PART_MAP) {+    mp = mp_match;+    keylen = mp_match_len;+  }+  *keylenp = keylen;+  return mp;+}++// Returns 0 to continue, -1 to carry on in the loop, otherwise, returns the+// character that should be used.+// Keeps track of the mapdepth in the variable pointed to by ""mapdepthp"".+static int look_in_typebuf(int *mapdepthp, int *keylenp,+                           const bool timedout, const int advance,+                           const int local_State)+{+  if (typebuf.tb_len <= 0) {+    return -1;+  }+  // Check for a mappable key sequence.+  // Walk through one maphash[] list until we find an+  // entry that matches.+  // Don't look for mappings if:+  // - no_mapping set: mapping disabled (e.g. for CTRL-V)+  // - maphash_valid not set: no mappings present.+  // - typebuf.tb_buf[typebuf.tb_off] should not be remapped+  // - in insert or cmdline mode and 'paste' option set+  // - waiting for ""hit return to continue"" and CR or SPACE+  //     typed+  // - waiting for a char with --more--+  // - in Ctrl-X mode, and we get a valid char for that mode+  mapblock_T *mp = find_typed_map(timedout, local_State, keylenp);++  if (mp == NULL && check_togglepaste(mp, keylenp)) {+    // Have toggled 'paste', now have to start searching for characters again+    // in order to find the character that nvim proper needs to deal with.+    return 0;+  }++  if (mp == NULL+      && *keylenp != KEYLEN_PART_MAP+      && *keylenp != KEYLEN_PART_KEY) {+    // No matching mapping found or found a non-matching mapping that+    // matches at least what the matching mapping matched+    // If there was no mapping, use the character from the typeahead+    // buffer right here. Otherwise, use the mapping (loop around).+    // get a character: 2. from the typeahead buffer+    int c = typebuf.tb_buf[typebuf.tb_off] & 255;+    if (advance) {                  // remove chars from tb_buf+      cmd_silent = (typebuf.tb_silent > 0);+      if (typebuf.tb_maplen > 0) {+        KeyTyped = false;+      } else {+        KeyTyped = true;+        // write char to script file(s)+        gotchars(typebuf.tb_buf + typebuf.tb_off, 1);+      }+      KeyNoremap = typebuf.tb_noremap[typebuf.tb_off];+      del_typebuf(1, 0);+    }+    return c;+  }++  if (expand_matched_map(mp, *keylenp, mapdepthp)) {+    return 0;+  }++  return -1;+}++static int ins_esc_special_case(+    int *new_wcolp, int *new_wrowp, bool *mode_deletedp,+    const int advance, const int keylen)+{+  // special case: if we get an <ESC> in insert mode and there+  // are no more characters at once, we pretend to go out of+  // insert mode.  This prevents the one second delay after+  // typing an <ESC>.  If we get something after all, we may+  // have to redisplay the mode. That the cursor is in the wrong+  // place does not matter.+  int bytes_read = 0;+  if (       advance+      && typebuf.tb_len == 1+      && typebuf.tb_buf[typebuf.tb_off] == ESC+      && !no_mapping+      && ex_normal_busy == 0+      && typebuf.tb_maplen == 0+      && (State & INSERT)+      && (p_timeout+          || (keylen == KEYLEN_PART_KEY && p_ttimeout))+      && (bytes_read = inchar(typebuf.tb_buf + typebuf.tb_off + typebuf.tb_len,+                              3, 25L, typebuf.tb_change_cnt)) == 0) {+    colnr_T col = 0, vcol;+    char_u      *ptr;++    if (mode_displayed) {+      unshowmode(true);+      *mode_deletedp = true;+    }+    validate_cursor();+    int old_wcol = curwin->w_wcol;+    int old_wrow = curwin->w_wrow;++    // move cursor left, if possible+    if (curwin->w_cursor.col != 0) {+      if (curwin->w_wcol > 0) {+        if (did_ai) {+          // We are expecting to truncate the trailing+          // white-space, so find the last non-white+          // character -- webb+          col = vcol = curwin->w_wcol = 0;+          ptr = get_cursor_line_ptr();+          while (col < curwin->w_cursor.col) {+            if (!ascii_iswhite(ptr[col])) {+              curwin->w_wcol = vcol;             }-            if (has_mbyte && col > 0 && curwin->w_wcol > 0) {-              /* Correct when the cursor is on the right halve-               * of a double-wide character. */-              ptr = get_cursor_line_ptr();-              col -= (*mb_head_off)(ptr, ptr + col);-              if ((*mb_ptr2cells)(ptr + col) > 1)-                --curwin->w_wcol;+            vcol += lbr_chartabsize(ptr, ptr + col, (colnr_T)vcol);+            if (has_mbyte) {+              col += (*mb_ptr2len)(ptr + col);",Also with larger refactorings we should change `(*mb_func)(` and `MB_FUNC(` to to `mb_func(`. The only reason against would be merging from vim easier but with heavy refactoring applying patches must be done manually anyway.,X
251450,chemzqm,https://api.github.com/repos/neovim/neovim/pulls/5856,109951806,2017-04-05T15:42:06Z,runtime/autoload/provider/pythonx.vim,"@@ -9,19 +9,29 @@ let s:stderr = {} let s:job_opts = {'rpc': v:true}  "" TODO(bfredl): this logic is common and should be builtin-function! s:job_opts.on_stderr(chan_id, data, event)-  let stderr = get(s:stderr, a:chan_id, [''])-  let last = remove(stderr, -1)-  let a:data[0] = last.a:data[0]-  call extend(stderr, a:data)+function! s:job_opts.on_stderr(chan_id, data, event) dict+  let stderr = get(s:stderr, a:chan_id, [])","I found I couldn't get any error stack in my branch, but that no longer a case for latest branch, so I've revert the changes.",X
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/6440,109952801,2017-04-05T15:45:33Z,test/functional/ui/screen_basic_spec.lua,"@@ -73,33 +73,29 @@ describe('Screen', function()   describe(':suspend', function()     it('is forwarded to the UI', function()       local function check()-        if not screen.suspended then-          return 'Screen was not suspended'-        end+        eq(true, screen.suspended)       end","This, by the way, is the reason I didn't use screen:expect() condition in the first place.",X
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/6440,109958856,2017-04-05T16:07:42Z,test/functional/ui/screen_basic_spec.lua,"@@ -73,33 +73,29 @@ describe('Screen', function()   describe(':suspend', function()     it('is forwarded to the UI', function()       local function check()-        if not screen.suspended then-          return 'Screen was not suspended'-        end+        eq(true, screen.suspended)       end","That happens _precisely_ because `eq(false, screen.suspended)` here _is_ a failure-after-success condition, you could get either success, failure, or failure-after-success warning in different runs. Change it to `eq('test', screen.suspended)` and you get a consistent failure.I've induced many correct test failures both in `basic_spec` and the cursor shape tests, this wouldn't be possible if `pcall()` didn't catch test failures. Also, how would test failures possibly stop the test execution if not by raising lua error?",X
189413,aktau,https://api.github.com/repos/neovim/neovim/pulls/6467,110372440,2017-04-07T11:51:31Z,src/nvim/eval.c,"@@ -13416,14 +13416,12 @@ static void f_resolve(typval_T *argvars, typval_T *rettv, FunPtr fptr)           q = (char *)path_tail((char_u *)p);         }         if (q > p && !path_is_absolute_path((const char_u *)buf)) {-          // Symlink is relative to directory of argument.+          // Symlink is relative to directory of argument. Replace the+          // symlink with the resolved name in the same directory.           const size_t p_len = strlen(p);           const size_t buf_len = strlen(buf);-          cpy = xmalloc(p_len + buf_len + 1);-          memcpy(cpy, p, p_len);","Yes. I was thinking it's too easy to make mistakes like this. Especially when doing larger refactoring.We may be able to catch a couple by running ASAN tests with a fully loaded (plugins) Vim doing all sorts of things (i.e.: what happened to me, though I didn't see it on OSX because it perhaps returns zeroed memory). However I think in general we should defer to using safer string functions. If `path_tail` didn't return `char_u` and take `char_u`, I would've used `xstrlcpy()`. Performance wise, the function in which this is happening does worse things than calculating the length of the string (in cache) redundantly. (Moreover, if we truly want that, `strlcpy` can be optimized a lot, copying most of glibcs `str(n)cpy`).",X
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/5416,110431109,2017-04-07T16:36:37Z,src/nvim/os/env.c,"@@ -127,11 +131,19 @@ void os_get_hostname(char *hostname, size_t len)     strncpy(hostname, vutsname.nodename, len - 1);     hostname[len - 1] = '\0';   }-#else-  // TODO(unknown): Implement this for windows.-  // See the implementation used in vim:-  // https://code.google.com/p/vim/source/browse/src/os_win32.c?r=6b69d8dde19e32909f4ee3a6337e6a2ecfbb6f72#2899-  *hostname = '\0';+#endif+#ifdef WIN32+  WCHAR hostname_unicode[MAX_COMPUTERNAME_LENGTH + 1];+  WCHAR hostname_length = (WCHAR)len;+  if (GetComputerName(hostname_unicode, &hostname_length) == 0) {+    *hostname = '\0';+  } else {+    int conversion_result = utf16_to_utf8(hostname_unicode,+                                          &hostname);","This doesn't work because `hostname` is reassigned by `utf16_to_utf8`, so the original pointer passed to `os_get_hostname()` isn't updated. Instead a temporary pointer should be passed to `utf16_to_utf8`, then copy its contents to `hostname`. Fixed in #6413The API of `utf16_to_utf8` is like this because it saves the caller from having to guess a buffer size for the resulting string. Though in this case that doesn't matter.",X
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/6475,110502811,2017-04-07T23:57:06Z,test/functional/terminal/tui_spec.lua,"@@ -2,9 +2,10 @@ -- as a simple way to send keys and assert screen state. local helpers = require('test.functional.helpers')(after_each) local thelpers = require('test.functional.terminal.helpers')-local feed = thelpers.feed_data+local feed_data = thelpers.feed_data",Overloading the usual functions like this is very confusing. Use feed_data explicitly to hint that the keys are sent to the child nvim instance.,X
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/6421,110527096,2017-04-08T20:48:00Z,test/functional/options/pastetoggle_spec.lua,"@@ -0,0 +1,37 @@+local helpers = require('test.functional.helpers')(after_each)++local clear = helpers.clear+local feed = helpers.feed+local execute = helpers.execute+local eq = helpers.eq+local eval = helpers.eval+local sleep = helpers.sleep++describe(""'pastetoggle' option"", function()+  before_each(function()+    clear()+    execute('set nopaste')+    execute('set pastetoggle=a')+  end)+  it(""toggles 'paste'"", function()+    eq(eval('&paste'), 0)+    feed('a')+    -- Need another key so that the vgetorpeek() function returns.+    feed('j')+    eq(eval('&paste'), 1)+  end)+  it(""multiple key 'pastetoggle' is waited for"", function()+    eq(eval('&paste'), 0)+    local pastetoggle = 'lllll'+    execute('set pastetoggle=' .. pastetoggle)+    execute('set timeoutlen=1', 'set ttimoutlen=10000')",Note that here is a typo: missing `e` in `ttimoutlen`. And `execute()` is successfull at hiding this fact.,X
189413,aktau,https://api.github.com/repos/neovim/neovim/pulls/6370,110535628,2017-04-09T08:16:32Z,src/nvim/getchar.c,"@@ -1847,7 +1849,7 @@ static mapblock_T *find_typed_map(const bool timedout, const int local_State,     return NULL;   } -  int keylen = *keylenp;+  int keylen = 0;   mapblock_T *mp = NULL;   mapblock_T *mp2 = NULL;   int nolmaplen;","Can't comment below, but at the end of the function I see:```  // If no partly match found, use the longest full  // match.  if (keylen != KEYLEN_PART_MAP) {    mp = mp_match;    keylen = mp_match_len;  }  *keylenp = keylen;  return mp;``````// If no partly match found, use the longest full match.if (keylen != KEYLEN_PART_MAP) {  return mp_match;}*keylenp = keylen;return mp;```While rewriting this I realized that `keylen = mp_match_len` is a completely unused statement (don't we have warnings for this?).The fact that this exists tells me fishy stuff may be going on.",X
189413,aktau,https://api.github.com/repos/neovim/neovim/pulls/6370,110535753,2017-04-09T08:23:30Z,src/nvim/getchar.c,"@@ -1847,7 +1849,7 @@ static mapblock_T *find_typed_map(const bool timedout, const int local_State,     return NULL;   } -  int keylen = *keylenp;+  int keylen = 0;   mapblock_T *mp = NULL;   mapblock_T *mp2 = NULL;   int nolmaplen;","Wow, scratch this. I'm stupid. My ""improved"" version does something different, and the initial `keylen = mp_match_len` wasn't useless. Still, I think the following would be an improvement:```c// If no partial match found, use the longest full match.if (keylen != KEYLEN_PART_MAP) {  *keylenp = mp_match_len;  return mp_match;}*keylenp = keylen;return mp;```",
189413,aktau,https://api.github.com/repos/neovim/neovim/pulls/6370,110535820,2017-04-09T08:28:11Z,src/nvim/getchar.c,"@@ -1806,13 +1806,15 @@ static bool expand_matched_map(mapblock_T *mp, const int keylen, int *mapdepthp) // of the mapblock_T m_keylen member in *keylenp. // If no mapping is found return NULL. //    If this is because the typebuffer contains characters that don't match-//    any mapping, don't change *keylenp.+//    any mapping, then leave *keylenp as 0. //    If it is because the typebuffer contains the start of a mapping, but not //    an entire one, set *keylenp to KEYLEN_PART_MAP. static mapblock_T *find_typed_map(const bool timedout, const int local_State,                                   int *keylenp) {   int temp_c = typebuf.tb_buf[typebuf.tb_off];+  // Mainly to make it clear this is always 0 when calling this function.+  assert(*keylenp == 0);","Perhaps it would be better to document that `*keylenp` will be set to `0` if no (partial) mapping could be found.I only cursorily looked at the callchain of this function, but it seems like no part of the code relies on the fact that `*keylenp` is unchanged. So making it always changed (and thus always defined) makes the function easier to read.",
4070620,hardenedapple,https://api.github.com/repos/neovim/neovim/pulls/6370,110540176,2017-04-09T12:26:34Z,src/nvim/getchar.c,"@@ -2312,7 +2317,7 @@ static int vgetorpeek(const int advance)     }           /* if (!character from stuffbuf) */      /* if advance is FALSE don't loop on NULs */-  } while (c < 0 || (advance && c == NUL));+  } while (!exiting);","Some of the commits I have here are essentially ""showing my workings"", where I've split up the change I want to make into some changes that are much easier to verify are correct.This is one of the commits in the series that splits the multiple uses of the variable `c` into separate variables.Initially it was used to store each of- The final character to return- The number of bytes read from the user- A `-1` put there simply to say ""continue on in the loop""at various points in the `while()` loop.I found this very confusing, which is why I split it up.The `exiting` variable is a temporary one (removed in later commits), that removes one of the uses, so that the others are easy to reason about for future changes.",
4070620,hardenedapple,https://api.github.com/repos/neovim/neovim/pulls/6370,110540207,2017-04-09T12:27:47Z,src/nvim/getchar.c,"@@ -1721,7 +1721,11 @@ static int vgetorpeek(const int advance)     } else {       c = read_readbuffers(advance);     }-    if (c != NUL && !got_int) {++    if (got_int) {+      c = handle_int(advance);+      exiting = true;","All cases were covered, but I wanted to be explicit about where the function was exiting. I thought this made it much easier when reasoning about the control flow.Again, this is a temporary change that makes it easier to verify other commits.",
112971,jamessan,https://api.github.com/repos/neovim/neovim/pulls/6520,111611387,2017-04-14T18:02:01Z,test/helpers.lua,"@@ -185,7 +188,11 @@ local function check_cores(app, force)   local gdb_db_cmd = 'gdb -n -batch -ex ""thread apply all bt full"" ""$_NVIM_TEST_APP"" -c ""$_NVIM_TEST_CORE""'   local lldb_db_cmd = 'lldb -Q -o ""bt all"" -f ""$_NVIM_TEST_APP"" -c ""$_NVIM_TEST_CORE""'   local random_skip = false-  local local_tmpdir = tmpdir_is_local(tmpdir_get()) and tmpdir_get() or nil+  -- Workspace-local $TMPDIR, scrubbed and pattern-escaped.+  -- ""./Xtest-tmpdir/"" => ""Xtest%-tmpdir""+  local local_tmpdir = (tmpdir_is_local(tmpdir_get())+    and tmpdir_get():gsub('^[ ./]+',''):gsub('%/+$',''):gsub('([^%w])', '%%%1')","```luagsub('^[ ./]+', '')```Why is a character class being used here?  This would rewrite `/foo` to `foo`.",X
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/6520,111612332,2017-04-14T18:07:52Z,test/helpers.lua,"@@ -185,7 +188,11 @@ local function check_cores(app, force)   local gdb_db_cmd = 'gdb -n -batch -ex ""thread apply all bt full"" ""$_NVIM_TEST_APP"" -c ""$_NVIM_TEST_CORE""'   local lldb_db_cmd = 'lldb -Q -o ""bt all"" -f ""$_NVIM_TEST_APP"" -c ""$_NVIM_TEST_CORE""'   local random_skip = false-  local local_tmpdir = tmpdir_is_local(tmpdir_get()) and tmpdir_get() or nil+  -- Workspace-local $TMPDIR, scrubbed and pattern-escaped.+  -- ""./Xtest-tmpdir/"" => ""Xtest%-tmpdir""+  local local_tmpdir = (tmpdir_is_local(tmpdir_get())+    and tmpdir_get():gsub('^[ ./]+',''):gsub('%/+$',''):gsub('([^%w])', '%%%1')","Yes, I made that tradeoff because of the app-specific nature of this logic: workspace-local temp dir is not going to be an absolute path, and even if it is, removing the preceding slash isn't going to cause a false positive.Doing it the robust way requires more gsub() calls. Would be nice to have some `path_scrub()` function but again this is application-specific it didn't make sense as a function, unless one writes a function with various parameters to control the behavior (would be welcome, just out of scope here).",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/6516,111661045,2017-04-15T08:21:47Z,src/nvim/log.h,"@@ -67,6 +67,30 @@        __VA_ARGS__) #  endif +# if __linux__+#  include <execinfo.h>+#  define LOG_CALLSTACK(prefix) \",@zhou13  Why? This is for the developer to use for temporary debugging. What good will it do if LOG_CALLSTACK compiles on non-linux but doesn't do anything?,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/6524,111661180,2017-04-15T08:33:43Z,test/functional/insert/ctrl_r_spec.lua,"@@ -0,0 +1,19 @@+local helpers = require('test.functional.helpers')(after_each)+local clear, feed, insert = helpers.clear, helpers.feed, helpers.insert",testlint complains that `insert` is unused,X
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/5119,111675011,2017-04-15T23:10:34Z,src/nvim/eval/typval.c,,Comment was somehow misplaced. See line 2490 on master:https://github.com/neovim/neovim/blob/master/src/nvim/eval/typval.c#L2465-L2494,
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/5119,111683420,2017-04-16T12:34:27Z,src/nvim/eval/typval.c,"@@ -0,0 +1,2556 @@+#include <stdio.h>+#include <stddef.h>+#include <string.h>+#include <assert.h>+#include <stdbool.h>++#include ""nvim/lib/queue.h""+#include ""nvim/eval/typval.h""+#include ""nvim/eval/gc.h""+#include ""nvim/eval/executor.h""+#include ""nvim/eval/encode.h""+#include ""nvim/eval/typval_encode.h""+#include ""nvim/eval.h""+#include ""nvim/types.h""+#include ""nvim/assert.h""+#include ""nvim/memory.h""+#include ""nvim/globals.h""+#include ""nvim/hashtab.h""+#include ""nvim/vim.h""+#include ""nvim/ascii.h""+#include ""nvim/pos.h""+#include ""nvim/charset.h""+#include ""nvim/garray.h""+#include ""nvim/gettext.h""+#include ""nvim/macros.h""+#include ""nvim/mbyte.h""+#include ""nvim/message.h""+// TODO(ZyX-I): Move line_breakcheck out of misc1+#include ""nvim/misc1.h""  // For line_breakcheck++#ifdef INCLUDE_GENERATED_DECLARATIONS+# include ""eval/typval.c.generated.h""+#endif++bool tv_in_free_unref_items = false;++// TODO(ZyX-I): Remove DICT_MAXNEST, make users be non-recursive instead++#define DICT_MAXNEST 100++const char *const tv_empty_string = """";++//{{{1 Lists+//{{{2 List item++/// Allocate a list item+///+/// @warning Allocated item is not initialized, do not forget to initialize it+///          and specifically set lv_lock.+///+/// @return [allocated] new list item.+listitem_T *tv_list_item_alloc(void)+  FUNC_ATTR_NONNULL_RET FUNC_ATTR_MALLOC+{+  return xmalloc(sizeof(listitem_T));+}++/// Free a list item+///+/// Also clears the value. Does not touch watchers.+///+/// @param[out]  item  Item to free.+void tv_list_item_free(listitem_T *const item)+  FUNC_ATTR_NONNULL_ALL+{+  tv_clear(&item->li_tv);+  xfree(item);+}++/// Remove a list item from a List and free it+///+/// Also clears the value.+///+/// @param[out]  l  List to remove item from.+/// @param[in,out]  item  Item to remove.+void tv_list_item_remove(list_T *const l, listitem_T *const item)+  FUNC_ATTR_NONNULL_ALL+{+  tv_list_remove_items(l, item, item);+  tv_list_item_free(item);+}++//{{{2 List watchers++/// Add a watcher to a list+///+/// @param[out]  l  List to add watcher to.+/// @param[in]  lw  Watcher to add.+void tv_list_watch_add(list_T *const l, listwatch_T *const lw)+  FUNC_ATTR_NONNULL_ALL+{+  lw->lw_next = l->lv_watch;+  l->lv_watch = lw;+}++/// Remove a watcher from a list+///+/// Does not give a warning if watcher was not found.+///+/// @param[out]  l  List to remove watcher from.+/// @param[in]  lwrem  Watcher to remove.+void tv_list_watch_remove(list_T *const l, listwatch_T *const lwrem)+  FUNC_ATTR_NONNULL_ALL+{+  listwatch_T **lwp = &l->lv_watch;+  for (listwatch_T *lw = l->lv_watch; lw != NULL; lw = lw->lw_next) {+    if (lw == lwrem) {+      *lwp = lw->lw_next;+      break;+    }+    lwp = &lw->lw_next;+  }+}++/// Advance watchers to the next item+///+/// Used just before removing an item from a list.+///+/// @param[out]  l  List from which item is removed.+/// @param[in]  item  List item being removed.+void tv_list_watch_fix(list_T *const l, const listitem_T *const item)+  FUNC_ATTR_NONNULL_ALL+{+  for (listwatch_T *lw = l->lv_watch; lw != NULL; lw = lw->lw_next) {+    if (lw->lw_item == item) {+      lw->lw_item = item->li_next;+    }+  }+}++//{{{2 Alloc/free++/// Allocate an empty list+///+/// Caller should take care of the reference count.+///+/// @return [allocated] new list.+list_T *tv_list_alloc(void)+  FUNC_ATTR_NONNULL_RET FUNC_ATTR_MALLOC+{+  list_T *const list = xcalloc(1, sizeof(list_T));++  // Prepend the list to the list of lists for garbage collection.+  if (gc_first_list != NULL) {+    gc_first_list->lv_used_prev = list;+  }+  list->lv_used_prev = NULL;+  list->lv_used_next = gc_first_list;+  gc_first_list = list;+  return list;+}++/// Free items contained in a list+///+/// @param[in,out]  l  List to clear.+void tv_list_free_contents(list_T *const l)+  FUNC_ATTR_NONNULL_ALL+{+  for (listitem_T *item = l->lv_first; item != NULL; item = l->lv_first) {+    // Remove the item before deleting it.+    l->lv_first = item->li_next;+    tv_clear(&item->li_tv);+    xfree(item);+  }+  l->lv_len = 0;+  l->lv_idx_item = NULL;+  l->lv_last = NULL;+  assert(l->lv_watch == NULL);+}++/// Free a list itself, ignoring items it contains+///+/// Ignores the reference count.+///+/// @param[in,out]  l  List to free.+void tv_list_free_list(list_T *const l)+  FUNC_ATTR_NONNULL_ALL+{+  // Remove the list from the list of lists for garbage collection.+  if (l->lv_used_prev == NULL) {+    gc_first_list = l->lv_used_next;+  } else {+    l->lv_used_prev->lv_used_next = l->lv_used_next;+  }+  if (l->lv_used_next != NULL) {+    l->lv_used_next->lv_used_prev = l->lv_used_prev;+  }++  xfree(l);+}++/// Free a list, including all items it points to+///+/// Ignores the reference count. Does not do anything if+/// tv_in_free_unref_items is true.+///+/// @param[in,out]  l  List to free.+void tv_list_free(list_T *const l)+  FUNC_ATTR_NONNULL_ALL+{+  if (!tv_in_free_unref_items) {+    tv_list_free_contents(l);+    tv_list_free_list(l);+  }+}++/// Unreference a list+///+/// Decrements the reference count and frees when it becomes zero or less.+///+/// @param[in,out]  l  List to unreference.+void tv_list_unref(list_T *const l)+{+  if (l != NULL && --l->lv_refcount <= 0) {+    tv_list_free(l);+  }+}++//{{{2 Add/remove++/// Remove items ""item"" to ""item2"" from list ""l"".+///+/// @warning Does not free the listitem or the value!+///+/// @param[out]  l  List to remove from.+/// @param[in]  item  First item to remove.+/// @param[in]  item2  Last item to remove.+void tv_list_remove_items(list_T *const l, listitem_T *const item,+                          listitem_T *const item2)+  FUNC_ATTR_NONNULL_ALL+{+  // Notify watchers.+  for (listitem_T *ip = item; ip != item2->li_next; ip = ip->li_next) {+    l->lv_len--;+    tv_list_watch_fix(l, ip);+  }++  if (item2->li_next == NULL) {+    l->lv_last = item->li_prev;+  } else {+    item2->li_next->li_prev = item->li_prev;+  }+  if (item->li_prev == NULL) {+    l->lv_first = item2->li_next;+  } else {+    item->li_prev->li_next = item2->li_next;+  }+  l->lv_idx_item = NULL;+}++/// Insert list item+///+/// @param[out]  l  List to insert to.+/// @param[in,out]  ni  Item to insert.+/// @param[in]  item  Item to insert before. If NULL, inserts at the end of the+///                   list.+void tv_list_insert(list_T *const l, listitem_T *const ni,+                    listitem_T *const item)+  FUNC_ATTR_NONNULL_ARG(1, 2)+{+  if (item == NULL) {+    // Append new item at end of list.+    tv_list_append(l, ni);+  } else {+    // Insert new item before existing item.+    ni->li_prev = item->li_prev;+    ni->li_next = item;+    if (item->li_prev == NULL) {+      l->lv_first = ni;+      l->lv_idx++;+    } else {+      item->li_prev->li_next = ni;+      l->lv_idx_item = NULL;+    }+    item->li_prev = ni;+    l->lv_len++;+  }+}++/// Insert VimL value into a list+///+/// @param[out]  l  List to insert to.+/// @param[in,out]  tv  Value to insert. Is copied (@see tv_copy()) to an+///                     allocated listitem_T and inserted.+/// @param[in]  item  Item to insert before. If NULL, inserts at the end of the+///                   list.+void tv_list_insert_tv(list_T *const l, typval_T *const tv,+                       listitem_T *const item)+{+  listitem_T *const ni = tv_list_item_alloc();++  tv_copy(tv, &ni->li_tv);+  tv_list_insert(l, ni, item);+}++/// Append item to the end of list+///+/// @param[out]  l  List to append to.+/// @param[in,out]  item  Item to append.+void tv_list_append(list_T *const l, listitem_T *const item)+  FUNC_ATTR_NONNULL_ALL+{+  if (l->lv_last == NULL) {+    // empty list+    l->lv_first = item;+    l->lv_last = item;+    item->li_prev = NULL;+  } else {+    l->lv_last->li_next = item;+    item->li_prev = l->lv_last;+    l->lv_last = item;+  }+  l->lv_len++;+  item->li_next = NULL;+}++/// Append VimL value to the end of list+///+/// @param[out]  l  List to append to.+/// @param[in,out]  tv  Value to append. Is copied (@see tv_copy()) to an+///                     allocated listitem_T.+void tv_list_append_tv(list_T *const l, typval_T *const tv)+  FUNC_ATTR_NONNULL_ALL+{+  listitem_T *const li = tv_list_item_alloc();+  tv_copy(tv, &li->li_tv);+  tv_list_append(l, li);+}++/// Append a list to a list as one item+///+/// @param[out]  l  List to append to.+/// @param[in,out]  itemlist  List to append. Reference count is increased.+void tv_list_append_list(list_T *const list, list_T *const itemlist)+  FUNC_ATTR_NONNULL_ARG(1)+{+  listitem_T *const li = tv_list_item_alloc();++  li->li_tv.v_type = VAR_LIST;+  li->li_tv.v_lock = VAR_UNLOCKED;+  li->li_tv.vval.v_list = itemlist;+  tv_list_append(list, li);+  if (itemlist != NULL) {+    itemlist->lv_refcount++;+  }+}++/// Append a dictionary to a list+///+/// @param[out]  l  List to append to.+/// @param[in,out]  dict  Dictionary to append. Reference count is increased.+void tv_list_append_dict(list_T *const list, dict_T *const dict)+  FUNC_ATTR_NONNULL_ARG(1)+{+  listitem_T *const li = tv_list_item_alloc();++  li->li_tv.v_type = VAR_DICT;+  li->li_tv.v_lock = VAR_UNLOCKED;+  li->li_tv.vval.v_dict = dict;+  tv_list_append(list, li);+  if (dict != NULL) {+    dict->dv_refcount++;+  }+}++/// Make a copy of ""str"" and append it as an item to list ""l""+///+/// @param[out]  l  List to append to.+/// @param[in]  str  String to append.+/// @param[in]  len  Length of the appended string. May be -1, in this+///                  case string is considered to be usual zero-terminated+///                  string or NULL ���empty��� string.+void tv_list_append_string(list_T *const l, const char *const str,+                           const ptrdiff_t len)+  FUNC_ATTR_NONNULL_ARG(1)+{+  if (str == NULL) {+    assert(len == 0 || len == -1);+    tv_list_append_allocated_string(l, NULL);+  } else {+    tv_list_append_allocated_string(l, (len >= 0+                                        ? xmemdupz(str, (size_t)len)+                                        : xstrdup(str)));+  }+}++/// Append given string to the list+///+/// Unlike list_append_string this function does not copy the string.+///+/// @param[out]  l    List to append to.+/// @param[in]   str  String to append.+void tv_list_append_allocated_string(list_T *const l, char *const str)+  FUNC_ATTR_NONNULL_ARG(1)+{+  listitem_T *const li = tv_list_item_alloc();++  tv_list_append(l, li);+  li->li_tv.v_type = VAR_STRING;+  li->li_tv.v_lock = VAR_UNLOCKED;+  li->li_tv.vval.v_string = (char_u *)str;+}++/// Append number to the list+///+/// @param[out]  l  List to append to.+/// @param[in]  n  Number to append. Will be recorded in the allocated+///                listitem_T.+void tv_list_append_number(list_T *const l, const varnumber_T n)+{+  listitem_T *const li = tv_list_item_alloc();+  li->li_tv.v_type = VAR_NUMBER;+  li->li_tv.v_lock = VAR_UNLOCKED;+  li->li_tv.vval.v_number = n;+  tv_list_append(l, li);+}++//{{{2 Operations on the whole list++/// Make a copy of list+///+/// @param[in]  conv  If non-NULL, then all internal strings will be converted.+///                   Only used when `deep` is true.+/// @param[in]  orig  Original list to copy.+/// @param[in]  deep  If false, then shallow copy will be done.+/// @param[in]  copyID  See var_item_copy().+///+/// @return Copied list. May be NULL in case original list is NULL or some+///         failure happens. The refcount of the new list is set to 1.+list_T *tv_list_copy(const vimconv_T *const conv, list_T *const orig,+                     const bool deep, const int copyID)+  FUNC_ATTR_WARN_UNUSED_RESULT+{+  if (orig == NULL) {+    return NULL;+  }++  list_T *copy = tv_list_alloc();+  if (copyID != 0) {+    // Do this before adding the items, because one of the items may+    // refer back to this list.+    orig->lv_copyID = copyID;+    orig->lv_copylist = copy;+  }+  listitem_T *item;+  for (item = orig->lv_first; item != NULL && !got_int;+       item = item->li_next) {+    listitem_T *const ni = tv_list_item_alloc();+    if (deep) {+      if (var_item_copy(conv, &item->li_tv, &ni->li_tv, deep, copyID) == FAIL) {+        xfree(ni);+        break;+      }+    } else {+      tv_copy(&item->li_tv, &ni->li_tv);+    }+    tv_list_append(copy, ni);+  }+  copy->lv_refcount++;+  if (item != NULL) {+    tv_list_unref(copy);+    copy = NULL;+  }++  return copy;+}++/// Extend first list with the second+///+/// @param[out]  l1  List to extend.+/// @param[in]  l2  List to extend with.+/// @param[in]  bef  If not NULL, extends before this item.+void tv_list_extend(list_T *const l1, list_T *const l2,+                    listitem_T *const bef)+  FUNC_ATTR_NONNULL_ARG(1, 2)+{+  int todo = l2->lv_len;+  listitem_T *const befbef = (bef == NULL ? NULL : bef->li_prev);+  listitem_T *const saved_next = (befbef == NULL ? NULL : befbef->li_next);+  // We also quit the loop when we have inserted the original item count of+  // the list, avoid a hang when we extend a list with itself.+  for (listitem_T *item = l2->lv_first+       ; item != NULL && --todo >= 0+       ; item = (item == befbef ? saved_next : item->li_next)) {+    tv_list_insert_tv(l1, &item->li_tv, bef);+  }+}++/// Concatenate lists into a new list+///+/// @param[in]  l1  First list.+/// @param[in]  l2  Second list.+/// @param[out]  ret_tv  Location where new list is saved.+///+/// @return OK or FAIL.+int tv_list_concat(list_T *const l1, list_T *const l2, typval_T *const tv)+  FUNC_ATTR_WARN_UNUSED_RESULT+{+  list_T *l;++  tv->v_type = VAR_LIST;++  if (l1 == NULL && l2 == NULL) {+    l = NULL;+  } else if (l1 == NULL) {+    l = tv_list_copy(NULL, l2, false, 0);+  } else {+    l = tv_list_copy(NULL, l1, false, 0);+    if (l != NULL && l2 != NULL) {+      tv_list_extend(l, l2, NULL);+    }+  }+  if (l == NULL && !(l1 == NULL && l2 == NULL)) {+    return FAIL;+  }++  tv->vval.v_list = l;+  return OK;+}++typedef struct {+  char_u *s;+  char_u *tofree;","Why is `tofree` needed? Can't we free with `s` too?To optimize some `strlen()` calls out, we could save the length of `s` here too and later use `ga_concat_len()` instead of `ga_concat()` in `list_join_inner()`.",X
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/6539,111728776,2017-04-17T10:34:41Z,src/nvim/ui.c,"@@ -541,10 +535,11 @@ static void flush_cursor_update(void)   } } -// Notify that the current mode has changed. Can be used to change cursor-// shape, for example.-static void ui_mode_change(void)+/// Check if current mode has changed.+/// May update the shape of the cursor.+void ui_cursor_shape(void)","This change doesn't narrow anything, only removes useless static alias in `ui.c`. This is the name actually used around the code base, but that can be changed, of course.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/6236,111752418,2017-04-17T14:49:16Z,src/nvim/api/private/helpers.c,"@@ -965,3 +966,41 @@ static void set_option_value_err(char *key,     api_set_error(err, Exception, ""%s"", errmsg);   } }+++/// Get an array containing dictionaries describing mappings+/// based on mode and buffer id+///+/// @param  mode  The abbreviation for the mode+/// @param  buf  The buffer to get the mapping array. NULL for global+/// @returns An array of maparg() like dictionaries describing mappings+ArrayOf(Dictionary) keymap_array(String mode, buf_T *buf)+{+  Array mappings = ARRAY_DICT_INIT;+  dict_T *const dict = tv_dict_alloc();++  // Convert the string mode to the integer mode+  // that is stored within each mapblock+  int int_mode = get_map_mode((char_u **)(&(mode.data)), 0);","this would mutate `mode.data`, which is really unexpected, better use temporary `char_u *p = mode.data`.",X
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/6539,111968147,2017-04-18T14:28:09Z,test/functional/ui/cursor_spec.lua,"@@ -18,138 +18,155 @@ describe('ui/cursor', function()   end)    it(""'guicursor' is published as a UI event"", function()-    local expected_cursor_style = {-      cmdline_hover = {-        mouse_shape = 0,-        short_name = 'e' },-      cmdline_insert = {+    local expected_mode_info = {+      [1] = {         blinkoff = 250,         blinkon = 400,         blinkwait = 700,-        cell_percentage = 25,-        cursor_shape = 'vertical',+        cell_percentage = 0,+        cursor_shape = 'block',+        full_name = 'normal',         hl_id = 46,         id_lm = 47,         mouse_shape = 0,-        short_name = 'ci' },-      cmdline_normal = {+        short_name = 'n' },+      [2] = {         blinkoff = 250,         blinkon = 400,         blinkwait = 700,         cell_percentage = 0,         cursor_shape = 'block',+        full_name = 'visual',         hl_id = 46,         id_lm = 47,         mouse_shape = 0,-        short_name = 'c' },-      cmdline_replace = {+        short_name = 'v' },+      [3] = {         blinkoff = 250,         blinkon = 400,         blinkwait = 700,-        cell_percentage = 20,-        cursor_shape = 'horizontal',+        cell_percentage = 25,+        cursor_shape = 'vertical',+        full_name = 'insert',         hl_id = 46,         id_lm = 47,         mouse_shape = 0,-        short_name = 'cr' },-      insert = {+        short_name = 'i' },+      [4] = {         blinkoff = 250,         blinkon = 400,         blinkwait = 700,-        cell_percentage = 25,-        cursor_shape = 'vertical',+        cell_percentage = 20,+        cursor_shape = 'horizontal',+        full_name = 'replace',         hl_id = 46,         id_lm = 47,         mouse_shape = 0,-        short_name = 'i' },-      more = {-        mouse_shape = 0,-        short_name = 'm' },-      more_lastline = {-        mouse_shape = 0,-        short_name = 'ml' },-      normal = {+        short_name = 'r' },+      [5] = {         blinkoff = 250,         blinkon = 400,         blinkwait = 700,         cell_percentage = 0,         cursor_shape = 'block',+        full_name = 'cmdline_normal',","I like to turn that question around, what so special about `full_name` it deserves to be the key? For the TUI (and other clients only caring about style) before this change there was a needless transformation from an array to a dict and back to an array again... And for clients that want to interpret the mode, it would be better with fields that actually describe the mode (mapping mode, selection type, temporary substate). I will add that in a later PR. This string should be mostly useful for testing and debugging purposes.",X
886074,teto,https://api.github.com/repos/neovim/neovim/pulls/6539,112085750,2017-04-18T23:13:10Z,test/functional/ui/cursor_spec.lua,"@@ -18,138 +18,155 @@ describe('ui/cursor', function()   end)    it(""'guicursor' is published as a UI event"", function()-    local expected_cursor_style = {-      cmdline_hover = {-        mouse_shape = 0,-        short_name = 'e' },-      cmdline_insert = {+    local expected_mode_info = {+      [1] = {         blinkoff = 250,         blinkon = 400,         blinkwait = 700,-        cell_percentage = 25,-        cursor_shape = 'vertical',+        cell_percentage = 0,+        cursor_shape = 'block',+        full_name = 'normal',         hl_id = 46,         id_lm = 47,         mouse_shape = 0,-        short_name = 'ci' },-      cmdline_normal = {+        short_name = 'n' },+      [2] = {         blinkoff = 250,         blinkon = 400,         blinkwait = 700,         cell_percentage = 0,         cursor_shape = 'block',+        full_name = 'visual',         hl_id = 46,         id_lm = 47,         mouse_shape = 0,-        short_name = 'c' },-      cmdline_replace = {+        short_name = 'v' },+      [3] = {         blinkoff = 250,         blinkon = 400,         blinkwait = 700,-        cell_percentage = 20,-        cursor_shape = 'horizontal',+        cell_percentage = 25,+        cursor_shape = 'vertical',+        full_name = 'insert',         hl_id = 46,         id_lm = 47,         mouse_shape = 0,-        short_name = 'cr' },-      insert = {+        short_name = 'i' },+      [4] = {         blinkoff = 250,         blinkon = 400,         blinkwait = 700,-        cell_percentage = 25,-        cursor_shape = 'vertical',+        cell_percentage = 20,+        cursor_shape = 'horizontal',+        full_name = 'replace',         hl_id = 46,         id_lm = 47,         mouse_shape = 0,-        short_name = 'i' },-      more = {-        mouse_shape = 0,-        short_name = 'm' },-      more_lastline = {-        mouse_shape = 0,-        short_name = 'ml' },-      normal = {+        short_name = 'r' },+      [5] = {         blinkoff = 250,         blinkon = 400,         blinkwait = 700,         cell_percentage = 0,         cursor_shape = 'block',+        full_name = 'cmdline_normal',","The decision was made in https://github.com/neovim/neovim/pull/6044 (you can search the page for justin's answer:> Yes. It's more a matter of not wanting to expose the internal order to the API, and then having to support those numbers forever more. It also is hopefully a better experience for API users.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/6546,112115098,2017-04-19T04:47:12Z,runtime/doc/develop.txt,"@@ -233,4 +225,23 @@ _not_ a Buffer). The common {action} ""list"" indicates that it lists all bufs (plural) in the global context.  +EXTERNAL UI 						*dev-ui*++External UIs should be aware of the |api-contract|. In particular, future+versions of Nvim may add optional, new items to existing events. The API is+strongly backwards-compatible, but clients must not break if new fields are+added to existing events.++External UIs are expected to implement some common features.++- Users may want to configure UI-specific options. The UI should publish the",I very much would like to eliminate ginit.vim. It's a big hack. Users should only need to have one config file to think about.,X
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/6546,112148405,2017-04-19T08:56:10Z,runtime/doc/api.txt,"@@ -55,6 +54,28 @@ error_types		Possible error types returned by API functions External programs (""clients"") can use the metadata to discover the |rpc-api|.  ==============================================================================+API contract                                                     *api-contract*++The API is made of functions and events. Basic clients interact with functions+like those described at |api-global|. Advanced clients may ""attach"" in order","I don't think ui clients are more ""advanced"". Starting to use event streams (UI is the only current one, there will be more in the future), shouldn't be seen as a step up in complexity, that is something the client simply does when it needs to.",
4070620,hardenedapple,https://api.github.com/repos/neovim/neovim/pulls/5658,112203822,2017-04-19T13:40:23Z,src/nvim/getchar.c,"@@ -2015,6 +2036,12 @@ static int vgetorpeek(int advance)             else {               int noremap; +              // If this is a LANGMAP mapping, then we didn't record the keys+              // at the start of the function and have to record them now.+              if (keylen > typebuf.tb_maplen && (mp->m_mode & LANGMAP) != 0) {+                gotchars(s, -1);","No problem.Just to note: for me LANGMAP is a very common case (~30% of keys in insert mode), but the map expansions are all one character long so it's still not a performance problem :-)",
112971,jamessan,https://api.github.com/repos/neovim/neovim/pulls/6531,112233956,2017-04-19T15:25:17Z,runtime/doc/vi_diff.txt,"@@ -124,6 +127,11 @@ Plugins.						|add-plugin| 	right directory.  That's an easy way to start using Vim scripts 	written by others.  Plugins can be for all kind of files, or 	specifically for a filetype.+	Packages make this even easier. |packages|++Asynchronous communication and timers.			|job-control| |timer|+	Nvim can exchange messages with other processes in the background.+	Nvim can start a job, communicate with it and stop it.","Upstream also mentioned timers here, to go along with the `|timer|` link.> Timers can fire once or repeatedly and invoke a function to do any work.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/6531,112265775,2017-04-19T17:31:53Z,runtime/doc/options.txt,"@@ -3499,7 +3499,7 @@ A jump table for the options with a short description can be found at |Q_op|. 	if you want to use Vim as a modeless editor. 	These Insert mode commands will be useful: 	- Use the cursor keys to move around.-	- Use CTRL-O to execute one Normal mode command |i_CTRL-O|).  When+	- Use CTRL-O to execute one Normal mode command |i_CTRL-O|.  When 	  this is a mapping, it is executed as if 'insertmode' was off.","- I intentionally left out the `c_CTRL-N` 'incsearch' stuff because it will be overridden later anyways (and we don't have that patch yet).- We default 'langremap' to ""off"" so I thought it best to leave out frantic attempts to help the user overcome bad defaults.    - ...but since you went to the trouble, I'll add it :)",
111942,tweekmonster,https://api.github.com/repos/neovim/neovim/pulls/6531,112476080,2017-04-20T14:59:40Z,runtime/plugin/matchit.vim,"@@ -1,8 +1,10 @@ ""  matchit.vim: (global plugin) Extended ""%"" matching-""  Last Change: Fri Jul 29 01:20 AM 2016 EST+""  Last Change: 2016 Aug 21 ""  Maintainer:  Benji Fisher PhD   <benji@member.AMS.org> ""  Version:     1.13.2, for Vim 6.3+ ""		Fix from Tommy Allen included.","Thanks for the effort (not just on this issue) @chrisbra!  I thought I originally emailed Benji before I commented on that old PR, but I can't find the email.  It seems he only replied when Bram cc'd him.  Maybe he's not subscribed to the list email notifications?  Still strange that he skipped the PR dealing with the jumps, though.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/6560,112649220,2017-04-21T09:29:45Z,src/nvim/getchar.h,"@@ -12,6 +12,10 @@ #define KEYLEN_PART_MAP -2      /* keylen value for incomplete mapping */ #define KEYLEN_REMOVED  9999    /* keylen value for removed sequence */ +#include ""nvim/types.h""+#include ""nvim/buffer_defs.h""+#include ""nvim/ex_cmds_defs.h""","let's keep includes near the top, i.e. line 3. (INCLUDE_GENERATED_DECLARATIONS is an exception to this)",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/6539,112655214,2017-04-21T10:01:57Z,runtime/doc/msgpack_rpc.txt,"@@ -387,10 +392,32 @@ of update. [""update_menu""] 	The menu mappings changed. -[""mode_change"", mode]-	The mode changed. Currently sent when ""insert"", ""replace"", ""cmdline"" and-	""normal"" modes are entered. A client could for instance change the cursor-	shape.+[""mode_info_set"", cursor_style_enabled, mode_info]+`mode_info` is an array containing information about various modes, as later+will be indicated with the `mode_change` update. Currently this primarily+concerns cursor styles to be set in the different modes. The keys are++	`cursor_shape`:	One of ""block"", ""horizontal"" or ""vertical""+	`cell_percentage`:Percentage of the cell taken by the cursor.+	`blinkwait`, `blinkon`, `blinkoff`: see |cursor-blinking|.+	`hl_id`:	Highlight group for the cursor.+	`hl_lm`:	Highlight group for the cursor when langmap is active.+	`short_name`:	Short name for the mode, as used in 'guicursor'+			option.+	`name`:		Full name for the mode.+	`mouse_shape`:	(To be implemented.)++Not all keys need to be present for all modes. `cursor_style_enabled` is a+boolean indicating if the ui should change the cursor style.++[""mode_change"", mode, mode_idx]+The mode changed.  The first parameter `mode` is a string representing the+current mode.  `mode_idx` is a numerical index into the array received with+the `mode_info_set` event, which contains information about the mode.  The+client should change the cursor shape accordingly, to fully support the+'guicursor' option.  The set of modes reported will change in new versions of+Nvim, for instance more submodes and temporary states might be represented as+separate modes.",> mode_idx is an index into the the list received by the `mode_info_set` event. UIs should change the cursor style according to the properties specified in the corresponding item.,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/6539,112657279,2017-04-21T10:14:08Z,runtime/doc/msgpack_rpc.txt,"@@ -270,10 +270,15 @@ a dictionary with these (optional) keys: 				Defaults to false.  Nvim will then send msgpack-rpc notifications, with the method name ""redraw""-and a single argument, an array of screen updates (described below).-These should be processed in order. Preferably the user should only be able to-see the screen state after all updates are processed (not any intermediate-state after processing only a part of the array).+and a single argument, an array of screen updates (described below).  These+should be processed in order. Preferably the user should only be able to see+the screen state after all updates in the same ""redraw"" event are processed+(not any intermediate state after processing only a part of the array).++New update kinds will be added in later versions of Nvim.  Clients should+ignore new updates it doesn't know about.  Also, new parameters might be added+to existing updates.  Clients should ignore these as well, and just use the+parameters known when the client was implemented. |api-contract|",Suggestion for the entire paragraph:> Future versions of Nvim may add new update kinds and may append new parameters to existing update kinds. Clients must be prepared to ignore such extensions (forward-compatible). |api-contract|,
886074,teto,https://api.github.com/repos/neovim/neovim/pulls/6567,112810460,2017-04-22T14:07:14Z,src/nvim/screen.c,"@@ -2232,6 +2362,24 @@ win_line (     boguscols = 0; \   } +  #define MB_IS_WIDE() ((*mb_char2cells)(mb_c) > 1)++  #define SET_CHAR(ch) \+    c = ch; \+    mb_c = c; \+    mb_l = (*mb_char2len)(c); \+    if (mb_l > 1) { \+      c = 0xc0; \+      u8cc[0] = 0; \+      mb_utf8 = true; \+    } else { \+      mb_utf8 = false; \+    }++  #define COL_ADD(var, val) var = (wp->w_p_rl) ? var - val : var + val;",parameters should have parentheses or make it a proper function ?,
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/5031,112814487,2017-04-22T17:34:40Z,src/nvim/mark_extended.c,"@@ -0,0 +1,932 @@++// mark_extended.c --+// Implements extended marks for text widgets.+// Each Mark exists in a btree of lines containing btrees+// of columns.+//+// The btree provides efficent range lookus.+// A map of pointers to the marks is used for fast lookup by mark id.+//+// Marks are moved by calls to extmark_col_adjust or+// extmark_adjust which are based on col_adjust and mark_adjust from mark.c+//+// Undo/Redo of marks is implemented by storing the call arguments to+// extmark_col_adjust or extmark_adjust. The list of arguments+// is traversed in extmark_iter_undo and applied in extmark_apply_undo+//+// For possible ideas for efficency improvements see:+// http://blog.atom.io/2015/06/16/optimizing-an-important-atom-primitive.html+// Other implementations exist in gtk and tk toolkits.++#include <assert.h>++#include ""nvim/vim.h""+#include ""nvim/mark_extended.h""+#include ""nvim/memory.h""+#include ""nvim/pos.h""          // MAXLNUM+#include ""nvim/globals.h""      // FOR_ALL_BUFFERS+#include ""nvim/map.h""          // pmap ...+#include ""nvim/lib/kbtree.h""   // kbitr ...+#include ""nvim/undo_defs.h""    // u_header_T+#include ""nvim/undo.h""         // u_save_cursor++#ifdef INCLUDE_GENERATED_DECLARATIONS+# include ""mark_extended.c.generated.h""+#endif++static uint64_t namespace_counter = 0;++// Required before calling any other functions+uint64_t extmark_ns_create(char *ns)+{+  if (!namespace_counter) {+    EXTMARK_NAMESPACES = map_new(uint64_t, cstr_t)();+  }+  // Ensure the namespace is unique+  cstr_t value;+  map_foreach_value(EXTMARK_NAMESPACES, value, {+    if (STRCMP(ns, value) == 0) {","Plugins wouldn't break other plugins, they do separate calls to `nvim_init_mark_ns` and thus get different values, even if they use the same name accidentally. In principle also one plugin can allocate several namespaces, ideally it would then use different names but I don't think it is an error if it uses the same name.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/5031,112815989,2017-04-22T18:45:09Z,src/nvim/api/buffer.c,"@@ -703,6 +708,360 @@ ArrayOf(Integer, 2) nvim_buf_get_mark(Buffer buffer, String name, Error *err)   return rv; } +/// Returns mark info at the given position or mark index+///+/// @param buffer The buffer handle+/// @param namespace a identifier returned previously with extmark_ns_create+/// @param id (row, col) or mark_id of mark+/// @param[out] err Details of an error that may have occurred+/// @return (mark_id, row, col) tuple+ArrayOf(Object) nvim_buf_get_mark_index(Buffer buffer,+                                        Integer namespace,+                                        Object id,+                                        Error *err)+    FUNC_API_SINCE(1)+{+  Array rv = ARRAY_DICT_INIT;++  ExtendedMark *extmark = extmark_from_id_or_pos(buffer, namespace, id, err,+                                                 true);++  if (!extmark) {+    return rv;+  }+  ADD(rv, INTEGER_OBJ((Integer)extmark->mark_id));+  ADD(rv, INTEGER_OBJ((Integer)extmark->line->lnum));+  ADD(rv, INTEGER_OBJ((Integer)extmark->col));+  return rv;+}++/// Returns an ordered list of mark info+///+/// @param buffer The buffer handle+/// @param[out] err Details of an error that may have occurred+/// @return [(mark_id, row, col), ...]+ArrayOf(Object) nvim_buf_get_mark_ids(Buffer buffer,+                                      Integer namespace,+                                      Error *err)+    FUNC_API_SINCE(1)+{+  Array rv = ARRAY_DICT_INIT;+  buf_T *buf = find_buffer_by_handle(buffer, err);++  if (!buf) {+    return rv;+  }++  uint64_t ns = (uint64_t)namespace;+  Array mark = ARRAY_DICT_INIT;+  FOR_ALL_EXTMARKS(buf, ns, 0, 0, -1, -1, {+    if (extmark->ns_id == ns) {+      mark.size = 0;+      mark.capacity = 0;+      mark.items = 0;+      ADD(mark, INTEGER_OBJ((Integer)extmark->mark_id));+      ADD(mark, INTEGER_OBJ(extmark->line->lnum));+      ADD(mark, INTEGER_OBJ(extmark->col));+      ADD(rv, ARRAY_OBJ(mark));+    }+  })+  return rv;+}++/// Returns mark info of the mark following the given index+/// If there are no following marks returns an empty list+///+/// @param buffer The buffer handle+/// @param namespace a identifier returned previously with extmark_ns_create+/// @param id The mark's id+/// @param[out] err Details of an error that may have occurred+/// @return (id, row, col)+ArrayOf(Integer, 3) nvim_buf_get_next_mark(Buffer buffer,+                                           Integer namespace,+                                           Object id,+                                           Error *err)+    FUNC_API_SINCE(1)+{+  Array rv = ARRAY_DICT_INIT;+  if (!ns_initialized((uint64_t)namespace)) {+    api_set_error(err, Validation, _(""Invalid mark namespace""));+    return rv;+  }++  linenr_T lnum;+  colnr_T col;+  bool _err = false;+  // extremity=false+  SET_EXTMARK_INDEX_FROM_OBJ(id, lnum, col, _err, false);+  if (!_err) {+    return rv;+  }++  bool match = false;+  buf_T *buf = find_buffer_by_handle(buffer, err);+  ExtendedMark *next = extmark_next(buf,+                                    (uint64_t)namespace,+                                    lnum,+                                    col,+                                    match);+  if (next) {+    ADD(rv, INTEGER_OBJ((Integer)next->mark_id));+    ADD(rv, INTEGER_OBJ(next->line->lnum));+    ADD(rv, INTEGER_OBJ(next->col));+  }+  return rv;+}++/// Returns mark info inbetween and including the bounds+/// If there are no following marks returns empty list+///+/// @param buffer The buffer handle+/// @param namespace a identifier returned previously with extmark_ns_create+/// @param lower (row, col) or mark_id of lower bound+/// @param uower (row, col) or mark_id of upper bound+/// @param[out] err Details of an error that may have occurred+/// @return [(mark_id, row, col), ...]+ArrayOf(Object) nvim_buf_get_next_markrange(Buffer buffer,","As a precedent, we decided to similarly remove superfluous aliases for get/set buffer line functionality. It might dealing with single marks a bit more inconvenient, but same as for buffer lines it serves a point to nudge API users towards using more efficient range API. Wrappers for convenience can be done on client/vimscript side, we prefer to not have unnecessary core API functions.",
886074,teto,https://api.github.com/repos/neovim/neovim/pulls/6567,112819311,2017-04-22T21:32:30Z,src/nvim/screen.c,"@@ -2081,6 +2058,151 @@ fill_foldcolumn (   } } ++static int get_column_diff_until_eol(win_T* wp, int col) {","I might be nitpicking but diff can be ambiguous (like git diff) so I suggest ""get_(column_)span_until_eol""  ?",
886074,teto,https://api.github.com/repos/neovim/neovim/pulls/6567,112819344,2017-04-22T21:34:59Z,src/nvim/screen.c,"@@ -2081,6 +2058,151 @@ fill_foldcolumn (   } } ++static int get_column_diff_until_eol(win_T* wp, int col) {+  return (wp->w_p_rl ? col : wp->w_width - 1 - col);+}++static bool character_fits_at_col(int mb_c, int col, win_T* wp) {+  return !((wp->w_p_rl ? (col <= 0) : (col >= wp->w_width - 1))+           && (*mb_char2cells)(mb_c) == 2);+}++static bool should_conceal_line(win_T* wp, linenr_T lnum, bool lnum_in_visual_area) {+  return (wp->w_p_cole > 0+          && (wp != curwin || lnum != wp->w_cursor.lnum || conceal_cursor_line(wp))+          && !(lnum_in_visual_area && vim_strchr(wp->w_p_cocu, 'v') == NULL));+}++static bool should_correct_column(win_T* wp, linenr_T lnum, int col) {+  return (curwin == wp+          && lnum == wp->w_cursor.lnum+          && conceal_cursor_line(wp)+          && (int)wp->w_virtcol <= col);+}++static bool init_syntax(int lnum, win_T* wp) {+  int save_did_emsg;+  if (syntax_present(wp) && !wp->w_s->b_syn_error) {+    save_did_emsg = did_emsg;+    did_emsg = FALSE;+    syntax_start(wp, lnum); // Prepare for syntax highlighting in this line.+    if (did_emsg) {         // On error, stop syntax highlighting.+      wp->w_s->b_syn_error = TRUE;+    } else {+      did_emsg = save_did_emsg;+      return true;+    }+  }+  return false;+}++static bool can_spell(win_T* wp) {+  return (wp->w_p_spell+          && *wp->w_s->b_p_spl != NUL+          && !GA_EMPTY(&wp->w_s->b_langp)+          && *(char **)(wp->w_s->b_langp.ga_data) != NULL);+}++struct VisualPos {+  int from;+  int to;+  bool in_visual;+  pos_T pos;+};++static struct VisualPos init_visual(int lnum, win_T* wp) {+  struct VisualPos res = {+    .from = -10,+    .to = MAXCOL,+    .in_visual = false,+    .pos = {+      .lnum = 0,+      .col = 0,+      .coladd = 0+    }+  };++  pos_T *top, *bot;++  // Visual is after curwin->w_cursor+  if (ltoreq(curwin->w_cursor, VIsual)) {+    top = &curwin->w_cursor;+    bot = &VIsual;+  }+  // Visual is before curwin->w_cursor */+  else {+    top = &VIsual;+    bot = &curwin->w_cursor;+  }++  res.in_visual = (lnum >= top->lnum && lnum <= bot->lnum);++  // block mode+  if (VIsual_mode == Ctrl_V) {+    if (res.in_visual) {+      res.from = wp->w_old_cursor_fcol;+      res.to   = wp->w_old_cursor_lcol;+    }+  } // non-block mode+  else {+    if (lnum > top->lnum && lnum <= bot->lnum) {+      res.from = 0;+    } else if (lnum == top->lnum) {+      if (VIsual_mode == 'V') { // linewise+        res.from = 0;+      } else {+        getvvcol(wp, top, (colnr_T *)&res.from, NULL, NULL);+        if (gchar_pos(top) == NUL)+          res.to = res.from + 1;+      }+    }+    if (VIsual_mode != 'V' && lnum == bot->lnum) {+      if (*p_sel == 'e' && bot->col == 0 && bot->coladd == 0) {+        res.from = -10;+        res.to = MAXCOL;+      } else if (bot->col == MAXCOL) {+        res.to = MAXCOL;+      } else {+        res.pos = *bot;+        if (*p_sel == 'e') {+          getvvcol(wp, &res.pos, (colnr_T *)&res.to, NULL, NULL);+        } else {+          getvvcol(wp, &res.pos, NULL, NULL, (colnr_T *)&res.to);+          res.to++;+        }+      }+    }+  }++  return res;+}++static void write_char(int c, int mb_c, int mb_utf8, int attr, unsigned off, int *u8cc) {",many parameters might be helpful to document them.mb_utf8 could be a bool.,
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/6569,112828170,2017-04-23T08:23:01Z,src/nvim/api/private/helpers.h,"@@ -8,15 +8,10 @@ #include ""nvim/memory.h"" #include ""nvim/lib/kvec.h"" +void _api_set_error(Error *err, ErrorType errType, const char *format, ...); // -V:api_set_error:618 #define api_set_error(err, errtype, ...) \-  do { \-    snprintf((err)->msg, \-             sizeof((err)->msg), \-             __VA_ARGS__); \-    (err)->set = true; \-    (err)->type = kErrorType##errtype; \-  } while (0)+  _api_set_error(err, kErrorType##errtype, __VA_ARGS__)","The macro should be all-caps. So the function could be used without leading underscore. And there is no need to duplicate declaration, macro is not used before including `api/private/helpers.h.generated.h`.",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/6569,112828249,2017-04-23T08:28:09Z,src/nvim/api/private/helpers.h,"@@ -8,15 +8,10 @@ #include ""nvim/memory.h"" #include ""nvim/lib/kvec.h"" +void _api_set_error(Error *err, ErrorType errType, const char *format, ...); // -V:api_set_error:618 #define api_set_error(err, errtype, ...) \-  do { \-    snprintf((err)->msg, \-             sizeof((err)->msg), \-             __VA_ARGS__); \-    (err)->set = true; \-    (err)->type = kErrorType##errtype; \-  } while (0)+  _api_set_error(err, kErrorType##errtype, __VA_ARGS__)","Though I do not see much sense in the macro any longer: it only hides `kErrorType` prefix, not something I would consider good under this circumstances (when passing e.g. Validation to a function you would not expect that it is not a full identifier, but a part of it: all-lower does not look like a macro; with all-caps this is slightly better but I do not think ten characters are worth it).",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/6569,112828272,2017-04-23T08:29:37Z,src/nvim/api/private/defs.h,"@@ -38,7 +38,7 @@ typedef enum {  typedef struct {   ErrorType type;-  char msg[1024];+  char *msg;   bool set;",I usually put such data into `type` if present: if I was writing this struct there would be `kErrorTypeNone` and no flag.,
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/6569,112829418,2017-04-23T09:40:00Z,src/nvim/tui/input.c,"@@ -225,7 +225,7 @@ static int get_key_code_timeout(void)   if (nvim_get_option(cstr_as_string(""ttimeout""), &err).data.boolean) {     ms = nvim_get_option(cstr_as_string(""ttimeoutlen""), &err).data.integer;",In case of an error `....data.integer` seems to be `0`. But should `ms` not keep the value `-1`?,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/5266,112925646,2017-04-24T11:49:43Z,src/nvim/lib/kbtree.h,"@@ -0,0 +1,430 @@+/*-+ * Copyright 1997-1999, 2001, John-Mark Gurney.+ *           2008-2009, Attractive Chaos <attractor@live.co.uk>+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions+ * are met:+ *+ * 1. Redistributions of source code must retain the above copyright+ *    notice, this list of conditions and the following disclaimer.+ * 2. Redistributions in binary form must reproduce the above copyright+ *    notice, this list of conditions and the following disclaimer in the+ *    documentation and/or other materials provided with the distribution.+ *+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF+ * SUCH DAMAGE.+ */++#ifndef NVIM_LIB_KBTREE_H+#define NVIM_LIB_KBTREE_H++#include <stdlib.h>+#include <string.h>+#include <stdint.h>++#define KB_MAX_DEPTH 64++#define	__KB_KEY(type, x)	(x->key)+#define __KB_PTR(btr, x)	(x->ptr)++#define __KB_TREE_T(name,key_t,T)						\+    typedef struct kbnode_##name##_s kbnode_##name##_t;     \+    struct kbnode_##name##_s {              \+      int32_t n; \+      bool is_internal; \+      key_t key[2*T-1]; \+      kbnode_##name##_t *ptr[]; \+    } ; \+    \+    typedef struct { \+        kbnode_##name##_t *root; \+        int	n_keys, n_nodes; \+    } kbtree_##name##_t; \+    \+    typedef struct { \+        kbnode_##name##_t *x; \+        int i; \+    } kbpos_##name##_t; \+    typedef struct { \+        kbpos_##name##_t stack[KB_MAX_DEPTH], *p; \+    } kbitr_##name##_t; \+++#define __kb_destroy(kbnode_t,b) do {											\+		int i;                                                          \+        unsigned int max = 8;											\+		kbnode_t *x, **top, **stack = 0;								\+		if (b->root) {													\+			top = stack = (kbnode_t**)calloc(max, sizeof(kbnode_t*));	\+			*top++ = (b)->root;											\+			while (top != stack) {										\+				x = *--top;												\+				if (x->is_internal == 0) { free(x); continue; }			\+				for (i = 0; i <= x->n; ++i)								\+					if (__KB_PTR(b, x)[i]) {							\+						if (top - stack == (int)max) {		        	\+							max <<= 1;									\+							stack = (kbnode_t**)realloc(stack, max * sizeof(kbnode_t*)); \","Should we not use xrealloc and xcalloc in kbtree.h, as we do in klist.h?(I wonder why clint didn't catch this)",
112971,jamessan,https://api.github.com/repos/neovim/neovim/pulls/6581,113043176,2017-04-24T20:07:05Z,ci/common/build.sh,"@@ -46,10 +45,10 @@ build_deps() { }  prepare_build() {-  if [[ -n ""${CLANG_SANITIZER}"" ]]; then+  if test -n ""${CLANG_SANITIZER}"" ; then     CMAKE_FLAGS=""${CMAKE_FLAGS} -DCLANG_${CLANG_SANITIZER}=ON""   fi-  if [[ ""${BUILD_32BIT}"" == ON ]]; then+  if test ""x${BUILD_32BIT}"" = xON ; then","Quoting [this](http://www.pixelbeat.org/programming/shell_script_mistakes.html):> [ x""$var"" = x""find"" ] && echo foundThe use of x""$var"" was required in case var is """" or ""-hyphen"". Thinking about this for a moment should indicate that the shell can handle both of these cases unambiguously, and if it doesn't it's a bug. This bug was probably fixed about 20 years ago, so stop propagating this nonsense please! Shell doesn't have the cleanest syntax to start with, so polluting it with stuff like this is horrible.",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/6581,113043539,2017-04-24T20:08:48Z,ci/common/build.sh,"@@ -7,27 +7,26 @@ build_make() { }  build_deps() {-  if [[ ""${BUILD_32BIT}"" == ON ]]; then+  if test ""x${BUILD_32BIT}"" = xON ; then     DEPS_CMAKE_FLAGS=""${DEPS_CMAKE_FLAGS} ${CMAKE_FLAGS_32BIT}""   fi-  if [[ ""${FUNCTIONALTEST}"" == ""functionaltest-lua"" ]]; then+  if test ""x${FUNCTIONALTEST}"" = ""xfunctionaltest-lua"" ; then","BTW, `/usr/bin/\[ --help` prints usage, starting with `Usage: test EXPRESSION` (note: `test`). `test --help`  prints nothing (guess because it is a test for emptyness, like `[ --help ]` would be). And executables have different sizes, `[` is larger by 4 KiB.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/6583,113156691,2017-04-25T10:12:28Z,src/nvim/screen.c,"@@ -7027,6 +7033,28 @@ static void draw_tabline(void)   redraw_tabline = FALSE; } +// send tabline update to external ui+void ui_ext_tabline_update(void)+{+  Array args = ARRAY_DICT_INIT;+  ADD(args, INTEGER_OBJ(curtab->handle));+  Array tabs = ARRAY_DICT_INIT;+  FOR_ALL_TABS(tp) {+    win_T *cwp = (tp == curtab) ? curwin : tp->tp_curwin;+    get_trans_bufname(cwp->w_buffer);+    Array tab = ARRAY_DICT_INIT;+    ADD(tab, INTEGER_OBJ(tp->handle));","or compare against objects from `nvim('list_tabpages')`, this is what the API tests do.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/5031,113177632,2017-04-25T12:11:40Z,src/nvim/api/buffer.c,"@@ -702,6 +706,166 @@ ArrayOf(Integer, 2) nvim_buf_get_mark(Buffer buffer, String name, Error *err)    return rv; }+//+/// Returns mark info in a range (inclusive)+/// If there are no following marks returns empty list+///+/// @param buffer The buffer handle+/// @param namespace an id returned previously from extmark_ns_create+/// @param lower any valid mark identifier (row, col) or mark_id or -1+/// @param upper any valid mark identifier (row, col) or mark_id or -1+/// @param amount Maximum number of extmarks to return+/// @param reverse Decides the search direction in the range+/// @param[out] err Details of an error that may have occurred+/// @return [[mark_id, row, col], ...]+ArrayOf(Object) nvim_buf_get_marks(Buffer buffer,+                                   Integer namespace,+                                   Object lower,+                                   Object upper,+                                   Integer amount,+                                   Boolean reverse,+                                   Error *err)+    FUNC_API_SINCE(1)+{+  Array rv = ARRAY_DICT_INIT;+  if (!ns_initialized((uint64_t)namespace)) {+    api_set_error(err, Validation, _(""Invalid mark namespace""));+    return rv;+  }++  if(amount == 0) {+    api_set_error(err, Validation, _(""Amount must be greater than 0""));+    return rv;+  }++  linenr_T l_lnum;+  colnr_T l_col;+  bool l_set = false;+  SET_EXTMARK_INDEX_FROM_OBJ(lower, l_lnum, l_col, l_set);","Is it really easier to reuse as a macro? The only macro feature used is return variables, but that could just as well be pointer parameters or return a struct. If the compiler decides the function worth inlining, the end result will be more or less the same. ",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/6583,113253712,2017-04-25T17:03:49Z,src/nvim/screen.c,"@@ -7027,6 +7033,28 @@ static void draw_tabline(void)   redraw_tabline = FALSE; } +// send tabline update to external ui+void ui_ext_tabline_update(void)+{+  Array args = ARRAY_DICT_INIT;+  ADD(args, INTEGER_OBJ(curtab->handle));+  Array tabs = ARRAY_DICT_INIT;+  FOR_ALL_TABS(tp) {+    win_T *cwp = (tp == curtab) ? curwin : tp->tp_curwin;+    get_trans_bufname(cwp->w_buffer);+    Array tab = ARRAY_DICT_INIT;+    ADD(tab, INTEGER_OBJ(tp->handle));","It is awkward due to limitations in neovim-lua. In the python-client (and similarly in other plugin hosts) you get a useful object you can call methods on, assign to `nvim.current.tabpage` etc. The lua client should at least be fixed to decode the id so that it prints like `{[id]=1}`.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/6592,113510592,2017-04-26T17:11:34Z,test/functional/ui/inccommand_spec.lua,"@@ -805,6 +805,7 @@ describe("":substitute, inccommand=split"", function()   it('does not show split window for :s/', function()     feed(""2gg"")     feed("":s/tw"")+    screen:sleep(1)","There's nothing directly wrong with it, but I'd be surprised if sleeping 1ms makes such a big difference.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/6583,113634401,2017-04-27T07:50:58Z,src/nvim/screen.c,"@@ -7027,6 +7032,26 @@ static void draw_tabline(void)   redraw_tabline = FALSE; } +void ui_ext_tabline_update(void)+{+  Array args = ARRAY_DICT_INIT;+  ADD(args, INTEGER_OBJ(curtab->handle));+  Array tabs = ARRAY_DICT_INIT;+  FOR_ALL_TABS(tp) {+    Dictionary tab_info = ARRAY_DICT_INIT;+    PUT(tab_info, ""tab"", TABPAGE_OBJ(tp->handle));","You need an msgpack library capable of extension types. The EXT value can either be sent as-is to any method expecting a tabpage, or the internal data can be decoded as a msgpack INT.",
886074,teto,https://api.github.com/repos/neovim/neovim/pulls/6566,113790786,2017-04-27T20:09:58Z,src/nvim/syntax.c,"@@ -8251,9 +8256,37 @@ color_name_table_T color_name_table[] = {   { NULL, 0 }, }; +/// Tranlate terminal color to one of cterm_color_names.+/// color_to_name can then be used to retrieve RgbValue+///+/// @return NULL if could not find+/// @see color_to_name+const char *cterm_int2name(int color)+{+  int *color_idx = NULL;+  if (color >= 27 || color < 0) {+    return NULL;+  }++  switch (t_colors) {+    case 8: color_idx = color_numbers_8;break;+    case 16: color_idx = color_numbers_16;break;+    case 88: color_idx = color_numbers_88;break;+    case 256: color_idx = color_numbers_256;break;+    default: return NULL;+  };++  for (int i = ARRAY_SIZE(cterm_color_names); i-- >= 0; ) {+    if (color == color_idx[i]) {+      return cterm_color_names[i];+    }+  }++  return NULL;+}",shouldn't this function along with cterm_color_name and color_numbers_X live in one of the terminal libraries ?,
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/6162,113860800,2017-04-28T06:38:14Z,runtime/doc/msgpack_rpc.txt,"@@ -445,5 +446,24 @@ states might be represented as separate modes. 	curtab:	  Current Tabpage 	tabs:	  List of Dicts [{ ""tab"": Tabpage, ""name"": String }, ...] +							*ui-ext-cmdline*+[""cmdline_enter""]+	Enter the cmdline.++[""cmdline_leave""]+	Leave the cmdline.++[""cmdline_show"", content, pos, firstc, prompt]","Still, what about making `content` be a list of pairs `[highlight group, string]` (always one item `content=[[""Normal"", text]]` in this PR because cmdline highlighting PR is not finished yet)?",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/6162,113874513,2017-04-28T08:05:18Z,src/nvim/ex_getln.c,"@@ -2263,20 +2280,56 @@ static void draw_cmdline(int start, int len)     msg_outtrans_len(ccline.cmdbuff + start, len); } +void ui_ext_cmdline_char(int c, int shift)+{+    Array args = ARRAY_DICT_INIT;+    ADD(args, STRING_OBJ(cstr_to_string((char *)(&c))));+    ADD(args, INTEGER_OBJ(shift));+    ui_event(""cmdline_char"", args);+}++void ui_ext_cmdline_show(void)+{+    Array args = ARRAY_DICT_INIT;+    Array content = ARRAY_DICT_INIT;+    Array text = ARRAY_DICT_INIT;+    ADD(text, STRING_OBJ(cstr_to_string(""Normal"")));+    ADD(text, STRING_OBJ(cstr_to_string((char *)(ccline.cmdbuff))));+    ADD(content, ARRAY_OBJ(text));+    ADD(args, ARRAY_OBJ(content));+    ADD(args, INTEGER_OBJ(ccline.cmdpos));+    if (ccline.cmdfirstc != NUL) {+      ADD(args, STRING_OBJ(cstr_to_string((char *)(&ccline.cmdfirstc))));","This is not safe, cmdfirstc is an `int`. (it works accidentally on a LE platform as long as firstc is ASCII)",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/6162,113879735,2017-04-28T08:36:18Z,src/nvim/ex_getln.c,"@@ -1669,7 +1672,16 @@ getcmdline (     int indent               // indent for inside conditionals ) {-  return command_line_enter(firstc, count, indent);+  if (ui_is_external(kUICmdline)) {+    Array args = ARRAY_DICT_INIT;+    ui_event(""cmdline_enter"", args);+  }+  char_u *p = command_line_enter(firstc, count, indent);+  if (ui_is_external(kUICmdline)) {+    Array args = ARRAY_DICT_INIT;+    ui_event(""cmdline_leave"", args);",cmdline_hide,
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/6162,113881961,2017-04-28T08:49:51Z,src/nvim/ex_getln.c,"@@ -2263,20 +2280,56 @@ static void draw_cmdline(int start, int len)     msg_outtrans_len(ccline.cmdbuff + start, len); } +void ui_ext_cmdline_char(int c, int shift)+{+    Array args = ARRAY_DICT_INIT;+    ADD(args, STRING_OBJ(cstr_to_string((char *)(&c))));+    ADD(args, INTEGER_OBJ(shift));+    ui_event(""cmdline_char"", args);+}++void ui_ext_cmdline_show(void)+{+    Array args = ARRAY_DICT_INIT;+    Array content = ARRAY_DICT_INIT;+    Array text = ARRAY_DICT_INIT;+    ADD(text, STRING_OBJ(cstr_to_string(""Normal"")));+    ADD(text, STRING_OBJ(cstr_to_string((char *)(ccline.cmdbuff))));+    ADD(content, ARRAY_OBJ(text));+    ADD(args, ARRAY_OBJ(content));+    ADD(args, INTEGER_OBJ(ccline.cmdpos));+    if (ccline.cmdfirstc != NUL) {+      ADD(args, STRING_OBJ(cstr_to_string((char *)(&ccline.cmdfirstc))));","One could avoid buf with `(String) { .size = 1, .data = xmemdupz((char []) { (char)ccline.cmdfirstc }, 1) }`.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/6162,113887663,2017-04-28T09:20:34Z,src/nvim/ex_getln.c,"@@ -1669,7 +1672,16 @@ getcmdline (     int indent               // indent for inside conditionals ) {-  return command_line_enter(firstc, count, indent);+  if (ui_is_external(kUICmdline)) {+    Array args = ARRAY_DICT_INIT;+    ui_event(""cmdline_enter"", args);","I don't think the ui is really supposed to keep track of the mode stack-machine, it should just be told what to draw right now. When entering the sub cmdline it will see `cmdline_show` with the new relevant attributes. When leaving, it will see `cmdline_hide` immediately followed by `cmdline_show` for the outer command line. In the end it will always see consistent state.",
1169480,dzhou121,https://api.github.com/repos/neovim/neovim/pulls/6162,113888524,2017-04-28T09:25:48Z,src/nvim/ex_getln.c,"@@ -1669,7 +1672,16 @@ getcmdline (     int indent               // indent for inside conditionals ) {-  return command_line_enter(firstc, count, indent);+  if (ui_is_external(kUICmdline)) {+    Array args = ARRAY_DICT_INIT;+    ui_event(""cmdline_enter"", args);",I think we can leave the UI to decide whether they want to implement this complexity. What's the drawbacks to enable this new event?,
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/6162,113889467,2017-04-28T09:30:50Z,src/nvim/ex_getln.c,"@@ -1669,7 +1672,16 @@ getcmdline (     int indent               // indent for inside conditionals ) {-  return command_line_enter(firstc, count, indent);+  if (ui_is_external(kUICmdline)) {+    Array args = ARRAY_DICT_INIT;+    ui_event(""cmdline_enter"", args);","Separation of concerns. We do want richer mode change events, but that's relevant not only for ui, and it doesn't belong in `ext_cmdline`. These events should just tell the ui the current cmdline state to draw.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/6162,113894903,2017-04-28T10:01:47Z,src/nvim/ex_getln.c,"@@ -1669,7 +1672,16 @@ getcmdline (     int indent               // indent for inside conditionals ) {-  return command_line_enter(firstc, count, indent);+  if (ui_is_external(kUICmdline)) {+    Array args = ARRAY_DICT_INIT;+    ui_event(""cmdline_enter"", args);","True, but that can be done in a state-less way by adding a `level` field to `show` and `hide`. If an ui attaches in the middle of cmdline, we do not need to ""simulate"" enter events for it to get a consistent world view. That will also incidentally work better with cmdline window. Then the first-level cmdline (if it ever was shown) will be hidden (as it is now drawn in a window), and if the user does `:` again, only the second-level cmdline will be shown.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/6162,113895164,2017-04-28T10:03:23Z,src/nvim/ex_getln.c,"@@ -2263,20 +2280,56 @@ static void draw_cmdline(int start, int len)     msg_outtrans_len(ccline.cmdbuff + start, len); } +void ui_ext_cmdline_char(int c, int shift)","it is short, and not longer than the other branch in the calling function, we should not ""hide away"" ext ui code specifically, it is as important as the other branch.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/6162,113937307,2017-04-28T14:03:26Z,src/nvim/ex_getln.c,"@@ -2263,20 +2280,56 @@ static void draw_cmdline(int start, int len)     msg_outtrans_len(ccline.cmdbuff + start, len); } +void ui_ext_cmdline_char(int c, int shift)","But it's not a tag, and it doesn't encourage gathering all the state and logic needed to externalize the widget. It's a simple pattern that can be recommended for all of the externalized widgets, instead of having to analyze each case. In the few cases where we can provide concrete guidelines instead of ""use your judgement"" it's a really nice to be able to do so.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/6162,113939921,2017-04-28T14:15:34Z,src/nvim/ex_getln.c,"@@ -2263,20 +2280,56 @@ static void draw_cmdline(int start, int len)     msg_outtrans_len(ccline.cmdbuff + start, len); } +void ui_ext_cmdline_char(int c, int shift)","But what is it there we need to analyze? In `putcmdline()` there is a branch:     if (!ui_is_external(kUICmdline)) {         // do stuff    } else {        // do other stuff    }`ui_ext_cmdline_show` makes sense because the code is long. But otherwise why should `other stuff""` be in a separate function when `stuff` isn't? ",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/6162,113940852,2017-04-28T14:19:58Z,src/nvim/ex_getln.c,"@@ -2263,20 +2280,56 @@ static void draw_cmdline(int start, int len)     msg_outtrans_len(ccline.cmdbuff + start, len); } +void ui_ext_cmdline_char(int c, int shift)","the pattern ""certain classes of code must be in a separate function, even if it is very short and integral with the surrounding code"" I have never heard of.OTOH, what could make sense is generating marshaling wrappers, to avoid manually contructing the outermost array. But there will still be external ui specific code to prepare the values, and contruct inner arrays/dicts.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/6162,113942076,2017-04-28T14:25:12Z,src/nvim/ex_getln.c,"@@ -2263,20 +2280,56 @@ static void draw_cmdline(int start, int len)     msg_outtrans_len(ccline.cmdbuff + start, len); } +void ui_ext_cmdline_char(int c, int shift)","If this pattern is followed it's easy to undo later. The converse is probably not.In most of these cases the function is already full of a lot of noise. Giving the reader a signal ""go here for the externalized logic"" is helpful. The fact that some cases the logic is small just means when a few lines are added here and there later, we have to have this discussion again.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/6162,113943112,2017-04-28T14:29:15Z,src/nvim/ex_getln.c,"@@ -2263,20 +2280,56 @@ static void draw_cmdline(int start, int len)     msg_outtrans_len(ccline.cmdbuff + start, len); } +void ui_ext_cmdline_char(int c, int shift)","> the pattern ""certain classes of code must be in a separate function, even if it is very short and integral with the surrounding code"" I have never heard of.The API functions and `foo_event` handlers are somewhat analogous. ""Externalized widgets"" are special and should be called out. Regularity is really helpful. And given that these functions are part of a class as you noted, formalizing the name under a psuedo-namespace natural.Most logic isn't trivially assignable to a class or pattern. Why not take the few opportunities that we can?",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/6162,113951279,2017-04-28T15:03:35Z,src/nvim/ex_getln.c,"@@ -2263,20 +2280,56 @@ static void draw_cmdline(int start, int len)     msg_outtrans_len(ccline.cmdbuff + start, len); } +void ui_ext_cmdline_char(int c, int shift)","I don't disagree, and I strongly agree about avoiding needless indirection/abstraction. I see this case as an exception, it's a way of labeling an important special class of functionality. I'm not concerned about grepping.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/6162,113957800,2017-04-28T15:32:08Z,src/nvim/ex_getln.c,"@@ -2263,20 +2280,56 @@ static void draw_cmdline(int start, int len)     msg_outtrans_len(ccline.cmdbuff + start, len); } +void ui_ext_cmdline_char(int c, int shift)","Maybe my point is better illustrated by an example:```/// Undisplay the popup menu (later).void pum_undisplay(void){  pum_is_visible = false;  pum_array = NULL;  if (pum_external) {    Array args = ARRAY_DICT_INIT;    ui_event(""popupmenu_hide"", args);  } else {    redraw_all_later(SOME_VALID);    redraw_tabline = true;    status_redraw_all();  }}```The relevant abstraction here is already `pum_undisplay()`. If we add yet another layer, the actual `ui_event` (or maybe later `ui_popupmenu_hide() ` auto generated wrapper), will be doubly divorced from the true source of the ui change, the calls to `pum_undisplay()`.  In both this and the `cmdline_putchar` case that will be a very short function one is forced to analyze separately (from the true abstraction point) to make sure it don't have extra conditions etc. On the other side, `ui_ext_tabline_show` and `cmdline_show` makes sense as there actually are some logic going on. Also, it would make sense to extract the external logic  in `pum_display` to _one_ function, even if it might result in two different events. To put it bluntly, I don't see how a bad pattern becomes a good pattern just because one uses it consistently.",
112971,jamessan,https://api.github.com/repos/neovim/neovim/pulls/6566,114064248,2017-04-30T00:32:18Z,src/nvim/tui/tui.c,"@@ -1021,10 +1053,11 @@ static void fix_terminfo(TUIData *data) end:   // Fill some empty slots with common terminal strings   if (data->term == kTermiTerm) {-    data->unibi_ext.set_cursor_color = (int)unibi_add_ext_str(+    data->unibi_ext.set_cursor_bg_color = (int)unibi_add_ext_str(         ut, NULL, ""\033]Pl%p1%06x\033\\"");   } else {-    data->unibi_ext.set_cursor_color = (int)unibi_add_ext_str(+    // new form rgb:X/X/X does not seem to work so well","vte is [supposed](https://git.gnome.org/browse/vte/tree/src/vtetypes.cc?id=a31a41d2a93ef45c3940d714f82f58c6b3f9d7d8#n84) to convert the `rgb:rrr/ggg/bbb` (independent of the arity of each color) to the `#rrrgggbbb` form and then pass that on to [`pango_color_parse`](https://developer.gnome.org/pango/stable/pango-Text-Attributes.html#pango-color-parse).Older versions of vte used [`gdk_parse_color`](https://developer.gnome.org/gdk3/stable/gdk3-Colors.html#gdk-color-parse) instead, but either one should handle the format fine.If you're seeing different behavior, then I'd either guess it's an old version of vte or the terminal using vte is doing something wrong.",
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/6619,114075931,2017-04-30T13:55:00Z,src/nvim/ex_cmds.lua,"@@ -3003,6 +3003,12 @@ return {     func='ex_map',   },   {+    command='fnew',+    flags=bit.bor(BANG, FILE1, RANGE, NOTADR, EDITCMD, ARGOPT, TRLBAR),+    addr_type=ADDR_LINES,+    func='ex_newfwin',+  },","Ordering of the commands is important, see https://github.com/neovim/neovim/blob/master/src/nvim/ex_cmds_defs.h#L15-L39. Otherwise the generated array `cmdidxs` is not correct.",
112971,jamessan,https://api.github.com/repos/neovim/neovim/pulls/6627,114126028,2017-05-01T13:42:17Z,ci/common/suite.sh,"@@ -11,14 +11,37 @@ FAIL_SUMMARY="""" END_MARKER=""$BUILD_DIR/.tests_finished"" FAIL_SUMMARY_FILE=""$BUILD_DIR/.test_errors"" +ANSI_CLEAR=""\033[0K""++travis_fold() {+  local action=""$1""+  local name=""$2""+  name=""$(echo -n ""$name"" | tr '\n\0' '--' | sed -r 's/[^A-Za-z0-9]+/-/g')""+  name=""$(echo -n ""$name"" | sed -r 's/-$//')""","BRE syntax doesn't support `\+`.Apple's [re_format(7)](https://developer.apple.com/legacy/library/documentation/Darwin/Reference/ManPages/man7/re_format.7.html#//apple_ref/doc/man/7/re_format) and GNU's [regex(7)](https://manpages.debian.org/jessie/manpages/regex.7.en.html) both describe BRE in similar wording:```Obsolete (``basic'') regular expressions differ in several respects.  `|' is an ordinary character andthere is no equivalent for its functionality.  `+' and `?' are ordinary characters, and their functionalitycan be expressed using bounds (`{1,}' or `{0,1}' respectively).  Also note that `x+' in modernREs is equivalent to `xx*'.  The delimiters for bounds are `\{' and `\}', with `{' and `}' by themselvesordinary characters.``````Obsolete (""basic"") regular expressions differ in several respects. '|', '+', and '?' are ordinarycharacters and there is no equivalent for their functionality. The delimiters for bounds are"" \{"" and ""\}"", with '{' and '}' by themselves ordinary characters.```",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/6618,114155731,2017-05-01T17:03:24Z,scripts/gen_lib.lua,"@@ -0,0 +1,71 @@+lpeg = require('lpeg')","I do not like the idea of placing modules into scripts/, name of the directory implies that it contains scripts. So far such things were only in test/ and src/nvim/, but first is for tests and second only contains various lists (like list of commands) ATM, so if you think that e.g. src/nvim/api/ is not fine feel free to create some new directory.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/6618,114161254,2017-05-01T17:34:50Z,scripts/gen_lib.lua,"@@ -0,0 +1,71 @@+lpeg = require('lpeg')","Well it is a library used by `scripts/` and unlike `dispatch_deprecated.lua` (which actually defines stuff exposed in the nvim binary, and thus belong in `src/`) it is not really api source. As you mention `test/` contains not only tests but also libraries for tests, is this not analogous?",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/6618,114164287,2017-05-01T17:50:52Z,scripts/gen_lib.lua,"@@ -0,0 +1,71 @@+lpeg = require('lpeg')","@bfredl test/ contains libraries for tests and tests, but both can���t be run on their own (tests are only runnable by busted which is a whole bunch of other lua stuff). Also libraries for tests are named ���smth.lua���, tests are named ���smth_spec.lua���: easily distinguishable. And all are lua, non-lua things have separate directories.Neither distinguishable naming nor grouping by ���scripts are lua and library for scripts is lua��� applies here. Last, but not least: I would not expect directory named scripts/ contain any non-scripts, just like bin/ containing something which is not runnable from the command-line, not even any directory with some stuff; `ls -lA {,/usr{,/local}}/bin/*(ND-^*)` shows that Gentoo maintainers agree with me here: found only .keep and a bunch of broken symlinks.",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/6618,114165338,2017-05-01T17:56:30Z,scripts/gen_lib.lua,"@@ -0,0 +1,71 @@+lpeg = require('lpeg')","No scripts/. And definitely no scripts/helpers, scripts/ contains too much stuff for this name to be useful: this is helpers to what? Generating C functions��� declarations? Generating Ex commands lists, eval functions or options? Generating Vim syntax files?Or maybe even running PVS checks as `helpers.lua` may just as well be a helpers script used like `lua scripts/helpers.lua --do-some-stuff`?",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/6618,114168474,2017-05-01T18:12:33Z,scripts/gen_lib.lua,"@@ -0,0 +1,71 @@+lpeg = require('lpeg')","This is code only run by generators in `scripts/`, it should be at the same place as generators. Maybe it would make sense to separate generators? it seems a very consistent and well-defined pattern, unlike some of the random stuff in `scripts`. So `scripts/generators/helpers.lua` ? Or just `generators/helpers.lua` ?",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/6618,114174022,2017-05-01T18:39:39Z,scripts/gen_lib.lua,"@@ -0,0 +1,71 @@+lpeg = require('lpeg')",">  It still does not tell whether helpers.lua is of ���lua helpers.lua --do-something��� type or a lua module.I think it is obvious enough, you wouldn't invoke a file called `helpers` from outside the directory. But if conformity with tests are irrelevant,  we can`generators/gen_xx.lua` and `generators/lib.lua`. (though  `generators/lib/xx.lua` is better if already expect multiple library files). But I see little point to `generators/bin`, generators should just be in `generators/`.",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/6618,114175745,2017-05-01T18:48:30Z,scripts/gen_lib.lua,"@@ -0,0 +1,71 @@+lpeg = require('lpeg')","lib/ and bin/ or scripts/ indicate a type of usage: generators/��� is unknown, generators/lib/��� are obviously `require()`d and generators/bin/��� are obviously used directly from the command-line and not some other way around (better also add shebangs to generators which are missing that).(Tests may also follow something like this, I remember myself accidentally running helpers.lua by busted as a test a few times before I wrote run_���_test helper shell functions.)",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/6618,114176150,2017-05-01T18:50:18Z,scripts/gen_lib.lua,"@@ -0,0 +1,71 @@+lpeg = require('lpeg')","The point of `src/nvim/generators/` would the that these would be invoked by `src/nvim/CMakeLists.txt`, take files in `src/nvim/` as input,  and they also could all take `{root}/src/nvim` as first argument as library path. But I'm not really sure.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/6618,114176921,2017-05-01T18:54:32Z,scripts/gen_lib.lua,"@@ -0,0 +1,71 @@+lpeg = require('lpeg')","But generators are not run directly by the user command-line. They are run by CMakeLists as part of a luajit command. Rather than second-guessing argument lists, providing `make gen_xx` would be a better manual invoke point. If there is `generators/gen_xx.lua` and `generators/lib/xx.lua`, an extra `bin/` will only be a many a wasted tab completion for no gain.",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/6618,114188762,2017-05-01T19:56:48Z,scripts/gen_lib.lua,"@@ -0,0 +1,71 @@+lpeg = require('lpeg')","> Maybe that's better, but wouldn't paths.lua then be need to be found by some mechanism? At which point the mechanism can be used to find the paths directly...This is more about how many data would be fine to pass through that mechanism. E.g. better make user specify one path to build/ then both path to build/ and pass to source.> I guess I'm too used to languages where including code from the same directory as the code is a thing you just do...Do not remember using such languages in Neovim, or them being common in my experience:- Python is directed  by `sys.path` for which you need things like `pip install --editable .` (or $PYTHONPATH). There is `from .foo import smth`, but this is only going to work in imported modules which requires them being in `sys.path`.- Shell requires hacks with $0, $_ or $BASH_SOURCE.- lua needs to adjust package.path and package.cpath via e.g. $LUA_INIT (and it is really the worst: most verbose, needs escaping, inconsistent with others which have $\*PATH).- C needs supplying -I or -isystem argument to compiler. Did not really do modules with Perl, but AFAIK it has `.` in `@INC`, but not something to run from the *codes* directory and not current. `@INC` may be adjusted with `-I` argument.- CMake includes only from CMAKE_MODULE_PATH, though it is the closest: you may alternatively use `include(cmake/Foo.cmake)` and it would be relative to where CMakeLists.txt is located (including when you use include() from cmake/Foo.cmake, so it is not ���including code from the same directory as the code is���).",
4079454,AdnoC,https://api.github.com/repos/neovim/neovim/pulls/6638,114240255,2017-05-02T02:49:02Z,scripts/genappimage.sh,"@@ -0,0 +1,143 @@+#!/bin/bash++########################################################################+# Package the baries built on Travis-CI as an AppImage+# By Simon Peter 2016+# For more information, see http://appimage.org/+########################################################################++if [ -z ""$ARCH"" ]; then+  export ARCH=""$(arch)""+fi++APP=NVim+LOWERAPP=""${APP,,}""+ROOT_DIR=""$(git rev-parse --show-toplevel)""+APP_BUILD_DIR=""$ROOT_DIR/build""+APP_DIR=""$APP_BUILD_DIR/$APP.AppDir""++# cd neovim+GIT_REV=""$(git rev-parse --short HEAD)""++# Since neovim increments versions slower than vim, using+# the commit's date makes more sense.+VIM_VER=""$(date -d ""@$(git log -1 --format=%ct)"" ""+%F"")""+++make install DESTDIR=""$APP_DIR""++# Move runtime from /usr/local to /usr+mv ""$APP_DIR""/usr/local/* ""$APP_DIR/usr/""++cd ""$APP_BUILD_DIR""++wget -q https://github.com/probonopd/AppImages/raw/master/functions.sh -O ./appimage_functions.sh+. ./appimage_functions.sh++cd ""$APP"".AppDir++# # Also needs grep for gvim.wrapper+# cp /bin/grep ./usr/bin+#+# # install additional dependencies for python+# # this makes the image too big, so skip it+# # and depend on the host where the image is run to fulfill those dependencies+#+# #URL=$(apt-get install -qq --yes --no-download --reinstall --print-uris libpython2.7 libpython3.2 libperl5.14 liblua5.1-0 libruby1.9.1| cut -d' ' -f1 | tr -d ""'"")+# #wget -c $URL+# #for package in *.deb; do+# #    dpkg -x $package .+# #done+# #rm -f *.deb+++########################################################################+# Copy desktop and icon file to AppDir for AppRun to pick them up+########################################################################++# Download AppRun and make it executable+#get_apprun++# get_desktop+find ""${ROOT_DIR}"" -name ""${LOWERAPP}.desktop"" -xdev -exec cp {} ""${LOWERAPP}.desktop"" \;++find ""${ROOT_DIR}"" -name ""nvim.png"" -xdev -exec cp {} ""${LOWERAPP}.png"" \;++# mkdir -p ./usr/lib/x86_64-linux-gnu+# copy custom libruby.so 1.9+# find ""$HOME/.rvm/"" -name ""libruby.so.1.9"" -xdev -exec cp {} ./usr/lib/x86_64-linux-gnu/ \; || true+# add libncurses5+# find /lib -name ""libncurses.so.5"" -xdev -exec cp -v -rfL {} ./usr/lib/x86_64-linux-gnu/ \; || true++# copy dependencies+copy_deps++# Move the libraries to usr/bin+move_lib++########################################################################+# Delete stuff that should not go into the AppImage+########################################################################++# if those libraries are present, there will be a pango problem+# find . -name ""libpango*"" -delete+# find . -name ""libfreetype*"" -delete+# find . -name ""libX*"" -delete++# Delete dangerous libraries; see+# https://github.com/probonopd/AppImages/blob/master/excludelist+delete_blacklisted++########################################################################+# desktopintegration asks the user on first run to install a menu item+########################################################################++# get_desktopintegration ""$LOWERAPP""++########################################################################+# Determine the version of the app; also include needed glibc version","Ah, I need to change that comment. It used to add glibc to the version string twice - once there and once in the generate_appimage function in https://github.com/probonopd/AppImages/blob/master/functions.sh",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/6618,114251507,2017-05-02T05:42:48Z,scripts/gen_lib.lua,"@@ -0,0 +1,71 @@+lpeg = require('lpeg')","I just meant when debugging, the starting point would be to invoke exactly the same way as the build files does. > And they tend to be overly verbose: after make VERBOSE=1 output Hmm, I litteraly get 6 short lines before entering `build/` (of course more if cmake needed rerun), zero lines after. And grepping for `gendispactch` gives:> [102/260] cd /home/bjorn/dev/neovim/build/src/nvim && /home/bjorn/dev/neovim/.deps/usr/bin/luajit /home/bjorn/dev/neovim/scripts/gendispatch.lua /home/bjorn/dev/neovim/src/nvim /home/bjorn/dev/neovim/src/nvim/api/buffer.h /home/bjorn/dev/neovim/src/nvim/api/tabpage.h /home/bjorn/dev/neovim/src/nvim/api/ui.h /home/bjorn/dev/neovim/src/nvim/api/vim.h /home/bjorn/dev/neovim/src/nvim/api/window.h /home/bjorn/dev/neovim/build/include/api/buffer.h.generated.h /home/bjorn/dev/neovim/build/include/api/tabpage.h.generated.h /home/bjorn/dev/neovim/build/include/api/ui.h.generated.h /home/bjorn/dev/neovim/build/include/api/vim.h.generated.h /home/bjorn/dev/neovim/build/include/api/window.h.generated.h /home/bjorn/dev/neovim/build/src/nvim/auto/api/private/dispatch_wrappers.generated.h /home/bjorn/dev/neovim/build/src/nvim/auto/api/private/funcs_metadata.generated.h /home/bjorn/dev/neovim/build/api_metadata.mpackit seems readable enough, I don't see how it should be more or less verbose. But yeah individual `make gen_xx` would probably be overblow, `make gen` or `make generators` is probably enough. Generators depend on each other anyway, and rerunning just the needed generators will be alot faster than also rerunnning gcc (which could be a lot due to header dependencies). I find it rerunning cmake when needed practical, but again, no one is forced to use top-level short-cuts just because they exist.",
9766,blueyed,https://api.github.com/repos/neovim/neovim/pulls/6644,114362870,2017-05-02T16:31:15Z,src/nvim/event/process.c,"@@ -247,10 +245,13 @@ void process_stop(Process *proc) FUNC_ATTR_NONNULL_ALL   Loop *loop = proc->loop;   if (!loop->children_stop_requests++) {     // When there's at least one stop request pending, start a timer that-    // will periodically check if a signal should be send to a to the job+    // will periodically check if a signal should be send to the job.     DLOG(""Starting job kill timer"");-    uv_timer_start(&loop->children_kill_timer, children_kill_cb, 100, 100);+    uv_timer_start(&loop->children_kill_timer, children_kill_cb, KILL_TIMEOUT, 100);   }++  ILOG(""Sending SIGTERM to pid %d"", proc->pid);+  uv_kill(proc->pid, SIGTERM);","Moved it up a bit, but in general I've thought to keep it similar to before.Not interfering with SIGHUP seems like a valid reason to not do it before that at least.",
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/6644,114533421,2017-05-03T12:40:53Z,src/nvim/event/process.c,"@@ -244,12 +242,15 @@ void process_stop(Process *proc) FUNC_ATTR_NONNULL_ALL       abort();   } +  ILOG(""Sending SIGTERM to pid %d"", proc->pid);+  uv_kill(proc->pid, SIGTERM);+   Loop *loop = proc->loop;   if (!loop->children_stop_requests++) {     // When there's at least one stop request pending, start a timer that-    // will periodically check if a signal should be send to a to the job+    // will periodically check if a signal should be send to the job.     DLOG(""Starting job kill timer"");-    uv_timer_start(&loop->children_kill_timer, children_kill_cb, 100, 100);+    uv_timer_start(&loop->children_kill_timer, children_kill_cb, KILL_TIMEOUT_MS, 100);",Line too long.,
6589866,brcolow,https://api.github.com/repos/neovim/neovim/pulls/6685,114934728,2017-05-05T05:45:11Z,src/nvim/tui/tui.c,"@@ -423,9 +426,16 @@ static void tui_resize(UI *ui, int width, int height)   ugrid_resize(&data->grid, width, height);    if (!got_winch) {  // Try to resize the terminal window.-    char r[16];  // enough for 9999x9999-    snprintf(r, sizeof(r), ""\x1b[8;%d;%dt"", height, width);-    out(ui, r, strlen(r));+    // Only send this control sequence extension to terminal types that we know understand it.",[The linter](https://travis-ci.org/neovim/neovim/jobs/228865508#L2992) complains about line length here and a couple other lines to line 434...if it is possible to shorten anything while retaining the meaning that would be swell - no big deal though.,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/6597,114961117,2017-05-05T09:35:19Z,src/nvim/option.c,"@@ -3579,6 +3586,36 @@ static char_u *compile_cap_prog(synblock_T *synblock)   return NULL; } +/// Handle setting `winhighlight' in window ""wp""+static bool parse_winhl(win_T *wp)",`parse_winhl_opt` (parallel to `parse_shape_opt`),
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/6597,115253547,2017-05-08T13:58:03Z,src/nvim/buffer_defs.h,"@@ -930,6 +932,10 @@ struct window_S {    synblock_T  *w_s;                 /* for :ownsyntax */ +  int w_hl_id;                      ///< 'winhighlight' id+  int w_hl_id_inactive;             ///< 'winhighlight' id for inactive window","To support all builtin hl groups in the future, I suppose this will be some sort of list?",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/6597,115260249,2017-05-08T14:25:33Z,test/functional/ui/highlight_spec.lua,"@@ -650,3 +650,296 @@ describe(""'listchars' highlight"", function()     ]])   end) end)++describe(""'winhighlight' highlight"", function()+  local screen++  before_each(function()+    clear()+    screen = Screen.new(20,8)+    screen:attach()+    screen:set_default_attr_ids({+      [0] = {bold=true, foreground=Screen.colors.Blue},+      [1] = {background = Screen.colors.DarkBlue},+      [2] = {background = Screen.colors.DarkBlue, bold = true, foreground = Screen.colors.Blue1},+      [3] = {bold = true, reverse = true},+      [4] = {reverse = true},+      [5] = {background = Screen.colors.DarkGreen},+      [6] = {background = Screen.colors.DarkGreen, bold = true, foreground = Screen.colors.Blue1},+      [7] = {background = Screen.colors.DarkMagenta},+      [8] = {background = Screen.colors.DarkMagenta, bold = true, foreground = Screen.colors.Blue1},+      [9] = {foreground = Screen.colors.Brown},+      [10] = {foreground = Screen.colors.Brown, background = Screen.colors.DarkBlue},+    })+    command(""hi Background1 guibg=DarkBlue"")+    command(""hi Background2 guibg=DarkGreen"")+  end)++  it('works', function()+    insert(""aa"")+    command(""split"")+    command(""set winhl=Normal:Background1"")+    screen:expect([[+      {1:a^a                  }|+      {2:~                   }|+      {2:~                   }|+      {3:[No Name] [+]       }|+      aa                  |+      {0:~                   }|+      {4:[No Name] [+]       }|+                          |+    ]])++    command(""enew"")+    screen:expect([[+      {1:^                    }|+      {2:~                   }|+      {2:~                   }|+      {3:[No Name]           }|+      aa                  |+      {0:~                   }|+      {4:[No Name] [+]       }|+                          |+    ]])+  end)++  it('handles invalid values', function()+    command(""set winhl=Normal:Background1"")+    screen:expect([[+      {1:^                    }|+      {2:~                   }|+      {2:~                   }|+      {2:~                   }|+      {2:~                   }|+      {2:~                   }|+      {2:~                   }|+                          |+    ]])++    eq('Vim(set):E474: Invalid argument: winhl=xxx:yyy',+       exc_exec(""set winhl=xxx:yyy""))+    eq('Normal:Background1', eval('&winhl'))+    screen:expect([[+      {1:^                    }|+      {2:~                   }|+      {2:~                   }|+      {2:~                   }|+      {2:~                   }|+      {2:~                   }|+      {2:~                   }|+                          |+    ]])+  end)+++  it('works local to the buffer', function()","That was decided by bram long ago. ""window option"" means global=per window, local=per buffer.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/6597,115264280,2017-05-08T14:41:31Z,src/nvim/buffer_defs.h,"@@ -930,6 +932,10 @@ struct window_S {    synblock_T  *w_s;                 /* for :ownsyntax */ +  int w_hl_id;                      ///< 'winhighlight' id+  int w_hl_id_inactive;             ///< 'winhighlight' id for inactive window","Actually, if we do `'highlight'` reform, this should just mimic the global `hl_attr()` list. Then we can have `hl_attr_w(wp, HLF_XX)`, support a lot of stuff by doing `:%s/hl_attr(/hl_attr_w(wp,/gc` in screen.c and as a bonus remove a lot of the _ad-hoc_ logic this PR currently needed to deal with vim's _ad-hoc_ logic.",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/6680,115484879,2017-05-09T13:15:19Z,src/nvim/event/socket.c,"@@ -90,14 +71,38 @@ int socket_watcher_start(SocketWatcher *watcher, int backlog, socket_cb cb)   int result;    if (watcher->stream->type == UV_TCP) {-    result = uv_tcp_bind(&watcher->uv.tcp.handle,-                         (const struct sockaddr *)&watcher->uv.tcp.addr, 0);+    struct addrinfo *ai = watcher->uv.tcp.addrinfo;","@mhinz This should be UV_EINVAL without `-`, not `-EINVAL`. According to C99 only EDOM, EILSEQ and ERANGE must be defined, no EINVAL in this list.",
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/6680,115493308,2017-05-09T13:47:46Z,src/nvim/event/socket.c,"@@ -21,58 +21,34 @@ # include ""event/socket.c.generated.h"" #endif -#define NVIM_DEFAULT_TCP_PORT 7450--void socket_watcher_init(Loop *loop, SocketWatcher *watcher,-    const char *endpoint, void *data)+void socket_watcher_init(Loop *loop, SocketWatcher *watcher, const char *endpoint,+                         void *data)",Are we missing a `watcher->data = data`?,
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/6680,115497040,2017-05-09T14:01:55Z,src/nvim/event/socket.c,"@@ -21,58 +21,34 @@ # include ""event/socket.c.generated.h"" #endif -#define NVIM_DEFAULT_TCP_PORT 7450--void socket_watcher_init(Loop *loop, SocketWatcher *watcher,-    const char *endpoint, void *data)+void socket_watcher_init(Loop *loop, SocketWatcher *watcher, const char *endpoint,+                         void *data)   FUNC_ATTR_NONNULL_ARG(1) FUNC_ATTR_NONNULL_ARG(2) FUNC_ATTR_NONNULL_ARG(3) {-  // Trim to `ADDRESS_MAX_SIZE`-  if (xstrlcpy(watcher->addr, endpoint, sizeof(watcher->addr))-      >= sizeof(watcher->addr)) {-    // TODO(aktau): since this is not what the user wanted, perhaps we-    // should return an error here-    WLOG(""Address was too long, truncated to %s"", watcher->addr);-  }--  bool tcp = true;-  char ip[16], *ip_end = xstrchrnul(watcher->addr, ':');--  // (ip_end - addr) is always > 0, so convert to size_t-  size_t addr_len = (size_t)(ip_end - watcher->addr);--  if (addr_len > sizeof(ip) - 1) {-    // Maximum length of an IPv4 address buffer is 15 (eg: 255.255.255.255)-    addr_len = sizeof(ip) - 1;-  }--  // Extract the address part-  xstrlcpy(ip, watcher->addr, addr_len + 1);-  int port = NVIM_DEFAULT_TCP_PORT;--  if (*ip_end == ':') {-    // Extract the port-    long lport = strtol(ip_end + 1, NULL, 10); // NOLINT-    if (lport <= 0 || lport > 0xffff) {-      // Invalid port, treat as named pipe or unix socket-      tcp = false;-    } else {-      port = (int) lport;-    }-  }--  if (tcp) {-    // Try to parse ip address-    if (uv_ip4_addr(ip, port, &watcher->uv.tcp.addr)) {-      // Invalid address, treat as named pipe or unix socket-      tcp = false;+  char *addr = xstrdup(endpoint);","We could copy endpoint directly into `watcher->addr` and work with that string:```diffdiff --git a/src/nvim/event/socket.c b/src/nvim/event/socket.cindex 48d4c3716..c254b8077 100644--- a/src/nvim/event/socket.c+++ b/src/nvim/event/socket.c@@ -25,12 +25,12 @@ void socket_watcher_init(Loop *loop, SocketWatcher *watcher, const char *endpoin                          void *data)   FUNC_ATTR_NONNULL_ARG(1) FUNC_ATTR_NONNULL_ARG(2) FUNC_ATTR_NONNULL_ARG(3) {-  char *addr = xstrdup(endpoint);+  xstrlcpy(watcher->addr, endpoint, sizeof(watcher->addr));+  char *addr = watcher->addr;   char *host_end = strrchr(addr, ':');    if (host_end && addr != host_end) {     *host_end = '\0';-    xstrlcpy(watcher->addr, addr, sizeof(watcher->addr));      uv_getaddrinfo_t request;     int retval = uv_getaddrinfo(&loop->uv, &request, NULL, addr, host_end+1,@@ -40,6 +40,7 @@ void socket_watcher_init(Loop *loop, SocketWatcher *watcher, const char *endpoin                                 });     if (retval != 0) {       // Failed to look up address.+      *host_end = ':';       goto do_pipe;     }     watcher->uv.tcp.addrinfo = request.addrinfo;@@ -48,7 +49,6 @@ void socket_watcher_init(Loop *loop, SocketWatcher *watcher, const char *endpoin     watcher->stream = (uv_stream_t *)&watcher->uv.tcp.handle;   } else { do_pipe:-    xstrlcpy(watcher->addr, endpoint, sizeof(watcher->addr));     uv_pipe_init(&loop->uv, &watcher->uv.pipe.handle, 0);     watcher->stream = (uv_stream_t *)&watcher->uv.pipe.handle;   }@@ -57,8 +57,6 @@ do_pipe:   watcher->cb = NULL;   watcher->close_cb = NULL;   watcher->events = NULL;--  xfree(addr); }  int socket_watcher_start(SocketWatcher *watcher, int backlog, socket_cb cb)```",
972014,mhinz,https://api.github.com/repos/neovim/neovim/pulls/6680,115497881,2017-05-09T14:05:15Z,src/nvim/event/socket.c,"@@ -21,58 +21,34 @@ # include ""event/socket.c.generated.h"" #endif -#define NVIM_DEFAULT_TCP_PORT 7450--void socket_watcher_init(Loop *loop, SocketWatcher *watcher,-    const char *endpoint, void *data)+void socket_watcher_init(Loop *loop, SocketWatcher *watcher, const char *endpoint,+                         void *data)",Can we just remove `data` from the arguments? It's always called with `NULL` and only in `server_start()`. Maybe the original author planned ahead back then.,
886074,teto,https://api.github.com/repos/neovim/neovim/pulls/6460,115500537,2017-05-09T14:15:15Z,src/nvim/strings.c,"@@ -394,72 +394,28 @@ int vim_strnicmp(const char *s1, const char *s2, size_t len) } #endif -/*- * Version of strchr() and strrchr() that handle unsigned char strings- * with characters from 128 to 255 correctly.  It also doesn't return a- * pointer to the NUL at the end of the string.- */-char_u *vim_strchr(const char_u *string, int c)-  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_PURE+/// strchr() version which handles multibyte strings+///+/// @param[in]  string  String to search in.+/// @param[in]  c  Character to search for. Must be a valid character.+///+/// @return Pointer to the first byte of the found character in string or NULL+///         if it was not found. NUL character is never found, use `strlen()`+///         instead.+char_u *vim_strchr(const char_u *const string, const int c)+  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT {-  int b;--  const char_u *p = string;-  if (enc_utf8 && c >= 0x80) {-    while (*p != NUL) {-      int l = (*mb_ptr2len)(p);--      // Avoid matching an illegal byte here.-      if (l > 1 && utf_ptr2char(p) == c) {-        return (char_u *) p;-      }-      p += l;-    }+  assert(c >= 0);","on startup  a similar trace```#0  __GI_raise (sig=sig@entry=6) at ../sysdeps/unix/sysv/linux/raise.c:58#1  0x00007ffff6cfb3ea in __GI_abort () at abort.c:89#2  0x00007ffff6cf1bb7 in __assert_fail_base (fmt=<optimized out>,     assertion=assertion@entry=0x5555558f1d06 ""c >= 0"",     file=file@entry=0x5555558f1cf0 ""../src/nvim/strings.c"", line=line@entry=439,     function=function@entry=0x5555558f2030 <__PRETTY_FUNCTION__.20488> ""vim_strchr"") at assert.c:92#3  0x00007ffff6cf1c62 in __GI___assert_fail (assertion=0x5555558f1d06 ""c >= 0"",     file=0x5555558f1cf0 ""../src/nvim/strings.c"", line=439,     function=0x5555558f2030 <__PRETTY_FUNCTION__.20488> ""vim_strchr"") at assert.c:101#4  0x00005555557d2ae8 in vim_strchr (string=0x5555558e4262 ""\r\n "", c=-24829) at ../src/nvim/strings.c:439#5  0x00005555556f60cf in wait_return (redraw=0) at ../src/nvim/message.c:935#6  0x00005555556f8d45 in msg_end () at ../src/nvim/message.c:2441#7  0x00005555556f48c0 in msg_attr_keep (s=0x555555b95660 <errbuf> ""E121: Undefined variable: a:pat"",     attr=3, keep=0) at ../src/nvim/message.c:194```",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/6618,115671315,2017-05-10T07:29:56Z,src/nvim/generators/dump_bin_array.lua,"@@ -0,0 +1,19 @@+local function dump_bin_array(output, name, data)+  output:write([[+  static const uint8_t ]]..name..[[[] = {+]])++  -- serialize the API metadata using msgpack and embed into the resulting+  -- binary for easy querying by clients",that comment belongs at the relevant section of gen_api_dispatch.lua,
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/6618,115673082,2017-05-10T07:40:55Z,src/nvim/generators/gen_api_dispatch.lua,"@@ -86,8 +42,12 @@ for i = 6, #arg do   end   headers[#headers + 1] = parts[#parts - 1]..'/'..parts[#parts] +  if full_path:sub(-12) ~= '.generated.h' then+    goto continue","sorry, it was a temp workaround no longer needed. I will remove it.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/6618,115692932,2017-05-10T09:22:13Z,src/nvim/api/private/helpers.c,"@@ -820,6 +821,7 @@ Dictionary api_metadata(void)   if (!metadata.size) {     PUT(metadata, ""version"", DICTIONARY_OBJ(version_dict()));     init_function_metadata(&metadata);+    init_ui_event_metadata(&metadata);",mention this at `:h api-metadata` ?,
972014,mhinz,https://api.github.com/repos/neovim/neovim/pulls/6680,115708861,2017-05-10T10:44:57Z,src/nvim/msgpack_rpc/server.c,"@@ -110,8 +110,8 @@ char *server_address_new(void) ///          on failure to bind or connect. int server_start(const char *endpoint) {-  if (endpoint == NULL) {-    ELOG(""Attempting to start server on NULL endpoint"");+  if (endpoint == NULL || endpoint[0] == '\0') {+    ELOG(""The endpoint musn't be NULL or empty."");     return 1;","> 0 on success, 1 on a regular error, and negative errno on failure to bind or listen.I'd argue that it should be treated as regular error, since it's input validation that happens before anything else. It's no ""network error"".",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/6618,115719896,2017-05-10T11:52:44Z,src/nvim/api/ui_events.in.h,"@@ -0,0 +1,70 @@+#ifndef NVIM_API_UI_EVENTS_IN_H+#define NVIM_API_UI_EVENTS_IN_H++// This file is not compiled, just parsed for definitons+#ifdef INCLUDE_GENERATED_DECLARATIONS+#error ""don't include this file, include nvim/ui.h""+#endif++#include ""nvim/api/private/defs.h""+#include ""nvim/func_attr.h""+#include ""nvim/ui.h""+void resize(Integer rows, Integer columns)+    FUNC_API_SINCE(2);+void clear(void)+    FUNC_API_SINCE(2);+void eol_clear(void)+    FUNC_API_SINCE(2);+void cursor_goto(Integer row, Integer col)+    FUNC_API_SINCE(2);","Should not most of these be `FUNC_API_SINCE(1)` ? I would think clients don't care if something is in the metadata, but rather that the thing is merely ""supported"".",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/6618,115720829,2017-05-10T11:58:18Z,src/nvim/api/ui_events.in.h,"@@ -0,0 +1,70 @@+#ifndef NVIM_API_UI_EVENTS_IN_H+#define NVIM_API_UI_EVENTS_IN_H++// This file is not compiled, just parsed for definitons+#ifdef INCLUDE_GENERATED_DECLARATIONS+#error ""don't include this file, include nvim/ui.h""+#endif++#include ""nvim/api/private/defs.h""+#include ""nvim/func_attr.h""+#include ""nvim/ui.h""+void resize(Integer rows, Integer columns)+    FUNC_API_SINCE(2);+void clear(void)+    FUNC_API_SINCE(2);+void eol_clear(void)+    FUNC_API_SINCE(2);+void cursor_goto(Integer row, Integer col)+    FUNC_API_SINCE(2);",I don't think it meaningful to track versions earlier than the versioning mechanism itself. So actually it should be 3 as that will be the first version with events in the frozen metadata,
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/6162,115914474,2017-05-11T06:44:31Z,src/nvim/ex_getln.c,"@@ -2325,7 +2310,7 @@ void putcmdline(int c, int shift)       draw_cmdline(ccline.cmdpos, ccline.cmdlen - ccline.cmdpos);     msg_no_more = FALSE;   } else {-    ui_ext_cmdline_char(c, shift);+    ui_call_cmdline_char(cstr_to_string((char *)(&c)), shift);","`cchar_to_string((char)c)` would be better, maybe (add to `api/private/helpers.c`)```/// Allocates a String consisting of a single char. Does not support multibyte/// characters. The resulting string is also NUL-terminated, to facilitate/// interoperating with code using C strings.////// @param char the char to convert/// @return the resulting String, if the input char was NUL, an///         empty String is returnedString cchar_to_string(char c){    char buf[] = { c, NUL };    return (String) {        .data = xmemdupz(buf, 1),        .size = (c != NUL) ? 1 : 0    };}```",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/6704,115924351,2017-05-11T07:49:20Z,test/functional/api/vim_spec.lua,"@@ -81,6 +81,26 @@ describe('api', function()     end)   end) +  describe('nvim_execute_lua', function()","I don't know, it depends on interactions that I didn't evaluate. Also, adding test coverage exercises future accidental interactions.> Also this is to some extent intended as an alternative to call_atomic in cases it is too primitive.My intention is to recommend Lua for any server-side coordination logic, who knows what kind of things will be batched in call_atomic.",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/6721,115971129,2017-05-11T12:00:50Z,runtime/autoload/health/provider.vim,"@@ -38,6 +38,16 @@ function! s:system_handler(jobid, data, event) dict abort   endif endfunction +"" Attempts to construct a shell command from an args list.+"" Only for display, to help users debug a failed command.+function! s:shellify(cmd) abort+  if type(a:cmd) != type([])+    return a:cmd+  endif+  return join(map(a:cmd,+    \'v:key == 0 || v:val !~# ''[^\-.a-zA-Z_/]'' ? v:val : shellescape(v:val)'), ' ')","Checking for `v:key == 0` does not seem right, it is valid to have paths with e.g. spaces. Especially on cygwin. Second condition with double negation is hard to parse. I would simply write `v:val =~# ''\m[\-.a-zA-Z_/]'' ? shellescape(v:val) : v:val`. (`\m` is a convention raising from ���I do not want to remember where &magic applies and where it does not���.)",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/6680,115989482,2017-05-11T13:28:50Z,src/nvim/event/socket.c,"@@ -16,63 +16,47 @@ #include ""nvim/strings.h"" #include ""nvim/path.h"" #include ""nvim/memory.h""+#include ""nvim/charset.h""  #ifdef INCLUDE_GENERATED_DECLARATIONS # include ""event/socket.c.generated.h"" #endif -#define NVIM_DEFAULT_TCP_PORT 7450- void socket_watcher_init(Loop *loop, SocketWatcher *watcher,-    const char *endpoint, void *data)-  FUNC_ATTR_NONNULL_ARG(1) FUNC_ATTR_NONNULL_ARG(2) FUNC_ATTR_NONNULL_ARG(3)+                         const char *endpoint)+  FUNC_ATTR_NONNULL_ALL {-  // Trim to `ADDRESS_MAX_SIZE`-  if (xstrlcpy(watcher->addr, endpoint, sizeof(watcher->addr))-      >= sizeof(watcher->addr)) {-    // TODO(aktau): since this is not what the user wanted, perhaps we-    // should return an error here-    WLOG(""Address was too long, truncated to %s"", watcher->addr);-  }--  bool tcp = true;-  char ip[16], *ip_end = xstrchrnul(watcher->addr, ':');--  // (ip_end - addr) is always > 0, so convert to size_t-  size_t addr_len = (size_t)(ip_end - watcher->addr);--  if (addr_len > sizeof(ip) - 1) {-    // Maximum length of an IPv4 address buffer is 15 (eg: 255.255.255.255)-    addr_len = sizeof(ip) - 1;-  }--  // Extract the address part-  xstrlcpy(ip, watcher->addr, addr_len + 1);-  int port = NVIM_DEFAULT_TCP_PORT;--  if (*ip_end == ':') {-    // Extract the port-    long lport = strtol(ip_end + 1, NULL, 10); // NOLINT-    if (lport <= 0 || lport > 0xffff) {-      // Invalid port, treat as named pipe or unix socket-      tcp = false;-    } else {-      port = (int) lport;+  xstrlcpy(watcher->addr, endpoint, sizeof(watcher->addr));+  char *addr = watcher->addr;+  char *host_end = strrchr(addr, ':');++  if (host_end && addr != host_end) {+    intmax_t port;+    int ret = getdigits_safe(&(char_u *){ (char_u *)host_end + 1 }, &port);+    if (ret == FAIL || port < 0 || port > UINT16_MAX) {+      // Invalid port.+      goto do_pipe;     }-  } -  if (tcp) {-    // Try to parse ip address-    if (uv_ip4_addr(ip, port, &watcher->uv.tcp.addr)) {-      // Invalid address, treat as named pipe or unix socket-      tcp = false;+    *host_end = '\0';+    uv_getaddrinfo_t request;++    int retval = uv_getaddrinfo(&loop->uv, &request, NULL, addr, host_end+1,","There are some exceptions to allow making some things more readable. Do not remember which exactly, AFAIR I did not touch this part much.",
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/6680,116076429,2017-05-11T19:04:18Z,src/nvim/eval.c,"@@ -14266,7 +14266,8 @@ static void f_serverstart(typval_T *argvars, typval_T *rettv, FunPtr fptr)    int result = server_start((char *) rettv->vval.v_string);   if (result != 0) {-    EMSG2(""Failed to start server: %s"", uv_strerror(result));+    EMSG2(""Failed to start server: %s"",+          result > 0 ? ""Unknonwn system error"" : uv_strerror(result));","Hm, `result` is here always `1`, so we could use the string ""Unknown system error"" unconditionally.For a more specific error message we only have `errno`, but this variable is not always set on error in `server_start()`.",
972014,mhinz,https://api.github.com/repos/neovim/neovim/pulls/6680,116116141,2017-05-11T22:22:17Z,src/nvim/eval.c,"@@ -14266,7 +14266,8 @@ static void f_serverstart(typval_T *argvars, typval_T *rettv, FunPtr fptr)    int result = server_start((char *) rettv->vval.v_string);   if (result != 0) {-    EMSG2(""Failed to start server: %s"", uv_strerror(result));+    EMSG2(""Failed to start server: %s"",+          result > 0 ? ""Unknonwn system error"" : uv_strerror(result));",> `result` is here always `1``:call serverstart('localhost:12345')` twice throws the exception: `Failed to start server: invalid argument` (`UV_EINVAL`) for me.,
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/6704,116148808,2017-05-12T03:53:42Z,src/nvim/api/vim.c,"@@ -254,6 +255,25 @@ Object nvim_call_function(String fname, Array args, Error *err)   return rv; } +/// Execute lua code. Parameters might be passed, they are available inside+/// the chunk as `...`. They chunk can return a value.+///+/// To evaluate an expression, it must be prefixed with ""return "".+/// For instance, to call a lua function with arguments and return value,","""arguments and return value"" should have been a noun phrase, but as was ambiguous (even if both readings _kinda_ make sense, as you see) I will rewrite it ",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/6162,116156295,2017-05-12T05:45:37Z,src/nvim/api/ui_events.in.h,"@@ -68,4 +68,15 @@ void popupmenu_select(Integer selected) void tabline_update(Tabpage current, Array tabs)     FUNC_API_SINCE(3) FUNC_API_REMOTE_ONLY; +void cmdline_enter(void)+    FUNC_API_SINCE(3) FUNC_API_REMOTE_ONLY;+void cmdline_show(Array content, Integer pos, String firstc, String prompt, Integer level)+    FUNC_API_SINCE(3) FUNC_API_REMOTE_ONLY;+void cmdline_pos(Integer pos, Integer level)+    FUNC_API_SINCE(3) FUNC_API_REMOTE_ONLY;+void cmdline_char(String c, Integer shift)","@justinmk What was the point of this suggestion? UI events are already prefectly extensible by adding new events, and new fields to extisting events. The only effect this has is that ext ui contributors would have to write a lot of dict packing code that the metadata mechanism could have autogenerated for them... The point of #6618 was exactly to _move away_ from `ADD(""x"", ...); ADD(""y"", ...); ui_event()` style code,  so I wonder why we want to cancel the effect of that PR by recreating `ui_event()` as an inner platform...Also, from the ui implementers view, the metadata `cmdline_pos(Integer pos, Integer level)` is more or less self-documenting, while `cmdline_update(Dictionary)` is positively useless.",
886074,teto,https://api.github.com/repos/neovim/neovim/pulls/6272,116280569,2017-05-12T17:16:27Z,test/functional/options/defaults_spec.lua,"@@ -328,3 +329,64 @@ describe('XDG-based defaults', function()     end)   end) end)+++describe('stdpath()', function()+  before_each(function()+    clear({env={+      XDG_CONFIG_HOME='cat',",shouldn't we test with more realistic values ? like /home/helmut/.config,
40799,docwhat,https://api.github.com/repos/neovim/neovim/pulls/6272,116281186,2017-05-12T17:19:24Z,test/functional/options/defaults_spec.lua,"@@ -328,3 +329,64 @@ describe('XDG-based defaults', function()     end)   end) end)+++describe('stdpath()', function()+  before_each(function()+    clear({env={+      XDG_CONFIG_HOME='cat',",The code is basically string manipulation; it doesn't know anything about separators.  And I don't want to write tests that test `get_xdg_home()` and friends; those tests belong someplace else.,
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/6272,116281367,2017-05-12T17:20:27Z,test/functional/options/defaults_spec.lua,"@@ -328,3 +329,64 @@ describe('XDG-based defaults', function()     end)   end) end)+++describe('stdpath()', function()+  before_each(function()+    clear({env={+      XDG_CONFIG_HOME='cat',","Not actually, edge cases are more likely to contain bugs. Though better test *both* realistic and not, I would also suggest using `$XDG_DATA_HOME` and like here (i.e. check that environment variables are not expanded) and `~/foo` (i.e. check that `~/` is not expanded).",
40799,docwhat,https://api.github.com/repos/neovim/neovim/pulls/6272,116281962,2017-05-12T17:23:26Z,test/functional/options/defaults_spec.lua,"@@ -328,3 +329,64 @@ describe('XDG-based defaults', function()     end)   end) end)+++describe('stdpath()', function()+  before_each(function()+    clear({env={+      XDG_CONFIG_HOME='cat',+      XDG_CONFIG_DIRS='siamese:persian',+      XDG_DATA_HOME='dog',+      XDG_DATA_DIRS='chihuahua:terrier',+      XDG_CACHE_HOME='capybara',+    }})+  end)++  it('knows the config home', function()+    eq('cat/nvim', eval('stdpath(""config"")'))+  end)++  it('knows the data home', function()+    if os_name() == 'windows' then+      eq('dog\\nvim-data', eval('stdpath(""data"")'))+    else+      eq('dog/nvim', eval('stdpath(""data"")'))+    end+  end)++  it('knows the cache home', function()+    if os_name() == 'windows' then+      eq('capybara\\nvim', eval('stdpath(""cache"")'))+    else+      eq('capybara/nvim', eval('stdpath(""cache"")'))+    end+  end)++  it('knows the config dirs', function()+    local gotten = eval('stdpath(""config_dirs"")')+    if os_name() == 'windows' then+      eq('siamese\\nvim', gotten[1])+      eq('persian\\nvim', gotten[2])+    else+      eq('siamese/nvim', gotten[1])+      eq('persian/nvim', gotten[2])+    end+    eq(2, #gotten)+  end)++  it('knows the data dirs', function()+    local gotten = eval('stdpath(""data_dirs"")')+    if os_name() == 'windows' then+      eq('chihuahua\\nvim', gotten[1])+      eq('terrier\\nvim', gotten[2])+    else+      eq('chihuahua/nvim', gotten[1])+      eq('terrier/nvim', gotten[2])+    end+    eq(2, #gotten)+  end)++  it('accepts unknown strings', function()+    eq('', eval('stdpath(""cavey"")'))+  end)",But that isn't a function of `stdpath()`; [`stdpaths_get_xdg_var()`](https://github.com/neovim/neovim/blob/15af803cce0221588011879723ccfc2ade51ea98/src/nvim/os/stdpaths.c#L54-L81) takes care of that for `stdpath()`.I don't see any tests for `stdpaths_get_xdg_var()` but I may be missing them.,
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/6272,116282120,2017-05-12T17:24:18Z,test/functional/options/defaults_spec.lua,"@@ -328,3 +329,64 @@ describe('XDG-based defaults', function()     end)   end) end)+++describe('stdpath()', function()+  before_each(function()+    clear({env={+      XDG_CONFIG_HOME='cat',+      XDG_CONFIG_DIRS='siamese:persian',+      XDG_DATA_HOME='dog',+      XDG_DATA_DIRS='chihuahua:terrier',+      XDG_CACHE_HOME='capybara',+    }})+  end)++  it('knows the config home', function()+    eq('cat/nvim', eval('stdpath(""config"")'))+  end)++  it('knows the data home', function()+    if os_name() == 'windows' then+      eq('dog\\nvim-data', eval('stdpath(""data"")'))","I would suggest one line in all cases: `eq(alter_slashes('capybara/nvim'), funcs.stdpath('cache'))` and `eq(os_path('dog/nvim', 'dog\\nvim-data'), funcs.stdpath('data'))`: `os_name()` checks may be hidden in two new pretty trivial functions��`alter_slashes` and `os_path`. (`funcs` is `helpers.funcs` and it is better then `eval` for this purpose.)",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/6272,116283584,2017-05-12T17:31:18Z,test/functional/options/defaults_spec.lua,"@@ -328,3 +329,64 @@ describe('XDG-based defaults', function()     end)   end) end)+++describe('stdpath()', function()+  before_each(function()+    clear({env={+      XDG_CONFIG_HOME='cat',","@docwhat `stdpaths_get_xdg_var()` may only be tested in a unit tests. This is *functional* test, it tests how all that is functioning together. `stdpaths_get_xdg_var()` may be splitted into multiple functions, replaced with some library function (e.g. if libuv will provide similar functionality), etc with tests gone, `stdpath()` is going to stay, be a part of an API and questioning ���how API works in edge cases��� is completely valid.",
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/6272,116300175,2017-05-12T18:49:33Z,src/nvim/eval.c,"@@ -15534,6 +15534,64 @@ static void f_split(typval_T *argvars, typval_T *rettv, FunPtr fptr)   p_cpo = save_cpo; } ++/// ""stdpath(type)"" function+static void f_stdpath(typval_T *argvars, typval_T *rettv, FunPtr fptr)+{+  const char *p = tv_get_string(&argvars[0]);+  const void *iter = NULL;++  if (strcmp(p, ""config"") == 0) {+    rettv->v_type = VAR_STRING;+    rettv->vval.v_string = (char_u *)get_xdg_home(kXDGConfigHome);+  } else if (strcmp(p, ""data"") == 0) {+    rettv->v_type = VAR_STRING;+    rettv->vval.v_string = (char_u *)get_xdg_home(kXDGDataHome);+  } else if (strcmp(p, ""cache"") == 0) {+    rettv->v_type = VAR_STRING;+    rettv->vval.v_string = (char_u *)get_xdg_home(kXDGCacheHome);+  } else if (strcmp(p, ""config_dirs"") == 0) {+    list_T *const list = tv_list_alloc();+    rettv->v_type = VAR_LIST;+    rettv->vval.v_list = list;+    list->lv_refcount++;+    char *const dirs = stdpaths_get_xdg_var(kXDGConfigDirs);+    do {+      size_t dir_len;+      const char *dir;+      iter = vim_colon_env_iter(dirs, iter, &dir, &dir_len);+      if (dir != NULL && dir_len > 0) {+        char *dir_with_nvim = strncpy(xmallocz(dir_len), dir, dir_len);+        dir_with_nvim = concat_fnames_realloc(dir_with_nvim, ""nvim"", true);+        tv_list_append_string(list, dir_with_nvim, strlen(dir_with_nvim));+        xfree(dir_with_nvim);+      }+    } while (iter != NULL);+    xfree(dirs);+  } else if (strcmp(p, ""data_dirs"") == 0) {+    list_T *const list = tv_list_alloc();+    rettv->v_type = VAR_LIST;+    rettv->vval.v_list = list;+    list->lv_refcount++;+    char *const dirs = stdpaths_get_xdg_var(kXDGDataDirs);+    do {+      size_t dir_len;+      const char *dir;+      iter = vim_colon_env_iter(dirs, iter, &dir, &dir_len);+      if (dir != NULL && dir_len > 0) {+        char *dir_with_nvim = strncpy(xmallocz(dir_len), dir, dir_len);+        dir_with_nvim = concat_fnames_realloc(dir_with_nvim, ""nvim"", true);+        tv_list_append_string(list, dir_with_nvim, strlen(dir_with_nvim));+        xfree(dir_with_nvim);+      }+    } while (iter != NULL);+    xfree(dirs);",Code for `config_dirs` and `data_dirs` cases are nearly identical. Could be refactored.,
1270688,sassanh,https://api.github.com/repos/neovim/neovim/pulls/6732,116354988,2017-05-13T09:50:10Z,runtime/doc/options.txt,"@@ -1327,7 +1327,10 @@ A jump table for the options with a short description can be found at |Q_op|. 	Number of screen lines to use for the command-line.  Helps avoiding 	|hit-enter| prompts. 	The value of this option is stored with the tab page, so that each tab-	page can have a different value.+	page can have a different value. Setting it to '0' hides cmdline and is+  appropriate for windows that user is not supposed to use cmdline in.+  If you use cmdline while 'cmdheight' is set to '0' it'll behave+  strangely specially when it interacts with statusline.","It does its work which is ""hiding cmdline for windows in which user is not supposed to use cmdline"" there are many use cases for it. ctrlp has lots of code just to simulate this behavior (which could be done by changing one bit in vim source) my fzf looks much better with cmdline=0 for its window. I understand it may introduce bug reports so the tradeoff is obvious:1. merge this patch and let plugin developers hide cmdline in their plugin's window, and explain the behavior in first bug report and ask people interested in zero height cmdline for their normal vim usage to provide pr and reference other bug reports to that first bug report.2. don't merge this patch to reduce bug reports and the annoyance.",
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/4411,116373891,2017-05-14T06:55:39Z,src/nvim/lua/executor.c,"@@ -0,0 +1,576 @@+#include <lua.h>+#include <lualib.h>+#include <lauxlib.h>++#include ""nvim/misc1.h""+#include ""nvim/getchar.h""+#include ""nvim/garray.h""+#include ""nvim/func_attr.h""+#include ""nvim/api/private/defs.h""+#include ""nvim/api/private/helpers.h""+#include ""nvim/api/vim.h""+#include ""nvim/vim.h""+#include ""nvim/ex_getln.h""+#include ""nvim/message.h""+#include ""nvim/memline.h""+#include ""nvim/buffer_defs.h""+#include ""nvim/macros.h""+#include ""nvim/screen.h""+#include ""nvim/cursor.h""+#include ""nvim/undo.h""+#include ""nvim/ascii.h""++#include ""nvim/lua/executor.h""+#include ""nvim/lua/converter.h""++typedef struct {+  Error err;+  String lua_err_str;+} LuaError;++#ifdef INCLUDE_GENERATED_DECLARATIONS+# include ""lua/vim_module.generated.h""+# include ""lua/executor.c.generated.h""+#endif++/// Name of the run code for use in messages+#define NLUA_EVAL_NAME ""<VimL compiled string>""++/// Call C function which does not expect any arguments+///+/// @param  function  Called function+/// @param  numret    Number of returned arguments+#define NLUA_CALL_C_FUNCTION_0(lstate, function, numret) \+    do { \+      lua_pushcfunction(lstate, &function); \+      lua_call(lstate, 0, numret); \+    } while (0)+/// Call C function which expects one argument+///+/// @param  function  Called function+/// @param  numret    Number of returned arguments+/// @param  a���        Supplied argument (should be a void* pointer)+#define NLUA_CALL_C_FUNCTION_1(lstate, function, numret, a1) \+    do { \+      lua_pushcfunction(lstate, &function); \+      lua_pushlightuserdata(lstate, a1); \+      lua_call(lstate, 1, numret); \+    } while (0)+/// Call C function which expects two arguments+///+/// @param  function  Called function+/// @param  numret    Number of returned arguments+/// @param  a���        Supplied argument (should be a void* pointer)+#define NLUA_CALL_C_FUNCTION_2(lstate, function, numret, a1, a2) \+    do { \+      lua_pushcfunction(lstate, &function); \+      lua_pushlightuserdata(lstate, a1); \+      lua_pushlightuserdata(lstate, a2); \+      lua_call(lstate, 2, numret); \+    } while (0)+/// Call C function which expects three arguments+///+/// @param  function  Called function+/// @param  numret    Number of returned arguments+/// @param  a���        Supplied argument (should be a void* pointer)+#define NLUA_CALL_C_FUNCTION_3(lstate, function, numret, a1, a2, a3) \+    do { \+      lua_pushcfunction(lstate, &function); \+      lua_pushlightuserdata(lstate, a1); \+      lua_pushlightuserdata(lstate, a2); \+      lua_pushlightuserdata(lstate, a3); \+      lua_call(lstate, 3, numret); \+    } while (0)+/// Call C function which expects five arguments+///+/// @param  function  Called function+/// @param  numret    Number of returned arguments+/// @param  a���        Supplied argument (should be a void* pointer)+#define NLUA_CALL_C_FUNCTION_4(lstate, function, numret, a1, a2, a3, a4) \+    do { \+      lua_pushcfunction(lstate, &function); \+      lua_pushlightuserdata(lstate, a1); \+      lua_pushlightuserdata(lstate, a2); \+      lua_pushlightuserdata(lstate, a3); \+      lua_pushlightuserdata(lstate, a4); \+      lua_call(lstate, 4, numret); \+    } while (0)++/// Convert lua error into a Vim error message+///+/// @param  lstate  Lua interpreter state.+/// @param[in]  msg  Message base, must contain one `%s`.+static void nlua_error(lua_State *const lstate, const char *const msg)+  FUNC_ATTR_NONNULL_ALL+{+  size_t len;+  const char *const str = lua_tolstring(lstate, -1, &len);++  emsgf(msg, (int)len, str);++  lua_pop(lstate, 1);+}++/// Compare two strings, ignoring case+///+/// Expects two values on the stack: compared strings. Returns one of the+/// following numbers: 0, -1 or 1.+///+/// Does no error handling: never call it with non-string or with some arguments+/// omitted.+static int nlua_stricmp(lua_State *const lstate) FUNC_ATTR_NONNULL_ALL+{+  const char *s1 = luaL_checklstring(lstate, 1, NULL);+  const char *s2 = luaL_checklstring(lstate, 2, NULL);+  const int ret = STRICMP(s1, s2);+  lua_pop(lstate, 2);+  lua_pushnumber(lstate, (lua_Number)((ret > 0) - (ret < 0)));+  return 1;+}++/// Evaluate lua string+///+/// Expects two values on the stack: string to evaluate, pointer to the+/// location where result is saved. Always returns nothing (from the lua point+/// of view).+static int nlua_exec_lua_string(lua_State *const lstate) FUNC_ATTR_NONNULL_ALL+{+  const String *const str = (const String *)lua_touserdata(lstate, 1);+  typval_T *const ret_tv = (typval_T *)lua_touserdata(lstate, 2);+  lua_pop(lstate, 2);++  if (luaL_loadbuffer(lstate, str->data, str->size, NLUA_EVAL_NAME)) {+    nlua_error(lstate, _(""E5104: Error while creating lua chunk: %.*s""));+    return 0;+  }+  if (lua_pcall(lstate, 0, 1, 0)) {+    nlua_error(lstate, _(""E5105: Error while calling lua chunk: %.*s""));+    return 0;+  }+  if (!nlua_pop_typval(lstate, ret_tv)) {+    return 0;+  }+  return 0;+}++/// Evaluate lua string for each line in range+///+/// Expects two values on the stack: string to evaluate and pointer to integer+/// array with line range. Always returns nothing (from the lua point of view).+static int nlua_exec_luado_string(lua_State *const lstate) FUNC_ATTR_NONNULL_ALL+{+  const String *const str = (const String *)lua_touserdata(lstate, 1);+  const linenr_T *const range = (const linenr_T *)lua_touserdata(lstate, 2);+  lua_pop(lstate, 2);++#define DOSTART ""return function(line, linenr) ""+#define DOEND "" end""+  const size_t lcmd_len = (str->size+                           + (sizeof(DOSTART) - 1)+                           + (sizeof(DOEND) - 1));+  char *lcmd;+  if (lcmd_len < IOSIZE) {+    lcmd = (char *)IObuff;+  } else {+    lcmd = xmalloc(lcmd_len + 1);+  }+  memcpy(lcmd, DOSTART, sizeof(DOSTART) - 1);+  memcpy(lcmd + sizeof(DOSTART) - 1, str->data, str->size);+  memcpy(lcmd + sizeof(DOSTART) - 1 + str->size, DOEND, sizeof(DOEND) - 1);+#undef DOSTART+#undef DOEND++  if (luaL_loadbuffer(lstate, lcmd, lcmd_len, NLUA_EVAL_NAME)) {+    nlua_error(lstate, _(""E5109: Error while creating lua chunk: %.*s""));+    if (lcmd_len >= IOSIZE) {+      xfree(lcmd);+    }+    return 0;+  }+  if (lcmd_len >= IOSIZE) {+    xfree(lcmd);+  }+  if (lua_pcall(lstate, 0, 1, 0)) {+    nlua_error(lstate, _(""E5110: Error while creating lua function: %.*s""));+    return 0;+  }+  for (linenr_T l = range[0]; l <= range[1]; l++) {+    if (l > curbuf->b_ml.ml_line_count) {+      break;+    }+    lua_pushvalue(lstate, -1);+    lua_pushstring(lstate, (const char *)ml_get_buf(curbuf, l, false));+    lua_pushnumber(lstate, (lua_Number)l);+    if (lua_pcall(lstate, 2, 1, 0)) {+      nlua_error(lstate, _(""E5111: Error while calling lua function: %.*s""));+      break;+    }+    if (lua_isstring(lstate, -1)) {+      size_t new_line_len;+      const char *const new_line = lua_tolstring(lstate, -1, &new_line_len);+      char *const new_line_transformed = xmemdupz(new_line, new_line_len);+      for (size_t i = 0; i < new_line_len; i++) {+        if (new_line_transformed[i] == NUL) {+          new_line_transformed[i] = '\n';+        }+      }+      ml_replace(l, (char_u *)new_line_transformed, false);+      changed_bytes(l, 0);+    }+    lua_pop(lstate, 1);+  }+  lua_pop(lstate, 1);+  check_cursor();+  update_screen(NOT_VALID);+  return 0;+}++/// Evaluate lua file+///+/// Expects one value on the stack: file to evaluate. Always returns nothing+/// (from the lua point of view).+static int nlua_exec_lua_file(lua_State *const lstate) FUNC_ATTR_NONNULL_ALL+{+  const char *const filename = (const char *)lua_touserdata(lstate, 1);+  lua_pop(lstate, 1);++  if (luaL_loadfile(lstate, filename)) {+    nlua_error(lstate, _(""E5112: Error while creating lua chunk: %.*s""));+    return 0;+  }+  if (lua_pcall(lstate, 0, 0, 0)) {+    nlua_error(lstate, _(""E5113: Error while calling lua chunk: %.*s""));+    return 0;+  }+  return 0;+}++/// Initialize lua interpreter state+///+/// Called by lua interpreter itself to initialize state.+static int nlua_state_init(lua_State *const lstate) FUNC_ATTR_NONNULL_ALL+{+  // stricmp+  lua_pushcfunction(lstate, &nlua_stricmp);+  lua_setglobal(lstate, ""stricmp"");++  // print+  lua_pushcfunction(lstate, &nlua_print);+  lua_setglobal(lstate, ""print"");++  // debug.debug+  lua_getglobal(lstate, ""debug"");+  lua_pushcfunction(lstate, &nlua_debug);+  lua_setfield(lstate, -2, ""debug"");+  lua_pop(lstate, 1);++  // vim+  if (luaL_dostring(lstate, (char *)&vim_module[0])) {+    nlua_error(lstate, _(""E5106: Error while creating vim module: %.*s""));+    return 1;+  }+  // vim.api+  nlua_add_api_functions(lstate);+  // vim.types, vim.type_idx, vim.val_idx+  nlua_init_types(lstate);+  lua_setglobal(lstate, ""vim"");+  return 0;+}++/// Initialize lua interpreter+///+/// Crashes NeoVim if initialization fails. Should be called once per lua+/// interpreter instance.+static lua_State *init_lua(void)+  FUNC_ATTR_NONNULL_RET FUNC_ATTR_WARN_UNUSED_RESULT+{+  lua_State *lstate = luaL_newstate();+  if (lstate == NULL) {+    EMSG(_(""E970: Failed to initialize lua interpreter""));+    preserve_exit();+  }+  luaL_openlibs(lstate);+  NLUA_CALL_C_FUNCTION_0(lstate, nlua_state_init, 0);+  return lstate;+}++static lua_State *global_lstate = NULL;++/// Execute lua string+///+/// @param[in]  str  String to execute.+/// @param[out]  ret_tv  Location where result will be saved.+///+/// @return Result of the execution.+void executor_exec_lua(const String str, typval_T *const ret_tv)+  FUNC_ATTR_NONNULL_ALL+{+  if (global_lstate == NULL) {+    global_lstate = init_lua();+  }++  NLUA_CALL_C_FUNCTION_2(global_lstate, nlua_exec_lua_string, 0,+                         (void *)&str, ret_tv);+}++/// Evaluate lua string+///+/// Used for luaeval(). Expects three values on the stack:+///+/// 1. String to evaluate.+/// 2. _A value.+/// 3. Pointer to location where result is saved.+///+/// @param[in,out]  lstate  Lua interpreter state.+static int nlua_eval_lua_string(lua_State *const lstate)+  FUNC_ATTR_NONNULL_ALL+{+  const String *const str = (const String *)lua_touserdata(lstate, 1);+  typval_T *const arg = (typval_T *)lua_touserdata(lstate, 2);+  typval_T *const ret_tv = (typval_T *)lua_touserdata(lstate, 3);+  lua_pop(lstate, 3);++  garray_T str_ga;+  ga_init(&str_ga, 1, 80);+#define EVALHEADER ""local _A=select(1,...) return (""+  const size_t lcmd_len = sizeof(EVALHEADER) - 1 + str->size + 1;+  char *lcmd;+  if (lcmd_len < IOSIZE) {+    lcmd = (char *)IObuff;+  } else {+    lcmd = xmalloc(lcmd_len);+  }+  memcpy(lcmd, EVALHEADER, sizeof(EVALHEADER) - 1);+  memcpy(lcmd + sizeof(EVALHEADER) - 1, str->data, str->size);+  lcmd[lcmd_len - 1] = ')';+#undef EVALHEADER+  if (luaL_loadbuffer(lstate, lcmd, lcmd_len, NLUA_EVAL_NAME)) {+    nlua_error(lstate,+               _(""E5107: Error while creating lua chunk for luaeval(): %.*s""));+    if (lcmd != (char *)IObuff) {+      xfree(lcmd);+    }+    return 0;+  }+  if (lcmd != (char *)IObuff) {+    xfree(lcmd);+  }++  if (arg == NULL || arg->v_type == VAR_UNKNOWN) {+    lua_pushnil(lstate);+  } else {+    nlua_push_typval(lstate, arg);+  }+  if (lua_pcall(lstate, 1, 1, 0)) {+    nlua_error(lstate,+               _(""E5108: Error while calling lua chunk for luaeval(): %.*s""));+    return 0;+  }+  if (!nlua_pop_typval(lstate, ret_tv)) {+    return 0;+  }++  return 0;+}++/// Print as a Vim message+///+/// @param  lstate  Lua interpreter state.+static int nlua_print(lua_State *const lstate)+  FUNC_ATTR_NONNULL_ALL+{+#define PRINT_ERROR(msg) \+  do { \+    errmsg = msg; \+    errmsg_len = sizeof(msg) - 1; \+    goto nlua_print_error; \+  } while (0)+  const int nargs = lua_gettop(lstate);+  lua_getglobal(lstate, ""tostring"");+  const char *errmsg = NULL;+  size_t errmsg_len = 0;+  garray_T msg_ga;+  ga_init(&msg_ga, 1, 80);+  int curargidx = 1;+  for (; curargidx <= nargs; curargidx++) {+    lua_pushvalue(lstate, -1);  // tostring+    lua_pushvalue(lstate, curargidx);  // arg+    if (lua_pcall(lstate, 1, 1, 0)) {+      errmsg = lua_tolstring(lstate, -1, &errmsg_len);+      goto nlua_print_error;+    }+    size_t len;+    const char *const s = lua_tolstring(lstate, -1, &len);+    if (s == NULL) {+      PRINT_ERROR(+          ""<Unknown error: lua_tolstring returned NULL for tostring result>"");+    }+    ga_concat_len(&msg_ga, s, len);+    if (curargidx < nargs) {+      ga_append(&msg_ga, ' ');+    }+    lua_pop(lstate, 1);+  }+#undef PRINT_ERROR+  lua_pop(lstate, nargs + 1);+  ga_append(&msg_ga, NUL);+  {+    const size_t len = (size_t)msg_ga.ga_len - 1;+    char *const str = (char *)msg_ga.ga_data;++    for (size_t i = 0; i < len;) {+      const size_t start = i;+      while (i < len) {+        switch (str[i]) {+          case NUL: {+            str[i] = NL;+            i++;+            continue;+          }+          case NL: {+            str[i] = NUL;+            i++;+            break;+          }+          default: {+            i++;+            continue;+          }+        }+        break;+      }+      msg((char_u *)str + start);+    }+    if (str[len - 1] == NUL) {  // Last was newline+      msg((char_u *)"""");+    }+  }+  ga_clear(&msg_ga);+  return 0;+nlua_print_error:+  emsgf(_(""E5114: Error while converting print argument #%i: %.*s""),+        curargidx, errmsg_len, errmsg);","Length argument should be of type int: `errmsg_len` -> `(int)errmsg_len`, otherwise macros `va_*()` parse the parameter list wrong.",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/6741,116395088,2017-05-15T00:23:14Z,src/nvim/path.c,"@@ -2237,3 +2237,40 @@ int path_is_absolute_path(const char_u *fname)   return *fname == '/' || *fname == '~'; #endif }++/// Builds a full path from an invocation name `argv0`, based on heuristics.+///+/// @param[in]  argv0     Name by which Nvim was invoked.+/// @param[out] buf       Guessed full path to `argv0`.+/// @param[in]  bufsize   Size of `buf`.+///+/// @see os_exepath+void path_guess_exepath(char *argv0, char *buf, size_t bufsize)+{+  char *path = getenv(""PATH"");++  if (path == NULL || path_is_absolute_path((char_u *)argv0)) {+    xstrlcpy(buf, argv0, bufsize);+  } else if (argv0[0] == '.' || strchr(argv0, PATHSEP)) {+    if (os_dirname((char_u *)buf, MAXPATHL) != OK) {+      buf[0] = NUL;+    }+    xstrlcat(buf, PATHSEPSTR, bufsize);+    xstrlcat(buf, argv0, bufsize);+  } else {+    char  *pathbuf = xstrdup(path);+    char  *runpath = xmalloc(MAXPATHL);+    path = strtok(pathbuf, ENV_SEPSTR);","BTW, there is `vim_colon_env_iter` which does not require allocating new string. Just need a bit of refactoring to use a parameter in place of hardcoded `:`.",
40799,docwhat,https://api.github.com/repos/neovim/neovim/pulls/6272,116407244,2017-05-15T04:12:10Z,test/functional/options/defaults_spec.lua,"@@ -328,3 +329,64 @@ describe('XDG-based defaults', function()     end)   end) end)+++describe('stdpath()', function()+  before_each(function()+    clear({env={+      XDG_CONFIG_HOME='cat',+      XDG_CONFIG_DIRS='siamese:persian',+      XDG_DATA_HOME='dog',+      XDG_DATA_DIRS='chihuahua:terrier',+      XDG_CACHE_HOME='capybara',+    }})+  end)++  it('knows the config home', function()+    eq('cat/nvim', eval('stdpath(""config"")'))+  end)++  it('knows the data home', function()+    if os_name() == 'windows' then+      eq('dog\\nvim-data', eval('stdpath(""data"")'))","I decided to leave the `os_name() == ""windows""` in place for the case of appending `/nvim-data` (windows) vs. `/nvim` (everyone else) because I felt it was clearer.  I did move it into a `before_each` though to get it out of each test.",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/6741,116445068,2017-05-15T09:20:46Z,src/nvim/path.c,"@@ -2237,3 +2237,44 @@ int path_is_absolute_path(const char_u *fname)   return *fname == '/' || *fname == '~'; #endif }++/// Builds a full path from an invocation name `argv0`, based on heuristics.+///+/// @param[in]  argv0     Name by which Nvim was invoked.+/// @param[out] buf       Guessed full path to `argv0`.+/// @param[in]  bufsize   Size of `buf`.+///+/// @see os_exepath+void path_guess_exepath(char *argv0, char *buf, size_t bufsize)+{+  char *path = getenv(""PATH"");++  if (path == NULL || path_is_absolute_path((char_u *)argv0)) {+    xstrlcpy(buf, argv0, bufsize);+  } else if (argv0[0] == '.' || strchr(argv0, PATHSEP)) {+    if (os_dirname((char_u *)buf, MAXPATHL) != OK) {+      buf[0] = NUL;+    }+    xstrlcat(buf, PATHSEPSTR, bufsize);+    xstrlcat(buf, argv0, bufsize);+  } else {+    const void *iter = NULL;+    do {+      const char *dir;+      size_t dir_len;+      iter = vim_env_iter(ENV_SEPCHAR, path, iter, &dir, &dir_len);+      if (dir == NULL || dir_len == 0 || dir_len + 1 > sizeof(NameBuff)) {","I believe last alternative in the condition should not yield `break`, but `continue`.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/6741,116460508,2017-05-15T10:47:10Z,test/unit/path_spec.lua,"@@ -293,6 +293,60 @@ describe('path_shorten_fname_if_possible', function()   end) end) +describe('path.c path_guess_exepath', function()+  local cwd = lfs.currentdir()++  for _,name in ipairs({'./nvim', '.nvim', 'foo/nvim'}) do+    itp('""'..name..'"" returns name catenated with CWD', function()+      local name = to_cstr(name)",In this case luajit complains:    test/unit/path_spec.lua:303: bad argument #1 to 'path_guess_exepath' (cannot convert 'string' to 'char *')',
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/6741,116469759,2017-05-15T11:46:24Z,test/unit/path_spec.lua,"@@ -293,6 +293,60 @@ describe('path_shorten_fname_if_possible', function()   end) end) +describe('path.c path_guess_exepath', function()+  local cwd = lfs.currentdir()++  for _,name in ipairs({'./nvim', '.nvim', 'foo/nvim'}) do+    itp('""'..name..'"" returns name catenated with CWD', function()+      local name = to_cstr(name)","@justinmk Strange, see e.g. https://github.com/neovim/neovim/blob/17531ed0825c1bf5e24e78ae94020fb08ca06013/test/unit/eval/typval_spec.lua#L1636. Maybe it needs `const` to do automatic conversion?",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/6741,116477446,2017-05-15T12:30:13Z,test/unit/path_spec.lua,"@@ -293,6 +293,59 @@ describe('path_shorten_fname_if_possible', function()   end) end) +describe('path.c path_guess_exepath', function()+  local cwd = lfs.currentdir()++  for _,name in ipairs({'./nvim', '.nvim', 'foo/nvim'}) do+    itp('""'..name..'"" returns name catenated with CWD', function()+      local bufsize = 255+      local buf = cstr(bufsize, '')+      cimp.path_guess_exepath(name, buf, bufsize)+      eq(cwd..'/'..name, ffi.string(buf))+    end)+  end++  itp('absolute path returns the name unmodified', function()+    local name = '/foo/bar/baz'+    local bufsize = 255+    local buf = cstr(bufsize, '')+    cimp.path_guess_exepath(name, buf, bufsize)+    eq(name, ffi.string(buf))+  end)++  itp('returns the name unmodified if not found in $PATH', function()+    local name = '23u0293_not_in_path'+    local bufsize = 255+    local buf = cstr(bufsize, '')+    cimp.path_guess_exepath(name, buf, bufsize)+    eq(name, ffi.string(buf))+  end)++  itp('does not crash if $PATH item exceeds MAXPATHL', function()+    local orig_path_env = os.getenv('PATH')+    local name = 'cat'  -- Some executable in $PATH.+    local bufsize = 255+    local buf = cstr(bufsize, '')+    local insane_path = orig_path_env..':'..((""x/""):rep(4097))++    cimp.os_setenv(to_cstr('PATH'), to_cstr(insane_path), true)+    cimp.path_guess_exepath(name, buf, bufsize)+    eq(""bin/cat"", string.match(ffi.string(buf), ""....cat$""))","Should not it be```luaeq('bin/' .. name, ffi.string(buf):sub(-#('bin/' .. name), -1))```? I mean, without this `name` variable is pretty useless. Same in a test below.",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/6272,116501083,2017-05-15T14:12:26Z,runtime/doc/eval.txt,"@@ -7008,6 +7009,28 @@ sqrt({expr})						*sqrt()* 		""nan"" may be different, it depends on system libraries.  +stdpath({what})					*stdpath()*+		Returns the standard path(s) for {what}.++		These directories are the default locations for various files+		used by Neovim.++		{what} can be one of the following:+			'config'	User configuration directory. The",Like this:```vimhelp{what}     Type    Description ~data       String  User data directory. |shada-file|                   is stored here for example.data_dirs  List    Additional data directories.```,
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/6272,116502822,2017-05-15T14:19:22Z,src/nvim/eval.c,"@@ -15577,6 +15577,53 @@ static void f_split(typval_T *argvars, typval_T *rettv, FunPtr fptr)   p_cpo = save_cpo; } +/// ""stdpath()"" helper for list results+void stdpath_list_helper(const XDGVarType xdg, typval_T *rettv)",`helper` is not descriptive. `get_xdg_var_list` perhaps (can���t really use `stdpath[s]` prefix because this is not in `stdpaths.c`)? For a static function no prefix is fine (it should be static BTW).Also need `FUNC_ATTR_NONNULL_ALL`.,
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/6272,116509652,2017-05-15T14:43:17Z,test/functional/options/defaults_spec.lua,"@@ -328,3 +332,235 @@ describe('XDG-based defaults', function()     end)   end) end)+++describe('stdpath()', function()+  -- Returns an OS friendly version of the unix_path.+  local function alter_path(unix_path)+    if os_name() == 'windows' then+      return string.gsub(unix_path, '/', '\\')+    else+      return unix_path+    end+  end++  describe('""config""' , function ()+    it('knows XDG_CONFIG_HOME', function()+      clear({env={+        XDG_CONFIG_HOME=alter_path('/home/docwhat/.config')+      }})+      eq(alter_path('/home/docwhat/.config/nvim'), funcs.stdpath('config'))+    end)++    it('handles changes during runtime', function()+      clear({env={+        XDG_CONFIG_HOME=alter_path('/home/original')+      }})+      eq(alter_path('/home/original/nvim'), funcs.stdpath('config'))+      nvim('command', 'let $XDG_CONFIG_HOME=""/home/new""')+      eq(alter_path('/home/new/nvim'), funcs.stdpath('config'))+    end)++    it(""doesn't expand $VARIABLES"", function()+      clear({env={+        XDG_CONFIG_HOME='$VARIABLES',+        VARIABLES='this-should-not-happen'+      }})+      eq(alter_path('$VARIABLES/nvim'), funcs.stdpath('config'))+    end)++    it(""doesn't expand ~/"", function()+      clear({env={+        XDG_CONFIG_HOME='~/frobnitz'+      }})+      eq(alter_path('~/frobnitz/nvim'), funcs.stdpath('config'))+    end)+  end)++  describe('""data""' , function ()+    local appended_dir+    before_each(function()+      -- Windows appends 'nvim-data' instead of just 'nvim' to+      -- prevent collisions due to XDG_CONFIG_HOME and XDG_DATA_HOME+      -- being the same.+      if os_name() == 'windows' then+        appended_dir = '/nvim-data'+      else+        appended_dir = '/nvim'+      end+    end)++    it('knows XDG_DATA_HOME', function()+      clear({env={+        XDG_DATA_HOME=alter_path('/home/docwhat/.local')+      }})+      eq(alter_path('/home/docwhat/.local' .. appended_dir), funcs.stdpath('data'))+    end)++    it('handles changes during runtime', function()+      clear({env={+        XDG_DATA_HOME=alter_path('/home/original')+      }})+      eq(alter_path('/home/original' .. appended_dir), funcs.stdpath('data'))+      nvim('command', 'let $XDG_DATA_HOME=""/home/new""')+      eq(alter_path('/home/new' .. appended_dir), funcs.stdpath('data'))+    end)++    it(""doesn't expand $VARIABLES"", function()+      clear({env={+        XDG_DATA_HOME='$VARIABLES',+        VARIABLES='this-should-not-happen'+      }})+      eq(alter_path('$VARIABLES' .. appended_dir), funcs.stdpath('data'))+    end)++    it(""doesn't expand ~/"", function()+      clear({env={+        XDG_DATA_HOME='~/frobnitz'+      }})+      eq(alter_path('~/frobnitz' .. appended_dir), funcs.stdpath('data'))+    end)+  end)++  describe('""cache""' , function ()+    it('knows XDG_CACHE_HOME', function()+      clear({env={+        XDG_CACHE_HOME=alter_path('/home/docwhat/.cache')+      }})+      eq(alter_path('/home/docwhat/.cache/nvim'), funcs.stdpath('cache'))+    end)++    it('handles changes during runtime', function()+      clear({env={+        XDG_CACHE_HOME=alter_path('/home/original')+      }})+      eq(alter_path('/home/original/nvim'), funcs.stdpath('cache'))+      nvim('command', 'let $XDG_CACHE_HOME=""/home/new""')+      eq(alter_path('/home/new/nvim'), funcs.stdpath('cache'))+    end)++    it(""doesn't expand $VARIABLES"", function()+      clear({env={+        XDG_CACHE_HOME='$VARIABLES',+        VARIABLES='this-should-not-happen'+      }})+      eq(alter_path('$VARIABLES/nvim'), funcs.stdpath('cache'))+    end)++    it(""doesn't expand ~/"", function()+      clear({env={+        XDG_CACHE_HOME='~/frobnitz'+      }})+      eq(alter_path('~/frobnitz/nvim'), funcs.stdpath('cache'))+    end)+  end)++  describe('""config_dirs""' , function ()+    it('knows XDG_CONFIG_DIRS', function()+      clear({env={+        XDG_CONFIG_DIRS=alter_path('/home/docwhat/.config:/etc/config')+      }})+      eq({+        alter_path('/home/docwhat/.config/nvim'),+        alter_path('/etc/config/nvim'),+      }, funcs.stdpath('config_dirs'))+    end)++    it('handles changes during runtime', function()+      clear({env={+        XDG_CONFIG_DIRS=alter_path('/home/original:/etc/config')+      }})+      eq({+        alter_path('/home/original/nvim'),+        alter_path('/etc/config/nvim')+      }, funcs.stdpath('config_dirs'))+      nvim('command', 'let $XDG_CONFIG_DIRS=""/home/new:/etc/config""')+      eq({+        alter_path('/home/new/nvim'),+        alter_path('/etc/config/nvim')+      }, funcs.stdpath('config_dirs'))+    end)++    it(""doesn't expand $VAR and $IBLES"", function()+      clear({env={+        XDG_CONFIG_DIRS='$VAR:$IBLES',+        VAR='this-should-not-happen',+        IBLES='neither-should-this'+      }})+      eq({+        alter_path('$VAR/nvim'),+        alter_path('$IBLES/nvim'),+      }, funcs.stdpath('config_dirs'))+    end)++    it(""doesn't expand ~/"", function()+      clear({env={+        XDG_CONFIG_DIRS='~/.oldconfig:~/.olderconfig'+      }})+      eq({+        alter_path('~/.oldconfig/nvim'),+        alter_path('~/.olderconfig/nvim'),+      }, funcs.stdpath('config_dirs'))+    end)+  end)++  describe('""data_dirs""' , function ()","Missing returns in cases ���colon-separated variable contains one directory���, ���colon-separated variable contains no directories��� (do not forget to set $HOME, $LOCALAPPDATA and $TEMP), ���colon-separated variable contains item larger then MAXPATHL��� (e.g. 8192 bytes). And I would highly suggest to create a test generator function like```lualocal home = ���  -- depends on OSlocal localappdata = ...  -- Something on Windows, empty string on *nixlocal function test_colon_env(msg, stdpath_arg, env_name, env_val, expected_paths, env_val_runtime, expected_paths_runtime)  it(msg, function()    clear({env={[env_name]=env_val, HOME=home, LOCALAPPDATA=localappdata}})    eq(expected_paths, funcs.stdpath(stdpath_arg))    if not env_val_runtime then return end    meths.set_var('env_val', env_val_runtime)    command(('let $%s=g:env_val'):format(env_name))    eq(expected_paths_runtime, funcs.stdpath(stdpath_arg))  end)end```Using such generators makes code less verbose.",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/6272,116512628,2017-05-15T14:54:26Z,src/nvim/eval.c,"@@ -15577,6 +15577,53 @@ static void f_split(typval_T *argvars, typval_T *rettv, FunPtr fptr)   p_cpo = save_cpo; } +/// ""stdpath()"" helper for list results+void stdpath_list_helper(const XDGVarType xdg, typval_T *rettv)+{+  const void *iter = NULL;+  list_T *const list = tv_list_alloc();+  rettv->v_type = VAR_LIST;+  rettv->vval.v_list = list;+  list->lv_refcount++;+  char *const dirs = stdpaths_get_xdg_var(xdg);+  do {+    size_t dir_len;+    const char *dir;+    iter = vim_colon_env_iter(dirs, iter, &dir, &dir_len);",You need to merge in master because `vim_colon_env_iter` is no longer there (now `vim_env_iter` and colon may be the first argument).,
7069,nelstrom,https://api.github.com/repos/neovim/neovim/pulls/6757,116788011,2017-05-16T16:10:21Z,runtime/doc/various.txt,"@@ -211,6 +211,11 @@ g8			Print the hex values of the bytes used in the :te[rminal][!]		Open an interactive shell in a |terminal-emulator|. 			Use the shell specified in 'shell'. +			The new terminal buffer takes over the current split","Ok, I'll `s/split window/window`Happy to remove the stuff about failing if the current buffer has changes. I thought it was worthwhile at least having a go at documenting the meaning of `[!]` in `:terminal!`, but there's a lot of complexity there and to document it thoroughly would mean adding lots and lots of words.",
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/6680,116843934,2017-05-16T20:05:24Z,src/nvim/event/socket.c,"@@ -40,17 +40,18 @@ int socket_watcher_init(Loop *loop, SocketWatcher *watcher,       return UV_EINVAL;     } -    *host_end = '\0';     uv_getaddrinfo_t request;+    *host_end = '\0';+    char *host = !strcmp(addr, ""localhost"") ? ""127.0.0.1"" : addr;",What if `localhost` is defined and its IP address is not `127.0.0.1` (perhaps a system with only IPv6 addresses that  maps `localhost` to `::1`? Also the the name in `serverlist()` would not match the address that the socket is using. Should names in the list be replaced with the IP address that is used with the tcp socket?,
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/6766,117333268,2017-05-18T19:28:27Z,runtime/autoload/man.vim,"@@ -12,6 +12,11 @@ catch /E145:/   "" Ignore the error in restricted mode endtry +try","What���s the point of `try` here? It is transforming all errors inside into exceptions and not catching after that, not what you would need at startup. I would suggest just `silent!` the call and remove `try`/`endtry`.",
10180857,nhooyr,https://api.github.com/repos/neovim/neovim/pulls/6766,117368989,2017-05-18T22:29:55Z,runtime/autoload/man.vim,"@@ -86,58 +136,13 @@ function! man#read_page(ref) abort   call s:put_page(page) endfunction -"" Handler for s:system() function.-function! s:system_handler(jobid, data, event) dict abort-  if a:event == 'stdout'-    let self.stdout .= join(a:data, ""\n"")-  elseif a:event == 'stderr'-    let self.stderr .= join(a:data, ""\n"")-  else-    let self.exit_code = a:data-  endif-endfunction--"" Run a system command and timeout after 30 seconds.-function! s:system(cmd, ...) abort-  let opts = {-        \ 'stdout': '',-        \ 'stderr': '',-        \ 'exit_code': 0,-        \ 'on_stdout': function('s:system_handler'),-        \ 'on_stderr': function('s:system_handler'),-        \ 'on_exit': function('s:system_handler'),-        \ }-  let jobid = jobstart(a:cmd, opts)--  if jobid < 1-    throw printf('command error %d: %s', jobid, join(a:cmd))-  endif--  let res = jobwait([jobid], 30000)-  if res[0] == -1-    try-      call jobstop(jobid)-      throw printf('command timed out: %s', join(a:cmd))-    catch /^Vim\%((\a\+)\)\=:E900/-    endtry-  elseif res[0] == -2-    throw printf('command interrupted: %s', join(a:cmd))-  endif-  if opts.exit_code != 0-    throw printf(""command error (%d) %s: %s"", jobid, join(a:cmd), substitute(opts.stderr, '\_s\+$', '', &gdefault ? '' : 'g'))-  endif--  return opts.stdout-endfunction- function! s:get_page(path) abort   "" Respect $MANWIDTH or default to window width.   let manwidth = empty($MANWIDTH) ? winwidth(0) : $MANWIDTH   "" Force MANPAGER=cat to ensure Vim is not recursively invoked (by man-db).   "" http://comments.gmane.org/gmane.editors.vim.devel/29085   let cmd = ['env', 'MANPAGER=cat', 'MANWIDTH='.manwidth, 'man']-  "" Use -l everywhere except macOS. #6683-  return s:system(cmd + (has('mac') ? [a:path] : ['-l', a:path]))+  return s:system(cmd + (!s:man_has_l_flag ? [a:path] : ['-l', a:path]))",could you reorder this so that the condition isn't a negative?,
151506,raichoo,https://api.github.com/repos/neovim/neovim/pulls/6766,117369077,2017-05-18T22:30:31Z,runtime/autoload/man.vim,"@@ -2,14 +2,64 @@  let s:man_find_arg = ""-w"" +"" Handler for s:system() function.+function! s:system_handler(jobid, data, event) dict abort+  if a:event == 'stdout'+    let self.stdout .= join(a:data, ""\n"")+  elseif a:event == 'stderr'+    let self.stderr .= join(a:data, ""\n"")+  else+    let self.exit_code = a:data+  endif+endfunction++"" Run a system command and timeout after 30 seconds.+function! s:system(cmd, ...) abort+  let opts = {+        \ 'stdout': '',+        \ 'stderr': '',+        \ 'exit_code': 0,+        \ 'on_stdout': function('s:system_handler'),+        \ 'on_stderr': function('s:system_handler'),+        \ 'on_exit': function('s:system_handler'),+        \ }+  let jobid = jobstart(a:cmd, opts)++  if jobid < 1+    throw printf('command error %d: %s', jobid, join(a:cmd))+  endif++  let res = jobwait([jobid], 30000)+  if res[0] == -1+    try+      call jobstop(jobid)+      throw printf('command timed out: %s', join(a:cmd))+    catch /^Vim\%((\a\+)\)\=:E900/+    endtry+  elseif res[0] == -2+    throw printf('command interrupted: %s', join(a:cmd))+  endif+  if opts.exit_code != 0+    throw printf(""command error (%d) %s: %s"", jobid, join(a:cmd), substitute(opts.stderr, '\_s\+$', '', &gdefault ? '' : 'g'))+  endif++  return opts.stdout+endfunction+ "" TODO(nhooyr) Completion may work on SunOS; I'm not sure if `man -l` displays "" the list of searched directories. try   if !has('win32') && $OSTYPE !~? 'cygwin\|linux' && system('uname -s') =~? 'SunOS' && system('uname -r') =~# '^5'     let s:man_find_arg = '-l'   endif+  let s:man_has_l_flag = 1+  let man_file = s:system(['man', '-w', 'man'])+  call s:system(['env', 'MANPAGER=cat', 'man', '-l', man_file])+  unlet man_file","Yes that seems reasonable. The thing is, I'm not a big fan of the `s:system` solution since I'm not quite sure if another exception can get thrown somewhere in there and I'll might end up with 'man_has_l_flag' as a default. I'd prefer the `system` solution.",
10180857,nhooyr,https://api.github.com/repos/neovim/neovim/pulls/6766,117369691,2017-05-18T22:34:49Z,runtime/autoload/man.vim,"@@ -2,14 +2,64 @@  let s:man_find_arg = ""-w"" +"" Handler for s:system() function.+function! s:system_handler(jobid, data, event) dict abort+  if a:event == 'stdout'+    let self.stdout .= join(a:data, ""\n"")+  elseif a:event == 'stderr'+    let self.stderr .= join(a:data, ""\n"")+  else+    let self.exit_code = a:data+  endif+endfunction++"" Run a system command and timeout after 30 seconds.+function! s:system(cmd, ...) abort+  let opts = {+        \ 'stdout': '',+        \ 'stderr': '',+        \ 'exit_code': 0,+        \ 'on_stdout': function('s:system_handler'),+        \ 'on_stderr': function('s:system_handler'),+        \ 'on_exit': function('s:system_handler'),+        \ }+  let jobid = jobstart(a:cmd, opts)++  if jobid < 1+    throw printf('command error %d: %s', jobid, join(a:cmd))+  endif++  let res = jobwait([jobid], 30000)+  if res[0] == -1+    try+      call jobstop(jobid)+      throw printf('command timed out: %s', join(a:cmd))+    catch /^Vim\%((\a\+)\)\=:E900/+    endtry+  elseif res[0] == -2+    throw printf('command interrupted: %s', join(a:cmd))+  endif+  if opts.exit_code != 0+    throw printf(""command error (%d) %s: %s"", jobid, join(a:cmd), substitute(opts.stderr, '\_s\+$', '', &gdefault ? '' : 'g'))+  endif++  return opts.stdout+endfunction+ "" TODO(nhooyr) Completion may work on SunOS; I'm not sure if `man -l` displays "" the list of searched directories. try   if !has('win32') && $OSTYPE !~? 'cygwin\|linux' && system('uname -s') =~? 'SunOS' && system('uname -r') =~# '^5'     let s:man_find_arg = '-l'   endif+  let s:man_has_l_flag = 1+  let man_file = s:system(['man', '-w', 'man'])+  call s:system(['env', 'MANPAGER=cat', 'man', '-l', man_file])+  unlet man_file","Yea, you are right, another exception can be thrown. Could you add a default exception check that will call echom to log the error? Include the prefix `man.vim: `",
10180857,nhooyr,https://api.github.com/repos/neovim/neovim/pulls/6766,117370602,2017-05-18T22:41:13Z,runtime/autoload/man.vim,"@@ -2,14 +2,67 @@  let s:man_find_arg = ""-w"" +"" Handler for s:system() function.+function! s:system_handler(jobid, data, event) dict abort+  if a:event == 'stdout'+    let self.stdout .= join(a:data, ""\n"")+  elseif a:event == 'stderr'+    let self.stderr .= join(a:data, ""\n"")+  else+    let self.exit_code = a:data+  endif+endfunction++"" Run a system command and timeout after 30 seconds.+function! s:system(cmd, ...) abort+  let opts = {+        \ 'stdout': '',+        \ 'stderr': '',+        \ 'exit_code': 0,+        \ 'on_stdout': function('s:system_handler'),+        \ 'on_stderr': function('s:system_handler'),+        \ 'on_exit': function('s:system_handler'),+        \ }+  let jobid = jobstart(a:cmd, opts)++  if jobid < 1+    throw printf('command error %d: %s', jobid, join(a:cmd))+  endif++  let res = jobwait([jobid], 30000)+  if res[0] == -1+    try+      call jobstop(jobid)+      throw printf('command timed out: %s', join(a:cmd))+    catch /^Vim\%((\a\+)\)\=:E900/+    endtry+  elseif res[0] == -2+    throw printf('command interrupted: %s', join(a:cmd))+  endif+  if opts.exit_code != 0+    throw printf(""command error (%d) %s: %s"", jobid, join(a:cmd), substitute(opts.stderr, '\_s\+$', '', &gdefault ? '' : 'g'))+  endif++  return opts.stdout+endfunction++function! s:enable_l_flag()+  let s:man_has_l_flag = 1+  let l:man_file = s:system(['man', '-w', 'man'])+  call s:system(['env', 'MANPAGER=cat', 'man', '-l', l:man_file])+endfunction+ "" TODO(nhooyr) Completion may work on SunOS; I'm not sure if `man -l` displays "" the list of searched directories. try   if !has('win32') && $OSTYPE !~? 'cygwin\|linux' && system('uname -s') =~? 'SunOS' && system('uname -r') =~# '^5'     let s:man_find_arg = '-l'   endif+  call s:enable_l_flag() catch /E145:/   "" Ignore the error in restricted mode+catch /command error*/","Since more exceptions can be thrown (e.g. if the command times out or is killed for whatever reason), could you add a default catch? And in the default catch, set the variable to 0 and echom `v:exception` to log the error.",
10180857,nhooyr,https://api.github.com/repos/neovim/neovim/pulls/6766,117372701,2017-05-18T22:56:00Z,runtime/autoload/man.vim,"@@ -2,14 +2,70 @@  let s:man_find_arg = ""-w"" +"" Handler for s:system() function.+function! s:system_handler(jobid, data, event) dict abort+  if a:event == 'stdout'+    let self.stdout .= join(a:data, ""\n"")+  elseif a:event == 'stderr'+    let self.stderr .= join(a:data, ""\n"")+  else+    let self.exit_code = a:data+  endif+endfunction++"" Run a system command and timeout after 30 seconds.+function! s:system(cmd, ...) abort+  let opts = {+        \ 'stdout': '',+        \ 'stderr': '',+        \ 'exit_code': 0,+        \ 'on_stdout': function('s:system_handler'),+        \ 'on_stderr': function('s:system_handler'),+        \ 'on_exit': function('s:system_handler'),+        \ }+  let jobid = jobstart(a:cmd, opts)++  if jobid < 1+    throw printf('command error %d: %s', jobid, join(a:cmd))+  endif++  let res = jobwait([jobid], 30000)+  if res[0] == -1+    try+      call jobstop(jobid)+      throw printf('command timed out: %s', join(a:cmd))+    catch /^Vim\%((\a\+)\)\=:E900/+    endtry+  elseif res[0] == -2+    throw printf('command interrupted: %s', join(a:cmd))+  endif+  if opts.exit_code != 0+    throw printf(""command error (%d) %s: %s"", jobid, join(a:cmd), substitute(opts.stderr, '\_s\+$', '', &gdefault ? '' : 'g'))+  endif++  return opts.stdout+endfunction++function! s:enable_l_flag()+  let s:man_has_l_flag = 1+  let l:man_file = s:system(['man', '-w', 'man'])+  call s:system(['env', 'MANPAGER=cat', 'man', '-l', l:man_file])","Oh yea, my bad. Instead, could you copy the comment from the line where you got this, the one about why `MANPAGER=cat` is present there?",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/6766,117404854,2017-05-19T05:15:02Z,runtime/autoload/man.vim,"@@ -2,14 +2,67 @@  let s:man_find_arg = ""-w"" +"" Handler for s:system() function.+function! s:system_handler(jobid, data, event) dict abort+  if a:event == 'stdout'+    let self.stdout .= join(a:data, ""\n"")+  elseif a:event == 'stderr'+    let self.stderr .= join(a:data, ""\n"")+  else+    let self.exit_code = a:data+  endif+endfunction++"" Run a system command and timeout after 30 seconds.+function! s:system(cmd, ...) abort+  let opts = {+        \ 'stdout': '',+        \ 'stderr': '',+        \ 'exit_code': 0,+        \ 'on_stdout': function('s:system_handler'),+        \ 'on_stderr': function('s:system_handler'),+        \ 'on_exit': function('s:system_handler'),+        \ }+  let jobid = jobstart(a:cmd, opts)++  if jobid < 1+    throw printf('command error %d: %s', jobid, join(a:cmd))+  endif++  let res = jobwait([jobid], 30000)+  if res[0] == -1+    try+      call jobstop(jobid)+      throw printf('command timed out: %s', join(a:cmd))+    catch /^Vim\%((\a\+)\)\=:E900/+    endtry+  elseif res[0] == -2+    throw printf('command interrupted: %s', join(a:cmd))+  endif+  if opts.exit_code != 0+    throw printf(""command error (%d) %s: %s"", jobid, join(a:cmd), substitute(opts.stderr, '\_s\+$', '', &gdefault ? '' : 'g'))+  endif++  return opts.stdout+endfunction++function! s:enable_l_flag()+  let s:man_has_l_flag = 1+  let l:man_file = s:system(['man', '-w', 'man'])+  call s:system(['env', 'MANPAGER=cat', 'man', '-l', l:man_file])+endfunction+ "" TODO(nhooyr) Completion may work on SunOS; I'm not sure if `man -l` displays "" the list of searched directories. try   if !has('win32') && $OSTYPE !~? 'cygwin\|linux' && system('uname -s') =~? 'SunOS' && system('uname -r') =~# '^5'     let s:man_find_arg = '-l'   endif+  call s:enable_l_flag() catch /E145:/   "" Ignore the error in restricted mode+catch /command error*/","This condition is false, you are trying to match `command erro`, `command error`, `command errorrrrrrr`: you get the idea. I guess not what you meant, need to write `command error .*`.",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/6766,117405525,2017-05-19T05:24:54Z,runtime/autoload/man.vim,"@@ -2,14 +2,91 @@  let s:man_find_arg = ""-w"" +"" Handler for s:system() function.+function! s:system_handler(jobid, data, event) dict abort+  if a:event == 'stdout'+    let self.stdout .= join(a:data, ""\n"")+  elseif a:event == 'stderr'+    let self.stderr .= join(a:data, ""\n"")+  else+    let self.exit_code = a:data+  endif+endfunction++"" Run a system command and timeout after 30 seconds.+function! s:system(cmd, ...) abort+  let opts = {+        \ 'stdout': '',+        \ 'stderr': '',+        \ 'exit_code': 0,+        \ 'on_stdout': function('s:system_handler'),+        \ 'on_stderr': function('s:system_handler'),+        \ 'on_exit': function('s:system_handler'),+        \ }+  let jobid = jobstart(a:cmd, opts)++  if jobid < 1+    throw printf('command error %d: %s', jobid, join(a:cmd))+  endif++  let res = jobwait([jobid], 30000)+  if res[0] == -1+    try+      call jobstop(jobid)+      throw printf('command timed out: %s', join(a:cmd))+    catch /^Vim\%((\a\+)\)\=:E900/+    endtry+  elseif res[0] == -2+    throw printf('command interrupted: %s', join(a:cmd))+  endif+  if opts.exit_code != 0+    throw printf(""command error (%d) %s: %s"", jobid, join(a:cmd), substitute(opts.stderr, '\_s\+$', '', &gdefault ? '' : 'g'))+  endif++  return opts.stdout+endfunction++function! s:get_path(sect, name) abort+  if empty(a:sect)+    return s:system(['man', s:man_find_arg, a:name])+  endif+  "" '-s' flag handles:+  ""   - tokens like 'printf(echo)'+  ""   - sections starting with '-'+  ""   - 3pcap section (found on macOS)+  ""   - commas between sections (for section priority)+  return s:system(['man', s:man_find_arg, '-s', a:sect, a:name])+endfunction++function! s:get_page(path) abort+  "" Respect $MANWIDTH or default to window width.+  let manwidth = empty($MANWIDTH) ? winwidth(0) : $MANWIDTH+  "" Force MANPAGER=cat to ensure Vim is not recursively invoked (by man-db).+  "" http://comments.gmane.org/gmane.editors.vim.devel/29085+  let cmd = ['env', 'MANPAGER=cat', 'MANWIDTH='.manwidth, 'man']+  return s:system(cmd + (s:man_has_l_flag ? ['-l', a:path] : [a:path]))+endfunction++function! s:enable_l_flag()","I would also remove the function and move the code back to inside try (additionall note: there need not be any `:unset` if you used `s:man_file` to not pollute global scope, though I tend to `unlet` temporary variables in such cases as well): it hides away some manipulations with global `s:man_has_l_flag` while other manipulations are still below and it has incorrect name: you are not enabling `-l` flag, you are checking whether it can be enabled by enabling it and running `s:get_page`.",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/6766,117405671,2017-05-19T05:26:50Z,runtime/autoload/man.vim,"@@ -2,14 +2,91 @@  let s:man_find_arg = ""-w"" +"" Handler for s:system() function.+function! s:system_handler(jobid, data, event) dict abort+  if a:event == 'stdout'+    let self.stdout .= join(a:data, ""\n"")+  elseif a:event == 'stderr'+    let self.stderr .= join(a:data, ""\n"")","These two branches may be merged into```VimLif a:event is# 'stdout' || a:event is# 'stderr'  let self[a:event] .= join(a:data, ""\n"")```",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/6766,117448147,2017-05-19T10:08:16Z,runtime/autoload/man.vim,"@@ -2,15 +2,24 @@  let s:man_find_arg = ""-w"" -"" TODO(nhooyr) Completion may work on SunOS; I'm not sure if `man -l` displays-"" the list of searched directories.-try-  if !has('win32') && $OSTYPE !~? 'cygwin\|linux' && system('uname -s') =~? 'SunOS' && system('uname -r') =~# '^5'-    let s:man_find_arg = '-l'-  endif-catch /E145:/-  "" Ignore the error in restricted mode-endtry+function s:init() abort+  "" TODO(nhooyr) Completion may work on SunOS; I'm not sure if `man -l` displays+  "" the list of searched directories.+  try+    if !has('win32') && $OSTYPE !~? 'cygwin\|linux' && system('uname -s') =~? 'SunOS' && system('uname -r') =~# '^5'+      let s:man_find_arg = '-l'+    endif+    let s:man_has_l_flag = 1+    call s:get_page(s:get_path('', 'man'))+  catch /E145:/+    "" Ignore the error in restricted mode+  catch /command error .*/+    let s:man_has_l_flag = 0+  catch+    let s:man_has_l_flag = 0","Actually this whole `catch` should be removed, let the exception bubble up as before.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/6766,117471934,2017-05-19T12:47:00Z,runtime/autoload/man.vim,"@@ -2,15 +2,21 @@  let s:man_find_arg = ""-w"" -"" TODO(nhooyr) Completion may work on SunOS; I'm not sure if `man -l` displays-"" the list of searched directories.-try-  if !has('win32') && $OSTYPE !~? 'cygwin\|linux' && system('uname -s') =~? 'SunOS' && system('uname -r') =~# '^5'-    let s:man_find_arg = '-l'-  endif-catch /E145:/-  "" Ignore the error in restricted mode-endtry+function s:init() abort+  "" TODO(nhooyr) Completion may work on SunOS; I'm not sure if `man -l` displays+  "" the list of searched directories.+  try+    if !has('win32') && $OSTYPE !~? 'cygwin\|linux' && system('uname -s') =~? 'SunOS' && system('uname -r') =~# '^5'+      let s:man_find_arg = '-l'+    endif+    let s:localfile_arg = 1+    call s:get_page(s:get_path('', 'man'))",@nhooyr  see https://github.com/raichoo/neovim/blob/a07ca9df1c5cb664a9244ed45561d511130c1935/runtime/autoload/man.vim#L233And try removing the `[0:-2]` in my commit to see the error I was seeing.,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/6772,117599673,2017-05-20T02:16:53Z,test/functional/fixtures/tty-test.c,"@@ -6,6 +6,9 @@ #include <stdlib.h> #include <uv.h> +// -V:STRUCT_CAST:641+#define STRUCT_CAST(Type, obj) ((Type *)(obj))",Does this hide strict aliasing violations?,
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/6772,117599843,2017-05-20T02:27:28Z,test/functional/fixtures/tty-test.c,"@@ -6,6 +6,9 @@ #include <stdlib.h> #include <uv.h> +// -V:STRUCT_CAST:641+#define STRUCT_CAST(Type, obj) ((Type *)(obj))","This does not hide anything, just silences some warnings. If I am not mistaking regarding what strict aliasing means then you may search for STRUCT_CAST to find code which for sure violates strict aliasing rules. It is libuv which makes us play with struct pointers though.",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/6772,117599971,2017-05-20T02:33:25Z,src/nvim/charset.c,"@@ -545,18 +545,8 @@ void transchar_nonprint(char_u *buf, int c)     buf[1] = (char_u)(c ^ 0x40);      buf[2] = NUL;-  } else if (c >= 0x80) {","Based on the Vim code it appears that `|x` and `~x` were intended for non-multibyte builds or when `&encoding` is not UTF-8: not actually a dead code, just we removed all conditions which may trigger it.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/6772,117600092,2017-05-20T02:40:01Z,test/functional/fixtures/tty-test.c,"@@ -6,6 +6,9 @@ #include <stdlib.h> #include <uv.h> +// -V:STRUCT_CAST:641+#define STRUCT_CAST(Type, obj) ((Type *)(obj))","Yeah, but I wonder if it could hide something in the future. Maybe we should leave the PVS warnings.",
40799,docwhat,https://api.github.com/repos/neovim/neovim/pulls/6272,117600350,2017-05-20T02:53:11Z,test/functional/options/defaults_spec.lua,"@@ -328,3 +332,235 @@ describe('XDG-based defaults', function()     end)   end) end)+++describe('stdpath()', function()+  -- Returns an OS friendly version of the unix_path.+  local function alter_path(unix_path)+    if os_name() == 'windows' then+      return string.gsub(unix_path, '/', '\\')+    else+      return unix_path+    end+  end++  describe('""config""' , function ()+    it('knows XDG_CONFIG_HOME', function()+      clear({env={+        XDG_CONFIG_HOME=alter_path('/home/docwhat/.config')+      }})+      eq(alter_path('/home/docwhat/.config/nvim'), funcs.stdpath('config'))+    end)++    it('handles changes during runtime', function()+      clear({env={+        XDG_CONFIG_HOME=alter_path('/home/original')+      }})+      eq(alter_path('/home/original/nvim'), funcs.stdpath('config'))+      nvim('command', 'let $XDG_CONFIG_HOME=""/home/new""')+      eq(alter_path('/home/new/nvim'), funcs.stdpath('config'))+    end)++    it(""doesn't expand $VARIABLES"", function()+      clear({env={+        XDG_CONFIG_HOME='$VARIABLES',+        VARIABLES='this-should-not-happen'+      }})+      eq(alter_path('$VARIABLES/nvim'), funcs.stdpath('config'))+    end)++    it(""doesn't expand ~/"", function()+      clear({env={+        XDG_CONFIG_HOME='~/frobnitz'+      }})+      eq(alter_path('~/frobnitz/nvim'), funcs.stdpath('config'))+    end)+  end)++  describe('""data""' , function ()+    local appended_dir+    before_each(function()+      -- Windows appends 'nvim-data' instead of just 'nvim' to+      -- prevent collisions due to XDG_CONFIG_HOME and XDG_DATA_HOME+      -- being the same.+      if os_name() == 'windows' then","I don't know what `clear()` actually does.  I'm cargo-culting that bit of code.I assume it is [this method](https://github.com/neovim/neovim/blob/19d38c4d0f98004e8b2c39821f9bee8ca7e2f5d2/test/functional/helpers.lua#L258) but there are no docs and I'm not skilled enough at Lua to understand what it is doing.Also, can you confirm that [Busted](http://olivinelabs.com/busted/) is what's being used for the lua tests? It isn't mentioned in `CONTRIBUTING.md`, so I googled for ""rspec like lua tests"" ���� ",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/6772,117611313,2017-05-20T15:07:20Z,test/functional/fixtures/tty-test.c,"@@ -6,6 +6,9 @@ #include <stdlib.h> #include <uv.h> +// -V:STRUCT_CAST:641+#define STRUCT_CAST(Type, obj) ((Type *)(obj))","> How?I mean if, e.g., the type argument to the parameter is changed for some reason in the future.",
40799,docwhat,https://api.github.com/repos/neovim/neovim/pulls/6272,117622964,2017-05-21T04:41:29Z,test/functional/options/defaults_spec.lua,"@@ -328,3 +332,235 @@ describe('XDG-based defaults', function()     end)   end) end)+++describe('stdpath()', function()+  -- Returns an OS friendly version of the unix_path.+  local function alter_path(unix_path)+    if os_name() == 'windows' then+      return string.gsub(unix_path, '/', '\\')+    else+      return unix_path+    end+  end++  describe('""config""' , function ()+    it('knows XDG_CONFIG_HOME', function()+      clear({env={+        XDG_CONFIG_HOME=alter_path('/home/docwhat/.config')+      }})+      eq(alter_path('/home/docwhat/.config/nvim'), funcs.stdpath('config'))+    end)++    it('handles changes during runtime', function()+      clear({env={+        XDG_CONFIG_HOME=alter_path('/home/original')+      }})+      eq(alter_path('/home/original/nvim'), funcs.stdpath('config'))+      nvim('command', 'let $XDG_CONFIG_HOME=""/home/new""')+      eq(alter_path('/home/new/nvim'), funcs.stdpath('config'))+    end)++    it(""doesn't expand $VARIABLES"", function()+      clear({env={+        XDG_CONFIG_HOME='$VARIABLES',+        VARIABLES='this-should-not-happen'+      }})+      eq(alter_path('$VARIABLES/nvim'), funcs.stdpath('config'))+    end)++    it(""doesn't expand ~/"", function()+      clear({env={+        XDG_CONFIG_HOME='~/frobnitz'+      }})+      eq(alter_path('~/frobnitz/nvim'), funcs.stdpath('config'))+    end)+  end)++  describe('""data""' , function ()+    local appended_dir+    before_each(function()+      -- Windows appends 'nvim-data' instead of just 'nvim' to+      -- prevent collisions due to XDG_CONFIG_HOME and XDG_DATA_HOME+      -- being the same.+      if os_name() == 'windows' then+        appended_dir = '/nvim-data'+      else+        appended_dir = '/nvim'+      end+    end)++    it('knows XDG_DATA_HOME', function()+      clear({env={+        XDG_DATA_HOME=alter_path('/home/docwhat/.local')+      }})+      eq(alter_path('/home/docwhat/.local' .. appended_dir), funcs.stdpath('data'))+    end)++    it('handles changes during runtime', function()+      clear({env={+        XDG_DATA_HOME=alter_path('/home/original')+      }})+      eq(alter_path('/home/original' .. appended_dir), funcs.stdpath('data'))+      nvim('command', 'let $XDG_DATA_HOME=""/home/new""')+      eq(alter_path('/home/new' .. appended_dir), funcs.stdpath('data'))+    end)++    it(""doesn't expand $VARIABLES"", function()+      clear({env={+        XDG_DATA_HOME='$VARIABLES',+        VARIABLES='this-should-not-happen'+      }})+      eq(alter_path('$VARIABLES' .. appended_dir), funcs.stdpath('data'))+    end)++    it(""doesn't expand ~/"", function()+      clear({env={+        XDG_DATA_HOME='~/frobnitz'+      }})+      eq(alter_path('~/frobnitz' .. appended_dir), funcs.stdpath('data'))+    end)+  end)++  describe('""cache""' , function ()+    it('knows XDG_CACHE_HOME', function()+      clear({env={+        XDG_CACHE_HOME=alter_path('/home/docwhat/.cache')+      }})+      eq(alter_path('/home/docwhat/.cache/nvim'), funcs.stdpath('cache'))+    end)++    it('handles changes during runtime', function()+      clear({env={+        XDG_CACHE_HOME=alter_path('/home/original')+      }})+      eq(alter_path('/home/original/nvim'), funcs.stdpath('cache'))+      nvim('command', 'let $XDG_CACHE_HOME=""/home/new""')+      eq(alter_path('/home/new/nvim'), funcs.stdpath('cache'))+    end)++    it(""doesn't expand $VARIABLES"", function()+      clear({env={+        XDG_CACHE_HOME='$VARIABLES',+        VARIABLES='this-should-not-happen'+      }})+      eq(alter_path('$VARIABLES/nvim'), funcs.stdpath('cache'))+    end)++    it(""doesn't expand ~/"", function()+      clear({env={+        XDG_CACHE_HOME='~/frobnitz'+      }})+      eq(alter_path('~/frobnitz/nvim'), funcs.stdpath('cache'))+    end)+  end)++  describe('""config_dirs""' , function ()+    it('knows XDG_CONFIG_DIRS', function()+      clear({env={+        XDG_CONFIG_DIRS=alter_path('/home/docwhat/.config:/etc/config')+      }})+      eq({+        alter_path('/home/docwhat/.config/nvim'),+        alter_path('/etc/config/nvim'),+      }, funcs.stdpath('config_dirs'))+    end)++    it('handles changes during runtime', function()+      clear({env={+        XDG_CONFIG_DIRS=alter_path('/home/original:/etc/config')+      }})+      eq({+        alter_path('/home/original/nvim'),+        alter_path('/etc/config/nvim')+      }, funcs.stdpath('config_dirs'))+      nvim('command', 'let $XDG_CONFIG_DIRS=""/home/new:/etc/config""')+      eq({+        alter_path('/home/new/nvim'),+        alter_path('/etc/config/nvim')+      }, funcs.stdpath('config_dirs'))+    end)++    it(""doesn't expand $VAR and $IBLES"", function()+      clear({env={+        XDG_CONFIG_DIRS='$VAR:$IBLES',+        VAR='this-should-not-happen',+        IBLES='neither-should-this'+      }})+      eq({+        alter_path('$VAR/nvim'),+        alter_path('$IBLES/nvim'),+      }, funcs.stdpath('config_dirs'))+    end)++    it(""doesn't expand ~/"", function()+      clear({env={+        XDG_CONFIG_DIRS='~/.oldconfig:~/.olderconfig'+      }})+      eq({+        alter_path('~/.oldconfig/nvim'),+        alter_path('~/.olderconfig/nvim'),+      }, funcs.stdpath('config_dirs'))+    end)+  end)++  describe('""data_dirs""' , function ()","Thanks for the generator suggestion.  I implemented something similar, splitting the two tests into separate `it` statements.I'm not sure how to test _colon-separated variable contains no directories_ since that triggers the default behavior from `stdpaths.c`.  Should I re-implement the `xdg_defaults` struct (with its `#ifdef WIN32` logic)? And regarding _colon-separated variable contains item larger then MAXPATHL_: What should I expect?`get_xdg_home` and `concat_fnames_realloc` don't do any checks for `MAXPATHL` at the moment.I also dislike hard-coding a value (e.g. 8192) since that can vary from OS to OS.  Is there a way to query vim or lua for this value?",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/6383,117628943,2017-05-21T10:11:32Z,test/functional/terminal/scrollback_spec.lua,"@@ -416,7 +440,12 @@ describe(""'scrollback' option"", function()     -- Terminal job data is received asynchronously, may happen before the     -- 'scrollback' option is synchronized with the internal sb_buffer.     command('sleep 100m')-    feed_data('for i in $(seq 1 40); do echo ""line$i""; done\n')+    if iswin() then+      nvim('command',",Can't feed_data be used ? It does jobsend on the child instance in the terminal.,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/6566,117630205,2017-05-21T11:17:38Z,src/nvim/api/ui_events.in.h,"@@ -58,6 +58,8 @@ void set_title(String title)     FUNC_API_SINCE(3); void set_icon(String icon)     FUNC_API_SINCE(3);+void highlights_changed(Array highlights_changed)","The naming precedent is ""set"", we don't have ""changed"" (though we do have ""change""... oh dear). We already have `highlight_set`, which is a UI change, whereas this new event is a property change. Kind of a mess. Naming this `highlight_info_set` at least is analogous to `mode_info_set`. We can use ""info"" as the pattern for ""property changes"".",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/6272,117630730,2017-05-21T11:44:19Z,test/functional/options/defaults_spec.lua,"@@ -328,3 +332,235 @@ describe('XDG-based defaults', function()     end)   end) end)+++describe('stdpath()', function()+  -- Returns an OS friendly version of the unix_path.+  local function alter_path(unix_path)+    if os_name() == 'windows' then+      return string.gsub(unix_path, '/', '\\')+    else+      return unix_path+    end+  end++  describe('""config""' , function ()+    it('knows XDG_CONFIG_HOME', function()+      clear({env={+        XDG_CONFIG_HOME=alter_path('/home/docwhat/.config')+      }})+      eq(alter_path('/home/docwhat/.config/nvim'), funcs.stdpath('config'))+    end)++    it('handles changes during runtime', function()+      clear({env={+        XDG_CONFIG_HOME=alter_path('/home/original')+      }})+      eq(alter_path('/home/original/nvim'), funcs.stdpath('config'))+      nvim('command', 'let $XDG_CONFIG_HOME=""/home/new""')+      eq(alter_path('/home/new/nvim'), funcs.stdpath('config'))+    end)++    it(""doesn't expand $VARIABLES"", function()+      clear({env={+        XDG_CONFIG_HOME='$VARIABLES',+        VARIABLES='this-should-not-happen'+      }})+      eq(alter_path('$VARIABLES/nvim'), funcs.stdpath('config'))+    end)++    it(""doesn't expand ~/"", function()+      clear({env={+        XDG_CONFIG_HOME='~/frobnitz'+      }})+      eq(alter_path('~/frobnitz/nvim'), funcs.stdpath('config'))+    end)+  end)++  describe('""data""' , function ()+    local appended_dir+    before_each(function()+      -- Windows appends 'nvim-data' instead of just 'nvim' to+      -- prevent collisions due to XDG_CONFIG_HOME and XDG_DATA_HOME+      -- being the same.+      if os_name() == 'windows' then+        appended_dir = '/nvim-data'+      else+        appended_dir = '/nvim'+      end+    end)++    it('knows XDG_DATA_HOME', function()+      clear({env={+        XDG_DATA_HOME=alter_path('/home/docwhat/.local')+      }})+      eq(alter_path('/home/docwhat/.local' .. appended_dir), funcs.stdpath('data'))+    end)++    it('handles changes during runtime', function()+      clear({env={+        XDG_DATA_HOME=alter_path('/home/original')+      }})+      eq(alter_path('/home/original' .. appended_dir), funcs.stdpath('data'))+      nvim('command', 'let $XDG_DATA_HOME=""/home/new""')+      eq(alter_path('/home/new' .. appended_dir), funcs.stdpath('data'))+    end)++    it(""doesn't expand $VARIABLES"", function()+      clear({env={+        XDG_DATA_HOME='$VARIABLES',+        VARIABLES='this-should-not-happen'+      }})+      eq(alter_path('$VARIABLES' .. appended_dir), funcs.stdpath('data'))+    end)++    it(""doesn't expand ~/"", function()+      clear({env={+        XDG_DATA_HOME='~/frobnitz'+      }})+      eq(alter_path('~/frobnitz' .. appended_dir), funcs.stdpath('data'))+    end)+  end)++  describe('""cache""' , function ()+    it('knows XDG_CACHE_HOME', function()+      clear({env={+        XDG_CACHE_HOME=alter_path('/home/docwhat/.cache')+      }})+      eq(alter_path('/home/docwhat/.cache/nvim'), funcs.stdpath('cache'))+    end)++    it('handles changes during runtime', function()+      clear({env={+        XDG_CACHE_HOME=alter_path('/home/original')+      }})+      eq(alter_path('/home/original/nvim'), funcs.stdpath('cache'))+      nvim('command', 'let $XDG_CACHE_HOME=""/home/new""')+      eq(alter_path('/home/new/nvim'), funcs.stdpath('cache'))+    end)++    it(""doesn't expand $VARIABLES"", function()+      clear({env={+        XDG_CACHE_HOME='$VARIABLES',+        VARIABLES='this-should-not-happen'+      }})+      eq(alter_path('$VARIABLES/nvim'), funcs.stdpath('cache'))+    end)++    it(""doesn't expand ~/"", function()+      clear({env={+        XDG_CACHE_HOME='~/frobnitz'+      }})+      eq(alter_path('~/frobnitz/nvim'), funcs.stdpath('cache'))+    end)+  end)++  describe('""config_dirs""' , function ()+    it('knows XDG_CONFIG_DIRS', function()+      clear({env={+        XDG_CONFIG_DIRS=alter_path('/home/docwhat/.config:/etc/config')+      }})+      eq({+        alter_path('/home/docwhat/.config/nvim'),+        alter_path('/etc/config/nvim'),+      }, funcs.stdpath('config_dirs'))+    end)++    it('handles changes during runtime', function()+      clear({env={+        XDG_CONFIG_DIRS=alter_path('/home/original:/etc/config')+      }})+      eq({+        alter_path('/home/original/nvim'),+        alter_path('/etc/config/nvim')+      }, funcs.stdpath('config_dirs'))+      nvim('command', 'let $XDG_CONFIG_DIRS=""/home/new:/etc/config""')+      eq({+        alter_path('/home/new/nvim'),+        alter_path('/etc/config/nvim')+      }, funcs.stdpath('config_dirs'))+    end)++    it(""doesn't expand $VAR and $IBLES"", function()+      clear({env={+        XDG_CONFIG_DIRS='$VAR:$IBLES',+        VAR='this-should-not-happen',+        IBLES='neither-should-this'+      }})+      eq({+        alter_path('$VAR/nvim'),+        alter_path('$IBLES/nvim'),+      }, funcs.stdpath('config_dirs'))+    end)++    it(""doesn't expand ~/"", function()+      clear({env={+        XDG_CONFIG_DIRS='~/.oldconfig:~/.olderconfig'+      }})+      eq({+        alter_path('~/.oldconfig/nvim'),+        alter_path('~/.olderconfig/nvim'),+      }, funcs.stdpath('config_dirs'))+    end)+  end)++  describe('""data_dirs""' , function ()","By ���Colon-separated variable contains no directories��� I meant simply ���it is empty���. About ���larger then MAXPATHL���: best if you just return those large directories. Maybe omitting them from the output. But not truncating (not here, I believe omitting is better then truncating for `stdpath`) and definitely not crashing Neovim (there were such problems, and maybe are now in some places). Querying Neovim for this value is not possible currently, but I think it is good idea to add `GREAT_DIR_LENGTH` constant to `test.functional.helpers`, needs to be at least twice as large as MAXPATHL (if it is not too large Neovim may not crash on buffer overflow).",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/6272,117630879,2017-05-21T11:51:44Z,test/functional/options/defaults_spec.lua,"@@ -328,3 +331,277 @@ describe('XDG-based defaults', function()     end)   end) end)+++describe('stdpath()', function()+  -- Returns an OS friendly version of the unix_path.+  local function alter_path(unix_path)+    if helpers.iswin() then+      return string.gsub(unix_path, '/', '\\')+    else+      return unix_path+    end+  end++  context('returns a String', function()+    describe('with ""config""' , function ()+      it('knows XDG_CONFIG_HOME', function()+        clear({env={+          XDG_CONFIG_HOME=alter_path('/home/docwhat/.config')+        }})+        eq(alter_path('/home/docwhat/.config/nvim'), funcs.stdpath('config'))+      end)++      it('handles changes during runtime', function()+        clear({env={+          XDG_CONFIG_HOME=alter_path('/home/original')+        }})+        eq(alter_path('/home/original/nvim'), funcs.stdpath('config'))+        nvim('command', 'let $XDG_CONFIG_HOME=""/home/new""')","There is `command` function imported, why not use that? I would actually name `nvim` deprecated: in my tests this is normally expressed as `meths.command('���')`, unless there is some function in helpers (`eval`, `command`, etc).",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/6272,117630930,2017-05-21T11:53:47Z,test/functional/options/defaults_spec.lua,"@@ -328,3 +331,277 @@ describe('XDG-based defaults', function()     end)   end) end)+++describe('stdpath()', function()+  -- Returns an OS friendly version of the unix_path.+  local function alter_path(unix_path)+    if helpers.iswin() then+      return string.gsub(unix_path, '/', '\\')","`string.gsub` returns two items (note: not a list of two items, two items). Use `select` or first assign to a variable and then return it (better second because I remember some issues with select, though do not remember which exactly). This is why you get `2` on AppVeyor.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/6680,117644405,2017-05-21T22:12:37Z,src/nvim/msgpack_rpc/server.c,"@@ -97,37 +97,47 @@ char *server_address_new(void) #endif } -/// Starts listening for API calls on the TCP address or pipe path `endpoint`.+/// Starts listening for API calls.+/// /// The socket type is determined by parsing `endpoint`: If it's a valid IPv4-/// address in 'ip[:port]' format, then it will be TCP socket. The port is-/// optional and if omitted defaults to NVIM_DEFAULT_TCP_PORT. Otherwise it-/// will be a unix socket or named pipe.+/// or IPv6 address in 'ip:[port]' format, then it will be a TCP socket.+/// Otherwise it will be a Unix socket or named pipe (Windows).+///+/// If no port is given, a random one will be assigned. ///-/// @param endpoint Address of the server. Either a 'ip[:port]' string or an-///        arbitrary identifier (trimmed to 256 bytes) for the unix socket or-///        named pipe.+/// @param endpoint Address of the server. Either a 'ip:[port]' string or an+///                 arbitrary identifier (trimmed to 256 bytes) for the Unix+///                 socket or named pipe. /// @returns 0 on success, 1 on a regular error, and negative errno-///          on failure to bind or connect.+///          on failure to bind or listen. int server_start(const char *endpoint) {-  if (endpoint == NULL) {-    ELOG(""Attempting to start server on NULL endpoint"");+  if (endpoint == NULL || endpoint[0] == '\0') {+    ELOG(""The endpoint mustn't be NULL or empty."");","~~typo.~~ (actually not a typo, I'm just up too late) avoid ""The"", it's usually useless at the start of a message or comment.    ELOG(""Empty or NULL endpoint"");",
972014,mhinz,https://api.github.com/repos/neovim/neovim/pulls/6680,117644543,2017-05-21T22:19:12Z,src/nvim/event/socket.c,"@@ -82,33 +68,60 @@ void socket_watcher_init(Loop *loop, SocketWatcher *watcher,   watcher->cb = NULL;   watcher->close_cb = NULL;   watcher->events = NULL;+  watcher->data = NULL;++  return 0; }  int socket_watcher_start(SocketWatcher *watcher, int backlog, socket_cb cb)   FUNC_ATTR_NONNULL_ALL {   watcher->cb = cb;-  int result;+  int result = UV_EINVAL;    if (watcher->stream->type == UV_TCP) {-    result = uv_tcp_bind(&watcher->uv.tcp.handle,-                         (const struct sockaddr *)&watcher->uv.tcp.addr, 0);+    struct addrinfo *ai = watcher->uv.tcp.addrinfo;++    for (; ai; ai = ai->ai_next) {+      result = uv_tcp_bind(&watcher->uv.tcp.handle, ai->ai_addr, 0);+      if (result != 0) {+        continue;+      }+      result = uv_listen(watcher->stream, backlog, connection_cb);+      if (result == 0) {+        struct sockaddr_storage sas;++        // When the endpoint in socket_watcher_init() didn't specify a port+        // number, a free random port number will be assigned. sin_port will+        // contain 0 in this case, unless uv_tcp_getsockname() is used first.+        uv_tcp_getsockname(&watcher->uv.tcp.handle, (struct sockaddr *)&sas,+                           &(int){ sizeof(sas) });+        uint16_t port = (sas.ss_family == AF_INET)+          ? ((struct sockaddr_in  *)&sas)->sin_port+          : ((struct sockaddr_in6 *)&sas)->sin6_port;+        // v:servername uses the string from watcher->addr+        size_t len = strlen(watcher->addr);+        snprintf(watcher->addr+len, sizeof(watcher->addr)-len, ""%"" PRIu16,+                 ntohs(port));",The network byte order is big endian and my host's byte order is little endian.,
972014,mhinz,https://api.github.com/repos/neovim/neovim/pulls/6680,117645370,2017-05-21T22:58:06Z,src/nvim/event/socket.c,"@@ -17,60 +17,46 @@ #include ""nvim/path.h"" #include ""nvim/memory.h"" #include ""nvim/macros.h""+#include ""nvim/charset.h""  #ifdef INCLUDE_GENERATED_DECLARATIONS # include ""event/socket.c.generated.h"" #endif -#define NVIM_DEFAULT_TCP_PORT 7450--void socket_watcher_init(Loop *loop, SocketWatcher *watcher,-    const char *endpoint, void *data)-  FUNC_ATTR_NONNULL_ARG(1) FUNC_ATTR_NONNULL_ARG(2) FUNC_ATTR_NONNULL_ARG(3)+int socket_watcher_init(Loop *loop, SocketWatcher *watcher,+                        const char *endpoint)+  FUNC_ATTR_NONNULL_ALL {-  // Trim to `ADDRESS_MAX_SIZE`-  if (xstrlcpy(watcher->addr, endpoint, sizeof(watcher->addr))-      >= sizeof(watcher->addr)) {-    // TODO(aktau): since this is not what the user wanted, perhaps we-    // should return an error here-    WLOG(""Address was too long, truncated to %s"", watcher->addr);-  }--  bool tcp = true;-  char ip[16], *ip_end = xstrchrnul(watcher->addr, ':');--  // (ip_end - addr) is always > 0, so convert to size_t-  size_t addr_len = (size_t)(ip_end - watcher->addr);--  if (addr_len > sizeof(ip) - 1) {-    // Maximum length of an IPv4 address buffer is 15 (eg: 255.255.255.255)-    addr_len = sizeof(ip) - 1;-  }--  // Extract the address part-  xstrlcpy(ip, watcher->addr, addr_len + 1);-  int port = NVIM_DEFAULT_TCP_PORT;--  if (*ip_end == ':') {-    // Extract the port-    long lport = strtol(ip_end + 1, NULL, 10); // NOLINT-    if (lport <= 0 || lport > 0xffff) {-      // Invalid port, treat as named pipe or unix socket-      tcp = false;-    } else {-      port = (int) lport;+  xstrlcpy(watcher->addr, endpoint, sizeof(watcher->addr));+  char *addr = watcher->addr;+  char *host_end = strrchr(addr, ':');++  if (host_end && addr != host_end) {+    char *port = host_end + 1;+    intmax_t iport;++    int ret = getdigits_safe(&(char_u *){ (char_u *)port }, &iport);+    if (ret == FAIL || iport < 0 || iport > UINT16_MAX) {+      ELOG(""Invalid port: %s"", port);+      return UV_EINVAL;     }-  } -  if (tcp) {-    // Try to parse ip address-    if (uv_ip4_addr(ip, port, &watcher->uv.tcp.addr)) {-      // Invalid address, treat as named pipe or unix socket-      tcp = false;+    *host_end = '\0';+    uv_getaddrinfo_t request;++    int retval = uv_getaddrinfo(&loop->uv, &request, NULL, addr, port,+                                &(struct addrinfo){+                                  .ai_family = AF_UNSPEC,+                                  .ai_socktype = SOCK_STREAM,+                                });+    *host_end = ':';","Even if it makes the code longer? Because we need to keep the `host_end` in any case:```cchar *host_end = strrchr(addr, ':');if (host_end) {  ptrdiff_t sepoff = host_end - addr;  ...  addr[sepoff] = '\0'```Something like that? Is that better?",
1585463,bohrshaw,https://api.github.com/repos/neovim/neovim/pulls/6549,117647821,2017-05-22T00:38:16Z,test/functional/legacy/045_folding_spec.lua,"@@ -190,6 +190,17 @@ describe('folding', function()       0]])   end) +  it(""Regression #6549"", function()+    feed_command('let g:markdown_folding = 1')+    feed_command('term top')+    feed_command('e 045_test_data.md')",`e + 045_test_data.md` may work.,
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/6789,117859982,2017-05-22T22:29:15Z,src/nvim/api/vim.c,"@@ -299,7 +299,7 @@ ArrayOf(String) nvim_list_runtime_paths(void)     FUNC_API_SINCE(1) {   Array rv = ARRAY_DICT_INIT;-  uint8_t *rtp = p_rtp;+  char_u *rtp = p_rtp;","I was already commenting this. `uint8_t`��is 8-bit unsigned *number*. `char_u` is an unsigned *character*. It is deprecated, but not in a sense ���you should replace char_u with uint8_t���, it is to be replaced by ���char���, with a few exceptions where a number was actually meant and not a character.",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/6789,118029953,2017-05-23T15:45:13Z,test/functional/lua/overrides_spec.lua,"@@ -173,3 +176,116 @@ describe('debug.debug', function()     ]])   end) end)++describe('package.path/package.cpath', function()+  local as = alter_slashes++  local function get_new_paths(sufs, runtimepaths)+    runtimepaths = runtimepaths or meths.list_runtime_paths()+    local new_paths = {}+    for _, v in ipairs(runtimepaths) do+      for _, suf in ipairs(sufs) do+        new_paths[#new_paths + 1] = v .. suf:sub(1, 1) .. 'lua' .. suf+      end+    end+    return new_paths+  end+  local function execute_lua(cmd, ...)+    return meths.execute_lua(cmd, {...})+  end+  local function eval_lua(expr, ...)+    return meths.execute_lua('return ' .. expr, {...})+  end+  local function set_path(which, value)+    return execute_lua('package[select(1, ...)] = select(2, ...)', which, value)+  end++  it('contains directories from &runtimepath on first invocation', function()+    local new_paths = get_new_paths(as{'/?.lua', '/?/init.lua'})+    local new_paths_str = table.concat(new_paths, ';')+    eq(new_paths_str, eval_lua('package.path'):sub(1, #new_paths_str))++    local new_cpaths = get_new_paths(iswin() and {'\\?.dll'} or {'/?.so'})+    local new_cpaths_str = table.concat(new_cpaths, ';')+    eq(new_cpaths_str, eval_lua('package.cpath'):sub(1, #new_cpaths_str))+  end)+  it('puts directories from &runtimepath always at the start', function()+    meths.set_option('runtimepath', 'a,b')+    local new_paths = get_new_paths(as{'/?.lua', '/?/init.lua'}, {'a', 'b'})+    local new_paths_str = table.concat(new_paths, ';')+    eq(new_paths_str, eval_lua('package.path'):sub(1, #new_paths_str))++    set_path('path', as'foo/?.lua;foo/?/init.lua;' .. new_paths_str)","I figured it would look nicer if I pretended it is something like string/table literal prefix (similar to e.g. `L""foo""` for `const wchar_t*`) and not a function call.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/6791,118106409,2017-05-23T21:05:04Z,test/functional/eval/null_spec.lua,"@@ -60,7 +60,7 @@ describe('NULL', function()     -- FIXME should be accepted by writefile(), return {0, {}}     null_expr_test('is accepted as an empty list by writefile()',                         ('[writefile(L, ""%s""), readfile(""%s"")]'):format(tmpfname, tmpfname),-                        'E484: Can\'t open file ' .. tmpfname, {0, {}})+                        'E484: Cannot open file ' .. tmpfname, {0, {}})","We need to fix that, but in the meantime this change needs to be removed from this PR.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/6236,118166335,2017-05-24T05:42:55Z,src/nvim/api/buffer.c,"@@ -453,6 +453,26 @@ Integer nvim_buf_get_changedtick(Buffer buffer, Error *err)   return buf->b_changedtick; } +/// Get a list of dictionaries describing buffer-local mappings+/// Note that the buffer key in the dictionary will represent the buffer+/// handle where the mapping is present+///+/// @param  mode  The abbreviation for the mode+/// @param  buffer_id  Buffer handle+/// @param[out]  err   Error details, if any+/// @returns An array of maparg() like dictionaries describing mappings+ArrayOf(Dictionary) nvim_buf_get_keymap(Buffer buffer, String mode, Error *err)+  FUNC_API_SINCE(3)",4 spaces  (and similarly below),
4079454,AdnoC,https://api.github.com/repos/neovim/neovim/pulls/4700,118436087,2017-05-25T07:52:24Z,src/nvim/ops.c,"@@ -5732,3 +5738,19 @@ const yankreg_T *op_register_get(const char name)   }   return &y_regs[i]; }++/// Set the previous yank register+///+/// @param[in]  name  Register name.+///+/// @return true on success, false on failure.+bool op_register_set_previous(const char name)","If we warn on unused result, would it be a good idea to print an error message if it fails? I made it return a bool mainly for the sake of completeness.",
189413,aktau,https://api.github.com/repos/neovim/neovim/pulls/6789,118477219,2017-05-25T12:42:39Z,src/nvim/lua/vim.lua,"@@ -1,2 +1,62 @@ -- TODO(ZyX-I): Create compatibility layer.-return {}+--{{{1 package.path updater function+-- Last inserted paths. Used to clear out items from package.[c]path when they+-- are no longer in &runtimepath.+local last_nvim_paths = {}+local function _update_package_paths()+  local new_last_nvim_paths = {}+  local rtps = vim.api.nvim_list_runtime_paths()+  for _, key in ipairs({'path', 'cpath'}) do+    local orig_str = package[key] .. ';'+    local pathtrails = {}+    local pathtrails_ordered = {}+    local orig = {}+    local orig_paths = {}+    -- Note: ignores trailing item without trailing `;`. Not using something+    -- simpler in order to preserve empty items (stand for default path).+    for s in orig_str:gmatch('[^;]*;') do+      s = s:sub(1, -2)  -- Strip trailing semicolon+      orig[#orig + 1] = s+      orig_paths[s] = true+      -- Find out path patterns. pathtrail should contain something like+      -- /?.so, /?/init.lua, /?.lua. This allows not to bother determining what+      -- correct suffixes are.+      local pathtrail = s:match('[/\\][^/\\]*%?.*$')+      if pathtrail and not pathtrails[pathtrail] then+        pathtrails[pathtrail] = pathtrail:sub(1, 1)+        pathtrails_ordered[#pathtrails_ordered + 1] = pathtrail+      end+    end+    local new = {}+    for _, rtp in ipairs(rtps) do+      if not rtp:match(';') then+        for _, pathtrail in pairs(pathtrails_ordered) do+          local sep = pathtrails[pathtrail]","Just realized, this is per-path. Is it possible to have different types of path separators in the same `[c]path` list?",
189413,aktau,https://api.github.com/repos/neovim/neovim/pulls/6789,118479522,2017-05-25T12:57:12Z,src/nvim/lua/vim.lua,"@@ -1,2 +1,62 @@ -- TODO(ZyX-I): Create compatibility layer.-return {}+--{{{1 package.path updater function+-- Last inserted paths. Used to clear out items from package.[c]path when they+-- are no longer in &runtimepath.+local last_nvim_paths = {}+local function _update_package_paths()+  local new_last_nvim_paths = {}+  local rtps = vim.api.nvim_list_runtime_paths()+  for _, key in ipairs({'path', 'cpath'}) do+    local orig_str = package[key] .. ';'+    local pathtrails = {}+    local pathtrails_ordered = {}+    local orig = {}+    local orig_paths = {}+    -- Note: ignores trailing item without trailing `;`. Not using something+    -- simpler in order to preserve empty items (stand for default path).+    for s in orig_str:gmatch('[^;]*;') do+      s = s:sub(1, -2)  -- Strip trailing semicolon+      orig[#orig + 1] = s+      orig_paths[s] = true+      -- Find out path patterns. pathtrail should contain something like+      -- /?.so, /?/init.lua, /?.lua. This allows not to bother determining what+      -- correct suffixes are.+      local pathtrail = s:match('[/\\][^/\\]*%?.*$')+      if pathtrail and not pathtrails[pathtrail] then+        pathtrails[pathtrail] = pathtrail:sub(1, 1)","Nevermind, I see you're using pathtrails as a membership tester (to deduplicate trailers), too.",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/6789,118479874,2017-05-25T12:59:17Z,src/nvim/lua/vim.lua,"@@ -1,2 +1,62 @@ -- TODO(ZyX-I): Create compatibility layer.-return {}+--{{{1 package.path updater function+-- Last inserted paths. Used to clear out items from package.[c]path when they+-- are no longer in &runtimepath.+local last_nvim_paths = {}+local function _update_package_paths()+  local new_last_nvim_paths = {}+  local rtps = vim.api.nvim_list_runtime_paths()+  for _, key in ipairs({'path', 'cpath'}) do+    local orig_str = package[key] .. ';'+    local pathtrails = {}+    local pathtrails_ordered = {}+    local orig = {}+    local orig_paths = {}","Leftover from some of the previous implementations: specifically before I decided to have```        -- Additionally keep paths from &runtimepath at the start:        -- unconditionally add them above, do not add them here.        cur_nvim_paths[orig_path]```and keep previous order.That was decided because if you reorder &runtimepath previous code would not reorder `package.[c]path`.",
189413,aktau,https://api.github.com/repos/neovim/neovim/pulls/6789,118482834,2017-05-25T13:17:14Z,src/nvim/lua/vim.lua,"@@ -22,7 +22,7 @@ local function _update_package_paths()       -- Find out path patterns. pathtrail should contain something like       -- /?.so, /?/init.lua, /?.lua. This allows not to bother determining what       -- correct suffixes are.-      local pathtrail = s:match('[/\\][^/\\]*%?.*$')+      local pathtrail = s:match('[/\\:][^/\\:]*%?.*$')",Wouldn't it be more accurate to build a character class from `path.config:sub(1.1)`?,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/6816,118590179,2017-05-25T21:32:30Z,runtime/doc/vim_diff.txt,"@@ -281,6 +285,19 @@ Nvim does not have special `t_XX` options nor <t_XX> keycodes to configure terminal capabilities. Instead Nvim treats the terminal as any other UI. For example, 'guicursor' sets the terminal cursor style if possible. +								*termcap*+Nvim never uses the termcap database and only uses |terminfo|.  See+|builtin-terms| for what happens on operating systems without a terminfo+database.++						*xterm-8bit* *xterm-8-bit*+Xterm can be run in a mode where it uses true 8-bit CSI.  Supporting this+requires autodetection of whether the terminal is in UTF-8 mode or non-UTF-8+mode, as the 8-bit CSI character has to be written differently in each case.+Vim issues a ""request version"" sequence to the terminal at startup and looks+at how the terminal is sending CSI.  Nvim does not issue such a sequence and+always uses 7-bit control sequences.","We have aspirations to change this :) Though, noting it in vim_diff.txt in the meantime is the right thing to do.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/6816,118593209,2017-05-25T21:49:14Z,src/nvim/tui/tui.c,,"If we're going to ignore the linter here, might as well make it one big line.",
189413,aktau,https://api.github.com/repos/neovim/neovim/pulls/6789,118594427,2017-05-25T21:56:31Z,runtime/doc/if_lua.txt,"@@ -13,14 +13,17 @@ Lua Interface to Nvim					*lua* *Lua*  Neovim lua interface automatically adjusts `package.path` and `package.cpath`  according to effective &runtimepath value.  Adjustment happens after each time -'runtimepath' is changed, `package.path` and `package.cpath` are adjusted by -prepending directories from 'runtimepath' each suffixed by `/lua` and -`?`-containing suffixes from `package.path` and `package.cpath`. I.e. when -'runtimepath' option contains `/foo` and `package.path` contains only -`./?.lua;./a?d/j/g.nlua;/bar/?.lua` the resulting `package.path` after +'runtimepath' is changed. `package.path` is adjusted by simply appending +`/lua/?.lua` and `/lua/?/init.lua` to each directory from 'runtimepath' (`/` +is actually a first character from `package.config`).++`package.cpath` is adjusted by prepending directories from 'runtimepath' each +suffixed by `/lua` and `?`-containing suffixes from existing `package.cpath`. +I.e. when 'runtimepath' option contains `/foo` and `package.cpath` contains +only `./?.so;./a?d/j/g.elf;/bar/?.so` the resulting `package.cpath` after ","I still find this wording hard to parse: `is adjusted by prepending ... each suffixed by ... -containing suffixing from`. This is work for a native English speaker, but I'll give it a shot:```Similarly to `package.path`, modified directories from `runtimepath` are also added to `package.cpath`. In this case, instead of appending `/lua/?.lua` and `/lua/?/init.lua` to each runtimepath, all unique `?`-containing suffixes of the existing `package.cpath` are used. An example explains it better: 1. 'runtimepath' option contains `/foo`2. `package.cpath` is `./?.so;./a?d/j/g.elf;/bar/?.so`, which means the unique `?`-suffixes are `/?.so` (from `./?.so` and `/bar/?.so`) and `/a?d/j/g.elf` (from `./a?d/j/g.elf`). 3. Thus the adjusted `package.cpath` looks like:    /foo/lua/?.so;/foo/lua/a?d/j/g.elf;./?.so;./a?d/j/g.elf;/bar/?.so  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^             runtimepath derived        ^^^^^^^^^^^^^^^^^^^^^^^^^                                                         original package.cpath```I realize this is also in poor shape. I just believe that though the Lua pattern is easy to grok, any text describing it is not. Which is why emphasizing the example is worth a War and Peace IMHO. Any suggestions, @justinmk?",
24855211,jdebp,https://api.github.com/repos/neovim/neovim/pulls/6816,118841341,2017-05-28T13:36:22Z,src/nvim/tui/tui.c,,Are you talking about the  `memcmp` call that is conditional upon a `strlen` test on the line above?,
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/6816,119082787,2017-05-30T12:20:27Z,src/nvim/tui/tui.c,,"My previous comment for this line was misplaced, so perhaps it was overlooked.The equal case could lead to invalid memory access (if there are no additional assumptions made for `fix_normal`). With`strlen(fix_normal)=n``sizeof LINUXRESETC -1 = n+1``strchr(fix_normal,0) = fix_normal+n`we call `memcmp(fix_normal-1, ""..."",n+1)` and are accessing memory in front of string `fix_normal`.So the condition should be`... && (strlen(fix_normal)) >= (sizeof LINUXRESETC - 1) && ...`No need to search for a suffix in a string that is shorter than the suffix.Edit:Looks like the comment was again misplaced. See line tui.c:2569",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/6827,119094789,2017-05-30T13:14:22Z,src/nvim/event/loop.c,"@@ -85,9 +86,18 @@ void loop_close(Loop *loop, bool wait)   uv_close((uv_handle_t *)&loop->children_kill_timer, NULL);   uv_close((uv_handle_t *)&loop->poll_timer, NULL);   uv_close((uv_handle_t *)&loop->async, NULL);-  do {+  uint64_t start = wait ? os_hrtime() : 0;+  while (true) {     uv_run(&loop->uv, wait ? UV_RUN_DEFAULT : UV_RUN_NOWAIT);-  } while (uv_loop_close(&loop->uv) && wait);+    if (!uv_loop_close(&loop->uv) || !wait) {+      break;+    }+    if (os_hrtime() - start >= 2 * 1000000000) {+      // Some libuv resource was not correctly deref'd. Log and bail.+      log_uv_handles(&loop->uv);+      break;+    }","If loop_close takes longer than 2 seconds it is most likely an infinite loop. So, log the state and exit the loop.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/6816,119203815,2017-05-30T20:18:32Z,src/nvim/option.c,"@@ -969,10 +969,12 @@ void set_init_2(bool headless)     p_window = Rows - 1;   }   set_number_default(""window"", Rows - 1);+#if 0 // This bodges around problems that should properly be fixed in the TUI layer.   if (!headless && !os_term_is_nice()) {",Why not adjust os_term_is_nice() in the meantime? Unless you are certain the exceptions there are all accounted for now--then this code should be removed entirely.,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/6816,119206080,2017-05-30T20:28:45Z,src/nvim/tui/tui.c,"@@ -348,50 +370,210 @@ static void update_attrs(UI *ui, HlAttrs attrs)       data->params[1].i = (fg >> 8) & 0xff;   // green       data->params[2].i = fg & 0xff;          // blue       unibi_out(ui, data->unibi_ext.set_rgb_foreground);+      data->default_attr = false;",Instead of repeating this we could set it once:    data->default_attr = !(attrs.bold || ... || fg == -1 || bg == -1);,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/6823,119208204,2017-05-30T20:38:11Z,src/nvim/event/process.c,"@@ -269,15 +273,18 @@ static void children_kill_cb(uv_timer_t *handle)     if (!proc->stopped_time) {       continue;     }-    uint64_t elapsed = now - proc->stopped_time;--    if (!proc->term_sent && elapsed >= TERM_TIMEOUT) {-      ILOG(""Sending SIGTERM to pid %d"", proc->pid);-      uv_kill(proc->pid, SIGTERM);-      proc->term_sent = true;-    } else if (elapsed >= KILL_TIMEOUT) {-      ILOG(""Sending SIGKILL to pid %d"", proc->pid);-      uv_kill(proc->pid, SIGKILL);+    uint64_t elapsed = (now - proc->stopped_time) / 1000000 + 1;","Was it waiting 2s longer, before this change?",
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/6823,119216933,2017-05-30T21:14:39Z,src/nvim/event/process.c,"@@ -269,15 +273,18 @@ static void children_kill_cb(uv_timer_t *handle)     if (!proc->stopped_time) {       continue;     }-    uint64_t elapsed = now - proc->stopped_time;--    if (!proc->term_sent && elapsed >= TERM_TIMEOUT) {-      ILOG(""Sending SIGTERM to pid %d"", proc->pid);-      uv_kill(proc->pid, SIGTERM);-      proc->term_sent = true;-    } else if (elapsed >= KILL_TIMEOUT) {-      ILOG(""Sending SIGKILL to pid %d"", proc->pid);-      uv_kill(proc->pid, SIGKILL);+    uint64_t elapsed = (now - proc->stopped_time) / 1000000 + 1;+    ILOG(""elapsed: %d"", elapsed);++    if (elapsed >= KILL_TIMEOUT_MS) {+      if (!proc->term_sent) {+        ILOG(""Sending SIGTERM to pid %d"", proc->pid);+        uv_kill(proc->pid, SIGTERM);+        proc->term_sent = true;+      } else if (elapsed >= KILL_TIMEOUT_MS * (proc->type == kProcessTypePty)) {","If this condition is checked, it is always true.",
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/6823,119220716,2017-05-30T21:31:20Z,src/nvim/event/process.c,"@@ -269,15 +273,18 @@ static void children_kill_cb(uv_timer_t *handle)     if (!proc->stopped_time) {       continue;     }-    uint64_t elapsed = now - proc->stopped_time;--    if (!proc->term_sent && elapsed >= TERM_TIMEOUT) {-      ILOG(""Sending SIGTERM to pid %d"", proc->pid);-      uv_kill(proc->pid, SIGTERM);-      proc->term_sent = true;-    } else if (elapsed >= KILL_TIMEOUT) {-      ILOG(""Sending SIGKILL to pid %d"", proc->pid);-      uv_kill(proc->pid, SIGKILL);+    uint64_t elapsed = (now - proc->stopped_time) / 1000000 + 1;+    ILOG(""elapsed: %d"", elapsed);++    if (elapsed >= KILL_TIMEOUT_MS) {+      if (!proc->term_sent) {+        ILOG(""Sending SIGTERM to pid %d"", proc->pid);+        uv_kill(proc->pid, SIGTERM);+        proc->term_sent = true;+      } else if (elapsed >= KILL_TIMEOUT_MS * (proc->type == kProcessTypePty)) {","We have already checked in an outer `if` that the condition `elapsed >= KILL_TIMEOUT_MS` is true, so the check here is also true ( `elapsed >= KILL_TIMEOUT_MS * {0/1}`).",
9766,blueyed,https://api.github.com/repos/neovim/neovim/pulls/6823,119221379,2017-05-30T21:34:33Z,src/nvim/event/process.c,"@@ -269,15 +273,18 @@ static void children_kill_cb(uv_timer_t *handle)     if (!proc->stopped_time) {       continue;     }-    uint64_t elapsed = now - proc->stopped_time;--    if (!proc->term_sent && elapsed >= TERM_TIMEOUT) {-      ILOG(""Sending SIGTERM to pid %d"", proc->pid);-      uv_kill(proc->pid, SIGTERM);-      proc->term_sent = true;-    } else if (elapsed >= KILL_TIMEOUT) {-      ILOG(""Sending SIGKILL to pid %d"", proc->pid);-      uv_kill(proc->pid, SIGKILL);+    uint64_t elapsed = (now - proc->stopped_time) / 1000000 + 1;",Yeah.. the condition was always 1ms short.,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/6827,119734795,2017-06-01T21:34:43Z,.travis.yml,"@@ -21,8 +21,6 @@ env:     - INSTALL_PREFIX=""$HOME/nvim-install""     # Log directory for Clang sanitizers and Valgrind.     - LOG_DIR=""$BUILD_DIR/log""-    # Nvim log file.-    - NVIM_LOG_FILE=""$BUILD_DIR/.nvimlog""","@blueyed That's part of the temporary commits, I am puzzled about why travis is failing.",
8740057,janlazo,https://api.github.com/repos/neovim/neovim/pulls/6383,119772357,2017-06-02T02:55:00Z,test/functional/terminal/scrollback_spec.lua,"@@ -416,7 +438,11 @@ describe(""'scrollback' option"", function()     -- Terminal job data is received asynchronously, may happen before the     -- 'scrollback' option is synchronized with the internal sb_buffer.     command('sleep 100m')-    feed_data('for i in $(seq 1 40); do echo ""line$i""; done\n')+    if iswin() then+      feed_data('for($i=1;$i -le 40;$i++){Write-Host \""line$i\""}\r')","Got [13, 96, 114].Get the char codes of carriage return, shell-specific escape character(s), and character(s) following them to resolve character combinations, such as `` `n ``, for terminal buffer.Unrelated but, is something similar done on cmd.exe for linefeeds?",
566993,alexgenco,https://api.github.com/repos/neovim/neovim/pulls/6841,120138355,2017-06-05T15:43:50Z,runtime/autoload/provider/ruby.vim,"@@ -16,23 +16,27 @@ function! s:job_opts.on_stderr(chan_id, data, event) endfunction  function! provider#ruby#Detect() abort-  return exepath('neovim-ruby-host')+  if exists(""g:ruby_host_prog"")+    return g:ruby_host_prog+  else+    return exepath('neovim-ruby-host')+  end endfunction  function! provider#ruby#Prog()   return s:prog endfunction  function! provider#ruby#Require(host) abort-  let args = [provider#ruby#Prog()]+  let prog = provider#ruby#Prog()   let ruby_plugins = remote#host#PluginsForHost(a:host.name)    for plugin in ruby_plugins-    call add(args, plugin.path)+    let prog .= "" "" . shellescape(plugin.path)","I want to support arbitrary commands in `g:ruby_host_prog`, not just executables, and my understanding was calling `jobstart` with a string rather than a list gives you e.g. `bash -c '...'` execution. Is there a better way to support this?",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/6856,120761712,2017-06-07T22:32:38Z,runtime/lua/json.lua,"@@ -0,0 +1,383 @@+--+-- json.lua","You are using `luv` to fork out different Neovim threads? I do not think this is a good idea, most of the code does not expect this and making sure that different shared resources (memory, file descriptors except for a small subset, etc) are not accessed through spawned threads is close to impossible. Generally: until there are Neovim own functions for creating threads or `fork()`ing don���t do this in core plugins, it risks producing nasty heizenbugs.---As to the question, though not exactly API, but JSON decoder could be easily edited to work with lua natively: most of code is parsing there, just need to abstract away creation of values (I would personally go with creating `jsondecode.c.h` macros-parametrized file for this purpose, should also be possible to do abstraction via `struct` with function references). Encoder is a separate issue, the ���easy��� way is to not touch it at all, but create duplicate lua -> VimL conversion functions which are exactly like existing ones, but do not put allocated lists and dictionaries into M&S GC double-linked list. In both cases you will spend more time creating the tests then adjusting the code.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/6856,120902961,2017-06-08T14:27:40Z,runtime/lua/json.lua,"@@ -0,0 +1,383 @@+--+-- json.lua","Luv won't spawn threads, but it can run callbacks at times which are not considered vimL-safe, though as long as GC won't be invoked in such a time (potentially, rooting might be incomplete), json_decode shouldn't be a problem.",
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/6844,120931162,2017-06-08T16:07:51Z,src/nvim/eval.c,"@@ -5138,8 +5112,8 @@ bool garbage_collect(bool testing)    // Jobs   {-    TerminalJobData *data;-    map_foreach_value(jobs, data, {+    Channel *data;+    map_foreach_value(channels, data, {       set_ref_in_callback(&data->on_stdout, copyID, NULL, NULL);","Missing cast `(Callback *)` to hide `-Wincompatible_pointer_types` warning for first argument. Perhaps also add somewhere a `static_assert` to make sure that the `Callback` object is the first member in `CallbackReader`:```c #include ""nvim/assert.h""#include <stddef.h>STATIC_ASSERT(offsetof(CallbackReader,cb)== 0,""..."");```",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/6856,120933016,2017-06-08T16:15:12Z,runtime/lua/json.lua,"@@ -0,0 +1,383 @@+--+-- json.lua","@bfredl Container allocation functions are not reentrant because they alter a linked list in a number of steps. So it is not safe to call callbacks at random times even without GC run (how, BTW? I do not know how uv is going to perform async read at unsafe time without either using SIGALARM (should probably mess up with our timers), or a separate thread, or a separate process), unless you edit C code of the parser to work with lua containers.Why not use existing jobs in any case, this is going to be safe for sure? Just have a lambda which immediately calls lua.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/6844,120936461,2017-06-08T16:29:58Z,src/nvim/event/process.h,"@@ -43,9 +45,9 @@ static inline Process process_init(Loop *loop, ProcessType type, void *data)     .stopped_time = 0,     .cwd = NULL,     .argv = NULL,-    .in = NULL,-    .out = NULL,-    .err = NULL,+    .in = {0},","Strange that clang complains, `{0}` is a standard pattern and it's used elsewhere without complaints.",
112971,jamessan,https://api.github.com/repos/neovim/neovim/pulls/6855,121193129,2017-06-09T18:27:06Z,src/nvim/ops.c,"@@ -3644,6 +3644,10 @@ int do_join(size_t count,    */   for (t = (linenr_T)count - 1;; t--) {     cend -= currsize;+	if(cend == NULL || curr == NULL){","Please see [CONTRIBUTING.md](https://github.com/neovim/neovim/blob/master/CONTRIBUTING.md) for explanations about that.However, given that you didn't have any conflicts with master, I'm not sure why you were trying a rebase or merge.  If there's no need to do either of those, then don't bother.",
6589866,brcolow,https://api.github.com/repos/neovim/neovim/pulls/6844,121274631,2017-06-11T07:53:05Z,runtime/doc/channels.txt,"@@ -0,0 +1,91 @@+*channel.txt*    Nvim+++		 NVIM REFERENCE MANUAL    by Thiago de Arruda+++Nvim's facilities for async io				  *channels*++				      Type <M-]> to see the table of contents.++==============================================================================+1. Introduction						    *channels-intro*++Channels are nvim's way of communicating with external processes.++There are several ways to open a channel:++  1. Through stdin/stdout when `nvim` is started with `--headless`, and a startup+     script or --cmd  commad opens the stdio channel using |stdioopen()|.++  2. Through stdin, stdout and stderr of a process spawned by |jobstart()|.++  3. Through the PTY master end of a PTY opened with+     `jobstart(..., {'pty': v:true})` or |termopen()|.++  4. By connecting to a TCP/IP socket or named pipe with |sockconnect()|.++  5. By another process connecting to a socket listened by nvim. This only",socket listened by => socket listened to by,
6589866,brcolow,https://api.github.com/repos/neovim/neovim/pulls/6844,121274773,2017-06-11T07:58:57Z,runtime/doc/channels.txt,"@@ -0,0 +1,91 @@+*channel.txt*    Nvim+++		 NVIM REFERENCE MANUAL    by Thiago de Arruda+++Nvim's facilities for async io				  *channels*++				      Type <M-]> to see the table of contents.++==============================================================================+1. Introduction						    *channels-intro*++Channels are nvim's way of communicating with external processes.++There are several ways to open a channel:++  1. Through stdin/stdout when `nvim` is started with `--headless`, and a startup+     script or --cmd  commad opens the stdio channel using |stdioopen()|.++  2. Through stdin, stdout and stderr of a process spawned by |jobstart()|.++  3. Through the PTY master end of a PTY opened with+     `jobstart(..., {'pty': v:true})` or |termopen()|.++  4. By connecting to a TCP/IP socket or named pipe with |sockconnect()|.++  5. By another process connecting to a socket listened by nvim. This only+     supports RPC channels, see |rpc-connecting|.++Channels can operate in two different modes, a mode using the |rpc| protocol,","I would re-organize to:Channels can operate in two modes: one via the |rpc| protocol (msgpack-rpcbased) and the other in ""bytes"" mode where scripts read and write raw bytesover the channel. As a caveat even if a job's channel is in |rpc| mode, bytes can stillbe read over its' stderr.  Additionally only bytes can be written to nvim's stderr.(Honestly it doesn't make a big difference either way, feel completely free to rejectthis suggestion).Edit: Is it possible to link to the next section after mentioning ""bytes"" mode?Or is that too much?",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/6532,122131639,2017-06-15T06:59:02Z,src/nvim/state.c,"@@ -41,6 +42,7 @@ void state_enter(VimState *s)     } else {       input_enable_events();       // Flush screen updates before blocking",Comment is misplaced,
9766,blueyed,https://api.github.com/repos/neovim/neovim/pulls/6898,122296090,2017-06-15T19:53:15Z,scripts/pvscheck.sh,"@@ -1,12 +1,14 @@-#!/bin/sh+#!/usr/bin/env bash",I see.Should we then use the `foo() {(bar=1)}` pattern instead? (used elsewhere already),
112971,jamessan,https://api.github.com/repos/neovim/neovim/pulls/6898,122573238,2017-06-17T17:31:34Z,scripts/pvscheck.sh,"@@ -1,12 +1,14 @@-#!/bin/sh+#!/usr/bin/env bash set -e # Note: -u causes problems with posh, it barks at ���undefined��� $@ when no # arguments provided. test -z ""$POSH_VERSION"" && set -u  get_jobs_num() {-  local num=""$(cat /proc/cpuinfo | grep -c ""^processor"")""-  num=""$(echo $(( num + 1 )))""+  # TODO: why not only the grep?!",It's typical to use `numcpus + 1` as the number of parallel jobs.,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/6844,122590748,2017-06-18T13:13:17Z,src/nvim/eval.c,"@@ -15509,6 +15451,35 @@ static void f_sort(typval_T *argvars, typval_T *rettv, FunPtr fptr)   do_sort_uniq(argvars, rettv, true); } +/// ""stdioopen()"" function+static void f_stdioopen(typval_T *argvars, typval_T *rettv, FunPtr fptr)","It's not that different, it's opening a channel. We don't need numerous different narrowly-defined functions to open a channel. A `chanopen` function can work like `jobstart`, by taking options that control the behavior. `changet` might be a better name. In general the goal is to avoid mimicking the ad-hoc patterns of legacy unix, and instead do the work of designing an API.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/6566,122628584,2017-06-19T06:30:41Z,src/nvim/api/vim.c,"@@ -704,12 +756,21 @@ void nvim_unsubscribe(uint64_t channel_id, String event)   channel_unsubscribe(channel_id, e); } +/// Translate to integer if \p name is an hex value (e.g. #XXXXXX),+/// else look into \p color_name_table to translate a color name to  its",color_name_table sounds like an internal datastructure. Also the descriptions of `nvim_get_color_map` sounds like they use two different color tables.,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/6030,124150528,2017-06-26T23:58:28Z,runtime/autoload/provider/clipboard.vim,"@@ -46,53 +46,117 @@ function! provider#clipboard#Error() abort   return s:err endfunction +let s:providers = [+      \ {+      \   'name': 'pbcopy/pbpaste',+      \   'copy': {+      \      '+': 'pbcopy',+      \      '*': 'pbcopy',+      \    },+      \   'paste': {+      \      '+': 'pbpaste',+      \      '*': 'pbpaste',+      \   },+      \   'cache_enabled': 0,+      \   'check': 'executable(""pbcopy"")',+      \ },+      \ {+      \   'name': 'xsel',+      \   'copy': {+      \      '+': 'xsel --nodetach -i -b',+      \      '*': 'xsel --nodetach -i -p',+      \    },+      \   'paste': {+      \      '+': 'xsel -o -b',+      \      '*': 'xsel -o -p',+      \   },+      \   'cache_enabled': 1,+      \   'check': 'exists(""$DISPLAY"") && executable(""xsel"") && s:cmd_ok(""xsel -o -b"")',+      \ },+      \ {+      \   'name': 'xclip',+      \   'copy': {+      \      '+': 'xclip -quiet -i -selection clipboard',+      \      '*': 'xclip -quiet -i -selection primary',+      \    },+      \   'paste': {+      \      '+': 'xclip -o -selection clipboard',+      \      '*': 'xclip -o -selection primary',+      \   },+      \   'cache_enabled': 1,+      \   'check': 'exists(""$DISPLAY"") && executable(""xclip"")',+      \ },+      \ {+      \   'name': 'lemonade',+      \   'copy': {+      \      '+': 'lemonade copy',+      \      '*': 'lemonade copy',+      \    },+      \   'paste': {+      \      '+': 'lemonade paste',+      \      '*': 'lemonade paste',+      \   },+      \   'cache_enabled': 1,+      \   'check': 'executable(""lemonade"")',+      \ },+      \ {+      \   'name': 'doitclient',+      \   'copy': {+      \      '+': 'doitclient wclip',+      \      '*': 'doitclient wclip',+      \    },+      \   'paste': {+      \      '+': 'doitclient wclip -r',+      \      '*': 'doitclient wclip -r',+      \   },+      \   'cache_enabled': 1,+      \   'check': 'executable(""doitclient"")',+      \ },+      \ {+      \   'name': 'win32yank',+      \   'copy': {+      \      '+': 'win32yank -i --crlf',+      \      '*': 'win32yank -i --crlf',+      \    },+      \   'paste': {+      \      '+': 'win32yank -i --lf',+      \      '*': 'win32yank -i --lf',+      \   },+      \   'cache_enabled': 1,+      \   'check': 'executable(""win32yank"")',+      \ },+      \ {+      \   'name': 'tmux',+      \   'copy': {+      \      '+': 'tmux load-buffer -',+      \      '*': 'tmux load-buffer -',+      \    },+      \   'paste': {+      \      '+': 'tmux save-buffer -',+      \      '*': 'tmux save-buffer -',+      \   },+      \   'cache_enabled': 1,+      \   'check': 'exists(""$TMUX"") && executable(""tmux"")',+      \ },+      \ ]++function! s:set_provider(p) abort+    let s:copy = a:p.copy+    let s:paste = a:p.paste+    let s:cache_enabled = a:p.cache_enabled+    return a:p.name+endfunction",this isn't actually saving lines since the dictionary definition ends up being 50% bigger. So the churn isn't worth it.,
4466899,tjdevries,https://api.github.com/repos/neovim/neovim/pulls/6856,124416006,2017-06-27T22:49:52Z,runtime/autoload/lsp/request.vim,"@@ -0,0 +1,21 @@+let g:nvim_lsp_client = -1++function! s:get_client() abort+   if g:nvim_lsp_client == -1+      lua << EOF+local client = require('runtime.lua.lsp.client')","Okay, I have removed many of them and rebased, so I can use the updates from #6789 . I will clean up the code as I go along. Still brainstorming a lot of ideas.",
112971,jamessan,https://api.github.com/repos/neovim/neovim/pulls/6936,124902627,2017-06-29T20:19:06Z,scripts/download-unicode-files.sh,"@@ -30,7 +30,7 @@ for filename in $data_files ; do done  for filename in $emoji_files ; do-  curl -o ""$UNIDIR/$filename"" ""$DOWNLOAD_URL_BASE/emoji/3.0/$filename""+  curl -o ""$UNIDIR/$filename"" ""$DOWNLOAD_URL_BASE/emoji/5.0/$filename""","We can use `/emoji/latest/`.  I didn't think that would work, since it's not in the directory listing for `emoji/`, but they use a 302 redirect.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/6844,125160216,2017-07-01T10:38:50Z,src/nvim/event/rstream.c,"@@ -187,6 +188,7 @@ static void read_event(void **argv)   if (stream->read_cb) {     size_t count = (uintptr_t)argv[1];     bool eof = (uintptr_t)argv[2];+    stream->did_eof = eof;     stream->read_cb(stream, stream->buffer, count, stream->cb_data, eof);","it is not the same information. `eof` is part of the data relayed to the callback, it is not an ""extra argument"".  `stream->did_eof` is to avoid sending a superfluous EOF callback in the job cleanup code (which ensures all output callbacks are sent before the exit callback).",
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/6844,125178460,2017-07-02T09:38:36Z,runtime/doc/eval.txt,"@@ -7052,6 +7073,26 @@ sqrt({expr})						*sqrt()* 		""nan"" may be different, it depends on system libraries.  +stdioopen({opts})			 *stdioopen()*+		In a nvim launched with the |--headless| option, this opens+		stdin and stdout as a |channel|. This function can only be+		invoked once per instance. See |channels-stdio| for more+		information and examples. See also |v:stderrchan|++		Returns a |channel| ID. Close the stdio descriptors with |chanclose()|.+		Use |chansend()| to send data stdout, and",missing word: data `to` stdout,
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/6844,125178576,2017-07-02T09:44:36Z,runtime/doc/eval.txt,"@@ -7052,6 +7073,26 @@ sqrt({expr})						*sqrt()* 		""nan"" may be different, it depends on system libraries.  +stdioopen({opts})			 *stdioopen()*+		In a nvim launched with the |--headless| option, this opens+		stdin and stdout as a |channel|. This function can only be+		invoked once per instance. See |channels-stdio| for more+		information and examples. See also |v:stderrchan|++		Returns a |channel| ID. Close the stdio descriptors with |chanclose()|.+		Use |chansend()| to send data stdout, and+		|rpcrequest()| and |rpcnotify()| to communicate with a RPC+		soceket.++		{opts} is a dictionary with these keys:+		  |on_stdio|: callback invoked when stdin is written to.","`sockconnect()` uses `on_data`, should this be used here too? Otherwise `on_stdin`?",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/6844,125179111,2017-07-02T10:13:21Z,runtime/doc/eval.txt,"@@ -7052,6 +7073,26 @@ sqrt({expr})						*sqrt()* 		""nan"" may be different, it depends on system libraries.  +stdioopen({opts})			 *stdioopen()*+		In a nvim launched with the |--headless| option, this opens+		stdin and stdout as a |channel|. This function can only be+		invoked once per instance. See |channels-stdio| for more+		information and examples. See also |v:stderrchan|++		Returns a |channel| ID. Close the stdio descriptors with |chanclose()|.+		Use |chansend()| to send data stdout, and+		|rpcrequest()| and |rpcnotify()| to communicate with a RPC+		soceket.++		{opts} is a dictionary with these keys:+		  |on_stdio|: callback invoked when stdin is written to.+		  rpc      : If set, |msgpack-rpc| will be used to communicate+			     over stdio+		Returns:+		  - The channel ID on success (this is always 1)","Why? the function already returns the value. And one-time callable function signals that the channel is ""owned by"" the one that calls it, stdout is not expected to be used randomly by random plugins (but a fixed number is good for the external embedder's point of view) . But OTOH `v:stderr` tells that the channel ""belongs"" to nvim itself, and could be used by more than one (but it should still be used sparingly). ",
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/6844,125182567,2017-07-02T12:48:33Z,src/nvim/eval.c,"@@ -11537,18 +11474,18 @@ static void f_jobresize(typval_T *argvars, typval_T *rettv, FunPtr fptr)   }  -  TerminalJobData *data = find_job(argvars[0].vval.v_number);+  Channel *data = find_job(argvars[0].vval.v_number, true);   if (!data) {-    EMSG(_(e_invjob));     return;   } -  if (data->proc.uv.process.type != kProcessTypePty) {-    EMSG(_(e_jobnotpty));+  if (data->type != kChannelTypeProc","`find_job()` has already verified that `data->type == kChannelTypeProc`, so this condition could be removed.",
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/6844,125183743,2017-07-02T13:44:43Z,src/nvim/channel.c,"@@ -0,0 +1,598 @@+// This is an open source non-commercial project. Dear PVS-Studio, please check+// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com++#include ""nvim/api/ui.h""+#include ""nvim/channel.h""+#include ""nvim/eval.h""+#include ""nvim/event/socket.h""+#include ""nvim/msgpack_rpc/channel.h""+#include ""nvim/msgpack_rpc/server.h""+#include ""nvim/os/shell.h""+#include ""nvim/path.h""+#include ""nvim/ascii.h""++static bool did_stdio = false;+PMap(uint64_t) *channels = NULL;++/// next free id for a job or rpc channel+/// 1 is reserved for stdio channel+/// 2 is reserved for stderr channel+static uint64_t next_chan_id = CHAN_STDERR+1;+++typedef struct {+  Channel *data;+  Callback *callback;+  const char *type;+  list_T *received;+  int status;+} ChannelEvent;++#ifdef INCLUDE_GENERATED_DECLARATIONS+# include ""channel.c.generated.h""+#endif+/// Teardown the module+void channel_teardown(void)+{+  if (!channels) {+    return;+  }++  Channel *channel;++  map_foreach_value(channels, channel, {+    channel_close(channel->id, kChannelPartAll, NULL);+  });+}++/// Closes a channel+///+/// @param id The channel id+/// @return true if successful, false otherwise+bool channel_close(uint64_t id, ChannelPart part, const char **error)+{+  Channel *channel;+  Process *proc;++  if (!(channel = find_channel(id))) {+    if (id < next_chan_id) {+      // allow double close, even though we can't say what parts was valid.+      return true;+    }+    *error = (const char *)e_invchan;+    return false;+  }++  bool close_main = false;+  if (part == kChannelPartRpc || part == kChannelPartAll) {+    close_main = true;+    if (channel->is_rpc) {+       rpc_close(channel);+    } else if (part == kChannelPartRpc) {+      *error = (const char *)e_invstream;+      return false;+    }+  } else if ((part == kChannelPartStdin || part == kChannelPartStdout)+             && channel->is_rpc) {+        //EMSG(_(""Invalid stream on rpc job, use jobclose(id, 'rpc')""));+    *error = (const char *)e_invstreamrpc;+    return false;+  }++  switch (channel->type) {+    case kChannelTypeSocket:+      if (!close_main) {+        *error = (const char *)e_invstream;+        return false;+      }+      stream_close(&channel->stream.socket, NULL, NULL);+      break;++    case kChannelTypeProc:+      proc = (Process *)&channel->stream.proc;+      if (part == kChannelPartStdin || close_main) {+        process_close_in(proc);+      }+      if (part == kChannelPartStdout || close_main) {+        process_close_out(proc);+      }+      if (part == kChannelPartStderr || part == kChannelPartAll) {+        process_close_err(proc);+      }+      break;++    case kChannelTypeStdio:+      if (part == kChannelPartStdin || close_main) {+        stream_close(&channel->stream.stdio.in, NULL, NULL);+      }+      if (part == kChannelPartStdout || close_main) {+        stream_close(&channel->stream.stdio.out, NULL, NULL);+      }+      if (part == kChannelPartStderr) {+        *error = (const char *)e_invstream;+        return false;+      }+      break;++    case kChannelTypeStderr:+      if (part != kChannelPartAll) {+        return false;+      }+      if (!channel->stream.stderr.closed) {+        channel->stream.stderr.closed = true;+        // Don't close on exit, in case late error messeages+        if (!exiting) {+          fclose(stderr);+        }+        channel_decref(channel);+      }+      break;++    case kChannelTypeInternal:+      if (!close_main) {+        *error = (const char *)e_invstream;+        return false;+      }+      break;+  }++  return true;+}++/// Initializes the module+void channel_init(void)+{+  channels = pmap_new(uint64_t)();+  channel_alloc(kChannelTypeStderr);+  rpc_init();+  remote_ui_init();+}++/// Allocates a channel.+///+/// Channel is allocated with refcount 1, which should be decreased+/// when the underlying stream closes.+static Channel *channel_alloc(ChannelType type)+{+  Channel *chan = xcalloc(1, sizeof(*chan));+  if (type == kChannelTypeStdio) {+    chan->id = CHAN_STDIO;+  } else if (type == kChannelTypeStderr) {+    chan->id = CHAN_STDERR;+  } else {+    chan->id = next_chan_id++;+  }+  chan->events = multiqueue_new_child(main_loop.events);+  chan->refcount = 1;+  chan->type = type;+  pmap_put(uint64_t)(channels, chan->id, chan);+  return chan;+}++void channel_incref(Channel *channel)+{+  channel->refcount++;+}++void channel_decref(Channel *channel)+{+  if (!(--channel->refcount)) {+    multiqueue_put(main_loop.fast_events, free_channel_event, 1, channel);+  }+}++void callback_reader_free(CallbackReader *reader)+{+  callback_free(&reader->cb);+  //FIXME+}++void callback_reader_start(CallbackReader *reader)+{+  if(reader->buffered) {+    ga_init(&reader->buffer, sizeof(char *), 1);+  }+}++static void free_channel_event(void **argv)+{+  Channel *channel = argv[0];+  if (channel->is_rpc) {+    rpc_free(channel);+  }++  callback_reader_free(&channel->on_stdout);+  callback_reader_free(&channel->on_stderr);+  callback_free(&channel->on_exit);++  pmap_del(uint64_t)(channels, channel->id);+  multiqueue_free(channel->events);+  xfree(channel);+}++static void channel_destroy_early(Channel *chan)+{+  if ((chan->id != --next_chan_id)) {+    abort();+  }++  if ((--chan->refcount != 0)) {+    abort();+  }++  free_channel_event((void **)&chan);+}+++static void close_cb(Stream *stream, void *data)+{+  channel_decref(data);+}++Channel *channel_job_start(char **argv, CallbackReader on_stdout,+                           CallbackReader on_stderr, Callback on_exit,+                           bool pty, bool rpc, bool detach, const char *cwd,+                           uint16_t pty_width, uint16_t pty_height,+                           char *pty_name, varnumber_T *status_out)+{+  Channel *chan = channel_alloc(kChannelTypeProc);+  chan->on_stdout = on_stdout;+  chan->on_stderr = on_stderr;+  chan->on_exit = on_exit;+  chan->is_rpc = rpc;++  if (pty) {+    if (detach) {+      EMSG2(_(e_invarg2), ""terminal/pty job cannot be detached"");+      shell_free_argv(argv);+      channel_destroy_early(chan);+      *status_out = 0;+      return NULL;+    }+    chan->stream.pty = pty_process_init(&main_loop, chan);+    if (pty_width > 0) {+      chan->stream.pty.width = pty_width;+    }+    if (pty_height > 0) {+      chan->stream.pty.width = pty_height;+    }+    if (pty_name) {+      chan->stream.pty.term_name = pty_name;+    }+  } else {+    chan->stream.uv = libuv_process_init(&main_loop, chan);+  }++  Process *proc = (Process *)&chan->stream.proc;+  proc->argv = argv;+  proc->cb = channel_process_exit_cb;+  proc->events = chan->events;+  proc->detach = detach;+  proc->cwd = cwd;++  char *cmd = xstrdup(proc->argv[0]);+  bool has_out, has_err;+  if (proc->type == kProcessTypePty) {+    has_out = true;+    has_err = false;+  } else {+    has_out = chan->is_rpc || callback_reader_set(chan->on_stdout);+    has_err = callback_reader_set(chan->on_stderr);+  }+  int status = process_spawn(proc, true, has_out, has_err);+  if (status) {+    EMSG3(_(e_jobspawn), os_strerror(status), cmd);+    xfree(cmd);+    if (proc->type == kProcessTypePty) {+      xfree(chan->stream.pty.term_name);+    }+    channel_destroy_early(chan);+    *status_out = proc->status;+    return NULL;+  }+  xfree(cmd);++  if (chan->is_rpc) {+    // the rpc takes over the in and out streams+    rpc_start(chan);+  } else {+    wstream_init(&proc->in, 0);+    if (has_out) {+      callback_reader_start(&chan->on_stdout);+      rstream_init(&proc->out, 0);+      rstream_start(&proc->out, on_job_stdout, chan);+    }+  }++  if (has_err) {+    callback_reader_start(&chan->on_stderr);+    rstream_init(&proc->err, 0);+    rstream_start(&proc->err, on_job_stderr, chan);+  }+  *status_out = (varnumber_T)chan->id;+  return chan;+}+++uint64_t channel_connect(bool tcp, const char *address,+                         bool rpc, CallbackReader on_output,+                         int timeout, const char **error)+{+  // TODO: test mixed mode (server RPC, client bytes)+  if (!tcp && rpc) {+    char *path = fix_fname(address);+    if (server_owns_pipe_address(path)) {+      // avoid deadlock+      xfree(path);+      return channel_create_internal_rpc();+    }+    xfree(path);+  }++  Channel *channel = channel_alloc(kChannelTypeSocket);+  if (!socket_connect(&main_loop, &channel->stream.socket,+                      tcp, address, timeout, error)) {+    channel_destroy_early(channel);+    return 0;+  }++  channel->stream.socket.internal_close_cb = close_cb;+  channel->stream.socket.internal_data = channel;+  if (rpc) {+    rpc_start(channel);+  } else {+    channel->on_stdout = on_output;+    callback_reader_start(&channel->on_stdout);+    wstream_init(&channel->stream.socket, 0);+    rstream_init(&channel->stream.socket, 0);+    rstream_start(&channel->stream.socket, on_socket_output, channel);+  }++  return channel->id;+}++/// Creates an RPC channel from a tcp/pipe socket connection+///+/// @param watcher The SocketWatcher ready to accept the connection+void channel_from_connection(SocketWatcher *watcher)+{+  Channel *channel = channel_alloc(kChannelTypeSocket);+  socket_watcher_accept(watcher, &channel->stream.socket);+  channel->stream.socket.internal_close_cb = close_cb;+  channel->stream.socket.internal_data = channel;+  rpc_start(channel);+}++/// Creates a loopback channel. This is used to avoid deadlock+/// when an instance connects to its own named pipe.+static uint64_t channel_create_internal_rpc(void)+{+  Channel *channel = channel_alloc(kChannelTypeInternal);+  rpc_start(channel);+  return channel->id;+}++/// Creates an API channel from stdin/stdout. This is used when embedding+/// Neovim+uint64_t channel_from_stdio(bool rpc, CallbackReader on_output, const char **error)+{+  if (!headless_mode) {+    *error = _(""Stdio channel can only be opened in headless mode"");+    return 0;+  }++  if (did_stdio) {",`did_stdio` is always `false`. Is setting this variable on the TODO list?,
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/6945,125184852,2017-07-02T14:31:40Z,src/nvim/keymap.c,"@@ -771,7 +771,7 @@ int get_mouse_button(int code, bool *is_click, bool *is_drag) ///                        When cpo_flags contains #FLAG_CPO_BSLASH, a backslash ///                        can be used in place of <C-v>. All other <C-v> ///                        characters are removed.-/// @param[in]  special  If true, always accept <key> notation.+/// @param[in]  special    Replace keycodes, e.g. <CR> becomes a ""\n"" char.","Too many spaces, parameter documentation is not aligned here, it uses two spaces always instead..",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/6958,125523446,2017-07-04T19:39:02Z,src/nvim/shada.c,"@@ -3413,8 +3413,16 @@ static ShaDaReadResult shada_read_next_item(ShaDaReadDef *const sd_reader,     return mru_ret;   } -  const size_t length = (size_t) length_u64;-  entry->timestamp = (Timestamp) timestamp_u64;+  if (length_u64 > PTRDIFF_MAX) {+    emsgf(_(RCERR ""Error while reading ShaDa file: ""+            ""there is an item at position %"" PRIu64 "" ""+            ""that is stated to be too long""),","Why ""is stated to be"" instead of just ""is""? Could be abbreviated without ambiguity:```cemsgf(_(RCERR ""Error while reading ShaDa file: ""        ""item at position %"" PRIu64 "" is too long""),",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/6958,125523668,2017-07-04T19:41:52Z,src/nvim/shada.c,"@@ -3413,8 +3413,16 @@ static ShaDaReadResult shada_read_next_item(ShaDaReadDef *const sd_reader,     return mru_ret;   } -  const size_t length = (size_t) length_u64;-  entry->timestamp = (Timestamp) timestamp_u64;+  if (length_u64 > PTRDIFF_MAX) {+    emsgf(_(RCERR ""Error while reading ShaDa file: ""+            ""there is an item at position %"" PRIu64 "" ""+            ""that is stated to be too long""),","@justinmk Because it is ���stated to be���, you can���t generate such long entry under normal circumstances so most likely the number is wrong for one reason or another (starting from fuzzing output like in the original issue and ending with corrupted FS or trying to use non-ShaDa file).",
177685,lithammer,https://api.github.com/repos/neovim/neovim/pulls/3104,126278120,2017-07-08T08:52:59Z,runtime/autoload/help.vim,"@@ -0,0 +1,40 @@+if exists(""g:loaded_help"")+  finish+endif+let g:loaded_help = 1++function! help#topic() abort","Honestly, I barely know myself since this was blatantly copied from https://github.com/tpope/vim-scriptease/blob/59a73a2415ea1b006ae3e91163ddde24e8540844/autoload/scriptease.vim#L693-L723. Initially this pull request only contained a simple `keywordprg=:help`, but then it was suggested to use vim-scriptease's more intelligent lookup.But in short, this function looks at the word under the cursor (e.g. what syntax group it has), and on the word(s) coming before and after.",
312503,DarkDefender,https://api.github.com/repos/neovim/neovim/pulls/7004,126685569,2017-07-11T13:20:56Z,src/nvim/tui/tui.c,"@@ -1236,18 +1236,6 @@ static int unibi_find_ext_str(unibi_term *ut, const char *name)   return -1; } -static int unibi_find_ext_bool(unibi_term *ut, const char *name)","Ah, nice catch! I removed it mainly because travis was complaing that it was a unused function.Should it still be left in even if nothing uses it?",
6589866,brcolow,https://api.github.com/repos/neovim/neovim/pulls/7017,127367306,2017-07-14T01:11:33Z,runtime/tutor/en/vim-01-beginner.tutor,"@@ -947,8 +947,10 @@ There are many resources online to learn more about vim. Here's a bunch of them: - Vim Video-Tutorials by Derek Wyatt: http://derekwyatt.org/vim/tutorials/ - *Learn Vimscript the Hard Way*: http://learnvimscriptthehardway.stevelosh.com/ - *7 Habits of Effective Text Editing*: http://www.moolenaar.net/habits.html+- *vim-galore*: https://github.com/mhinz/vim-galore -If you prefer a book, *Practival Vim* by Drew Neil is recommended often.+If you prefer a book, *Practival Vim* by Drew Neil is recommended often (and the forthcoming","Practival => Practical (typo). Also I am not sure if it is a forthcoming *version* or *sequel*, no big deal though.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/6997,127585713,2017-07-15T14:45:21Z,src/nvim/tui/tui.c,"@@ -1440,13 +1440,28 @@ static void patch_terminfo_bugs(TUIData *data, const char *term,   // terminfo, is a fixup, not an augmentation.   data->unibi_ext.reset_cursor_style = unibi_find_ext_str(ut, ""Se"");   data->unibi_ext.set_cursor_style = unibi_find_ext_str(ut, ""Ss"");++  // Some terminals can not currently be trusted to report if they support+  // DECSCUSR or not. So we need to have a blacklist for when we should not+  // trust the reported features.+  if( (vte_version != 0 && vte_version < 3900) || konsole ) {+    data->unibi_ext.reset_cursor_style = -1;+    data->unibi_ext.set_cursor_style = -1;+  }   if (-1 == data->unibi_ext.set_cursor_style) {",we set this on line 1442 and then set it again on 1449. Would be clearer if the condition on 1447 guards lines 1441-2 with if/else.,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/6997,127586355,2017-07-15T15:19:27Z,src/nvim/tui/tui.c,"@@ -1440,13 +1440,28 @@ static void patch_terminfo_bugs(TUIData *data, const char *term,   // terminfo, is a fixup, not an augmentation.   data->unibi_ext.reset_cursor_style = unibi_find_ext_str(ut, ""Se"");   data->unibi_ext.set_cursor_style = unibi_find_ext_str(ut, ""Ss"");++  // Some terminals can not currently be trusted to report if they support+  // DECSCUSR or not. So we need to have a blacklist for when we should not+  // trust the reported features.+  if( (vte_version != 0 && vte_version < 3900) || konsole ) {+    data->unibi_ext.reset_cursor_style = -1;+    data->unibi_ext.set_cursor_style = -1;+  }   if (-1 == data->unibi_ext.set_cursor_style) {","Hmm, should it be like this (this is what I meant to suggest):```cif( (vte_version != 0 && vte_version < 3900) || konsole ) {  data->unibi_ext.reset_cursor_style = -1;  data->unibi_ext.set_cursor_style = -1;} else {  data->unibi_ext.reset_cursor_style = unibi_find_ext_str(ut, ""Se"");  data->unibi_ext.set_cursor_style = unibi_find_ext_str(ut, ""Ss"");}if (-1 == data->unibi_ext.set_cursor_style) {...```",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/6997,127586522,2017-07-15T15:29:13Z,src/nvim/tui/tui.c,"@@ -1440,13 +1440,28 @@ static void patch_terminfo_bugs(TUIData *data, const char *term,   // terminfo, is a fixup, not an augmentation.   data->unibi_ext.reset_cursor_style = unibi_find_ext_str(ut, ""Se"");   data->unibi_ext.set_cursor_style = unibi_find_ext_str(ut, ""Ss"");++  // Some terminals can not currently be trusted to report if they support+  // DECSCUSR or not. So we need to have a blacklist for when we should not+  // trust the reported features.+  if( (vte_version != 0 && vte_version < 3900) || konsole ) {+    data->unibi_ext.reset_cursor_style = -1;+    data->unibi_ext.set_cursor_style = -1;+  }   if (-1 == data->unibi_ext.set_cursor_style) {",That would explain why the existing code was checking `if (-1 == data->unibi_ext.set_cursor_style)`.,
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/7030,127586777,2017-07-15T15:43:50Z,src/nvim/CMakeLists.txt,"@@ -526,11 +526,6 @@ endfunction()  set(NO_SINGLE_CHECK_HEADERS   os/win_defs.h","This may be checked on Windows, AFAIR I was suggesting to add this to NO_SINGLE_CHECK_HEADERS depending on the platform condition.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/7030,127586807,2017-07-15T15:46:08Z,src/nvim/regexp_defs.h,"@@ -41,18 +43,38 @@ #define NFA_ENGINE          2  typedef struct regengine regengine_T;+typedef struct regprog regprog_T;+typedef struct reg_extmatch reg_extmatch_T;","Oh, right.Ideally, circular dependencies would be resolved by splitting things up. See @ZyX-I advice in https://github.com/neovim/neovim/issues/5321#issuecomment-292217974 and https://github.com/neovim/neovim/issues/6371tl;dr: What you have posted _works_, so don't change it. But if you are inclined, see if a new header can be introduced to avoid this fragile ordering.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/7028,127604830,2017-07-16T11:33:14Z,runtime/autoload/tutor.vim,"@@ -15,38 +15,28 @@ function! tutor#SetupVim()     endif endfunction -"" Mappings: {{{1--function! s:CheckMaps()-    nmap+"" Loads metadata file, if available+function! tutor#LoadMetadata()+    try+        let b:tutor_metadata = json_decode(join(readfile(expand('%').'.json'), ""\n""))+    catch","why not show an error? what happens if there's a problem?the call to LoadMetadata is guarded by `filereadable()`, also.",
221465,fmoralesc,https://api.github.com/repos/neovim/neovim/pulls/7028,127608298,2017-07-16T14:37:29Z,runtime/autoload/tutor.vim,"@@ -15,38 +15,28 @@ function! tutor#SetupVim()     endif endfunction -"" Mappings: {{{1--function! s:CheckMaps()-    nmap+"" Loads metadata file, if available+function! tutor#LoadMetadata()+    try+        let b:tutor_metadata = json_decode(join(readfile(expand('%').'.json'), ""\n""))+    catch","Failing to load the metadata is not a failure condition, because expect regions (which atm are the only elements defined in the `.json` file, although I considered allowing defining buffer-specific mappings) are optional to the format. At worst, an error loading this will mean that the check marks and highlighting of those regions will not be performed, which is a mere visual glitch. However, as you mention, this will be mainly covered by the `filereadable()` guard, so the only kind of issue one could expect is some error in decoding the json file itself. I think I put the `try` guard in place because the errors that `json_decode` throws are often unhelpful, but I suppose it's better to show them (or a message) anyway in case something goes wrong.I could remove this guard or do something like this:~~~let rjson = join(readfile(expand('%').'.json'), ""\n"")try    let b:tutor_metadata = json_decode(rjson)catch    echom ""tutor: error loading medatada file for tutorial: "". fnamemodify(expand('%'), ':t:r')endtry~~~",
268102,msva,https://api.github.com/repos/neovim/neovim/pulls/6997,127614877,2017-07-16T19:39:47Z,src/nvim/tui/tui.c,"@@ -1268,7 +1268,7 @@ static void patch_terminfo_bugs(TUIData *data, const char *term,   bool teraterm = terminfo_is_term_family(term, ""teraterm"");   bool putty = terminfo_is_term_family(term, ""putty"");   bool screen = terminfo_is_term_family(term, ""screen"");-  bool tmux = terminfo_is_term_family(term, ""tmux"");+  bool tmux = terminfo_is_term_family(term, ""tmux"") || !!os_getenv(""TMUX"");","well, it is no that reliable as it can be thought.It is some cases where users pass `TMUX` variable to shells to avoid some bugs.By the way, there is also `TMUX_PANE` variable, which have lesser chance to be used for such hacks, but it is anyway very bad way to detect because of the said reason ���� ",
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/7045,127951218,2017-07-18T11:43:10Z,src/nvim/eval.c,"@@ -4239,11 +4239,17 @@ static int eval7(         // use its contents.         s = deref_func_name((const char *)s, &len, &partial, !evaluate); +        // Need to make a copy, in case evaluating the arguments makes+        // the name invalid.+        s = vim_strsave(s);","Do we need the whole string or only `len` of it (`s = xmemdupz(s,len);`)? Looks like `s` can point to long strings:```len: 26 strlen(s): 260 s: vimfiler#get_status_string() : &ft == 'unite' ? unite#get_status_string() : &ft == 'vimshell' ? vimshell#get_status_string() : ('' != MyReadonly() ? MyReadonly() . ' ' : '') . ('' != fname ? fname : '[No Name]') . ('' != MyModified() ? ' ' . MyModified() : '')```",
6589866,brcolow,https://api.github.com/repos/neovim/neovim/pulls/6844,128870809,2017-07-21T22:05:54Z,runtime/doc/eval.txt,"@@ -6199,13 +6218,11 @@ rpcstart({prog}[, {argv}])				   {Nvim} *rpcstart()* 			:let id = jobstart(['prog', 'arg1', 'arg2'], {'rpc': v:true})  rpcstop({channel})					    {Nvim} *rpcstop()*-		Closes an |RPC| {channel}.  If the channel is a job-		started with |jobstart()|  the job is killed.-		It is better to use |jobstop()| in this case, or use-		|jobclose|(id, ""rpc"") to only close the channel without-		killing the job.-		Closes the socket connection if the channel was opened by-		connecting to |v:servername|.+		Deprecated. This function stopped a job with RPC channel, and","Very minor issue, but does it make sense to use the past tense for describing what a deprecated function did? Does it still do it?",
6589866,brcolow,https://api.github.com/repos/neovim/neovim/pulls/6844,128871012,2017-07-21T22:07:35Z,runtime/doc/msgpack_rpc.txt,"@@ -61,24 +60,24 @@ To get a formatted dump of the API using python (requires the `pyyaml` and ============================================================================== 3. Connecting						      *rpc-connecting* -There are several ways to open a msgpack-rpc channel to an Nvim instance:+See |channel-intro|, for various ways to open a channel. Most of the channel+opening functions take an `rpc` key in the options dictionary, to enable rpc. -  1. Through stdin/stdout when `nvim` is started with `--embed`. This is how-     applications can embed Nvim.+Additionally, rpc channels can be opened by other processes connecting to+TCP/IP sockets or named pipes listened to by nvim. -  2. Through stdin/stdout of some other process spawned by |jobstart()|.-     Set the ""rpc"" key to |v:true| in the options dict to use the job's stdin-     and stdout as a single msgpack channel that is processed directly by-     Nvim.  Then it is not possible to process raw data to or from the-     process's stdin and stdout. stderr can still be used, though.+An rpc socket is automatically created with each instance. The socket+ location is stored in |v:servername|. By default this is a named pipe+with an autmatically generated adress. See |XXX|. -  3. Through the socket automatically created with each instance. The socket-     location is stored in |v:servername|.--  4. Through a TCP/IP socket. To make Nvim listen on a TCP/IP socket, set the-     |$NVIM_LISTEN_ADDRESS| environment variable before starting Nvim: >+To make Nvim listen on a TCP/IP socket instead, set the+   |$NVIM_LISTEN_ADDRESS| environment variable before starting Nvim: >         NVIM_LISTEN_ADDRESS=127.0.0.1:6666 nvim-<+<Also, more sockets and named pipes can be listened using |serverstart()|.","""listened"" => ""listened on"" or ""listened to"" ?",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/7048,128905666,2017-07-22T21:42:28Z,src/nvim/eval.c,"@@ -15140,8 +15140,11 @@ static void f_sockconnect(typval_T *argvars, typval_T *rettv, FunPtr fptr)     return;   } +  snprintf((char *)IObuff, sizeof(IObuff), ""%s:%"" PRIdLINENR,","I intentionally did not want channel module digging around to get this info because (1) it's dependent on when the call is made, (2) the caller decides what ""source"" means (it may not always be a VimL function line:number), (3) channel is lower-level than eval module.",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/6844,128915222,2017-07-23T10:08:29Z,runtime/doc/eval.txt,"@@ -6200,13 +6219,11 @@ rpcstart({prog}[, {argv}])				   {Nvim} *rpcstart()* 			:let id = jobstart(['prog', 'arg1', 'arg2'], {'rpc': v:true})  rpcstop({channel})					    {Nvim} *rpcstop()*-		Closes an |RPC| {channel}.  If the channel is a job-		started with |jobstart()|  the job is killed.-		It is better to use |jobstop()| in this case, or use-		|jobclose|(id, ""rpc"") to only close the channel without-		killing the job.-		Closes the socket connection if the channel was opened by-		connecting to |v:servername|.+		Deprecated. This function was used to stop a job with |rpc|","No matter just past tense or with ���was used to���, with past tense it looks like ���functionality does not work any longer���.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/6844,128915757,2017-07-23T10:34:14Z,runtime/doc/eval.txt,"@@ -6200,13 +6219,11 @@ rpcstart({prog}[, {argv}])				   {Nvim} *rpcstart()* 			:let id = jobstart(['prog', 'arg1', 'arg2'], {'rpc': v:true})  rpcstop({channel})					    {Nvim} *rpcstop()*-		Closes an |RPC| {channel}.  If the channel is a job-		started with |jobstart()|  the job is killed.-		It is better to use |jobstop()| in this case, or use-		|jobclose|(id, ""rpc"") to only close the channel without-		killing the job.-		Closes the socket connection if the channel was opened by-		connecting to |v:servername|.+		Deprecated. This function was used to stop a job with |rpc|","It is backwards compatible so far that old code using rpcstart/rpcstop or calling rpcstop on remotely connected channels still should work as expected, but its semantics is very confusing together with the new channels design: it does something different if the channel happened to be a job or not. So the wording is deliberately somewhat stronger than eg `rpcstart`, which while inconsistent api, will not do anything unexpected when used together with the newer functions.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/7048,128923093,2017-07-23T15:57:57Z,src/nvim/eval.c,"@@ -15140,8 +15140,11 @@ static void f_sockconnect(typval_T *argvars, typval_T *rettv, FunPtr fptr)     return;   } +  snprintf((char *)IObuff, sizeof(IObuff), ""%s:%"" PRIdLINENR,","Not sure how AOP comes in here. I just mean that stack information is natural to be ""dynamically scoped"" (that is, by global state saved/restored in C), rather than making it an argument for every function ever that could want to print a traceback, or just being part of such chain. This would make it simpler in the future to implement rich tracebacks (covering both vimL, lua and remote indirections) without needing to change ad-hoc logic spread around the codebase.",
112971,jamessan,https://api.github.com/repos/neovim/neovim/pulls/7048,128925260,2017-07-23T17:42:15Z,src/nvim/eval.c,"@@ -15140,8 +15140,11 @@ static void f_sockconnect(typval_T *argvars, typval_T *rettv, FunPtr fptr)     return;   } +  snprintf((char *)IObuff, sizeof(IObuff), ""%s:%"" PRIdLINENR,","We do something [similar](https://github.com/neovim/neovim/blob/d011facf456dc85308cf58b6f0c6a06c4ddd7bb2/src/nvim/eval.c#L8009-L8011) for handling nested `execute()` calls, if I'm correctly understanding the suggestion.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/6322,129172456,2017-07-24T22:35:54Z,runtime/doc/eval.txt,"@@ -5506,6 +5506,66 @@ max({expr})	Return the maximum value of all items in {expr}. 		items in {expr} cannot be used as a Number this results in                 an error.  An empty |List| or |Dictionary| results in zero. +menu_get({path}, {modes})				*menu_get()*+		Returns a |Dictionary| with all the submenu of {path} (set to +		an empty string to match all menus). Only the commands matching {modes} are +		returned ('a' for all, 'i' for insert see |creating-menus|).++    For instance, executing:+<+    nnoremenu &Test.Test inormal+    inoremenu Test.Test insert+    vnoremenu Test.Test x+    echo menu_get("""")+>+should produce an output with a similar structure:+<","I think these `> ... <` pairs are reversed.```    For instance, executing: >     nnoremenu &Test.Test inormal     inoremenu Test.Test insert     vnoremenu Test.Test x     echo menu_get("""")<    should produce an output with a similar structure: >",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/6364,129527586,2017-07-26T09:46:59Z,runtime/doc/eval.txt,"@@ -4723,6 +4724,23 @@ input({opts}) 		more information.  Example: > 			let fname = input(""File: "", """", ""file"") <+		The optional highlight key allows specifying function which +		will be used for highlighting user input.  This function +		receives user input as its only argument and must return +		a list of 3-tuples [hl_start_byte, hl_end_byte + 1, hl_group] +		where+			hl_start_byte is the first highlighted byte,+			hl_end_byte is the last highlighted byte (+ 1!),+			hl_group is |:hl| group used for highlighting.+					      *E5403* *E5404* *E5405* *E5406*+		Both hl_start_byte and hl_end_byte + 1 must point to the start +		of the multibyte character (highlighting must not break +		multibyte characters), hl_end_byte + 1 may be equal to the +		input length.  Start column must be in range [0, len(input)), +		end column must be in range (hl_start_byte, len(input)], ",but is it used elsewhere in the documentation? You write a similar constraint in words below and it doesn't seem to lengthy.,
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/6364,129528781,2017-07-26T09:52:47Z,runtime/doc/eval.txt,"@@ -4723,6 +4724,23 @@ input({opts}) 		more information.  Example: > 			let fname = input(""File: "", """", ""file"") <+		The optional highlight key allows specifying function which +		will be used for highlighting user input.  This function +		receives user input as its only argument and must return +		a list of 3-tuples [hl_start_byte, hl_end_byte + 1, hl_group] +		where+			hl_start_byte is the first highlighted byte,+			hl_end_byte is the last highlighted byte (+ 1!),+			hl_group is |:hl| group used for highlighting.+					      *E5403* *E5404* *E5405* *E5406*+		Both hl_start_byte and hl_end_byte + 1 must point to the start +		of the multibyte character (highlighting must not break +		multibyte characters), hl_end_byte + 1 may be equal to the +		input length.  Start column must be in range [0, len(input)), +		end column must be in range (hl_start_byte, len(input)], ","���Similar constraint��� below is mere ���. And it *is* lengthy: compare ��������� or ���[, +���)��� to ���is greater then or equal to���. Just it is not *too* lengthy and I also do not like writing ���previous {varname}��� in a math expression, it looks bad and not mathy.",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/6364,129529683,2017-07-26T09:57:20Z,src/nvim/api/private/helpers.c,"@@ -37,6 +37,64 @@ typedef struct { # include ""api/private/ui_events_metadata.generated.h"" #endif +/// Start block that may cause VimL exceptions while evaluating another code+///+/// Used when caller is supposed to be operating when other VimL code is being+/// processed and that ���other VimL code��� must not be affected.+///+/// @param[out]  tstate  Location where try state should be saved.+void try_enter(TryState *const tstate)+{+  *tstate = (TryState) {+    .current_exception = current_exception,+    .msg_list = (const struct msglist *const *)msg_list,+    .private_msg_list = NULL,+    .trylevel = trylevel,+    .got_int = got_int,+    .did_throw = did_throw,+    .need_rethrow = need_rethrow,+    .did_emsg = did_emsg,+  };+  msg_list = &tstate->private_msg_list;+  current_exception = NULL;+  trylevel = 1;+  got_int = false;+  did_throw = false;+  need_rethrow = false;+  did_emsg = false;+}++/// End try block, set the error message if any and restore previous state+///+/// @warning Return is consistent with most functions (false on error), not with+///          try_end (true on error).+///+/// @param[in]  tstate  Previous state to restore.+/// @param[out]  err  Location where error should be saved.+///+/// @return false if error occurred, true otherwise.+bool try_leave(const TryState *const tstate, Error *const err)+  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT+{+  const bool ret = !try_end(err);+  assert(trylevel == 0);+  assert(!need_rethrow);+  assert(!got_int);+  assert(!did_throw);+  assert(!did_emsg);+  assert(msg_list == &tstate->private_msg_list);+  assert(*msg_list == NULL);","We will, but if asserts would���ve failed we are getting some kind of ���undefined behaviour��� and not ���leaking memory���: failing assert indicates that code is being based on wrong assumptions. Fixing ���memory leak��� in this case will most likely just introduce another bug instead, like silently ignored exception.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/6364,129536222,2017-07-26T10:30:14Z,src/nvim/api/private/helpers.c,"@@ -37,6 +37,64 @@ typedef struct { # include ""api/private/ui_events_metadata.generated.h"" #endif +/// Start block that may cause VimL exceptions while evaluating another code+///+/// Used when caller is supposed to be operating when other VimL code is being+/// processed and that ���other VimL code��� must not be affected.+///+/// @param[out]  tstate  Location where try state should be saved.+void try_enter(TryState *const tstate)+{+  *tstate = (TryState) {+    .current_exception = current_exception,+    .msg_list = (const struct msglist *const *)msg_list,+    .private_msg_list = NULL,+    .trylevel = trylevel,+    .got_int = got_int,+    .did_throw = did_throw,+    .need_rethrow = need_rethrow,+    .did_emsg = did_emsg,+  };+  msg_list = &tstate->private_msg_list;+  current_exception = NULL;+  trylevel = 1;+  got_int = false;+  did_throw = false;+  need_rethrow = false;+  did_emsg = false;+}++/// End try block, set the error message if any and restore previous state+///+/// @warning Return is consistent with most functions (false on error), not with+///          try_end (true on error).+///+/// @param[in]  tstate  Previous state to restore.+/// @param[out]  err  Location where error should be saved.+///+/// @return false if error occurred, true otherwise.+bool try_leave(const TryState *const tstate, Error *const err)+  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT+{+  const bool ret = !try_end(err);+  assert(trylevel == 0);+  assert(!need_rethrow);+  assert(!got_int);+  assert(!did_throw);+  assert(!did_emsg);+  assert(msg_list == &tstate->private_msg_list);+  assert(*msg_list == NULL);","That's what meant with ""intentional"", we can accept undefined exception state and small memory leak until the code elsewhere is fixed.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/6364,129647810,2017-07-26T17:52:43Z,test/functional/eval/input_spec.lua,"@@ -196,6 +228,19 @@ describe('input()', function()     eq('Vim(call):E118: Too many arguments for function: input',        exc_exec('call input(""prompt> "", ""default"", ""file"", ""extra"")'))   end)+  it('supports highlighting', function()+    feed([[:call input({""highlight"": ""RainBowParens""})<CR>]])+    wait()+    feed('(())')+    wait()","I was referring to the extra `wait()`,  which will not be needed if remove the narrow width issue (make the window wider, or use `command`)I've also noticed that the cmdline redraw logic is not very efficient. We needed some throttling to implement the cursor type switching without overloading the ui protocol serialization with data....",
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/6844,130215966,2017-07-29T07:41:50Z,src/nvim/rbuffer.c,"@@ -121,7 +121,7 @@ char *rbuffer_read_ptr(RBuffer *buf, size_t *read_count) FUNC_ATTR_NONNULL_ALL {   if (!buf->size) {     *read_count = 0;-    return NULL;+    return buf->read_ptr;","Yes, nonzero size still needs to be checked, but some(/all) of the `NULL` checks could be removed. `out_data_append_to_screen()`  could also be changed, because this function is now never called with a `NULL` pointer for `output` (`FUNC_ATTR_NONNULL_ALL`?).",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/7095,130223851,2017-07-29T16:40:51Z,src/nvim/terminal.c,"@@ -465,12 +453,8 @@ static int terminal_execute(VimState *state, int key)       break;      case K_EVENT:-      // We cannot let an event free the terminal yet. It is still needed.-      s->term->refcount++;       multiqueue_process_events(main_loop.events);-      s->term->refcount--;","Sounds good. In the meantime, don't want to overwhelm  @madmax28 with side-jobs. The ASan error reported by @oni-link below is likely related to this, so `refcount` should stay until we make the change you suggest.",
8182046,madmax28,https://api.github.com/repos/neovim/neovim/pulls/7095,130227391,2017-07-29T20:06:48Z,src/nvim/terminal.c,"@@ -465,12 +453,8 @@ static int terminal_execute(VimState *state, int key)       break;      case K_EVENT:-      // We cannot let an event free the terminal yet. It is still needed.-      s->term->refcount++;       multiqueue_process_events(main_loop.events);-      s->term->refcount--;","The only real purpose this ref counter had was to distinguish if `terminal_close()` was called due to a job that exited or the buffer being wiped. Since we now have separate functions for those (`terminal_close()` and `terminal_exit()`), it should be no longer required.",
8182046,madmax28,https://api.github.com/repos/neovim/neovim/pulls/7095,130227671,2017-07-29T20:23:43Z,src/nvim/terminal.c,"@@ -465,12 +453,8 @@ static int terminal_execute(VimState *state, int key)       break;      case K_EVENT:-      // We cannot let an event free the terminal yet. It is still needed.-      s->term->refcount++;       multiqueue_process_events(main_loop.events);-      s->term->refcount--;","I think it's not related to the missing refcount here, but caused by the fact that i deferred freeing terminal and job related data to when the buffer gets wiped, which vim doesn't like when exiting. Working on it, and will then update the PR.",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/6364,130315813,2017-07-31T10:07:09Z,runtime/doc/vim_diff.txt,"@@ -126,7 +126,6 @@ Commands: Functions:   |dictwatcheradd()| notifies a callback whenever a |Dict| is modified   |dictwatcherdel()|-  |execute()| works with |:redir|","Vim has `execute()`, so it can���t be in vim_diff any longer. And in any case implementation has nothing to do with `:redir` except for living near it in some functions.",
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/7095,131495642,2017-08-04T22:04:02Z,src/nvim/eval.c,"@@ -22633,14 +22634,15 @@ static inline void term_delayed_free(void **argv)   term_job_data_decref(j); } +/// Called when the terminal buffer gets wiped while the job is still running static void term_close(void *d) {   TerminalJobData *data = d;   if (!data->exited) {     data->exited = true;","Looks like we are missing here a `term_job_data_decref(data);`.If the terminal job exits first, two calls to `term_job_data_decref()` are made.If the buffer is wiped first, only one call to `term_job_data_decref()` is made, becausethe flag `data->exited` prevents the terminal job callback `eval_job_process_exit()` to call `terminal_exit() -> free_cb()`. ",
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/7095,131527441,2017-08-05T18:44:05Z,src/nvim/terminal.c,"@@ -293,48 +292,49 @@ Terminal *terminal_open(TerminalOptions opts)   return rv; } -void terminal_close(Terminal *term, char *msg)+/// Called when the terminal job dies+void terminal_exit(Terminal *term, char *msg) {-  if (term->closed) {-    return;-  }+  assert(!term->exited);    term->forward_mouse = false;+  if (msg) {+    terminal_receive(term, msg, strlen(msg));+  } -  // flush any pending changes to the buffer   if (!exiting) {+    // flush any pending changes to the buffer     block_autocmds();     refresh_terminal(term);     unblock_autocmds();   } -  buf_T *buf = handle_get_buffer(term->buf_handle);-  term->closed = true;--  if (!msg || exiting) {-    // If no msg was given, this was called by close_buffer(buffer.c).  Or if-    // exiting, we must inform the buffer the terminal no longer exists so that-    // close_buffer() doesn't call this again.-    term->buf_handle = 0;-    if (buf) {-      buf->terminal = NULL;-    }-    if (!term->refcount) {-      // We should not wait for the user to press a key.-      term->opts.close_cb(term->opts.data);-    }-  } else {-    terminal_receive(term, msg, strlen(msg));+  terminal_destroy(term);+}++/// Called when the terminal buffer gets wiped+void terminal_close(Terminal *term)+{+  if (!term->exited) {+    term->opts.close_cb(term->opts.data);+    terminal_destroy(term);   } -  if (buf) {-    apply_autocmds(EVENT_TERMCLOSE, NULL, NULL, false, buf);+  buf_T *buf = handle_get_buffer(term->buf_handle);+  assert(buf);+  buf->terminal = NULL;++  for (size_t i = 0; i < term->sb_current; i++) {+    xfree(term->sb_buffer[i]);   }+  xfree(term->sb_buffer);+  vterm_free(term->vt);+  xfree(term);","The terminal memory is only freed when the buffer is closed. Why not call the ""terminal_destroy"" codefrom `free_term_job_data_event()`? `terminal_close()` then had only to stop the terminal process, the clean up would be triggered by the terminal job callback (refcount == 0). To see if the clean up was already done, one could check `buf->terminal == NULL`. ",
8182046,madmax28,https://api.github.com/repos/neovim/neovim/pulls/7095,131529902,2017-08-05T21:30:05Z,src/nvim/terminal.c,"@@ -293,48 +292,49 @@ Terminal *terminal_open(TerminalOptions opts)   return rv; } -void terminal_close(Terminal *term, char *msg)+/// Called when the terminal job dies+void terminal_exit(Terminal *term, char *msg) {-  if (term->closed) {-    return;-  }+  assert(!term->exited);    term->forward_mouse = false;+  if (msg) {+    terminal_receive(term, msg, strlen(msg));+  } -  // flush any pending changes to the buffer   if (!exiting) {+    // flush any pending changes to the buffer     block_autocmds();     refresh_terminal(term);     unblock_autocmds();   } -  buf_T *buf = handle_get_buffer(term->buf_handle);-  term->closed = true;--  if (!msg || exiting) {-    // If no msg was given, this was called by close_buffer(buffer.c).  Or if-    // exiting, we must inform the buffer the terminal no longer exists so that-    // close_buffer() doesn't call this again.-    term->buf_handle = 0;-    if (buf) {-      buf->terminal = NULL;-    }-    if (!term->refcount) {-      // We should not wait for the user to press a key.-      term->opts.close_cb(term->opts.data);-    }-  } else {-    terminal_receive(term, msg, strlen(msg));+  terminal_destroy(term);+}++/// Called when the terminal buffer gets wiped+void terminal_close(Terminal *term)+{+  if (!term->exited) {+    term->opts.close_cb(term->opts.data);+    terminal_destroy(term);   } -  if (buf) {-    apply_autocmds(EVENT_TERMCLOSE, NULL, NULL, false, buf);+  buf_T *buf = handle_get_buffer(term->buf_handle);+  assert(buf);+  buf->terminal = NULL;++  for (size_t i = 0; i < term->sb_current; i++) {+    xfree(term->sb_buffer[i]);   }+  xfree(term->sb_buffer);+  vterm_free(term->vt);+  xfree(term);","The problem is that the vterm instance and the scrollback buffer must be kept for the lifetime of the buffer. Even after the job died, vim asks for line attributes (`terminal_get_line_attributes`) when redrawing the buffer. That function retrieves data from libvterm on the fly (which in turn uses the scrollback buffer).What we could do is fetch the data from libvterm when the job dies and cache it to be able to free the vterm, but I don't know if that would be preferable.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/6364,131540656,2017-08-06T11:27:44Z,test/functional/eval/input_spec.lua,"@@ -196,6 +228,18 @@ describe('input()', function()     eq('Vim(call):E118: Too many arguments for function: input',        exc_exec('call input(""prompt> "", ""default"", ""file"", ""extra"")'))   end)+  it('supports highlighting', function()+    feed([[:call input({""highlight"": ""RainBowParens""})<CR>]])+    wait()","this wait should still be removed. In any realistic situation, `input()` will be invoked with one call, not with an unrelated event incidentally right after it.",
8182046,madmax28,https://api.github.com/repos/neovim/neovim/pulls/7095,131735169,2017-08-07T18:51:47Z,src/nvim/terminal.c,"@@ -496,37 +495,33 @@ static int terminal_execute(VimState *state, int key) void terminal_destroy(Terminal *term) {   buf_T *buf = handle_get_buffer(term->buf_handle);-  if (buf) {-    term->buf_handle = 0;-    buf->terminal = NULL;-  }+  assert(buf);+  apply_autocmds(EVENT_TERMCLOSE, NULL, NULL, false, buf);","Yes, the documentation is not accurate there. However, if we wait for the job to terminate or get killed, `TermClose` may be triggered after the buffer was wiped, meaning that autocommands are no longer able to access the buffer content. On the other hand, when the job dies but the buffer stays, we still want to generate the event. How would you suggest to go forward with this?",
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/7095,131749801,2017-08-07T20:03:32Z,src/nvim/terminal.c,"@@ -496,37 +495,33 @@ static int terminal_execute(VimState *state, int key) void terminal_destroy(Terminal *term) {   buf_T *buf = handle_get_buffer(term->buf_handle);-  if (buf) {-    term->buf_handle = 0;-    buf->terminal = NULL;-  }+  assert(buf);+  apply_autocmds(EVENT_TERMCLOSE, NULL, NULL, false, buf);","> How would you suggest to go forward with this?Perhaps something like this```c    int status = process_wait((Process *)&data->proc,6000,NULL);```after `process_stop()` in `term_close()`?",
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/6844,132588368,2017-08-10T22:51:15Z,src/nvim/channel.h,"@@ -0,0 +1,135 @@+#ifndef NVIM_CHANNEL_H+#define NVIM_CHANNEL_H++#include ""nvim/main.h""+#include ""nvim/event/socket.h""+#include ""nvim/event/process.h""+#include ""nvim/os/pty_process.h""+#include ""nvim/event/libuv_process.h""+#include ""nvim/eval/typval.h""+#include ""nvim/msgpack_rpc/channel_defs.h""++#define CHAN_STDIO 1+#define CHAN_STDERR 2++#define CHAN_STDIO 1+#define CHAN_STDERR 2",Both defines are duplicates.,
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/6844,132591683,2017-08-10T23:15:40Z,src/nvim/eval.c,"@@ -15151,19 +15067,19 @@ static void f_sockconnect(typval_T *argvars, typval_T *rettv, FunPtr fptr)   }    bool rpc = false;+  CallbackReader on_data = CALLBACK_READER_INIT;   if (argvars[2].v_type == VAR_DICT) {     dict_T *opts = argvars[2].vval.v_dict;     rpc = tv_dict_get_number(opts, ""rpc"") != 0;-  } -  if (!rpc) {-    EMSG2(_(e_invarg2), ""rpc option must be true"");-    return;+    if (!tv_dict_get_callback(opts, S_LEN(""on_data""), &on_data.cb)) {+      return;+    }+    on_data.buffered = tv_dict_get_number(opts, ""data_buffered"");",`data_buffered` is not mentioned in the help for `sockconnect()`,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/7123,132829431,2017-08-12T23:57:58Z,src/nvim/generators/gen_api_dispatch.lua,"@@ -4,43 +4,65 @@ mpack = require('mpack') if arg[1] == '--help' then   print('Usage: genmsgpack.lua args')   print('Args: 1: source directory')-  print('      2: dispatch output file (dispatch_wrappers.generated.h)')-  print('      3: functions metadata output file (funcs_metadata.generated.h)')-  print('      4: API metadata output file (api_metadata.mpack)')-  print('      5: lua C bindings output file (msgpack_lua_c_bindings.generated.c)')+  print('      2: dispatch output file (dispatch_wrappers.generated.c)')+  print('      3: dispatch table output file (dispatch_table.generated.h)')+  print('      4: functions metadata output file (funcs_metadata.generated.h)')+  print('      5: API metadata output file (api_metadata.mpack)')+  print('      6: lua C bindings output file (msgpack_lua_c_bindings.generated.c)')   print('      rest: C files where API functions are defined') end-assert(#arg >= 4)+assert(#arg >= 6) functions = {}  local nvimdir = arg[1]-package.path = nvimdir .. '/?.lua;' .. package.path+package.path = nvimdir .. '/?/init.lua;' .. nvimdir .. '/?.lua;' .. package.path+package.path = nvimdir .. '/../../?.lua;' .. package.path  -- names of all headers relative to the source root (for inclusion in the -- generated file) headers = {}+-- Like `headers`, but without headers ending with .generated.h+local written_headers = {} --- output h file with generated dispatch functions-dispatch_outputf = arg[2]+-- output c file with generated dispatch functions+local dispatch_outputf = arg[2]+-- output h file with generated dispatch table+local dispatch_table_outputf = arg[3] -- output h file with packed metadata-funcs_metadata_outputf = arg[3]+local funcs_metadata_outputf = arg[4] -- output metadata mpack file, for use by other build scripts-mpack_outputf = arg[4]-lua_c_bindings_outputf = arg[5]+local mpack_outputf = arg[5]+-- output c file with lua bindings+local lua_c_bindings_outputf = arg[6]  -- set of function names, used to detect duplicates function_names = {}  c_grammar = require('generators.c_grammar')+local lust = require('generators.lust')+local gperf = require('generators.gperf')+local global_test_helpers = require('test.helpers') --- read each input file, parse and append to the api metadata-for i = 6, #arg do-  local full_path = arg[i]+local dedent = global_test_helpers.dedent+local shallowcopy = global_test_helpers.shallowcopy","@ZyX-I `src/nvim/lib/util.lua` makes the most sense to me. Can break it out in to `src/nvim/lib/{foo,bar}.lua` later if it gets big.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/6364,132854231,2017-08-13T21:45:42Z,runtime/doc/eval.txt,"@@ -4703,6 +4703,7 @@ input({opts}) 		cancelreturn  """"       Same as {cancelreturn} from 		                       |inputdialog()|. Also works with  		                       input().+		highlight     nothing  Highlight handler: |Funcref|.","How often is the handler called? Should mention this somewhere.Typically we prefix VimL handlers with `on_` (Vim does `_cb` suffix). Maybe this should be called `on_input`. But this is not a passive event, it's more of a hook. So maybe it should be called `hl_hook` (emacs has a similar `foo-hook` convention).",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/6364,132854563,2017-08-13T22:02:45Z,runtime/doc/vim_diff.txt,"@@ -147,6 +146,15 @@ Highlight groups:   |hl-TermCursorNC|   |hl-Whitespace| highlights 'listchars' whitespace +UI:+		*E5408* *E5409* *g:Nvim_color_expr* *g:Nvim_color_cmdline*+  UI now supports command-line coloring. Officially only |input()| and +  |inputdialog()| may be colored, temporary for testing purposes expressions +  (e.g. |i_CTRL-R_=|) and regular command-line (|:|) are colored by callbacks +  defined in `g:Nvim_color_expr` and `g:Nvim_color_cmdline` respectively. ","`g:Nvim_` might not be a good convention because `sessionoptions+=globals` will try to store such variables if they are string/num types (doesn't apply here, but as a general convention ...).Since these are temporary and deprecated, perhaps underscore prefix would make sense. `g:_nvim_foo`",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/6844,133853946,2017-08-17T23:37:53Z,runtime/doc/eval.txt,"@@ -6200,13 +6219,11 @@ rpcstart({prog}[, {argv}])				   {Nvim} *rpcstart()* 			:let id = jobstart(['prog', 'arg1', 'arg2'], {'rpc': v:true})  rpcstop({channel})					    {Nvim} *rpcstop()*-		Closes an |RPC| {channel}.  If the channel is a job-		started with |jobstart()|  the job is killed.-		It is better to use |jobstop()| in this case, or use-		|jobclose|(id, ""rpc"") to only close the channel without-		killing the job.-		Closes the socket connection if the channel was opened by-		connecting to |v:servername|.+		Deprecated. This function was used to stop a job with |rpc|",should be moved to deprecated.txt,
886074,teto,https://api.github.com/repos/neovim/neovim/pulls/7202,134309366,2017-08-21T19:22:27Z,src/nvim/eval.c,"@@ -11686,14 +11687,61 @@ static void f_jobstart(typval_T *argvars, typval_T *rettv, FunPtr fptr)         return;       }     }+    dictitem_T *item;+    // or new_env+    item = tv_dict_find(job_opts, S_LEN(""env""));+    ILOG(""Just looked into job_opts"");+    if (item) {+      ILOG(""env passed correctly"");+      if (item->di_tv.v_type != VAR_DICT) {+        EMSG2(_(e_invarg2), ""Expected a dictionary for 'env'"");+        return;+      }+      // TODO add the following in tv_to_argv  ?+      //tv_to_argv(&argvars[0], NULL, &executable);+      size_t count = 0;+      TV_DICT_ITER(item->di_tv.vval.v_dict, var, {+          const char *str = tv_get_string(&var->di_tv);+          count++;+          if (str) {+            ILOG(""key %s"", str);+            if (env == NULL) {+              env = xmalloc((size_t)1);+            } else {+              env = xrealloc(env, count);+            }+            // env[count-1] = xmalloc( (size_t)(STRLEN(di->di_key) + 1 + (STRLEN(str))  ) * sizeof(char_u));+            // int res = sprintf(env[count-1], ""%s=%s"", var->di_key, str));+            // TODO need to escape the var +            // use shell_xescape_xquote ?+            env[count-1] = (char *)concat_str(var->di_key, concat_str((char_u *)""="", (char_u*)(str)));","hum I think you are right. I thought of that because I have failures when running `TEST_FILE=test/functional/core/job_spec.lua TEST_TAG=env make functionaltest`I get```Passed in:(table) {  [1] = 'notification' *[2] = 'stderr'  [3] = {    [1] = 0    [2] = {      [1] = '/bin/zsh: can't open input file: '      [2] = '' } } }Expected:(table) {  [1] = 'notification' *[2] = 'stdout'  [3] = {    [1] = 0    [2] = {      [1] = 'hello world'      [2] = '' } } }```I am not sure why, I tried passing a list instead of a command (e.g., `jobstart(['echo', '$TOTO'], ...` to no avail.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/7201,134358309,2017-08-22T00:02:10Z,src/nvim/main.c,"@@ -1291,15 +1291,22 @@ static void set_window_layout(mparm_T *paramp) static void load_plugins(void) {   if (p_lpl) {+    char_u *rtp_copy = NULL;+     // First add all package directories to 'runtimepath', so that their     // autoload directories can be found.  Only if not done already with a     // :packloadall command.+    // Make a copy of 'runtimepath', so that source_runtime does not use the+    // pack directories.     if (!did_source_packages) {+      rtp_copy = vim_strsave(p_rtp);       add_pack_start_dirs();     } -    source_runtime((char_u *)""plugin/**/*.vim"", DIP_ALL | DIP_NOAFTER);  // NOLINT+    source_in_path(rtp_copy, (char_u *)""plugin/**/*.vim"",  // NOLINT","yes, but isn't it possible that `rtp_copy` is null if the condition on line 1301 is false? Even if it's not possible because of ""action at a distance"", I would tend to prefer the localized guard which removes all doubt.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/7202,134570210,2017-08-22T18:50:56Z,src/nvim/eval.c,"@@ -11686,14 +11691,70 @@ static void f_jobstart(typval_T *argvars, typval_T *rettv, FunPtr fptr)         return;       }     }+    dictitem_T *item;+    // or new_env+    item = tv_dict_find(job_opts, S_LEN(""env""));+    if (item) {+      size_t env_size = 0; // len ?+      size_t i = 0;+      // size_t orig_env_size = 0;+      if (item->di_tv.v_type != VAR_DICT) {+        EMSG2(_(e_invarg2), ""Expected a dictionary for 'env'"");+        return;+      }++      // number of items in dict+      env_size += (size_t)tv_dict_len(item->di_tv.vval.v_dict);+      ILOG(""%d passed env variables"", env_size);++      if (!reset_env) {+        char **environ = os_getfullenv();","Now I get it. Here we actually take action to attempt to _gather_ the full environment and pass it on. That's rather different than what is implied: ""reset_env"" sounds like it takes action to _delete_ an environment that would otherwise be inherited.Something like `include_parent_env` would be better, but too long ... so I'll be quiet.",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/7202,134701357,2017-08-23T09:28:39Z,src/nvim/eval.c,"@@ -11686,14 +11691,70 @@ static void f_jobstart(typval_T *argvars, typval_T *rettv, FunPtr fptr)         return;       }     }+    dictitem_T *item;+    // or new_env+    item = tv_dict_find(job_opts, S_LEN(""env""));+    if (item) {+      size_t env_size = 0; // len ?+      size_t i = 0;+      // size_t orig_env_size = 0;+      if (item->di_tv.v_type != VAR_DICT) {+        EMSG2(_(e_invarg2), ""Expected a dictionary for 'env'"");+        return;+      }++      // number of items in dict+      env_size += (size_t)tv_dict_len(item->di_tv.vval.v_dict);+      ILOG(""%d passed env variables"", env_size);++      if (!reset_env) {+        char **environ = os_getfullenv();+        size_t current_env_size = 0; // = strlen(environ); // strlen excludes null byte+        for (env = environ; *env; env++) {+          current_env_size++;+        }+        ILOG(""current env_len=%d"", current_env_size);+        env_size += current_env_size;+        env = xmalloc( (env_size) * sizeof(char));+        for (;i < current_env_size; i++) {+            env[i] = xstrdup(environ[i]);+            ILOG(""from env: %s (id=%d)"", env[i], i);+        }+      } else {+        // + 1 for last null entry+        env = xmalloc( (env_size + 1) * sizeof(char));+      }+      assert(env);  // env should be allocated here+      ILOG(""total env_len=%d"", env_size);++      // TODO add the following in tv_to_argv  ?+      TV_DICT_ITER(item->di_tv.vval.v_dict, var, {+          // tv_get_string => single buffer vs tv_get_string_buf+          const char *str = tv_get_string(&var->di_tv);+          if (str) {+            size_t len = STRLEN(var->di_key) + strlen(str) + strlen(""="") + 1;+            ILOG(""value #%d: %s"", i, str);+            env[i] = xmallocz(len * sizeof(char));",Remove useless `sizeof(char)`. Or replace with `sizeof(env[0][0])`.,
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/7202,134703019,2017-08-23T09:36:01Z,src/nvim/eval.c,"@@ -11686,14 +11691,70 @@ static void f_jobstart(typval_T *argvars, typval_T *rettv, FunPtr fptr)         return;       }     }+    dictitem_T *item;+    // or new_env+    item = tv_dict_find(job_opts, S_LEN(""env""));+    if (item) {+      size_t env_size = 0; // len ?+      size_t i = 0;+      // size_t orig_env_size = 0;+      if (item->di_tv.v_type != VAR_DICT) {+        EMSG2(_(e_invarg2), ""Expected a dictionary for 'env'"");+        return;+      }++      // number of items in dict+      env_size += (size_t)tv_dict_len(item->di_tv.vval.v_dict);+      ILOG(""%d passed env variables"", env_size);++      if (!reset_env) {+        char **environ = os_getfullenv();+        size_t current_env_size = 0; // = strlen(environ); // strlen excludes null byte+        for (env = environ; *env; env++) {+          current_env_size++;+        }+        ILOG(""current env_len=%d"", current_env_size);+        env_size += current_env_size;+        env = xmalloc( (env_size) * sizeof(char));",Also here are useless parenthesis around `env_size` and space after `(` which should not be present.,
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/7082,134979225,2017-08-24T10:21:15Z,src/nvim/api/vim.c,"@@ -55,6 +56,64 @@ void nvim_command(String command, Error *err)   try_end(err); } +/// Retrieves highlight description from its name+///+/// @param name Highlight group name+/// @return a highlight description e.g. {'bold': true, 'bg': 123, 'fg': 42}+/// @see nvim_get_hl_by_id+Dictionary nvim_get_hl_by_name(String name, Error *err)+  FUNC_API_SINCE(3)+{+  Dictionary result = ARRAY_DICT_INIT;+  int id = syn_name2id((const char_u *)name.data);++  if (id == 0) {+    api_set_error(err, kErrorTypeException, ""Invalid highlight name %s"",+                  name.data);+    return result;+  }+  result = nvim_get_hl_by_id(id, err);+  return result;+}++/// Retrieves highlight description from its id (as returned by hlID())+/// @see nvim_get_hl_by_name+Dictionary nvim_get_hl_by_id(Integer hl_id, Error *err)+  FUNC_API_SINCE(3)+{+  Dictionary dic = ARRAY_DICT_INIT;+  if (syn_get_final_id((int)hl_id) == 0) {+    api_set_error(err, kErrorTypeException, ""Invalid highlight id %d"", hl_id);+    return dic;+  }+  int attrcode = syn_id2attr((int)hl_id);+  return nvim_get_attr(attrcode, err);+}++Dictionary nvim_get_attr(Integer attr_id, Error *err)","I would argue any situation that needs attr combination it should be done nvim side not ui side, with possible exception of ui-managed windows/floats having separate default colors, which can be seen as extension of existing default color management and is much simpler than arbitrary combination",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/6917,135390411,2017-08-26T14:44:52Z,src/nvim/api/ui.c,"@@ -112,6 +114,14 @@ void nvim_ui_attach(uint64_t channel_id, Integer width, Integer height,    pmap_put(uint64_t)(connected_uis, channel_id, ui);   ui_attach_impl(ui);++  if (channel_id <= LONG_MAX) {+    dict_T *dict = get_vim_var_dict(VV_EVENT);+    tv_dict_add_nr(dict, S_LEN(""channel_id""), (long)channel_id);","Shouldn't it include all the other options as well? E.g. `rgb={true,false}` tells listeners if a GUI is attached.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/6917,135390951,2017-08-26T15:12:25Z,src/nvim/api/ui.c,"@@ -112,6 +114,14 @@ void nvim_ui_attach(uint64_t channel_id, Integer width, Integer height,    pmap_put(uint64_t)(connected_uis, channel_id, ui);   ui_attach_impl(ui);++  if (channel_id <= LONG_MAX) {",this seems like an anti-pattern. Better to then add assert at channel/job creation that the number is not larger than VARNUMMER_MAX or what it is called.,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/7082,135391555,2017-08-26T15:46:52Z,src/nvim/ui.c,"@@ -166,6 +166,115 @@ void ui_event(char *name, Array args)   } } +/// Retrieves attribute description from its id+///+/// @param attr_id attribute id+Dictionary get_attr_by_id(Integer attr_id, Error *err)","these new functions are in the UI module but don't have a `ui_` prefix. If they really belong there then they should have that prefix. Not sure if they do belong there though, `hl_` prefix might be better.",
886074,teto,https://api.github.com/repos/neovim/neovim/pulls/7082,135421161,2017-08-27T21:02:49Z,test/functional/api/highlight_spec.lua,"@@ -0,0 +1,60 @@++local helpers = require('test.functional.helpers')(after_each)+local clear, nvim = helpers.clear, helpers.nvim+local Screen = require('test.functional.ui.screen')+local eq, eval = helpers.eq, helpers.eval+local command = helpers.command+local ok = helpers.ok+local meths = helpers.meths+++describe('highlight api',function()+  local expected_rgb = { background = Screen.colors.Yellow,+                          foreground = Screen.colors.Red,+                          special = Screen.colors.Blue,+                          bold = true,+                        }++  local expected_cterm = { background = 10,+                          underline = true,+                        }++  before_each(function()+    clear()+    command(""hi NewHighlight cterm=underline ctermbg=green guifg=red guibg=yellow guisp=blue gui=bold"")+  end)++  it(""nvim_get_hl_by_id"", function()+    local hl_id = eval(""hlID('NewHighlight')"")++    eq(expected_cterm, nvim(""get_hl_by_id"", hl_id))++    command('set termguicolors')+    hl_id = eval(""hlID('NewHighlight')"")+    eq(expected_rgb, nvim(""get_hl_by_id"", hl_id))++    -- assume there is no hl with id 30000+    local err, emsg = pcall(meths.get_hl_by_id, 30000)+    eq(false, err)+    ok(string.find(emsg, 'Invalid highlight id') ~= nil)+  end)++  it(""nvim_get_hl_by_name"", function()+    local expected_normal = { background = Screen.colors.Yellow,+                          foreground = Screen.colors.Red }++    -- test ""Normal"" hl defaults+    eq({}, nvim(""get_hl_by_name"", 'Normal'))++    eq(expected_cterm, nvim(""get_hl_by_name"", 'NewHighlight'))+    command('set termguicolors')","surely we have to be able to convey RGB and non-RGB values through the API, if only to support other TUIs. Do you suggest nvim_get_hl_by_name rely on https://github.com/neovim/neovim/blob/master/src/nvim/api/ui.c#L71 rather than termguicolors or should I change the prototype `nvim_get_hl_by_name (String hl_name, Boolean rgb)` to prevent interference from nvim configuration ?",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/7224,135975891,2017-08-30T05:51:34Z,src/nvim/ex_cmds.c,"@@ -3333,9 +3333,16 @@ static buf_T *do_sub(exarg_T *eap, proftime_T timeout)    // Check for a match on each line.   linenr_T line2 = eap->line2;+  // Condition: If preview, then go on if one of the following holds:+  // * EITHER we don't yet have enough matches for the preview window+  //    matched_lines.size < (size_t)p_cwh+  // * OR we're not yet done looking through the lines shown in the+  //   curren window+  //     lnum <= curwin->w_botline",Could that part of the condition be stored in a local variable?,
4117685,KillTheMule,https://api.github.com/repos/neovim/neovim/pulls/7224,135980870,2017-08-30T06:32:46Z,src/nvim/ex_cmds.c,"@@ -3333,9 +3333,16 @@ static buf_T *do_sub(exarg_T *eap, proftime_T timeout)    // Check for a match on each line.   linenr_T line2 = eap->line2;+  // Condition: If preview, then go on if one of the following holds:+  // * EITHER we don't yet have enough matches for the preview window+  //    matched_lines.size < (size_t)p_cwh+  // * OR we're not yet done looking through the lines shown in the+  //   curren window+  //     lnum <= curwin->w_botline","Wait, sorry, I did not yet have my 2 mugs of coffee. That condition contains `lnum` which is the running variable of the loop, it changes on every iteration.We _could_ save `curwin->w_botline - lnum` in a variable `to_bot`, and then compare `lnum - eap->line1` to `to_bot`. Would that be better? Note that lnum is sometimes changed inside the loop itself, so we could not just increment another variable instead of comparing to `lnum - eap->line1`. Otoh, we can save `eap->line1` in a local variable.So this would become something like```C  linenr_T line1 = eap->line1;  linenr_T to_bot = curwin->w_botline - line1;  for (linenr_T lnum = line1;       lnum <= line2 && !got_quit && !aborting()       && (!preview || matched_lines.size < (size_t)p_cwh           || lnum - line1 <= to_bot);       lnum++) ```where we'd need something to account for possible negativity of `to_bot`. Is that worthwile, shall I pursue?",
4117685,KillTheMule,https://api.github.com/repos/neovim/neovim/pulls/7224,135999600,2017-08-30T08:16:56Z,src/nvim/ex_cmds.c,"@@ -3333,9 +3333,16 @@ static buf_T *do_sub(exarg_T *eap, proftime_T timeout)    // Check for a match on each line.   linenr_T line2 = eap->line2;+  // Condition: If preview, then go on if one of the following holds:+  // * EITHER we don't yet have enough matches for the preview window+  //    matched_lines.size < (size_t)p_cwh+  // * OR we're not yet done looking through the lines shown in the+  //   curren window+  //     lnum <= curwin->w_botline",We could put an `if (...) break;` at the top of the loop body to cut down the condition size. Sounds like pretty bad practice to me though.,
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/6619,136696287,2017-09-02T13:53:13Z,src/nvim/screen.c,"@@ -419,18 +419,29 @@ void update_screen(int type)    */   did_one = FALSE;   search_hl.rm.regprog = NULL;-  FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {-    if (wp->w_redr_type != 0) {-      if (!did_one) {-        did_one = TRUE;-        start_search_hl();++  for (int floating = 0; floating < 2; floating++) {",AFAIK ���two-iteration loop�����is supposed to be an antipattern.,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/7236,136806082,2017-09-04T11:58:18Z,src/nvim/tui/tui.c,"@@ -1448,7 +1448,27 @@ static void patch_terminfo_bugs(TUIData *data, const char *term,     // teminfo entries.  See     // https://github.com/gnachman/iTerm2/pull/92 for more.     // xterm even has an extended version that has a vertical bar.-    if (true_xterm    // per xterm ctlseqs doco (since version 282)+    if (konsole) {+      // Konsole uses an idiosyncratic escape code to set the cursor shape and+      // does not support DECSCUSR.  This makes Konsole set up and apply a+      // nonce profile, which has side-effects on temporary font resizing.+      // In an ideal world, Konsole would just support DECSCUSR.+      data->unibi_ext.set_cursor_style = (int)unibi_add_ext_str(ut, ""Ss"",+          TMUX_WRAP(tmux, ""\x1b]50;CursorShape=%?""+          ""%p1%{3}%<"" ""%t%{0}""    // block+          ""%e%p1%{5}%<"" ""%t%{2}""  // underline+          ""%e%{1}""                // everything else is bar+          ""%;%d;BlinkingCursorEnabled=%?""+          ""%p1%{1}%<"" ""%t%{1}""  // Fortunately if we exclude zero as special,+          ""%e%p1%{1}%&""  // in all other cases we can treat bit #0 as a flag.+          ""%;%d\x07""));+      if (-1 == data->unibi_ext.reset_cursor_style) {+          data->unibi_ext.reset_cursor_style = (int)unibi_add_ext_str(ut, ""Se"",+                                                                      """");+      }+      unibi_set_ext_str(ut, (size_t)data->unibi_ext.reset_cursor_style,+          ""\x1b]50;\x07"");+    } else if (true_xterm    // per xterm ctlseqs doco (since version 282)",Embedding decisions in the order of these conditions is fragile. Explicit is better. It also avoids churn.Why wouldn't this work:    if (!konsole && (true_xterm ...,
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/6195,137924978,2017-09-09T12:04:33Z,src/nvim/terminal.c,"@@ -651,6 +651,15 @@ static void buf_set_term_title(buf_T *buf, char *title)   api_clear_error(&err); } +// Get the associated buffer for the terminal and return whether it's in a+// valid state to be used+static buf_T *term_buf_valid(Terminal *term)+  FUNC_ATTR_NONNULL_ALL+{+  buf_T *buf = handle_get_buffer(term->buf_handle);",can't we make sure buffer is deleted from the handle dict at the same time as it is invalidated? Otherwise I would expect similar bug to sneak up sooner or later...,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/7231,137936940,2017-09-09T22:49:05Z,src/nvim/ex_cmds.c,"@@ -3168,7 +3177,13 @@ static buf_T *do_sub(exarg_T *eap, proftime_T timeout)   linenr_T old_line_count = curbuf->b_ml.ml_line_count;   char_u *sub_firstline;    // allocated copy of first sub line   bool endcolumn = false;   // cursor in last column when done-  MatchedLineVec matched_lines = KV_INITIAL_VALUE;+  PreviewLines preview_lines = { KV_INITIAL_VALUE, 0};+  static linenr_T pre_started;+  static linenr_T pre_ended;+  static int pre_src_id; // initialized to 0, see+                         // https://stackoverflow.com/questions/13251083",Usually we put static locals at the very start of a function. I think it would be surprising to see them in the middle of other locals.,
4117685,KillTheMule,https://api.github.com/repos/neovim/neovim/pulls/7231,137942755,2017-09-10T07:22:41Z,src/nvim/ex_cmds.c,"@@ -3168,7 +3177,13 @@ static buf_T *do_sub(exarg_T *eap, proftime_T timeout)   linenr_T old_line_count = curbuf->b_ml.ml_line_count;   char_u *sub_firstline;    // allocated copy of first sub line   bool endcolumn = false;   // cursor in last column when done-  MatchedLineVec matched_lines = KV_INITIAL_VALUE;+  PreviewLines preview_lines = { KV_INITIAL_VALUE, 0};+  static linenr_T pre_started;+  static linenr_T pre_ended;+  static int pre_src_id; // initialized to 0, see+                         // https://stackoverflow.com/questions/13251083","About that explizit, I'm not sure about the semantics. I don't want it to be reset to 0 every time the function is called, of course. That won't happen?",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/6195,138280461,2017-09-12T08:18:17Z,src/nvim/terminal.c,"@@ -651,6 +651,15 @@ static void buf_set_term_title(buf_T *buf, char *title)   api_clear_error(&err); } +// Get the associated buffer for the terminal and return whether it's in a+// valid state to be used+static buf_T *term_buf_valid(Terminal *term)+  FUNC_ATTR_NONNULL_ALL+{+  buf_T *buf = handle_get_buffer(term->buf_handle);","Adding more _ad-hoc_ logic like that certainly doesn't address my concern in any way, if anything it will make the code _harder_ to reason about... My point was that _invalid_ buffer handles have nothing to do in the buffer table, under _any condition_. Buffer handles are something introduced by nvim, I wouldn't expect vim's destruction code to rely on them in any way. >  that there won't be something added in the future which does need it.And why would we add code that relies on invalid handles after we just removed them? Exactly what would be the point of code that relies on invalid memory?",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/7234,138454807,2017-09-12T20:20:02Z,src/nvim/CMakeLists.txt,"@@ -81,6 +81,8 @@ foreach(subdir         event         eval         lua+        viml","`eval` was intended for expression evaluation only. `viml` is for the whole VimL, including Ex commands. The ���expression evaluation��� parts like parsing and execution are going to move to viml/ for sure, the core problem is that after the whole VimL is ported to a new parser, the difference between expression evaluation and Ex commands evaluation should be gone (both will use a new VM, whatever it will actually be).What is left of eval is1. `typval_T` and related values manipulations. It is more logical to move that near the VM, to viml/ as well (just eval/typval\* to viml/typval\* when viml/ will actually contain some executor, not much hassle).2. A big bunch of `f_���` functions. My idea is that most logical choice for that is treating them just like `ex_���` functions used for Ex commands: scattered around the codebase, near the domain these functions belong to. But this is too heavy refactoring so probably somebody will move them to a separate file (as a part of #5081) where that will live from now on. File may be moved later.3. Utilities for things mentioned above: currently existing executing parser, functions, etc.So it is just ���old��� vs ���new��� code, with ���new��� not using ���eval��� because it is not about only the expressions. I do not want to have expressions parsing in `eval/` because it is going to be fairly isolated from what already is there, but sharing some things with Ex commands parser (for which there is no preexisting directory in any case).",
4117685,KillTheMule,https://api.github.com/repos/neovim/neovim/pulls/7261,138470086,2017-09-12T21:23:52Z,src/nvim/ex_cmds.c,"@@ -3665,9 +3665,38 @@ static buf_T *do_sub(exarg_T *eap, proftime_T timeout)          * use ""\=col("".""). */         curwin->w_cursor.col = regmatch.startpos[0].col; +        // When the match included the ""$"" of the last line it may+        // go beyond the last line of the buffer.+        if (nmatch > curbuf->b_ml.ml_line_count - sub_firstlnum + 1) {+          nmatch = curbuf->b_ml.ml_line_count - sub_firstlnum + 1;+          skip_match = true;+        }+         // 3. Substitute the string. During 'inccommand' preview only do this if         //    there is a replace pattern.","It's stil in the right place I'd say, but it mainly belongs to the `else if` clause... Should be changed, you're right.",
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/6844,139290378,2017-09-16T16:40:03Z,src/nvim/eval.c,"@@ -22390,318 +22313,48 @@ char_u *do_string_sub(char_u *str, char_u *pat, char_u *sub,   return ret; } -static inline TerminalJobData *common_job_init(char **argv,-                                               Callback on_stdout,-                                               Callback on_stderr,-                                               Callback on_exit,-                                               bool pty,-                                               bool rpc,-                                               bool detach,-                                               const char *cwd)-{-  TerminalJobData *data = xcalloc(1, sizeof(TerminalJobData));-  data->stopped = false;-  data->on_stdout = on_stdout;-  data->on_stderr = on_stderr;-  data->on_exit = on_exit;-  data->events = multiqueue_new_child(main_loop.events);-  data->rpc = rpc;-  if (pty) {-    data->proc.pty = pty_process_init(&main_loop, data);-  } else {-    data->proc.uv = libuv_process_init(&main_loop, data);-  }-  Process *proc = (Process *)&data->proc;-  proc->argv = argv;-  proc->in = &data->in;-  proc->out = &data->out;-  if (!pty) {-    proc->err = &data->err;-  }-  proc->cb = eval_job_process_exit_cb;-  proc->events = data->events;-  proc->detach = detach;-  proc->cwd = cwd;-  return data;-}- /// common code for getting job callbacks for jobstart, termopen and rpcstart /// /// @return true/false on success/failure.-static inline bool common_job_callbacks(dict_T *vopts, Callback *on_stdout,-                                        Callback *on_stderr, Callback *on_exit)+static inline bool common_job_callbacks(dict_T *vopts,+                                        CallbackReader *on_stdout,+                                        CallbackReader *on_stderr,+                                        Callback *on_exit) {-  if (tv_dict_get_callback(vopts, S_LEN(""on_stdout""), on_stdout)-      &&tv_dict_get_callback(vopts, S_LEN(""on_stderr""), on_stderr)+  if (tv_dict_get_callback(vopts, S_LEN(""on_stdout""), &on_stdout->cb)+      &&tv_dict_get_callback(vopts, S_LEN(""on_stderr""), &on_stderr->cb)       && tv_dict_get_callback(vopts, S_LEN(""on_exit""), on_exit)) {+    on_stdout->buffered = tv_dict_get_number(vopts, ""stdout_buffered"");+    on_stderr->buffered = tv_dict_get_number(vopts, ""stderr_buffered"");","We could be buffering data without ever using it:```:echo termopen('bash',{'stdout_buffered':1})```Output for a pty would be buffered, but no callback was specified.",
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/6844,139544476,2017-09-18T21:23:20Z,src/nvim/channel.c,"@@ -0,0 +1,751 @@+// This is an open source non-commercial project. Dear PVS-Studio, please check+// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com++#include ""nvim/api/ui.h""+#include ""nvim/channel.h""+#include ""nvim/eval.h""+#include ""nvim/event/socket.h""+#include ""nvim/msgpack_rpc/channel.h""+#include ""nvim/msgpack_rpc/server.h""+#include ""nvim/os/shell.h""+#include ""nvim/path.h""+#include ""nvim/ascii.h""++static bool did_stdio = false;+PMap(uint64_t) *channels = NULL;++/// next free id for a job or rpc channel+/// 1 is reserved for stdio channel+/// 2 is reserved for stderr channel+static uint64_t next_chan_id = CHAN_STDERR+1;+++typedef struct {+  Channel *chan;+  Callback *callback;+  const char *type;+  list_T *received;+  int status;+} ChannelEvent;++#ifdef INCLUDE_GENERATED_DECLARATIONS+# include ""channel.c.generated.h""+#endif+/// Teardown the module+void channel_teardown(void)+{+  if (!channels) {+    return;+  }++  Channel *channel;++  map_foreach_value(channels, channel, {+    channel_close(channel->id, kChannelPartAll, NULL);+  });+}++/// Closes a channel+///+/// @param id The channel id+/// @return true if successful, false otherwise+bool channel_close(uint64_t id, ChannelPart part, const char **error)+{+  Channel *chan;+  Process *proc;++  const char *dummy;+  if (!error) {+    error = &dummy;+  }++  if (!(chan = find_channel(id))) {+    if (id < next_chan_id) {+      // allow double close, even though we can't say what parts was valid.+      return true;+    }+    *error = (const char *)e_invchan;+    return false;+  }++  bool close_main = false;+  if (part == kChannelPartRpc || part == kChannelPartAll) {+    close_main = true;+    if (chan->is_rpc) {+       rpc_close(chan);+    } else if (part == kChannelPartRpc) {+      *error = (const char *)e_invstream;+      return false;+    }+  } else if ((part == kChannelPartStdin || part == kChannelPartStdout)+             && chan->is_rpc) {+    *error = (const char *)e_invstreamrpc;+    return false;+  }++  switch (chan->streamtype) {+    case kChannelStreamSocket:+      if (!close_main) {+        *error = (const char *)e_invstream;+        return false;+      }+      stream_may_close(&chan->stream.socket);+      break;++    case kChannelStreamProc:+      proc = (Process *)&chan->stream.proc;+      if (part == kChannelPartStdin || close_main) {+        stream_may_close(&proc->in);+      }+      if (part == kChannelPartStdout || close_main) {+        stream_may_close(&proc->out);+      }+      if (part == kChannelPartStderr || part == kChannelPartAll) {+        stream_may_close(&proc->err);+      }+      if (proc->type == kProcessTypePty && part == kChannelPartAll) {+        pty_process_close_master(&chan->stream.pty);+      }++      break;++    case kChannelStreamStdio:+      if (part == kChannelPartStdin || close_main) {+        stream_may_close(&chan->stream.stdio.in);+      }+      if (part == kChannelPartStdout || close_main) {+        stream_may_close(&chan->stream.stdio.out);+      }+      if (part == kChannelPartStderr) {+        *error = (const char *)e_invstream;+        return false;+      }+      break;++    case kChannelStreamStderr:+      if (part != kChannelPartAll && part != kChannelPartStderr) {+        *error = (const char *)e_invstream;+        return false;+      }+      if (!chan->stream.err.closed) {+        chan->stream.err.closed = true;+        // Don't close on exit, in case late error messages+        if (!exiting) {+          fclose(stderr);+        }+        channel_decref(chan);+      }+      break;++    case kChannelStreamInternal:+      if (!close_main) {+        *error = (const char *)e_invstream;+        return false;+      }+      break;+  }++  return true;+}++/// Initializes the module+void channel_init(void)+{+  channels = pmap_new(uint64_t)();+  channel_alloc(kChannelStreamStderr);+  rpc_init();+  remote_ui_init();+}++/// Allocates a channel.+///+/// Channel is allocated with refcount 1, which should be decreased+/// when the underlying stream closes.+static Channel *channel_alloc(ChannelStreamType type)+{+  Channel *chan = xcalloc(1, sizeof(*chan));+  if (type == kChannelStreamStdio) {+    chan->id = CHAN_STDIO;+  } else if (type == kChannelStreamStderr) {+    chan->id = CHAN_STDERR;+  } else {+    chan->id = next_chan_id++;+  }+  chan->events = multiqueue_new_child(main_loop.events);+  chan->refcount = 1;+  chan->streamtype = type;+  pmap_put(uint64_t)(channels, chan->id, chan);+  return chan;+}++/// Not implemented, only logging for now+void channel_create_event(Channel *chan, char *ext_source)+{+#if MIN_LOG_LEVEL <= INFO_LOG_LEVEL+  char *stream_desc, *mode_desc, *source;++  switch (chan->streamtype) {+    case kChannelStreamProc:+      if (chan->stream.proc.type == kProcessTypePty) {+          stream_desc = ""pty job"";+      } else {+          stream_desc = ""job"";+      }+      break;++    case kChannelStreamStdio:+       stream_desc = ""stdio"";+       break;++    case kChannelStreamSocket:+      stream_desc = ""socket"";+      break;++    case kChannelStreamInternal:+      stream_desc = ""socket (internal)"";+      break;++    default:+      stream_desc = ""?"";+  }++  if (chan->is_rpc) {+    mode_desc = "", rpc"";+  } else if (chan->term) {+    mode_desc = "", terminal"";+  } else {+    mode_desc = """";+  }++  if (ext_source) {+    // TODO(bfredl): in a future improved traceback solution,+    // external events should be included.+    source = ext_source;+  } else {+    eval_format_source_name_line((char *)IObuff, sizeof(IObuff));+    source = (char *)IObuff;+  }++  ILOG(""new channel %"" PRIu64 "" (%s%s): %s"", chan->id, stream_desc,+       mode_desc, source);+#else+  (void)chan;+  (void)ext_source;+#endif+}++void channel_incref(Channel *channel)+{+  channel->refcount++;+}++void channel_decref(Channel *channel)+{+  if (!(--channel->refcount)) {+    multiqueue_put(main_loop.fast_events, free_channel_event, 1, channel);+  }+}++void callback_reader_free(CallbackReader *reader)+{+  callback_free(&reader->cb);+  if (reader->buffered) {+    ga_clear(&reader->buffer);+  }+}++void callback_reader_start(CallbackReader *reader)+{+  if (reader->buffered) {+    ga_init(&reader->buffer, sizeof(char *), 1);+  }+}++static void free_channel_event(void **argv)+{+  Channel *channel = argv[0];+  if (channel->is_rpc) {+    rpc_free(channel);+  }++  callback_reader_free(&channel->on_stdout);+  callback_reader_free(&channel->on_stderr);+  callback_free(&channel->on_exit);++  pmap_del(uint64_t)(channels, channel->id);+  multiqueue_free(channel->events);+  xfree(channel);+}++static void channel_destroy_early(Channel *chan)+{+  if ((chan->id != --next_chan_id)) {+    abort();+  }++  if ((--chan->refcount != 0)) {+    abort();+  }++  free_channel_event((void **)&chan);+}+++static void close_cb(Stream *stream, void *data)+{+  channel_decref(data);+}++Channel *channel_job_start(char **argv, CallbackReader on_stdout,+                           CallbackReader on_stderr, Callback on_exit,+                           bool pty, bool rpc, bool detach, const char *cwd,+                           uint16_t pty_width, uint16_t pty_height,+                           char *term_name, varnumber_T *status_out)+{+  Channel *chan = channel_alloc(kChannelStreamProc);+  chan->on_stdout = on_stdout;+  chan->on_stderr = on_stderr;+  chan->on_exit = on_exit;+  chan->is_rpc = rpc;++  if (pty) {+    if (detach) {+      EMSG2(_(e_invarg2), ""terminal/pty job cannot be detached"");+      shell_free_argv(argv);+      xfree(term_name);+      channel_destroy_early(chan);+      *status_out = 0;+      return NULL;+    }+    chan->stream.pty = pty_process_init(&main_loop, chan);+    if (pty_width > 0) {+      chan->stream.pty.width = pty_width;+    }+    if (pty_height > 0) {+      chan->stream.pty.height = pty_height;+    }+    if (term_name) {+      chan->stream.pty.term_name = term_name;+    }+  } else {+    chan->stream.uv = libuv_process_init(&main_loop, chan);+  }++  Process *proc = (Process *)&chan->stream.proc;+  proc->argv = argv;+  proc->cb = channel_process_exit_cb;+  proc->events = chan->events;+  proc->detach = detach;+  proc->cwd = cwd;++  char *cmd = xstrdup(proc->argv[0]);+  bool has_out, has_err;+  if (proc->type == kProcessTypePty) {+    has_out = true;+    has_err = false;+  } else {+    has_out = chan->is_rpc || callback_reader_set(chan->on_stdout);+    has_err = callback_reader_set(chan->on_stderr);+  }+  int status = process_spawn(proc, true, has_out, has_err);+  if (status) {+    EMSG3(_(e_jobspawn), os_strerror(status), cmd);+    xfree(cmd);+    if (proc->type == kProcessTypePty) {+      xfree(chan->stream.pty.term_name);+    }+    channel_destroy_early(chan);+    *status_out = proc->status;+    return NULL;+  }+  xfree(cmd);++  wstream_init(&proc->in, 0);+  if (has_out) {+    rstream_init(&proc->out, 0);+  }++  if (chan->is_rpc) {+    // the rpc takes over the in and out streams+    rpc_start(chan);+  } else {+    if (has_out) {+      callback_reader_start(&chan->on_stdout);+      rstream_start(&proc->out, on_job_stdout, chan);+    }+  }++  if (has_err) {+    callback_reader_start(&chan->on_stderr);+    rstream_init(&proc->err, 0);+    rstream_start(&proc->err, on_job_stderr, chan);+  }++  *status_out = (varnumber_T)chan->id;+  return chan;+}+++uint64_t channel_connect(bool tcp, const char *address,+                         bool rpc, CallbackReader on_output,+                         int timeout, const char **error)+{+  if (!tcp && rpc) {+    char *path = fix_fname(address);+    if (server_owns_pipe_address(path)) {+      // avoid deadlock+      xfree(path);+      return channel_create_internal_rpc();+    }+    xfree(path);+  }++  Channel *channel = channel_alloc(kChannelStreamSocket);+  if (!socket_connect(&main_loop, &channel->stream.socket,+                      tcp, address, timeout, error)) {+    channel_destroy_early(channel);+    return 0;+  }++  channel->stream.socket.internal_close_cb = close_cb;+  channel->stream.socket.internal_data = channel;+  wstream_init(&channel->stream.socket, 0);+  rstream_init(&channel->stream.socket, 0);++  if (rpc) {+    rpc_start(channel);+  } else {+    channel->on_stdout = on_output;+    callback_reader_start(&channel->on_stdout);+    rstream_start(&channel->stream.socket, on_socket_output, channel);+  }++  channel_create_event(channel, NULL);+  return channel->id;+}++/// Creates an RPC channel from a tcp/pipe socket connection+///+/// @param watcher The SocketWatcher ready to accept the connection+void channel_from_connection(SocketWatcher *watcher)+{+  Channel *channel = channel_alloc(kChannelStreamSocket);+  socket_watcher_accept(watcher, &channel->stream.socket);+  channel->stream.socket.internal_close_cb = close_cb;+  channel->stream.socket.internal_data = channel;+  wstream_init(&channel->stream.socket, 0);+  rstream_init(&channel->stream.socket, 0);+  rpc_start(channel);+  channel_create_event(channel, watcher->addr);+}++/// Creates a loopback channel. This is used to avoid deadlock+/// when an instance connects to its own named pipe.+static uint64_t channel_create_internal_rpc(void)+{+  Channel *channel = channel_alloc(kChannelStreamInternal);+  rpc_start(channel);+  return channel->id;+}++/// Creates an API channel from stdin/stdout. This is used when embedding+/// Neovim+uint64_t channel_from_stdio(bool rpc, CallbackReader on_output,+                            const char **error)+  FUNC_ATTR_NONNULL_ALL+{+  if (!headless_mode) {+    *error = _(""can only be opened in headless mode"");+    return 0;+  }++  if (did_stdio) {+    *error = _(""channel was already open"");+    return 0;+  }+  did_stdio = true;++  Channel *channel = channel_alloc(kChannelStreamStdio);++  rstream_init_fd(&main_loop, &channel->stream.stdio.in, 0, 0);+  wstream_init_fd(&main_loop, &channel->stream.stdio.out, 1, 0);++  if (rpc) {+    rpc_start(channel);+  } else {+    channel->on_stdout = on_output;+    callback_reader_start(&channel->on_stdout);+    rstream_start(&channel->stream.stdio.in, on_stdio_input, channel);+  }++  return channel->id;+}++/// @param data will be consumed+size_t channel_send(uint64_t id, char *data, size_t len, const char **error)+{+  Channel *chan = find_channel(id);+  if (!chan) {+    EMSG(_(e_invchan));+    goto err;+  }++  if (chan->streamtype == kChannelStreamStderr) {+    if (chan->stream.err.closed) {+      *error = _(""Can't send data to closed stream"");+      goto err;+    }+    // unbuffered write+    size_t written = fwrite(data, len, 1, stderr);+    xfree(data);+    return len * written;+  }+++  Stream *in = channel_instream(chan);+  if (in->closed) {+    *error = _(""Can't send data to closed stream"");+    goto err;+  }++  if (chan->is_rpc) {+    *error = _(""Can't send raw data to rpc channel"");+    goto err;+  }++  WBuffer *buf = wstream_new_buffer(data, len, 1, xfree);+  return wstream_write(in, buf) ? len : 0;++err:+  xfree(data);+  return 0;+}++/// NB: mutates buf in place!+static list_T *buffer_to_tv_list(char *buf, size_t count)+  FUNC_ATTR_NONNULL_ALL+{+  list_T *ret = tv_list_alloc();+  char *ptr = buf;+  size_t remaining = count;+  size_t off = 0;++  while (off < remaining) {+    // append the line+    if (ptr[off] == NL) {+      tv_list_append_string(ret, ptr, (ssize_t)off);+      size_t skip = off + 1;+      ptr += skip;+      remaining -= skip;+      off = 0;+      continue;+    }+    if (ptr[off] == NUL) {+      // Translate NUL to NL+      ptr[off] = NL;+    }+    off++;+  }+  tv_list_append_string(ret, ptr, (ssize_t)off);+  return ret;+}++// vimscript job callbacks must be executed on Nvim main loop+static inline void process_job_event(Channel *chan, Callback *callback,+                                     const char *type, char *buf, size_t count,+                                     int status)+{+  assert(callback);+  ChannelEvent *event_data = xmalloc(sizeof(*event_data));+  event_data->received = NULL;+  if (buf) {+    event_data->received = buffer_to_tv_list(buf, count);+  } else {+    event_data->status = status;+  }+  channel_incref(chan);  // Hold on ref to callback+  event_data->chan = chan;+  event_data->callback = callback;+  event_data->type = type;++  multiqueue_put(chan->events, on_job_event, 1, event_data);+}++void on_job_stdout(Stream *stream, RBuffer *buf, size_t count,+                   void *data, bool eof)+{+  Channel *chan = data;+  on_channel_output(stream, chan, buf, count, eof, &chan->on_stdout, ""stdout"");+}++void on_job_stderr(Stream *stream, RBuffer *buf, size_t count,+                   void *data, bool eof)+{+  Channel *chan = data;+  on_channel_output(stream, chan, buf, count, eof, &chan->on_stderr, ""stderr"");+}++static void on_socket_output(Stream *stream, RBuffer *buf, size_t count,+                             void *data, bool eof)+{+  Channel *chan = data;+  on_channel_output(stream, chan, buf, count, eof, &chan->on_stdout, ""data"");+}++static void on_stdio_input(Stream *stream, RBuffer *buf, size_t count,+                           void *data, bool eof)+{+  Channel *chan = data;+  on_channel_output(stream, chan, buf, count, eof, &chan->on_stdout, ""stdin"");+}++static void on_channel_output(Stream *stream, Channel *chan, RBuffer *buf,+                              size_t count, bool eof, CallbackReader *reader,+                              const char *type)+{+  // stub variable, to keep reading consistent with the order of events, only+  // consider the count parameter.+  size_t r;+  char *ptr = rbuffer_read_ptr(buf, &r);++  if (eof) {+    if (reader->buffered) {+      if (reader->cb.type != kCallbackNone) {+        process_job_event(chan, &reader->cb, type, reader->buffer.ga_data,+                          (size_t)reader->buffer.ga_len, 0);+        ga_clear(&reader->buffer);+      } else if (reader->self) {+        list_T *data = buffer_to_tv_list(reader->buffer.ga_data,+                                         (size_t)reader->buffer.ga_len);","`buffer_to_tv_list()` has attribute `FUNC_ATTR_NONNULL_ALL`, but if no output was seen on this stream `.ga_data` is `NULL`.",
4117685,KillTheMule,https://api.github.com/repos/neovim/neovim/pulls/7231,140165469,2017-09-21T07:19:14Z,src/nvim/ex_cmds.c,"@@ -6028,6 +6089,8 @@ static buf_T *show_sub(exarg_T *eap, pos_T old_cusr, char_u *pat, char_u *sub,   char_u *save_shm_p = vim_strsave(p_shm);   size_t sub_size = mb_string2cells(sub);   size_t pat_size = mb_string2cells(pat);","Those are not used for anything anymore other than the decision if we need to show the split window, see https://github.com/KillTheMule/neovim/blob/6fd1c047e837d4bddb9f59a8d9894d6a8ce6f8b5/src/nvim/ex_cmds.c#L6105.  We only check if those are 0 or not, so `mb_string2cells` or `strlen` should not matter (actually, we could really check `*sub` and `*pat`).I'm not sure why that check is there anyways. If `pat` or `sub` are empty or `NULL`, doesn't that just mean the user left it out and the last recent pattern/substitution is used? Why wouldn't we want to show the preview window then?I think we could just remove those 2 lines, remove this part of the check and remove those arguments from the function call.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/7231,140170856,2017-09-21T07:51:28Z,src/nvim/ex_cmds.c,"@@ -6028,6 +6089,8 @@ static buf_T *show_sub(exarg_T *eap, pos_T old_cusr, char_u *pat, char_u *sub,   char_u *save_shm_p = vim_strsave(p_shm);   size_t sub_size = mb_string2cells(sub);   size_t pat_size = mb_string2cells(pat);","> I'm not sure why that check is there anyways. If pat or sub are empty or NULL, doesn't that just mean the user left it out and the last recent pattern/substitution is used?Well, it's a matter of whether we think the user wants to see a preview of `:%s/`. At the time I decided this would be more annoying than helpful.> I think we could just remove those 2 lines, remove this part of the check and remove those arguments from the function call.����  Let's put it in a separate commit for clarity.",
240938,aignas,https://api.github.com/repos/neovim/neovim/pulls/7287,140626890,2017-09-23T05:43:21Z,test/functional/shada/merging_spec.lua,"@@ -13,6 +13,11 @@ local read_shada_file = shada_helpers.read_shada_file local wshada, sdrcmd, shada_fname =   get_shada_rw('Xtest-functional-shada-merging.shada') +local mock_file_path = '/a/b/'+if helpers.iswin() then+  mock_file_path = 'C:\\a\\b\\'+end","I agree. However, I was trying to construct a payload with a filename, that has more than 6 characters in the path and as far as I understand the payload part with the filename should be something like `\xc4\x07/a/bb/c` but that does not work, however `\xc4\x05/aa/c` does work, which leaves me completely baffled. I was reading on the [bin format in msgpack spec](https://github.com/msgpack/msgpack/blob/master/spec.md#bin-format-family).The example test file:```lua-- ShaDa filename length greater that 6 testlocal helpers = require('test.functional.helpers')(after_each)local exc_exec = helpers.exc_execlocal eq = helpers.eqlocal shada_helpers = require('test.functional.shada.helpers')local reset, clear, get_shada_rw =  shada_helpers.reset, shada_helpers.clear, shada_helpers.get_shada_rwlocal wshada, sdrcmd, shada_fname =  get_shada_rw('Xtest-functional-shada-merging.shada')describe('When trying to par ShaDa code this', function()  before_each(reset)  after_each(function()    clear()    os.remove(shada_fname)  end)  it('works #7287',  function()    wshada('\007\001\018\131\162mX\195\161f\xc4\006/a/b/-\161nA')    eq(0, exc_exec(sdrcmd()))  end)  it('does not work #7287',  function()    wshada('\007\001\018\131\162mX\195\161f\xc4\007/a/bc/-\161nA')    eq(0, exc_exec(sdrcmd()))  end)end)```Do you know if there is any documentation on the protocol that NVIM uses in order to store things? ",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/7315,140658867,2017-09-24T15:10:50Z,src/nvim/ex_cmds.c,"@@ -6156,7 +6249,11 @@ void ex_substitute(exarg_T *eap)   curwin->w_p_cul = false;    // Disable 'cursorline'   curwin->w_p_cuc = false;    // Disable 'cursorcolumn' +  long numval = 0;+  get_option_value((char_u *)""hls"", &numval, NULL, 0);+  set_option_value((const char *)""hls"", 0, NULL, OPT_GLOBAL);   buf_T *preview_buf = do_sub(eap, profile_setlimit(p_rdt));+  set_option_value((const char *)""hls"", numval, NULL, OPT_GLOBAL);","If possible, it's often faster to set/reset options directly (e.g. `p_hls` in this case), particuarly if there's side-effects. I usually look around the codebase to see how it's typically done for a given option (didn't check `p_hls`), some options will behave badly if their side-effects aren't taken care of. In this case I would _guess_ that `p_hls = false` is enough to get what we want, without any problems. Maybe you tried it already though.",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/7336,141797708,2017-09-29T06:31:28Z,runtime/doc/quickfix.txt,"@@ -138,11 +138,12 @@ processing a quickfix or location list command, it will be aborted. 			current window is used instead of the quickfix list.  							*:cq* *:cquit*-:cq[uit][!]		Quit Vim with an error code, so that the compiler-			will not compile the same file again.-			WARNING: All changes in files are lost!  Also when the-			[!] is not used.  It works like "":qall!"" |:qall|,-			except that Vim returns a non-zero exit code.+:cq[uit][!]		Quit Vim with an error code (When vim is called from another","Here should be argument listed, or `:[count]cq[uit]`, better the second.",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/7336,141801196,2017-09-29T07:00:55Z,test/functional/core/exit_spec.lua,"@@ -43,4 +43,17 @@ describe('v:exiting', function()     run(on_request, nil, on_setup)   end) +  it('is specified exit code after :cquit', function()+    local function on_setup()+      command('autocmd VimLeavePre * call rpcrequest('..cid..', """")')+      command('autocmd VimLeave    * call rpcrequest('..cid..', """")')+      command('cquit 123')+    end+    local function on_request()+      eq(123, eval('v:exiting'))+      return ''+    end+    run(on_request, nil, on_setup)+  end)","Ah, no, add ZEROR flag to the list and `:0cquit` should be the same as `:cquit 0`. It is just `:cnext` thinks that is incorrect.",
576382,zhou13,https://api.github.com/repos/neovim/neovim/pulls/6380,141810694,2017-09-29T08:05:02Z,src/nvim/screen.c,"@@ -2653,20 +2663,6 @@ win_line (       cur = cur->next;   } -  /* Cursor line highlighting for 'cursorline' in the current window.  Not-   * when Visual mode is active, because it's not clear what is selected-   * then. */-  if (wp->w_p_cul && lnum == wp->w_cursor.lnum-      && !(wp == curwin && VIsual_active)) {-    if (line_attr != 0 && !(State & INSERT) && bt_quickfix(wp->w_buffer)-        && qf_current_entry(wp) == lnum) {-      line_attr = hl_combine_attr(win_hl_attr(wp, HLF_CUL), line_attr);","The old one basically says if we are in quickfix window, then we use `HLF_CUL` to complement current `line_attr`, otherwise it will directly set `line_attr` to `HLF_CUL`.  Setting `line_attr` to `HLF_CUL` is not what we want, since it incorrectly override some highlights under some condition (the logic is complex here)....In this patch, I split `line_attr` into `line_attr` and `line_attr_low_priority`.  Now `line_attr_low_priority` only takes care of `cursorline`, and it will be merged into `char_attr` with lowest priority.  For other `line_attr`, it will still use the old logic.  Since `line_attr_low_priority` already has lowest priority, I believe these lines are not necessary.",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/7336,141956400,2017-09-29T20:06:25Z,test/functional/core/exit_spec.lua,"@@ -43,4 +43,29 @@ describe('v:exiting', function()     run(on_request, nil, on_setup)   end) +  it('is specified a non-zero exit code after :cquit', function()+    local function on_setup()+      command('autocmd VimLeavePre * call rpcrequest('..cid..', """")')+      command('autocmd VimLeave    * call rpcrequest('..cid..', """")')+      command('cquit 123')+    end+    local function on_request()+      eq(123, eval('v:exiting'))+      return ''+    end+    run(on_request, nil, on_setup)+  end)++  it('is specified a zero exit code after :cquit', function()+    local function on_setup()+      command('autocmd VimLeavePre * call rpcrequest('..cid..', """")')+      command('autocmd VimLeave    * call rpcrequest('..cid..', """")')+      command('cquit 0')+    end+    local function on_request()+      eq(0, eval('v:exiting'))+      return ''+    end+    run(on_request, nil, on_setup)+  end)","Still missing most of the tests I listed. I would also highly advise on creating a ���test generator��� function called like `test_cq('cquit 0', 0, nil)`:```lualocal function test_cq(cmdline, exit_code, redir_msg)  if redir_msg then    eq('\n' .. redir_msg, redir_exec(cmdline))    wait()    eq(1, eval('1'))  -- Check that Neovim did not crash or exit  else    funcs.system({nvim_prog, '-u', 'NONE', '-i', 'NONE', '--headless', '--cmd', cmdline})    eq(exit_code, eval('v:shell_error'))    local function on_setup()       command('autocmd VimLeavePre * call rpcrequest('..cid..', """")')       command('autocmd VimLeave    * call rpcrequest('..cid..', """")')       command(cmdline)     end     local function on_request()       eq(exit_code, eval('v:exiting'))       return ''     end     run(on_request, nil, on_setup)  endend```Note the significant difference: I do not suggest checking *only* `v:exiting`, this test does not really serve its purpose because you can���t observe exit code before Neovim actually exits and you can���t have `v:exiting` available after it exits: test is only valid as long as there is connection between `v:exiting` and exit value and it is not necessary the case if somebody added a bug. Actually since I mentioned it: what you are testing is `:cquit`, *not* `v:exiting`, so while checking for it sideways is fine, setting `v:exiting` is by no means a purpose of `:cquit`: it is purpose of `v:exiting` to contain exit value Neovim will use, purpose of `:cq` is quit Neovim with specified exit value which is checked by `system()` check only.Thus remove `:cq` out of the current `describe()` block, it is not correct.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/7342,142027166,2017-10-01T11:25:12Z,runtime/doc/intro.txt,"@@ -373,8 +373,8 @@ CTRL-{char}	{char} typed as a control character; that is, typing {char}  					*key-notation* *key-codes* *keycodes* These names for keys are used in the documentation.  They can also be used-with the "":map"" command (insert the key name by pressing CTRL-K and then the-key you want the name for).+with the "":map"" command (some of these key names can be inserted by pressing+CTRL-K and then the key you want the name for).","Just delete the part in parens, then. It's useless.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/7351,142100907,2017-10-02T10:13:30Z,src/nvim/normal.c,"@@ -635,6 +635,21 @@ static void normal_redraw_mode_message(NormalState *s)   emsg_on_display = false; } +static int add_vgetc(void)+{+   while(true) {+     int key = state_vgetc(""nx"");+     if (key == K_IGNORE) {+       continue;+     } else if (key == K_EVENT) {+        state_process_events(""nx"");+        continue;+     }+     return key;+   }+}++ // TODO(tarruda): Split into a ""normal pending"" state that can handle K_EVENT static void normal_get_additional_char(NormalState *s)","What would be the gain of changing the structure of the code so much? The purpose of `state_vgetc` and `state_process_events` is to easily support temporary states that don't handle mappings (on their own, ""normal additional"" can of course still process rhs of ""normal normal"" mapping) and really need no ""internal"" state flag, but we still want to announce it in `nvim_get_mode` (either, as I do by overriding `mode(1)` or alternatively by adding third field)And I'm looking forward to seeing the multicursor branch :)",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/7340,142235210,2017-10-02T19:42:09Z,src/nvim/menu.c,"@@ -696,9 +700,11 @@ static dict_T *menu_get_recursive(const vimmenu_T *menu, int modes)       if ((menu->modes & modes & (1 << bit)) != 0) {         dict_T *impl = tv_dict_alloc();         if (*menu->strings[bit] == NUL) {-          tv_dict_add_str(impl, S_LEN(""rhs""), (char *)""<Nop>"");+          tv_dict_add_str(impl, S_LEN(""rhs""), (char *)"""");","No, just remove `if()`, what do you think `str2special_save` is going to do with the empty string and how exactly this is common to justify adding four more lines? `nvim_get_keymap` does not bother with treating empty string specially. Also the cast here is in any case useless.",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/7340,142236709,2017-10-02T19:49:00Z,test/functional/ex_cmds/menu_spec.lua,"@@ -379,5 +379,253 @@ describe('menu_get', function()     }     eq(expected, m)   end)+end)++describe('menu_get', function()++  before_each(function()+    clear()+  end) +  it('prettyprints special chars', function()+    clear()+    command('nnoremenu &Test.Test inormal<ESC>')+    command('inoremenu &Test.Test2 <Tab><Esc>')+    command('vnoremenu &Test.Test3 yA<C-R>0<Tab>xyz<Esc>')+    command('inoremenu &Test.Test4 <c-r>*')+    command('inoremenu &Test.Test5 <c-R>+')+    command('nnoremenu &Test.Test6 <Nop>')+    command('nnoremenu &Test.Test7 <NOP>')+    command('nnoremenu &Test.Test8 <NoP>')+    command('nnoremenu &Test.Test9 """"')++    local m = funcs.menu_get("""");+    expected = {+      {+        shortcut = ""T"",+        hidden = 0,+        submenus = {+          {+            priority = 500,+            mappings = {+              n = {+                sid = 1,+                noremap = 1,+                enabled = 1,+                rhs = ""inormal<Esc>"",+                silent = 0+              }+            },+            name = ""Test"",+            hidden = 0+          },+          {+            priority = 500,+            mappings = {+              i = {+                sid = 1,+                noremap = 1,+                enabled = 1,+                rhs = ""<Tab><Esc>"",+                silent = 0+              }+            },+            name = ""Test2"",+            hidden = 0+          },+          {+            priority = 500,+            mappings = {+              s = {+                sid = 1,+                noremap = 1,+                enabled = 1,+                rhs = ""yA<C-R>0<Tab>xyz<Esc>"",+                silent = 0+              },+              v = {+                sid = 1,+                noremap = 1,+                enabled = 1,+                rhs = ""yA<C-R>0<Tab>xyz<Esc>"",+                silent = 0+              }+            },+            name = ""Test3"",+            hidden = 0+          },+          {+            priority = 500,+            mappings = {+              i = {+                sid = 1,+                noremap = 1,+                enabled = 1,+                rhs = ""<C-R>*"",+                silent = 0+              }+            },+            name = ""Test4"",+            hidden = 0+          },+          {+            priority = 500,+            mappings = {+              i = {+                sid = 1,+                noremap = 1,+                enabled = 1,+                rhs = ""<C-R>+"",+                silent = 0+              }+            },+            name = ""Test5"",+            hidden = 0+          },+          {+            priority = 500,+            mappings = {+              n = {+                sid = 1,+                noremap = 1,+                enabled = 1,+                rhs = """",+                silent = 0+              }+            },+            name = ""Test6"",+            hidden = 0+          },+          {+            priority = 500,+            mappings = {+              n = {+                sid = 1,+                noremap = 1,+                enabled = 1,+                rhs = """",+                silent = 0+              }+            },+            name = ""Test7"",+            hidden = 0+          },+          {+            priority = 500,+            mappings = {+              n = {+                sid = 1,+                noremap = 1,+                enabled = 1,+                rhs = """",+                silent = 0+              }+            },+            name = ""Test8"",+            hidden = 0+          },+          {+            priority = 500,+            mappings = {+              n = {+                sid = 1,+                noremap = 1,+                enabled = 1,+                rhs = ""\""\"""",+                silent = 0+              }+            },+            name = ""Test9"",+            hidden = 0+          }+        },+        priority = 500,+        name = ""Test""+      }+    }++    eq(m, expected)+  end)++  it('works with right-aligned text and spaces', function()+    clear()+    command('nnoremenu &Test<Tab>Y.Test<Tab>X\\ x inormal<Alt-j>')+    command('nnoremenu &Test\\ 1.Test\\ 2 Wargl')+    command('nnoremenu &Test4.Test<Tab>3 i space<Esc>')++    local m = funcs.menu_get("""");+    local expected = {+      {+        shortcut = ""T"",+        hidden = 0,+        actext = ""Y"",+        submenus = {+          {+            mappings = {+              n = {+                sid = 1,+                noremap = 1,+                enabled = 1,+                rhs = ""inormal<Alt-j>"",+                silent = 0+              }+            },+            hidden = 0,+            actext = ""X x"",+            priority = 500,+            name = ""Test""+          }+        },+        priority = 500,+        name = ""Test""+      },+      {+        shortcut = ""T"",+        hidden = 0,+        submenus = {+          {+            priority = 500,+            mappings = {+              n = {+                sid = 1,+                noremap = 1,+                enabled = 1,+                rhs = ""Wargl"",+                silent = 0+              }+            },+            name = ""Test 2"",+            hidden = 0+          }+        },+        priority = 500,+        name = ""Test 1""+      },+      {+        shortcut = ""T"",+        hidden = 0,+        submenus = {+          {+            mappings = {+              n = {+                sid = 1,+                noremap = 1,+                enabled = 1,+                rhs = ""i space<Esc>"",+                silent = 0+              }+            },+            hidden = 0,+            actext = ""3"",+            priority = 500,+            name = ""Test""+          }+        },+        priority = 500,+        name = ""Test4""+      }+    }","By the way, wondering how do you create such lengthy dictionaries? For #7234 and previous PRs I used to write the whole thing by hand until I got too bored and finally added https://github.com/ZyX-I/neovim/blob/f2724f85ed32f20443cfaa3a636ec875c313b19f/test/helpers.lua#L310-L359 which may be used to dump lua tables and strings (no support for numbers yet because specifically for my PR I do not need them), but maybe there already is something existing.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/7343,142854082,2017-10-05T06:11:01Z,test/functional/terminal/edit_spec.lua,"@@ -36,6 +36,9 @@ describe(':edit term://*', function()     local scr = get_screen(columns, lines)     local rep = 'a'     meths.set_option('shellcmdflag', 'REP ' .. rep)+    if helpers.os_name() == 'windows' then+      command('set shellxquote=')","This is also the default for unix, so just do it unconditionally. But let's put a small hint next to it:```luacommand('set shellxquote=')  -- win: avoid extra quotes```",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/7358,143064448,2017-10-05T21:41:12Z,src/nvim/buffer.c,"@@ -3069,9 +3069,13 @@ static bool ti_change(char_u *str, char_u **last) /// Set current window title void resettitle(void) {-  ui_call_set_title(cstr_as_string((char *)lasttitle));-  ui_call_set_icon(cstr_as_string((char *)lasticon));-  ui_flush();+  if (p_icon) {","These conditions should be in the TUI not here, it breaks other UIs.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/7358,143240295,2017-10-06T16:54:45Z,src/nvim/buffer.c,"@@ -3069,9 +3069,13 @@ static bool ti_change(char_u *str, char_u **last) /// Set current window title void resettitle(void) {-  ui_call_set_title(cstr_as_string((char *)lasttitle));-  ui_call_set_icon(cstr_as_string((char *)lasticon));-  ui_flush();+  if (p_icon) {","Ah, got it. We didn't have these conditions before, so we could just default title=on , right?",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/7358,143263320,2017-10-06T18:24:15Z,src/nvim/buffer.c,"@@ -3069,9 +3069,13 @@ static bool ti_change(char_u *str, char_u **last) /// Set current window title void resettitle(void) {-  ui_call_set_title(cstr_as_string((char *)lasttitle));-  ui_call_set_icon(cstr_as_string((char *)lasticon));-  ui_flush();+  if (p_icon) {","After checking, we already have them in `maketitle()`, so these conditions are  redundant. (and master before this doesn't set terminal title with `-u NONE`) . So the question still stands. _Personally_ I'm perfectly fine with `set title` by default, but if `guicursor` is any precedent, prepare for responses like ""nvim set the title and didn't restore it, it broke my terminal setup"".  Your call, I guess you will be the one responding to them. :) But there is a third way, we can hack the vim behavior a simpler way; if nvim is started with `--headless` or `--embed`, then `set title` by default.",
8740057,janlazo,https://api.github.com/repos/neovim/neovim/pulls/7343,143315073,2017-10-07T00:03:34Z,test/functional/eval/system_spec.lua,"@@ -446,8 +446,11 @@ describe('systemlist()', function()     after_each(delete_file(fname))      it('replaces NULs by newline characters', function()-      if helpers.pending_win32(pending) then return end-      eq({'part1\npart2\npart3'}, eval('systemlist(""cat '..fname..'"")'))+      if iswin() then+        eq({'part1\npart2\npart3\r'}, eval('systemlist(""type '..fname..'"")'))",Is the trailing carriage return intentional for `systemlist` to be compatible with Vim?,
112971,jamessan,https://api.github.com/repos/neovim/neovim/pulls/7343,143318068,2017-10-07T00:59:19Z,test/functional/eval/system_spec.lua,"@@ -446,8 +446,11 @@ describe('systemlist()', function()     after_each(delete_file(fname))      it('replaces NULs by newline characters', function()-      if helpers.pending_win32(pending) then return end-      eq({'part1\npart2\npart3'}, eval('systemlist(""cat '..fname..'"")'))+      if iswin() then+        eq({'part1\npart2\npart3\r'}, eval('systemlist(""type '..fname..'"")'))","`systemlist()` splits the output from the command on `\n`.  Since you're on Windows, nvim is defaulting `'fileformat'` to `dos`.  This means that the file created by `create_file_with_nuls()` has a `\r\n` for the line ending instead of the `\n` that's expected on non-Windows systems.Therefore, what you're seeing is expected given the differences in default `'fileformat'`.  You can either account for it here, like you did, or change the test setup to force `fileformat=unix`.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/7358,143327742,2017-10-07T10:23:21Z,src/nvim/buffer.c,"@@ -3069,9 +3069,13 @@ static bool ti_change(char_u *str, char_u **last) /// Set current window title void resettitle(void) {-  ui_call_set_title(cstr_as_string((char *)lasttitle));-  ui_call_set_icon(cstr_as_string((char *)lasticon));-  ui_flush();+  if (p_icon) {","> we already have them in maketitle(), so these conditions are redundantBut `resettitle()` is not only called from `maketitle()`. Vim doesn't have these conditions in `resettitle`, it only calls `mch_settitle`, which is driven by the state of `lasttitle`/`lasticon`, which are set by `maketitle()`. `mch_settitle()` doesn't exist in Nvim, it was replaced by `ui_call_set_*`, i.e., it's delegated to the UI.I actually don't know what the implications of the conditions are, and if it works ok without them (**edit:** it does; checked with all combinations of 'title', 'titlestring', 'titleold'), might as well remove them as they were before. The logic is just crazy.",
9730330,bew,https://api.github.com/repos/neovim/neovim/pulls/7371,143492592,2017-10-09T14:57:53Z,runtime/nvim.desktop,"@@ -71,7 +71,7 @@ Comment[wa]=Asspougn�� des fitch��s tecses Comment[zh_CN]=������������������ Comment[zh_TW]=��������������� TryExec=nvim-Exec=nvim %F+Exec=nvim ""%f""","Using `%f` instead of `%F` is a regression I think:- `%f`: A single file name (including the path), even if multiple files are selected.- `%F`: A list of files. Use for apps that can open several local files at once. Each file is passed as a separate argument to the executable program. > Each file is passed as a separate argument to the executable program. I think it should already work the way it should with filenames with spaces",
8740057,janlazo,https://api.github.com/repos/neovim/neovim/pulls/7343,143545638,2017-10-09T18:34:33Z,test/functional/core/job_spec.lua,"@@ -561,7 +555,6 @@ describe('jobs', function()   end)    it('cannot have both rpc and pty options', function()-    if helpers.pending_win32(pending) then return end  -- TODO: Need `cat`.     command(""let g:job_opts.pty = v:true"")     command(""let g:job_opts.rpc = v:true"")     local _, err = pcall(command, ""let j = jobstart(['cat', '-'], g:job_opts)"")","Appveyor log for MINGW_64```[00:10:28] [  ERROR   ] C:/projects/neovim/test/functional\core\job_spec.lua @ 557: jobs cannot have both rpc and pty options[00:10:28] C:/projects/neovim/test/functional\core\job_spec.lua:561: bad argument #1 to 'find' (string expected, got nil)[00:10:28] [00:10:28] stack traceback:[00:10:28] 	C:/projects/neovim/test/functional\core\job_spec.lua:561: in function <C:/projects/neovim/test/functional\core\job_spec.lua:557>[00:10:28] [00:10:28] [00:10:28]  79 SKIPPED TESTS[00:10:28]  1 ERROR[00:10:28] -- Output to stderr:[00:10:28] Get-Process : Cannot find a process with the process identifier 2428.[00:10:28] At line:1 char:1[00:10:28] + Get-Process -Id 2428[00:10:28] + ~~~~~~~~~~~~~~~~~~~~[00:10:28]     + CategoryInfo          : ObjectNotFound: (2428:Int32) [Get-Process], Proc [00:10:28]    essCommandException[00:10:28]     + FullyQualifiedErrorId : NoProcessFoundForGivenId,Microsoft.PowerShell.Co [00:10:28]    mmands.GetProcessCommand[00:10:28]  [00:10:28] The system cannot find the path specified.[00:10:28] 2017/10/09 18:10:59 ERROR 1304 open_log_file:178: Logging to stderr, failed to open $NVIM_LOG_FILE: Xtest-startup-xdg-logpath\nvim-data\log[00:10:28] 2017/10/09 18:10:59 WARN  1304 call_set_error:864: RPC: ch 1 was closed by the client```",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/7343,143565886,2017-10-09T20:12:34Z,test/functional/core/job_spec.lua,"@@ -138,7 +138,7 @@ describe('jobs', function()   end)    it('preserves NULs', function()-    if helpers.pending_win32(pending) then return end  -- TODO: Need `cat`.+    if helpers.pending_win32(pending) then return end   -- XXX: Hangs in Appveyor","in https://github.com/neovim/neovim/pull/6129 i left this note:```lua-- TODO: Windows: why is the data received on_stderr instead of on_stdout?if helpers.pending_win32(pending) then return end```So that explains why it hangs: `next_msg()` will never return because we don't have a handler for stderr.Rather than add a handler, let's leave that TODO because this needs more investigation.",
112971,jamessan,https://api.github.com/repos/neovim/neovim/pulls/7371,143786517,2017-10-10T16:46:07Z,runtime/nvim.desktop,"@@ -71,7 +71,7 @@ Comment[wa]=Asspougn�� des fitch��s tecses Comment[zh_CN]=������������������ Comment[zh_TW]=��������������� TryExec=nvim-Exec=nvim %F+Exec=nvim ""%f""","> I've tested it in multiple environments. %F cannot open file(filename or path with space) correctly.Then that sounds like a problem with whatever is executing nvim.  According to the [desktop spec](https://specifications.freedesktop.org/desktop-entry-spec/latest/ar01s06.html), `%F` is supposed to pass each file as independent arguments to the executable.  This implies that the program is being run using an `execve()`-type function.Based on your experience, it seems like a shell is being used and the arguments aren't being properly delineated as distinct arguments.  That is not a bug in our desktop file.The Debian vim package has been using `%F` for the past 10 years.  I've yet to receive a single bug about this, where as we did get bugs about the previously used `%U`.",
8740057,janlazo,https://api.github.com/repos/neovim/neovim/pulls/7343,143889929,2017-10-11T00:56:43Z,test/functional/autocmd/termclose_spec.lua,"@@ -22,14 +20,14 @@ describe('TermClose event', function()   end)    it('triggers when long-running terminal job gets stopped', function()-    nvim('set_option', 'shell', 'sh')","After removing this line, this test is a duplicate of the `triggers when fast-exiting terminal job stops` test.",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/7234,144733975,2017-10-15T22:25:31Z,src/nvim/keymap.c,"@@ -573,11 +571,7 @@ int find_special_key(const char_u **srcp, const size_t src_len, int *const modp,     if (*bp == '-') {       last_dash = bp;       if (bp + 1 <= end) {-        if (has_mbyte) {-          l = mb_ptr2len_len(bp + 1, (int) (end - bp) + 1);-        } else {-          l = 1;-        }+        l = utfc_ptr2len_len(bp + 1, (int)(end - bp) + 1);","It is very bad idea, `mb_���` references *both* `utf` and `utfc` and they have different enough semantics. So I never use this variant.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/7173,145269033,2017-10-17T22:02:47Z,src/nvim/api/private/helpers.c,"@@ -687,6 +703,22 @@ String cstr_to_string(const char *str)     }; } +/// Copies buffer to an allocated String.+/// The resulting string is also NUL-terminated, to facilitate interoperating+/// with code using C strings.+///+/// @param str the buffer to copy+/// @return the resulting String, if the input string was NULL, an+///         empty String is returned+String buf_to_string(const char *buf, size_t len)",- maybe name it `cbuf_to_string` in analogy with the others.- docstring doesn't match the parameter names- I think it's a good pattern to use `size` as the param name if it's a raw buffer size instead of a string length,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/7173,145270149,2017-10-17T22:08:04Z,src/nvim/eval.c,"@@ -11149,15 +11149,23 @@ void get_user_input(const typval_T *const argvars,   // Only the part of the message after the last NL is considered as   // prompt for the command line.   const char *p = strrchr(prompt, '\n');-  if (p == NULL) {+  if (ui_is_external(kUICmdline)) {     p = prompt;   } else {-    p++;-    msg_start();-    msg_clr_eos();-    msg_puts_attr_len(prompt, p - prompt, echo_attr);-    msg_didout = false;-    msg_starthere();+    if (p == NULL) {+      p = prompt;+    } else {+      if (p == NULL) {+        p = prompt;",looks duplicated. `p` can't be null here.,
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/7407,145282533,2017-10-17T23:23:55Z,test/functional/eval/special_vars_spec.lua,"@@ -168,4 +169,11 @@ describe('Special values', function()       'Expected True but got v:null',     }, meths.get_vvar('errors'))   end)++  describe('compat', function()+    it('v:count is distinct from count', function()+      command('let count = v:count + 1')+      neq(eval('count'), eval('v:count'))+    end)+  end)","I would not use `neq`, just set it to list and check that it works as you could not set `v:count` to list. Also good idea to check `eq(1, eval('count is# g:[""count""]'))` and `eq(0, eval('count is# v:count'))` after that.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/6917,146107470,2017-10-21T15:06:33Z,runtime/doc/autocmd.txt,"@@ -263,8 +263,10 @@ Name			triggered by ~  	Startup and exit |VimEnter|		after doing all the startup stuff-|GUIEnter|		after starting the GUI successfully-|GUIFailed|		after starting the GUI failed+|GUIEnter|		never used in Nvim.+|GUIFailed|		never used in Nvim.",should be moved to `deprecated.txt` I think.,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/7412,146143360,2017-10-22T20:35:25Z,test/functional/helpers.lua,"@@ -319,6 +319,7 @@ end -- Dedent the given text and write it to the file name. local function write_file(name, text, dont_dedent)   local file = io.open(name, 'w')+  if file == nil then return false end","Was this silently failing before? If not, it will now, which means we would have to explicitly check `eq(true, write_file())` everywhere.Why don't we raise an error (exception) here instead?",
8740057,janlazo,https://api.github.com/repos/neovim/neovim/pulls/7412,146904379,2017-10-25T15:57:06Z,test/functional/legacy/025_jump_tag_hidden_spec.lua,"@@ -25,12 +23,17 @@ describe('jump to a tag with hidden set', function()     feed_command('set hidden')      -- Create a link from test25.dir to the current directory.-    feed_command('!rm -f test25.dir')-    feed_command('!ln -s . test25.dir')+    if helpers.iswin() then+      feed_command('!rd /q/s test25.dir')",It can't handle directory junctions in Windows and luafilesystem does not support Windows symlinks yet. Best to call `delete()` through nvim or os.execute() and raise an exception if it fails.,
135535,tecywiz121,https://api.github.com/repos/neovim/neovim/pulls/7440,146981023,2017-10-25T20:42:40Z,src/nvim/terminal.c,"@@ -365,6 +365,16 @@ void terminal_resize(Terminal *term, uint16_t width, uint16_t height)   invalidate_terminal(term, -1, -1); } +void terminal_resize_into(Terminal *term, win_T* wp)+{+  int width = wp->w_width;+  if (wp->w_p_nu || wp->w_p_rnu) {+    width -= wp->w_nrwidth + 1;+  }",This is an example of how `w_nrwidth` is calculated:https://github.com/neovim/neovim/blob/56eda2aa17c80ba380b606f9466f288fb8162dd3/src/nvim/screen.c#L691I don't actually see any uses of it besides determining if a redraw needs to happen.,
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/7234,147550543,2017-10-28T09:48:05Z,src/nvim/charset.c,"@@ -1655,88 +1658,66 @@ void vim_str2nr(const char_u *const start, int *const prep, int *const len,        if (what & STR2NR_OCT) {         // Don't interpret ""0"", ""08"" or ""0129"" as octal.-        for (int n = 1; ascii_isdigit(ptr[n]); ++n) {-          if (ptr[n] > '7') {+        for (int i = 1; !STRING_ENDED(ptr + i) && ascii_isdigit(ptr[i]); i++) {+          if (ptr[i] > '7') {             // can't be octal             pre = 0;             break;           }-          if (ptr[n] >= '0') {+          if (ptr[i] >= '0') {",This condition is always true.,
715238,equalsraf,https://api.github.com/repos/neovim/neovim/pulls/6917,147585436,2017-10-29T15:49:33Z,src/nvim/ui_bridge.c,"@@ -88,6 +89,7 @@ UI *ui_bridge_attach(UI *ui, ui_main_fn ui_main, event_scheduler scheduler)   uv_mutex_unlock(&rv->mutex);    ui_attach_impl(&rv->bridge);+  apply_autocmds(EVENT_UIATTACH, NULL, NULL, false, curbuf);",I assume this no longer applies since channel_id is only available in external attachment.,
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/7458,147595734,2017-10-29T21:40:11Z,runtime/autoload/provider/node.vim,"@@ -0,0 +1,82 @@+if exists('g:loaded_node_provider')+  finish+endif+let g:loaded_node_provider = 1++let s:stderr = {}+let s:job_opts = {'rpc': v:true}++function! s:job_opts.on_stderr(chan_id, data, event)","Use provider#stderr_collector, see https://github.com/neovim/neovim/blob/master/runtime/autoload/provider.vim",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/7458,147877783,2017-10-31T01:38:58Z,runtime/autoload/health/provider.vim,"@@ -487,9 +487,71 @@ function! s:check_ruby() abort   endif endfunction +function! s:check_node() abort+  call health#report_start('Node provider (optional)')++  let loaded_var = 'g:loaded_node_provider'+  if exists(loaded_var) && !exists('*provider#node#Call')+    call health#report_info('Disabled. '.loaded_var.'='.eval(loaded_var))+    return+  endif++  if !executable('node') || !executable('npm') || !executable('yarn')+    call health#report_warn(+          \ '`node` and `npm` must be in $PATH.',+          \ ['Install Node.js and verify that `node` and `npm` commands work.'])+    return+  endif+  call health#report_info('Node: '. s:system('node -v'))++  let host = provider#node#Detect()+  if empty(host)+    call health#report_warn('Missing ""neovim"" npm package.',+          \ ['Run in shell: npm install -g neovim',+          \  'Is the npm bin directory in $PATH?'])+    return+  endif+  call health#report_info('Host: '. host)++  let latest_npm_cmd = has('win32') ? 'cmd /c npm info neovim --json' : 'npm info neovim --json'","should not need a separate command for Windows, I believe the ruby check does it that way because of the different quoting. (Though it may possibly be unnecessary there as well, since `system([...])` is called with a list.)",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/7478,148482317,2017-11-02T09:46:36Z,test/functional/api/server_requests_spec.lua,"@@ -304,14 +304,30 @@ describe('server -> client', function()       connect_test(server, 'pipe', address)     end) -    it('via ip address', function()+    it('via ipv4 address', function()       local server = spawn(nvim_argv)       set_session(server)       local address = funcs.serverstart(""127.0.0.1:"")+      if #address == 0 then","If serverstart() returns empty for some other reason, this won't catch the problem.But checking for ipv6 support via the shell is annoying and very platform-dependent. :(",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/7514,149810382,2017-11-08T22:03:44Z,test/unit/path_spec.lua,"@@ -366,134 +366,150 @@ describe('path.c', function()   end)    describe('vim_FullName', function()-    local function vim_FullName(filename, buf, len, force)-      filename = to_cstr(filename)-      return cimp.vim_FullName(filename, buf, len, force)+    -- These variables get reset in before_each().+    local buf+    local do_expand++    local function vim_FullName(path, buflen)+      buf = cstr(buflen, '')+      return cimp.vim_FullName(to_cstr(path), buf, buflen, do_expand)","Lua has multi-return, so this could return `buf, cimp.vim_...`, then `buf` could stay local. And `do_expand` should just be a parameter (as it already was. Not in favor of shared-state to save a couple lines of code; tests especially should lean towards ""explicit, self-contained"" more than ""DRY"").",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/7514,149810964,2017-11-08T22:06:04Z,test/unit/path_spec.lua,"@@ -366,134 +366,150 @@ describe('path.c', function()   end)    describe('vim_FullName', function()-    local function vim_FullName(filename, buf, len, force)-      filename = to_cstr(filename)-      return cimp.vim_FullName(filename, buf, len, force)+    -- These variables get reset in before_each().+    local buf+    local do_expand++    local function vim_FullName(path, buflen)+      buf = cstr(buflen, '')+      return cimp.vim_FullName(to_cstr(path), buf, buflen, do_expand)+    end++    local function get_buf_len(s, t)+      return math.max(string.len(s), string.len(t)) + 1     end      before_each(function()       -- Create empty string buffer which will contain the resulting path.-      length = (string.len(lfs.currentdir())) + 33-      buffer = cstr(length, '')+      buf = cstr(0, '')+      do_expand = 1     end)      itp('fails if given filename is NULL', function()-      local force_expansion = 1-      local result = cimp.vim_FullName(NULL, buffer, length, force_expansion)+      local result = cimp.vim_FullName(NULL, buf, 10, do_expand)       eq(FAIL, result)     end)      itp('fails safely if given length is wrong #5737', function()-      local force_expansion = 1-      local filename = 'foo/bar/bazzzzzzz/buz/aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa/a'+      local path = 'foo/bar/bazzzzzzz/buz/aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa/a'","I intentionally avoid naming variables ""path"" (usually) since (1) it often means $PATH and (2) ""filename"" tends to be more common in most APIs I've seen. Sometimes `filepath` is ok in contexts where ""filename"" means only the tail.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/7518,149912307,2017-11-09T10:01:36Z,runtime/syntax/tex.vim,"@@ -385,7 +385,7 @@ if s:tex_fast =~# 'b'     syn region texBoldItalStyle	matchgroup=texTypeStyle start=""\\textit\s*{"" matchgroup=texTypeStyle  end=""}"" concealends contains=@texItalGroup,@Spell     syn region texItalStyle	matchgroup=texTypeStyle start=""\\textit\s*{"" matchgroup=texTypeStyle  end=""}"" concealends contains=@texItalGroup,@Spell     syn region texItalBoldStyle	matchgroup=texTypeStyle start=""\\textbf\s*{"" matchgroup=texTypeStyle  end=""}"" concealends contains=@texBoldGroup,@Spell-   else                                                                                              +   else","Please don't make stylistic changes to runtime files, no matter how horrible the existing code is. Otherwise it makes merges from Vim more noisy.",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/7477,150152358,2017-11-10T04:31:31Z,test/functional/eval/null_spec.lua,"@@ -42,14 +42,8 @@ describe('NULL', function()   describe('list', function()     -- Incorrect behaviour -    -- FIXME map() should not return 0 without error-    null_expr_test('does not crash map()', 'map(L, ""v:val"")', 0, 0)-    -- FIXME map() should not return 0 without error-    null_expr_test('does not crash filter()', 'filter(L, ""1"")', 0, 0)-    -- FIXME map() should at least return L-    null_expr_test('makes map() return v:_null_list', 'map(L, ""v:val"") is# L', 0, 0)-    -- FIXME filter() should at least return L-    null_expr_test('makes filter() return v:_null_list', 'map(L, ""1"") is# L', 0, 0)+    null_expr_test('makes map() return v:_null_list', 'map(L, ""v:val"") is# L', 0, 1)+    null_expr_test('makes filter() return v:_null_list', 'map(L, ""1"") is# L', 0, 1)","Here is a copy-paste typo, test needs to test filter(). And, BTW, list with OK tests is *below*, in this part only tests that need fixing are located. You may see ���Incorrect behaviour��� comment above.",
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/6844,150381973,2017-11-11T11:34:22Z,src/nvim/buffer_defs.h,"@@ -603,6 +603,7 @@ struct file_buffer {   char_u *b_p_bt;               ///< 'buftype'   int b_has_qf_entry;           ///< quickfix exists for buffer   int b_p_bl;                   ///< 'buflisted'+  long b_p_channel;             ///< 'bomb'",Do we need a bigger type for the channel number or is `INT_MAX` an upper limit that we don't reach?,
117642,lunixbochs,https://api.github.com/repos/neovim/neovim/pulls/5269,151293912,2017-11-16T00:37:45Z,src/nvim/liveupdate.c,"@@ -0,0 +1,195 @@+#include ""nvim/liveupdate.h""+#include ""nvim/memline.h""+#include ""nvim/api/private/helpers.h""+#include ""nvim/msgpack_rpc/channel.h""++// Register a channel. Return True if the channel was added, or already added.+// Return False if the channel couldn't be added because the buffer is+// unloaded.+bool liveupdate_register(buf_T *buf, uint64_t channel_id)+{+  // must fail if the buffer isn't loaded+  if (buf->b_ml.ml_mfp == NULL) {+    return false;+  }++  // count how many channels are currently watching the buffer+  size_t size = kv_size(buf->liveupdate_channels);+  if (size) {+    for (size_t i = 0; i < size; i++) {+      if (kv_A(buf->liveupdate_channels, i) == channel_id) {+        // buffer is already registered ... nothing to do+        return true;+      }+    }+  }++  // append the channelid to the list+  kv_push(buf->liveupdate_channels, channel_id);++  // send through the full channel contents now+  Array linedata = ARRAY_DICT_INIT;","I would very much like a flag to not include (or set to an empty array) the linedata in every LiveUpdateStart notification (ActualVim already knows the entire buffer contents, and I'm just using neovim to track changes to the buffer. Not sending the whole buffer extra times is the entire reason I want a diff system.)",
3629785,phodge,https://api.github.com/repos/neovim/neovim/pulls/5269,151314689,2017-11-16T03:38:50Z,src/nvim/api/buffer.c,"@@ -402,7 +431,7 @@ void nvim_buf_set_lines(uint64_t channel_id,     mark_adjust((linenr_T)start, (linenr_T)(end - 1), MAXLNUM, extra, false);   } -  changed_lines((linenr_T)start, 0, (linenr_T)end, (long)extra);+  changed_lines((linenr_T)start, 0, (linenr_T)end, (long)extra, true);","@lunixbochs: Yes you'll get all your changes back, but I can't think of a simple way to make neovim aware which calls from `buf_set_lines()` are coming from your plugin so that it can skip just those ones.Ultimately it's going to result in double the amount of RPC calls as neovim reflects everything back at you, and while ""double the amount"" seems like a lot, keep in mind that the biggest advantage of live updates isn't even related to the quantity of RPC traffic - the big advantage is that plugins don't need to stop and re-parse the entire buffer contents when only one line or character has changed.",
117642,lunixbochs,https://api.github.com/repos/neovim/neovim/pulls/5269,151318458,2017-11-16T04:23:35Z,src/nvim/api/buffer.c,"@@ -402,7 +431,7 @@ void nvim_buf_set_lines(uint64_t channel_id,     mark_adjust((linenr_T)start, (linenr_T)(end - 1), MAXLNUM, extra, false);   } -  changed_lines((linenr_T)start, 0, (linenr_T)end, (long)extra);+  changed_lines((linenr_T)start, 0, (linenr_T)end, (long)extra, true);","It's far worse than you imagine. It's twice the blocking latency by adding another round trip (latency is barely tolerable as is), and amplifies O(N) where N can be and often is HUGE (there are many cases where I am required to send the entire buffer to neovim, and the entire buffer can be >50MB *and* goes through UTF8 conversion in both directions). Please don't downplay this, I know my use case well and this is extremely bad for my use case. I've benchmarked and had to optimize the hell out of receiving lines from neovim because it was a huge bottleneck in the past. I'd be pretty sad if that hard work went away needlessly.Can we add an optional argument to `nvim_buf_set_lines` with a channel id to not notify? Or an entirely new command? Everyone building/using a buffer-synced vim embed or collab plugin (which I reallllly feel are the main use cases for this) will suffer if this isn't in the API somewhere.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/5269,151339128,2017-11-16T07:46:51Z,src/nvim/api/buffer.c,"@@ -402,7 +431,7 @@ void nvim_buf_set_lines(uint64_t channel_id,     mark_adjust((linenr_T)start, (linenr_T)(end - 1), MAXLNUM, extra, false);   } -  changed_lines((linenr_T)start, 0, (linenr_T)end, (long)extra);+  changed_lines((linenr_T)start, 0, (linenr_T)end, (long)extra, true);","@lunixbochs the notification must not be silently dropped, the sequence of notifications must form a ""single source of truth"" from the nvim side. But we could avoid the text data being sent being echoed back, by adding   an extension where client can provide its own update-id to set_lines, then a further notify _might_ reference this update instead of sending lines back (  ""this change was done in this place in the stream of diffs"") but it also _might  not_, if an error stopped the call from being done (or errored out itself), or the change got coalesced with another change, so the exact diff didn't become part of the stream. But if the usecase only is ""completely resetting the buffer in exceptional cases"", I would expect it to be good enough to call_atomic with three requests, where you turn off updates, do the set_lines overwriting the entire buffer, and turn updates on again. (with the ""no initial update"" flag that needs to be added, of course).",
117642,lunixbochs,https://api.github.com/repos/neovim/neovim/pulls/5269,151342304,2017-11-16T08:08:10Z,src/nvim/api/buffer.c,"@@ -402,7 +431,7 @@ void nvim_buf_set_lines(uint64_t channel_id,     mark_adjust((linenr_T)start, (linenr_T)(end - 1), MAXLNUM, extra, false);   } -  changed_lines((linenr_T)start, 0, (linenr_T)end, (long)extra);+  changed_lines((linenr_T)start, 0, (linenr_T)end, (long)extra, true);","> the sequence of notifications must form a ""single source of truth"" from the nvim sideI vehemently disagree, because in this case *my side* is a valid source of truth. My use case is made vastly simpler by not designing for stuff like embedded terminals and collab plugins from the vim side which will perform unexpected async transformations on the buffer. I understand the tradeoffs and consciously decide to instead completely prevent UI flicker and reduce UI latency (I believe the ActualVim latency is currently somewhere between 3%-16% that of Oni, so I feel pretty vindicated).> if the usecase only is ""completely resetting the buffer in exceptional cases""This is by no means an ""exceptional case"" any more than all of ActualVim is an exceptional case. It does both full and sub-buffer updates from the Sublime side that can happen more than once a second. Toggling LiveUpdate or using placeholder lines don't feel like an acceptable or complete solution because those still cause extra RPC messages when I'm racing latency on the UI thread.I think I will literally never want my `nvim_buf_set_lines` calls to receive a LiveUpdate notification of any kind, and still definitely not containing the line contents. I also think it's not helpful to use a placeholder identifier, because the other plugin channels would know nothing about its contents.Even if you want to guarantee clients with this requirement will preserve ordering, they can just request the buftick after nvim_buf_set_lines using nvim_atomic.",
117642,lunixbochs,https://api.github.com/repos/neovim/neovim/pulls/5269,151342779,2017-11-16T08:11:06Z,src/nvim/api/buffer.c,"@@ -402,7 +431,7 @@ void nvim_buf_set_lines(uint64_t channel_id,     mark_adjust((linenr_T)start, (linenr_T)(end - 1), MAXLNUM, extra, false);   } -  changed_lines((linenr_T)start, 0, (linenr_T)end, (long)extra);+  changed_lines((linenr_T)start, 0, (linenr_T)end, (long)extra, true);","> Also, are you sure utf-8 conversion is needed?Yes. For this specific point, I could special case to drop the update message before the python-client finished decoding it, but (1) that's pretty gross and (2) I'd still have the msgpack-c overhead which is definitely still non-zero for large line counts.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/5269,151350242,2017-11-16T08:50:35Z,src/nvim/api/buffer.c,"@@ -402,7 +431,7 @@ void nvim_buf_set_lines(uint64_t channel_id,     mark_adjust((linenr_T)start, (linenr_T)(end - 1), MAXLNUM, extra, false);   } -  changed_lines((linenr_T)start, 0, (linenr_T)end, (long)extra);+  changed_lines((linenr_T)start, 0, (linenr_T)end, (long)extra, true);","> I vehemently disagree, because in this case my side is a valid source of truth.I just meant how the nvim API should be designed: A single uninterrupted LiveUpdate stream should always give a complete conistent stream of the buffer changes. Then of course actualvim can do whatever, if you know actualvim is the only source of changes apart from core nvim then your approach should work perfectly fine. But the api preferably should be defined in terms of the fully general situation (multiple async sources), and then _optimized_  if need be to also work well for your case.> This is by no means an ""exceptional case"" any more than all of ActualVim is an exceptional case.I meant ""exceptional"" not in judgmental way nor as as statement of relative frequency, just from the consequences: that the previous buffer state could be completely ignored. Only in this ""exceptional"" case the `call_atomic` workaround I suggested would be safe.> I think I will literally never want my nvim_buf_set_lines calls to receive a LiveUpdate notification of any kind, and still definitely not containing the line contents.Right, but if you don't care about it, you do not need to wait for it, and can just silently drop this small notification (it should almost always be ""placeholder"" with your style of interaction I think) if/when it comes. A notification not waited for is not a ""roundtrip"", and shouldn't contribute much to latency.>  I also think it's not helpful to use a placeholder identifier, because the other plugin channels would know nothing about its contents.Of course only the source channel will receive the placeholder, other subscribers will receive full contents.",
79684,billyvg,https://api.github.com/repos/neovim/neovim/pulls/7569,151415659,2017-11-16T13:43:06Z,runtime/autoload/health/provider.vim,"@@ -496,7 +496,7 @@ function! s:check_node() abort     return   endif -  if !executable('node') || !executable('npm') || !executable('yarn')+  if !executable('node') || !executable('npm')","(I updated my commit msg, but not PR msg)* yes, it's highly unlikely you have yarn installed but not npm* we also only try to call `npm`: https://github.com/neovim/neovim/blob/master/runtime/autoload/health/provider.vim#L516",
1523978,peskal,https://api.github.com/repos/neovim/neovim/pulls/7593,152090372,2017-11-20T19:38:13Z,src/nvim/api/private/helpers.c,"@@ -760,12 +761,7 @@ bool object_to_vim(Object obj, typval_T *tv, Error *err)     case kObjectTypeWindow:     case kObjectTypeTabpage:     case kObjectTypeInteger:-      if (obj.data.integer > VARNUMBER_MAX",`VARNUMBER_MAX/MIN` is defined as maximum/minimum possible value of `varnumber_T` variable. `obj.data.integer` and `varnumber_T` are both defined as `int64_t`,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/7591,152416493,2017-11-21T22:12:52Z,src/nvim/testdir/test_alot.vim,"@@ -12,6 +12,7 @@ source test_filter_cmd.vim source test_filter_map.vim source test_float_func.vim source test_functions.vim+source test_ga.vim",should also be added to https://github.com/ckelsel/neovim/blob/1295e460959a1c463e42a3da1d2c8c4b6746de65/src/nvim/testdir/Makefile#L45 That's at least necessary for running single tests via `TEST_FILE=foo.res`.,
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/7593,152425542,2017-11-21T22:56:48Z,src/nvim/api/private/helpers.c,"@@ -760,12 +761,7 @@ bool object_to_vim(Object obj, typval_T *tv, Error *err)     case kObjectTypeWindow:     case kObjectTypeTabpage:     case kObjectTypeInteger:-      if (obj.data.integer > VARNUMBER_MAX-          || obj.data.integer < VARNUMBER_MIN) {-        api_set_error(err, kErrorTypeValidation, ""Integer value outside range"");-        return false;-      }-+      STATIC_ASSERT(sizeof(obj.data.integer) <= sizeof(varnumber_T), ""Expected integer size to be less than or equal to VimL number size"");",Looks like too long line. Below there also is `--n;` which is not going to pass the linter.,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/7422,152687431,2017-11-22T21:56:28Z,src/nvim/globals.h,"@@ -1167,6 +1167,8 @@ EXTERN char_u e_dirnotf[] INIT(= N_( EXTERN char_u e_unsupportedoption[] INIT(= N_(""E519: Option not supported"")); EXTERN char_u e_fnametoolong[] INIT(= N_(""E856: Filename too long"")); EXTERN char_u e_float_as_string[] INIT(= N_(""E806: using Float as a String""));+EXTERN char_u e_autocmd_err[] INIT(=N_(+    ""E920: autocmd has thrown an exception: %s""));","Ah, if you chose it for reason, so be it. No big deal.> Or did we change our channel errors to be the in the same range as vim channel errors?I meant that Vim uses error 920. We don't, until now.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/7633,153050928,2017-11-25T17:55:52Z,src/nvim/fileio.c,"@@ -4448,14 +4448,24 @@ bool vim_fgets(char_u *buf, int size, FILE *fp) FUNC_ATTR_NONNULL_ALL   char tbuf[FGETS_SIZE];    buf[size - 2] = NUL;+retry:+  errno = 0;   eof = fgets((char *)buf, size, fp);+  if (eof == NULL && errno == EINTR) {+    goto retry;+  }   if (buf[size - 2] != NUL && buf[size - 2] != '\n') {     buf[size - 1] = NUL;            /* Truncate the line */      /* Now throw away the rest of the line: */     do {       tbuf[FGETS_SIZE - 2] = NUL;+retry_ignore:+      errno = 0;       ignoredp = fgets((char *)tbuf, FGETS_SIZE, fp);+      if (ignoredp == NULL && errno == EINTR) {+        goto retry_ignore;","technically we're not ignoring the retval now, so `ignoredp` should not be used.",
1835,florolf,https://api.github.com/repos/neovim/neovim/pulls/7676,154507764,2017-12-02T21:41:32Z,src/nvim/tui/tui.c,"@@ -1240,11 +1260,31 @@ static void out(void *ctx, const char *str, size_t len)   size_t available = sizeof(data->buf) - data->bufpos;    if (len > available) {-    flush_buf(ui, false);+    flush_buf(ui);+  }++  memcpy(data->buf + data->bufpos, str, len);+  data->bufpos += len;+}++static void limited_out(void *ctx, const char *str, size_t len)","I didn't want to modify the current users of `out()`, both because this slightly changes the semantics (possibly causing flushes at different points) and requires them to pass a context struct.The semantics part shouldn't be an issue though, so one could reimplement `out()` using `limited_out()` which would reduce duplicated code. I'll do that.Rolling `llimited_out_ctx` into `TUIData` feels slightly wrong because this is local state, but I have no strong opinion on this. If you think this is better stored as part of `TUIData`, I'll move it there. Your call.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/7676,154508962,2017-12-02T22:34:00Z,src/nvim/tui/tui.c,"@@ -1240,11 +1260,31 @@ static void out(void *ctx, const char *str, size_t len)   size_t available = sizeof(data->buf) - data->bufpos;    if (len > available) {-    flush_buf(ui, false);+    flush_buf(ui);+  }++  memcpy(data->buf + data->bufpos, str, len);+  data->bufpos += len;+}++static void limited_out(void *ctx, const char *str, size_t len)","> The semantics part shouldn't be an issue though, so one could reimplement out() using limited_out() which would reduce duplicated code. I'll do that.Ok, will wait for that before merging.> Rolling llimited_out_ctx into TUIData feels slightly wrong because this is local state, but I have no strong opinion on this. If you think this is better stored as part of TUIData, I'll move it there. Your call.Let's leave it as you have it. TUIData has fields like `bufpos`, but what you have is probably clearer and otherwise harmless.",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/7412,154527848,2017-12-03T15:55:02Z,test/unit/helpers.lua,"@@ -468,7 +469,7 @@ else       end       return total_bytes_written     end,-    close = ffi.C.close,+    close = iswin() and io.close or ffi.C.close,","`io.close` is for file objects, error message for `io.close(0)` and `type(io.open(���))` suggests that it is a userdata with `FILE *`. Unless you have a solid idea on how you are going to open pipes it is too early to make this change, and creating process should probably go first.I would also suggest to not add any win32 code here at all, add `elseif iswin()` clause with a whole table above.",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/7695,155348279,2017-12-06T20:13:50Z,src/nvim/eval.c,"@@ -6531,13 +6531,18 @@ static void f_abs(typval_T *argvars, typval_T *rettv, FunPtr fptr) static void f_add(typval_T *argvars, typval_T *rettv, FunPtr fptr) {   list_T      *l;+  const char *const arg_errmsg = N_(""add() argument"");","I see it actually could be used in multiple places. Though I think it is better to remove `else` clause, as well as the check for NULL and add `tv_list_locked` function near `tv_list_len` with similar contents and purpose: in any case I was planning to eventually remove any references outside of typval.[ch] to any list and dictionary internal structure members so it would be possible to play with their implementation.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/7705,155839922,2017-12-08T18:16:34Z,src/nvim/testdir/Makefile,"@@ -10,22 +15,41 @@ export SHELL := sh export NVIM_PRG := $(NVIM_PRG) export TMPDIR -SCRIPTS ?= \-           test13.out             \-           test14.out             \-           test17.out             \-           test24.out             \-           test32.out             \-           test37.out             \-           test40.out             \-           test42.out             \-           test48.out             \-           test49.out             \-           test52.out             \-           test53.out             \-           test64.out             \-           test73.out             \-           test79.out             \+ifeq ($(OS),Windows_NT)+  SCRIPTS ?= \+	test13.out             \+	test14.out             \+	test24.out             \+	test37.out             \+	test40.out             \+	test42.out             \+	test48.out             \+	test49.out             \+	test52.out             \+	test53.out             \+	test64.out             \+	test73.out             \+	test79.out             \++else+  SCRIPTS ?= \","Since this is a superset of the Windows list, can we append to it? Something like:```ifneq ($(OS),Windows_NT)    SCRIPTS := $(SCRIPTS) \      ... \      ...```",
13706192,fvkluck,https://api.github.com/repos/neovim/neovim/pulls/7695,155917026,2017-12-09T09:06:25Z,src/nvim/eval.c,"@@ -6531,13 +6531,18 @@ static void f_abs(typval_T *argvars, typval_T *rettv, FunPtr fptr) static void f_add(typval_T *argvars, typval_T *rettv, FunPtr fptr) {   list_T      *l;+  const char *const arg_errmsg = N_(""add() argument"");","I have two questions regarding this comment:First about removing the else clause: I'm not sure to which occurrence of `tv_list_len` you refer. My interpretation currently is that instead of the current if {if something/else error} else error, you would like the errors in f_add to be grouped right? So more like if () {error} else {perform actions}. Is this what you mean?Second about 'misusing' `tv_check_fixed` to generate an error using `VAR_FIXED`. I could duplicate the define of 'E742' from the `tv_check_fixed` to the top of eval.c, where `e_listreq` is also defined (and perhaps sort those on error number), and then replace all those misuses, reducing the amount of calls to tv_ functions by 3. Do you like the idea?",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/7695,155917327,2017-12-09T09:27:04Z,src/nvim/eval.c,"@@ -6531,13 +6531,18 @@ static void f_abs(typval_T *argvars, typval_T *rettv, FunPtr fptr) static void f_add(typval_T *argvars, typval_T *rettv, FunPtr fptr) {   list_T      *l;+  const char *const arg_errmsg = N_(""add() argument"");","You added only one else to this function, it can be removed if you replace `l->lv_lock` with (to be created) `tv_list_locked` and remove the NULL check above. Do not duplicate the define, use `tv_check_lock`, but only once.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/7706,155934922,2017-12-09T23:43:29Z,test/functional/provider/node_spec.lua,"@@ -15,3 +19,22 @@ end before_each(function()   clear() end)++describe('node host', function()","Let's use ""nodejs"" everywhere possible. Reduces ambiguity when grepping, etc.",
8740057,janlazo,https://api.github.com/repos/neovim/neovim/pulls/7706,155935087,2017-12-09T23:54:43Z,test/functional/provider/node_spec.lua,"@@ -15,3 +19,22 @@ end before_each(function()   clear() end)++describe('node host', function()","""node"" is used in https://github.com/neovim/neovim/blob/master/runtime/autoload/provider/node.vim and `rplugin/node`.",
972014,mhinz,https://api.github.com/repos/neovim/neovim/pulls/7704,155935750,2017-12-10T00:47:45Z,src/nvim/CMakeLists.txt,"@@ -13,6 +13,9 @@ endif() if(WIN32)   # tell MinGW compiler to enable wmain   set(CMAKE_EXE_LINKER_FLAGS ""${CMAKE_EXE_LINKER_FLAGS} -municode"")+elseif(CMAKE_SYSTEM_NAME STREQUAL ""Darwin"")+  set(CMAKE_EXE_LINKER_FLAGS ""${CMAKE_EXE_LINKER_FLAGS} -framework Foundation"")+  set(CMAKE_SHARED_LINKER_FLAGS ""${CMAKE_SHARED_LINKER_FLAGS} -framework Foundation"")","Sorry, my bad. It has to be `CoreFoundation`, not `Foundation`. Both exist, but the former is the low-level C API and the latter is a huge ObjC framework.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/7714,155958840,2017-12-10T20:20:28Z,runtime/autoload/download.lua,"@@ -0,0 +1,41 @@+basepath = ""http://ftp.vim.org/pub/vim/runtime/spell/""+spell_home = ""~/.config/nvim/spell/""++--[+-- Checks if a file or directory exists.+-- ]+function exists(path)","Nvim already has very robust solution for this (`:help filereadable()`, `:help isdirectory()`), there is no reason to re-implement it in Lua.All VimL functions/commands/etc. can be called via `vim.api` from Lua. See `:help api` for the list of API functions.",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/7695,155998080,2017-12-11T07:28:21Z,src/nvim/eval.c,"@@ -14503,7 +14508,9 @@ static void f_setline(typval_T *argvars, typval_T *rettv, FunPtr fptr)   const char *line = NULL;   if (argvars[1].v_type == VAR_LIST) {     l = argvars[1].vval.v_list;-    li = l->lv_first;+    if (l != NULL) {+      li = l->lv_first;+    }","This will prevent a crash, but `echo setline(1, [])` will still be different from `echo setline(1, v:_null_list)` (latter will yield error).",
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/7708,156338791,2017-12-12T11:24:04Z,src/nvim/eval/typval.c,"@@ -339,12 +402,12 @@ void tv_list_append_list(list_T *const list, list_T *const itemlist) {   listitem_T *const li = tv_list_item_alloc(); -  li->li_tv.v_type = VAR_LIST;-  li->li_tv.v_lock = VAR_UNLOCKED;-  li->li_tv.vval.v_list = itemlist;+  TV_LIST_ITEM_TV(li)->v_type = VAR_LIST;+  TV_LIST_ITEM_TV(li)->v_lock = VAR_UNLOCKED;+  TV_LIST_ITEM_TV(li)->vval.v_list = itemlist;   tv_list_append(list, li);   if (itemlist != NULL) {","Could be removed, `tv_list_ref()` checks also for `NULL`.",
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/7708,156343133,2017-12-12T11:45:08Z,src/nvim/eval/typval.c,"@@ -632,18 +693,45 @@ bool tv_list_equal(list_T *const l1, list_T *const l2, const bool ic,     return false;   } -  listitem_T *item1 = l1->lv_first;-  listitem_T *item2 = l2->lv_first;+  listitem_T *item1 = tv_list_first(l1);+  listitem_T *item2 = tv_list_first(l2);   for (; item1 != NULL && item2 != NULL-       ; item1 = item1->li_next, item2 = item2->li_next) {-    if (!tv_equal(&item1->li_tv, &item2->li_tv, ic, recursive)) {+       ; (item1 = TV_LIST_ITEM_NEXT(l1, item1),+          item2 = TV_LIST_ITEM_NEXT(n2, item2))) {",Wrong list name: `n2` -> `l2`.,
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/7708,156352500,2017-12-12T12:30:05Z,src/nvim/quickfix.c,"@@ -4399,7 +4403,7 @@ void ex_cexpr(exarg_T *eap)   typval_T tv;   if (eval0(eap->arg, &tv, NULL, true) != FAIL) {     if ((tv.v_type == VAR_STRING && tv.vval.v_string != NULL)-        || (tv.v_type == VAR_LIST && tv.vval.v_list != NULL)) {+        || tv.v_type == VAR_LIST) {",Does `eval0()` returns a list that is not `NULL`?,
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/7708,156365852,2017-12-12T13:33:45Z,src/nvim/eval/encode.c,"@@ -135,21 +136,22 @@ static int conv_error(const char *const msg, const MPConvStack *const mpstack,       }       case kMPConvPairs:       case kMPConvList: {-        int idx = 0;-        const listitem_T *li;-        for (li = v.data.l.list->lv_first;-             li != NULL && li->li_next != v.data.l.li;-             li = li->li_next) {-          idx++;-        }+        const listitem_T *const li = (v.data.l.li == NULL+                                      ? tv_list_last(v.data.l.list)","In this case we could compute the value of `idx` directly (`MAX(tv_list_len(v.data.l.list)-1,0)`).",
460034,qvacua,https://api.github.com/repos/neovim/neovim/pulls/7520,156739244,2017-12-13T18:14:10Z,src/nvim/ui_bridge.c,"@@ -144,6 +145,29 @@ static void ui_bridge_highlight_set_event(void **argv)   xfree(argv[1]); } +static void ui_bridge_option_set(UI *ui, String name, Object value)+{+  // Assumes bridge is only used by TUI","@justinmk @bfredl VimR actually uses the bridge. I only recently started to use the MsgPack API for some non-UI related tasks like getting the list of buffers. Probably VimR should also use the UI MsgPack API, but since I do not plan to implement externalization of widgets anytime soon, it has very low priority... I'll try to use/implement `option_set` and come back here if I run into problems. ����",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/7708,157086462,2017-12-14T23:04:59Z,src/nvim/eval/typval.c,"@@ -772,15 +855,14 @@ long tv_list_idx_of_item(const list_T *const l, const listitem_T *const item)   if (l == NULL) {     return -1;   }-  long idx = 0;-  const listitem_T *li;-  for (li = l->lv_first; li != NULL && li != item; li = li->li_next) {+  int idx = 0;+  TV_LIST_ITER_CONST(l, li, {+    if (li == item) {+      return idx;+    }     idx++;-  }-  if (li == NULL) {-    return -1;-  }-  return idx;+  });+  return -1;","Not now. I have no idea why original functions have `long` type (AFAIR I got that from Vim), but that will for sure raise a bunch of warnings.",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/7708,157086827,2017-12-14T23:06:57Z,src/nvim/quickfix.c,"@@ -4399,7 +4403,7 @@ void ex_cexpr(exarg_T *eap)   typval_T tv;   if (eval0(eap->arg, &tv, NULL, true) != FAIL) {     if ((tv.v_type == VAR_STRING && tv.vval.v_string != NULL)-        || (tv.v_type == VAR_LIST && tv.vval.v_list != NULL)) {+        || tv.v_type == VAR_LIST) {","? It could return either list, removal of this check makes it sure that NULL list is processed like empty one.",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/7708,157088891,2017-12-14T23:20:40Z,src/nvim/eval/typval.c,"@@ -439,33 +502,32 @@ list_T *tv_list_copy(const vimconv_T *const conv, list_T *const orig,   }    list_T *copy = tv_list_alloc();+  tv_list_ref(copy);   if (copyID != 0) {     // Do this before adding the items, because one of the items may     // refer back to this list.     orig->lv_copyID = copyID;     orig->lv_copylist = copy;   }-  listitem_T *item;-  for (item = orig->lv_first; item != NULL && !got_int;-       item = item->li_next) {+  TV_LIST_ITER(orig, item, {","It appears that I can have got_int check here, but it is not exactly useful:```local helpers = require('test.functional.helpers')(after_each)local command = helpers.commandlocal meths = helpers.methslocal clear = helpers.clearlocal funcs = helpers.funcslocal sleep = helpers.sleeplocal wait = helpers.waitlocal feed = helpers.feedlocal eq = helpers.eqlocal screenlocal durlocal min_dur = 8local len = 131072describe('List support code', function()  before_each(function()    clear()    if dur == nil then      dur = 0      while true do        command(([[          let rt = reltime()          let bl = range(%u)          let dur = reltimestr(reltime(rt))        ]]):format(len))        dur = tonumber(meths.get_var('dur'))        if dur >= min_dur then          print(('Using len %u, dur %g'):format(len, dur))          break        else          len = len * 2        end      end    end  end)  it('allows interrupting copy', function()    feed(':let t_rt = reltime()<CR>:let t_bl = copy(bl)<CR>')    sleep(min_dur / 16 * 1000)    feed('<C-c>')    wait()    command('let t_dur = reltimestr(reltime(t_rt))')    local t_dur = tonumber(meths.get_var('t_dur'))    if t_dur >= dur / 8 then      eq(nil, ('Took too long to cancel: %g >= %g'):format(t_dur, dur / 8))    end  end)end)```with got_int check added always fails. Manual testing confirms that copy() accually runs *slower*  when cancelled because the only thing it does cancel is an assignment, which ultimately means that big list needs to be freed before continuing.Test succeeds if I not only add `if (got_int) break;` but also `os_breakcheck()`.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/7706,157150887,2017-12-15T09:05:04Z,test/functional/provider/nodejs_spec.lua,"@@ -0,0 +1,68 @@+local helpers = require('test.functional.helpers')(after_each)+local eq, clear = helpers.eq, helpers.clear+local missing_provider = helpers.missing_provider+local command = helpers.command+local write_file = helpers.write_file+local eval = helpers.eval+local sleep = helpers.sleep+local funcs = helpers.funcs++do+  clear()+  if missing_provider('node') then+    pending(+      ""Cannot find the neovim nodejs host. Try :checkhealth"",+      function() end)+    return+  end+end++before_each(function()+  clear()+end)++describe('nodejs', function()+  it('can inspect', function()+    eq(1, funcs['provider#node#can_inspect']())+  end)+end)++describe('nodejs host', function()+  it('works', function()+    local fname = 'hello.js'","Test files always begin with ""Xtest"", and should be somewhat ""namespaced"" (to track down badly-behaving tests).    local fname = 'Xtest-nodejs-hello.js'This helps things like `make clean`, and avoids overwriting files that might be in the dev's workspace.",
8740057,janlazo,https://api.github.com/repos/neovim/neovim/pulls/7706,157220609,2017-12-15T15:02:05Z,test/functional/provider/nodejs_spec.lua,"@@ -0,0 +1,68 @@+local helpers = require('test.functional.helpers')(after_each)+local eq, clear = helpers.eq, helpers.clear+local missing_provider = helpers.missing_provider+local command = helpers.command+local write_file = helpers.write_file+local eval = helpers.eval+local sleep = helpers.sleep+local funcs = helpers.funcs++do+  clear()+  if missing_provider('node') then+    pending(+      ""Cannot find the neovim nodejs host. Try :checkhealth"",+      function() end)+    return+  end+end++before_each(function()+  clear()+end)++describe('nodejs', function()+  it('can inspect', function()+    eq(1, funcs['provider#node#can_inspect']())+  end)+end)++describe('nodejs host', function()+  it('works', function()+    local fname = 'hello.js'+    write_file(fname, [[+      const socket = process.env.NVIM_LISTEN_ADDRESS;+      const neovim = require('neovim');+      const nvim = neovim.attach({socket: socket});+      nvim.command('let g:job_out = ""hello""');+      nvim.command('call jobstop(g:job_id)');+    ]])+    command('let g:job_id = jobstart([""node"", ""'..fname..'""])')+    sleep(5000)+    eq('hello', eval('g:job_out'))+    os.remove(fname)",Perhaps teardown is better to guarantee deletion for all temporary test files.,
8740057,janlazo,https://api.github.com/repos/neovim/neovim/pulls/7706,157224201,2017-12-15T15:17:16Z,ci/run_tests.sh,"@@ -23,6 +23,7 @@ if test ""$CLANG_SANITIZER"" != ""TSAN"" ; then   # Additional threads are only created when the builtin UI starts, which   # doesn't happen in the unit/functional tests   run_test run_unittests+  export NODE_PATH=""$(npm root -g)""","I think plugin authors are expected to locally install the neovim npm package as a dependency in `package.json` to avoid global `require()`. The test cases I've created use the API directly instead of the relying on the host ([bin/cli.js](https://github.com/neovim/node-client/blob/master/bin/cli.js)) so `NODE_PATH` must be set.I wonder if there's a way to break up the npm package into host-only (end users, global install) and plugin-only (plugin authors, local install) without source code duplication.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/7706,157338338,2017-12-16T09:34:44Z,runtime/autoload/health/provider.vim,"@@ -502,7 +502,14 @@ function! s:check_node() abort           \ ['Install Node.js and verify that `node` and `npm` commands work.'])     return   endif-  call health#report_info('Node: '. s:system('node -v'))+  let node_v = get(split(s:system('node -v'), ""\n""), 0, '')+  call health#report_info('Node: '. node_v)+  if !s:shell_error && s:version_cmp(node_v[1:], '6.0.0') < 0+    call health#report_warn('nodejs host does not support '.node_v)+  endif+  if has('win32') || !provider#node#can_inspect()+    call health#report_warn('nodejs on this system does not support --inspect-brk or this system is Windows so $NVIM_NODE_HOST_DEBUG is ignored.')","The message is getting too long, there's not much reason to use the same message when we can trivially check if we're on Windows.```vimif has('win32')  call health#report_warn('nodejs on Windows does not support --inspect-brk. $NVIM_NODE_HOST_DEBUG will be ignored.')elseif !provider#node#can_inspect()  call health#report_warn('nodejs on this system does not support --inspect-brk. $NVIM_NODE_HOST_DEBUG will be ignored.')endif```",
8740057,janlazo,https://api.github.com/repos/neovim/neovim/pulls/7706,157345173,2017-12-16T16:13:55Z,runtime/autoload/health/provider.vim,"@@ -502,7 +502,14 @@ function! s:check_node() abort           \ ['Install Node.js and verify that `node` and `npm` commands work.'])     return   endif-  call health#report_info('Node: '. s:system('node -v'))+  let node_v = get(split(s:system('node -v'), ""\n""), 0, '')+  call health#report_info('Node: '. node_v)+  if !s:shell_error && s:version_cmp(node_v[1:], '6.0.0') < 0+    call health#report_warn('nodejs host does not support '.node_v)+  endif+  if has('win32') || !provider#node#can_inspect()+    call health#report_warn('nodejs on this system does not support --inspect-brk or this system is Windows so $NVIM_NODE_HOST_DEBUG is ignored.')","As long as the version requirement is reached, `--inspect-brk` works on Windows.The problem is that you cannot pass this to `node` through the shims.```sh# Ignore the shims and run cli.js directlynode $PREV  ""$(npm root -g)/neovim/bin/cli.js"" $NEXT```Without calling `node` directly, the user can't set `$PREV`. Passing arguments through the shim is for `$NEXT`.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/7706,157350113,2017-12-16T20:08:11Z,runtime/autoload/health/provider.vim,"@@ -502,7 +502,14 @@ function! s:check_node() abort           \ ['Install Node.js and verify that `node` and `npm` commands work.'])     return   endif-  call health#report_info('Node: '. s:system('node -v'))+  let node_v = get(split(s:system('node -v'), ""\n""), 0, '')+  call health#report_info('Node: '. node_v)+  if !s:shell_error && s:version_cmp(node_v[1:], '6.0.0') < 0+    call health#report_warn('nodejs host does not support '.node_v)","Users are going to be confused, most don't know that ""nodejs host"" is something different than actual ""nodejs"". It's a bit of mess, but for user-facing messages we should say ""Neovim node-client"" (the literal repo name) or ""Neovim nodejs host"".This is why `:help dev-api-client` now says very clearly:```Package Naming                                                                                                                                                  API client packages should NOT be named something ambiguous like ""neovim"" or                                                                                    ""python-client"".  Use ""nvim"" as a prefix/suffix to some other identifier                                                                                        following ecosystem conventions. ```",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/7706,157351911,2017-12-16T21:47:49Z,test/functional/provider/nodejs_spec.lua,"@@ -20,12 +20,7 @@ end  before_each(function()   clear()-end)--describe('nodejs', function()-  it('can inspect', function()-    eq(1, funcs['provider#node#can_inspect']())-  end)+  command([[let $NODE_PATH = get(split(system('npm root -g'), ""\n""), 0, '')]])",Why not use systemlist() instead of split(system())?,
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/7708,157362520,2017-12-17T09:03:26Z,src/nvim/eval.c,"@@ -8936,7 +8968,7 @@ static void common_function(typval_T *argvars, typval_T *rettv,           goto theend;         }         list = argvars[arg_idx].vval.v_list;-        if (list == NULL || list->lv_len == 0) {+        if (list == NULL || tv_list_len(list) == 0) {",`list == NULL` could be removed.,
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/7708,157362778,2017-12-17T09:16:22Z,src/nvim/eval.c,"@@ -11025,39 +11055,40 @@ static void f_indent(typval_T *argvars, typval_T *rettv, FunPtr fptr)  */ static void f_index(typval_T *argvars, typval_T *rettv, FunPtr fptr) {-  list_T      *l;-  listitem_T  *item;   long idx = 0;-  int ic = FALSE;+  bool ic = false;    rettv->vval.v_number = -1;   if (argvars[0].v_type != VAR_LIST) {     EMSG(_(e_listreq));     return;   }-  l = argvars[0].vval.v_list;+  list_T *const l = argvars[0].vval.v_list;   if (l != NULL) {-    item = l->lv_first;+    listitem_T *item = tv_list_first(l);     if (argvars[2].v_type != VAR_UNKNOWN) {       bool error = false;        // Start at specified item.  Use the cached index that tv_list_find()       // sets, so that a negative number also works.-      item = tv_list_find(l, tv_get_number_chk(&argvars[2], &error));-      idx = l->lv_idx;-      if (argvars[3].v_type != VAR_UNKNOWN) {-        ic = tv_get_number_chk(&argvars[3], &error);-      }-      if (error) {+      idx = tv_list_uidx(l, tv_get_number_chk(&argvars[2], &error));",Why not only error check `tv_get_number_chk()` here and let `tv_list_find()` handle the normalization and error handling?,
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/7708,157366358,2017-12-17T12:09:22Z,src/nvim/eval.c,"@@ -11025,39 +11055,40 @@ static void f_indent(typval_T *argvars, typval_T *rettv, FunPtr fptr)  */ static void f_index(typval_T *argvars, typval_T *rettv, FunPtr fptr) {-  list_T      *l;-  listitem_T  *item;   long idx = 0;-  int ic = FALSE;+  bool ic = false;    rettv->vval.v_number = -1;   if (argvars[0].v_type != VAR_LIST) {     EMSG(_(e_listreq));     return;   }-  l = argvars[0].vval.v_list;+  list_T *const l = argvars[0].vval.v_list;   if (l != NULL) {-    item = l->lv_first;+    listitem_T *item = tv_list_first(l);     if (argvars[2].v_type != VAR_UNKNOWN) {       bool error = false;        // Start at specified item.  Use the cached index that tv_list_find()       // sets, so that a negative number also works.-      item = tv_list_find(l, tv_get_number_chk(&argvars[2], &error));-      idx = l->lv_idx;-      if (argvars[3].v_type != VAR_UNKNOWN) {-        ic = tv_get_number_chk(&argvars[3], &error);-      }-      if (error) {+      idx = tv_list_uidx(l, tv_get_number_chk(&argvars[2], &error));",And how I am to get the number to return exactly? `tv_list_find()` does not return one and I was not feeling like refactoring it to have ret_idx argument as it is useful in two places out of 18 tv_list_find is being used.,
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/7708,157366613,2017-12-17T12:22:06Z,src/nvim/eval.c,"@@ -15432,34 +15440,25 @@ static void do_sort_uniq(typval_T *argvars, typval_T *rettv, bool sort)       info.item_compare_func_err = false;       if (info.item_compare_func != NULL           || info.item_compare_partial != NULL) {-          item_compare_func_ptr = item_compare2_keeping_zero;+        item_compare_func_ptr = item_compare2_keeping_zero;       } else {-          item_compare_func_ptr = item_compare_keeping_zero;-      }--      for (li = l->lv_first; li != NULL && li->li_next != NULL; li = li->li_next) {-        if (item_compare_func_ptr(&li, &li->li_next) == 0) {-          ptrs[i++].item = li;-        }-        if (info.item_compare_func_err) {-          EMSG(_(""E882: Uniq compare function failed""));-          break;-        }+        item_compare_func_ptr = item_compare_keeping_zero;       } -      if (!info.item_compare_func_err) {-        while (--i >= 0) {-          assert(ptrs[i].item->li_next);-          li = ptrs[i].item->li_next;-          ptrs[i].item->li_next = li->li_next;-          if (li->li_next != NULL) {-            li->li_next->li_prev = ptrs[i].item;-          } else {-            l->lv_last = ptrs[i].item;+      int idx = 0;+      for (listitem_T *li = TV_LIST_ITEM_NEXT(l, tv_list_first(l))+           ; li != NULL+           ; li = TV_LIST_ITEM_NEXT(l, li)) {+        listitem_T *const prev_li = TV_LIST_ITEM_PREV(l, li);+        if (item_compare_func_ptr(&prev_li, &li) == 0) {+          if (info.item_compare_func_err) {+            EMSG(_(""E882: Uniq compare function failed""));+            break;           }-          tv_list_watch_fix(l, li);-          tv_list_item_free(li);-          l->lv_len--;+          tv_list_item_remove(l, li);+          li = tv_list_find(l, idx);","No, it will actually be invalid after removal. Not invalid *with the current implementation*, but invalid with array-based list implementation that may trigger realloc() at removal. I know that this is suboptimal, but I also know that `uniq()` is almost never used.",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/7708,157367178,2017-12-17T12:48:36Z,src/nvim/eval.c,"@@ -15432,34 +15440,25 @@ static void do_sort_uniq(typval_T *argvars, typval_T *rettv, bool sort)       info.item_compare_func_err = false;       if (info.item_compare_func != NULL           || info.item_compare_partial != NULL) {-          item_compare_func_ptr = item_compare2_keeping_zero;+        item_compare_func_ptr = item_compare2_keeping_zero;       } else {-          item_compare_func_ptr = item_compare_keeping_zero;-      }--      for (li = l->lv_first; li != NULL && li->li_next != NULL; li = li->li_next) {-        if (item_compare_func_ptr(&li, &li->li_next) == 0) {-          ptrs[i++].item = li;-        }-        if (info.item_compare_func_err) {-          EMSG(_(""E882: Uniq compare function failed""));-          break;-        }+        item_compare_func_ptr = item_compare_keeping_zero;       } -      if (!info.item_compare_func_err) {-        while (--i >= 0) {-          assert(ptrs[i].item->li_next);-          li = ptrs[i].item->li_next;-          ptrs[i].item->li_next = li->li_next;-          if (li->li_next != NULL) {-            li->li_next->li_prev = ptrs[i].item;-          } else {-            l->lv_last = ptrs[i].item;+      int idx = 0;+      for (listitem_T *li = TV_LIST_ITEM_NEXT(l, tv_list_first(l))+           ; li != NULL+           ; li = TV_LIST_ITEM_NEXT(l, li)) {+        listitem_T *const prev_li = TV_LIST_ITEM_PREV(l, li);+        if (item_compare_func_ptr(&prev_li, &li) == 0) {+          if (info.item_compare_func_err) {+            EMSG(_(""E882: Uniq compare function failed""));+            break;           }-          tv_list_watch_fix(l, li);-          tv_list_item_free(li);-          l->lv_len--;+          tv_list_item_remove(l, li);+          li = tv_list_find(l, idx);","After searching for uniq() calls in the plugins that happened to be in my ~/.vam I found exactly *one* user of actual uniq() (that is, neosnippet) and a bunch of uniq() implementations based on dictionary (those that do not do sorting), though I do not quite understand WTF author was thinking when writing such code as```function! deoplete#util#uniq(list) abort  let list = map(copy(a:list), '[v:val, v:val]')  let i = 0  let seen = {}  while i < len(list)    let key = string(list[i][1])    if has_key(seen, key)      call remove(list, i)    else      let seen[key] = 1      let i += 1    endif  endwhile  return map(list, 'v:val[0]')endfunction```(it is not only deoplete, same thing is copied over in some other plugins). (Basically, what I do not understand is what the first and last map()s are for, from my POV you can just copy list over and do remove().)",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/7708,157367569,2017-12-17T13:06:51Z,src/nvim/eval.c,"@@ -15432,34 +15440,25 @@ static void do_sort_uniq(typval_T *argvars, typval_T *rettv, bool sort)       info.item_compare_func_err = false;       if (info.item_compare_func != NULL           || info.item_compare_partial != NULL) {-          item_compare_func_ptr = item_compare2_keeping_zero;+        item_compare_func_ptr = item_compare2_keeping_zero;       } else {-          item_compare_func_ptr = item_compare_keeping_zero;-      }--      for (li = l->lv_first; li != NULL && li->li_next != NULL; li = li->li_next) {-        if (item_compare_func_ptr(&li, &li->li_next) == 0) {-          ptrs[i++].item = li;-        }-        if (info.item_compare_func_err) {-          EMSG(_(""E882: Uniq compare function failed""));-          break;-        }+        item_compare_func_ptr = item_compare_keeping_zero;       } -      if (!info.item_compare_func_err) {-        while (--i >= 0) {-          assert(ptrs[i].item->li_next);-          li = ptrs[i].item->li_next;-          ptrs[i].item->li_next = li->li_next;-          if (li->li_next != NULL) {-            li->li_next->li_prev = ptrs[i].item;-          } else {-            l->lv_last = ptrs[i].item;+      int idx = 0;+      for (listitem_T *li = TV_LIST_ITEM_NEXT(l, tv_list_first(l))+           ; li != NULL+           ; li = TV_LIST_ITEM_NEXT(l, li)) {+        listitem_T *const prev_li = TV_LIST_ITEM_PREV(l, li);+        if (item_compare_func_ptr(&prev_li, &li) == 0) {+          if (info.item_compare_func_err) {+            EMSG(_(""E882: Uniq compare function failed""));+            break;           }-          tv_list_watch_fix(l, li);-          tv_list_item_free(li);-          l->lv_len--;+          tv_list_item_remove(l, li);+          li = tv_list_find(l, idx);","Oh, I remembered that I actually bothered to clone all repositories from https://github.com/vim-scripts once in Jun 18, may search that for uniq(). The following is all what `ag` managed to find there:```% ag '^\s*(?!"")\S.*(?<![#a-zA-Z0-9.]|\b\w:)\buniq\(' -G '.*\.vim' ../vim-scripts | tee uniqs.lst../vim-scripts/AmbiCompletion.git/plugin/ambicompletion.vim:151:            call uniq(candidates)../vim-scripts/AmbiCompletion.git/plugin/ambicompletion.vim:316:        call uniq(cachewords)../vim-scripts/AmbiCompletion.git/plugin/ambicompletion.vim:355:        call uniq(cachewords)../vim-scripts/changesPlugin.git/autoload/changes.vim:783:          call uniq(b:diffhl[i])../vim-scripts/changesPlugin.git/autoload/changes.vim:1283:     let lines = uniq(lines)../vim-scripts/changesPlugin.git/autoload/changes.vim:1347:         let g:lines=uniq(g:lines)../vim-scripts/clickable.vim.git/autoload/vital/_clickable_vim.vim:265:    return uniq(a:list)../vim-scripts/cmake.vim--Alcin.git/autoload/cmake/extension.vim:49:../vim-scripts/cmake.vim--Alcin.git/autoload/cmake/extension.vim:50:  call uniq(l:signatures)../vim-scripts/cmake.vim--Alcin.git/autoload/cmake/extension/ninja.vim:47:  call uniq(l:flags)../vim-scripts/cmake.vim--Alcin.git/autoload/cmake/extension/ninja.vim:117:  call uniq(l:ninja_file_lines)../vim-scripts/columnmove.git/autoload/vital/_columnmove.vim:265:    return uniq(a:list)../vim-scripts/ctrlp-locate.git/autoload/vital/_ctrlp_locate.vim:276:    return uniq(a:list)../vim-scripts/Dutyl.git/autoload/dutyl/util.vim:81:        return uniq(sort(a:list))../vim-scripts/incsearch.vim.git/autoload/vital/_incsearch.vim:282:    return uniq(a:list)../vim-scripts/ingo-library.git/autoload/ingo/compat.vim:93:    return uniq(a:list)../vim-scripts/open-browser.vim.git/autoload/vital/_openbrowser.vim:265:    return uniq(a:list)../vim-scripts/projectionist.vim.git/autoload/projectionist.vim:29:    return uniq(a:list)../vim-scripts/tsuquyomi.git/autoload/vital/_tsuquyomi.vim:266:    return uniq(a:list)../vim-scripts/unite-spell-suggest.git/autoload/mklib/string.vim:142:  return a:0 && a:1 ? uniq(sort(l:parts)) : l:parts../vim-scripts/vim-gista.git/autoload/vital/_vim_gista.vim:247:    return uniq(a:list)../vim-scripts/vim-javacomplete2.git/autoload/javacomplete/server.vim:15:    return uniq(a:list)../vim-scripts/vim-operator-flashy.git/autoload/vital/_operator_flashy.vim:272:    return uniq(a:list)../vim-scripts/vim-pandoc-bundle.git/autoload/pandoc/command.vim:72:            return filter(uniq(extend(sort(short_opts), sort(long_opts))), 'v:val != ""-:""')../vim-scripts/vim-signjk-motion.git/autoload/vital/_signjk.vim:272:    return uniq(a:list)../vim-scripts/vim-snoopy.git/autoload/vital/_snoopy.vim:266:    return uniq(a:list)../vim-scripts/vison.git/autoload/vital/_vison.vim:266:    return uniq(a:list)```",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/7732,157371992,2017-12-17T15:51:09Z,scripts/vim-patch.sh,"@@ -108,22 +111,23 @@ assign_commit_details() {     vim_tag=""v${1}""     vim_commit=$(cd ""${VIM_SOURCE_DIR}"" \       && git log -1 --format=""%H"" ""${vim_tag}"")-    local strip_commit_line=true+    local munge_commit_line=true   else     # Interpret parameter as commit hash.     vim_version=""${1:0:12}""+    vim_tag=     vim_commit=$(cd ""${VIM_SOURCE_DIR}"" \       && git log -1 --format=""%H"" ""${vim_version}"")-    local strip_commit_line=false+    local munge_commit_line=false   fi    vim_commit_url=""https://github.com/vim/vim/commit/${vim_commit}""   vim_message=""$(cd ""${VIM_SOURCE_DIR}"" \     && git log -1 --pretty='format:%B' ""${vim_commit}"" \       | sed -e 's/\(#[0-9]*\)/vim\/vim\1/g')""-  if [[ ${strip_commit_line} == ""true"" ]]; then+  if [[ ${munge_commit_line} == ""true"" ]]; then     # Remove first line of commit message.-    vim_message=""$(echo ""${vim_message}"" | sed -e '1d')""+    vim_message=""$(echo ""${vim_message}"" | sed -e '1s/^patch /vim-patch:/')""","Is this dependent on Bram never changing the message format? In particular, we never want whitespace after `vim-patch:` token.",
112971,jamessan,https://api.github.com/repos/neovim/neovim/pulls/7732,157373556,2017-12-17T16:48:07Z,scripts/vim-patch.sh,"@@ -108,22 +111,23 @@ assign_commit_details() {     vim_tag=""v${1}""     vim_commit=$(cd ""${VIM_SOURCE_DIR}"" \       && git log -1 --format=""%H"" ""${vim_tag}"")-    local strip_commit_line=true+    local munge_commit_line=true   else     # Interpret parameter as commit hash.     vim_version=""${1:0:12}""+    vim_tag=     vim_commit=$(cd ""${VIM_SOURCE_DIR}"" \       && git log -1 --format=""%H"" ""${vim_version}"")-    local strip_commit_line=false+    local munge_commit_line=false   fi    vim_commit_url=""https://github.com/vim/vim/commit/${vim_commit}""   vim_message=""$(cd ""${VIM_SOURCE_DIR}"" \     && git log -1 --pretty='format:%B' ""${vim_commit}"" \       | sed -e 's/\(#[0-9]*\)/vim\/vim\1/g')""-  if [[ ${strip_commit_line} == ""true"" ]]; then+  if [[ ${munge_commit_line} == ""true"" ]]; then     # Remove first line of commit message.-    vim_message=""$(echo ""${vim_message}"" | sed -e '1d')""+    vim_message=""$(echo ""${vim_message}"" | sed -e '1s/^patch /vim-patch:/')""",He has a script that handles this.  It [looks like](https://gist.github.com/jamessan/0c8e3770f83c7a3d9eaa204e55eb4245) we're good.  The last 1300 patches or so don't violate that format.,
8740057,janlazo,https://api.github.com/repos/neovim/neovim/pulls/7734,157378663,2017-12-17T20:19:05Z,runtime/autoload/provider/node.vim,"@@ -5,35 +5,53 @@ let g:loaded_node_provider = 1  let s:job_opts = {'rpc': v:true, 'on_stderr': function('provider#stderr_collector')} +function! s:is_minimum_version(version, min_major, min_minor) abort+  let nodejs_version = a:version+  if !a:version+    let nodejs_version = get(split(system(['node', '-v']), ""\n""), 0, '')+    if v:shell_error || nodejs_version[0] !=# 'v'+      return 0+    endif+  endif+  "" [major, minor, patch]+  let v_list = !!a:version ? a:version : split(nodejs_version[1:], '\.')+  return len(v_list) == 3+    \ && ((str2nr(v_list[0]) > str2nr(a:min_major))+    \     || (str2nr(v_list[0]) == str2nr(a:min_major)+    \         && str2nr(v_list[1]) >= str2nr(a:min_minor)))+endfunction+ "" Support for --inspect-brk requires node 6.12+ or 7.6+ or 8+ "" Return 1 if it is supported "" Return 0 otherwise-function! provider#node#can_inspect()+function! provider#node#can_inspect() abort   if !executable('node')     return 0   endif-  let node_v = get(split(system(['node', '-v']), ""\n""), 0, '')-  if v:shell_error || node_v[0] !=# 'v'+  let ver = get(split(system(['node', '-v']), ""\n""), 0, '')+  if v:shell_error || ver[0] !=# 'v'     return 0   endif-  "" [major, minor, patch]-  let node_v = split(node_v[1:], '\.')-  return len(node_v) == 3 && (-  \ (node_v[0] > 7) ||-  \ (node_v[0] == 7 && node_v[1] >= 6) ||-  \ (node_v[0] == 6 && node_v[1] >= 12)-  \ )+  return (ver[1] ==# '6' && s:is_minimum_version(ver, 6, 12))","Perhaps it's simpler to pass the raw version string and unconditionally split it to get the [major, minor,patch] version list.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/7734,157379143,2017-12-17T20:38:55Z,runtime/autoload/provider/node.vim,"@@ -5,35 +5,53 @@ let g:loaded_node_provider = 1  let s:job_opts = {'rpc': v:true, 'on_stderr': function('provider#stderr_collector')} +function! s:is_minimum_version(version, min_major, min_minor) abort+  let nodejs_version = a:version+  if !a:version+    let nodejs_version = get(split(system(['node', '-v']), ""\n""), 0, '')+    if v:shell_error || nodejs_version[0] !=# 'v'+      return 0+    endif+  endif+  "" [major, minor, patch]+  let v_list = !!a:version ? a:version : split(nodejs_version[1:], '\.')+  return len(v_list) == 3+    \ && ((str2nr(v_list[0]) > str2nr(a:min_major))+    \     || (str2nr(v_list[0]) == str2nr(a:min_major)+    \         && str2nr(v_list[1]) >= str2nr(a:min_minor)))+endfunction+ "" Support for --inspect-brk requires node 6.12+ or 7.6+ or 8+ "" Return 1 if it is supported "" Return 0 otherwise-function! provider#node#can_inspect()+function! provider#node#can_inspect() abort   if !executable('node')     return 0   endif-  let node_v = get(split(system(['node', '-v']), ""\n""), 0, '')-  if v:shell_error || node_v[0] !=# 'v'+  let ver = get(split(system(['node', '-v']), ""\n""), 0, '')+  if v:shell_error || ver[0] !=# 'v'     return 0   endif-  "" [major, minor, patch]-  let node_v = split(node_v[1:], '\.')-  return len(node_v) == 3 && (-  \ (node_v[0] > 7) ||-  \ (node_v[0] == 7 && node_v[1] >= 6) ||-  \ (node_v[0] == 6 && node_v[1] >= 12)-  \ )+  return (ver[1] ==# '6' && s:is_minimum_version(ver, 6, 12))","> Why are you not passing split(ver[1:], '\.')?We already have too much similar code duplicated in various places (e.g. health/provider.vim). Was trying to avoid even more duplication.Ultimately I would like to add a built-in function that offers this functionality.",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/7710,158579378,2017-12-23T08:58:34Z,test/functional/fixtures/tty-test.c,"@@ -34,6 +33,18 @@ bool owns_tty(void) #endif } +static inline bool is_terminal(const FILE * stream1) +    __attribute__((always_inline)) __attribute__ ((pure)) __attribute__((warn_unused_result));++/**+ * Checks if the file pointer is not a terminal like STDIN or STDOUT + * @param[in] stream to be checked+ * @return bool+ */+static inline bool is_terminal(const FILE * stream){","There are lots of style guide violations and things that won���t work here:1. You need to include nvim/func_attr.h to have REAL_FATTR available. And correct approach would be using FUNC_ATTR��� and no declarations since you are in a C file, but include header with generated declarations. But as files in test/functional/fixtures are compiled differently I am not sure whether ���correct��� approach will work at all.2. `fileno()` does not accept pointers to const memory. So argument type should be `FILE *const` or there should be a cast below, but latter is theoretically dangerous.3. We are not using `/*`-style comments.4. `{` on the same line as function declaration is not correct either, do you see any other functions below like this?5. Should have no space after asterisk.6. Indentation shift witdth is 2, not 4. Applies to two lines here.7. Do not add useless `@return bool`, doxygen does include function declarations.8. Two spaces after `[in]`, two spaces after `stream`, blank line between `@param` and summary (also between `@param` and `@return`), and correct sentense in parameter description. Though it is better to not have `@param` as well, only function summary is enough.And there should not be a big bunch of commits with merges, such small PRs better be rebased.",
10484881,aparavind,https://api.github.com/repos/neovim/neovim/pulls/7710,158587427,2017-12-23T18:59:40Z,test/functional/fixtures/tty-test.c,"@@ -34,6 +33,18 @@ bool owns_tty(void) #endif } +static inline bool is_terminal(const FILE * stream1) +    __attribute__((always_inline)) __attribute__ ((pure)) __attribute__((warn_unused_result));++/**+ * Checks if the file pointer is not a terminal like STDIN or STDOUT + * @param[in] stream to be checked+ * @return bool+ */+static inline bool is_terminal(const FILE * stream){",I Have made the changes and committed them. Pls review once so that i can take up further on a similar note.,
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/7710,158587804,2017-12-23T19:27:41Z,src/nvim/ex_eval.c,"@@ -68,7 +68,16 @@ #define THROW_ON_INTERRUPT true #define THROW_ON_INTERRUPT_TRUE -#define discard_pending_return(p) tv_free((typval_T *)(p))+static inline void discard_pending_return(void *p)+  REAL_FATTR_ALWAYS_INLINE REAL_FATTR_PURE;++// Free allocated VimL object and value stored inside+// @param[in]  p  the pointer to typval_T object",Missing blank line before starting parameter documentation.,
10180857,nhooyr,https://api.github.com/repos/neovim/neovim/pulls/7623,158590924,2017-12-23T23:33:05Z,runtime/lua/man.lua,"@@ -0,0 +1,141 @@+local function highlight_formatted(line, linenr)+  local chars = {}+  local prev_char = ''+  local overstrike, escape = false, false+  local hls = {} -- Store highlight groups as { attr, start, end }+  local NONE, BOLD, UNDERLINE, ITALIC = 0, 1, 2, 3+  local hl_groups = {[BOLD]=""manBold"", [UNDERLINE]=""manUnderline"", [ITALIC]=""manItalic""}+  local attr = NONE+  local byte = 0 -- byte offset++  local function end_attr_hl(attr)+    for i, hl in ipairs(hls) do+      if hl[1] == attr and hl[3] == -1 then+        hl[3] = byte+        hls[i] = hl+      end+    end+  end++  local function add_attr_hl(code)+    local on = true+    if code == 0 then+      attr = NONE+      on = false+    elseif code == 1 then+      attr = BOLD+    elseif code == 21 or code == 22 then+      attr = BOLD+      on = false+    elseif code == 3 then+      attr = ITALIC+    elseif code == 23 then+      attr = ITALIC+      on = false+    elseif code == 4 then+      attr = UNDERLINE+    elseif code == 24 then+      attr = UNDERLINE+      on = false+    else+      attr = NONE+      return+    end++    if on then+      hls[#hls + 1] = {attr, byte, -1}+    else+      if attr == NONE then+        for a, _ in pairs(hl_groups) do+          end_attr_hl(a)+        end+      else+        end_attr_hl(attr)+      end+    end+  end++  -- Break input into UTF8 characters+  for char in line:gmatch(""[^\128-\191][\128-\191]*"") do","Why do we need that pattern? Why not just `"".""` as the pattern?",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/7714,158598721,2017-12-24T10:14:11Z,runtime/autoload/download.lua,"@@ -0,0 +1,41 @@+basepath = ""http://ftp.vim.org/pub/vim/runtime/spell/""+spell_home = ""~/.config/nvim/spell/""++--[+-- Checks if a file or directory exists.+-- ]+function exists(path)+  local file = os.execute(""test -f ""..path)+  local dir = os.execute(""test -d ""..path)+  return (dir or file) == true+end++--[+-- Downloads a specific language file from the vim servers.+-- @Asserts correct lang, spell_home, basepath and internett connection.+--]+function download(url, dest)+  if exists(spell_home..lang) then+    print(""file exists"")+  else+    if not io.popen(""which curl &> /dev/null"") then","Do not use lua built-in library here at all, VimL functions like `executable()`, `system([���])` (note: with argument list in order to not bother with escaping), `mkdir()`, `isdirectory()` are better suited here. These are available via API (vim.api.nvim_call_function), but I would suggest to drop lua completely and use VimL instead, this is not a thing which is easier to write in lua.Basically you must run exactly one command: curl. For everything else there is VimL function. And run it via `system()`.",
1683303,keidax,https://api.github.com/repos/neovim/neovim/pulls/7623,158605716,2017-12-24T16:32:36Z,runtime/lua/man.lua,"@@ -0,0 +1,141 @@+local function highlight_formatted(line, linenr)+  local chars = {}+  local prev_char = ''+  local overstrike, escape = false, false+  local hls = {} -- Store highlight groups as { attr, start, end }+  local NONE, BOLD, UNDERLINE, ITALIC = 0, 1, 2, 3+  local hl_groups = {[BOLD]=""manBold"", [UNDERLINE]=""manUnderline"", [ITALIC]=""manItalic""}+  local attr = NONE+  local byte = 0 -- byte offset++  local function end_attr_hl(attr)+    for i, hl in ipairs(hls) do+      if hl[1] == attr and hl[3] == -1 then+        hl[3] = byte+        hls[i] = hl+      end+    end+  end++  local function add_attr_hl(code)+    local on = true+    if code == 0 then+      attr = NONE+      on = false+    elseif code == 1 then+      attr = BOLD+    elseif code == 21 or code == 22 then","Good point. I was looking at the [Wikipedia page](https://en.wikipedia.org/wiki/ANSI_escape_code#SGR_.28Select_Graphic_Rendition.29_parameters) which indicates ""Bold off or Double Underline"". I never saw 21 used anywhere, so I'll drop it.",
1683303,keidax,https://api.github.com/repos/neovim/neovim/pulls/7623,158605958,2017-12-24T16:45:33Z,runtime/lua/man.lua,"@@ -0,0 +1,141 @@+local function highlight_formatted(line, linenr)+  local chars = {}+  local prev_char = ''+  local overstrike, escape = false, false+  local hls = {} -- Store highlight groups as { attr, start, end }+  local NONE, BOLD, UNDERLINE, ITALIC = 0, 1, 2, 3+  local hl_groups = {[BOLD]=""manBold"", [UNDERLINE]=""manUnderline"", [ITALIC]=""manItalic""}+  local attr = NONE+  local byte = 0 -- byte offset++  local function end_attr_hl(attr)+    for i, hl in ipairs(hls) do+      if hl[1] == attr and hl[3] == -1 then+        hl[3] = byte+        hls[i] = hl+      end+    end+  end++  local function add_attr_hl(code)+    local on = true+    if code == 0 then+      attr = NONE+      on = false+    elseif code == 1 then+      attr = BOLD+    elseif code == 21 or code == 22 then+      attr = BOLD+      on = false+    elseif code == 3 then+      attr = ITALIC+    elseif code == 23 then+      attr = ITALIC+      on = false+    elseif code == 4 then+      attr = UNDERLINE+    elseif code == 24 then+      attr = UNDERLINE+      on = false+    else+      attr = NONE+      return+    end++    if on then+      hls[#hls + 1] = {attr, byte, -1}+    else+      if attr == NONE then+        for a, _ in pairs(hl_groups) do+          end_attr_hl(a)+        end+      else+        end_attr_hl(attr)+      end+    end+  end++  -- Break input into UTF8 characters+  for char in line:gmatch(""[^\128-\191][\128-\191]*"") do","`"".""` will just match a single byte. But the input is encoded as UTF-8, so matching one byte at a time won't work if any characters fall outside of the ASCII range. [More details here.](https://stackoverflow.com/a/15980690/910109)_Side note: I've only ever seen UTF-8, but I wonder if other encodings would be possible based on terminal/locale settings? If so, would likely need some sort of Lua string library to deal with._",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/7623,158609858,2017-12-24T21:22:17Z,runtime/lua/man.lua,"@@ -0,0 +1,141 @@+local function highlight_formatted(line, linenr)+  local chars = {}+  local prev_char = ''+  local overstrike, escape = false, false+  local hls = {} -- Store highlight groups as { attr, start, end }+  local NONE, BOLD, UNDERLINE, ITALIC = 0, 1, 2, 3+  local hl_groups = {[BOLD]=""manBold"", [UNDERLINE]=""manUnderline"", [ITALIC]=""manItalic""}+  local attr = NONE+  local byte = 0 -- byte offset++  local function end_attr_hl(attr)+    for i, hl in ipairs(hls) do+      if hl[1] == attr and hl[3] == -1 then+        hl[3] = byte+        hls[i] = hl+      end+    end+  end++  local function add_attr_hl(code)+    local on = true+    if code == 0 then+      attr = NONE+      on = false+    elseif code == 1 then+      attr = BOLD+    elseif code == 21 or code == 22 then+      attr = BOLD+      on = false+    elseif code == 3 then+      attr = ITALIC+    elseif code == 23 then+      attr = ITALIC+      on = false+    elseif code == 4 then+      attr = UNDERLINE+    elseif code == 24 then+      attr = UNDERLINE+      on = false+    else+      attr = NONE+      return+    end++    if on then+      hls[#hls + 1] = {attr, byte, -1}+    else+      if attr == NONE then+        for a, _ in pairs(hl_groups) do+          end_attr_hl(a)+        end+      else+        end_attr_hl(attr)+      end+    end+  end++  -- Break input into UTF8 characters+  for char in line:gmatch(""[^\128-\191][\128-\191]*"") do","As long as all Ctrl chars are ASCII, which I strongly suspect in man format, segmenting UTF-8 codepoints (which not unambiguously is ""chars"" anyway) shouldn't be needed. The highlight API only cares about bytes anyway.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/7623,158609928,2017-12-24T21:28:37Z,test/functional/plugin/man_spec.lua,"@@ -0,0 +1,181 @@+local helpers = require('test.functional.helpers')(after_each)+local plugin_helpers = require('test.functional.plugin.helpers')++local Screen = require('test.functional.ui.screen')++local buffer, command, eval = helpers.buffer, helpers.command, helpers.eval++before_each(function()+  plugin_helpers.reset()+  helpers.clear()+  command('syntax on')+  command('set filetype=man')+end)++describe('In autoload/man.vim', function()+  describe('function man#highlight_formatted_text', function()+    local screen++    before_each(function()+      command('syntax off') -- Ignore syntax groups+      screen = Screen.new(52, 5)+      screen:attach()+    end)++    after_each(function()+      screen:detach()+    end)++    local function expect(string)+      screen:expect(string,+      {+        b = { bold = true },+        i = { italic = true },+        u = { underline = true },+        bi = { bold = true, italic = true },+        biu = { bold = true, italic = true, underline = true },+      },+      {{ bold = true, foreground = Screen.colors.Blue }})+    end++    local function expect_without_highlights(string)",This is an anti-pattern. Just use `screen:snapshot_util()` and it will capture highlighting with not much extra work,
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/7762,158646987,2017-12-25T14:56:09Z,src/nvim/lua/converter.c,"@@ -212,19 +212,27 @@ bool nlua_pop_typval(lua_State *lstate, typval_T *ret_tv)           const char *s = lua_tolstring(lstate, -2, &len);           if (cur.special) {             list_T *const kv_pair = tv_list_alloc();+             tv_list_append_list(cur.tv->vval.v_list, kv_pair);-            listitem_T *const key = tv_list_item_alloc();-            *TV_LIST_ITEM_TV(key) = decode_string(s, len, kTrue, false, false);-            tv_list_append(kv_pair, key);-            if (TV_LIST_ITEM_TV(key)->v_type == VAR_UNKNOWN) {+            typval_T s_tv = decode_string(s, len, kTrue, false, false);+            if (s_tv.v_type == VAR_UNKNOWN) {               ret = false;               tv_list_unref(kv_pair);",Is it okay to free the list `kv_pair` but keep it as an item in the list `cur.tv->vval.v_list`?,
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/7762,158649263,2017-12-25T16:00:05Z,src/nvim/eval.c,"@@ -12211,24 +12216,36 @@ static void find_some_match(typval_T *argvars, typval_T *rettv, int type)   p_cpo = (char_u *)"""";    rettv->vval.v_number = -1;-  if (type == 3 || type == 4) {-    // type 3: return empty list when there are no matches.-    // type 4: return ["""", -1, -1, -1]-    tv_list_alloc_ret(rettv);-    if (type == 4) {+  switch (type) {+    // matchlist(): return empty list when there are no matches.+    case kSomeMatchList: {+      tv_list_alloc_ret(rettv);+      FALLTHROUGH;+    }+    // matchstrpos(): return ["""", -1, -1, -1]+    case kSomeMatchStrPos: {",In this case `tv_list_alloc_ret(rettv)` was not called.,
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/7762,158650220,2017-12-25T16:32:02Z,src/nvim/eval.c,"@@ -13131,16 +13155,13 @@ static void f_readfile(typval_T *argvars, typval_T *rettv, FunPtr fptr)     }   }   /* while */ -  /*-   * For a negative line count use only the lines at the end of the file,-   * free the rest.-   */-  if (maxline < 0)-    while (cnt > -maxline) {-      tv_list_item_remove(rettv->vval.v_list,-                          tv_list_first(rettv->vval.v_list));-      cnt--;-    }+  // For a negative line count use only the lines at the end of the file,+  // free the rest.+  if (maxline < -tv_list_len(rettv->vval.v_list)) {+    listitem_T *const first_li = tv_list_find(rettv->vval.v_list, maxline);+    listitem_T *const last_li = tv_list_last(rettv->vval.v_list);+    tv_list_remove_items(rettv->vval.v_list, first_li, last_li);",Here the last items of the list are removed. In the old code the first items were removed.,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/6856,159001504,2017-12-28T21:33:25Z,runtime/lua/lsp/structures.lua,"@@ -0,0 +1,117 @@+local lsp_util = require('runtime.lua.lsp.util')","drive-by comment: `runtime.lua.lsp.util` looks too nested, possibly a sign of over-architecture. Hyper-categorization is bad enough, but sub-categories and sub-sub-categories are rarely needed. I think we already have too many subdirectories in Nvim source. We should try to keep things relatively flat.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/6856,159001677,2017-12-28T21:35:07Z,runtime/lua/lsp/structures.lua,"@@ -0,0 +1,117 @@+local lsp_util = require('runtime.lua.lsp.util')","In fact the LSP support should be _one_ big file, with truly _common_ utilities in _one_ separate file (call it `foo.lua`, doesn't matter: again, _one_ big file, we can nitpick over naming/placement later). ""Common"" means ""can be used by any other Lua code, not just LSP"".",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/6856,159001798,2017-12-28T21:36:23Z,runtime/lua/lsp/structures.lua,"@@ -0,0 +1,117 @@+local lsp_util = require('runtime.lua.lsp.util')",The most important thing to avoid is shared state. The line count of a file doesn't mean anything as long as there is minimal or no shared global or pseudo-global state.,
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/6856,159003917,2017-12-28T22:00:06Z,runtime/lua/lsp/structures.lua,"@@ -0,0 +1,117 @@+local lsp_util = require('runtime.lua.lsp.util')",I think it looks too nested only because it's wrong: it should be `require('lsp.util')`. That wouldn't seem too bad?,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/7795,159139055,2017-12-31T12:15:29Z,runtime/doc/options.txt,"@@ -2712,6 +2712,10 @@ A jump table for the options with a short description can be found at |Q_op|. 		:s///g		  subst. one	  subst. all 		:s///gg		  subst. all	  subst. one +	DEPRECATED: Setting this option may break plugins that are not aware",Should also add it to deprecated.txt,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/7795,159141971,2017-12-31T15:03:20Z,runtime/doc/deprecated.txt,"@@ -48,8 +48,10 @@ Modifiers ~ *:map-special*		<> notation is always enabled. |cpo-<|  Options ~+*'gd'*+*'gdefault'*		Enables the |:substitute| flag 'g' by default.",Should not be a tag  unless the other entry was moved here entirely. In the meantime it's ok just to mention it here.,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/5031,159156278,2018-01-01T13:51:17Z,src/nvim/api/buffer.c,"@@ -738,6 +742,223 @@ ArrayOf(Integer, 2) nvim_buf_get_mark(Buffer buffer, String name, Error *err)   return rv; } +/// Returns extended mark info for a given mark identifier+/// If no mark is found, returns an empty list.+///+/// If an invalid namespace or buffer is given, an error will be+/// raised and 0 returned.+///+/// @param buffer The buffer handle+/// @param namespace a identifier returned previously with nvim_create_namespace+/// @param id any mark identifier that uniquely selects a mark (no positions)+/// @param[out] err Details of an error that may have occurred+/// @return [mark_id, row, col]+ArrayOf(Object) nvim_buf_lookup_mark(Buffer buffer,","""lookup"" is new jargon without a clear reason. `get` or `get_by_foo` or `find` would be better.`nvim_buf_get_mark` already exists, it is meaningless to differentiate API functions by synonyms (""get"" vs ""lookup""). If a new function has the same semantics as an existing one, one should just admit it and append a number (`nvim_buf_get_mark2`).I would suggest `nvim_buf_get_ns_mark` or `nvim_buf_get_mark2`. ""find"" wouldn't be the right verb here because it's not a search, it's an index (AKA lookup, AKA `get`).",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/5031,159156362,2018-01-01T13:55:42Z,src/nvim/api/buffer.c,"@@ -738,6 +742,223 @@ ArrayOf(Integer, 2) nvim_buf_get_mark(Buffer buffer, String name, Error *err)   return rv; } +/// Returns extended mark info for a given mark identifier+/// If no mark is found, returns an empty list.+///+/// If an invalid namespace or buffer is given, an error will be+/// raised and 0 returned.","Is ""0 returned"" still correct? Above it says ""If no mark is found, returns an empty list"".",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/5031,159156459,2018-01-01T14:00:47Z,src/nvim/api/buffer.c,"@@ -738,6 +742,223 @@ ArrayOf(Integer, 2) nvim_buf_get_mark(Buffer buffer, String name, Error *err)   return rv; } +/// Returns extended mark info for a given mark identifier+/// If no mark is found, returns an empty list.+///+/// If an invalid namespace or buffer is given, an error will be+/// raised and 0 returned.+///+/// @param buffer The buffer handle+/// @param namespace a identifier returned previously with nvim_create_namespace+/// @param id any mark identifier that uniquely selects a mark (no positions)+/// @param[out] err Details of an error that may have occurred+/// @return [mark_id, row, col]+ArrayOf(Object) nvim_buf_lookup_mark(Buffer buffer,+                                     Integer namespace,+                                     Integer id,+                                     Error *err)+    FUNC_API_SINCE(3)+{+  Array rv = ARRAY_DICT_INIT;++  buf_T *buf = find_buffer_by_handle(buffer, err);++  if (!buf) {+    return rv;+  }++  if (!ns_initialized((uint64_t)namespace)) {+    api_set_error(err, kErrorTypeValidation, _(""Invalid mark namespace""));+    return rv;+  }++  ExtendedMark *extmark = extmark_from_id(buf,+                                          (uint64_t)namespace,+                                          (uint64_t)id);+  if (!extmark) {+    return rv;+  }+  ADD(rv, INTEGER_OBJ((Integer)extmark->mark_id));+  ADD(rv, INTEGER_OBJ((Integer)extmark->line->lnum));+  ADD(rv, INTEGER_OBJ((Integer)extmark->col));+  return rv;+}++/// Returns extended mark info in a range (inclusive)+/// If no marks are found, returns an empty list.+///+/// If an invalid namespace or buffer is given, an error will be+/// raised and 0 returned.+///+/// @param buffer The buffer handle+/// @param namespace An id returned previously from nvim_create_namespace+/// @param lower One of: extended mark id, (row, col) or -1 for start of buffer+/// @param upper One of: extended mark id, (row, col) or -1 for end of buffer+/// @param amount Maximum number of marks to return or -1 for all marks found+/// @param reverse Boolean to switch the search direction.+/// /// @param[out] err Details of an error that may have occurred+/// @return [[mark_id, row, col], ...]+ArrayOf(Object) nvim_buf_get_marks(Buffer buffer,+                                   Integer namespace,+                                   Object lower,+                                   Object upper,+                                   Integer amount,+                                   Boolean reverse,+                                   Error *err)+    FUNC_API_SINCE(3)+{+  Array rv = ARRAY_DICT_INIT;++  buf_T *buf = find_buffer_by_handle(buffer, err);++  if (!buf) {+    return rv;+  }++  if (!ns_initialized((uint64_t)namespace)) {+    api_set_error(err, kErrorTypeValidation, _(""Invalid mark namespace""));+    return rv;+  }++  if (amount == 0) {+    return rv;+  }++  linenr_T l_lnum;+  colnr_T l_col;+  if (!set_extmark_index_from_obj(buffer, namespace, lower, &l_lnum, &l_col,+                                  err)) {+    return rv;+  }++  linenr_T u_lnum;+  colnr_T u_col;+  if (!set_extmark_index_from_obj(buffer, namespace, upper, &u_lnum, &u_col,+                                  err)) {+    return rv;+  }++  // TODO: assert lower <= upper++  ExtendedMark *extmark;+  Array mark = ARRAY_DICT_INIT;++  // Range Query+  ExtmarkArray extmarks_in_range;++  extmarks_in_range = extmark_get(buf,+                                  (uint64_t)namespace,+                                  l_lnum,+                                  l_col,+                                  u_lnum,+                                  u_col,+                                  (int64_t)amount,+                                  reverse ? BACKWARD: FORWARD);++  size_t n = kv_size(extmarks_in_range);+  for (size_t i = 0; i < n; i++) {+    mark.size = 0;+    mark.capacity = 0;+    mark.items = 0;+    extmark = kv_A(extmarks_in_range, i);+    ADD(mark, INTEGER_OBJ((Integer)extmark->mark_id));+    ADD(mark, INTEGER_OBJ(extmark->line->lnum));+    ADD(mark, INTEGER_OBJ(extmark->col));+    ADD(rv, ARRAY_OBJ(mark));+  }+  kv_destroy(extmarks_in_range);+  return rv;++}++/// Create or update an extended mark at a position+///+/// If an invalid namespace or buffer is given, an error will be+/// raised and 0 returned.+///+/// @param buffer The buffer handle+/// @param namespace a identifier returned previously with nvim_create_namespace+/// @param id The extended mark's id or 0 for a randomly generated id+/// @param row The row to set the extended mark to.+/// @param col The column to set the extended mark to.+/// @param[out] err Details of an error that may have occurred+/// @return 1 on new, 2 on update; or a mark_id if argument mark_id was 0+Integer nvim_buf_set_mark(Buffer buffer,+                          Integer namespace,+                          Integer mark_id,+                          Integer row,+                          Integer col,+                          Error *err)+    FUNC_API_SINCE(3)+{+  Integer rv = 0;+  buf_T *buf = find_buffer_by_handle(buffer, err);++  if (!buf) {+    return rv;+  }+  if (!ns_initialized((uint64_t)namespace)) {+    api_set_error(err, kErrorTypeValidation, _(""Invalid mark namespace""));+    return rv;+  }+  if (row < 1 || col < 1) {+    api_set_error(err, kErrorTypeValidation, _(""Row and column must be greater than 0""));+    return rv;+  }++  bool return_id = false;+  uint64_t id;+  if (mark_id == 0) {+    id = extmark_free_id_get(buf, (uint64_t)namespace);+    return_id = true;+  } else if (mark_id > 0) {+    id = (uint64_t)mark_id;+  } else {+    api_set_error(err, kErrorTypeValidation, _(""Invalid mark id""));+    return rv;+  }++  rv = (Integer)extmark_set(buf, (uint64_t)namespace, id,+                            (linenr_T)row, (colnr_T)col, kExtmarkUndo);+  if (return_id) {+    return (Integer)id;+  } else {+    return rv;+  }+}++/// Remove an extended mark+///+/// If an invalid namespace or buffer is given, an error will be+/// raised and 0 returned.+///+/// @param buffer The buffer handle+/// @param namespace a identifier returned previously with nvim_create_namespace+/// @param id The extended mark's id+/// @param[out] err Details of an error that may have occurred+/// @return 1 on success, 0 on no mark found+Integer nvim_buf_unset_mark(Buffer buffer,","See `:help dev-api` for function naming guidelines.Currently in the API we have `clear` as a verb (`nvim_buf_clear_highlight`) and `del`. I don't think we need `unset` or `remove`, so pick one of `del` or `clear`.    nvim_buf_del_extmark",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/5031,159157182,2018-01-01T14:46:02Z,src/nvim/api/buffer.c,"@@ -738,6 +742,223 @@ ArrayOf(Integer, 2) nvim_buf_get_mark(Buffer buffer, String name, Error *err)   return rv; } +/// Returns extended mark info for a given mark identifier+/// If no mark is found, returns an empty list.+///+/// If an invalid namespace or buffer is given, an error will be+/// raised and 0 returned.+///+/// @param buffer The buffer handle+/// @param namespace a identifier returned previously with nvim_create_namespace+/// @param id any mark identifier that uniquely selects a mark (no positions)+/// @param[out] err Details of an error that may have occurred+/// @return [mark_id, row, col]+ArrayOf(Object) nvim_buf_lookup_mark(Buffer buffer,","We probably want a proper noun to use consistently in both overview docs and API, to distinguish them from ordinary (named) marks. Either `extmark` or `nsmark` as was suggested, but if the later then we should call them ""namespaced marks"" and not ""extended marks"" in docs. `nvim_buf_get_mark2` is ambiguous if its just the function that's different and not the marks, similarly with `mark_info` (which sounds more like returning a dict with info about marks in general, traditional and extended)",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/5031,159157285,2018-01-01T14:51:29Z,src/nvim/api/buffer.c,"@@ -738,6 +742,223 @@ ArrayOf(Integer, 2) nvim_buf_get_mark(Buffer buffer, String name, Error *err)   return rv; } +/// Returns extended mark info for a given mark identifier+/// If no mark is found, returns an empty list.+///+/// If an invalid namespace or buffer is given, an error will be+/// raised and 0 returned.","also, if error is raised, sentinel value must be returned (empty list) and not mentioned in docs, as it is redundant. Also ""if invalid buffer is given an error will raised"" should not be mentioned, this behavior is shared among all buffer functions.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/5031,159157466,2018-01-01T15:01:47Z,src/nvim/api/buffer.c,"@@ -738,6 +742,223 @@ ArrayOf(Integer, 2) nvim_buf_get_mark(Buffer buffer, String name, Error *err)   return rv; } +/// Returns extended mark info for a given mark identifier+/// If no mark is found, returns an empty list.+///+/// If an invalid namespace or buffer is given, an error will be+/// raised and 0 returned.","No, `ARRAY_DICT_INIT` is returned. And it is only returned as a detail of C API, semantically nothing is returned, and so it should not be mentioned at each and every function...",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/7812,159858216,2018-01-05T11:37:20Z,test/functional/shada/helpers.lua,"@@ -37,8 +37,6 @@ local function add_argv(...) end  local clear = function()-  os.execute('cp ' .. tmpname .. ' /tmp/test.shada')-  os.remove(tmpname)",The whole reason of `cp` was because `os.remove` *must* be there for cleanup. If removing `os.remove` will not fail some tests I would be surprised. But in any case this is one of temporary files to be removed.,
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/7821,160033284,2018-01-06T19:43:02Z,src/nvim/api/vim.c,"@@ -207,18 +208,38 @@ String nvim_replace_termcodes(String str, Boolean from_part, Boolean do_lt,   return cstr_as_string(ptr); } -String nvim_command_output(String str, Error *err)+/// Executes an ex-command and returns its (non-error) output.+/// Shell |:!| output is not captured.+///+/// On parse error: forwards the Vim error; does not update v:errmsg.+/// On runtime error: forwards the Vim error; does not update v:errmsg.+///+/// @param command  Ex-command string+/// @param[out] err Error details (Vim error), if any+String nvim_command_output(String command, Error *err)   FUNC_API_SINCE(1) {-  do_cmdline_cmd(""redir => v:command_output"");-  nvim_command(str, err);-  do_cmdline_cmd(""redir END"");+  Array args = ARRAY_DICT_INIT;+  ADD(args, STRING_OBJ(command));+  ADD(args, STRING_OBJ(cstr_as_string(""silent""))); +  Object rv = nvim_call_function(cstr_as_string(""execute""), args, err);",Creating typvals directly is simpler and cleared than first creating API values only to be converted to typvals. So you replaced a meaningful (and standard pattern) dance with a meaningless dance.,
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/7821,160033383,2018-01-06T19:49:04Z,src/nvim/api/vim.c,"@@ -207,18 +208,38 @@ String nvim_replace_termcodes(String str, Boolean from_part, Boolean do_lt,   return cstr_as_string(ptr); } -String nvim_command_output(String str, Error *err)+/// Executes an ex-command and returns its (non-error) output.+/// Shell |:!| output is not captured.+///+/// On parse error: forwards the Vim error; does not update v:errmsg.+/// On runtime error: forwards the Vim error; does not update v:errmsg.+///+/// @param command  Ex-command string+/// @param[out] err Error details (Vim error), if any+String nvim_command_output(String command, Error *err)   FUNC_API_SINCE(1) {-  do_cmdline_cmd(""redir => v:command_output"");-  nvim_command(str, err);-  do_cmdline_cmd(""redir END"");+  Array args = ARRAY_DICT_INIT;+  ADD(args, STRING_OBJ(command));+  ADD(args, STRING_OBJ(cstr_as_string(""silent""))); +  Object rv = nvim_call_function(cstr_as_string(""execute""), args, err);+  api_free_array(args);   if (ERROR_SET(err)) {+    assert(rv.type == kObjectTypeNil);     return (String)STRING_INIT;   } -  return cstr_to_string((char *)get_vim_var_str(VV_COMMAND_OUTPUT));+  assert(rv.type == kObjectTypeString);+  // execute() always(?) prepends a newline; remove it.+  if (rv.data.string.size > 1) {","You can mark it with a TODO if noone cares to fix it right now. In the long run ""the behaviour of the first error message inside a capture"" doesn't sound like like something we should express uncertainty about, rather it should just do the intended thing directly.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/7821,160034734,2018-01-06T20:57:27Z,src/nvim/api/vim.c,"@@ -207,18 +208,38 @@ String nvim_replace_termcodes(String str, Boolean from_part, Boolean do_lt,   return cstr_as_string(ptr); } -String nvim_command_output(String str, Error *err)+/// Executes an ex-command and returns its (non-error) output.+/// Shell |:!| output is not captured.+///+/// On parse error: forwards the Vim error; does not update v:errmsg.+/// On runtime error: forwards the Vim error; does not update v:errmsg.+///+/// @param command  Ex-command string+/// @param[out] err Error details (Vim error), if any+String nvim_command_output(String command, Error *err)   FUNC_API_SINCE(1) {-  do_cmdline_cmd(""redir => v:command_output"");-  nvim_command(str, err);-  do_cmdline_cmd(""redir END"");+  Array args = ARRAY_DICT_INIT;+  ADD(args, STRING_OBJ(command));+  ADD(args, STRING_OBJ(cstr_as_string(""silent""))); +  Object rv = nvim_call_function(cstr_as_string(""execute""), args, err);","Calling a vimscript function indirectly to implement an API function is definitely not ""using the API internally"" (that design pattern would be rather defining `execute()` in terms of an API function)If one for some reason needs to construct an explicit typval there is no reason to construct an API _value_ and immediately convecting it to typval. This just moves _horizontally_ between different abstractions, at a performance cost, and not across whatever internal/external boundary. Not that performance matters matters in this particular case, but it is an anti-pattern to be avoided. ( i e ""performance as a consequence of doing things right"" and not optimization)  ",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/7821,160035281,2018-01-06T21:27:40Z,src/nvim/api/vim.c,"@@ -207,18 +208,38 @@ String nvim_replace_termcodes(String str, Boolean from_part, Boolean do_lt,   return cstr_as_string(ptr); } -String nvim_command_output(String str, Error *err)+/// Executes an ex-command and returns its (non-error) output.+/// Shell |:!| output is not captured.+///+/// On parse error: forwards the Vim error; does not update v:errmsg.+/// On runtime error: forwards the Vim error; does not update v:errmsg.+///+/// @param command  Ex-command string+/// @param[out] err Error details (Vim error), if any+String nvim_command_output(String command, Error *err)   FUNC_API_SINCE(1) {-  do_cmdline_cmd(""redir => v:command_output"");-  nvim_command(str, err);-  do_cmdline_cmd(""redir END"");+  Array args = ARRAY_DICT_INIT;+  ADD(args, STRING_OBJ(command));+  ADD(args, STRING_OBJ(cstr_as_string(""silent""))); +  Object rv = nvim_call_function(cstr_as_string(""execute""), args, err);+  api_free_array(args);   if (ERROR_SET(err)) {+    assert(rv.type == kObjectTypeNil);     return (String)STRING_INIT;   } -  return cstr_to_string((char *)get_vim_var_str(VV_COMMAND_OUTPUT));+  assert(rv.type == kObjectTypeString);+  // execute() always(?) prepends a newline; remove it.+  if (rv.data.string.size > 1) {","The behavior of `execute()` is already configurable, it wouldn't be strange for a common implementation (which can happen later) to also have this as a flag.I might look into the relevant parts anyway when revisiting #7466 (which in some sense is `command_output` on steroids, but continuously). If we find a better way to treat newlines, it wouldn't be completely unrealistic for vim to also implement it? (either behind a new `silent` value, or change the default on the same theory of not bug-for-bug compatibility).  ",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/7821,160035995,2018-01-06T22:02:52Z,src/nvim/api/vim.c,"@@ -207,18 +208,38 @@ String nvim_replace_termcodes(String str, Boolean from_part, Boolean do_lt,   return cstr_as_string(ptr); } -String nvim_command_output(String str, Error *err)+/// Executes an ex-command and returns its (non-error) output.+/// Shell |:!| output is not captured.+///+/// On parse error: forwards the Vim error; does not update v:errmsg.+/// On runtime error: forwards the Vim error; does not update v:errmsg.+///+/// @param command  Ex-command string+/// @param[out] err Error details (Vim error), if any+String nvim_command_output(String command, Error *err)   FUNC_API_SINCE(1) {-  do_cmdline_cmd(""redir => v:command_output"");-  nvim_command(str, err);-  do_cmdline_cmd(""redir END"");+  Array args = ARRAY_DICT_INIT;+  ADD(args, STRING_OBJ(command));+  ADD(args, STRING_OBJ(cstr_as_string(""silent""))); +  Object rv = nvim_call_function(cstr_as_string(""execute""), args, err);","I agree, it would be cleaner to make `f_execute` call API `nvim_command_output()` and not the other way around. Though given how ���much��� code is actually needed I would rather go with calling `do_cmdline` directly with a custom `LineGetter`: basically you need```{  garray_T *const save_capture_ga = &capture_ga;  garray_T capture_local;  ga_init(&capture_local, 1, 80);  capture_ga = &capture_local;  try_start();  do_cmdline(NULL, get_string_line, &string,              DOCMD_NOWAIT|DOCMD_VERBOSE|DOCMD_REPEAT|DOCMD_KEYTYPED);  try_end(&err);  Object ret = STRING_OBJ(cstr_as_string(capture_local.ga_data));  capture_ga = save_capture_ga;  return ret;}```BTW, `f_execute` actually needs neither `vim_strsave()` nor `ga_clear()`, that is only useless waste of time.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/7821,160036142,2018-01-06T22:12:19Z,src/nvim/api/vim.c,"@@ -207,18 +208,38 @@ String nvim_replace_termcodes(String str, Boolean from_part, Boolean do_lt,   return cstr_as_string(ptr); } -String nvim_command_output(String str, Error *err)+/// Executes an ex-command and returns its (non-error) output.+/// Shell |:!| output is not captured.+///+/// On parse error: forwards the Vim error; does not update v:errmsg.+/// On runtime error: forwards the Vim error; does not update v:errmsg.+///+/// @param command  Ex-command string+/// @param[out] err Error details (Vim error), if any+String nvim_command_output(String command, Error *err)   FUNC_API_SINCE(1) {-  do_cmdline_cmd(""redir => v:command_output"");-  nvim_command(str, err);-  do_cmdline_cmd(""redir END"");+  Array args = ARRAY_DICT_INIT;+  ADD(args, STRING_OBJ(command));+  ADD(args, STRING_OBJ(cstr_as_string(""silent""))); +  Object rv = nvim_call_function(cstr_as_string(""execute""), args, err);","@ZyX-I if we go this route, it might make sense to define `nvim_source` which sources an API list using custom reader and also has output/error handling controlled by parameter.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/7813,160046124,2018-01-07T10:56:44Z,src/nvim/channel.c,"@@ -283,12 +283,15 @@ static void channel_destroy_early(Channel *chan)   if ((chan->id != --next_chan_id)) {     abort();   }+  pmap_del(uint64_t)(channels, chan->id);+  chan->id = 0;    if ((--chan->refcount != 0)) {     abort();   } -  free_channel_event((void **)&chan);+  // uv will still keep a reference to our memory until next event loop tick, so delay free+  multiqueue_put(main_loop.fast_events, free_channel_event, 1, chan);","I think it can be assumed that libuv frees handles at latest during the next loop iteration (but not in the middle of a still ongoing tick). Otherwise we will need to keep a second refcount on the channel struct just for ""number of not yet closed libuv handles""  ",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/7821,160354222,2018-01-09T09:26:46Z,src/nvim/api/vim.c,"@@ -207,18 +208,38 @@ String nvim_replace_termcodes(String str, Boolean from_part, Boolean do_lt,   return cstr_as_string(ptr); } -String nvim_command_output(String str, Error *err)+/// Executes an ex-command and returns its (non-error) output.+/// Shell |:!| output is not captured.+///+/// On parse error: forwards the Vim error; does not update v:errmsg.+/// On runtime error: forwards the Vim error; does not update v:errmsg.+///+/// @param command  Ex-command string+/// @param[out] err Error details (Vim error), if any+String nvim_command_output(String command, Error *err)   FUNC_API_SINCE(1) {-  do_cmdline_cmd(""redir => v:command_output"");-  nvim_command(str, err);-  do_cmdline_cmd(""redir END"");+  Array args = ARRAY_DICT_INIT;+  ADD(args, STRING_OBJ(command));+  ADD(args, STRING_OBJ(cstr_as_string(""silent""))); +  Object rv = nvim_call_function(cstr_as_string(""execute""), args, err);","@ZyX-I Why is `get_string_line` variant needed? `nvim_command_output` only accepts String and returns String, so I guess `do_cmdline_cmd(command.data)` should be enough.",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/7839,160874150,2018-01-11T06:34:45Z,src/nvim/eval/decode.c,"@@ -285,7 +285,7 @@ typval_T decode_string(const char *const s, const size_t len,       .v_type = VAR_STRING,       .v_lock = VAR_UNLOCKED,       .vval = { .v_string = (char_u *)(-          s_allocated ? (char *)s : xmemdupz(s, len)) },+          (s == NULL) || s_allocated ? (char *)s : xmemdupz(s, len)) },","AFAIR no. Though I would rather write `(s == NULL || s_allocated)` or have no parenthesis (and better first as I do not remember what is the priority of the ternary exactly, but grouping the whole condition together makes more sense then parenthesising part of it).",
542599,zhaozg,https://api.github.com/repos/neovim/neovim/pulls/7848,161394951,2018-01-14T11:47:23Z,src/nvim/macros.h,"@@ -148,7 +148,9 @@ /// zero in those cases (-Wdiv-by-zero in GCC). #define ARRAY_SIZE(arr) ((sizeof(arr)/sizeof((arr)[0])) / ((size_t)(!(sizeof(arr) % sizeof((arr)[0]))))) +#ifndef RGB","```typedef unsigned long DWORD;typedef DWORD COLORREF;#define RGB(r,g,b) ((COLORREF)(((BYTE)(r)|((WORD)((BYTE)(g))<<8))|(((DWORD)(BYTE)(b))<<16)))```uint32_t equals unsigned long",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/7836,161406841,2018-01-14T19:05:05Z,src/nvim/ex_docmd.c,"@@ -9256,6 +9269,19 @@ put_view (           || put_eol(fd) == FAIL) {         return FAIL;       }++			if (fputs(""call add(buffer_names, [bufname('%'),'"", fd) < 0+					|| ses_fname(fd, wp->w_buffer, flagp, false) == FAIL","@AlexandreDubray Even though it is buggy for intended purpose, intended purpose still is not valid for expressions. As it is named `ses_fname` you can overload it for expressions going into file (without renaming, I mean), but I do not think that string escaping suitable for dumping into sourced file would always be useful for sessions only, better have separate function. Or overload `convert_to_json_string`, code is going to be very similar in any case. You would need to uninline it, make not static, add boolean argument (it must not error out, dumping any possible string instead: file names with non-unicode bytes are valid, but not JSON strings) and rename to something like `encode_convert_to_double_quoted_string`.",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/7836,161406882,2018-01-14T19:06:58Z,src/nvim/ex_docmd.c,"@@ -9256,6 +9269,19 @@ put_view (           || put_eol(fd) == FAIL) {         return FAIL;       }++			if (fputs(""call add(buffer_names, [bufname('%'),'"", fd) < 0+					|| ses_fname(fd, wp->w_buffer, flagp, false) == FAIL","Ah, and it also should not use surrogate pairs to dump characters which have too big unicode codepoint number, unlike JSON VimL has `\U01234567` for that and it does allow byte sequences representing codepoint belonging to surrogate pair in a string (that is not valid in UTF-8 itself, not to mention JSON which allows using surrogate pairs solely for their intended purpose).",
542599,zhaozg,https://api.github.com/repos/neovim/neovim/pulls/7863,161767708,2018-01-16T14:14:11Z,src/nvim/option.c,"@@ -844,7 +844,7 @@ set_option_default (       if (options[opt_idx].indir == PV_SCROLL)         win_comp_scroll(curwin);       else {-        *(intptr_t *)varp = (intptr_t)options[opt_idx].def_val[dvi];+        *(long *)varp = (long)options[opt_idx].def_val[dvi];","varp is char_u*, long value will corrupt ??It's difficult to understand.",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/7863,161909785,2018-01-16T22:46:52Z,src/nvim/option.c,"@@ -844,7 +844,7 @@ set_option_default (       if (options[opt_idx].indir == PV_SCROLL)         win_comp_scroll(curwin);       else {-        *(intptr_t *)varp = (intptr_t)options[opt_idx].def_val[dvi];+        *(long *)varp = (long)options[opt_idx].def_val[dvi];","varp is `union {char_u **strp; int *boolp; long *nump;}`, `char_u*` is legacy because Bram for some reason does not like using `void*` or unions in a number of places: depending on option type it is `int*`, `long*` or `char_u**`, not sure how `intptr_t*` managed to appear here.",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/7863,161910446,2018-01-16T22:50:00Z,src/nvim/option.c,"@@ -5012,7 +5012,7 @@ static int optval_default(vimoption_T *p, char_u *varp)     return TRUE;            /* hidden option is always at default */   dvi = ((p->flags & P_VI_DEF) || p_cp) ? VI_DEFAULT : VIM_DEFAULT;   if (p->flags & P_NUM)-    return *(intptr_t *)varp == (intptr_t)p->def_val[dvi];+    return *(long *)varp == (long)p->def_val[dvi];","If I am not mistaking, what actually should be here is `*(long *)varp == (long)(intptr_t)p->def_val[dvi]`: you can���t just go and cast pointer to integer without running into a warning, but you can first cast it to `u?intptr_t` integer first and then to the needed integer next.",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/7863,161910578,2018-01-16T22:50:41Z,src/nvim/option.c,"@@ -1442,7 +1442,7 @@ do_set (              */             ++arg;             if (nextchar == '&')-              value = (intptr_t)options[opt_idx].def_val[+              value = (long)options[opt_idx].def_val[",For this reason here you probably want `(long)(intptr_t)` and above `long` should remain unchanged.,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/7863,162192616,2018-01-17T22:02:35Z,src/nvim/os/fs.c,"@@ -563,8 +568,13 @@ ptrdiff_t os_write(const int fd, const char *const buf, const size_t size)   size_t written_bytes = 0;   while (written_bytes != size) {     assert(size >= written_bytes);+#ifdef WIN32+    const ptrdiff_t cur_written_bytes =+      write(fd, buf + written_bytes, (unsigned int)(size - written_bytes));",would rather live with the warning than have this kind of code duplication. Same for the one above. Until a better solution is found ..,
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/7863,162196299,2018-01-17T22:18:14Z,src/nvim/os/fs.c,"@@ -460,8 +460,13 @@ ptrdiff_t os_read(const int fd, bool *ret_eof, char *const ret_buf,   bool did_try_to_free = false;   while (read_bytes != size) {     assert(size >= read_bytes);+#ifdef WIN32+    const ptrdiff_t cur_read_bytes = read(fd, ret_buf + read_bytes,+                                          (unsigned int)(size - read_bytes));","Better conditionally define a `SIZE_CAST(size)` macros above the function (and undefine it below the last function code is being used in). (Local defining/undefining like this allows using shorter names for local macros without fear of running into collisions.) And still do not use `int`, `unsigned int` and `unsigned` are the same thing.",
112971,jamessan,https://api.github.com/repos/neovim/neovim/pulls/7867,162239351,2018-01-18T03:05:21Z,src/nvim/ex_docmd.c,"@@ -3442,6 +3442,9 @@ const char * set_one_cmd_context(   case CMD_profile:     set_context_in_profile_cmd(xp, arg);     break;+  case CMD_checkhealth:+    set_context_in_checkhealth_cmd(xp, arg);",```cxp->xp_context = EXPAND_CHECKHEALTH;xp->xp_pattern = (char_u *)arg;break;```,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/7863,162336073,2018-01-18T13:08:36Z,src/nvim/macros.h,"@@ -148,6 +148,11 @@ /// zero in those cases (-Wdiv-by-zero in GCC). #define ARRAY_SIZE(arr) ((sizeof(arr)/sizeof((arr)[0])) / ((size_t)(!(sizeof(arr) % sizeof((arr)[0]))))) +// Windows defines a RGB macro that produces 0x00bbggrr color values for use+// with GDI. Our macro is different, and we don't use GDI.+#if defined(RGB)","If RGB macro is defined by a library on non-Windows, we want to know about it, not silently override it. If that happens we should rename the macro.",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/7863,162591364,2018-01-19T10:49:02Z,src/nvim/macros.h,"@@ -183,4 +188,18 @@ /// @return ((Type *)obj). #define STRUCT_CAST(Type, obj) ((Type *)(obj)) +// Type of uv_buf_t.len on Windows is ULONG, but others is size_t.+#if defined(WIN32)+# define UV_BUF_LEN(x)  (ULONG)(x)+#else+# define UV_BUF_LEN(x)  (x)+#endif++// Type of bufcnt for read/write on Windows is unsigned int, not size_t.+#if defined(WIN32)+# define IO_SIZE(x)  (unsigned int)(x)","`unsigned int` is present in 18 files, though it is still less common then just `unsigned`. Better not touch anything you did not modify for other reasons. *Especially* kbtree.h, it is full of style guide violations so changing `unsigned int` to `unsigned` will not change much, but will make clint produces many warnings.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/7875,162784162,2018-01-20T14:43:33Z,src/nvim/eval.c,"@@ -400,6 +400,8 @@ static struct vimvar {   VV(VV_SEARCHFORWARD,  ""searchforward"",    VAR_NUMBER, 0),   VV(VV_HLSEARCH,       ""hlsearch"",         VAR_NUMBER, 0),   VV(VV_OLDFILES,       ""oldfiles"",         VAR_LIST, 0),+  VV(VV_ACTUAL_CURBUF,  ""actual_curbuf"",    VAR_NUMBER, VV_RO),+  VV(VV_STL_WINDOW,     ""stl_window"",       VAR_NUMBER, VV_RO),","How about `v:curbuf` and `v:curwin` ? It's not really statusline-specific, semantically, though that happens to be the only place it's useful. (In the future we may want to set it in more contexts, though we can skip that for now, to avoid blocking this PR.)Also agreed with @tjdevries : we need to keep `g:actual_curbuf`, but in the documentation move it to `deprecated.txt`. But introduce a redundant `v:` variant, `v:curbuf`.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/7875,162809744,2018-01-21T12:10:08Z,src/nvim/eval.c,"@@ -400,6 +400,8 @@ static struct vimvar {   VV(VV_SEARCHFORWARD,  ""searchforward"",    VAR_NUMBER, 0),   VV(VV_HLSEARCH,       ""hlsearch"",         VAR_NUMBER, 0),   VV(VV_OLDFILES,       ""oldfiles"",         VAR_LIST, 0),+  VV(VV_ACTUAL_CURBUF,  ""actual_curbuf"",    VAR_NUMBER, VV_RO),+  VV(VV_STL_WINDOW,     ""stl_window"",       VAR_NUMBER, VV_RO),","If you mean new var, why not `v:stl_buffer` ? If you mean `v:actual_curbuf` I see no point of renaming it.",
112971,jamessan,https://api.github.com/repos/neovim/neovim/pulls/7894,163038791,2018-01-22T19:13:47Z,CMakeLists.txt,"@@ -526,9 +515,27 @@ if(BUSTED_PRG)     list(APPEND TEST_TARGET_ARGS ""USES_TERMINAL"")   endif() -  configure_file(-    test/config/paths.lua.in-    ${CMAKE_BINARY_DIR}/test/config/paths.lua)+  if(NOT (${CMAKE_VERSION} VERSION_LESS 2.8.12))","Sure.  I was just following the pattern used a few lines earlier, as suggested by [former you](https://github.com/neovim/neovim/pull/4753#discussion_r63464657). :)",
972014,mhinz,https://api.github.com/repos/neovim/neovim/pulls/7891,164005512,2018-01-26T00:11:55Z,src/nvim/CMakeLists.txt,"@@ -14,6 +14,7 @@ if(WIN32)   # tell MinGW compiler to enable wmain   set(CMAKE_EXE_LINKER_FLAGS ""${CMAKE_EXE_LINKER_FLAGS} -municode"") elseif(CMAKE_SYSTEM_NAME STREQUAL ""Darwin"")+  set(CMAKE_C_FLAGS ""${CMAKE_C_FLAGS} -iframework CoreFoundation"")",In that case I'd get this message for each C file:```[278/282] Building C object src/nvim/CMakeFiles/nvim.dir/viml/parser/expressions.c.oclang: warning: -framework CoreFoundation: 'linker' input unused [-Wunused-command-line-argument]```I think we need @jszakmeister to tell us about the intention. :>,
448087,jszakmeister,https://api.github.com/repos/neovim/neovim/pulls/7891,164036958,2018-01-26T05:41:30Z,src/nvim/CMakeLists.txt,"@@ -14,6 +14,7 @@ if(WIN32)   # tell MinGW compiler to enable wmain   set(CMAKE_EXE_LINKER_FLAGS ""${CMAKE_EXE_LINKER_FLAGS} -municode"") elseif(CMAKE_SYSTEM_NAME STREQUAL ""Darwin"")+  set(CMAKE_C_FLAGS ""${CMAKE_C_FLAGS} -iframework CoreFoundation"")","I think we need to drop that line.  I forgot to remove it after I found the real culprit (the missing `-isysroot`).  The hope was that it would help with pulling in CoreFoundation for the generation step, but as you see here, it didn't.This was definitely a weird problem overall.  It turns out there's a difference between executing `/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang` and `/usr/bin/clang`.  CMake was picking up the former and with that it left off a key include path.  Why?  I dunno. :-(Either way this line can be dropped as it didn't fix the problem.  Sorry about the troubles... it was definitely a weird bug to track down.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/7917,164170517,2018-01-26T17:21:59Z,runtime/doc/msgpack_rpc.txt,"@@ -242,4 +242,198 @@ Even for statically compiled clients it is good practice to avoid hardcoding the type codes, because a client may be built against one Nvim version but connect to another with different type codes. +==============================================================================+7. Live Updates				      *live-updates* *rpc-live-updates*++A dedicated API has been created to allow co-processes to be notified in+real-time when the user changes a buffer in any way. It is difficult and+error-prone to try and do this with autocommands such as |TextChanged|.++							*live-updates-enabling*+Setting Up~++If your API client is a standalone co-process, it can use the+`""nvim_buf_live_updates""`API method to activate Live Update events for a+specific buffer. For example, in python >++	import sys, neovim","I don't think this belongs here. At this point we can assume that the reader is aware of clients, attach-ment etc. Also we shouldn't start with a language-specific example, just describe the API functionality. (See `:help ui-intro` for comparison)",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/7917,164171480,2018-01-26T17:26:06Z,runtime/doc/msgpack_rpc.txt,"@@ -242,4 +242,198 @@ Even for statically compiled clients it is good practice to avoid hardcoding the type codes, because a client may be built against one Nvim version but connect to another with different type codes. +==============================================================================+7. Live Updates				      *live-updates* *rpc-live-updates*++A dedicated API has been created to allow co-processes to be notified in+real-time when the user changes a buffer in any way. It is difficult and+error-prone to try and do this with autocommands such as |TextChanged|.++							*live-updates-enabling*+Setting Up~++If your API client is a standalone co-process, it can use the+`""nvim_buf_live_updates""`API method to activate Live Update events for a+specific buffer. For example, in python >++	import sys, neovim+	nvim = neovim.attach('stdio')+	bufnr = sys.argv[1]+	nvim.buffers[bufnr].live_updates(True, True)++After the `""nvim_buf_live_updates""` method is called, neovim will send a+series of notifications containing the entire buffer's contents and any+subsequent changes. The buffer's contents are sent via notifications because+if you were to use the other API methods to retrieve the buffer contents, the+buffer could be changed again before you turn on live updates. This can cause+a delay if your plugin activates live updates for a very large buffer, but it+is the the most efficient way to maintain a copy of the entire buffer's+contents inside your plugin.++To disable the initial sending of the full buffer, set the second argument of+""nvim_buf_live_updates"" to false. The resulting notification will be the same+as shown in |LiveUpdateStart|, but {linedata} will be an empty list.++						      *live-updates-disabling*+Turning Off~++You can use `""nvim_buf_live_updates""` with an argument of `False` to turn off+notifications. One final notification will be sent to indicate that live+updates are no longer active for the specified buffer. Alternatively, you can+just close the channel.++						    *live-updates-limitations*+Limitations~++Note that any of the following actions will also turn off live updates because+the buffer contents are unloaded from memory:++  - Closing all a buffer's windows (unless 'hidden' is enabled).+  - Using |:edit| to reload the buffer+  - reloading the buffer after it is changed from outside neovim.++							  *live-updates-events*+Handling Events~++The co-process will start receiving the notification events which will be+equivilent to the following |rpcnotify()| calls:++1. rpcnotify({channel}, ""LiveUpdateStart"",		      *LiveUpdateStart*"," `rpcnotfy` shouldn't be used here, the fundamental concept is msgpack notifications (and what's relevant for the reader is how they are represented at the receiving end, which we don't control). Just mention name + `[argument, list]`",
4117685,KillTheMule,https://api.github.com/repos/neovim/neovim/pulls/7917,164172487,2018-01-26T17:30:34Z,runtime/doc/msgpack_rpc.txt,"@@ -242,4 +242,198 @@ Even for statically compiled clients it is good practice to avoid hardcoding the type codes, because a client may be built against one Nvim version but connect to another with different type codes. +==============================================================================+7. Live Updates				      *live-updates* *rpc-live-updates*++A dedicated API has been created to allow co-processes to be notified in+real-time when the user changes a buffer in any way. It is difficult and+error-prone to try and do this with autocommands such as |TextChanged|.++							*live-updates-enabling*+Setting Up~++If your API client is a standalone co-process, it can use the+`""nvim_buf_live_updates""`API method to activate Live Update events for a+specific buffer. For example, in python >++	import sys, neovim+	nvim = neovim.attach('stdio')+	bufnr = sys.argv[1]+	nvim.buffers[bufnr].live_updates(True, True)++After the `""nvim_buf_live_updates""` method is called, neovim will send a+series of notifications containing the entire buffer's contents and any+subsequent changes. The buffer's contents are sent via notifications because+if you were to use the other API methods to retrieve the buffer contents, the+buffer could be changed again before you turn on live updates. This can cause+a delay if your plugin activates live updates for a very large buffer, but it+is the the most efficient way to maintain a copy of the entire buffer's+contents inside your plugin.++To disable the initial sending of the full buffer, set the second argument of+""nvim_buf_live_updates"" to false. The resulting notification will be the same+as shown in |LiveUpdateStart|, but {linedata} will be an empty list.++						      *live-updates-disabling*+Turning Off~++You can use `""nvim_buf_live_updates""` with an argument of `False` to turn off+notifications. One final notification will be sent to indicate that live+updates are no longer active for the specified buffer. Alternatively, you can+just close the channel.++						    *live-updates-limitations*+Limitations~++Note that any of the following actions will also turn off live updates because+the buffer contents are unloaded from memory:++  - Closing all a buffer's windows (unless 'hidden' is enabled).+  - Using |:edit| to reload the buffer+  - reloading the buffer after it is changed from outside neovim.++							  *live-updates-events*+Handling Events~++The co-process will start receiving the notification events which will be+equivilent to the following |rpcnotify()| calls:++1. rpcnotify({channel}, ""LiveUpdateStart"",		      *LiveUpdateStart*",Like [this](https://github.com/neovim/neovim/blob/master/runtime/doc/api.txt#L128)?,
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/7917,164178779,2018-01-26T17:56:51Z,runtime/doc/msgpack_rpc.txt,"@@ -242,4 +242,198 @@ Even for statically compiled clients it is good practice to avoid hardcoding the type codes, because a client may be built against one Nvim version but connect to another with different type codes. +==============================================================================+7. Live Updates				      *live-updates* *rpc-live-updates*++A dedicated API has been created to allow co-processes to be notified in+real-time when the user changes a buffer in any way. It is difficult and+error-prone to try and do this with autocommands such as |TextChanged|.++							*live-updates-enabling*+Setting Up~++If your API client is a standalone co-process, it can use the+`""nvim_buf_live_updates""`API method to activate Live Update events for a+specific buffer. For example, in python >++	import sys, neovim+	nvim = neovim.attach('stdio')+	bufnr = sys.argv[1]+	nvim.buffers[bufnr].live_updates(True, True)++After the `""nvim_buf_live_updates""` method is called, neovim will send a+series of notifications containing the entire buffer's contents and any+subsequent changes. The buffer's contents are sent via notifications because+if you were to use the other API methods to retrieve the buffer contents, the+buffer could be changed again before you turn on live updates. This can cause+a delay if your plugin activates live updates for a very large buffer, but it+is the the most efficient way to maintain a copy of the entire buffer's+contents inside your plugin.++To disable the initial sending of the full buffer, set the second argument of+""nvim_buf_live_updates"" to false. The resulting notification will be the same+as shown in |LiveUpdateStart|, but {linedata} will be an empty list.++						      *live-updates-disabling*+Turning Off~++You can use `""nvim_buf_live_updates""` with an argument of `False` to turn off+notifications. One final notification will be sent to indicate that live+updates are no longer active for the specified buffer. Alternatively, you can+just close the channel.++						    *live-updates-limitations*+Limitations~++Note that any of the following actions will also turn off live updates because+the buffer contents are unloaded from memory:++  - Closing all a buffer's windows (unless 'hidden' is enabled).+  - Using |:edit| to reload the buffer+  - reloading the buffer after it is changed from outside neovim.++							  *live-updates-events*+Handling Events~++The co-process will start receiving the notification events which will be+equivilent to the following |rpcnotify()| calls:++1. rpcnotify({channel}, ""LiveUpdateStart"",		      *LiveUpdateStart*","Possibly, but I would like to make events visually distinct from methods in some way, maybe by using `[ ]` argument list.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/7330,164185051,2018-01-26T18:22:12Z,CMakeLists.txt,"@@ -44,6 +44,11 @@ if(CMAKE_SYSTEM_NAME STREQUAL ""Darwin"")   endif() endif() +if (CMAKE_HOST_SYSTEM_VERSION MATCHES "".*-Microsoft"")+  # Detect WSL, which is also UNIX but not Windows/WIN32/WIN64+  add_definitions(-DWSL)","""WSL"" for a build-time define seems like it could risk conflicting with some other C library define. Let's qualify it a bit, I guess `NVIM_WSL` is unambiguous enough.",
542599,zhaozg,https://api.github.com/repos/neovim/neovim/pulls/7914,164274508,2018-01-27T15:53:13Z,cmake/FindUnibilium.cmake,"@@ -23,6 +23,10 @@ find_path(UNIBILIUM_INCLUDE_DIR unibilium.h           PATHS ${PC_UNIBILIUM_INCLUDEDIR} ${PC_UNIBILIUM_INCLUDE_DIRS}           ${LIMIT_SEARCH}) +if(WIN32)+  set(UNIBILIUM_USE_STATIC ON)",Uniblium in mingw64 only static libs. To declare use static lib for disambiguation,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/7914,164305729,2018-01-28T17:23:04Z,src/nvim/CMakeLists.txt,"@@ -401,6 +406,12 @@ if(JEMALLOC_FOUND)   list(APPEND NVIM_EXEC_LINK_LIBRARIES ${JEMALLOC_LIBRARIES}) endif() +if(WIN32 AND NVIM_BUILD_STATIC)+  list(REMOVE_DUPLICATES NVIM_EXEC_LINK_LIBRARIES)+  # Static stdc++ runtime library must keep tail for static link +  list(APPEND NVIM_EXEC_LINK_LIBRARIES -static-libgcc -static-libstdc++ -Wl,-Bstatic -lstdc++)","Maybe it's worth doing REMOVE_DUPLICATES after this line, then append `-lstdc++`. Like this:```list(APPEND NVIM_EXEC_LINK_LIBRARIES -static-libgcc -static-libstdc++ -Wl,-Bstatic)list(REMOVE_DUPLICATES NVIM_EXEC_LINK_LIBRARIES)list(APPEND NVIM_EXEC_LINK_LIBRARIES -lstdc++)```Also, should there be a space in `-Wl,-Bstatic`? Like this: `-Wl, -Bstatic` (I don't know, just asking)Also for NVIM_TEST_LINK_LIBRARIES.",
1937689,yan12125,https://api.github.com/repos/neovim/neovim/pulls/7948,165252547,2018-02-01T03:33:07Z,src/nvim/tui/tui.c,"@@ -1813,6 +1813,14 @@ static const char *tui_tk_ti_getstr(const char *name, const char *value,     if (value != NULL && strequal(stty_erase, value)) {       return stty_erase[0] == DEL ? CTRL_H_STR : DEL_STR;     }+  } else if (strequal(name, ""key_mouse"")) {+    DLOG(""libtermkey:kmous=%s"", value);+    // libtermkey assumes mouse encoding protocol is always X10 in its+    // terminfo driver (driver-ti.c), which is wrong. Don't use it if it's SGR+    // encoding. XXX how about other encodings (UTF-8, URXVT...)?+    if (value != NULL && strequal(""\033[<"", value)) {+      return NULL;","Oops, forgot to mention another tricky thing in libtermkey: the CSI driver can handle SGR and URXVR protocols but not the X10 protocol.https://github.com/neovim/libtermkey/blob/master/driver-csi.c#L162neovim already forces the SGR protocol (1006), so it's safe to skip the value check. I put it here so that neovim won't break in the future if it wants a different mouse encoding protocol.(According to the author of ncurses, some terminals do not implement 1006 protocol correctly [1])[1] https://raw.githubusercontent.com/ThomasDickey/ncurses-snapshots/master/misc/terminfo.src",
972014,mhinz,https://api.github.com/repos/neovim/neovim/pulls/7944,165352754,2018-02-01T13:20:35Z,src/nvim/eval.c,"@@ -10733,6 +10733,17 @@ static void f_has(typval_T *argvars, typval_T *rettv, FunPtr fptr)     n = true;   } +  if (STRICMP(name, ""ruby"") == 0 && n == true) {+    char *rubyhost = call_func_retstr(""provider#ruby#Detect"", 0, NULL, true);","It checks for Python installations, not the module: https://github.com/neovim/neovim/blob/6710164c2c44335a916a728cc8eb329c69d155f4/runtime/autoload/provider/pythonx.vim#L40-L71",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/7957,165459441,2018-02-01T19:18:28Z,third-party/cmake/BuildLuarocks.cmake,"@@ -130,6 +130,18 @@ add_custom_target(inspect  list(APPEND THIRD_PARTY_DEPS inspect) +if(USE_BUNDLED_LUA)+  # DEPENDS on the previous module, because Luarocks breaks if parallel.+  add_custom_command(OUTPUT ${HOSTDEPS_LIB_DIR}/luarocks/rocks/luabitop+    COMMAND ${LUAROCKS_BINARY}+    ARGS build luabitop ${LUAROCKS_BUILDARGS}+    DEPENDS inspect)","This is tricky, the `DEPENDS inspect` for penlight (below) could be parallel now.I guess we need to check `if(USE_BUNDLED_LUA)` below, and set penlight `DEPENDS luabitop` in that case.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/7944,165460781,2018-02-01T19:23:15Z,src/nvim/eval.c,"@@ -10733,6 +10733,17 @@ static void f_has(typval_T *argvars, typval_T *rettv, FunPtr fptr)     n = true;   } +  if (STRICMP(name, ""ruby"") == 0 && n == true) {+    char *rubyhost = call_func_retstr(""provider#ruby#Detect"", 0, NULL, true);","the pythonx Detect() function already returns a List with empty element 0, in case of error:https://github.com/neovim/neovim/blob/6710164c2c44335a916a728cc8eb329c69d155f4/runtime/autoload/provider/pythonx.vim#L69Can't we do something similar--without any new functions, or new C code--for the case where the module isn't installed? It's just an extra `if` check.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/7966,165893199,2018-02-05T07:00:21Z,src/nvim/testdir/test_help_tagjump.vim,"@@ -18,6 +18,52 @@ func Test_help_tagjump()   call assert_true(getline('.') =~ '\*help.txt\*')   helpclose +  help |+  call assert_equal(""help"", &filetype)+  call assert_true(getline('.') =~ '\*bar\*')+  helpclose++  help ""*+  call assert_equal(""help"", &filetype)+  call assert_true(getline('.') =~ '\*quotestar\*')+  helpclose++  help sm?le+  call assert_equal(""help"", &filetype)+  call assert_true(getline('.') =~ '\*:smile\*')","```Caught exception in Test_help_tagjump(): Vim(help):E149: Sorry, no help for sm?le @ function RunTheTest[13]..Test_help_tagjump, line 16```Nvim does not have `:smile` command, need to change this to something else. How about `:split`:```help sp?itcall assert_equal(""help"", &filetype)call assert_true(getline('.') =~ '\*:split\*')```",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/7969,166119663,2018-02-05T21:37:24Z,src/nvim/message.c,"@@ -466,15 +466,7 @@ int emsg_not_now(void)   return FALSE; } -/*- * emsg() - display an error message- *- * Rings the bell, if appropriate, and calls message() to do the real work- * When terminal not initialized (yet) mch_errmsg(..) is used.- *- * return TRUE if wait_return not called- */-int emsg(const char_u *s_)+static int _emsg(const char *s_, int (*msg_attr)(const char *s, const int attr))","It is bad idea to mask symbols; also need typedef, AFAIR C declarations generator intentionally cannot swallow that.",
9006098,AlexandreDubray,https://api.github.com/repos/neovim/neovim/pulls/7969,166140860,2018-02-05T23:04:29Z,src/nvim/message.c,"@@ -466,15 +466,7 @@ int emsg_not_now(void)   return FALSE; } -/*- * emsg() - display an error message- *- * Rings the bell, if appropriate, and calls message() to do the real work- * When terminal not initialized (yet) mch_errmsg(..) is used.- *- * return TRUE if wait_return not called- */-int emsg(const char_u *s_)+static int _emsg(const char *s_, int (*msg_attr)(const char *s, const int attr))","I made the typedef in a commit but I did not understood the ""mask symbol"" part (I mean, technically what does that mean? I'm sorry, my knowledge of C is not that advanced).",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/7969,166141381,2018-02-05T23:07:19Z,src/nvim/message.c,"@@ -577,9 +666,9 @@ static int _emsg(const char *s_, int (*msg_attr)(const char *s, const int attr))  */ int emsg(const char_u *s_) {-  return _emsg((const char *)s_, &msg_attr);+  fct_msg_attr f = &msg_attr;","Do not create temporary variable here, code should work as it worked.",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/7969,166143063,2018-02-05T23:14:28Z,src/nvim/message.c,"@@ -137,6 +139,94 @@ int msg_attr(const char *s, const int attr) FUNC_ATTR_NONNULL_ARG(1)   return msg_attr_keep((char_u *)s, attr, false); } +int msg_echo_attr(const char *s, const int attr) FUNC_ATTR_NONNULL_ARG(1)+{+  return msg_echo_attr_keep(s, attr, false);+}++int+msg_echo_attr_keep(+    const char *s,+    const int attr,+    int keep+)+  FUNC_ATTR_NONNULL_ARG(1)+{+  static int entered = 0;+  int retval;+  char * buf = NULL;++  if (!emsg_on_display && message_filtered((char_u *)s)) {+    return true;+  }++  if (attr == 0) {+    set_vim_var_string(VV_STATUSMSG, s, -1);+  }++  if (entered >= 3) {+    return true;+  }+  entered++;++  if ((char_u *)s != keep_msg+      || (*s != '<'+          && last_msg_hist != NULL+          && last_msg_hist->msg != NULL+          && STRCMP(s, last_msg_hist->msg))) {+    add_msg_hist(s, -1, attr);+  }++  if ((char_u *)s == keep_msg) {+    keep_msg = NULL;+  }++  bool needclr = true;++  msg_start();+  buf = (char *)msg_strtrunc((char_u *)s, false);+  if (buf != NULL) {+    s = buf;+  }++  char * spec_char = ""\t\n\r"";","Do not make compiler work harder, strpbrk argument better be a literal, either just literal or macros. But since you are using this list in a single place just put literal there.",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/7969,166143582,2018-02-05T23:17:13Z,src/nvim/message.c,"@@ -137,6 +139,94 @@ int msg_attr(const char *s, const int attr) FUNC_ATTR_NONNULL_ARG(1)   return msg_attr_keep((char_u *)s, attr, false); } +int msg_echo_attr(const char *s, const int attr) FUNC_ATTR_NONNULL_ARG(1)+{+  return msg_echo_attr_keep(s, attr, false);+}++int+msg_echo_attr_keep(+    const char *s,+    const int attr,+    int keep+)+  FUNC_ATTR_NONNULL_ARG(1)+{+  static int entered = 0;+  int retval;+  char * buf = NULL;++  if (!emsg_on_display && message_filtered((char_u *)s)) {+    return true;+  }++  if (attr == 0) {+    set_vim_var_string(VV_STATUSMSG, s, -1);+  }++  if (entered >= 3) {+    return true;+  }+  entered++;++  if ((char_u *)s != keep_msg+      || (*s != '<'+          && last_msg_hist != NULL+          && last_msg_hist->msg != NULL+          && STRCMP(s, last_msg_hist->msg))) {+    add_msg_hist(s, -1, attr);+  }++  if ((char_u *)s == keep_msg) {+    keep_msg = NULL;+  }++  bool needclr = true;++  msg_start();+  buf = (char *)msg_strtrunc((char_u *)s, false);+  if (buf != NULL) {+    s = buf;+  }++  char * spec_char = ""\t\n\r"";++  char * next_spec = (char *)s;++  while (next_spec != NULL) {+    next_spec = (char *)vim_strpbrk(s, spec_char);","You just added a bunch of useless casts here (some hidden by `vim_strpbrk` macros), don���t use `vim_strpbrk`, use `strpbrk` directly.",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/7969,166448029,2018-02-06T21:29:48Z,src/nvim/message.c,"@@ -137,6 +139,81 @@ int msg_attr(const char *s, const int attr) FUNC_ATTR_NONNULL_ARG(1)   return msg_attr_keep((char_u *)s, attr, false); } +int msg_echo_attr(const char *s, const int attr) FUNC_ATTR_NONNULL_ARG(1)","Do not put FUNC_ATTR on the same line as a function name, this variant both visually hides attributes and produces unneccessary line change if something needs to be added (e.g. new argument or another attribute).",
972014,mhinz,https://api.github.com/repos/neovim/neovim/pulls/7981,166704353,2018-02-07T18:05:54Z,src/nvim/tui/terminfo.c,"@@ -20,7 +20,7 @@ #endif  // One creates the dumps from terminfo.src by using-//      od -t d1 -w | cut -c9- | sed -e 's/\>/,/g'+//      od -t d1 -w | cut -c9- | sed -e 's/\>\s*/, /g'",They should be all superfluous because the actual data are integers by then. It's just for getting a shorter C array.,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/7982,166902286,2018-02-08T11:10:28Z,src/nvim/screen.c,"@@ -5847,30 +5840,16 @@ next_search_hl_pos(   return 0; } -static void screen_start_highlight(int attr)-{-  screen_attr = attr;-  ui_start_highlight(attr);-}--static void screen_stop_highlight(void)-{-  ui_stop_highlight();","I would vote to keep at least the `ui_` ""start""/""stop"" pair (`ui_start_highlight`, `ui_stop_highlight`). It gives a semantic hint (`ui_set_highlight(ATTR_NORMAL)` is not easily recognizable as ""stop highlighting"", unless one has the requisite tribal knowledge), and leaves clues when comparing Vim code, at a negligible cost.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/7982,166910138,2018-02-08T11:46:30Z,src/nvim/screen.c,"@@ -5847,30 +5840,16 @@ next_search_hl_pos(   return 0; } -static void screen_start_highlight(int attr)-{-  screen_attr = attr;-  ui_start_highlight(attr);-}--static void screen_stop_highlight(void)-{-  ui_stop_highlight();","But the semantics are not ""start"" and ""stop"", the nvim UI layer can directly _set_ the highlight from whatever value to whatever other value. The old names made sense in vim where screen.c directly wrote to the terminal, and clear highlight probably was a prerequisite for some term.c operations. But in nvim tui.c does its own housekeeping when literal `^[...m` needs to be sent or not, so it makes no sense: highlights only needs to be _set_ before explicitly grid modifying operations. We can have `ui_clear_highlight() { ui_set_highlight(0) }` (which rhymes nicely with that they are used for clear operations) and eliminate the ad-hoc constant, but we shouldn't be afraid to rename functions when semantics in fact are different from vim.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/7982,166911857,2018-02-08T11:54:18Z,src/nvim/api/ui.c,"@@ -86,6 +86,7 @@ void nvim_ui_attach(uint64_t channel_id, Integer width, Integer height,   ui->put = remote_ui_put;   ui->bell = remote_ui_bell;   ui->visual_bell = remote_ui_visual_bell;+  ui->default_colors_set = remote_ui_default_colors_set;","Wouldn't that be too similar to `set_highlight`? I would like some qualifier like ""default"" or ""global"" to make the distinction more clear.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/7982,166934794,2018-02-08T13:38:08Z,src/nvim/screen.c,"@@ -5847,30 +5840,16 @@ next_search_hl_pos(   return 0; } -static void screen_start_highlight(int attr)-{-  screen_attr = attr;-  ui_start_highlight(attr);-}--static void screen_stop_highlight(void)-{-  ui_stop_highlight();",Definitely. If the semantics changed then that was just my misunderstanding.,
886074,teto,https://api.github.com/repos/neovim/neovim/pulls/7986,167567330,2018-02-12T14:19:15Z,runtime/doc/options.txt,"@@ -2387,14 +2387,18 @@ A jump table for the options with a short description can be found at |Q_op|. 	  item		default		Used for ~ 	  stl:c		' ' or '^'	statusline of the current window 	  stlnc:c	' ' or '='	statusline of the non-current windows-	  vert:c	'���'		vertical separators |:vsplit|-	  fold:c	'��'		filling 'foldtext'+	  vert:c	'���' or '|'	vertical separators |:vsplit|+	  fold:c	'��' or '-'		filling 'foldtext' 	  diff:c	'-'		deleted lines of the 'diff' option  	Any one that is omitted will fall back to the default.  For ""stl"" and 	""stlnc"" the space will be used when there is highlighting, '^' or '=' 	otherwise. +	For ""vert"" and ""fold"", the new defaults '���' and '��' being of ambiguous+	width for CJK languages, nvim will fallback to the old defaults '|' and+	'-' when |ambiwidth| is set to ""double"".","I tried quickly but any way I could think of was too complex or brittle so I followed your suggestion. I fell back on reverting to old defaults when no vert/fold fillchar is specified. I believe the behavior is not perfect but reasonable: When ambiwdith=double, users who don't set fillchars won't benefit from the new defaults (the only problem is if they try another neovim on a server for instance, they might wonder why with a same neovim version they don't see the same fillchar defaults), if they set vert or fold, the usual behavior applies. Users with ambiwidth=single will see the new defaults and nothing else changes.The TUI dictates the use of monocell characters (for now).",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/7759,167866279,2018-02-13T13:41:17Z,src/nvim/ui.h,"@@ -13,14 +13,22 @@ typedef enum {   kUIPopupmenu,   kUITabline,   kUIWildmenu,+  kUIWidgetCount,","Yes, but can't that be changed if we ever need a switch statement? (which we don't if the keep using the existing pattern of specific widget code always calling into the generic one, and never the other way around)",
9006098,AlexandreDubray,https://api.github.com/repos/neovim/neovim/pulls/7969,168028705,2018-02-13T22:51:43Z,src/nvim/message.c,"@@ -572,8 +564,22 @@ int emsg(const char_u *s_)    // Display the error message itself.   msg_nowait = false;  // Wait for this msg.-  return msg_attr(s, attr);+  return (*msg_attr)(s, attr);+}++/*+ * emsg() - display an error message+ *+ * Rings the bell, if appropriate, and calls message() to do the real work+ * When terminal not initialized (yet) mch_errmsg(..) is used.+ *+ * return TRUE if wait_return not called+ */+int emsg(const char_u *s_)","Oh god, I must be blind. Sorry for that, I will change it immediately so I will not forget anymore !",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/8004,168132184,2018-02-14T10:25:34Z,src/nvim/api/vim.c,"@@ -1468,3 +1474,17 @@ Float nvim__id_float(Float flt) {   return flt; }++Array nvim_list_uis(void)+  FUNC_API_SINCE(1)+{+  Array alluis = ARRAY_DICT_INIT;+  for (unsigned int i = 0; i < ui_count ; i++) {+    Dictionary dic = ARRAY_DICT_INIT;+    PUT(dic, ""width"", INTEGER_OBJ(uis[i]->width));+    PUT(dic, ""height"", INTEGER_OBJ(uis[i]->height));+    PUT(dic, ""ui_options"", OBJECT_OBJ(api_metadata().items[3].value));","Metadata is effectively a compile-time constant, instead use a `UIExtension k` loop with `ui_ext_names[k]` and `ui->ui_ext[k]`. Also I think we can just include the options in the top level dict for each UI.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/7917,168189251,2018-02-14T14:27:18Z,runtime/doc/msgpack_rpc.txt,"@@ -242,4 +242,170 @@ Even for statically compiled clients it is good practice to avoid hardcoding the type codes, because a client may be built against one Nvim version but connect to another with different type codes. +==============================================================================+6. Buffer Updates				      *buffer-updates* *rpc-buffer-updates*++A dedicated API has been created to allow co-processes to be notified  when a+buffer is changed in any way. It is difficult and error-prone to try and do+this with autocommands such as |TextChanged|.++                                                              *buffer-updates-api*+BufferUpdates Functions~++nvim_buf_updates_start({send_buffer})                   *nvim_buf_updates_start()*","Function docs with argument lists will be auto-generated from the doxygen docs, so these shouldn't be duplicated here. See `:help api-buffer` for example of the results. (Which means it's also fine for the docs inside `api/*.c` to use helptags, so the reference to the events can be moved there)",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/8006,168267658,2018-02-14T18:29:30Z,src/nvim/syntax.c,"@@ -7685,6 +7689,10 @@ void highlight_changed(void)     }   }   highlight_ga.ga_len = hlcnt;++  ui_call_highlight_info_set(changed_highlights);","Yes, the only issue is that we might need some kind of batching. If the user reloads their color scheme it should only be sent once in total. Might follow similar scheme as `pending_cursor_update` in `ui.c`: when a highlight group changes set it to true, and in `ui_cursor_shape` send the `mode_info_set` if the flag is true.",
12918431,geekodour,https://api.github.com/repos/neovim/neovim/pulls/8004,168365182,2018-02-15T01:51:16Z,src/nvim/api/vim.c,"@@ -1468,3 +1474,17 @@ Float nvim__id_float(Float flt) {   return flt; }++Array nvim_list_uis(void)+  FUNC_API_SINCE(1)+{+  Array alluis = ARRAY_DICT_INIT;+  for (unsigned int i = 0; i < ui_count ; i++) {+    Dictionary dic = ARRAY_DICT_INIT;+    PUT(dic, ""width"", INTEGER_OBJ(uis[i]->width));+    PUT(dic, ""height"", INTEGER_OBJ(uis[i]->height));+    PUT(dic, ""ui_options"", OBJECT_OBJ(api_metadata().items[3].value));","@bfredl I spent quite a lot of time figuring this out but failed,putting the following inside `nvim_list_uis` does not work because no way `uis[i]->ui_ext_names[i]` is valid.```cfor (UIExtension i = 0; i < kUIExtCount; i++) {  PUT(dic, ui_ext_names[i], copy_object(uis[i]->ui_ext_names[i]));}```I don't know if `ui->ui_ext[k]` can help here, because `ui_ext` is a bool and is a belongs to the `ui`Either will have to just hardcode the `ui_options` properties one by one else have to use some kind of offset as described here i guess: http://c-faq.com/struct/fieldnames.html",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/8018,168840242,2018-02-16T18:51:18Z,test/functional/core/job_spec.lua,"@@ -78,8 +80,17 @@ describe('jobs', function()     else       nvim('command', ""let j = jobstart('pwd', g:job_opts)"")     end+    if iswin() then+    eq_any({'notification', 'stdout', {0, {dir}}},+           {'notification', 'stdout', {0, {dir, ''}}},+           next_msg())+    eq_any({'notification', 'stdout', {0, {}}},",This should never happen (empty list),
12918431,geekodour,https://api.github.com/repos/neovim/neovim/pulls/8004,168841236,2018-02-16T18:55:15Z,src/nvim/api/vim.c,"@@ -1468,3 +1473,19 @@ Float nvim__id_float(Float flt) {   return flt; }++Array nvim_list_uis(void)+  FUNC_API_SINCE(1)+{+  Array alluis = ARRAY_DICT_INIT;+  for (unsigned int i = 0; i < ui_count ; i++) {+    Dictionary dic = ARRAY_DICT_INIT;+    PUT(dic, ""width"", INTEGER_OBJ(uis[i]->width));+    PUT(dic, ""height"", INTEGER_OBJ(uis[i]->height));","Yes, I'll list all the other properties now. ",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/8018,168847649,2018-02-16T19:21:19Z,test/functional/core/job_spec.lua,"@@ -78,8 +80,17 @@ describe('jobs', function()     else       nvim('command', ""let j = jobstart('pwd', g:job_opts)"")     end+    if iswin() then+    eq_any({'notification', 'stdout', {0, {dir}}},+           {'notification', 'stdout', {0, {dir, ''}}},+           next_msg())+    eq_any({'notification', 'stdout', {0, {}}},","""lines"" doesn't exist as a fundamental concept, from libuv we receive bytes and only bytes. And we unambiguously represent EOF as `{''}`, empty list never happens.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/8020,168941777,2018-02-18T07:07:24Z,runtime/autoload/provider/clipboard.vim,"@@ -48,20 +48,38 @@ endfunction let s:cache_enabled = 1 let s:err = '' +"" Our code does a few assumptions about the clipboard dictionary.+"" Check for all required keys and their properly typed values.+function! s:valid_clipboard_format(clipboard) abort+  if type({}) != type(a:clipboard)+    let s:err = 'g:clipboard is no Dictionary'+  elseif type({}) != type(get(a:clipboard, 'copy', v:null))+    let s:err = 'g:clipboard has no `copy` key with type Dictionary'","    g:clipboard[""copy""] is missing or invalidIt's nice to be specific, but ""has no copy key with type Dictionary"" is confusing if the key exists, even if it is technically correct. ",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/8018,168941877,2018-02-18T07:13:25Z,test/functional/core/job_spec.lua,"@@ -78,8 +80,17 @@ describe('jobs', function()     else       nvim('command', ""let j = jobstart('pwd', g:job_opts)"")     end+    if iswin() then+    eq_any({'notification', 'stdout', {0, {dir}}},+           {'notification', 'stdout', {0, {dir, ''}}},+           next_msg())+    eq_any({'notification', 'stdout', {0, {}}},","No, expect_twolines, but  I saw it was to limited, it can't handle a final `\n`, only `\n` between two chunks.  Ideally we should join both functions to a generic `expect_streams` that supports _any_ division into chunks as they semantically are equal.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/8018,168956141,2018-02-18T15:54:36Z,test/functional/core/job_spec.lua,"@@ -308,8 +317,15 @@ describe('jobs', function()     nvim('command', 'unlet g:job_opts.on_exit')     nvim('command', 'let g:job_opts.user = 5')     nvim('command', [[call jobstart('echo ""foo""', g:job_opts)]])-    eq({'notification', 'stdout', {5, {'foo', ''}}}, next_msg())-    eq({'notification', 'stdout', {5, {''}}}, next_msg())+    expect_msg_seq(+      { {'notification', 'stdout', {5, {'foo', ''} } },+        {'notification', 'stdout', {5, {''} } }+      },+      -- Alternative sequence:+      { {'notification', 'stdout', {5, {'foo'} } },+        {'notification', 'stdout', {5, {'', ''} } }+      }","`expect_msg_seq()` accepts multiple sequences and will call `next_message()` enough times to compare the shortest sequence. If longer sequences are tried, it will call `next_message()` again as needed.In this case both possible sequences have length 2, so `next_message()` is called twice.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/7412,168961741,2018-02-18T19:03:24Z,test/functional/autocmd/termclose_spec.lua,"@@ -23,14 +23,15 @@ describe('TermClose event', function()   end)    it('triggers when long-running terminal job gets stopped', function()","Just noticed we should remove ""long-running"" from the description.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/8013,168965494,2018-02-18T21:06:08Z,src/nvim/syntax.c,"@@ -7760,6 +7760,17 @@ static void highlight_list_two(int cnt, int attr) const char *get_highlight_name(expand_T *const xp, const int idx)   FUNC_ATTR_WARN_UNUSED_RESULT {+  if (idx < 0) {+    return NULL;+  }++  // Items are never removed from the table, skip the ones that were cleared.+  int current_idx = idx;",`current_idx` was added in https://github.com/neovim/neovim/pull/7424 . We need to remove it now. And we need to remove `const` from the `idx` parameter.,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/8004,169198717,2018-02-20T01:13:00Z,src/nvim/api/vim.c,"@@ -35,13 +35,18 @@ #include ""nvim/os/input.h"" #include ""nvim/viml/parser/expressions.h"" #include ""nvim/viml/parser/parser.h""+#include ""nvim/ui.h""  #define LINE_BUFFER_SIZE 4096+#define MAX_UI_COUNT 16  #ifdef INCLUDE_GENERATED_DECLARATIONS # include ""api/vim.c.generated.h"" #endif +extern UI *uis[MAX_UI_COUNT];+extern size_t ui_count;","This is what I wanted to avoid. I would suggest instead creating a wrapper function in ui.h, and just call it from `nvim_list_uis()` (which lives in vim.c):```cArray nvim_list_uis(void)  FUNC_API_SINCE(4){  return ui_list();}```Then we avoid pulling UI stuff into vim.c.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/8060,170536882,2018-02-26T09:42:18Z,src/nvim/ex_docmd.c,"@@ -9952,3 +9953,104 @@ bool cmd_can_preview(char_u *cmd)    return false; }++/// Return the list of the commands in the specified buffer,+/// if no buffer is specified, then return list of global(non-buffer) the+/// commands+///+/// @param[in] buf the specified buffer, if NULL then global commands required+///+/// @return The array of the commands and the information of each command+ArrayOf(Dictionary) get_commands(buf_T *buf)","Not sure if it's the best convention, but our current convention (for internal wrappers that convert internal structures to `Array`) is to name this `commands_array`. Existing examples: `mode_style_array`, `keymap_array`. Until a better convention is found, we should always do the same thing, to avoid having numerous inconsistent patterns.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/8042,170563832,2018-02-26T11:33:26Z,third-party/cmake/BuildLibtermkey.cmake,"@@ -43,6 +43,7 @@ ExternalProject_Add(libtermkey                               PREFIX=${DEPS_INSTALL_DIR}                               PKG_CONFIG_PATH=${DEPS_LIB_DIR}/pkgconfig                               CFLAGS=-fPIC+                              CFLAGS+=-g","The short answer is: just change this line to `CFLAGS+=-Og CFLAGS+=-g`.The long answer is: `-Og` is not supported by some compilers/versions, so we need to use `HAS_OG_FLAG` to decide whether `-Og` can be included here.> Are we talking about Debug or ReleaseWithDebInfo now? What am I supposed to do for which build type?I don't understand the question, we aren't doing anything different for different build-types.  We're just trying to enable optimizations (`-Og`) if possible. `-Og` enables any optimizations that don't inhibit debugging (as opposed to `-O1`, `-O2`, ...).",
15214129,nimitbhardwaj,https://api.github.com/repos/neovim/neovim/pulls/8060,170854783,2018-02-27T09:08:13Z,src/nvim/ex_docmd.c,"@@ -9989,23 +9989,23 @@ ArrayOf(Dictionary) get_commands(buf_T *buf)     case(EXTRA|NEEDARG):       Arg[0] = '+'; break;     case(EXTRA|NOSPC|NEEDARG): Arg[0] = '1'; break;     }-    PUT(dic, ""Argument"", STRING_OBJ(cstr_to_string((const char *)Arg)));+    PUT(dic, ""argument"", STRING_OBJ(cstr_to_string((const char *)Arg)));      // Defination-    PUT(dic, ""Defination"",+    PUT(dic, ""defination"",","Okk, so, I think my english is sooo bad, I generally used defination, it was wrong, :laughing: ",
15214129,nimitbhardwaj,https://api.github.com/repos/neovim/neovim/pulls/8060,170863756,2018-02-27T09:41:39Z,src/nvim/ex_docmd.c,"@@ -9952,3 +9953,104 @@ bool cmd_can_preview(char_u *cmd)    return false; }++/// Return the list of the commands in the specified buffer,+/// if no buffer is specified, then return list of global(non-buffer) the+/// commands+///+/// @param[in] buf the specified buffer, if NULL then global commands required+///+/// @return The array of the commands and the information of each command+ArrayOf(Dictionary) commands_array(buf_T *buf)+{+  Array rv = ARRAY_DICT_INIT;+  int i = 0, j = 0;+  char Arg[2] = """";+  garray_T *gap;+  if (buf == NULL) {+    gap = &ucmds;+  } else {+    gap = &buf->b_ucmds;+  }+  for (i = 0; i < gap->ga_len; i++) {+    Dictionary dic = ARRAY_DICT_INIT;+    bool ck = false, ck2 = false;+    char Range[10] = """";+    ucmd_T *cmd = USER_CMD_GA(gap, i);++    // Name+    PUT(dic, ""name"", STRING_OBJ(cstr_to_string((const char *)cmd->uc_name)));++    // Argument+    switch (cmd->uc_argt & (EXTRA|NOSPC|NEEDARG)) {+    case 0:                    Arg[0] = '0'; break;+    case(EXTRA):               Arg[0] = '*'; break;+    case(EXTRA|NOSPC):         Arg[0] = '?'; break;+    case(EXTRA|NEEDARG):       Arg[0] = '+'; break;+    case(EXTRA|NOSPC|NEEDARG): Arg[0] = '1'; break;+    }+    PUT(dic, ""argument"", STRING_OBJ(cstr_to_string((const char *)Arg)));++    // Definition+    PUT(dic, ""definition"",+        STRING_OBJ(cstr_to_string((const char *)cmd->uc_rep)));++    // Complete+    for (j = 0; command_complete[j].expand != 0; j++) {+      if (cmd->uc_compl == command_complete[j].expand) {","This operation can be made more fast, command_complete is just a static array, we manually inserted the items in it, if the items there are added in sorted order then by using binary search O(log(n)) complexity can be achieved instead of O(n), so possibliity can be just arange the items in array, replace linear search with bin search",
15214129,nimitbhardwaj,https://api.github.com/repos/neovim/neovim/pulls/8060,170882207,2018-02-27T10:47:00Z,src/nvim/ex_docmd.c,"@@ -9952,3 +9953,104 @@ bool cmd_can_preview(char_u *cmd)    return false; }++/// Return the list of the commands in the specified buffer,+/// if no buffer is specified, then return list of global(non-buffer) the+/// commands+///+/// @param[in] buf the specified buffer, if NULL then global commands required+///+/// @return The array of the commands and the information of each command+ArrayOf(Dictionary) commands_array(buf_T *buf)+{+  Array rv = ARRAY_DICT_INIT;+  int i = 0, j = 0;+  char Arg[2] = """";+  garray_T *gap;+  if (buf == NULL) {+    gap = &ucmds;+  } else {+    gap = &buf->b_ucmds;+  }+  for (i = 0; i < gap->ga_len; i++) {+    Dictionary dic = ARRAY_DICT_INIT;+    bool ck = false, ck2 = false;+    char Range[10] = """";+    ucmd_T *cmd = USER_CMD_GA(gap, i);++    // Name+    PUT(dic, ""name"", STRING_OBJ(cstr_to_string((const char *)cmd->uc_name)));++    // Argument+    switch (cmd->uc_argt & (EXTRA|NOSPC|NEEDARG)) {+    case 0:                    Arg[0] = '0'; break;+    case(EXTRA):               Arg[0] = '*'; break;+    case(EXTRA|NOSPC):         Arg[0] = '?'; break;+    case(EXTRA|NEEDARG):       Arg[0] = '+'; break;+    case(EXTRA|NOSPC|NEEDARG): Arg[0] = '1'; break;+    }+    PUT(dic, ""argument"", STRING_OBJ(cstr_to_string((const char *)Arg)));++    // Definition+    PUT(dic, ""definition"",+        STRING_OBJ(cstr_to_string((const char *)cmd->uc_rep)));++    // Complete+    for (j = 0; command_complete[j].expand != 0; j++) {+      if (cmd->uc_compl == command_complete[j].expand) {","No, leave it here, because, there is a line, [here](https://github.com/neovim/neovim/blob/611351677dba450fc1a312061572c44c7e3d6482/src/nvim/ex_docmd.c#L5866), which suggests this implementation being better",
15214129,nimitbhardwaj,https://api.github.com/repos/neovim/neovim/pulls/8060,170895487,2018-02-27T11:42:29Z,src/nvim/ex_docmd.c,"@@ -9952,3 +9953,104 @@ bool cmd_can_preview(char_u *cmd)    return false; }++/// Return the list of the commands in the specified buffer,+/// if no buffer is specified, then return list of global(non-buffer) the+/// commands+///+/// @param[in] buf the specified buffer, if NULL then global commands required+///+/// @return The array of the commands and the information of each command+ArrayOf(Dictionary) commands_array(buf_T *buf)+{+  Array rv = ARRAY_DICT_INIT;+  int i = 0, j = 0;+  char Arg[2] = """";+  garray_T *gap;+  if (buf == NULL) {+    gap = &ucmds;+  } else {+    gap = &buf->b_ucmds;+  }+  for (i = 0; i < gap->ga_len; i++) {+    Dictionary dic = ARRAY_DICT_INIT;+    bool ck = false, ck2 = false;+    char Range[10] = """";+    ucmd_T *cmd = USER_CMD_GA(gap, i);++    // Name+    PUT(dic, ""name"", STRING_OBJ(cstr_to_string((const char *)cmd->uc_name)));++    // Argument+    switch (cmd->uc_argt & (EXTRA|NOSPC|NEEDARG)) {+    case 0:                    Arg[0] = '0'; break;+    case(EXTRA):               Arg[0] = '*'; break;+    case(EXTRA|NOSPC):         Arg[0] = '?'; break;+    case(EXTRA|NEEDARG):       Arg[0] = '+'; break;+    case(EXTRA|NOSPC|NEEDARG): Arg[0] = '1'; break;+    }+    PUT(dic, ""argument"", STRING_OBJ(cstr_to_string((const char *)Arg)));++    // Definition+    PUT(dic, ""definition"",+        STRING_OBJ(cstr_to_string((const char *)cmd->uc_rep)));++    // Complete+    for (j = 0; command_complete[j].expand != 0; j++) {+      if (cmd->uc_compl == command_complete[j].expand) {","I sorted the list of commands according to the values of EXPAND_, now I want to test if it will be correct, will `get_user_cmd_complete` function pose no difficulty, where is its test",
15214129,nimitbhardwaj,https://api.github.com/repos/neovim/neovim/pulls/8060,171148099,2018-02-28T05:44:06Z,src/nvim/ex_docmd.c,"@@ -4867,50 +4868,58 @@ static struct {  * List of names for completion for "":command"" with the EXPAND_ flag.  * Must be alphabetical for completion.  */-static struct {-  int expand;-  char    *name;-} command_complete[] =-{-  { EXPAND_AUGROUP, ""augroup"" },-  { EXPAND_BEHAVE, ""behave"" },-  { EXPAND_BUFFERS, ""buffer"" },-  { EXPAND_CHECKHEALTH, ""checkhealth"" },-  { EXPAND_COLORS, ""color"" },-  { EXPAND_COMMANDS, ""command"" },-  { EXPAND_COMPILER, ""compiler"" },-  { EXPAND_CSCOPE, ""cscope"" },-  { EXPAND_USER_DEFINED, ""custom"" },-  { EXPAND_USER_LIST, ""customlist"" },-  { EXPAND_DIRECTORIES, ""dir"" },-  { EXPAND_ENV_VARS, ""environment"" },-  { EXPAND_EVENTS, ""event"" },-  { EXPAND_EXPRESSION, ""expression"" },-  { EXPAND_FILES, ""file"" },-  { EXPAND_FILES_IN_PATH, ""file_in_path"" },-  { EXPAND_FILETYPE, ""filetype"" },-  { EXPAND_FUNCTIONS, ""function"" },-  { EXPAND_HELP, ""help"" },-  { EXPAND_HIGHLIGHT, ""highlight"" },-  { EXPAND_HISTORY, ""history"" },+static const char *command_complete[] =+{+  [EXPAND_AUGROUP] = ""augroup"",+  [EXPAND_BEHAVE] = ""behave"",+  [EXPAND_BUFFERS] = ""buffer"",+  [EXPAND_CHECKHEALTH] = ""checkhealth"",+  [EXPAND_COLORS] = ""color"",+  [EXPAND_COMMANDS] = ""command"",+  [EXPAND_COMPILER] = ""compiler"",+  [EXPAND_CSCOPE] = ""cscope"",+  [EXPAND_USER_DEFINED] = ""custom"",+  [EXPAND_USER_LIST] = ""customlist"",+  [EXPAND_DIRECTORIES] = ""dir"",+  [EXPAND_ENV_VARS] = ""environment"",+  [EXPAND_EVENTS] = ""event"",+  [EXPAND_EXPRESSION] = ""expression"",+  [EXPAND_FILES] = ""file"",+  [EXPAND_FILES_IN_PATH] = ""file_in_path"",+  [EXPAND_FILETYPE] = ""filetype"",+  [EXPAND_FUNCTIONS] = ""function"",+  [EXPAND_HELP] = ""help"",+  [EXPAND_HIGHLIGHT] = ""highlight"",+  [EXPAND_HISTORY] = ""history"", #ifdef HAVE_WORKING_LIBINTL-  { EXPAND_LOCALES, ""locale"" },+  [EXPAND_LOCALES] = ""locale"", #endif-  { EXPAND_MAPPINGS, ""mapping"" },-  { EXPAND_MENUS, ""menu"" },-  { EXPAND_MESSAGES, ""messages"" },-  { EXPAND_OWNSYNTAX, ""syntax"" },-  { EXPAND_SYNTIME, ""syntime"" },-  { EXPAND_SETTINGS, ""option"" },-  { EXPAND_PACKADD, ""packadd"" },-  { EXPAND_SHELLCMD, ""shellcmd"" },-  { EXPAND_SIGN, ""sign"" },-  { EXPAND_TAGS, ""tag"" },-  { EXPAND_TAGS_LISTFILES, ""tag_listfiles"" },-  { EXPAND_USER, ""user"" },-  { EXPAND_USER_VARS, ""var"" },-  { 0, NULL }+  [EXPAND_MAPPINGS] = ""mapping"",+  [EXPAND_MENUS] = ""menu"",+  [EXPAND_MESSAGES] = ""messages"",+  [EXPAND_OWNSYNTAX] = ""syntax"",+  [EXPAND_SYNTIME] = ""syntime"",+  [EXPAND_SETTINGS] = ""option"",+  [EXPAND_PACKADD] = ""packadd"",+  [EXPAND_SHELLCMD] = ""shellcmd"",+  [EXPAND_SIGN] = ""sign"",+  [EXPAND_TAGS] = ""tag"",+  [EXPAND_TAGS_LISTFILES] = ""tag_listfiles"",+  [EXPAND_USER] = ""user"",+  [EXPAND_USER_VARS] = ""var"",+  [0] = """",","I previously thought it would be needed if there is some match with 0, but actually the condition was `command_complete[i].expand != 0` and as I modified the code, now it is not needed, I am going to remove it",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/8081,171353238,2018-02-28T19:11:33Z,src/nvim/ui.c,"@@ -186,6 +186,10 @@ Dictionary hlattrs2dict(const HlAttrs *aep, bool use_rgb)     PUT(hl, ""bold"", BOOLEAN_OBJ(true));   } +  if (mask & HL_STANDOUT) {","Also remove `HL_STANDOUT` from ""reverse"" condition below. ",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/8094,172023294,2018-03-03T17:43:48Z,ci/before_install.sh,"@@ -23,20 +23,20 @@ echo 'python info:'   2>&1 pyenv versions || true ) | sed 's/^/  /' +if [[ ""${TRAVIS_OS_NAME}"" == osx ]]; then+    echo ""Install Python 2.""+    brew install python@2","Ok, but with the current changes we are no longer installing python3. Was that intentional? `brew install python3` was removed, is python3 assumed to exist already?(edit: based on https://travis-ci.org/neovim/neovim/jobs/348685132 it looks like it works ok.)",
287744,prabirshrestha,https://api.github.com/repos/neovim/neovim/pulls/7996,172035647,2018-03-04T03:01:54Z,src/nvim/testdir/test_autocmd.vim,"@@ -823,6 +823,7 @@ func Test_Cmdline()   au! CmdlineLeave endfunc +<<<<<<< HEAD",seems like a bad merge here.,
16161283,b-r-o-c-k,https://api.github.com/repos/neovim/neovim/pulls/8084,172259498,2018-03-05T17:08:31Z,ci/build.bat,"@@ -42,19 +48,19 @@ where.exe neovim-node-host.cmd || goto :error  mkdir .deps cd .deps-cmake -G ""MinGW Makefiles"" -DCMAKE_BUILD_TYPE=RelWithDebInfo ..\third-party\ || goto :error-mingw32-make VERBOSE=1 || goto :error+cmake -G %CMAKE_GENERATOR% -DCMAKE_BUILD_TYPE=RelWithDebInfo ..\third-party\ || goto :error+cmake --build . -- %CMAKE_GENERATOR_ARGS% || goto :error cd ..  :: Build Neovim mkdir build cd build-cmake -G ""MinGW Makefiles"" -DCMAKE_BUILD_TYPE=RelWithDebInfo -DBUSTED_OUTPUT_TYPE=nvim %USE_GCOV% -DGPERF_PRG=""C:\msys64\usr\bin\gperf.exe"" .. || goto :error-mingw32-make VERBOSE=1 || goto :error+cmake -G %CMAKE_GENERATOR% -DCMAKE_BUILD_TYPE=RelWithDebInfo -DBUSTED_OUTPUT_TYPE=nvim %USE_GCOV% -DGPERF_PRG=""C:\msys64\usr\bin\gperf.exe"" .. || goto :error","Yes, it is on the AppVeyor image, but I was wondering if we could add it to the [wintools.zip](https://github.com/neovim/deps/blob/master/opt/win32tools.zip) so Windows devs wouldn't need to download it themselves. Then the only requirements for building Neovim on Windows would be Visual Studio 2017, CMake, git, and Python.",
16161283,b-r-o-c-k,https://api.github.com/repos/neovim/neovim/pulls/8084,172907545,2018-03-07T16:46:55Z,third-party/CMakeLists.txt,"@@ -50,6 +50,13 @@ endif()  option(USE_EXISTING_SRC_DIR ""Skip download of deps sources in case of existing source directory."" OFF) +if(WIN32)+  find_package(Git)",`find_package` will use [FindGit.cmake](https://github.com/Kitware/CMake/blob/v2.8.7/Modules/FindGit.cmake) which is presumably better because it can find Git installations with non-standard names and paths.,
112971,jamessan,https://api.github.com/repos/neovim/neovim/pulls/8122,173506652,2018-03-09T16:55:15Z,scripts/genappimage.sh,"@@ -69,14 +71,16 @@ cd ""$APP_BUILD_DIR"" # Get out of AppImage directory. #   - Expects: $ARCH, $APP, $VERSION env vars #   - Expects: ./$APP.AppDir/ directory #   - Produces: ../out/$APP-$VERSION.glibc$GLIBC_NEEDED-$ARCH.AppImage-generate_appimage+if [ -n ""$TAG"" ]; then+  generate_type2_appimage -u ""gh-releases-zsync|neovim|neovim|$TAG|nvim.appimage.zsync""","It's part of the [spec](https://github.com/AppImage/AppImageSpec/blob/35c50ecc519bdf499e174c1d1cd445b87a37f4e6/draft.md#update-information).  Adding the `-u ...` embeds extra information into the AppImage which AppImageUpdate knows to look for.  When AppImageUpdate sees this, it will check the github releases based on this information to see if an update is available.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/8120,173593264,2018-03-09T23:22:13Z,test/functional/core/job_spec.lua,"@@ -138,7 +139,7 @@ describe('jobs', function()   end)    it('allows interactive commands', function()-    nvim('command', ""let j = jobstart(['cat', '-'], g:job_opts)"")+    nvim('command', ""let j = jobstart(['""..nvim_cat..""', '-'], g:job_opts)"")","Doesn't `foo.cmd` require a shell? So I would not expect this to work, the `jobstart({list})` form skips the shell. That's one reason why including `cat.exe` was important. And changing these invocations to use the shell form of `jobstart({string})` changes the nature of the tests, so we don't want to do that.",
8740057,janlazo,https://api.github.com/repos/neovim/neovim/pulls/8120,173606298,2018-03-10T01:37:21Z,test/functional/core/job_spec.lua,"@@ -138,7 +139,7 @@ describe('jobs', function()   end)    it('allows interactive commands', function()-    nvim('command', ""let j = jobstart(['cat', '-'], g:job_opts)"")+    nvim('command', ""let j = jobstart(['""..nvim_cat..""', '-'], g:job_opts)"")",You're right. I'll keep the list form and run the batchfile with cmd.exe directly. It should be fine if the path of the tempfile doesn't have to be escaped.,
16161283,b-r-o-c-k,https://api.github.com/repos/neovim/neovim/pulls/8124,173636491,2018-03-10T22:04:30Z,ci/build.ps1,"@@ -0,0 +1,125 @@+Set-PSDebug -Trace 1","I added this because it causes each line to be printed as it's executed, similar to `echo on` in Batch, except it doesn't print the arguments used when calling other executables.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/8124,173650689,2018-03-11T11:07:47Z,ci/build.ps1,"@@ -0,0 +1,125 @@+Set-PSDebug -Trace 1++$env:CONFIGURATION -match '^(?<compiler>\w+)_(?<bits>32|64)(?:-(?<option>\w+))?$'+$compiler = $Matches.compiler+$compileOption = $Matches.option+$bits = $Matches.bits+$cmakeBuildType = 'RelWithDebInfo'+$depsCmakeVars = @{+  CMAKE_BUILD_TYPE = $cmakeBuildType;+}+$nvimCmakeVars = @{+  CMAKE_BUILD_TYPE = $cmakeBuildType;+  BUSTED_OUTPUT_TYPE = 'nvim';+  GPERF_PRG = 'C:\msys64\usr\bin\gperf.exe';+}++if ($compiler -eq 'MINGW')+{+  if ($bits -eq 32)+  {+    $arch = 'i686'+  }+  elseif ($bits -eq 64)+  {+    $arch = 'x86_64'+  }+  if ($compileOption -eq 'gcov')+  {+    $cmakeVars['USE_GCOV'] = 'ON'+    $uploadToCodecov = $true+  }+  # These are native MinGW builds, but they use the toolchain inside+  # MSYS2, this allows using all the dependencies and tools available+  # in MSYS2, but we cannot build inside the MSYS2 shell.+  $cmakeGenerator = 'MinGW Makefiles'+  $cmakeGeneratorArgs = 'VERBOSE=1'++  # Add MinGW to the PATH+  $env:Path = ""C:\msys64\mingw$bits\bin;$env:Path""+  # Remove the Git sh.exe from the PATH+  $env:Path = $env:Path.Replace('C:\Program Files\Git\usr\bin', '')++  # Build third-party dependencies+  C:\msys64\usr\bin\bash -lc ""pacman --verbose --noconfirm -Su"" ; exitIfFailed+  C:\msys64\usr\bin\bash -lc ""pacman --verbose --noconfirm --needed -S mingw-w64-$arch-cmake mingw-w64-$arch-perl mingw-w64-$arch-diffutils mingw-w64-$arch-unibilium gperf"" ; exitIfFailed+}+elseif ($compiler -eq 'MSVC')+{+  $cmakeGeneratorArgs = '/verbosity:normal'+  if ($bits -eq 32)+  {+    $cmakeGenerator = 'Visual Studio 15 2017'+  }+  elseif ($bits -eq 64)+  {+    $cmakeGenerator = 'Visual Studio 15 2017 Win64'+  }+}++function convertToCmakeArgs($vars)+{+  return $vars.GetEnumerator() | foreach { ""-D$($_.Key)=$($_.Value)"" }+}++function exitIfFailed($command)+{+  if ($LastExitCode -ne 0)+  {+    exit $LastExitCode+  }+}++# Setup python (use AppVeyor system python)+C:\Python27\python.exe -m pip install neovim ; exitIfFailed+C:\Python35\python.exe -m pip install neovim ; exitIfFailed+# Disambiguate python3+move c:\Python35\python.exe c:\Python35\python3.exe+$env:Path = ""C:\Python35;C:\Python27;$env:Path""+# Sanity check+python  -c ""import neovim; print(str(neovim))"" ; exitIfFailed+python3 -c ""import neovim; print(str(neovim))"" ; exitIfFailed++$env:Path = ""C:\Ruby24\bin;$env:Path""+cmd /c gem.cmd install neovim ; exitIfFailed+where.exe neovim-ruby-host.bat ; exitIfFailed++cmd /c npm.cmd install -g neovim ; exitIfFailed+where.exe neovim-node-host.cmd ; exitIfFailed++mkdir .deps+cd .deps+cmake -G $cmakeGenerator $(convertToCmakeArgs($depsCmakeVars)) ..\third-party\ ; exitIfFailed+cmake --build . --config $cmakeBuildType -- $cmakeGeneratorArgs ; exitIfFailed+cd ..","Apparently powershell doesn't have real subshells, so we still need this `cd foo ... cd ..` pattern.",
16161283,b-r-o-c-k,https://api.github.com/repos/neovim/neovim/pulls/8124,173657422,2018-03-11T14:52:58Z,ci/build.ps1,"@@ -0,0 +1,125 @@+Set-PSDebug -Trace 1++$env:CONFIGURATION -match '^(?<compiler>\w+)_(?<bits>32|64)(?:-(?<option>\w+))?$'+$compiler = $Matches.compiler+$compileOption = $Matches.option+$bits = $Matches.bits+$cmakeBuildType = 'RelWithDebInfo'+$depsCmakeVars = @{+  CMAKE_BUILD_TYPE = $cmakeBuildType;+}+$nvimCmakeVars = @{+  CMAKE_BUILD_TYPE = $cmakeBuildType;+  BUSTED_OUTPUT_TYPE = 'nvim';+  GPERF_PRG = 'C:\msys64\usr\bin\gperf.exe';+}++if ($compiler -eq 'MINGW')+{+  if ($bits -eq 32)+  {+    $arch = 'i686'+  }+  elseif ($bits -eq 64)+  {+    $arch = 'x86_64'+  }+  if ($compileOption -eq 'gcov')+  {+    $cmakeVars['USE_GCOV'] = 'ON'+    $uploadToCodecov = $true+  }+  # These are native MinGW builds, but they use the toolchain inside+  # MSYS2, this allows using all the dependencies and tools available+  # in MSYS2, but we cannot build inside the MSYS2 shell.+  $cmakeGenerator = 'MinGW Makefiles'+  $cmakeGeneratorArgs = 'VERBOSE=1'++  # Add MinGW to the PATH+  $env:Path = ""C:\msys64\mingw$bits\bin;$env:Path""+  # Remove the Git sh.exe from the PATH+  $env:Path = $env:Path.Replace('C:\Program Files\Git\usr\bin', '')++  # Build third-party dependencies+  C:\msys64\usr\bin\bash -lc ""pacman --verbose --noconfirm -Su"" ; exitIfFailed+  C:\msys64\usr\bin\bash -lc ""pacman --verbose --noconfirm --needed -S mingw-w64-$arch-cmake mingw-w64-$arch-perl mingw-w64-$arch-diffutils mingw-w64-$arch-unibilium gperf"" ; exitIfFailed+}+elseif ($compiler -eq 'MSVC')+{+  $cmakeGeneratorArgs = '/verbosity:normal'+  if ($bits -eq 32)+  {+    $cmakeGenerator = 'Visual Studio 15 2017'+  }+  elseif ($bits -eq 64)+  {+    $cmakeGenerator = 'Visual Studio 15 2017 Win64'+  }+}++function convertToCmakeArgs($vars)+{+  return $vars.GetEnumerator() | foreach { ""-D$($_.Key)=$($_.Value)"" }+}++function exitIfFailed($command)+{+  if ($LastExitCode -ne 0)+  {+    exit $LastExitCode+  }+}++# Setup python (use AppVeyor system python)+C:\Python27\python.exe -m pip install neovim ; exitIfFailed+C:\Python35\python.exe -m pip install neovim ; exitIfFailed+# Disambiguate python3+move c:\Python35\python.exe c:\Python35\python3.exe+$env:Path = ""C:\Python35;C:\Python27;$env:Path""","I don't think there's a consistent style of capitalization in PowerShell like there is in Batch, so I decided to go with `$env:Path` because the `ls env:path` command shows that is how it's actually capitalized. It's probably a good idea to use `$env:PATH` because it will look more similar to Batch scripts.",
112971,jamessan,https://api.github.com/repos/neovim/neovim/pulls/8124,173672695,2018-03-11T22:35:17Z,ci/build.ps1,"@@ -0,0 +1,112 @@+Set-PSDebug -Trace 1++$env:CONFIGURATION -match '^(?<compiler>\w+)_(?<bits>32|64)(?:-(?<option>\w+))?$'+$compiler = $Matches.compiler+$compileOption = $Matches.option+$bits = $Matches.bits+$cmakeBuildType = 'RelWithDebInfo'+$depsCmakeVars = @{+  CMAKE_BUILD_TYPE = $cmakeBuildType;+}+$nvimCmakeVars = @{+  CMAKE_BUILD_TYPE = $cmakeBuildType;+  BUSTED_OUTPUT_TYPE = 'nvim';+  GPERF_PRG = 'C:\msys64\usr\bin\gperf.exe';+}++function exitIfFailed() {+  if ($LastExitCode -ne 0) {+    exit $LastExitCode+  }+}++if ($compiler -eq 'MINGW') {+  if ($bits -eq 32) {+    $arch = 'i686'+  }+  elseif ($bits -eq 64) {+    $arch = 'x86_64'+  }+  if ($compileOption -eq 'gcov') {+    $nvimCmakeVars['USE_GCOV'] = 'ON'+    $uploadToCodecov = $true+  }+  # These are native MinGW builds, but they use the toolchain inside+  # MSYS2, this allows using all the dependencies and tools available+  # in MSYS2, but we cannot build inside the MSYS2 shell.+  $cmakeGenerator = 'MinGW Makefiles'+  $cmakeGeneratorArgs = 'VERBOSE=1'++  # Add MinGW to the PATH+  $env:PATH = ""C:\msys64\mingw$bits\bin;$env:PATH""+  # Remove the Git sh.exe from the PATH+  $env:PATH = $env:PATH.Replace('C:\Program Files\Git\usr\bin', '')++  # Build third-party dependencies+  C:\msys64\usr\bin\bash -lc ""pacman --verbose --noconfirm -Su"" ; exitIfFailed+  C:\msys64\usr\bin\bash -lc ""pacman --verbose --noconfirm --needed -S mingw-w64-$arch-cmake mingw-w64-$arch-perl mingw-w64-$arch-diffutils mingw-w64-$arch-unibilium gperf"" ; exitIfFailed+}+elseif ($compiler -eq 'MSVC') {+  $cmakeGeneratorArgs = '/verbosity:normal'+  if ($bits -eq 32) {+    $cmakeGenerator = 'Visual Studio 15 2017'+  }+  elseif ($bits -eq 64) {+    $cmakeGenerator = 'Visual Studio 15 2017 Win64'+  }+}++# Setup python (use AppVeyor system python)+C:\Python27\python.exe -m pip install neovim ; exitIfFailed+C:\Python35\python.exe -m pip install neovim ; exitIfFailed+# Disambiguate python3+move c:\Python35\python.exe c:\Python35\python3.exe+$env:PATH = ""C:\Python35;C:\Python27;$env:PATH""+# Sanity check+python  -c ""import neovim; print(str(neovim))"" ; exitIfFailed+python3 -c ""import neovim; print(str(neovim))"" ; exitIfFailed++$env:PATH = ""C:\Ruby24\bin;$env:PATH""+cmd /c gem.cmd install neovim ; exitIfFailed+where.exe neovim-ruby-host.bat ; exitIfFailed++cmd /c npm.cmd install -g neovim ; exitIfFailed+where.exe neovim-node-host.cmd ; exitIfFailed++function convertToCmakeArgs($vars) {+  return $vars.GetEnumerator() | foreach { ""-D$($_.Key)=$($_.Value)"" }+}++mkdir .deps+cd .deps+cmake -G $cmakeGenerator $(convertToCmakeArgs($depsCmakeVars)) ..\third-party\ ; exitIfFailed+cmake --build . --config $cmakeBuildType -- $cmakeGeneratorArgs ; exitIfFailed+cd ..++# Build Neovim+mkdir build+cd build+cmake -G $cmakeGenerator $(convertToCmakeArgs($nvimCmakeVars)) .. ; exitIfFailed+cmake --build . --config $cmakeBuildType -- $cmakeGeneratorArgs ; exitIfFailed+bin\nvim --version ; exitIfFailed++# Functional tests+cmake --build . --config $cmakeBuildType --target functionaltest -- $cmakeGeneratorArgs ; exitIfFailed++if ($uploadToCodecov) {+  C:\msys64\usr\bin\bash -lc ""cd /c/projects/neovim; bash <(curl -s https://codecov.io/bash) -c -F functionaltest || echo 'codecov upload failed.'""+}++# Old tests+$env:PATH += ';C:\msys64\usr\bin'+& ""C:\msys64\mingw$bits\bin\mingw32-make.exe"" -C $(Convert-Path ..\src\nvim\testdir) VERBOSE=1++if ($uploadToCodecov) {+  C:\msys64\usr\bin\bash -lc ""cd /c/projects/neovim; bash <(curl -s https://codecov.io/bash) -c -F oldtest || echo 'codecov upload failed.'""","No.  The pattern for using codecov is 1) run the relevant tests, 2) upload the results with a flag (`-F ...`) indicating what testing produced the coverage.",
112971,jamessan,https://api.github.com/repos/neovim/neovim/pulls/8107,174321094,2018-03-14T00:03:36Z,src/nvim/os/process.c,"@@ -0,0 +1,168 @@+// This is an open source non-commercial project. Dear PVS-Studio, please check+// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com++#include <uv.h>+#ifdef WIN32+# include <tlhelp32.h>  // for CreateToolhelp32Snapshot+#endif++#if defined(__FreeBSD__)+# include <string.h>+# include <sys/types.h>+# include <sys/user.h>+#endif++#if defined(__APPLE__) || defined(BSD)+# include <sys/sysctl.h>  // kinfo_proc on OpenBSD, NetBSD+# include <pwd.h>+#endif++#include ""nvim/log.h""+#include ""nvim/os/process.h""+#include ""nvim/os/os.h""+#include ""nvim/os/os_defs.h""++#ifdef INCLUDE_GENERATED_DECLARATIONS+# include ""os/process.c.generated.h""+#endif++#ifdef WIN32+static bool os_proc_tree_kill_rec(HANDLE process, int sig)+{+  if (process == NULL) {+    return false;+  }+  PROCESSENTRY32 pe;+  DWORD pid = GetProcessId(process);++  if (pid != 0) {+    HANDLE h = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);+    if (h != INVALID_HANDLE_VALUE) {+      pe.dwSize = sizeof(PROCESSENTRY32);+      if (!Process32First(h, &pe)) {+        goto theend;+      }++      do {+        if (pe.th32ParentProcessID == pid) {+          HANDLE ph = OpenProcess(PROCESS_ALL_ACCESS, false, pe.th32ProcessID);+          if (ph != NULL) {+            os_proc_tree_kill_rec(ph, sig);+            CloseHandle(ph);+          }+        }+      } while (Process32Next(h, &pe));++      CloseHandle(h);+    }+  }++theend:+  return (bool)TerminateProcess(process, (unsigned int)sig);+}+/// Kills process `pid` and its descendants recursively.+bool os_proc_tree_kill(int pid, int sig)+{+  assert(sig >= 0);+  assert(sig == SIGTERM || sig == SIGKILL);+  if (pid > 0) {+    ILOG(""terminating process tree: %d"", pid);+    HANDLE h = OpenProcess(PROCESS_ALL_ACCESS, false, (DWORD)pid);+    return os_proc_tree_kill_rec(h, sig);+  } else {+    ELOG(""invalid pid: %d"", pid);+  }+  return false;+}+#else+/// Kills process group where `pid` is the process group leader.+bool os_proc_tree_kill(int pid, int sig)+{+  assert(sig == SIGTERM || sig == SIGKILL);+  int pgid = getpgid(pid);+  if (pgid > 0) {  // Ignore error. Never kill self (pid=0).+    if (pgid == pid) {+      ILOG(""sending %s to process group: -%d"",+           sig == SIGTERM ? ""SIGTERM"" : ""SIGKILL"", pgid);+      int rv = uv_kill(-pgid, sig);+      return rv == 0;+    } else {+      // Should never happen, because process_spawn() did setsid() in the child.+      ELOG(""pgid %d != pid %d"", pgid, pid);+    }+  } else {+    ELOG(""getpgid(%d) returned %d"", pid, pgid);+  }+  return false;+}+#endif++/// Gets the process ids of the immediate children of process `ppid`.+///+/// @param ppid Process to inspect.+/// @param[out,allocated] proc_list Child process ids.+/// @param[out] proc_count Number of child processes.+/// @return 0 on success, or error code.+int os_proc_children(int ppid, int **proc_list, size_t *proc_count)+{+  int *temp = NULL;+  *proc_list = NULL;+  *proc_count = 0;++#if defined(__APPLE__) || defined(BSD)+  // ref: http://unix.superglobalmegacorp.com/Net2/newsrc/sys/kinfo_proc.h.html+  static int name[] = { CTL_KERN, KERN_PROC, KERN_PROC_ALL, 0 };++  // Get total process count.+  size_t len = 0;+  int rv = sysctl(name, ARRAY_SIZE(name), NULL, &len, NULL, 0);+  if (rv) {+    return 1;+  }++  // Get ALL processes.+  struct kinfo_proc *p_list = xmalloc(len);+  rv = sysctl(name, ARRAY_SIZE(name), p_list, &len, NULL, 0);+  if (rv) {+    xfree(p_list);+    return 1;+  }++  // Collect processes whose parent matches `ppid`.+  bool exists = false;+  size_t p_count = len / sizeof(*p_list);+  for (size_t i = 0; i < p_count; i++) {+    exists |= (p_list[i].kp_proc.p_pid == ppid);","Shouldn't this be```cexists ||= (p_list[i].ki_pid == ppid);if (p_list[i].ki_ppid == ppid) {  temp = xrealloc(temp, (*proc_count + 1) * sizeof(*temp));  temp[*proc_count] = p_list[i].ki_pid;```",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/8076,175189482,2018-03-16T19:13:52Z,test/functional/ui/cmdline_spec.lua,"@@ -168,7 +168,7 @@ describe('external cmdline', function()     ]], nil, nil, function()       eq({{         content = { { {}, ""default"" } },-        firstc = """",+        firstc = ""@"",","I'm not sure this change is good or not. IIRC emtpy firstc should only occur with `input()` so there is no strong reason to change it (and if not, we should consider setting firstc in that other place instead)Also, in this file a test should be added that `inputlist()` works as expected with external cmdline (firstc is set to `#`, prompt if applicable)",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/8076,175190097,2018-03-16T19:16:38Z,test/functional/ui/cmdline_spec.lua,"@@ -168,7 +168,7 @@ describe('external cmdline', function()     ]], nil, nil, function()       eq({{         content = { { {}, ""default"" } },-        firstc = """",+        firstc = ""@"",","Then also, we should consider allowing GUI:s to convert `inputlist()` in to proper dialogs. That would be a separate follow up PR though (so no action needed here)",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/8142,175252438,2018-03-17T09:04:06Z,src/nvim/ascii.h,"@@ -146,7 +146,7 @@ static inline bool ascii_isxdigit(int c) /// Checks if `c` is an ���identifier��� character /// /// That is, whether it is alphanumeric character or underscore.-static inline bool ascii_isident(const int c)+static inline bool ascii_isident(int c)","I agree with @aktau that `const` on (**edit:** _non-pointer_) parameters  is usually more trouble than it's worth, because it cascades to callers. If the function body is large then a local `const` variant could be used instead.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/8107,175252714,2018-03-17T09:17:09Z,src/nvim/lua/vim.lua,"@@ -1,3 +1,46 @@+local function system(cmd)+  local out = vim.api.nvim_call_function('system', { cmd })+  local err = vim.api.nvim_get_vvar('shell_error')+  local args_str = vim.api.nvim_call_function('string', { cmd })+  if 0 ~= err then+    error('command failed: '..args_str)+  end+  return out+end++local function systemlist(...)","@neovim/core I'm considering documenting these Lua-flavored `systemlist()` and `system()` variants in `:help lua` as part of the `vim` module. The normal Lua idiom would be to return `status, rv` pair, where `status=false` on failure. But I think it's really useful to show the failed command with `error()`. Thoughts?",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/8107,175254916,2018-03-17T11:01:05Z,src/nvim/lua/vim.lua,"@@ -1,3 +1,65 @@+local function system(cmd)","Until we have lua native job control this should probably use `systemlist` (or even better viml job control to distinguish stderr) internally and do a safe conversion to lua binary string, so that this function handles binary data correctly (unlike vimL `system()` where this is impossible)",
886074,teto,https://api.github.com/repos/neovim/neovim/pulls/8107,175254959,2018-03-17T11:02:47Z,src/nvim/lua/vim.lua,"@@ -1,3 +1,65 @@+local function system(cmd)",or even remove the function to force using systemlist which is better in every way.,
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/8076,175260266,2018-03-17T14:51:58Z,test/functional/ui/cmdline_spec.lua,"@@ -168,7 +168,7 @@ describe('external cmdline', function()     ]], nil, nil, function()       eq({{         content = { { {}, ""default"" } },-        firstc = """",+        firstc = ""@"",","Not sure i follow, only `input()` is `input()` (well, except for `inputdialog()` for the moment). Number (`inputlist()` ) is a new and different cmdline type, and should definitely be marked with `firstc = '#'` (even if prompt is available, we will need to update the docs). I was speaking if some other cmdline type  also happened to set `firstc = """"` already (maybe some ex mode state), it is probably much rarer and so nicer to clients to change that instead.",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/8142,175262535,2018-03-17T16:20:48Z,src/nvim/ascii.h,"@@ -146,7 +146,7 @@ static inline bool ascii_isxdigit(int c) /// Checks if `c` is an ���identifier��� character /// /// That is, whether it is alphanumeric character or underscore.-static inline bool ascii_isident(const int c)+static inline bool ascii_isident(int c)",I have const in parameters for the similar reasons languages like Rust have const by default: it is safer to have data immutable by default.,
189413,aktau,https://api.github.com/repos/neovim/neovim/pulls/8142,175264879,2018-03-17T17:46:59Z,src/nvim/ascii.h,"@@ -146,7 +146,7 @@ static inline bool ascii_isxdigit(int c) /// Checks if `c` is an ���identifier��� character /// /// That is, whether it is alphanumeric character or underscore.-static inline bool ascii_isident(const int c)+static inline bool ascii_isident(int c)","Right. `const` on values restricts the callee while telling the caller nothing. In contrast, `const` on ""references"" (like a pointer) does tell the caller something (I won't do anything to the value your pointer points to).  In the same vein, `restrict` tells the caller something, and is thus also useful in prototypes (thought only in very very select circumstances). At that point, my argument for not declaring parameters like `const size_t ...` is just to avoid word soup and to let callers focus on what's important.In (really) long functions, I prefer not modifying variables/parameters: I'd declare a new one with a better name. In short(er) functions, I find that modifying a parameter or variable usually makes the code even shorter. The modification is obvious as the function fits in a limited viewport. One can keep the value flow in one's head.Another way of looking at it which is often tied to the length of the function: when you have to think hard about the new name of something, that usually means it's a good candidate for re-assignment instead of just creating a similar variable with a new name.> I have const in parameters for the similar reasons languages like Rust have const by default: it is safer to have data immutable by default.I'm not doubting that it restricts the actions of the programmer a bit, which is usually safer. I'd be interested to read about where this is safer in our codebase, given that we're talking about `const` on value types (`char, int, double, struct, ...`).",
8445768,coditva,https://api.github.com/repos/neovim/neovim/pulls/8076,175278783,2018-03-18T06:36:29Z,test/functional/ui/cmdline_spec.lua,"@@ -168,7 +168,7 @@ describe('external cmdline', function()     ]], nil, nil, function()       eq({{         content = { { {}, ""default"" } },-        firstc = """",+        firstc = ""@"",","Oh, I get it now! There is another mode `:insert` with `firstc = NUL`. The line `ccline.cmdfirstc = (firstc == '@' ? 0 : firstc)` makes `cmdfirstc` for both `:insert` and `input()` same, but I guess that's because they are so similar.I think I understand it now and should revert back to `firstc = """"` for `@` mode.",
16161283,b-r-o-c-k,https://api.github.com/repos/neovim/neovim/pulls/8128,175297778,2018-03-18T18:00:21Z,third-party/cmake/Libvterm-tbl2inc_c.cmake,"@@ -0,0 +1,163 @@+cmake_minimum_required(VERSION 2.8.7)++set(HEX_ALPHABET ""0123456789abcdef"")++function(ConvertToHex dec hex)+  while(dec GREATER 0)+    math(EXPR _val ""${dec} % 16"")+    math(EXPR dec ""${dec} / 16"")+    string(SUBSTRING ${HEX_ALPHABET} ${_val} 1 _val)+    set(_res ""${_val}${_res}"")+  endwhile()+  # Pad the result with the number of zeros+  # specified by the optional third argument+  if(${ARGC} EQUAL 3)+    set(padding ${ARGV2})+    string(LENGTH ${_res} _resLen)+    if(_resLen LESS ${padding})+      math(EXPR _neededPadding ""${padding} - ${_resLen}"")+      foreach(i RANGE 1 ${_neededPadding})+	set(_res ""0${_res}"")"," Sorry, I accidentally inserted tabs in some places because I wasn't using `expandtab`. It's fixed now.",
16161283,b-r-o-c-k,https://api.github.com/repos/neovim/neovim/pulls/8128,175297855,2018-03-18T18:02:56Z,third-party/cmake/BuildGperf.cmake,"@@ -36,15 +36,28 @@ function(BuildGperf)     INSTALL_COMMAND ""${_gperf_INSTALL_COMMAND}"") endfunction() -set(GPERF_BUILDARGS CC=${HOSTDEPS_C_COMPILER} LD=${HOSTDEPS_C_COMPILER})",I removed this variable because it appears to be unused.,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/8128,175307457,2018-03-18T22:43:17Z,third-party/cmake/LibvtermCMakeLists.txt,"@@ -60,13 +68,24 @@ set_target_properties(harness PROPERTIES   # run-test.pl expects to find the harness in t/.libs/   RUNTIME_OUTPUT_DIRECTORY t/.libs) -file(GLOB TESTFILES ${CMAKE_SOURCE_DIR}/t/*.test)-add_custom_target(check)-foreach(testfile ${TESTFILES})-  get_filename_component(target_name ${testfile} NAME_WE)-  add_custom_target(${target_name}-    COMMAND ${PERL_EXECUTABLE} ${CMAKE_SOURCE_DIR}/t/run-test.pl ${testfile}-    COMMENT ""**${target_name} **""-    DEPENDS harness)-  add_dependencies(check ${target_name})-endforeach()+if(Perl_FOUND)+  file(GLOB TESTFILES ${CMAKE_SOURCE_DIR}/t/*.test)+  add_custom_target(check)+  foreach(testfile ${TESTFILES})+    get_filename_component(target_name ${testfile} NAME_WE)+    add_custom_target(${target_name}+      COMMAND ${PERL_EXECUTABLE} ${CMAKE_SOURCE_DIR}/t/run-test.pl ${testfile}+      COMMENT ""**${target_name} **""+      DEPENDS harness)+    add_dependencies(check ${target_name})+  endforeach()++  foreach(header_path ${TBL_FILES_HEADERS})+    get_filename_component(header_name ${header_path} NAME)+    set(perl_header_path ${CMAKE_BINARY_DIR}/encoding-test/${header_name})+    add_custom_target(test-${header_name}+      COMMAND ${CMAKE_COMMAND} -E compare_files+              ${header_path} ${perl_header_path}+      DEPENDS ${header_path} ${perl_header_path})+  endforeach()","How does one actually run these? Perhaps they should be dependencies on one of the main targets (`unittest` ? or a new meta-target ?) Otherwise this code is ""dead"", no one will know to run it :) I guess the `check` target above was never run either.",
8740057,janlazo,https://api.github.com/repos/neovim/neovim/pulls/8120,175514278,2018-03-19T17:12:41Z,test/functional/core/job_spec.lua,"@@ -511,7 +565,12 @@ describe('jobs', function()      it('will return status codes in the order of passed ids', function()       source([[-      call rpcnotify(g:channel, 'wait', jobwait([+      call rpcnotify(g:channel, 'wait', jobwait(has('win32') ? [+      \  jobstart('Start-Sleep -Milliseconds 70; exit 4'),+      \  jobstart('Start-Sleep -Milliseconds 50; exit 5'),+      \  jobstart('Start-Sleep -Milliseconds 30; exit 6'),+      \  jobstart('Start-Sleep -Milliseconds 10; exit 7')","Bump the sleep timeout to (1)700, (1)500, (1)300, (1)100 or use cmd.exe and ping instead?The timeout test for jobwait lasts up to 2-3s so it's long wait either way.",
8445768,coditva,https://api.github.com/repos/neovim/neovim/pulls/8076,175549850,2018-03-19T18:59:02Z,test/functional/ui/cmdline_spec.lua,"@@ -187,6 +187,36 @@ describe('external cmdline', function()    end) +  it(""works with inputlist()"", function()+    feed(':call inputlist([""input0"", ""input1""])<cr>')+    screen:expect([[+      {1:~                        }|+      {1:~                        }|+      input0                   |+      input1                   |+            ^                   |","I think this code is responsible for putting the last line as well as the cursor position:```c// from line 11279 in eval.cTV_LIST_ITER_CONST(argvars[0].vval.v_list, li, {    msg_puts(tv_get_string(TV_LIST_ITEM_TV(li)));    msg_putchar('\n');  });```Removing the newline would be complicated... Also, how do we change the cursor position? It stays at the position that `msg_putchar()` or `msg_puts()` leaves it.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/8120,175671939,2018-03-20T07:22:31Z,test/functional/core/job_spec.lua,"@@ -511,7 +565,12 @@ describe('jobs', function()      it('will return status codes in the order of passed ids', function()       source([[-      call rpcnotify(g:channel, 'wait', jobwait([+      call rpcnotify(g:channel, 'wait', jobwait(has('win32') ? [+      \  jobstart('Start-Sleep -Milliseconds 70; exit 4'),+      \  jobstart('Start-Sleep -Milliseconds 50; exit 5'),+      \  jobstart('Start-Sleep -Milliseconds 30; exit 6'),+      \  jobstart('Start-Sleep -Milliseconds 10; exit 7')","I think cmd.exe would be a better choice here.> The timeout test for jobwait lasts up to 2-3s so it's long wait either way.Yes but I'm thinking of the variance in event ordering, e.g. if powershell starts 20ms faster in one case.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/7783,175702412,2018-03-20T09:39:36Z,runtime/doc/starting.txt,"@@ -349,11 +349,20 @@ argument. 							*--api-info* --api-info 	Print msgpack-encoded |api-metadata| and exit. +							*--embed*+--embed		Use stdin/stdout as a msgpack-rpc channel.  This makes it easy+		for applications to embed and control Nvim via the |rpc-api|.+                Implies |--headless|.  Equivalent to: >+			nvim --headless --cmd ""call stdioopen({'rpc': v:true})""+<+                See also |channel-stdio|.+ 							*--headless*---headless 	Do not start the built-in UI.-                See |channel-stdio| for how to use stdio for other purposes-                instead.-		See also |silent-mode|, which does start a (limited) UI.+--headless 	Do not start the built-in UI.  Allows stdio to be used as+                a communication channel. |channel-stdio| To detect this state+                in a script, use |nvim_list_uis()|: if it returns empty after+                |VimEnter|, then Nvim is headless. Compare |silent-mode|,","Do we say nvim is headless still after a remote UI connects over a socket? Then `nvim_list_uis()` will be non-empty, but stdio channel is still available. Or did you mean this check was reliable _before_ VimEnter?",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/7783,175715825,2018-03-20T10:25:50Z,runtime/doc/starting.txt,"@@ -349,11 +349,20 @@ argument. 							*--api-info* --api-info 	Print msgpack-encoded |api-metadata| and exit. +							*--embed*+--embed		Use stdin/stdout as a msgpack-rpc channel.  This makes it easy+		for applications to embed and control Nvim via the |rpc-api|.+                Implies |--headless|.  Equivalent to: >+			nvim --headless --cmd ""call stdioopen({'rpc': v:true})""+<+                See also |channel-stdio|.+ 							*--headless*---headless 	Do not start the built-in UI.-                See |channel-stdio| for how to use stdio for other purposes-                instead.-		See also |silent-mode|, which does start a (limited) UI.+--headless 	Do not start the built-in UI.  Allows stdio to be used as+                a communication channel. |channel-stdio| To detect this state+                in a script, use |nvim_list_uis()|: if it returns empty after+                |VimEnter|, then Nvim is headless. Compare |silent-mode|,","But then /non/emptiness of `nvim_list_uis()` can't really detect literal `--headless`, where stdio is available no?",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/7783,175735038,2018-03-20T11:40:17Z,runtime/doc/starting.txt,"@@ -349,11 +349,20 @@ argument. 							*--api-info* --api-info 	Print msgpack-encoded |api-metadata| and exit. +							*--embed*+--embed		Use stdin/stdout as a msgpack-rpc channel.  This makes it easy+		for applications to embed and control Nvim via the |rpc-api|.+                Implies |--headless|.  Equivalent to: >+			nvim --headless --cmd ""call stdioopen({'rpc': v:true})""+<+                See also |channel-stdio|.+ 							*--headless*---headless 	Do not start the built-in UI.-                See |channel-stdio| for how to use stdio for other purposes-                instead.-		See also |silent-mode|, which does start a (limited) UI.+--headless 	Do not start the built-in UI.  Allows stdio to be used as+                a communication channel. |channel-stdio| To detect this state+                in a script, use |nvim_list_uis()|: if it returns empty after+                |VimEnter|, then Nvim is headless. Compare |silent-mode|,","The one I gave initially? If nvim is started with `--headless` but a remote UI connects over socket, `nvim_list_uis()` will be non-empty. Therefore it doesn't detect `--headless` state.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/7783,175742195,2018-03-20T12:10:07Z,runtime/doc/starting.txt,"@@ -349,11 +349,20 @@ argument. 							*--api-info* --api-info 	Print msgpack-encoded |api-metadata| and exit. +							*--embed*+--embed		Use stdin/stdout as a msgpack-rpc channel.  This makes it easy+		for applications to embed and control Nvim via the |rpc-api|.+                Implies |--headless|.  Equivalent to: >+			nvim --headless --cmd ""call stdioopen({'rpc': v:true})""+<+                See also |channel-stdio|.+ 							*--headless*---headless 	Do not start the built-in UI.-                See |channel-stdio| for how to use stdio for other purposes-                instead.-		See also |silent-mode|, which does start a (limited) UI.+--headless 	Do not start the built-in UI.  Allows stdio to be used as+                a communication channel. |channel-stdio| To detect this state+                in a script, use |nvim_list_uis()|: if it returns empty after+                |VimEnter|, then Nvim is headless. Compare |silent-mode|,","> The one I gave initially? If nvim is started with --headless but a remote UI connects over socket, nvim_list_uis() will be non-empty. Therefore it doesn't detect --headless state.It's no longer ""headless"" in that case. `--headless` flag itself is meaningless after a UI attaches. We could keep a flag around and expose that, but that would be pointless.Plugins care about whether a UI is attached, not the `--headless` flag itself. (However, it would be nice in general to expose the exact arguments used to start nvim, something like `argv()` except it returns all arguments, not just files).",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/7783,175755876,2018-03-20T13:03:43Z,runtime/doc/starting.txt,"@@ -349,11 +349,20 @@ argument. 							*--api-info* --api-info 	Print msgpack-encoded |api-metadata| and exit. +							*--embed*+--embed		Use stdin/stdout as a msgpack-rpc channel.  This makes it easy+		for applications to embed and control Nvim via the |rpc-api|.+                Implies |--headless|.  Equivalent to: >+			nvim --headless --cmd ""call stdioopen({'rpc': v:true})""+<+                See also |channel-stdio|.+ 							*--headless*---headless 	Do not start the built-in UI.-                See |channel-stdio| for how to use stdio for other purposes-                instead.-		See also |silent-mode|, which does start a (limited) UI.+--headless 	Do not start the built-in UI.  Allows stdio to be used as+                a communication channel. |channel-stdio| To detect this state+                in a script, use |nvim_list_uis()|: if it returns empty after+                |VimEnter|, then Nvim is headless. Compare |silent-mode|,","But why do does this text then claim that literal `--headless` (the state where stdio is available) can be detected by `nvim_list_uis()` ?My comment wasn't about what plugins are _supposed_ to care about (nor how they should do it), just that the present text is misleading.",
8740057,janlazo,https://api.github.com/repos/neovim/neovim/pulls/8120,175857520,2018-03-20T17:31:37Z,test/functional/core/job_spec.lua,"@@ -511,7 +565,12 @@ describe('jobs', function()      it('will return status codes in the order of passed ids', function()       source([[-      call rpcnotify(g:channel, 'wait', jobwait([+      call rpcnotify(g:channel, 'wait', jobwait(has('win32') ? [+      \  jobstart('Start-Sleep -Milliseconds 70; exit 4'),+      \  jobstart('Start-Sleep -Milliseconds 50; exit 5'),+      \  jobstart('Start-Sleep -Milliseconds 30; exit 6'),+      \  jobstart('Start-Sleep -Milliseconds 10; exit 7')",Likely because of Powershell's lazy-loading and Appveyor-specific modules. Can't prevent them with `-NoProfile`.,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/7343,176318838,2018-03-22T06:31:19Z,test/functional/eval/system_spec.lua,"@@ -354,6 +360,8 @@ describe('systemlist()', function()       eq(5, eval('v:shell_error'))       eval([[systemlist('this-should-not-exist')]])       eq(1, eval('v:shell_error'))+      eval([[systemlist('""ping"" ""-n"" ""1"" ""127.0.0.1""')]])+      eq(0, eval('v:shell_error'))","Ok, still it would be clearer if we could instead check the output of something like echo or cat.    eq(..., [[systemlist('""echo"" ""foo"" ""bar"" ""baz""')]])",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/8169,176914174,2018-03-24T16:55:17Z,src/nvim/option_defs.h,"@@ -581,6 +581,7 @@ EXTERN int p_sm;                // 'showmatch' EXTERN int p_smd;               // 'showmode' EXTERN long p_ss;               // 'sidescroll' EXTERN long p_siso;             // 'sidescrolloff'+EXTERN int p_sdt;               // 'smalldeletethreshold'","Not sure about this option name, it's unusually long. 'delcombine' is the only existing option from which precedent can be drawn...",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/7343,176919613,2018-03-24T20:42:41Z,test/functional/eval/system_spec.lua,"@@ -239,6 +254,8 @@ describe('system()', function()       end     end)     it('to backgrounded command does not crash', function()+      -- cmd.exe doesn't background a command with &+      if iswin() then return end       -- This is indeterminate, just exercise the codepath. May get E5677.       feed_command('call system(""echo -n echoed &"")')","So this test now fails? (Even if it was useless before, just want to confirm that the new default now causes this kind of thing to fail.)",
1460175,iTakeshi,https://api.github.com/repos/neovim/neovim/pulls/8177,176942867,2018-03-25T14:47:20Z,src/nvim/getchar.c,"@@ -237,6 +237,57 @@ char_u *get_inserted(void)   return get_buffcont(&redobuff, FALSE); } +///+/// Prepend string to the head of current block of the given buffer.+///+static void prepend_buf(buffheader_T *buf, char_u *s)+{+  size_t slen = STRLEN(s);++  if (buf->bh_index >= slen) {+    // Easy case+    buf->bh_index -= slen;+    memmove(buf->bh_first.b_next->b_str + buf->bh_index, s, slen);+  } else {+    // Need to allocate a new buffer block+    size_t len;+    if (slen < MINIMAL_SIZE) {+      len = MINIMAL_SIZE;+    } else {+      len = (size_t)slen;+    }+    buffblock_T *p = xmalloc(sizeof(buffblock_T) + len);+    memmove(p->b_str, s, slen);+    char_u *str_head = buf->bh_first.b_next->b_str + buf->bh_index;+    memmove(p->b_str + slen, str_head, STRLEN(str_head) + 1);","Yes, it is a kind of duplicate of a part of `ins_typebuf()`, however `ins_typebuf()` is only for inserting into `typebuf`, so we need this for read buffers.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/8113,177179198,2018-03-26T17:51:39Z,src/nvim/event/libuv_process.c,"@@ -51,12 +51,19 @@ int libuv_process_spawn(LibuvProcess *uvproc)    if (!proc->in.closed) {     uvproc->uvstdio[0].flags = UV_CREATE_PIPE | UV_READABLE_PIPE;+#ifdef WIN32+    uvproc->uvstdio[0].flags |= UV_OVERLAPPED_PIPE;+#endif     uvproc->uvstdio[0].data.stream = STRUCT_CAST(uv_stream_t,                                                  &proc->in.uv.pipe);   }    if (!proc->out.closed) {     uvproc->uvstdio[1].flags = UV_CREATE_PIPE | UV_WRITABLE_PIPE;+#ifdef WIN32+    // pipe must be readable for IOCP to work.+    uvproc->uvstdio[1].flags |= UV_READABLE_PIPE | UV_OVERLAPPED_PIPE;+#endif","We will need to somehow feature-detect the presence of `UV_OVERLAPPED_PIPE` (or check libuv version-string, if they `#define` those). Example: https://github.com/justinmk/neovim/blob/0f9f46056f1f2937fe9d0dd2a13996181e360417/src/nvim/tui/input.c#L37-L44Or I guess this works:```#ifndef UV_OVERLAPPED_PIPE#define UV_OVERLAPPED_PIPE 0 #endif```",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/8160,177232042,2018-03-26T20:56:28Z,src/nvim/testdir/test_autocmd.vim,"@@ -816,8 +816,8 @@ func Test_Cmdline()   new   call setline(1, 'hello')   call feedkeys(""/hello\<CR>"", 'xt')-  call assert_equal('/', g:entered)-  call assert_equal('/', g:left)+  call assert_equal(has('win32') ? 'C:/' : '/', g:entered)+  call assert_equal(has('win32') ? 'C:/' : '/', g:left)","This isn't needed in upstream Vim: https://github.com/vim/vim/blob/e7499ddc33508d3d341e96f84a0e7b95b2d6927c/src/testdir/test_autocmd.vim#L816When changing the oldtests, we need to be careful not to add a bunch of tiny changes except where absolutely unavoidable. Otherwise it makes merging pain in the ass.And we need to ask why the result is different. Is this an intentional behavior change in `expand('<afile>')` that we plan to keep? If not, there's no reason to make the test pass.",
8740057,janlazo,https://api.github.com/repos/neovim/neovim/pulls/8160,177241054,2018-03-26T21:30:04Z,src/nvim/testdir/test_autocmd.vim,"@@ -816,8 +816,8 @@ func Test_Cmdline()   new   call setline(1, 'hello')   call feedkeys(""/hello\<CR>"", 'xt')-  call assert_equal('/', g:entered)-  call assert_equal('/', g:left)+  call assert_equal(has('win32') ? 'C:/' : '/', g:entered)+  call assert_equal(has('win32') ? 'C:/' : '/', g:left)",~~Are they the same internally but Vim hides the network drive for `<afile>`?~~ Nevermind. I didn't know that `<afile>` is different on CmdLineEnter/Leave.,
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/8187,177261814,2018-03-26T23:06:41Z,src/nvim/os/env.c,"@@ -169,6 +178,64 @@ void os_get_hostname(char *hostname, size_t size) #endif } +/// @return -1 if error encountered, 1 if capslock active otherwise 0 if not.+int capslock_status(void ) {++#if defined(__linux__)++  FILE *fp = NULL;+  char res[1024];+  fp = popen(""xset -q | grep Caps"", ""r"");","This also assumes that xset is installed (I have it in a separate package with only two dependents (though one of which is pretty common xdg-utils)) and in $PATH, that shell is POSIX compatible to some extent and that grep is there and in $PATH as well. And, BTW, `popen` is not C99, it is POSIX; and there is libuv for that. I do not like shelling out in C code in any case, but there is no better alternative to xset it code must be limited to calling just `xset` and nothing else, not even a shell. In any case there is no way `grep` will beat even Neovim regexes as they are already loaded, and it does not look like regexes are what is actually needed.",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/8187,177262764,2018-03-26T23:12:12Z,src/nvim/api/vim.c,"@@ -1562,3 +1563,15 @@ Object nvim_get_proc(Integer pid, Error *err) #endif   return rvobj; }++Integer nvim_get_caps_state(Error *err )+  FUNC_API_SINCE(4)+{+  int res = capslock_status();","Missing `const`. And a lot of style guide violations, though most should be reported.",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/8187,177264244,2018-03-26T23:20:19Z,src/nvim/os/env.c,"@@ -169,6 +178,64 @@ void os_get_hostname(char *hostname, size_t size) #endif } +/// @return -1 if error encountered, 1 if capslock active otherwise 0 if not.+int capslock_status(void ) {++#if defined(__linux__)++  FILE *fp = NULL;+  char res[1024];+  fp = popen(""xset -q | grep Caps"", ""r"");+  if (fp == NULL) {+      return -1;+  }+  fgets(res, sizeof(res), fp);+  if (STRNCMP(res + 21, ""on"", 2) == 0) {+    return 1;+  } else {+    return 0;+  }++#elif defined(WIN32)+  if ((GetKeyState(VK_CAPITAL) & 0x0001)!=0) {","This is four lines longer then needed, you can just return the result of comparison.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/8081,177292948,2018-03-27T02:46:29Z,test/functional/ui/highlight_spec.lua,"@@ -540,6 +540,27 @@ describe(""'listchars' highlight"", function()     ]])   end) +  it(""'cursorline' and 'standout'"", function()","This isn't relevant to the `describe(""'listchars' highlight"",` group, so I moved it.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/8187,177412224,2018-03-27T12:54:12Z,src/nvim/os/env.c,"@@ -169,6 +178,64 @@ void os_get_hostname(char *hostname, size_t size) #endif } +/// @return -1 if error encountered, 1 if capslock active otherwise 0 if not.+int capslock_status(void ) {++#if defined(__linux__)++  FILE *fp = NULL;+  char res[1024];+  fp = popen(""xset -q | grep Caps"", ""r"");","I don't think `xsel` should be hardcoded, it should work more like say clipboard provider. If there is a similar utility for wayland it could then be configured. Something like `os_system()` would be preferable over `popen()`.",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/8187,177587203,2018-03-27T22:07:11Z,src/nvim/api/vim.c,"@@ -1562,3 +1563,15 @@ Object nvim_get_proc(Integer pid, Error *err) #endif   return rvobj; }++Integer nvim_get_caps_state(Error *err )","You do not return anything at all with a error. You may see how dispatch coded, it generates code like```CObject handle_nvim_get_current_line(uint64_t channel_id, Array args, Error *error){  Object ret = NIL;  if (args.size != 0) {    api_set_error(error, kErrorTypeException, ""Wrong number of arguments: expecting 0 but got %zu"", args.size);    goto cleanup;  }  String rv = nvim_get_current_line(error);  if (ERROR_SET(error)) {    goto cleanup;  }  ret = STRING_OBJ(rv);cleanup:  return ret;}```where you may clearly see NIL returned in case of error. Lua```Cstatic int nlua_msgpack_nvim_get_current_line(lua_State *lstate){  Error err = ERROR_INIT;  if (lua_gettop(lstate) != 0) {    api_set_error(&err, kErrorTypeValidation, ""Expected 0 arguments"");    goto exit_0;  }  const String ret = nvim_get_current_line(&err);  nlua_push_String(lstate, ret);  api_free_string(ret);exit_0:  if (ERROR_SET(&err)) {    luaL_where(lstate, 1);    lua_pushstring(lstate, err.msg);    api_clear_error(&err);    lua_concat(lstate, 2);    return lua_error(lstate);  }  return 1;}```may seem different as you could not actually see it not returning anything: value is pushed onto stack regardless of error condition (AFAIR in order to not rely on function not returning something allocated just in case). But `lua_error` is a longjump and the target may and will expect return value from another function, which may be the caller of the `nlua_msgpack_nvim_get_current_line` and not API function itself, with caller having a different contract, or an error condition (what I am saying is that lua error handling with `pcall` and longjumps does not allow failing functions to have meaningful return value even if authors were willing to implement it, this is not the case with VimL where builtin functions do return in case of failure, though you need to be careful not to put failing function inside `try` or do some hacking with `silent` to actually utilize that).",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/8160,177969046,2018-03-29T07:09:02Z,src/nvim/ex_docmd.c,"@@ -8544,7 +8544,14 @@ eval_vars (       if (autocmd_fname != NULL && !path_is_absolute(autocmd_fname)) {         // Still need to turn the fname into a full path.  It was         // postponed to avoid a delay when <afile> is not used.-        result = (char_u *)FullName_save((char *)autocmd_fname, false);+        if (has_event(EVENT_CMDLINEENTER)+            || has_event(EVENT_CMDLINELEAVE)+            || has_event(EVENT_CMDWINENTER)+            || has_event(EVENT_CMDWINLEAVE)) {+          result = (char_u *)tv_dict_get_string(get_vim_var_dict(VV_EVENT), ""cmdtype"", true);","Also this if block changes unconditionally whenever any such autocommand is _defined_, not whether the actual _invoked_ event was one of these four. It doesn't make sense to me.",
9766,blueyed,https://api.github.com/repos/neovim/neovim/pulls/8201,178010575,2018-03-29T10:07:13Z,src/nvim/ui.c,"@@ -441,8 +441,12 @@ void ui_puts(uint8_t *str)      if (p_wd) {  // 'writedelay': flush & delay each time.       ui_flush();-      uint64_t wd = (uint64_t)labs(p_wd);-      os_delay(wd, false);+      if (!((got_int || (did_emsg && force_abort) || current_exception))){+        uint64_t wd = (uint64_t)labs(p_wd);+        os_delay(wd, false);+      } else {+        p_wd = 0;","You then have to `Ctrl-C` multiple times, e.g. after `C-w s`,which I think is good, and similar to how Vim behaves.",
9766,blueyed,https://api.github.com/repos/neovim/neovim/pulls/8201,178011076,2018-03-29T10:09:24Z,src/nvim/ui.c,"@@ -441,8 +441,12 @@ void ui_puts(uint8_t *str)      if (p_wd) {  // 'writedelay': flush & delay each time.       ui_flush();-      uint64_t wd = (uint64_t)labs(p_wd);-      os_delay(wd, false);+      if (!((got_int || (did_emsg && force_abort) || current_exception))){","Not sure about the other conditions besides `got_int` here: wouldn't that skip the delay in case of `echoerr` etc, which shouldn't be the case?",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/6073,178199328,2018-03-29T22:36:35Z,src/nvim/api/vim.c,"@@ -44,6 +45,45 @@ # include ""api/vim.c.generated.h"" #endif ++/// Create a fold from line ""start"" to line ""end"" (inclusive) in the current+/// window.+/// @param window+/// @param start starting line+/// @param end starting end+/// @param err+void nvim_fold_create(Window window, Integer start, Integer end, Error *err)","Should these be in `api/window.c` ?see `:help dev-api` for API naming conventions: `nvim_win_add_fold()`,  `nvim_win_del_fold()`.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/8187,178309045,2018-03-30T15:13:25Z,src/nvim/os/keyboard.c,"@@ -0,0 +1,93 @@+// This is an open source non-commercial project. Dear PVS-Studio, please check+// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com++#include <assert.h>+#include <string.h>+#include <stdio.h>++#include ""nvim/api/private/helpers.h""+#include ""nvim/api/private/defs.h""+#include ""nvim/lua/executor.h""+#include ""nvim/vim.h""+#include ""nvim/version.h""++#ifdef WIN32+#include <Winuser.h>+#endif++#ifdef __APPLE__+#define Boolean Boolean_I_Dont_Care+#include <IOKit/IOKitLib.h>+#include <IOKit/IOReturn.h>+#include <IOKit/hidsystem/IOHIDLib.h>+#include <IOKit/hidsystem/IOHIDParameter.h>+#include <CoreFoundation/CoreFoundation.h>+#undef Boolean+#endif++/// @return -1 if error encountered, 1 if capslock active otherwise 0 if not.+bool capslock_status(const char **const err )+{+  *err = NULL;+#if defined(__linux__)+  String cmd = cstr_to_string(""return (function()""+                              ""local handle = io.popen('xset q|grep Caps')""+                              ""local data = handle:read('*all')""+                              ""handle:close()""+                              ""return data end)()"");","This will be all on one line which isn't valid Lua syntax. You would need newlines:```""return (function()\n""""local handle = io.popen('xset q|grep Caps')\n""...```However I would suggest putting the Lua function definition into `src/nvim/lua/vim.lua`. See `_os_proc_info` for example. Remember to add it to the ""exported"" list at the end of `src/nvim/lua/vim.lua`.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/8201,178427067,2018-03-31T08:52:31Z,src/nvim/screen.c,"@@ -5887,6 +5887,18 @@ static void screen_char(unsigned off, int row, int col)   }    ui_cursor_goto(row, col);++  if (p_wd) {+    if (!got_int) {+      ui_set_highlight(ScreenAttrs[off] ^ HL_STANDOUT);+      ui_putc('X');+      ui_cursor_goto(row, col);","ui_cursor_goto seems to hide the effects (if any) of  HL_STANDOUT/`ui_putc('X')`. The cursor placement helps  visually, so I don't think HL_STANDOUT/`ui_putc('X')` is needed.Also, I tested this locally, and moved it back to `ui_puts()` and it seems to work fine there, so it should stay there.The only changes needed are the checks for `got_int` . Let's move forward with that. ",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/6743,178428170,2018-03-31T09:49:06Z,src/nvim/os/pty_process_unix.c,"@@ -115,6 +115,11 @@ int pty_process_spawn(PtyProcess *ptyproc)   return status; } +const char *pty_process_tty_name(PtyProcess *ptyproc)+{+  return ptsname(ptyproc->tty_fd);","This patch sets `add_definitions(-D_GNU_SOURCE)` for clang:```diffdiff --git a/CMakeLists.txt b/CMakeLists.txtindex 4b021ad6e71b..b5b5b341dbd7 100644--- a/CMakeLists.txt+++ b/CMakeLists.txt@@ -290,13 +290,14 @@ option(LOG_LIST_ACTIONS ""Add list actions logging"" OFF)- add_definitions(-DINCLUDE_GENERATED_DECLARATIONS)--if(CMAKE_COMPILER_IS_GNUCXX AND CMAKE_SYSTEM_NAME STREQUAL ""Linux"")+if(CMAKE_SYSTEM_NAME STREQUAL ""Linux"")   set(CMAKE_EXE_LINKER_FLAGS ""${CMAKE_EXE_LINKER_FLAGS} -Wl,--no-undefined"")   set(CMAKE_SHARED_LINKER_FLAGS ""${CMAKE_SHARED_LINKER_FLAGS} -Wl,--no-undefined"")   set(CMAKE_MODULE_LINKER_FLAGS ""${CMAKE_MODULE_LINKER_FLAGS} -Wl,--no-undefined"")-   # For O_CLOEXEC, O_DIRECTORY, and O_NOFOLLOW flags on older systems   # (pre POSIX.1-2008: glibc 2.11 and earlier). #4042+  # For ptsname() on clang. #6743   add_definitions(-D_GNU_SOURCE) endif()```",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/6743,178428254,2018-03-31T09:54:22Z,src/nvim/api/vim.c,"@@ -839,6 +839,89 @@ Array nvim_get_api_info(uint64_t channel_id)   return rv; } +/// Identify the client for nvim. Can be called more than once, but subsequent+/// calls will remove earlier info, which should be resent if it is still+/// valid. (This could happen if a library first identifies the channel, and a+/// plugin using that library later overrides that info)+///+/// @param name short name for the connected client+/// @param version  Dictionary describing the version, with the following+///                 possible keys (all optional expect for ""major"")+///     - ""major"" major version (required, set to 0 if no release yet)+///     - ""minor"" minor version+///     - ""patch"" patch number+///     - ""prerelease"" string describing a prerelease, like ""dev"" or ""beta1""+///     - ""commit"" hash or similar identifier of commit+/// @param type Must be one of the following values. A client library should+///             use ""remote"" if the library user hasn't specified other value.+///     - ""remote"" remote client that connected to nvim.+///     - ""ui"" gui frontend+///     - ""embedder"" application using nvim as a component, for instance+///                  IDE/editor implementing a vim mode.+///     - ""host"" plugin host, typically started by nvim+///     - ""plugin"" single plugin, started by nvim+/// @param methods Builtin methods in the client. For a host, this does not+///                include plugin methods which will be discovered later.+///                The key should be the method name, the values are dicts with+///                the following (optional) keys:+///     - ""async""  if true, send as a notification. If false or unspecified,+///                use a blocking request+///     - ""n_args"" Number of arguments. Could be a single integer or an array+///                two integers, minimum and maximum inclusive.+///     Further keys might be added in later versions of nvim and unknown keys+///     are thus ignored. Clients must only use keys defined in this or later+///     versions of nvim!+///+/// @param attributes Informal attributes describing the client. Clients might+///                   define their own keys, but the following are suggested:+///     - ""website"" Website of client (for instance github repository)+///     - ""license"" Informal descripton of the license, such as ""Apache 2"",+///                 ""GPLv3"" or ""MIT""+///     - ""logo""    URI or path to image, preferably small logo or icon.+///                 .png or .svg format is preferred.+///+void nvim_set_client_info(uint64_t channel_id, String name,+                          Dictionary version, String type,+                          Dictionary methods, Dictionary attributes)+  FUNC_API_SINCE(4) FUNC_API_REMOTE_ONLY+{+  Dictionary info = ARRAY_DICT_INIT;+  PUT(info, ""name"", copy_object(STRING_OBJ(name)));+  PUT(info, ""version"", copy_object(DICTIONARY_OBJ(version)));+  PUT(info, ""type"", copy_object(STRING_OBJ(type)));+  PUT(info, ""methods"", copy_object(DICTIONARY_OBJ(methods)));+  PUT(info, ""attributes"", copy_object(DICTIONARY_OBJ(attributes)));++  rpc_set_info(channel_id, info);+}++/// Get information about all open channels+///+/// @returns Array of Dictionaries, each describing a channel with the+/// following keys:+///     - ""stream""  the stream underlying the channel+///         - ""stdio""      stdin and stdout of this Nvim instance+///         - ""stderr""     stderr of this Nvim instance+///         - ""socket""     TCP/IP socket or named pipe+///         - ""job""        job with communication over its stdio+///    -  ""mode""    how data received on the channel is interpreted+///         - ""bytes""      send and recieve raw bytes+///         - ""terminal""   a |terminal| instance interprets ASCII sequences+///         - ""rpc""        |RPC| communication on the channel is active+///    -  ""pty""     Name of pseudoterminal if present (optional)+///                 On a POSIX system, this will be a device path like+///                 /dev/pts/1+///    -  ""buffer""  buffer with connected |terminal| instance (optional)+///    -  ""client""  information about the client on the other end of the+///                 RPC channel, if it has added it using+///                 |nvim_set_client_info|. (optional)+///+Array nvim_list_channels(void)",`nvim_list_chans`,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/6743,178429166,2018-03-31T10:45:30Z,CMakeLists.txt,"@@ -298,6 +298,8 @@ if(CMAKE_COMPILER_IS_GNUCXX AND CMAKE_SYSTEM_NAME STREQUAL ""Linux"")   # For O_CLOEXEC, O_DIRECTORY, and O_NOFOLLOW flags on older systems   # (pre POSIX.1-2008: glibc 2.11 and earlier). #4042   add_definitions(-D_GNU_SOURCE)+elseif(NOT WIN32)+    add_definitions(-D_XOPEN_SOURCE=700)","Maybe or not, but it's good to have these low-cost hints. If they grow to list many things, then the hints aren't needed anymore, but until then it's worth it.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/6743,178429231,2018-03-31T10:50:23Z,CMakeLists.txt,"@@ -298,6 +298,8 @@ if(CMAKE_COMPILER_IS_GNUCXX AND CMAKE_SYSTEM_NAME STREQUAL ""Linux"")   # For O_CLOEXEC, O_DIRECTORY, and O_NOFOLLOW flags on older systems   # (pre POSIX.1-2008: glibc 2.11 and earlier). #4042   add_definitions(-D_GNU_SOURCE)+elseif(NOT WIN32)+    add_definitions(-D_XOPEN_SOURCE=700)","But the point is it might not grow, because no one will ever notice the flag was necessary for the next thing... And `glibc` docs seem to lazy with documenting flags needed for a function, thus not noticing that way either.",
15214129,nimitbhardwaj,https://api.github.com/repos/neovim/neovim/pulls/8187,178429915,2018-03-31T11:26:28Z,src/nvim/lua/vim.lua,"@@ -118,11 +118,21 @@ local function _update_package_paths()   last_nvim_paths = cur_nvim_paths end +local function _os_proc_capsinfo()++  local cmd = { 'xset', 'q', }","Yes, this is true, the functional approach here will be much better than just communicating with shell, there you specified the nvim-x11 but I have to get some time to fully understand its working, I didn't have much exp with wayland now, but if its a need of hour, I can understand it.Also would like to listen to the view of others too.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/8187,178431203,2018-03-31T12:39:32Z,src/nvim/lua/vim.lua,"@@ -118,11 +118,21 @@ local function _update_package_paths()   last_nvim_paths = cur_nvim_paths end +local function _os_proc_capsinfo()++  local cmd = { 'xset', 'q', }","@justinmk I thought I _very explictly_ stated that more flexible detection should wait until later. The change I have in mind could be as simple as renaming the function for now (and document it)> any underscore-prefix function in vim Lua module is not part of public API, so let's not suggest this to any users.I agree with the premise (underscore functions sholudn't be changed), but the conclusion is quite backwards. If some users need to override a ""underscore-prefix function in vim Lua module"" to properly use a new feature, isn't the obvious conclusion that the function should at least be renamed?",
9766,blueyed,https://api.github.com/repos/neovim/neovim/pulls/8201,178437542,2018-03-31T17:36:44Z,src/nvim/screen.c,"@@ -5887,6 +5887,18 @@ static void screen_char(unsigned off, int row, int col)   }    ui_cursor_goto(row, col);++  if (p_wd) {+    if (!got_int) {+      ui_set_highlight(ScreenAttrs[off] ^ HL_STANDOUT);+      ui_putc('X');+      ui_cursor_goto(row, col);","> ui_cursor_goto seems to hide the effects (if any) of HL_STANDOUT/ui_putc('X')Depends on the cursor shape (IIRC).But I agree that it is not necessary really, and using a block cursor would be the better improvement (but is not necessary).",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/8187,178653352,2018-04-02T21:17:51Z,src/nvim/os/keyboard.c,"@@ -0,0 +1,231 @@+// This is an open source non-commercial project. Dear PVS-Studio, please check+// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com++#include <assert.h>+#include <string.h>+#include <stdio.h>++#include <uv.h>++#include ""nvim/api/private/helpers.h""+#include ""nvim/api/private/defs.h""+#include ""nvim/lua/executor.h""+#include ""nvim/vim.h""+#include ""nvim/version.h""++#ifdef __linux__++#define XLIB_NAME ""libX11.so.6""+typedef void *_XDisplay;+typedef struct {+    char data[18];+} _XkbStateRec;+typedef int _XStatus;++enum { kLockedModsOffset = 9 };+enum { _XkbUseCoreKbd = 0x0100 };+#endif++#ifdef WIN32+#include <Winuser.h>+#endif++#ifdef __APPLE__+#define Boolean Boolean_I_Dont_Care+#include <IOKit/IOKitLib.h>+#include <IOKit/IOReturn.h>+#include <IOKit/hidsystem/IOHIDLib.h>+#include <IOKit/hidsystem/IOHIDParameter.h>+#include <CoreFoundation/CoreFoundation.h>+#undef Boolean+#endif++enum {+    kNumLock = 0x10,+    kCapsLock = 0x02,+};+++#if defined(__linux__)+static bool xlib_opened = false;+static uv_lib_t xlib;+static _XDisplay *(*_XOpenDisplay)(void *);+static int (*_XCloseDisplay)(_XDisplay *);+static _XStatus (*_XkbGetState)(_XDisplay *, unsigned, _XkbStateRec *);++/// A helper function to be used to load the libX11 and required functions+static bool os_xlib_init(const char **const err)+{+  if (xlib_opened) {+    return true;+  }+  const int udl_ret = uv_dlopen(XLIB_NAME, &xlib);+  if (udl_ret != 0) {+    *err = ""Failed to open library libX11"";+  } else {+    xlib_opened = true;+  }++  if ((uv_dlsym(&xlib, ""XOpenDisplay"", (void **)&_XOpenDisplay)+       || uv_dlsym(&xlib, ""XCloseDisplay"", (void **)&_XCloseDisplay)+       || uv_dlsym(&xlib, ""XkbGetState"", (void **)&_XkbGetState)) != 0) {+    *err = ""Unable to get the functions of X11"";+    return false;+  }+  return xlib_opened;+}++/// Get information about Num/Caps Lock state in linux+///+/// To be used in os_mods_status() function.+///+/// @param[out]  mods  Holds the information about the status of various locks+///                    in form of a bitmas+///",No empty line between parameters.,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/8222,178692572,2018-04-03T01:28:47Z,third-party/cmake/BuildLuv.cmake,"@@ -89,6 +89,10 @@ endif() set(LUV_BUILD_COMMAND ${CMAKE_COMMAND} --build .) set(LUV_INSTALL_COMMAND ${CMAKE_COMMAND} --build . --target install) +if(CMAKE_SYSTEM_NAME MATCHES ""OpenBSD"")+  set(CMAKE_MAKE_PROGRAM ""/usr/local/bin/gmake"" CACHE INTERNAL ""make->gmake"" FORCE)+endif()","I didn't realize we were using this directly, I see that now. > CMAKE_MAKE_PROGRAM is indeed set to /usr/bin/makeIs that perhaps the root problem? Nvim requires `gmake`. We even warn about this in [BSDmakefile](https://github.com/neovim/neovim/blob/master/BSDmakefile).I wonder why `make` is being used at all, on OpenBSD.If anything, I would guess we should set `CMAKE_MAKE_PROGRAM=gmake` in the top-level CMakeLists.txt. But I wonder why CMake didn't do that for us, or how could it possibly work on other BSDs?",
17116349,utkarsh009,https://api.github.com/repos/neovim/neovim/pulls/8222,178694646,2018-04-03T01:47:23Z,third-party/cmake/BuildLuv.cmake,"@@ -89,6 +89,10 @@ endif() set(LUV_BUILD_COMMAND ${CMAKE_COMMAND} --build .) set(LUV_INSTALL_COMMAND ${CMAKE_COMMAND} --build . --target install) +if(CMAKE_SYSTEM_NAME MATCHES ""OpenBSD"")+  set(CMAKE_MAKE_PROGRAM ""/usr/local/bin/gmake"" CACHE INTERNAL ""make->gmake"" FORCE)+endif()",">Is that perhaps the root problem?Yes! The fact that it is not just being set up by cmake, but also being used at an intermediary step. While building luv from it's repository, it just sets it up with the wrong value but it stays unused, so it isn't a problem there.>Nvim requires gmake. We even warn about this in BSDmakefile.I have `gmake` on my system, but it still sets it up with the wrong value. However, `make` is available in `/usr/bin` and `gmake` in `/usr/local/bin`. All the packages installed using the package manager are installed to `/usr/local/bin` by default unless you specify a prefix.>If anything, I would guess we should set CMAKE_MAKE_PROGRAM=gmake in the top-level CMakeLists.txt. You mean, the way I'm setting it, just in the parent directory, right?>But I wonder why CMake didn't do that for us, or how could it possibly work on other BSDs?This problem also occurs on DragonflyBSD, I'll push a fix for that. (currently, there are other problems too.)",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/8076,178739998,2018-04-03T07:54:42Z,test/functional/ui/cmdline_spec.lua,"@@ -187,6 +187,36 @@ describe('external cmdline', function()    end) +  it(""works with inputlist()"", function()+    feed(':call inputlist([""input0"", ""input1""])<cr>')+    screen:expect([[+      {1:~                        }|+      {1:~                        }|+      input0                   |+      input1                   |+            ^                   |","I think you can use `TV_LIST_ITEM_NEXT(list, li) != NULL` to check if an item is last and then avoid the `msg_putchar('\n')`. ( when `ui_is_external(kUICmdline)` is true)Alternatively, i think you can just add an `msg_putchar('\r')` at the end to move it back to first column.",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/8076,178743140,2018-04-03T08:09:00Z,test/functional/ui/cmdline_spec.lua,"@@ -187,6 +187,36 @@ describe('external cmdline', function()    end) +  it(""works with inputlist()"", function()+    feed(':call inputlist([""input0"", ""input1""])<cr>')+    screen:expect([[+      {1:~                        }|+      {1:~                        }|+      input0                   |+      input1                   |+            ^                   |",Better to check against equality to `tv_list_last()`: it makes the intention more clear.,
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/8187,178965112,2018-04-03T21:17:40Z,src/nvim/os/keyboard.c,"@@ -0,0 +1,231 @@+// This is an open source non-commercial project. Dear PVS-Studio, please check+// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com++#include <assert.h>+#include <string.h>+#include <stdio.h>++#include <uv.h>++#include ""nvim/api/private/helpers.h""+#include ""nvim/api/private/defs.h""+#include ""nvim/lua/executor.h""+#include ""nvim/vim.h""+#include ""nvim/version.h""++#ifdef __linux__++#define XLIB_NAME ""libX11.so.6""+typedef void *_XDisplay;+typedef struct {+    char data[18];+} _XkbStateRec;+typedef int _XStatus;++enum { kLockedModsOffset = 9 };+enum { _XkbUseCoreKbd = 0x0100 };+#endif++#ifdef WIN32+#include <Winuser.h>+#endif++#ifdef __APPLE__+#define Boolean Boolean_I_Dont_Care+#include <IOKit/IOKitLib.h>+#include <IOKit/IOReturn.h>+#include <IOKit/hidsystem/IOHIDLib.h>+#include <IOKit/hidsystem/IOHIDParameter.h>+#include <CoreFoundation/CoreFoundation.h>+#undef Boolean+#endif++enum {+    kNumLock = 0x10,+    kCapsLock = 0x02,+};+++#if defined(__linux__)+static bool xlib_opened = false;+static uv_lib_t xlib;+static _XDisplay *(*_XOpenDisplay)(void *);+static int (*_XCloseDisplay)(_XDisplay *);+static _XStatus (*_XkbGetState)(_XDisplay *, unsigned, _XkbStateRec *);++/// A helper function to be used to load the libX11 and required functions+static bool os_xlib_init(const char **const err)+{+  if (xlib_opened) {+    return true;+  }+  const int udl_ret = uv_dlopen(XLIB_NAME, &xlib);+  if (udl_ret != 0) {+    *err = ""Failed to open library libX11"";",Missing reason why library failed to open in error message.,
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/8187,178968611,2018-04-03T21:32:21Z,src/nvim/os/keyboard.c,"@@ -0,0 +1,250 @@+// This is an open source non-commercial project. Dear PVS-Studio, please check+// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com++#include <assert.h>+#include <string.h>+#include <stdio.h>++#include <uv.h>++#include ""nvim/api/private/helpers.h""+#include ""nvim/api/private/defs.h""+#include ""nvim/lua/executor.h""+#include ""nvim/vim.h""+#include ""nvim/version.h""++#ifdef __linux__++#define XLIB_NAME ""libX11.so.6""+typedef void *_XDisplay;+typedef struct {+    char data[18];+} _XkbStateRec;+typedef int _XStatus;++enum { kLockedModsOffset = 9 };+enum { _XkbUseCoreKbd = 0x0100 };+#endif++#ifdef WIN32+#include <Winuser.h>+#endif++#ifdef __APPLE__+#define Boolean Boolean_I_Dont_Care+#include <IOKit/IOKitLib.h>+#include <IOKit/IOReturn.h>+#include <IOKit/hidsystem/IOHIDLib.h>+#include <IOKit/hidsystem/IOHIDParameter.h>+#include <CoreFoundation/CoreFoundation.h>+#undef Boolean+#endif+++/// Masks for the specific lock status+typedef enum {+    kNumLock = 0x10,  ///< Mask used to check if the NumLock is active+    kCapsLock = 0x02,  ///< Mask used to check if the NumLock is active+    kScrollLock = 0x80,  ///< Mask used to check if the NumLock is active+} KbdLocks;+++#if defined(__linux__)+static bool xlib_opened = false;+static uv_lib_t xlib;+static _XDisplay *(*_XOpenDisplay)(void *);+static int (*_XCloseDisplay)(_XDisplay *);+static _XStatus (*_XkbGetState)(_XDisplay *, unsigned, _XkbStateRec *);++/// A helper function to be used to load the libX11 and required functions+static bool os_xlib_init(const char **const err)+{+  if (xlib_opened) {+    return true;+  }+  const int udl_ret = uv_dlopen(XLIB_NAME, &xlib);+  if (udl_ret != 0) {+    *err = ""Failed to open library libX11"";+    return false;+  } else {+    xlib_opened = true;+  }++  if ((uv_dlsym(&xlib, ""XOpenDisplay"", (void **)&_XOpenDisplay)+       || uv_dlsym(&xlib, ""XCloseDisplay"", (void **)&_XCloseDisplay)+       || uv_dlsym(&xlib, ""XkbGetState"", (void **)&_XkbGetState)) != 0) {+    *err = ""Unable to get the functions of X11"";+    return false;+  }+  return xlib_opened;+}++/// Get information about Num/Caps/Scroll Lock state in linux+///+/// To be used in os_mods_status() function.+///+/// @param[out]  mods  Holds the information about the status of various locks+///                    in form of a bitmask+/// @param[out]  err  Location where error message is to be saved, set to NULL+///                   if no error.+///+/// @return true in case of error, false otherwise.+static bool os_get_locks_status(int *const mods, const char **const err)+{+#define CLOSE_DISPLAY(display) \+  do { \+    const int e = _XCloseDisplay(display); \+    if (e) { \+      *err = ""XCloseDisplay unable to close the display""; \+      return false; \+    } \+  } while (0)+  *mods = 0;+  *err = NULL;+  if (!os_xlib_init(err)) {+    return false;+  }++  _XDisplay *const display = _XOpenDisplay(NULL);+  if (display == NULL) {+    *err = ""Couldn't open the display"";+    return false;+  }++  _XkbStateRec xkb_state;+  const _XStatus status = _XkbGetState(display, _XkbUseCoreKbd, &xkb_state);+  if (status) {+    *err = ""Non-zero status returned by XkbGetState"";+    CLOSE_DISPLAY(display);+  }+  *mods = xkb_state.data[kLockedModsOffset];++  CLOSE_DISPLAY(display);+  return true;+#undef CLOSE_DISPLAY+}++#elif defined(WIN32)+/// Get information about Num/Caps/Scroll Lock state in Windows+///+/// To be used in os_mods_status() function.+///+/// @param[out]  mods  Holds the information about the status of various locks+///                    in form of a bitmask+/// @param[out]  err  Location where error message is to be saved, set to NULL+///                   if no error.+///+/// @return true in case of error, false otherwise.+bool os_get_locks_status(int *const mods, const char **const err)+{+  *mods = 0;+  *err = NULL;+  if (GetKeyState(VK_CAPITAL) & 0x0001) {+    *mods = *mods | kCapsLock;+  }+  if (GetKeyState(VK_NUMLOCK) & 0x0001) {+    *mods = *mods | kNumLock;+  }+  if (GetKeyState(VK_SCROLL) & 0x0001) {+    *mods = *mods | kScrollLock;+  }+  return true;+}++#elif defined(__APPLE__)+/// Get information about Num/Caps Lock state in MacOS+///+/// To be used in os_mods_status() function.+///+/// @param[out]  mods  Holds the information about the status of various locks+///                    in form of a bitmask+/// @param[out]  err  Location where error message is to be saved, set to NULL+///                   if no error.+///+/// @return true in case of error, false otherwise.+static bool os_get_locks_status(int *const mods, const char **const err)+{+  *err = NULL;+  io_service_t ios;+  io_connect_t ioc;+  CFMutableDictionaryRef mdict;+  bool stateCaps, stateNums;+  mdict = IOServiceMatching(kIOHIDSystemClass);+  ios = IOServiceGetMatchingService(kIOMasterPortDefault,+                                    (CFDictionaryRef)mdict);+  if (!ios) {+    if (mdict) {+      CFRelease(mdict);+    }+    *err = ""Unable to start service to query data"";+    return false;+  }++  if (IOServiceOpen(ios, mach_task_self(), kIOHIDParamConnectType,+                    &ioc) != kIOReturnSuccess) {+    IOObjectRelease(ios);+    *err = ""Unable to query data"";+    return false;+  }+  IOObjectRelease(ios);++  if (IOHIDGetModifierLockState(ioc, kIOHIDCapsLockState,+                                &stateCaps) != kIOReturnSuccess) {+    *err = ""Unable to lock the state"";+    return false;+  }++  if (IOHIDGetModifierLockState(ioc, kIOHIDCapsLockState,+                                &stateNums) != kIOReturnSuccess) {+    *err = ""Unable to lock the state"";+    return false;+  }+  if (stateCaps) {+    *mods = *mods | kCapsLock;+  }","I would really go with a single boolean, nothing would be bad if you do not defer the checks.",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/8187,178968849,2018-04-03T21:33:24Z,src/nvim/os/keyboard.c,"@@ -0,0 +1,250 @@+// This is an open source non-commercial project. Dear PVS-Studio, please check+// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com++#include <assert.h>+#include <string.h>+#include <stdio.h>++#include <uv.h>++#include ""nvim/api/private/helpers.h""+#include ""nvim/api/private/defs.h""+#include ""nvim/lua/executor.h""+#include ""nvim/vim.h""+#include ""nvim/version.h""++#ifdef __linux__++#define XLIB_NAME ""libX11.so.6""+typedef void *_XDisplay;+typedef struct {+    char data[18];+} _XkbStateRec;+typedef int _XStatus;++enum { kLockedModsOffset = 9 };+enum { _XkbUseCoreKbd = 0x0100 };+#endif++#ifdef WIN32+#include <Winuser.h>+#endif++#ifdef __APPLE__+#define Boolean Boolean_I_Dont_Care+#include <IOKit/IOKitLib.h>+#include <IOKit/IOReturn.h>+#include <IOKit/hidsystem/IOHIDLib.h>+#include <IOKit/hidsystem/IOHIDParameter.h>+#include <CoreFoundation/CoreFoundation.h>+#undef Boolean+#endif+++/// Masks for the specific lock status+typedef enum {+    kNumLock = 0x10,  ///< Mask used to check if the NumLock is active+    kCapsLock = 0x02,  ///< Mask used to check if the NumLock is active+    kScrollLock = 0x80,  ///< Mask used to check if the NumLock is active+} KbdLocks;+++#if defined(__linux__)+static bool xlib_opened = false;+static uv_lib_t xlib;+static _XDisplay *(*_XOpenDisplay)(void *);+static int (*_XCloseDisplay)(_XDisplay *);+static _XStatus (*_XkbGetState)(_XDisplay *, unsigned, _XkbStateRec *);++/// A helper function to be used to load the libX11 and required functions+static bool os_xlib_init(const char **const err)+{+  if (xlib_opened) {+    return true;+  }+  const int udl_ret = uv_dlopen(XLIB_NAME, &xlib);+  if (udl_ret != 0) {+    *err = ""Failed to open library libX11"";+    return false;+  } else {+    xlib_opened = true;+  }++  if ((uv_dlsym(&xlib, ""XOpenDisplay"", (void **)&_XOpenDisplay)+       || uv_dlsym(&xlib, ""XCloseDisplay"", (void **)&_XCloseDisplay)+       || uv_dlsym(&xlib, ""XkbGetState"", (void **)&_XkbGetState)) != 0) {+    *err = ""Unable to get the functions of X11"";+    return false;+  }+  return xlib_opened;+}++/// Get information about Num/Caps/Scroll Lock state in linux+///+/// To be used in os_mods_status() function.+///+/// @param[out]  mods  Holds the information about the status of various locks+///                    in form of a bitmask+/// @param[out]  err  Location where error message is to be saved, set to NULL+///                   if no error.+///+/// @return true in case of error, false otherwise.+static bool os_get_locks_status(int *const mods, const char **const err)+{+#define CLOSE_DISPLAY(display) \+  do { \+    const int e = _XCloseDisplay(display); \+    if (e) { \+      *err = ""XCloseDisplay unable to close the display""; \+      return false; \+    } \+  } while (0)+  *mods = 0;+  *err = NULL;+  if (!os_xlib_init(err)) {+    return false;+  }++  _XDisplay *const display = _XOpenDisplay(NULL);+  if (display == NULL) {+    *err = ""Couldn't open the display"";+    return false;+  }++  _XkbStateRec xkb_state;+  const _XStatus status = _XkbGetState(display, _XkbUseCoreKbd, &xkb_state);+  if (status) {+    *err = ""Non-zero status returned by XkbGetState"";+    CLOSE_DISPLAY(display);+  }+  *mods = xkb_state.data[kLockedModsOffset];++  CLOSE_DISPLAY(display);+  return true;+#undef CLOSE_DISPLAY+}++#elif defined(WIN32)+/// Get information about Num/Caps/Scroll Lock state in Windows+///+/// To be used in os_mods_status() function.+///+/// @param[out]  mods  Holds the information about the status of various locks+///                    in form of a bitmask+/// @param[out]  err  Location where error message is to be saved, set to NULL+///                   if no error.+///+/// @return true in case of error, false otherwise.+bool os_get_locks_status(int *const mods, const char **const err)+{+  *mods = 0;+  *err = NULL;+  if (GetKeyState(VK_CAPITAL) & 0x0001) {+    *mods = *mods | kCapsLock;+  }+  if (GetKeyState(VK_NUMLOCK) & 0x0001) {+    *mods = *mods | kNumLock;+  }+  if (GetKeyState(VK_SCROLL) & 0x0001) {+    *mods = *mods | kScrollLock;+  }+  return true;+}++#elif defined(__APPLE__)+/// Get information about Num/Caps Lock state in MacOS+///+/// To be used in os_mods_status() function.+///+/// @param[out]  mods  Holds the information about the status of various locks+///                    in form of a bitmask+/// @param[out]  err  Location where error message is to be saved, set to NULL+///                   if no error.+///+/// @return true in case of error, false otherwise.+static bool os_get_locks_status(int *const mods, const char **const err)+{+  *err = NULL;+  io_service_t ios;+  io_connect_t ioc;+  CFMutableDictionaryRef mdict;+  bool stateCaps, stateNums;+  mdict = IOServiceMatching(kIOHIDSystemClass);+  ios = IOServiceGetMatchingService(kIOMasterPortDefault,+                                    (CFDictionaryRef)mdict);+  if (!ios) {+    if (mdict) {+      CFRelease(mdict);+    }+    *err = ""Unable to start service to query data"";+    return false;+  }++  if (IOServiceOpen(ios, mach_task_self(), kIOHIDParamConnectType,+                    &ioc) != kIOReturnSuccess) {+    IOObjectRelease(ios);+    *err = ""Unable to query data"";+    return false;+  }+  IOObjectRelease(ios);++  if (IOHIDGetModifierLockState(ioc, kIOHIDCapsLockState,+                                &stateCaps) != kIOReturnSuccess) {+    *err = ""Unable to lock the state"";+    return false;+  }++  if (IOHIDGetModifierLockState(ioc, kIOHIDCapsLockState,+                                &stateNums) != kIOReturnSuccess) {+    *err = ""Unable to lock the state"";+    return false;+  }+  if (stateCaps) {+    *mods = *mods | kCapsLock;+  }+  if (stateNums) {+    *mods = *mods | kNumLock;+  }+  IOServiceClose(ioc);+  return true;+}+#else+/// A dummy function to be used by os_mod_status() if none of the above+/// platforms were detected",Too long for a summary.,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/8226,179001346,2018-04-04T00:48:45Z,test/functional/insert/insert_spec.lua,"@@ -0,0 +1,41 @@+local helpers = require('test.functional.helpers')(after_each)+local clear, feed, insert = helpers.clear, helpers.feed, helpers.insert+local command = helpers.command+local eq = helpers.eq+local expect = helpers.expect+local funcs = helpers.funcs++describe('insert-mode', function()+  before_each(function()+    clear()+  end)++  it('CTRL-@', function()+    -- Inserts last-inserted text, leaves insert-mode.+    insert('hello')+    feed('i<C-@>x')+    expect('hellhello')++    -- C-Space is the same as C-@.+    -- CTRL-SPC inserts last-inserted text, leaves insert-mode.+    feed('i<C-Space>x')+    expect('hellhellhello')++    -- CTRL-A inserts last inserted text+    feed('i<C-A>x')+    expect('hellhellhellhelloxo')+  end)++  it('ALT/META #8213', function()+    -- Mapped ALT-chord behaves as mapped.+    command('inoremap <M-l> meta-l')+    command('inoremap <A-j> alt-j')+    feed('i<M-l> xxx <A-j><M-h><A-h>')","My previous comment was confusing.  The TODO is ""totally ignore unmapped ALT chords in normal mode"".Not sure what's consistent.  With the current PR, unmapped ALT chords will (accidentally) behave like ESC+key, in normal-mode.",
112971,jamessan,https://api.github.com/repos/neovim/neovim/pulls/8226,179003721,2018-04-04T01:08:19Z,test/functional/insert/insert_spec.lua,"@@ -0,0 +1,41 @@+local helpers = require('test.functional.helpers')(after_each)+local clear, feed, insert = helpers.clear, helpers.feed, helpers.insert+local command = helpers.command+local eq = helpers.eq+local expect = helpers.expect+local funcs = helpers.funcs++describe('insert-mode', function()+  before_each(function()+    clear()+  end)++  it('CTRL-@', function()+    -- Inserts last-inserted text, leaves insert-mode.+    insert('hello')+    feed('i<C-@>x')+    expect('hellhello')++    -- C-Space is the same as C-@.+    -- CTRL-SPC inserts last-inserted text, leaves insert-mode.+    feed('i<C-Space>x')+    expect('hellhellhello')++    -- CTRL-A inserts last inserted text+    feed('i<C-A>x')+    expect('hellhellhellhelloxo')+  end)++  it('ALT/META #8213', function()+    -- Mapped ALT-chord behaves as mapped.+    command('inoremap <M-l> meta-l')+    command('inoremap <A-j> alt-j')+    feed('i<M-l> xxx <A-j><M-h><A-h>')","> Not sure what's consistent. With the current PR, unmapped ALT chords will (accidentally) behave like ESC+key, in normal-mode.Right, which is consistent with the behavior in insert mode.  Is there a reason to _restrict_ this to insert mode?  Doesn't that just add confusion?",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/8187,179297463,2018-04-04T22:05:55Z,src/nvim/os/keyboard.c,"@@ -0,0 +1,295 @@+// This is an open source non-commercial project. Dear PVS-Studio, please check+// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com++#include <assert.h>+#include <string.h>+#include <stdio.h>++#include <uv.h>++#include ""nvim/api/private/helpers.h""+#include ""nvim/api/private/defs.h""+#include ""nvim/lua/executor.h""+#include ""nvim/vim.h""+#include ""nvim/version.h""++#ifdef __linux__++#define XLIB_NAME ""libX11.so.6""+typedef void *_XDisplay;+typedef struct {+  char data[18];+} _XkbStateRec;+typedef int _XStatus;++///+enum { kLockedModsOffset = 9 };+enum { _XkbUseCoreKbd = 0x0100 };++/// Masks used in libX11 for different Lock states+typedef enum {+    xNumLock = 0x10,  ///< Mask for NumLock+    xCapsLock = 0x02,  ///< Mask for CapsLock+    xScrollLock = 0x80,  ///< Mask for ScrollLock+} xlib_KbdLocks;++#endif++#ifdef WIN32++#include <Winuser.h>++#endif++#ifdef __APPLE__++#define Boolean Boolean_I_Dont_Care+#include <IOKit/IOKitLib.h>+#include <IOKit/IOReturn.h>+#include <IOKit/hidsystem/IOHIDLib.h>+#include <IOKit/hidsystem/IOHIDParameter.h>+#include <CoreFoundation/CoreFoundation.h>+#undef Boolean++#endif+++/// Masks for the specific keyboard lock status+typedef enum {+  kNumLock = 0x01,  ///< Mask used to check if the NumLock is active+  kCapsLock = 0x02,  ///< Mask used to check if the CapsLock is active+  kScrollLock = 0x04,  ///< Mask used to check if the ScrollLock is active+} KbdLocks;++typedef int32_t mod_mask_t;++#if defined(__linux__)+static bool xlib_opened = false;+static uv_lib_t xlib;+static _XDisplay *(*_XOpenDisplay)(void *);+static int (*_XCloseDisplay)(_XDisplay *);+static _XStatus (*_XkbGetState)(_XDisplay *, unsigned, _XkbStateRec *);++/// A helper function to be used to load a function of libX11+static bool os_xlib_dlsym(const char *name, void **fun, Error *const err)+{+  const int ret = uv_dlsym(&xlib, name, fun);+  if (ret != 0) {+    api_set_error(err, kErrorTypeException,+                  ""E6000: Unable to open %s function from X11\n""+                  ""uv_dlsym Failed: %s"", uv_dlerror(&xlib));+    return false;+  }+  return true;+}++/// A helper function to be used to load the libX11 and required functions+static bool os_xlib_init(Error *const err)+{+  if (xlib_opened) {+    return true;+  }+  const int udl_ret = uv_dlopen(XLIB_NAME, &xlib);+  if (udl_ret != 0) {+    api_set_error(err, kErrorTypeException,+                  ""E5999: Unable to load libX11.so library\n""+                  ""uv_dlopen Failed: %s"", uv_dlerror(&xlib));+    return false;+  } else {+    xlib_opened = true;+  }++  if (!os_xlib_dlsym(""XOpenDisplay"", (void **)&_XOpenDisplay, err)+      || !os_xlib_dlsym(""XCloseDisplay"", (void **)&_XCloseDisplay, err)+      || !os_xlib_dlsym(""XkbGetState"", (void **)&_XkbGetState, err)) {+    return false;+  }+  return xlib_opened;+}++/// Get information about Num/Caps/Scroll Lock state in Linux+///+/// To be used in os_mods_status() function.+///+/// @param[out]  mods  Holds the information about the status of various locks+///                    in form of a pointer to enum KbdLocks.+/// @param[out]  err  Location and description where error message is to+///                   be saved.+///+/// @return -1 in case of error otherwise an integer specified for given OS.+static mod_mask_t os_get_locks_status(mod_mask_t *const mods, Error *const err)+{+  if (!os_xlib_init(err)) {+    return -1;+  }++  _XDisplay *const display = _XOpenDisplay(NULL);+  if (display == NULL) {+    api_set_error(err, kErrorTypeException,+                  ""E5666: Unable to open the display\n""+                  ""XOpenDisplay Failed"");+    return -1;+  }++  _XkbStateRec xkb_state;+  const _XStatus status = _XkbGetState(display, _XkbUseCoreKbd, &xkb_state);+  if (status) {+    api_set_error(err, kErrorTypeException,+                  ""E5888: Unable to get keyboard state of the display\n""+                  ""XkbGetState Failed: %d"", status);++    _XCloseDisplay(display);+  }++  int state = xkb_state.data[kLockedModsOffset];+  if (state & xNumLock) {+    *mods |= kNumLock;+  }++  if (state & xCapsLock) {+    *mods |= kCapsLock;+  }++  if (state & xScrollLock) {+    *mods |= xScrollLock;+  }++  _XCloseDisplay(display);+  return kCapsLock | kNumLock | kScrollLock;+}++#elif defined(WIN32)+/// Get information about Num/Caps/Scroll Lock state in Windows.+///+/// To be used in os_mods_status() function.+///+/// @param[out]  mods  Holds the information about the status of various locks+///                    in form of a pointer to enum KbdLocks.+/// @param[out]  err  Location and description where error message is to+///                   be saved.+///+/// @return -1 in case of error otherwise an integer specified for given OS.+static mod_mask_t os_get_locks_status(mod_mask_t *const mods, Error *const err)+{+  *mods = 0;+  if (GetKeyState(VK_CAPITAL) & 0x0001) {+    *mods |= kCapsLock;+  }+  if (GetKeyState(VK_NUMLOCK) & 0x0001) {+    *mods |= kNumLock;+  }+  if (GetKeyState(VK_SCROLL) & 0x0001) {+    *mods |= kScrollLock;+  }+  return kCapsLock | kNumLock | kScrollLock;+}++#elif defined(__APPLE__)+/// Get information about Num/Caps Lock state in MacOS+///+/// To be used in os_mods_status() function.+///+/// @param[out]  mods  Holds the information about the status of various locks+///                    in form of a pointer to enum KbdLocks.+/// @param[out]  err  Location and description where error message is to+///                   be saved.+///+/// @return -1 in case of error otherwise an integer specified for given OS.","This is ambiguous: what is ���an intereg specified for given OS��� supposed to mean? Should be something like ���-1 in case of error and a mask specifying which values in `mods` are valid otherwise��� (no mention of OS because it is really not OS-specific, just we do not support linux terminal or wayland currently and have no providers either).",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/8187,179298489,2018-04-04T22:10:57Z,src/nvim/os/keyboard.c,"@@ -0,0 +1,295 @@+// This is an open source non-commercial project. Dear PVS-Studio, please check+// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com++#include <assert.h>+#include <string.h>+#include <stdio.h>++#include <uv.h>++#include ""nvim/api/private/helpers.h""+#include ""nvim/api/private/defs.h""+#include ""nvim/lua/executor.h""+#include ""nvim/vim.h""+#include ""nvim/version.h""++#ifdef __linux__++#define XLIB_NAME ""libX11.so.6""+typedef void *_XDisplay;+typedef struct {+  char data[18];+} _XkbStateRec;+typedef int _XStatus;++///+enum { kLockedModsOffset = 9 };+enum { _XkbUseCoreKbd = 0x0100 };++/// Masks used in libX11 for different Lock states+typedef enum {+    xNumLock = 0x10,  ///< Mask for NumLock+    xCapsLock = 0x02,  ///< Mask for CapsLock+    xScrollLock = 0x80,  ///< Mask for ScrollLock+} xlib_KbdLocks;++#endif++#ifdef WIN32++#include <Winuser.h>++#endif++#ifdef __APPLE__++#define Boolean Boolean_I_Dont_Care+#include <IOKit/IOKitLib.h>+#include <IOKit/IOReturn.h>+#include <IOKit/hidsystem/IOHIDLib.h>+#include <IOKit/hidsystem/IOHIDParameter.h>+#include <CoreFoundation/CoreFoundation.h>+#undef Boolean++#endif+++/// Masks for the specific keyboard lock status+typedef enum {+  kNumLock = 0x01,  ///< Mask used to check if the NumLock is active+  kCapsLock = 0x02,  ///< Mask used to check if the CapsLock is active+  kScrollLock = 0x04,  ///< Mask used to check if the ScrollLock is active+} KbdLocks;++typedef int32_t mod_mask_t;++#if defined(__linux__)+static bool xlib_opened = false;+static uv_lib_t xlib;+static _XDisplay *(*_XOpenDisplay)(void *);+static int (*_XCloseDisplay)(_XDisplay *);+static _XStatus (*_XkbGetState)(_XDisplay *, unsigned, _XkbStateRec *);++/// A helper function to be used to load a function of libX11+static bool os_xlib_dlsym(const char *name, void **fun, Error *const err)+{+  const int ret = uv_dlsym(&xlib, name, fun);+  if (ret != 0) {+    api_set_error(err, kErrorTypeException,+                  ""E6000: Unable to open %s function from X11\n""+                  ""uv_dlsym Failed: %s"", uv_dlerror(&xlib));+    return false;+  }+  return true;+}++/// A helper function to be used to load the libX11 and required functions+static bool os_xlib_init(Error *const err)+{+  if (xlib_opened) {+    return true;+  }+  const int udl_ret = uv_dlopen(XLIB_NAME, &xlib);+  if (udl_ret != 0) {+    api_set_error(err, kErrorTypeException,+                  ""E5999: Unable to load libX11.so library\n""+                  ""uv_dlopen Failed: %s"", uv_dlerror(&xlib));+    return false;+  } else {+    xlib_opened = true;+  }++  if (!os_xlib_dlsym(""XOpenDisplay"", (void **)&_XOpenDisplay, err)+      || !os_xlib_dlsym(""XCloseDisplay"", (void **)&_XCloseDisplay, err)+      || !os_xlib_dlsym(""XkbGetState"", (void **)&_XkbGetState, err)) {+    return false;+  }+  return xlib_opened;+}++/// Get information about Num/Caps/Scroll Lock state in Linux+///+/// To be used in os_mods_status() function.+///+/// @param[out]  mods  Holds the information about the status of various locks+///                    in form of a pointer to enum KbdLocks.+/// @param[out]  err  Location and description where error message is to+///                   be saved.+///+/// @return -1 in case of error otherwise an integer specified for given OS.+static mod_mask_t os_get_locks_status(mod_mask_t *const mods, Error *const err)+{+  if (!os_xlib_init(err)) {+    return -1;+  }++  _XDisplay *const display = _XOpenDisplay(NULL);+  if (display == NULL) {+    api_set_error(err, kErrorTypeException,+                  ""E5666: Unable to open the display\n""+                  ""XOpenDisplay Failed"");+    return -1;+  }++  _XkbStateRec xkb_state;+  const _XStatus status = _XkbGetState(display, _XkbUseCoreKbd, &xkb_state);+  if (status) {+    api_set_error(err, kErrorTypeException,+                  ""E5888: Unable to get keyboard state of the display\n""+                  ""XkbGetState Failed: %d"", status);++    _XCloseDisplay(display);+  }++  int state = xkb_state.data[kLockedModsOffset];+  if (state & xNumLock) {+    *mods |= kNumLock;+  }++  if (state & xCapsLock) {+    *mods |= kCapsLock;+  }++  if (state & xScrollLock) {+    *mods |= xScrollLock;+  }++  _XCloseDisplay(display);+  return kCapsLock | kNumLock | kScrollLock;+}++#elif defined(WIN32)+/// Get information about Num/Caps/Scroll Lock state in Windows.+///+/// To be used in os_mods_status() function.+///+/// @param[out]  mods  Holds the information about the status of various locks+///                    in form of a pointer to enum KbdLocks.+/// @param[out]  err  Location and description where error message is to+///                   be saved.+///+/// @return -1 in case of error otherwise an integer specified for given OS.+static mod_mask_t os_get_locks_status(mod_mask_t *const mods, Error *const err)+{+  *mods = 0;+  if (GetKeyState(VK_CAPITAL) & 0x0001) {+    *mods |= kCapsLock;+  }+  if (GetKeyState(VK_NUMLOCK) & 0x0001) {+    *mods |= kNumLock;+  }+  if (GetKeyState(VK_SCROLL) & 0x0001) {+    *mods |= kScrollLock;+  }+  return kCapsLock | kNumLock | kScrollLock;+}++#elif defined(__APPLE__)+/// Get information about Num/Caps Lock state in MacOS+///+/// To be used in os_mods_status() function.+///+/// @param[out]  mods  Holds the information about the status of various locks+///                    in form of a pointer to enum KbdLocks.+/// @param[out]  err  Location and description where error message is to+///                   be saved.+///+/// @return -1 in case of error otherwise an integer specified for given OS.+static mod_mask_t os_get_locks_status(mod_mask_t *const mods, Error *const err)+{+  const CFMutableDictionaryRef mdict = IOServiceMatching(kIOHIDSystemClass);+  const io_service_t ios = IOServiceGetMatchingService(kIOMasterPortDefault,+                                                       (CFDictionaryRef)mdict);+  if (!ios) {+    if (mdict) {+      CFRelease(mdict);+    }+    api_set_error(err, kErrorTypeException,+                  ""E5777: Unable to initiate the service.\n""+                  ""IOServiceGetMatchingService() Failed"");+    return -1;+  }++  io_connect_t ioc;+  kern_return_t kr;+  if ((kr = IOServiceOpen(ios, mach_task_self(), kIOHIDParamConnectType,+                          &ioc)) != kIOReturnSuccess) {+    IOObjectRelease(ios);+    api_set_error(err, kErrorTypeException,+                  ""E5777: Unable to initiate the service.\n""+                  ""IOServiceOpen() Failed: %d"", (int)kr);+    return -1;+  }+  IOObjectRelease(ios);++  bool stateCaps;+  if ((kr = IOHIDGetModifierLockState(ioc, kIOHIDCapsLockState,+                                      &stateCaps)) != kIOReturnSuccess) {+    IOServiceClose(ioc);+    api_set_error(err, kErrorTypeException,+                  ""E5778: Unable to query CapsLock state.\n""+                  ""IOHIDGetModifierLockState() Failed: %d"", (int)kr);+    return -1;+  }++  bool stateNums;+  if ((kr = IOHIDGetModifierLockState(ioc, kIOHIDNumLockState,+                                      &stateNums)) != kIOReturnSuccess) {+    IOServiceClose(ioc);+    api_set_error(err, kErrorTypeException,+                  ""E5779: Unable to query NumLock state:\n""+                  ""IOHIDGetModifierLockState() Failed: %d"", (int)kr);+    return -1;+  }+  if (stateCaps) {+    *mods |= kCapsLock;+  }+  if (stateNums) {+    *mods |= kNumLock;+  }+  IOServiceClose(ioc);+  return kCapsLock | kNumLock;+}+#else+/// Dummy function used in case of no known platform detected.+///+/// @param[out]  mods  Holds the information about the status of various locks+///                    in form of a pointer to enum KbdLocks.+/// @param[out]  err  Location and description where error message is to+///                   be saved.+///+/// @return 0 for all the cases.+static mod_mask_t os_get_locks_status(mod_mask_t *const mods, Error *const err)+{+  *mods = 0;+  return 0;+}+#endif++/// Get information about Num/Caps/Scroll Lock state.+///+/// To be used in nvim_get_keyboard_mods_state() function.+///+/// @param[out]  dict  Pointer to dictionary where information about modifiers+///                    is to be dumped.+/// @param[out]  err  Location and description where error message is to","It sounds like `err` contains description of location where error message is saved alongside with location itself. This is not the case, remove ���and description���.",
8445768,coditva,https://api.github.com/repos/neovim/neovim/pulls/8076,179393727,2018-04-05T08:57:34Z,src/nvim/misc1.c,"@@ -2408,10 +2412,24 @@ get_number (   if (msg_silent != 0)     return 0; +  cmd_silent = false;  // Want to see the prompt.+  cmdline_row = msg_row;++  select = getcmdline_prompt('#', prompt, 0, EXPAND_NOTHING, NULL,+                             input_callback);+  p = select;++  // Since the user typed this, no need to wait for return.+  need_wait_return = false;+  msg_didout = false;+  cmd_silent = cmd_silent_save;+  ex_normal_busy = save_ex_normal_busy;+  callback_free(&input_callback);+   no_mapping++;-  for (;; ) {-    ui_cursor_goto(msg_row, msg_col);-    c = safe_vgetc();+  while (select) {","I removed the redundant handling, but how do I make the `#` mode special case in `command_line_handle_key`? Do I add a condition in this:```cif (!mouse_has(MOUSE_COMMAND)) {  return command_line_not_changed(s);}```",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/8076,179416925,2018-04-05T10:24:26Z,src/nvim/misc1.c,"@@ -2408,10 +2412,24 @@ get_number (   if (msg_silent != 0)     return 0; +  cmd_silent = false;  // Want to see the prompt.+  cmdline_row = msg_row;++  select = getcmdline_prompt('#', prompt, 0, EXPAND_NOTHING, NULL,+                             input_callback);+  p = select;++  // Since the user typed this, no need to wait for return.+  need_wait_return = false;+  msg_didout = false;+  cmd_silent = cmd_silent_save;+  ex_normal_busy = save_ex_normal_busy;+  callback_free(&input_callback);+   no_mapping++;-  for (;; ) {-    ui_cursor_goto(msg_row, msg_col);-    c = safe_vgetc();+  while (select) {","Good question, previously mouse works in `inputlist()` if the mode from which it was called was included in `set mouse`, but now it will be controlled by if `mouse=c` (or `a`, which is the default) is included. We could add an exception so that mouse is always active with `firstc='#'` unless `mouse` is completely empty. (this will also require change to `setmouse()`). For now, you can start with it working with `mouse=c` or `a`, so put the condition _after_ this if block.if `s->firstc == '#'` you will need to check if the mouse is above the cmdline row, and then `return 0` to abort the cmdline. But you need to somehow signal back to  `get_number` that mouse was used (so that it reads `mouse_row` instead), as `getcmdline_prompt` is not called much, adding a `bool *` out arg would be fine.",
15214129,nimitbhardwaj,https://api.github.com/repos/neovim/neovim/pulls/8187,179440322,2018-04-05T12:09:44Z,src/nvim/os/keyboard.c,"@@ -0,0 +1,295 @@+// This is an open source non-commercial project. Dear PVS-Studio, please check+// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com++#include <assert.h>+#include <string.h>+#include <stdio.h>++#include <uv.h>++#include ""nvim/api/private/helpers.h""+#include ""nvim/api/private/defs.h""+#include ""nvim/lua/executor.h""+#include ""nvim/vim.h""+#include ""nvim/version.h""++#ifdef __linux__++#define XLIB_NAME ""libX11.so.6""+typedef void *_XDisplay;+typedef struct {+  char data[18];+} _XkbStateRec;+typedef int _XStatus;++///+enum { kLockedModsOffset = 9 };+enum { _XkbUseCoreKbd = 0x0100 };++/// Masks used in libX11 for different Lock states+typedef enum {+    xNumLock = 0x10,  ///< Mask for NumLock+    xCapsLock = 0x02,  ///< Mask for CapsLock+    xScrollLock = 0x80,  ///< Mask for ScrollLock+} xlib_KbdLocks;++#endif++#ifdef WIN32++#include <Winuser.h>++#endif++#ifdef __APPLE__++#define Boolean Boolean_I_Dont_Care","Is the indentation is required for `include`s too, some of the files in neovim code use indentation for `include`s but some code don't use it, so it was ambiguous to me as earlier I used no space.I add space, if the coding style says",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/8187,179602423,2018-04-05T21:12:21Z,src/nvim/os/keyboard.c,"@@ -0,0 +1,292 @@+// This is an open source non-commercial project. Dear PVS-Studio, please check+// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com++# include <assert.h>+# include <string.h>+# include <stdio.h>++# include <uv.h>++# include ""nvim/api/private/helpers.h""+# include ""nvim/api/private/defs.h""+# include ""nvim/lua/executor.h""+# include ""nvim/os/keyboard.h""+# include ""nvim/vim.h""+# include ""nvim/version.h""++#  if defined(__linux__)+#  define XLIB_NAME ""libX11.so.6""++typedef void *_XDisplay;++///+typedef struct {+  char data[18];+} _XkbStateRec;+typedef int _XStatus;++/// The offset of the keyboard lock modes for X11+enum { kLockedModsOffset = 9 };+enum { _XkbUseCoreKbd = 0x0100 };++/// Masks used in libX11 for different Lock states+typedef enum {+    kXNumLock = 0x10,  ///< Mask for NumLock+    kXCapsLock = 0x02,  ///< Mask for CapsLock+    kXScrollLock = 0x80,  ///< Mask for ScrollLock+} XlibKbdLocks;+# elif defined(WIN32)+# include <Winuser.h>+# elif defined(__APPLE__)+# define Boolean Boolean_I_Dont_Care+# include <IOKit/IOKitLib.h>+# include <IOKit/IOReturn.h>+# include <IOKit/hidsystem/IOHIDLib.h>+# include <IOKit/hidsystem/IOHIDParameter.h>+# include <CoreFoundation/CoreFoundation.h>+# undef Boolean+# endif++/// Masks for the specific keyboard lock status+typedef enum {+  kNumLock = 0x01,  ///< Mask used to check if the NumLock is active+  kCapsLock = 0x02,  ///< Mask used to check if the CapsLock is active+  kScrollLock = 0x04,  ///< Mask used to check if the ScrollLock is active+} KbdLocks;++/// The enum to be used as a return type for os_get_locks_status() function+typedef enum {+  kLinuxMod = 0x07,  ///< All three locks, kNumLock | kCapsLock | kScrollLock+  kWin32Mod = 0x07,  ///< All three locks, kNumLock | kCapsLock | kScrollLock+  kMacOSMod = 0x03,  ///< Support two locks, kNumLock | kCapsLock+  kErrored = -0x01,  ///< The invalid status, some error occured+  kUnknownOS = 0x00,  ///< The function is not supported by given platform or OS+} OSModQuery;","This looks obscure. Previous variant was absolutely fine, except for the naming of the type, this one adds *third* block of OS-specific things. One with types and one with actual functions are necessary because types are needed to be defined before including generated declarations and functions should be put after, but I do not really see why this needs to exist and additionally you have a bunch of needless magic numbers here.",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/8187,179613349,2018-04-05T22:02:03Z,src/nvim/os/keyboard.c,"@@ -0,0 +1,292 @@+// This is an open source non-commercial project. Dear PVS-Studio, please check+// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com++# include <assert.h>","I would suggest to look at some newer files, which were not inherited from Vim. E.g. everything in `src/nvim/api`, or `src/nvim/eval` (the latter was created by me and should be more consistent with my comments: there are some things not covered by a style guide which are done differently, I also sometimes see direct violations of the portions of the style guide which are not covered by linter, some of them even done by me: e.g. until I did spot that casts are to be made without space and adjusted linter to check that all my code used to have space after a cast).",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/8187,179615150,2018-04-05T22:11:52Z,src/nvim/os/keyboard.c,"@@ -0,0 +1,285 @@+// This is an open source non-commercial project. Dear PVS-Studio, please check+// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com++#include <assert.h>+#include <string.h>+#include <stdio.h>++#include <uv.h>++#include ""nvim/api/private/helpers.h""+#include ""nvim/api/private/defs.h""+#include ""nvim/lua/executor.h""+#include ""nvim/os/keyboard.h""+#include ""nvim/vim.h""+#include ""nvim/version.h""++# if defined(__linux__)+#define XLIB_NAME ""libX11.so.6""++typedef void *_XDisplay;++/// Holds the data of the present state of Keyboard+typedef struct {+  char data[18];+} _XkbStateRec;+typedef int _XStatus;++/// The offset of the keyboard lock modes for X11+enum { kLockedModsOffset = 9 };+enum { _XkbUseCoreKbd = 0x0100 };++/// Masks used in libX11 for different Lock states+typedef enum {+    kXNumLock = 0x10,  ///< Mask for NumLock+    kXCapsLock = 0x02,  ///< Mask for CapsLock+    kXScrollLock = 0x80,  ///< Mask for ScrollLock+} XlibKbdLocks;+# elif defined(WIN32)+#include <Winuser.h>+# elif defined(__APPLE__)+#define Boolean Boolean_I_Dont_Care+#include <IOKit/IOKitLib.h>+#include <IOKit/IOReturn.h>+#include <IOKit/hidsystem/IOHIDLib.h>+#include <IOKit/hidsystem/IOHIDParameter.h>+#include <CoreFoundation/CoreFoundation.h>+#undef Boolean+# endif++/// Masks for the specific keyboard lock status+typedef enum {+  kNumLock = 0x01,  ///< Mask used to check if the NumLock is active+  kCapsLock = 0x02,  ///< Mask used to check if the CapsLock is active+  kScrollLock = 0x04,  ///< Mask used to check if the ScrollLock is active+} KbdLocks;++/// Used as a bitmask for the status of the different Lock Status+typedef int ModMask;++# ifdef INCLUDE_GENERATED_DECLARATIONS+#include ""os/keyboard.c.generated.h""+# endif++# if defined(__linux__)+static bool xlib_opened = false;+static uv_lib_t xlib;+static _XDisplay *(*_XOpenDisplay)(void *);+static int (*_XCloseDisplay)(_XDisplay *);+static _XStatus (*_XkbGetState)(_XDisplay *, unsigned, _XkbStateRec *);++/// A helper function to be used to load a function of libX11+static bool os_xlib_dlsym(const char *name, void **fun, Error *const err)+{+  const int ret = uv_dlsym(&xlib, name, fun);+  if (ret != 0) {+    api_set_error(err, kErrorTypeException,+                  ""Unable to obtain %s function from X11"",+                  name);+    return false;+  }+  return true;+}++/// A helper function to be used to load the libX11 and required functions+static bool os_xlib_init(Error *const err)+{+  if (xlib_opened) {+    return true;+  }+  const int udl_ret = uv_dlopen(XLIB_NAME, &xlib);+  if (udl_ret != 0) {+    api_set_error(err, kErrorTypeException,+                  ""Unable to load "" XLIB_NAME "": %s"",+                  uv_dlerror(&xlib));+    return false;+  } else {+    xlib_opened = true;+  }++  if (!os_xlib_dlsym(""XOpenDisplay"", (void **)&_XOpenDisplay, err)+      || !os_xlib_dlsym(""XCloseDisplay"", (void **)&_XCloseDisplay, err)+      || !os_xlib_dlsym(""XkbGetState"", (void **)&_XkbGetState, err)) {+    return false;+  }+  return xlib_opened;+}++/// Get information about Num/Caps/Scroll Lock state in Linux+///+/// To be used in os_mods_status() function.+///+/// @param[out]  mods  Holds the information about the status of various locks+///                    in form of a pointer to integer bitmask.+/// @param[out]  err  Location where error message is to be saved+///+/// @return -1 in case of error and a mask specifying which values+///         in mods are valid otherwise.+static const ModMask os_get_locks_status(ModMask *const mods, Error *const err)+{+  if (!os_xlib_init(err)) {+    return -1;+  }++  _XDisplay *const display = _XOpenDisplay(NULL);+  if (display == NULL) {+    api_set_error(err, kErrorTypeException,+                  ""Unable to open the display"");+    return -1;+  }++  _XkbStateRec xkb_state;+  const _XStatus status = _XkbGetState(display, _XkbUseCoreKbd, &xkb_state);+  if (status) {+    api_set_error(err, kErrorTypeException,+                  ""Unable to get keyboard state of the display"");++    _XCloseDisplay(display);+  }++  int state = xkb_state.data[kLockedModsOffset];+  if (state & kXNumLock) {+    *mods |= kNumLock;+  }++  if (state & kXCapsLock) {+    *mods |= kCapsLock;+  }++  if (state & kXScrollLock) {+    *mods |= kScrollLock;+  }++  _XCloseDisplay(display);+  return kCapsLock | kNumLock | kScrollLock;+}++# elif defined(WIN32)+/// Get information about Num/Caps/Scroll Lock state in Windows.+///+/// To be used in os_mods_status() function.+///+/// @param[out]  mods  Holds the information about the status of various locks+///                    in form of a pointer to integer bitmask.+/// @param[out]  err  Location where error message is to be saved+///+/// @return -1 in case of error and a mask specifying which values+///         in mods are valid otherwise.+static const ModMask os_get_locks_status(ModMask *const mods, Error *const err)+{+  *mods = 0;+  if (GetKeyState(VK_CAPITAL) & 0x0001) {+    *mods |= kCapsLock;+  }+  if (GetKeyState(VK_NUMLOCK) & 0x0001) {+    *mods |= kNumLock;+  }+  if (GetKeyState(VK_SCROLL) & 0x0001) {+    *mods |= kScrollLock;+  }+  return kCapsLock | kNumLock | kScrollLock;+}++# elif defined(__APPLE__)+/// Get information about Num/Caps Lock state in MacOS+///+/// To be used in os_mods_status() function.+///+/// @param[out]  mods  Holds the information about the status of various locks+///                    in form of a pointer to integer bitmask.+/// @param[out]  err  Location where error message is to be saved+///+/// @return -1 in case of error and a mask specifying which values+///         in mods are valid otherwise.+static const ModMask os_get_locks_status(ModMask *const mods, Error *const err)+{+  const CFMutableDictionaryRef mdict = IOServiceMatching(kIOHIDSystemClass);+  const io_service_t ios = IOServiceGetMatchingService(kIOMasterPortDefault,+                                                       (CFDictionaryRef)mdict);+  if (!ios) {+    if (mdict) {+      CFRelease(mdict);+    }+    api_set_error(err, kErrorTypeException,+                  ""Unable to get the Matching IOService"");",Using `M` is weird. Also matching what? Based on the invocation of the function alone I would spelled that as ���Unable to get service for default master port���. Though after viewing documentation it looks like it should be ���Unable to get service for HID system class���.,
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/8187,179621103,2018-04-05T22:45:51Z,src/nvim/os/keyboard.c,"@@ -0,0 +1,285 @@+// This is an open source non-commercial project. Dear PVS-Studio, please check+// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com++#include <assert.h>+#include <string.h>+#include <stdio.h>++#include <uv.h>++#include ""nvim/api/private/helpers.h""+#include ""nvim/api/private/defs.h""+#include ""nvim/lua/executor.h""+#include ""nvim/os/keyboard.h""+#include ""nvim/vim.h""+#include ""nvim/version.h""++#if defined(__linux__)+# define XLIB_NAME ""libX11.so.6""++typedef void *_XDisplay;++/// Holds the data of the present state of Keyboard+typedef struct {+  char data[18];+} _XkbStateRec;+typedef int _XStatus;++/// The offset of the keyboard lock modes for X11+enum { kLockedModsOffset = 9 };+enum { _XkbUseCoreKbd = 0x0100 };++/// Masks used in libX11 for different Lock states+typedef enum {+    kXNumLock = 0x10,  ///< Mask for NumLock+    kXCapsLock = 0x02,  ///< Mask for CapsLock+    kXScrollLock = 0x80,  ///< Mask for ScrollLock+} XlibKbdLocks;+#elif defined(WIN32)+# include <Winuser.h>+#elif defined(__APPLE__)+# define Boolean Boolean_I_Dont_Care+# include <IOKit/IOKitLib.h>+# include <IOKit/IOReturn.h>+# include <IOKit/hidsystem/IOHIDLib.h>+# include <IOKit/hidsystem/IOHIDParameter.h>+# include <CoreFoundation/CoreFoundation.h>+# undef Boolean+#endif++/// Masks for the specific keyboard lock status+typedef enum {+  kNumLock = 0x01,  ///< Mask used to check if the NumLock is active+  kCapsLock = 0x02,  ///< Mask used to check if the CapsLock is active+  kScrollLock = 0x04,  ///< Mask used to check if the ScrollLock is active+} KbdLocks;++/// Used as a bitmask for the status of the different Lock Status+typedef int ModMask;++#ifdef INCLUDE_GENERATED_DECLARATIONS+# include ""os/keyboard.c.generated.h""+#endif++#if defined(__linux__)+static bool xlib_opened = false;+static uv_lib_t xlib;+static _XDisplay *(*_XOpenDisplay)(void *);+static int (*_XCloseDisplay)(_XDisplay *);+static _XStatus (*_XkbGetState)(_XDisplay *, unsigned, _XkbStateRec *);++/// A helper function to be used to load a function of libX11+static bool os_xlib_dlsym(const char *name, void **fun, Error *const err)+{+  const int ret = uv_dlsym(&xlib, name, fun);+  if (ret != 0) {+    api_set_error(err, kErrorTypeException,+                  ""Unable to obtain %s function from X11"",+                  name);+    return false;+  }+  return true;+}++/// A helper function to be used to load the libX11 and required functions+static bool os_xlib_init(Error *const err)+{+  if (xlib_opened) {+    return true;+  }+  const int udl_ret = uv_dlopen(XLIB_NAME, &xlib);+  if (udl_ret != 0) {+    api_set_error(err, kErrorTypeException,+                  ""Unable to load "" XLIB_NAME "": %s"",+                  uv_dlerror(&xlib));+    return false;+  } else {+    xlib_opened = true;+  }++  if (!os_xlib_dlsym(""XOpenDisplay"", (void **)&_XOpenDisplay, err)+      || !os_xlib_dlsym(""XCloseDisplay"", (void **)&_XCloseDisplay, err)+      || !os_xlib_dlsym(""XkbGetState"", (void **)&_XkbGetState, err)) {+    return false;+  }+  return xlib_opened;+}++/// Get information about Num/Caps/Scroll Lock state in Linux+///+/// To be used in os_mods_status() function.+///+/// @param[out]  mods  Holds the information about the status of various locks+///                    in form of a pointer to integer bitmask.+/// @param[out]  err  Location where error message is to be saved+///+/// @return -1 in case of error and a mask specifying which values+///         in mods are valid otherwise.+static ModMask os_get_locks_status(ModMask *const mods, Error *const err)+{+  if (!os_xlib_init(err)) {+    return -1;+  }++  _XDisplay *const display = _XOpenDisplay(NULL);+  if (display == NULL) {+    api_set_error(err, kErrorTypeException,+                  ""Unable to open the display"");+    return -1;+  }++  _XkbStateRec xkb_state;+  const _XStatus status = _XkbGetState(display, _XkbUseCoreKbd, &xkb_state);+  if (status) {+    api_set_error(err, kErrorTypeException,+                  ""Unable to get keyboard state of the display"");++    _XCloseDisplay(display);+  }++  int state = xkb_state.data[kLockedModsOffset];+  if (state & kXNumLock) {+    *mods |= kNumLock;+  }++  if (state & kXCapsLock) {+    *mods |= kCapsLock;+  }++  if (state & kXScrollLock) {+    *mods |= kScrollLock;+  }++  _XCloseDisplay(display);+  return kCapsLock | kNumLock | kScrollLock;+}++#elif defined(WIN32)+/// Get information about Num/Caps/Scroll Lock state in Windows.+///+/// To be used in os_mods_status() function.+///+/// @param[out]  mods  Holds the information about the status of various locks+///                    in form of a pointer to integer bitmask.+/// @param[out]  err  Location where error message is to be saved+///+/// @return -1 in case of error and a mask specifying which values+///         in mods are valid otherwise.+static ModMask os_get_locks_status(ModMask *const mods, Error *const err)+{+  *mods = 0;+  if (GetKeyState(VK_CAPITAL) & 0x0001) {+    *mods |= kCapsLock;+  }+  if (GetKeyState(VK_NUMLOCK) & 0x0001) {+    *mods |= kNumLock;+  }+  if (GetKeyState(VK_SCROLL) & 0x0001) {+    *mods |= kScrollLock;+  }+  return kCapsLock | kNumLock | kScrollLock;+}++#elif defined(__APPLE__)+/// Get information about Num/Caps Lock state in MacOS+///+/// To be used in os_mods_status() function.+///+/// @param[out]  mods  Holds the information about the status of various locks+///                    in form of a pointer to integer bitmask.+/// @param[out]  err  Location where error message is to be saved+///+/// @return -1 in case of error and a mask specifying which values+///         in mods are valid otherwise.+static ModMask os_get_locks_status(ModMask *const mods, Error *const err)+{+  const CFMutableDictionaryRef mdict = IOServiceMatching(kIOHIDSystemClass);+  const io_service_t ios = IOServiceGetMatchingService(kIOMasterPortDefault,+                                                       (CFDictionaryRef)mdict);+  if (!ios) {+    if (mdict) {+      CFRelease(mdict);+    }+    api_set_error(err, kErrorTypeException,+                  ""Unable to get service for default master port"");+    return -1;+  }++  io_connect_t ioc;+  if (IOServiceOpen(ios, mach_task_self(), kIOHIDParamConnectType,+                    &ioc) != kIOReturnSuccess) {+    IOObjectRelease(ios);+    api_set_error(err, kErrorTypeException,+                  ""Unable to get service for HID system class"");+    return -1;+  }+  IOObjectRelease(ios);++  bool stateCaps;+  if (IOHIDGetModifierLockState(ioc, kIOHIDCapsLockState,+                                &stateCaps) != kIOReturnSuccess) {+    IOServiceClose(ioc);+    api_set_error(err, kErrorTypeException,+                  ""Unable to query CapsLock state"");+    return -1;+  }++  bool stateNums;+  if (IOHIDGetModifierLockState(ioc, kIOHIDNumLockState,+                                &stateNums) != kIOReturnSuccess) {+    IOServiceClose(ioc);+    api_set_error(err, kErrorTypeException,+                  ""Unable to query NumLock state"");+    return -1;+  }+  if (stateCaps) {+    *mods |= kCapsLock;+  }+  if (stateNums) {+    *mods |= kNumLock;+  }+  IOServiceClose(ioc);+  return kCapsLock | kNumLock;+}+#else+/// Dummy function used in case of no known platform detected.+///+/// @param[out]  mods  Holds the information about the status of various locks+///                    in form of a pointer to integer bitmask.+/// @param[out]  err  Location where error message is to be saved+///+/// @return Always return 0.+static ModMask os_get_locks_status(ModMask *const mods, Error *const err)+{+  *mods = 0;+  return 0;+}+#endif++/// Get information about Num/Caps/Scroll Lock state.+///+/// To be used in nvim_get_keyboard_mods_state() function.+///+/// @param[out]  dict  Pointer to dictionary where information about modifiers+///                    is to be dumped.+/// @param[out]  err  Location where error message is to be saved+///+/// @return true in case of no error, false otherwise.+bool os_mods_status(Dictionary *const dict, Error *const err)",And `FUNC_ATTR_NONNULL_ALL` here (warning for unused result is not needed as result is actually redundant).,
17116349,utkarsh009,https://api.github.com/repos/neovim/neovim/pulls/8222,179654097,2018-04-06T03:42:06Z,third-party/cmake/BuildLuv.cmake,"@@ -89,6 +89,10 @@ endif() set(LUV_BUILD_COMMAND ${CMAKE_COMMAND} --build .) set(LUV_INSTALL_COMMAND ${CMAKE_COMMAND} --build . --target install) +if(CMAKE_SYSTEM_NAME MATCHES ""OpenBSD"")+  set(CMAKE_MAKE_PROGRAM ""/usr/local/bin/gmake"" CACHE INTERNAL ""make->gmake"" FORCE)+endif()","`MAKE_PRG` is not set to `gmake`. It's set to `$(MAKE)`. I believe [this](https://github.com/neovim/neovim/blob/d49c1dda8bf57587c609f3de7b78393f748a9df4/third-party/CMakeLists.txt#L81) is the culprit. If you don't want to hardcode it, we can either search for it here itself, or remove the line that I linked (Although, it says that it's a fix for an error).For now, I've changed the code a bit. This should work better. The previous version wasn't working when I tested it today.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/8245,179942401,2018-04-08T10:00:49Z,test/functional/api/ui_spec.lua,"@@ -0,0 +1,39 @@+local helpers = require('test.functional.helpers')(after_each)+local Screen = require('test.functional.ui.screen')+local clear = helpers.clear+local eq = helpers.eq+local eval = helpers.eval+local request = helpers.request++describe('nvim_ui_attach()', function()+  before_each(function()+    clear()+  end)+  it('handles very large width/height #2180', function()+    local screen = Screen.new(999, 999)+    screen:attach()+    eq(999, eval('&lines'))+    eq(999, eval('&columns'))+  end)+  it('invalid option returns error', function()+    local screen = Screen.new()+    local status, rv = pcall(function() screen:attach({foo={'foo'}}) end)+    eq(false, status)+    eq('No such UI option', rv:match(""No such .*""))+  end)+  it('validates channel arg', function()+    assert.has_error(function() request('nvim_ui_try_resize', 40, 10) end,","I mean in length and readability, I don't think we should start using a style where a lambda is required to assert every error return of an ordinary API call.  I just realised `eq({false, errmsg}, {pcall(method, args)})` should work, though it looks a bit weird if not used to lua arglist semantics...",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/8246,179942926,2018-04-08T10:24:30Z,src/nvim/api/ui.c,"@@ -53,8 +53,18 @@ void remote_ui_disconnect(uint64_t channel_id)  void nvim_ui_attach(uint64_t channel_id, Integer width, Integer height,                     Dictionary options, Error *err)-  FUNC_API_SINCE(1) FUNC_API_REMOTE_ONLY+  FUNC_API_SINCE(1) {+  if (is_internal_call(channel_id)) {","But my very point is that that this is a _weird_ and unfortunate special case for TUI. :)This function never does ask an UI to start. Rather it is _used by_ an intented UI to ask nvim to subscribe to UI events. The fact that args is ignored has noting to do with optional args, the point that it demonstrates an abstraction mismatch would stand even if the API had optional args. (because you can still pass the args, and they make no sense at all)I'm not trying to be pedantic, as indeed the _actual_ meaning of this function (send UI events to the caller) has a straightforward generalization to internal use: by lua code to ask lua callback to be called on UI layer events (so that lua can draw externalized widgets on a private grid layer)Also for rplugins it would be weird to not be able to call this function directly. Why should `vim.funcs.nvim_ui_detach` have a radically different meaning than `vim.api.ui_detach`. isn't `api.tui_stop` much more self-documenting and explicit?",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/8187,179942943,2018-04-08T10:25:24Z,test/functional/api/vim_spec.lua,"@@ -1036,5 +1036,33 @@ describe('api', function()       eq(expected, nvim(""list_uis""))     end)   end)-+  describe('nvim_get_keyboard_mods_state', function()+    it('on linux either xlib11 is available or not', function()+      if os_name() == 'unix' then+        local status, rv = pcall(nvim, ""get_keyboard_mods_state"")+        if status == true then","Never check boolean variables for equality to something in conditions, they are boolean precisely for them to be put in condition directly.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/8246,179943143,2018-04-08T10:33:50Z,src/nvim/api/ui.c,"@@ -53,8 +53,18 @@ void remote_ui_disconnect(uint64_t channel_id)  void nvim_ui_attach(uint64_t channel_id, Integer width, Integer height,                     Dictionary options, Error *err)-  FUNC_API_SINCE(1) FUNC_API_REMOTE_ONLY+  FUNC_API_SINCE(1) {+  if (is_internal_call(channel_id)) {","Good points. ~~How do you feel about a `:tui` command, similar to the `:gui` command?~~ ",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/8187,179948647,2018-04-08T13:57:23Z,src/nvim/api/vim.c,"@@ -1562,3 +1563,21 @@ Object nvim_get_proc(Integer pid, Error *err) #endif   return rvobj; }++/// Give the info of the state of the Caps/Num/Scroll lock.+///+/// This info will be in form of the dictionary, having+/// `CapsLock`, `NumLock` and `ScrollLock` as the entities+/// iff they are supported by their respective OS and are implemented.","Respective to what? And it is not OS-specific in longer term, it is implementation-specific. Just say about checking for them being implemented.",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/8187,179948848,2018-04-08T14:03:32Z,src/nvim/os/keyboard.c,"@@ -0,0 +1,292 @@+// This is an open source non-commercial project. Dear PVS-Studio, please check+// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com++#include <assert.h>+#include <string.h>+#include <stdio.h>++#include <uv.h>++#include ""nvim/api/private/helpers.h""+#include ""nvim/api/private/defs.h""+#include ""nvim/lua/executor.h""+#include ""nvim/os/keyboard.h""+#include ""nvim/vim.h""+#include ""nvim/version.h""++#if defined(__linux__)+# define XLIB_NAME ""libX11.so.6""++typedef void *_XDisplay;++/// Holds the data of the present state of Keyboard+typedef struct {+  char data[18];+} _XkbStateRec;+typedef int _XStatus;++/// The offset of the keyboard lock modes for X11+enum { kLockedModsOffset = 9 };+enum { _XkbUseCoreKbd = 0x0100 };++/// Masks used in libX11 for different Lock states+typedef enum {+    kXNumLock = 0x10,  ///< Mask for NumLock+    kXCapsLock = 0x02,  ///< Mask for CapsLock+    kXScrollLock = 0x80,  ///< Mask for ScrollLock+} XlibKbdLocks;+#elif defined(WIN32)+# include <Winuser.h>+#elif defined(__APPLE__)+# define Boolean Boolean_I_Dont_Care+# include <IOKit/IOKitLib.h>+# include <IOKit/IOReturn.h>+# include <IOKit/hidsystem/IOHIDLib.h>+# include <IOKit/hidsystem/IOHIDParameter.h>+# include <CoreFoundation/CoreFoundation.h>+# undef Boolean+#endif++/// Masks for the specific keyboard lock status+typedef enum {+  kNumLock = 0x01,  ///< Mask used to check if the NumLock is active+  kCapsLock = 0x02,  ///< Mask used to check if the CapsLock is active+  kScrollLock = 0x04,  ///< Mask used to check if the ScrollLock is active+} KbdLocks;++/// Used as a bitmask for the status of the different Lock Status+typedef int ModMask;++#ifdef INCLUDE_GENERATED_DECLARATIONS+# include ""os/keyboard.c.generated.h""+#endif++#if defined(__linux__)+static bool xlib_opened = false;+static uv_lib_t xlib;+static _XDisplay *(*_XOpenDisplay)(void *);+static int (*_XCloseDisplay)(_XDisplay *);+static _XStatus (*_XkbGetState)(_XDisplay *, unsigned, _XkbStateRec *);++/// A helper function to be used to load a function of libX11","Documentation string looks strange and it is missing documentation about arguments and return value.```C/// Load symbol from previously opened X11 library////// Requires os_xlib_init() to successfully load library before calling this.////// @param[in]  name  Symbol to load. Assumes it being a function name./// @param[out]  fun  Location where to put load results./// @param[out]  err  Location where to save error.////// @return true if loading was successfull, false otherwise.```",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/8187,179949000,2018-04-08T14:09:32Z,src/nvim/os/keyboard.c,"@@ -0,0 +1,292 @@+// This is an open source non-commercial project. Dear PVS-Studio, please check+// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com++#include <assert.h>+#include <string.h>+#include <stdio.h>++#include <uv.h>++#include ""nvim/api/private/helpers.h""+#include ""nvim/api/private/defs.h""+#include ""nvim/lua/executor.h""+#include ""nvim/os/keyboard.h""+#include ""nvim/vim.h""+#include ""nvim/version.h""++#if defined(__linux__)+# define XLIB_NAME ""libX11.so.6""++typedef void *_XDisplay;++/// Holds the data of the present state of Keyboard+typedef struct {+  char data[18];+} _XkbStateRec;+typedef int _XStatus;++/// The offset of the keyboard lock modes for X11+enum { kLockedModsOffset = 9 };+enum { _XkbUseCoreKbd = 0x0100 };++/// Masks used in libX11 for different Lock states+typedef enum {+    kXNumLock = 0x10,  ///< Mask for NumLock+    kXCapsLock = 0x02,  ///< Mask for CapsLock+    kXScrollLock = 0x80,  ///< Mask for ScrollLock+} XlibKbdLocks;+#elif defined(WIN32)+# include <Winuser.h>+#elif defined(__APPLE__)+# define Boolean Boolean_I_Dont_Care+# include <IOKit/IOKitLib.h>+# include <IOKit/IOReturn.h>+# include <IOKit/hidsystem/IOHIDLib.h>+# include <IOKit/hidsystem/IOHIDParameter.h>+# include <CoreFoundation/CoreFoundation.h>+# undef Boolean+#endif++/// Masks for the specific keyboard lock status+typedef enum {+  kNumLock = 0x01,  ///< Mask used to check if the NumLock is active+  kCapsLock = 0x02,  ///< Mask used to check if the CapsLock is active+  kScrollLock = 0x04,  ///< Mask used to check if the ScrollLock is active+} KbdLocks;++/// Used as a bitmask for the status of the different Lock Status+typedef int ModMask;++#ifdef INCLUDE_GENERATED_DECLARATIONS+# include ""os/keyboard.c.generated.h""+#endif++#if defined(__linux__)+static bool xlib_opened = false;+static uv_lib_t xlib;+static _XDisplay *(*_XOpenDisplay)(void *);+static int (*_XCloseDisplay)(_XDisplay *);+static _XStatus (*_XkbGetState)(_XDisplay *, unsigned, _XkbStateRec *);++/// A helper function to be used to load a function of libX11+static bool os_xlib_dlsym(const char *name, void **fun, Error *err)+  FUNC_ATTR_NONNULL_ALL+{+  const int ret = uv_dlsym(&xlib, name, fun);+  if (ret != 0) {+    api_set_error(err, kErrorTypeException,+                  ""Unable to obtain %s function from X11"",+                  name);+    return false;+  }+  return true;+}++/// A helper function to be used to load the libX11 and required functions","This also missing documentation about return value. And do not add noise about something being a ���helper function���, most functions are like this.```C/// Initialize global variables, loading X11 library and required functions////// @param[out]  err  Location where error is saved.////// @return true if everything was loaded successfully, false otherwise.```(and do not use ���helper function��� here, there is no clear definition of ���helper��� for this statement to be useful, but it does occupy place)",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/8187,179949999,2018-04-08T14:41:50Z,src/nvim/os/keyboard.c,"@@ -0,0 +1,304 @@+// This is an open source non-commercial project. Dear PVS-Studio, please check+// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com++#include <assert.h>+#include <string.h>+#include <stdio.h>++#include <uv.h>++#include ""nvim/api/private/helpers.h""+#include ""nvim/api/private/defs.h""+#include ""nvim/lua/executor.h""+#include ""nvim/os/keyboard.h""+#include ""nvim/vim.h""+#include ""nvim/version.h""++#if defined(__linux__)+# define XLIB_NAME ""libX11.so.6""++typedef void *_XDisplay;++/// Holds the data of the present state of Keyboard+typedef struct {+  char data[18];+} _XkbStateRec;+typedef int _XStatus;++/// The offset of the keyboard lock modes for X11+enum { kLockedModsOffset = 9 };+enum { _XkbUseCoreKbd = 0x0100 };++/// Masks used in libX11 for different Lock states+typedef enum {+    kXNumLock = 0x10,  ///< Mask for NumLock+    kXCapsLock = 0x02,  ///< Mask for CapsLock+    kXScrollLock = 0x80,  ///< Mask for ScrollLock+} XlibKbdLocks;+#elif defined(WIN32)+# include <Winuser.h>+#elif defined(__APPLE__)+# define Boolean Boolean_I_Dont_Care+# include <IOKit/IOKitLib.h>+# include <IOKit/IOReturn.h>+# include <IOKit/hidsystem/IOHIDLib.h>+# include <IOKit/hidsystem/IOHIDParameter.h>+# include <CoreFoundation/CoreFoundation.h>+# undef Boolean+#endif++/// Masks for the specific keyboard lock status+typedef enum {+  kNumLock = 0x01,  ///< Mask used to check if the NumLock is active+  kCapsLock = 0x02,  ///< Mask used to check if the CapsLock is active+  kScrollLock = 0x04,  ///< Mask used to check if the ScrollLock is active+} KbdLocks;++/// Used as a bitmask for the status of the different Lock Status+typedef int ModMask;++#ifdef INCLUDE_GENERATED_DECLARATIONS+# include ""os/keyboard.c.generated.h""+#endif++#if defined(__linux__)+static bool xlib_opened = false;+static uv_lib_t xlib;+static _XDisplay *(*_XOpenDisplay)(void *);+static int (*_XCloseDisplay)(_XDisplay *);+static _XStatus (*_XkbGetState)(_XDisplay *, unsigned, _XkbStateRec *);++/// Load symbol from previously opened X11 library+///+/// Requires os_xlib_init() to be called successfully before.","You picked a wrong version of this paragraph, I updated that later: this function is called from within `os_xlib_init()` so it can���t require it to be called successfully. Updated variant was ���Requires os_xlib_init() to successfully load library before calling this.���.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/8245,180140947,2018-04-09T15:49:41Z,test/functional/api/ui_spec.lua,"@@ -0,0 +1,39 @@+local helpers = require('test.functional.helpers')(after_each)+local Screen = require('test.functional.ui.screen')+local clear = helpers.clear+local eq = helpers.eq+local eval = helpers.eval+local request = helpers.request++describe('nvim_ui_attach()', function()+  before_each(function()+    clear()+  end)+  it('handles very large width/height #2180', function()+    local screen = Screen.new(999, 999)+    screen:attach()+    eq(999, eval('&lines'))+    eq(999, eval('&columns'))+  end)+  it('invalid option returns error', function()+    local screen = Screen.new()+    local status, rv = pcall(function() screen:attach({foo={'foo'}}) end)+    eq(false, status)+    eq('No such UI option', rv:match(""No such .*""))+  end)+  it('validates channel arg', function()+    assert.has_error(function() request('nvim_ui_try_resize', 40, 10) end,","luassert uses the following pattern:```    -- remove 'path/to/file:line: ' from string    err_actual = err_actual:gsub('^.-:%d+: ', '', 1)```",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/8187,180918514,2018-04-11T22:37:10Z,test/functional/api/vim_spec.lua,"@@ -1037,4 +1037,31 @@ describe('api', function()     end)   end) +  describe('nvim_get_keyboard_mods', function()+    it('returs a dictionary on or the specific error', function()+      -- Returns the dictionary on success otherwise a specified error+      -- if the resources were not present on the system.++      local status, rv = pcall(meths.get_keyboard_mods)+      if status then+        for k, v in pairs(rv) do+          eq(true, ({CapsLock=true, NumLock=true, ScrollLock=true})[k])+          eq('boolean', type(v))+        end+      else+        if os_name() == 'unix' then+          local errMch = string.match(rv, ""Unable to load *"")","`<space>*` means ���space repeated zero or more times��� and not ���space followed by any number of any characters���. I.e. having asterisk here is absolutely pointless, removing it will not change conditions under which tests pass at all, though theoretically may alter the error message (i.e. make ���*error message part* then two spaces��� fail with ������*error message part* then space��� not equal to ���*error message part* then two spaces������ error rather then ������*error message part* then space��� not equal to `nil`��� error).",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/8187,180919231,2018-04-11T22:40:55Z,test/functional/api/vim_spec.lua,"@@ -1037,4 +1037,31 @@ describe('api', function()     end)   end) +  describe('nvim_get_keyboard_mods', function()+    it('returs a dictionary on or the specific error', function()+      -- Returns the dictionary on success otherwise a specified error+      -- if the resources were not present on the system.++      local status, rv = pcall(meths.get_keyboard_mods)+      if status then+        for k, v in pairs(rv) do+          eq(true, ({CapsLock=true, NumLock=true, ScrollLock=true})[k])+          eq('boolean', type(v))+        end+      else+        if os_name() == 'unix' then+          local errMch = string.match(rv, ""Unable to load *"")","And, BTW, `string` ���module��� needs not be used, `string.match(str, re)` is the same thing as `str:match(re)` as long as `str` has string type.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/8267,181260964,2018-04-13T00:48:57Z,src/nvim/fileio.c,"@@ -1737,9 +1737,17 @@ readfile (   xfree(buffer);    if (read_stdin) {-    /* Use stderr for stdin, makes shell commands work. */     close(0);+#ifndef WIN32+    // On Unix, use stderr for stdin, makes shell commands work.     ignored = dup(2);","In Vim this is guarded by `HAVE_DUP`, which is defined for Windows (`src/os_dos.h` in Vim's source).https://github.com/vim/vim/blob/e7499ddc33508d3d341e96f84a0e7b95b2d6927c/src/fileio.c#L2397-L2398I wonder why it doesn't work in Nvim.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/8249,181263178,2018-04-13T01:09:55Z,src/nvim/terminal.c,"@@ -359,6 +359,15 @@ void terminal_resize(Terminal *term, uint16_t width, uint16_t height)     return;   } +  FOR_ALL_TAB_WINDOWS(tp, wp) {","@mrbiggfoot this will loop through all tabs, is that intended? To loop only the current tab:    FOR_ALL_WINDOWS_IN_TAB(wp, curtab)",
16161283,b-r-o-c-k,https://api.github.com/repos/neovim/neovim/pulls/8267,181271430,2018-04-13T02:21:58Z,src/nvim/fileio.c,"@@ -1737,9 +1737,17 @@ readfile (   xfree(buffer);    if (read_stdin) {-    /* Use stderr for stdin, makes shell commands work. */     close(0);+#ifndef WIN32+    // On Unix, use stderr for stdin, makes shell commands work.     ignored = dup(2);",It doesn't really work in Vim either. When it fails to read from stdin it falls back to reading from the Windows console input buffer.https://github.com/vim/vim/blob/e7499ddc33508d3d341e96f84a0e7b95b2d6927c/src/os_win32.c#L1703-L1714,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/8273,181548182,2018-04-14T10:10:39Z,src/nvim/event/process.c,"@@ -228,29 +228,26 @@ void process_stop(Process *proc) FUNC_ATTR_NONNULL_ALL   }    Loop *loop = proc->loop;-  if (!loop->children_stop_requests++) {","Small cleanup: I removed `loop->children_stop_requests` because it seems useless.  It will always be 0 here, because `process_stop()` is guarded by `proc->stopped_time`.",
16161283,b-r-o-c-k,https://api.github.com/repos/neovim/neovim/pulls/8267,181554585,2018-04-14T14:59:29Z,src/nvim/tui/input.c,"@@ -47,7 +47,13 @@ void term_input_init(TermInput *input, Loop *loop)   termkey_set_canonflags(input->tk, curflags | TERMKEY_CANON_DELBS);   // setup input handle #ifdef WIN32-  uv_tty_init(&loop->uv, &input->tty_in, 0, 1);+  // On Windows, always read from the console input buffer instead of stdin.+  // This avoids problems when stdin was previously used for other input.+  const HANDLE conin_handle = CreateFile(""CONIN$"", GENERIC_READ | GENERIC_WRITE,+                            FILE_SHARE_READ, (LPSECURITY_ATTRIBUTES)NULL,+                            OPEN_EXISTING, 0, (HANDLE)NULL);+  const int conin_fd = _open_osfhandle(conin_handle, _O_RDONLY);+  uv_tty_init(loop, &input->tty_in, conin_fd, true);",I think it's a better idea to move this patch to here because it's going to be less redundant. The patch won't need to be duplicated in #6299 if it's moved to here.,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/8267,181555496,2018-04-14T15:37:19Z,src/nvim/tui/input.c,"@@ -47,7 +47,13 @@ void term_input_init(TermInput *input, Loop *loop)   termkey_set_canonflags(input->tk, curflags | TERMKEY_CANON_DELBS);   // setup input handle #ifdef WIN32-  uv_tty_init(&loop->uv, &input->tty_in, 0, 1);+  // On Windows, always read from the console input buffer instead of stdin.+  // This avoids problems when stdin was previously used for other input.+  const HANDLE conin_handle = CreateFile(""CONIN$"", GENERIC_READ | GENERIC_WRITE,+                            FILE_SHARE_READ, (LPSECURITY_ATTRIBUTES)NULL,+                            OPEN_EXISTING, 0, (HANDLE)NULL);+  const int conin_fd = _open_osfhandle(conin_handle, _O_RDONLY);+  uv_tty_init(loop, &input->tty_in, conin_fd, true);","@b-r-o-c-k seems reasonable, but then it won't work for `--headless` (TUI is not started then). So some duplication or refactoring might still be needed.",
16161283,b-r-o-c-k,https://api.github.com/repos/neovim/neovim/pulls/8267,181560100,2018-04-14T18:40:27Z,src/nvim/tui/input.c,"@@ -47,7 +47,13 @@ void term_input_init(TermInput *input, Loop *loop)   termkey_set_canonflags(input->tk, curflags | TERMKEY_CANON_DELBS);   // setup input handle #ifdef WIN32-  uv_tty_init(&loop->uv, &input->tty_in, 0, 1);+  // On Windows, always read from the console input buffer instead of stdin.+  // This avoids problems when stdin was previously used for other input.+  const HANDLE conin_handle = CreateFile(""CONIN$"", GENERIC_READ | GENERIC_WRITE,+                            FILE_SHARE_READ, (LPSECURITY_ATTRIBUTES)NULL,+                            OPEN_EXISTING, 0, (HANDLE)NULL);+  const int conin_fd = _open_osfhandle(conin_handle, _O_RDONLY);+  uv_tty_init(loop, &input->tty_in, conin_fd, true);","You're right, this doesn't work for headless mode and I'm not sure if there's a good way to avoid the duplication so I'll just change it back to the way it was.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/8280,181565120,2018-04-14T22:23:50Z,runtime/doc/autocmd.txt,"@@ -294,6 +294,8 @@ Name			triggered by ~ |SourceCmd|		before sourcing a Vim script |Cmd-event|  |VimResized|		after the Vim window size changed+|VimResumed|		after Vim is resumed+|VimSuspendPre|		before Vim is suspended","""pre"" implies a ""post"" dual, but there will never be a ""suspend post"".  we already discussed and decided the names in https://github.com/neovim/neovim/pull/5959 .Note also that the chosen names follow the exist VimEnter/VimLeave pattern, so that's why they are not past-tense.",
15214129,nimitbhardwaj,https://api.github.com/repos/neovim/neovim/pulls/8256,181572601,2018-04-15T07:09:46Z,test/functional/ui/inccommand_spec.lua,"@@ -1354,6 +1354,23 @@ describe(""inccommand=nosplit"", function()       :echo 'foo'^         |     ]])   end)++  it(""only executes the first command in preview"", function()+    feed(':%s/two/three/g|q!')+    eq(eval('v:null'), eval('v:exiting'))","Yeah sure I do it. though I assumed race was something related to race conditions like in multithreading. Didn't know its meaning, but having screen:expect was better as we can know the text was entered successfully",
12918431,geekodour,https://api.github.com/repos/neovim/neovim/pulls/8280,181581326,2018-04-15T12:35:49Z,src/nvim/ex_docmd.c,"@@ -6300,15 +6300,18 @@ static void ex_stop(exarg_T *eap)     if (!eap->forceit) {       autowrite_all();     }+    apply_autocmds(EVENT_VIMSUSPEND, NULL, NULL, FALSE, NULL);     ui_cursor_goto((int)Rows - 1, 0);     ui_linefeed();     ui_flush();     ui_call_suspend();  // call machine specific function+     ui_flush();     maketitle();     resettitle();  // force updating the title     redraw_later_clear();     ui_refresh();  // may have resized window+    apply_autocmds(EVENT_VIMRESUME, NULL, NULL, FALSE, NULL);","yes, I saw that. there are other `FALSE` in the same file it's not complaining about them, so I thought it was fine :disappointed: Is the rule for function parameters, i guess so.I'll make the lint changes. thanks a lot!",
15214129,nimitbhardwaj,https://api.github.com/repos/neovim/neovim/pulls/8283,181592261,2018-04-15T18:27:43Z,src/nvim/ex_docmd.c,"@@ -577,6 +577,14 @@ int do_cmdline(char_u *cmdline, LineGetter fgetline,         ++RedrawingDisabled;         did_inc = TRUE;       }+      if (State & CMDPREVIEW) {","I could also add the condition in the above if stmt to check for `CMDPREVIEW`, and remove the DOCMD_NOWAIT from the part where this function will be called, for the case of previewable",
15214129,nimitbhardwaj,https://api.github.com/repos/neovim/neovim/pulls/8283,181700076,2018-04-16T11:19:05Z,src/nvim/ex_docmd.c,"@@ -577,6 +577,14 @@ int do_cmdline(char_u *cmdline, LineGetter fgetline,         ++RedrawingDisabled;         did_inc = TRUE;       }+      if (State & CMDPREVIEW) {","I did this because, I thought that for the completion of the preview command, there is finally need of a return, as told on Gitter, it NOWAIT was for hiding the `Press Enter...` error message.Mostly this was I think work was of hit and trial, how I reached this, I had the idea that the code that will execute the Inccommand, so I tried to remove the DOCMD_NOWAIT it worked a little bit, but just give the notice `Press Return or another key ...`, so to remove this msg, I found the code what extra will happen if DOCMD_NOWAIT flag is given, I found out, and tried to hack code there, as described above using some common sense of the inccommands and a little bit about the functions which will be triggered by reading the comments, I had a lucky guess.",
15214129,nimitbhardwaj,https://api.github.com/repos/neovim/neovim/pulls/8283,182036299,2018-04-17T11:16:20Z,src/nvim/ex_getln.c,"@@ -1911,7 +1911,7 @@ static int command_line_changed(CommandLineState *s)     //       - Immediately undo the effects.     State |= CMDPREVIEW;     emsg_silent++;  // Block error reporting as the command may be incomplete-    do_cmdline(ccline.cmdbuff, NULL, NULL, DOCMD_KEEPLINE|DOCMD_NOWAIT);","I try to think of it as I reach room, now in class",
15214129,nimitbhardwaj,https://api.github.com/repos/neovim/neovim/pulls/8283,182062659,2018-04-17T13:00:40Z,src/nvim/ex_getln.c,"@@ -1911,7 +1911,7 @@ static int command_line_changed(CommandLineState *s)     //       - Immediately undo the effects.     State |= CMDPREVIEW;     emsg_silent++;  // Block error reporting as the command may be incomplete-    do_cmdline(ccline.cmdbuff, NULL, NULL, DOCMD_KEEPLINE|DOCMD_NOWAIT);","By keeping `DOCMD_NOWAIT`, it means that the if part in `ex_docmd.c` will not work, I want that the if part should work, but only `no_wait_return` should not be incremented, if I have to edit it, the condition in if will become so messy, and according to my personal opinion, I don't like to read a messy, complicated and big condition, so I put this like the way.Other alternative which I think that was good, was making a separate if condition for `State & CMDPREVIEW` but according to @justinmk its also not too better, so this option was left, which I thought was acceptable.What are the views on it?",
15214129,nimitbhardwaj,https://api.github.com/repos/neovim/neovim/pulls/8283,182189757,2018-04-17T18:54:34Z,src/nvim/ex_getln.c,"@@ -1911,7 +1911,7 @@ static int command_line_changed(CommandLineState *s)     //       - Immediately undo the effects.     State |= CMDPREVIEW;     emsg_silent++;  // Block error reporting as the command may be incomplete-    do_cmdline(ccline.cmdbuff, NULL, NULL, DOCMD_KEEPLINE|DOCMD_NOWAIT);","Okk, then its an issue, then making the condition edit is better.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/8076,182433094,2018-04-18T13:50:07Z,src/nvim/ex_getln.c,"@@ -214,6 +215,9 @@ static int hislen = 0;                  /* actual length of history tables */ /// user interrupting highlight function to not interrupt command-line. static bool getln_interrupted_highlight = false; +/// Pointer to flag which keeps track if mouse was used+static int *mouse_used_p = NULL;","I think we should avoid storing pointers globally if not necessary. Instead set the return value in `getcmdline_prompt` after `getcmdline`. Also place the value inside `ccline`, not globally. (if mouse support is conditional, an explicit bool variable is also better than a NULL check far from where the pointer is defined)",
8445768,coditva,https://api.github.com/repos/neovim/neovim/pulls/8076,182486107,2018-04-18T16:15:45Z,test/functional/ui/cmdline_spec.lua,"@@ -187,6 +187,36 @@ describe('external cmdline', function()    end) +  it(""works with inputlist()"", function()+    feed(':call inputlist([""input0"", ""input1""])<cr>')+    screen:expect([[+      {1:~                        }|+      {1:~                        }|+      input0                   |+      input1                   |+            ^                   |","After rebasing with master, if `msg_putchar('\n')` is not present after every list item, the list isn't displayed correctly. Should I revert?",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/8076,182656073,2018-04-19T07:34:30Z,src/nvim/misc1.c,"@@ -2408,34 +2412,37 @@ get_number (   if (msg_silent != 0)     return 0; +  cmd_silent = false;  // Want to see the prompt.+  cmdline_row = msg_row;++  select = getcmdline_prompt('#', prompt, 0, EXPAND_NOTHING, NULL,+                             input_callback, mouse_used);",can use CALLBACK_NONE in arg list and drop `input_callback`,
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/8076,182657381,2018-04-19T07:40:25Z,src/nvim/ex_getln.h,"@@ -36,6 +36,7 @@ typedef enum {   HIST_SEARCH,        ///< Search commands.   HIST_EXPR,          ///< Expressions (e.g. from entering = register).   HIST_INPUT,         ///< input() lines.+  HIST_INPUT_NUM,     ///< input() numbers.",inputlist,
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/6856,183106163,2018-04-20T16:36:30Z,runtime/doc/lsp.txt,"@@ -0,0 +1,265 @@+*lsp.txt* The Language Server Protocol++        NVIM REFERENCE MANUAL+++Neovim Language Server Protocol (LSP) API++Neovim exposes a powerful API that conforms to Microsoft's published Language+Server Protocol specification. The documentation can be found here:++    https://github.com/Microsoft/language-server-protocol++================================================================================+                                                                  *lsp-request*+Requests++To make a request of the language server client running in Nvim, the following+API is defined:+>+    :call lsp#request(method, arguments, callback, filetype)+    :call lsp#request_async(method, arguments, callback, filetype)+<++                                                                *lsp#request()*+lsp#request({method} [, {arguments} [, {callback} [, {filetype}]]])+    Creates and sends a request to the server for [filetype]. Will fill in any+    missing required arguments as defined by the language server protocol. Will+    call the default callback for the request (if it exists), unless an+    [callback] is specified, in which case that will be called upon completion+    of the request.++    Returns the request's response data.++        Parameters:~+            {method}: The name of the request, as specified by the+            language server protocol.+                Example: 'textDocument/hover'++            [arguments]: The arguments that should be passed to the language+            server. If any required keys are missing, Nvim will fill those in+            with reasonable default values.+                Example (with 'textDocument/hover'):+                    Passed in:+                        `{}` or |v:null|++                    Sent:+>+                        {+                            'textDocument': '/home/user/test/example.lua',+                            'position': { 'line': 13, 'character': 17 }+                        }+<+                Example (with 'textDocument/rename'):+                    Passed in:+>+                        {+                            'newName': 'exampleRename'+                        }+<+                    Sent:+>+                        {+                            'textDocument': '/home/user/test/rename.lua',+                            'position': { 'line': 16, 'character': 8 }+                            'newName': 'exampleRename'+                        }+<++            [callback]: An optional callback that will be executed+            once the response has been received. If this is passed and not+            |v:null|, then the |lsp-default-callback| will not be executed for+            this request. If this request does not have a+            |lsp-default-callback| and this parameter is not passed, then no+            callback will be executed upon receiving the request.++            The callback must be a string with the name of the vimscript+            function to call. The signature must be:++                `func_name({success}, {data})`++                where {success} is a boolean where true means successful request+                and false means the request failed.++                The parameter {data} is a dictionary containing the possible+                response data (or error) data as specified by the language+                server protocol.++                The callback will be executed from lua running:++                    `vim.api.nvim_call_function('func_name', { success, data })`++            [filetype]: The filetype associated with the server.+            This will default to the current |filetype| if nothing is passed.++            Configuration for the default server can be found at+            |lsp-configuration|.++                                                          *lsp#request_async()*+lsp#request_async({method} [, {arguments} [, {callback} [, {filetype}]]])+    Creates and sends a request to the server for [filetype]. This request+    will not block and will call desired the [callback] upon completion.++    Returns the request ID.++    See |lsp#request()| for more information.++================================================================================+                                                         *lsp-default-callback*++The following requests have built-in callbacks defined to handle the response+in an idiomatic vim fashion.++  textDocument/hover~+  textDocument/references~+  textDocument/definition~++================================================================================+                                                                 *lsp-autocmds*++The language server implementation in Neovim will fire |autocmd-User| events+upon each request and response so that users can attach to whenever these+events are triggered.++For the request 'textDocument/hover', the following autocmds will be fired:++    Before sending the request:+        'textDocument/hover/pre'++    After sending the request:+        'textDocument/hover/post'++    Before handling the response:+        'textDocument/hover/response'++================================================================================+                                                            *lsp-configuration*++                                                             *lsp#server#add()*+lsp#server#add({ftype}, {configuration}):+    Used to add a language server.++    This will add an autocmd that will start the server and handle any other+    startup activities whenever the |FileType| event is triggered for {ftype}.++    Parameters:~+        {ftype}: A string or list of strings of filetypes to associate with+        this server.++        {configuration} (dictionary): The command to be sent to start the server+            `name`        (string):   The name of the server+            `command`     (string):   The command to start the server+            `arguments`   (list):     Any arguments to pass to the server","Why not specify the args conistently with jobstart? So `command` can either be a string, or a list of executable+arguments, and separate `arguments` is not needed. This would make the code simplers as this can be passed unmodified to `jobstart()`",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/6856,183106639,2018-04-20T16:38:35Z,runtime/doc/lsp.txt,"@@ -0,0 +1,265 @@+*lsp.txt* The Language Server Protocol++        NVIM REFERENCE MANUAL+++Neovim Language Server Protocol (LSP) API++Neovim exposes a powerful API that conforms to Microsoft's published Language+Server Protocol specification. The documentation can be found here:++    https://github.com/Microsoft/language-server-protocol++================================================================================+                                                                  *lsp-request*+Requests++To make a request of the language server client running in Nvim, the following+API is defined:+>+    :call lsp#request(method, arguments, callback, filetype)+    :call lsp#request_async(method, arguments, callback, filetype)+<++                                                                *lsp#request()*+lsp#request({method} [, {arguments} [, {callback} [, {filetype}]]])",the existence of `lsp#request_async` seems to imply that this is synchronous. So the response data is _both_ passed to a callback _and_ returned by this function? That seems a bit confusing.,
12913701,mschilli87,https://api.github.com/repos/neovim/neovim/pulls/8323,184860220,2018-04-28T17:20:34Z,src/nvim/terminal.c,"@@ -405,6 +405,7 @@ void terminal_enter(void)   // erase the unfocused cursor   invalidate_terminal(s->term, s->term->cursor.row, s->term->cursor.row + 1);   showmode();+  win_redr_status(curwin);",Just let me clarify that I by no means imply that I can confirm this is the way to go. :wink:But I follow your reasoning and I think work-arounds are better than visible bugs as long as the underlying problem is still investigated eventually.,
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/8326,185186271,2018-05-01T08:40:24Z,src/nvim/lua/vim.lua,"@@ -118,11 +118,53 @@ local function _update_package_paths()   last_nvim_paths = cur_nvim_paths end +local function rpcrequest(...)+  return vim.api.nvim_call_function(""rpcrequest"", {...})+end++local function _cs_remote(rcid, args)++  f_tab = false+  f_silent = false+  f_wait = false++  -- extract the subcommand+  subcmd = string.sub(args[1],10):gsub('-',' ')++  if subcmd == 'tab' then+    f_tab = true+  elseif subcmd == 'silent' then+    f_silent = true+  elseif string.find(subcmd,'wait') ~= nil then+    f_wait = true+    for i in subcmd:gmatch(""%S+"") do+      if i == 'silent' then f_silent = true end+      if i == 'tab' then f_tab = true end+    end+  elseif subcmd == 'send' then+    keys = args[2]+    rpcrequest(rcid, 'vim_input', keys)+    return+  elseif subcmd == 'expr' then+    expr = args[2]+    res = rpcrequest(rcid, 'vim_eval', expr)+    return+  end++  table.remove(args,1)++  command = 'args '..table.concat(args, "" "")+  rpcrequest(rcid, 'vim_command', command)",`nvim_command` (similar for the others),
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/8326,185191322,2018-05-01T09:20:27Z,src/nvim/main.c,"@@ -259,6 +261,35 @@ int main(int argc, char **argv)   command_line_scan(&params);   server_init(params.listen_addr); +  if (params.cs_remote) {+    const char *env_addr = os_getenv(""NVIM_LISTEN_ADDRESS"");","But this purpose is _already_ there, the var was exposed to child procs for mainly this reason. I get that `$NVIM` will be potentially much better, but `NVIM_LISTEN_ADDRESS` is what already is used and should be used in the meanwhile. We should deprecate functionality at the time we actually have a replacement for it.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/8358,186190369,2018-05-04T19:23:19Z,test/functional/ui/screen_basic_spec.lua,"@@ -645,4 +645,43 @@ describe('Screen', function()       ]])     end)   end)++  -- Regression test for #8357+  it('does not have artifacts', function()",This is not very descriptive. The relevant functionality is displaying and hiding a temporary char in insert mode (nothing else is using `screen_getbytes`).,
972014,mhinz,https://api.github.com/repos/neovim/neovim/pulls/8358,186193689,2018-05-04T19:30:30Z,test/functional/ui/screen_basic_spec.lua,"@@ -645,4 +645,43 @@ describe('Screen', function()       ]])     end)   end)++  -- Regression test for #8357+  it('does not have artifacts', function()","I don't like it myself, but I can't come up with a better one that isn't too long. I'm open for suggestions.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/8358,186203321,2018-05-04T20:05:17Z,test/functional/ui/screen_basic_spec.lua,"@@ -645,4 +645,43 @@ describe('Screen', function()       ]])     end)   end)++  -- Regression test for #8357+  it('does not have artifacts', function()","""does not have artifacts after temporary chars in insert mode"" doesn't sound to long to me.",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/6263,186244953,2018-05-05T00:00:06Z,src/nvim/normal.c,"@@ -2116,12 +2109,24 @@ static void op_function(oparg_T *oap)     // function.     virtual_op = MAYBE; -    (void)call_func_retnr(p_opfunc, 1, argv, false);+    (void)call_func_retnr(func, 1, argv, false);      virtual_op = save_virtual_op;   } } +// Handle the ""g@"" operator: call 'operatorfunc'.+static void op_function(oparg_T *oap)+{+  call_function(""E774: 'operatorfunc' is empty"", p_opfunc, oap);+}++// Handle the ""g?"" operator: call 'encodefunc'.+static void enc_function(oparg_T *oap)+{+  call_function(""E774: 'encodefunc' is empty"", p_encfunc, oap);","Even if you are not translating right here you must mark message for translation with `N_`. This is needed to automatically create a list of messages to translate.Though I would not suggest to go with E774 and two error messages where you can go with E774 and one error message: it is not like option name needs to be translated so you can have `emsgf(_(""E774: '%s' is empty""), option_name)` rather then `EMSG(_(msg))`. (Do *not* use `EMSG2()`, ever since `emsgf()` was introduced it has no purpose.)",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/6856,186258118,2018-05-05T09:57:19Z,runtime/lua/lsp/client.lua,"@@ -157,16 +157,23 @@ client.request_async = function(self, method, params, cb)     return nil   end +  local callback_list   if cb == nil then-    cb = get_callback_function(method)+    callback_list = get_callback_function(method)+  elseif type(cb) == 'table' then","callbacks sometimes being a list is a bit messy, better then to always make it a list. ",
4466899,tjdevries,https://api.github.com/repos/neovim/neovim/pulls/6856,186265304,2018-05-05T15:42:50Z,runtime/lua/lsp/client.lua,"@@ -157,16 +157,23 @@ client.request_async = function(self, method, params, cb)     return nil   end +  local callback_list   if cb == nil then-    cb = get_callback_function(method)+    callback_list = get_callback_function(method)+  elseif type(cb) == 'table' then","They'll always be a list after this call. get_callback_function should changed to get_list_of_callback_functions.Just wanted people to be able to specify a callback with a function reference directly, rather than in a table",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/6856,186265611,2018-05-05T15:56:29Z,runtime/lua/lsp/client.lua,"@@ -157,16 +157,23 @@ client.request_async = function(self, method, params, cb)     return nil   end +  local callback_list   if cb == nil then-    cb = get_callback_function(method)+    callback_list = get_callback_function(method)+  elseif type(cb) == 'table' then","> Just wanted people to be able to specify a callback with a function reference directly, rather than in a table.This doesn't contradict what I said. `add_callback` can represent it as a list either way. At no point do we need to store the union between a callback and a list of callbacks internally.",
4466899,tjdevries,https://api.github.com/repos/neovim/neovim/pulls/6856,186267283,2018-05-05T17:11:42Z,runtime/lua/lsp/client.lua,"@@ -157,16 +157,23 @@ client.request_async = function(self, method, params, cb)     return nil   end +  local callback_list   if cb == nil then-    cb = get_callback_function(method)+    callback_list = get_callback_function(method)+  elseif type(cb) == 'table' then","(I also noticed that I don't pass callback_list correctly yet, so it's still WIP :) )",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/6856,186268654,2018-05-05T18:14:52Z,runtime/lua/lsp/client.lua,"@@ -157,16 +157,23 @@ client.request_async = function(self, method, params, cb)     return nil   end +  local callback_list   if cb == nil then-    cb = get_callback_function(method)+    callback_list = get_callback_function(method)+  elseif type(cb) == 'table' then","Sorry, it seems I placed this comment on silghtly the wrong line, indeed `request_async` should  accept a single callback, but then _only_ a single callback. The point is than any value should either be a single callback or a list of callbacks, never the union of the two.",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/6263,186274743,2018-05-05T23:26:45Z,src/nvim/normal.c,"@@ -2086,15 +2089,13 @@ static void op_colon(oparg_T *oap)    */ } -/*- * Handle the ""g@"" operator: call 'operatorfunc'.- */-static void op_function(oparg_T *oap)+// Implements functionality of 'operatorfunc' and 'encodefunc'.+static void call_function(const char *option_name, char_u *func, oparg_T *oap) {   int save_virtual_op = virtual_op; -  if (*p_opfunc == NUL)-    EMSG(_(""E774: 'operatorfunc' is empty""));+  if (*func == NUL)",You need to run clint: every time you change some line style errors are no longer ignore in it and surrounding lines so missing figure braces here will cause CI failure.,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/8371,186311357,2018-05-07T01:29:33Z,src/nvim/message.c,"@@ -504,6 +505,9 @@ int emsg(const char_u *s_)     if (cause_errthrow((char_u *)s, severe, &ignore) == true) {       if (!ignore) {         did_emsg = true;+        if (msg_first_ignored_err == NULL) {+          msg_first_ignored_err = xstrdup(s);+        }","This is ugly, ~~but there's no way around it that I could find.~~ `call_func()` does not treat _non-exception, abort-triggering_ `emsg()` errors the same way as `do_cmdline_cmd()`.**Update:** we can get the desired behavior by using the `msg_list = &private_msg_list` pattern from `do_cmdline()`.  Then `cause_errthrow()` will capture the error in the `msg_list`, and `try_end()` will notice it.",
10180857,nhooyr,https://api.github.com/repos/neovim/neovim/pulls/8372,186690881,2018-05-08T11:05:45Z,runtime/autoload/man.vim,"@@ -213,7 +213,11 @@ endfunction  function! s:get_path(sect, name) abort   if empty(a:sect)-    return s:system(['man', s:find_arg, a:name])+    "" Some man implementations (OpenBSD) return all available man paths+    "" from the search command, so we split here to make sure we only+    "" take the first one.  Discovered and reported in+    "" https://github.com/neovim/neovim/issues/8341+    return split(s:system(['man', s:find_arg, a:name]))[0]",You'll need to remove the slice here that takes out the newline: https://github.com/jbernard/neovim/blob/a5dcfa1b7e07069ca5bcd0e9840adaa0e4138353/runtime/autoload/man.vim#L22you'll also need to trim the newline in the second branch of `s:get_path`: https://github.com/jbernard/neovim/blob/a5dcfa1b7e07069ca5bcd0e9840adaa0e4138353/runtime/autoload/man.vim#L227,
4117685,KillTheMule,https://api.github.com/repos/neovim/neovim/pulls/7917,187288084,2018-05-10T09:56:15Z,runtime/doc/msgpack_rpc.txt,"@@ -241,4 +241,152 @@ Even for statically compiled clients it is good practice to avoid hardcoding the type codes, because a client may be built against one Nvim version but connect to another with different type codes. +==============================================================================+6. Buffer Updates				                *buffer-updates* *rpc-buffer-updates*++A dedicated API has been created to allow co-processes to be notified  when a+buffer is changed in any way. It is difficult and error-prone to try and do+this with autocommands such as |TextChanged|.++                                                           *buffer-updates-events*+BufferUpdates Events~++The co-process will start receiving the following notification events:++nvim_buf_updates_start[{buf}, {changedtick}, {linedata}, {more}]	 *nvim_buf_updates_start*++  Nvim will send at least one of these notifications to confirm that buffer+  updates are registered for this plugin, and possibly send the buffer's+  contents. If the buffer is very large, nvim might send the contents+  through in multiple events to avoid loading the entire buffer's contents+  into memory at once.++	{buf} is an API handle for the buffer.++	{changedtick} is the value of |b:changedtick| for the buffer. If you+	send an API command back to nvim you can check the value of+	|b:changedtick| as part of your request to ensure that no other+	changes have been made. ++  {linedata} is a list of strings containing the buffer's contents. If this+  list contains 100 strings, then they represent lines 1-100 of the buffer.+  Newline characters are not included in the strings, so empty lines will be+  given as empty strings. If you receive another |nvim_buf_updates_start|+  notification with another {linedata} list, then these lines represent the+  next N lines of the buffer. I.e., a second notification with another list of+  100 strings will represent lines 101-200 of the buffer. If you send the+  |nvim_buf_updates_start| request with its argument set to `""False""`, this+  will be empty.++  {linedata} will always have at least 1 item, but the maximum length is+  determined by nvim and not guaranteed to be any particular size.  Also the+  number of {linedata} items may vary between notifications, so your plugin+  must be prepared to receive the line data in whatever size lists nvim+  decides to split it into.++  {more} is a boolean which tells you whether or not to expect more+  |nvim_buf_updates_start| notifications. When {more} is false, you can be certain+  that you now have the entire buffer's contents.","Not needed. I agree it would be nicer to just send `nvim_buf_update` for everything, and have the `{more}` parameter also for non-initial updates, even if we don't use it yet. #workingonit",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/7917,187303101,2018-05-10T11:15:54Z,runtime/doc/msgpack_rpc.txt,"@@ -241,4 +241,152 @@ Even for statically compiled clients it is good practice to avoid hardcoding the type codes, because a client may be built against one Nvim version but connect to another with different type codes. +==============================================================================+6. Buffer Updates				                *buffer-updates* *rpc-buffer-updates*++A dedicated API has been created to allow co-processes to be notified  when a+buffer is changed in any way. It is difficult and error-prone to try and do+this with autocommands such as |TextChanged|.++                                                           *buffer-updates-events*+BufferUpdates Events~++The co-process will start receiving the following notification events:++nvim_buf_updates_start[{buf}, {changedtick}, {linedata}, {more}]	 *nvim_buf_updates_start*++  Nvim will send at least one of these notifications to confirm that buffer+  updates are registered for this plugin, and possibly send the buffer's+  contents. If the buffer is very large, nvim might send the contents+  through in multiple events to avoid loading the entire buffer's contents+  into memory at once.++	{buf} is an API handle for the buffer.++	{changedtick} is the value of |b:changedtick| for the buffer. If you+	send an API command back to nvim you can check the value of+	|b:changedtick| as part of your request to ensure that no other+	changes have been made. ++  {linedata} is a list of strings containing the buffer's contents. If this+  list contains 100 strings, then they represent lines 1-100 of the buffer.+  Newline characters are not included in the strings, so empty lines will be+  given as empty strings. If you receive another |nvim_buf_updates_start|+  notification with another {linedata} list, then these lines represent the+  next N lines of the buffer. I.e., a second notification with another list of+  100 strings will represent lines 101-200 of the buffer. If you send the+  |nvim_buf_updates_start| request with its argument set to `""False""`, this+  will be empty.++  {linedata} will always have at least 1 item, but the maximum length is+  determined by nvim and not guaranteed to be any particular size.  Also the+  number of {linedata} items may vary between notifications, so your plugin+  must be prepared to receive the line data in whatever size lists nvim+  decides to split it into.++  {more} is a boolean which tells you whether or not to expect more+  |nvim_buf_updates_start| notifications. When {more} is false, you can be certain+  that you now have the entire buffer's contents.","@KillTheMule fair point, but clients already would have to handle `nvim_buf_updates_start` as a special case.The semantics of `-1` are well established by e.g `nvim_buf_{get,set}_lines`. ",
4117685,KillTheMule,https://api.github.com/repos/neovim/neovim/pulls/7917,187316479,2018-05-10T12:33:55Z,runtime/doc/msgpack_rpc.txt,"@@ -241,4 +241,152 @@ Even for statically compiled clients it is good practice to avoid hardcoding the type codes, because a client may be built against one Nvim version but connect to another with different type codes. +==============================================================================+6. Buffer Updates				                *buffer-updates* *rpc-buffer-updates*++A dedicated API has been created to allow co-processes to be notified  when a+buffer is changed in any way. It is difficult and error-prone to try and do+this with autocommands such as |TextChanged|.++                                                           *buffer-updates-events*+BufferUpdates Events~++The co-process will start receiving the following notification events:++nvim_buf_updates_start[{buf}, {changedtick}, {linedata}, {more}]	 *nvim_buf_updates_start*++  Nvim will send at least one of these notifications to confirm that buffer+  updates are registered for this plugin, and possibly send the buffer's+  contents. If the buffer is very large, nvim might send the contents+  through in multiple events to avoid loading the entire buffer's contents+  into memory at once.++	{buf} is an API handle for the buffer.++	{changedtick} is the value of |b:changedtick| for the buffer. If you+	send an API command back to nvim you can check the value of+	|b:changedtick| as part of your request to ensure that no other+	changes have been made. ++  {linedata} is a list of strings containing the buffer's contents. If this+  list contains 100 strings, then they represent lines 1-100 of the buffer.+  Newline characters are not included in the strings, so empty lines will be+  given as empty strings. If you receive another |nvim_buf_updates_start|+  notification with another {linedata} list, then these lines represent the+  next N lines of the buffer. I.e., a second notification with another list of+  100 strings will represent lines 101-200 of the buffer. If you send the+  |nvim_buf_updates_start| request with its argument set to `""False""`, this+  will be empty.++  {linedata} will always have at least 1 item, but the maximum length is+  determined by nvim and not guaranteed to be any particular size.  Also the+  number of {linedata} items may vary between notifications, so your plugin+  must be prepared to receive the line data in whatever size lists nvim+  decides to split it into.++  {more} is a boolean which tells you whether or not to expect more+  |nvim_buf_updates_start| notifications. When {more} is false, you can be certain+  that you now have the entire buffer's contents.","Actually, do we need a `{more}` parameter? You always need to expect ~spanish~ buffer updates. So if you request the buffer's content, and get something that's not the whole buffer, the next update will get you up-to-date, the line numbers will tell you specifics.Right?That of course means that we can't use `-1` for the initial send (at least if it's not the whole buffer), but I don't think that's really needed for anything.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/7917,187319039,2018-05-10T12:46:03Z,runtime/doc/msgpack_rpc.txt,"@@ -241,4 +241,152 @@ Even for statically compiled clients it is good practice to avoid hardcoding the type codes, because a client may be built against one Nvim version but connect to another with different type codes. +==============================================================================+6. Buffer Updates				                *buffer-updates* *rpc-buffer-updates*++A dedicated API has been created to allow co-processes to be notified  when a+buffer is changed in any way. It is difficult and error-prone to try and do+this with autocommands such as |TextChanged|.++                                                           *buffer-updates-events*+BufferUpdates Events~++The co-process will start receiving the following notification events:++nvim_buf_updates_start[{buf}, {changedtick}, {linedata}, {more}]	 *nvim_buf_updates_start*++  Nvim will send at least one of these notifications to confirm that buffer+  updates are registered for this plugin, and possibly send the buffer's+  contents. If the buffer is very large, nvim might send the contents+  through in multiple events to avoid loading the entire buffer's contents+  into memory at once.++	{buf} is an API handle for the buffer.++	{changedtick} is the value of |b:changedtick| for the buffer. If you+	send an API command back to nvim you can check the value of+	|b:changedtick| as part of your request to ensure that no other+	changes have been made. ++  {linedata} is a list of strings containing the buffer's contents. If this+  list contains 100 strings, then they represent lines 1-100 of the buffer.+  Newline characters are not included in the strings, so empty lines will be+  given as empty strings. If you receive another |nvim_buf_updates_start|+  notification with another {linedata} list, then these lines represent the+  next N lines of the buffer. I.e., a second notification with another list of+  100 strings will represent lines 101-200 of the buffer. If you send the+  |nvim_buf_updates_start| request with its argument set to `""False""`, this+  will be empty.++  {linedata} will always have at least 1 item, but the maximum length is+  determined by nvim and not guaranteed to be any particular size.  Also the+  number of {linedata} items may vary between notifications, so your plugin+  must be prepared to receive the line data in whatever size lists nvim+  decides to split it into.++  {more} is a boolean which tells you whether or not to expect more+  |nvim_buf_updates_start| notifications. When {more} is false, you can be certain+  that you now have the entire buffer's contents.","> That of course means that we can't use -1 for the initial send (at least if it's not the whole buffer), but I don't think that's really needed for anything.I don't think that follows. The first send still starts from an unknown state, but the following (even if they help build the ""true"" initial state) builds from the incomplete but concrete client state.But I still think we want to somehow separate ""real"" buffer states, from ones invented for transport technical reasons. How about setting changedtick to `-1` in the cases that would have `more`, if we want to avoid this flag? Because these do not correspond to any real buffer state, while true buffer states are identified by their changedtick.",
4117685,KillTheMule,https://api.github.com/repos/neovim/neovim/pulls/7917,187320542,2018-05-10T12:52:58Z,runtime/doc/msgpack_rpc.txt,"@@ -241,4 +241,152 @@ Even for statically compiled clients it is good practice to avoid hardcoding the type codes, because a client may be built against one Nvim version but connect to another with different type codes. +==============================================================================+6. Buffer Updates				                *buffer-updates* *rpc-buffer-updates*++A dedicated API has been created to allow co-processes to be notified  when a+buffer is changed in any way. It is difficult and error-prone to try and do+this with autocommands such as |TextChanged|.++                                                           *buffer-updates-events*+BufferUpdates Events~++The co-process will start receiving the following notification events:++nvim_buf_updates_start[{buf}, {changedtick}, {linedata}, {more}]	 *nvim_buf_updates_start*++  Nvim will send at least one of these notifications to confirm that buffer+  updates are registered for this plugin, and possibly send the buffer's+  contents. If the buffer is very large, nvim might send the contents+  through in multiple events to avoid loading the entire buffer's contents+  into memory at once.++	{buf} is an API handle for the buffer.++	{changedtick} is the value of |b:changedtick| for the buffer. If you+	send an API command back to nvim you can check the value of+	|b:changedtick| as part of your request to ensure that no other+	changes have been made. ++  {linedata} is a list of strings containing the buffer's contents. If this+  list contains 100 strings, then they represent lines 1-100 of the buffer.+  Newline characters are not included in the strings, so empty lines will be+  given as empty strings. If you receive another |nvim_buf_updates_start|+  notification with another {linedata} list, then these lines represent the+  next N lines of the buffer. I.e., a second notification with another list of+  100 strings will represent lines 101-200 of the buffer. If you send the+  |nvim_buf_updates_start| request with its argument set to `""False""`, this+  will be empty.++  {linedata} will always have at least 1 item, but the maximum length is+  determined by nvim and not guaranteed to be any particular size.  Also the+  number of {linedata} items may vary between notifications, so your plugin+  must be prepared to receive the line data in whatever size lists nvim+  decides to split it into.++  {more} is a boolean which tells you whether or not to expect more+  |nvim_buf_updates_start| notifications. When {more} is false, you can be certain+  that you now have the entire buffer's contents.","As in ""Updates with changedtick=-1 are initial ones that are not complete"" and ""Updates with changedtick > -1 are either the last of initial ones or real ones""?I don't like ""misusing"" another parameter like that. In that case I'd rather keep `more` and have it mean ""expect more updates for the same changedtick"".> But I still think we want to somehow separate ""real"" buffer states, from ones invented for transport technical reasons.Any specific reason for that? One can identify those because the changedtick stays the same, if need be, but I don't really see why that would be neccessary.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/7917,187324870,2018-05-10T13:11:50Z,runtime/doc/msgpack_rpc.txt,"@@ -241,4 +241,152 @@ Even for statically compiled clients it is good practice to avoid hardcoding the type codes, because a client may be built against one Nvim version but connect to another with different type codes. +==============================================================================+6. Buffer Updates				                *buffer-updates* *rpc-buffer-updates*++A dedicated API has been created to allow co-processes to be notified  when a+buffer is changed in any way. It is difficult and error-prone to try and do+this with autocommands such as |TextChanged|.++                                                           *buffer-updates-events*+BufferUpdates Events~++The co-process will start receiving the following notification events:++nvim_buf_updates_start[{buf}, {changedtick}, {linedata}, {more}]	 *nvim_buf_updates_start*++  Nvim will send at least one of these notifications to confirm that buffer+  updates are registered for this plugin, and possibly send the buffer's+  contents. If the buffer is very large, nvim might send the contents+  through in multiple events to avoid loading the entire buffer's contents+  into memory at once.++	{buf} is an API handle for the buffer.++	{changedtick} is the value of |b:changedtick| for the buffer. If you+	send an API command back to nvim you can check the value of+	|b:changedtick| as part of your request to ensure that no other+	changes have been made. ++  {linedata} is a list of strings containing the buffer's contents. If this+  list contains 100 strings, then they represent lines 1-100 of the buffer.+  Newline characters are not included in the strings, so empty lines will be+  given as empty strings. If you receive another |nvim_buf_updates_start|+  notification with another {linedata} list, then these lines represent the+  next N lines of the buffer. I.e., a second notification with another list of+  100 strings will represent lines 101-200 of the buffer. If you send the+  |nvim_buf_updates_start| request with its argument set to `""False""`, this+  will be empty.++  {linedata} will always have at least 1 item, but the maximum length is+  determined by nvim and not guaranteed to be any particular size.  Also the+  number of {linedata} items may vary between notifications, so your plugin+  must be prepared to receive the line data in whatever size lists nvim+  decides to split it into.++  {more} is a boolean which tells you whether or not to expect more+  |nvim_buf_updates_start| notifications. When {more} is false, you can be certain+  that you now have the entire buffer's contents.",">  One can identify those because the changedtick stays the same, if need be, but I don't really see why that would be neccessary.No you cannot, as you when you receive one event don't yet know if more events will come with the same changetick. But if separate `more` flag (which I imagined would be usable _beyond_ the initial send, for similarly large updates) is preferred, let's use that :)",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/7917,187325644,2018-05-10T13:15:10Z,runtime/doc/msgpack_rpc.txt,"@@ -241,4 +241,152 @@ Even for statically compiled clients it is good practice to avoid hardcoding the type codes, because a client may be built against one Nvim version but connect to another with different type codes. +==============================================================================+6. Buffer Updates				                *buffer-updates* *rpc-buffer-updates*++A dedicated API has been created to allow co-processes to be notified  when a+buffer is changed in any way. It is difficult and error-prone to try and do+this with autocommands such as |TextChanged|.++                                                           *buffer-updates-events*+BufferUpdates Events~++The co-process will start receiving the following notification events:++nvim_buf_updates_start[{buf}, {changedtick}, {linedata}, {more}]	 *nvim_buf_updates_start*++  Nvim will send at least one of these notifications to confirm that buffer+  updates are registered for this plugin, and possibly send the buffer's+  contents. If the buffer is very large, nvim might send the contents+  through in multiple events to avoid loading the entire buffer's contents+  into memory at once.++	{buf} is an API handle for the buffer.++	{changedtick} is the value of |b:changedtick| for the buffer. If you+	send an API command back to nvim you can check the value of+	|b:changedtick| as part of your request to ensure that no other+	changes have been made. ++  {linedata} is a list of strings containing the buffer's contents. If this+  list contains 100 strings, then they represent lines 1-100 of the buffer.+  Newline characters are not included in the strings, so empty lines will be+  given as empty strings. If you receive another |nvim_buf_updates_start|+  notification with another {linedata} list, then these lines represent the+  next N lines of the buffer. I.e., a second notification with another list of+  100 strings will represent lines 101-200 of the buffer. If you send the+  |nvim_buf_updates_start| request with its argument set to `""False""`, this+  will be empty.++  {linedata} will always have at least 1 item, but the maximum length is+  determined by nvim and not guaranteed to be any particular size.  Also the+  number of {linedata} items may vary between notifications, so your plugin+  must be prepared to receive the line data in whatever size lists nvim+  decides to split it into.++  {more} is a boolean which tells you whether or not to expect more+  |nvim_buf_updates_start| notifications. When {more} is false, you can be certain+  that you now have the entire buffer's contents.","> which I imagined would be usable beyond the initial send, for similarly large updatesThat's what I was thinking, seems like `more` ties in with the ""chunking"" discussion near the top of this PR.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/7917,188236670,2018-05-15T10:21:22Z,runtime/doc/msgpack_rpc.txt,"@@ -241,4 +241,124 @@ Even for statically compiled clients it is good practice to avoid hardcoding the type codes, because a client may be built against one Nvim version but connect to another with different type codes. +==============================================================================+6. Buffer Updates				   *buffer-updates* *rpc-buffer-updates*++A dedicated API has been created to allow co-processes to be notified  when a+buffer is changed in any way. It is difficult and error-prone to try and do+this with autocommands such as |TextChanged|.++                                                           *buffer-updates-events*+BufferUpdates Events~++The co-process will start receiving the following notification events:++                                                                   *nvim_buf_lines_event*+nvim_buf_lines_event[{buf}, {changedtick}, {firstline}, {lastline}, {linedata}, {more}]++  Indicates that the lines between {firstline} and {lastline} (end-exclusive,+  zero-indexed) have been replaced with the new line data contained in the+  {linedata} list.  All buffer changes (even adding single characters) will be+  transmitted as whole-line changes.++    {buf} is an API handle for the buffer.++    {changedtick} is the value of |b:changedtick| for the buffer. If you send an+    API command back to nvim you can check the value of |b:changedtick| as+    part of your request to ensure that no other changes have been made.++    {firstline} is the integer line number of the first line that was replaced.+    Note that {firstline} is zero-indexed, so if line `1` was replaced then+    {firstline} will be `0` instead of `1`. {firstline} is guaranteed to always+    be less than or equal to the number of lines that were in the buffer before+    the lines were replaced.++    {lastline} is the integer line number of the first line that was not replaced+    (i.e. the range {firstline}, {lastline} is end-exclusive). Note that+    {lastline} is zero-indexed, so if line numbers 2 to 5 were replaced, this+    will be `5` instead of `6`. {lastline} is guaranteed to always be less than+    or equal to the number of lines that were in the buffer before the lines were+    replaced. {lastline} will be `-1` if the event is part of the initial+    sending of the buffer.++    {linedata} is a list of strings containing the contents of the new buffer+    lines. Newline characters are not included in the strings, so empty lines+    will be given as empty strings. ++    {more} is a boolean which tells you whether or not to expect more+    |nvim_buf_updates| notifications for a single buffer change (i.e. Nvim has+    chunked up one event into several). Not yet used.++  Note: sometimes {changedtick} will be |v:null|, which means that the buffer+  text *looks* like it has changed, but actually hasn't. In this case the lines+  in {linedata} contain the modified text that is shown to the user, but+  doesn't reflect the actual buffer contents. Currently this behaviour is+  only used for the |inccommand| option.++nvim_buf_changedtick_event[{buf}, {changedtick}]	 *nvim_buf_changedtick*++  Indicates that |b:changedtick| was incremented for the buffer {buf}, but no+  text was changed. This is currently only used by undo/redo.++    {buf} is an API handle for the buffer.++    {changedtick} is the new value of |b:changedtick| for that buffer.++nvim_buf_updates_end[{buf}]                                    		*nvim_buf_updates_end*","It's an event, so it needs the `_event` suffix in its name. I suggest renaming it to `nvim_buf_detach_event`.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/8331,188851842,2018-05-17T06:39:17Z,src/nvim/tag.c,"@@ -2407,8 +2407,10 @@ jumpto_tag (   /* If it was a CTRL-W CTRL-] command split window now.  For "":tab tag""    * open a new tab page. */   if (postponed_split || cmdmod.tab != 0) {-    win_split(postponed_split > 0 ? postponed_split : 0,-        postponed_split_flags);+    if (win_split(postponed_split > 0 ? postponed_split : 0,+                  postponed_split_flags) == FAIL) {+      WLOG(_(""Error splitting window""));","Inspecting the implementation of win_split() shows that it does `EMSG` for all failure cases, so we don't need to log it here.Easiest thing to do here is ignore the return value (otherwise we need to do some cleanup and might require some refactoring.  jumpto_tag() can deal with a failed split, so it's no big deal.    (void)win_split(...);",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/8377,189430128,2018-05-19T09:35:08Z,test/functional/viml/completion_spec.lua,"@@ -971,4 +974,91 @@ describe('ui/ext_popupmenu', function()       eq(nil, items) -- popupmenu was hidden     end)   end)++  describe('TextChangeP autocommand', function()+    it('can trigger TextChangedP autocommand as expected',+    function()+      curbufmeths.set_lines(0, 1, false, { 'foo', 'bar', 'foobar'})+      command('set complete=. completeopt=menuone')+      command('let g:foo = []')+      command('autocmd! TextChanged * :call add(g:foo, ""N"")')+      command('autocmd! TextChangedI * :call add(g:foo, ""I"")')+      command('autocmd! TextChangedP * :call add(g:foo, ""P"")')+      command('call cursor(3, 1)')++      command('let g:foo = []')","Just for future reference: it's usually best to keep the test similar to the old one, if possible. E.g. use `g:autocmd` instead of `g:foo` for the variable name.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/8405,189533418,2018-05-21T09:05:29Z,test/functional/legacy/011_autocommands_spec.lua,"@@ -61,7 +62,7 @@ describe('file reading, writing and bufnew and filter autocommands', function()    if not has_gzip() then     pending('skipped (missing `gzip` utility)', function() end)-  else+  elseif not iswin() then",instead change the condition on line 62 to:    if iswin() or not has_gzip() then,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/8405,189536136,2018-05-21T09:16:49Z,ci/build.ps1,"@@ -35,61 +43,83 @@ if ($compiler -eq 'MINGW') {     $nvimCmakeVars['USE_GCOV'] = 'ON'     $uploadToCodecov = $true   }+   # These are native MinGW builds, but they use the toolchain inside   # MSYS2, this allows using all the dependencies and tools available   # in MSYS2, but we cannot build inside the MSYS2 shell.   $cmakeGenerator = 'MinGW Makefiles'-  $cmakeGeneratorArgs = 'VERBOSE=1'--  # Add MinGW to the PATH-  $env:PATH = ""C:\msys64\mingw$bits\bin;$env:PATH""+  $cmakeGeneratorArgs = @('VERBOSE=1')+  $env:CC = 'gcc'++  @{+    CMAKE_SH = 'CMAKE_SH-NOTFOUND'+    CMAKE_MAKE_PROGRAM = ""C:/msys64/mingw$bits/bin/mingw32-make.exe""+  }.GetEnumerator() | ForEach-Object {+    $nvimCmakeVars[$_.Key] = $_.Value+    $depsCmakeVars[$_.Key] = $_.Value+    $cmakeGeneratorArgs += $_.Key + '=' + $_.Value+  }    # Build third-party dependencies   C:\msys64\usr\bin\bash -lc ""pacman --verbose --noconfirm -Su"" ; exitIfFailed-  C:\msys64\usr\bin\bash -lc ""pacman --verbose --noconfirm --needed -S mingw-w64-$arch-cmake mingw-w64-$arch-perl mingw-w64-$arch-diffutils mingw-w64-$arch-unibilium"" ; exitIfFailed+  C:\msys64\usr\bin\bash -lc ""pacman --verbose --noconfirm --needed -S mingw-w64-$arch-gcc mingw-w64-$arch-make mingw-w64-$arch-cmake mingw-w64-$arch-perl mingw-w64-$arch-diffutils mingw-w64-$arch-unibilium"" ; exitIfFailed } elseif ($compiler -eq 'MSVC') {   $cmakeGeneratorArgs = '/verbosity:normal'-  if ($bits -eq 32) {-    $cmakeGenerator = 'Visual Studio 15 2017'-  }-  elseif ($bits -eq 64) {-    $cmakeGenerator = 'Visual Studio 15 2017 Win64'+  $cmakeGenerator = 'Visual Studio 15 2017'+  if ($bits -eq 64) {+    $cmakeGenerator += ' Win64'   } } -# Remove Git Unix utilities from the PATH-$env:PATH = $env:PATH.Replace('C:\Program Files\Git\usr\bin', '')- # Setup python (use AppVeyor system python)-C:\Python27\python.exe -m pip install neovim ; exitIfFailed-C:\Python35\python.exe -m pip install neovim ; exitIfFailed-# Disambiguate python3-move c:\Python35\python.exe c:\Python35\python3.exe-$env:PATH = ""C:\Python35;C:\Python27;$env:PATH""-# Sanity check-python  -c ""import neovim; print(str(neovim))"" ; exitIfFailed-python3 -c ""import neovim; print(str(neovim))"" ; exitIfFailed--$env:PATH = ""C:\Ruby24\bin;$env:PATH""-cmd /c gem.cmd install neovim ; exitIfFailed-where.exe neovim-ruby-host.bat ; exitIfFailed--cmd /c npm.cmd install -g neovim ; exitIfFailed-where.exe neovim-node-host.cmd ; exitIfFailed+# Perform sanity checks after installation+if (Test-Path -PathType Container C:\Python27) {+  $env:PATH = ""C:\Python27;$env:PATH""+}+if (where.exe python.exe 2> $null) {+  python.exe  -m pip install neovim ; exitIfFailed","the ""Disambiguate python3"" step should be done before calling python. Otherwise it might work by accident, but that is too subtle, better to be explicit.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/8405,189715979,2018-05-21T21:13:31Z,test/functional/ex_cmds/wviminfo_spec.lua,"@@ -36,7 +37,8 @@ describe(':wshada', function()     write_file(shada_file, text)      -- sanity check-    eq(text, io.open(shada_file):read())+    local fp0 = io.open(shada_file)+    eq(text, fp0:read())","@janlazo good thought, but this was accidental. It can be changed to:    eq(text, read_file(shada_file))",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/7783,191044148,2018-05-26T09:17:34Z,runtime/doc/starting.txt,"@@ -349,11 +347,21 @@ argument. 							*--api-info* --api-info 	Print msgpack-encoded |api-metadata| and exit. +							*--embed*+--embed		Use stdin/stdout as a msgpack-RPC channel.  This makes it easy+		for applications to embed and control Nvim via the |rpc-api|.+                Implies |--headless|.  Equivalent to: >+			nvim --headless --cmd ""call stdioopen({'rpc': v:true})""+<+                See also |channel-stdio|.+ 							*--headless*---headless 	Do not start the built-in UI.-                See |channel-stdio| for how to use stdio for other purposes-                instead.-		See also |silent-mode|, which does start a (limited) UI.+--headless 	Do not start the built-in UI.  Allows stdio to be used as+                a communication channel. |channel-stdio| To detect this state","My old comment was marked as outdated but is still not resolved: `nvim_list_uis()` does not reliably detect `--headless` (""this state""). It's better to say what it actually detects: ""To detect in a script whether an UI is available""",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/8434,191044207,2018-05-26T09:22:07Z,cmake/FindLibUV.cmake,"@@ -31,11 +31,7 @@ if(LIBUV_USE_STATIC)     ""${CMAKE_STATIC_LIBRARY_PREFIX}uv${CMAKE_STATIC_LIBRARY_SUFFIX}"") endif(LIBUV_USE_STATIC) -if(MSVC)-  list(APPEND LIBUV_NAMES libuv)-else()-  list(APPEND LIBUV_NAMES uv)-endif()+list(APPEND LIBUV_NAMES uv)","this was added long ago by @equalsraf 73db02b99c07d933a2bbbb9d4a29022699b436ab . I'm happy if it can be simplified, but @erw7 could you say why it's not needed anymore?",
11682285,erw7,https://api.github.com/repos/neovim/neovim/pulls/8434,191067564,2018-05-27T07:33:02Z,cmake/FindLibUV.cmake,"@@ -31,11 +31,7 @@ if(LIBUV_USE_STATIC)     ""${CMAKE_STATIC_LIBRARY_PREFIX}uv${CMAKE_STATIC_LIBRARY_SUFFIX}"") endif(LIBUV_USE_STATIC) -if(MSVC)-  list(APPEND LIBUV_NAMES libuv)-else()-  list(APPEND LIBUV_NAMES uv)-endif()+list(APPEND LIBUV_NAMES uv)","@justinmk I am doing `add_library (uv ..)` [here](https://github.com/neovim/neovim/pull/8434/files#diff-ca30aab4c551663b547e390f3d169775R7). `CMAKE_SHARED_LIBRARY_PREFIX` is empty in MSVC, so I think that this is no longer necessary. I think this setting is due to that we was using MinGW libuv on MSVC, because at that time MSVC could not build libuv.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/8434,191083123,2018-05-27T17:30:30Z,third-party/CMakeLists.txt,"@@ -81,6 +81,15 @@ if(CMAKE_GENERATOR MATCHES ""Makefiles"")   set(MAKE_PRG ""$(MAKE)"") endif() +if(MINGW AND CMAKE_GENERATOR MATCHES ""Ninja"")+  find_program(MAKE_PRG NAMES mingw32-make)+  if(NOT MAKE_PRG)+    message(FATAL_ERROR ""GNU Make for mingw32 is required to build the dependecies."")+  else()+    message(STATUS ""Found GNU Make for mingw32 at ${MAKE_PRG}"")+  endif()+endif()","~~so mingw32-make is required even when building with MSVC? Does the [wiki](https://github.com/neovim/neovim/wiki/Building-Neovim#windows--msvc) instructions need to mention this?~~Edit: never mind, I missed the `if(MINGW` condition.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/8453,192325878,2018-06-01T08:14:35Z,test/functional/ui/wildmode_spec.lua,"@@ -31,6 +31,21 @@ describe(""'wildmenu'"", function()     ]])   end) +  it(':sign <tab> <space> hides wildmenu, selects design, when laststatus=2 #8453', function()","what does ""selects design"" mean? Can just be:    it(':sign <tab> <space> hides wildmenu #8453', function()",
11901959,akarle,https://api.github.com/repos/neovim/neovim/pulls/8453,192403852,2018-06-01T13:56:30Z,test/functional/ui/wildmode_spec.lua,"@@ -31,6 +31,21 @@ describe(""'wildmenu'"", function()     ]])   end) +  it(':sign <tab> <space> hides wildmenu, selects design, when laststatus=2 #8453', function()",Ok! I'll change it--it was originally there because pressing the `<space>` selects the first option from the wildmenu ('design').I agree though--a bit long and confusing for a test name.,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/8453,192464514,2018-06-01T17:33:12Z,test/functional/ui/wildmode_spec.lua,"@@ -31,6 +31,21 @@ describe(""'wildmenu'"", function()     ]])   end) +  it(':sign <tab> <space> hides wildmenu #8453', function()+    command('set wildmode=full')+    -- only a regression if status-line open+    command('set laststatus=2')+    command('set wildmenu')+    feed(':sign <tab> ')+    screen:expect([[+                               |+      ~                        |+      ~                        |+      [No Name]                |+      :sign define ^            |+    ]])","To add more rigor to the test, let's add an extra `screen:expect()` before the `<space>` is input:```lua     feed(':sign <tab>')     screen:expect([[                                |       ~                        |       ~                        |       define  jump  list  >    |       :sign define^             |     ]])     feed('<space>')     screen:expect([[                                |       ~                        |       ~                        |       [No Name]                |       :sign define ^            |     ]])```After that LGTM! I tested the patch locally and didn't find any new regressions.",
112971,jamessan,https://api.github.com/repos/neovim/neovim/pulls/8464,192556865,2018-06-02T10:57:51Z,CMakeLists.txt,"@@ -406,24 +409,22 @@ else()   option(ENABLE_JEMALLOC ""enable jemalloc"" ON) endif() -if (ENABLE_JEMALLOC)+if(ENABLE_JEMALLOC)   if(CLANG_ASAN_UBSAN OR CLANG_MSAN OR CLANG_TSAN)     message(STATUS ""Sanitizers have been enabled; don't use jemalloc."")   else()-    find_package(JeMalloc)-    if(JEMALLOC_FOUND)-      include_directories(SYSTEM ${JEMALLOC_INCLUDE_DIRS})-    endif()+    find_package(JeMalloc REQUIRED)+    include_directories(SYSTEM ${JEMALLOC_INCLUDE_DIRS})   endif() endif() -find_package(LibIntl)-if(LibIntl_FOUND)+if(ENABLE_LIBINTL)+  find_package(Intl REQUIRED)",Upstream's is `FindIntl`:```[jamessan@freya] 0 % dpkg -S FindLibIntldpkg-query: no path found matching pattern *FindLibIntl*[jamessan@freya] 1 % dpkg -S FindIntlcmake-data: /usr/share/cmake-3.11/Modules/FindIntl.cmakecmake-data: /usr/share/cmake-3.11/Help/module/FindIntl.rst```Is there a reason we don't use that or build our own on top of that?,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/8489,193591018,2018-06-06T23:39:49Z,src/nvim/msgpack_rpc/channel.c,"@@ -312,24 +312,29 @@ static void handle_request(Channel *channel, msgpack_object *request)     api_clear_error(&error);     return;   }+   // Retrieve the request handler   MsgpackRpcRequestHandler handler;+  Array args = ARRAY_DICT_INIT;   msgpack_object *method = msgpack_rpc_method(request);    if (method) {     handler = msgpack_rpc_get_handler_for(method->via.bin.ptr,                                           method->via.bin.size);+    if (handler.fn == msgpack_rpc_handle_missing_method) {+      String m = method->via.bin.size > 0+        ? cbuf_to_string(method->via.bin.ptr, method->via.bin.size)+        : cstr_to_string(""<empty>"");+      ADD(args, STRING_OBJ(m));","I don't see a nice way to pass along the error to `on_request_event()`. Letting the fake `msgpack_rpc_handle_missing_method` do it is more consistent with how errors are usually set.Adding a field for this means adding cleanup code to free the variable, at least.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/8489,193684488,2018-06-07T09:34:10Z,src/nvim/msgpack_rpc/channel.c,"@@ -312,24 +312,29 @@ static void handle_request(Channel *channel, msgpack_object *request)     api_clear_error(&error);     return;   }+   // Retrieve the request handler   MsgpackRpcRequestHandler handler;+  Array args = ARRAY_DICT_INIT;   msgpack_object *method = msgpack_rpc_method(request);    if (method) {     handler = msgpack_rpc_get_handler_for(method->via.bin.ptr,                                           method->via.bin.size);+    if (handler.fn == msgpack_rpc_handle_missing_method) {+      String m = method->via.bin.size > 0+        ? cbuf_to_string(method->via.bin.ptr, method->via.bin.size)+        : cstr_to_string(""<empty>"");+      ADD(args, STRING_OBJ(m));","> It's not really contradictory, we can define the args for msgpack_rpc_handle_missing_method however we like.But of course it is contradictory: for _all other_ handlers, `args` is the _unvalided_ list of argument as passed by the user, and it is up to the _handler_ to validade the lenght of this array and extract arguments of compatible types if possible. Now this is very suddenly is used as a side-channel, where `handle_request` places an array with _already_  _validated_ type, for a value that has absolutely nothing to do with the common purpose of this array. > And the cost of that is lower than the cost of spending more time on thisI find this argument quite disturbing. Merging spaghetti code implementation is suddenly a good thing, just because someone chose to spend time to do that instead of a proper implementation (Adding _named_ and _typed_ struct field and C func arg to pass known info from point A to B, not exactly anything controversial or complicated) ? How does this lead to maintainable code? ",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/8489,193688628,2018-06-07T09:49:10Z,src/nvim/msgpack_rpc/channel.c,"@@ -312,24 +312,29 @@ static void handle_request(Channel *channel, msgpack_object *request)     api_clear_error(&error);     return;   }+   // Retrieve the request handler   MsgpackRpcRequestHandler handler;+  Array args = ARRAY_DICT_INIT;   msgpack_object *method = msgpack_rpc_method(request);    if (method) {     handler = msgpack_rpc_get_handler_for(method->via.bin.ptr,                                           method->via.bin.size);+    if (handler.fn == msgpack_rpc_handle_missing_method) {+      String m = method->via.bin.size > 0+        ? cbuf_to_string(method->via.bin.ptr, method->via.bin.size)+        : cstr_to_string(""<empty>"");+      ADD(args, STRING_OBJ(m));",Also if the _cost_ of spaghetti code is indeed _lower_ than the cost of improving the code then absolutely it makes no sense to do the thing that's higher cost. Whether I estimated the cost correctly is a different question.,
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/8489,193695804,2018-06-07T10:16:54Z,src/nvim/msgpack_rpc/channel.c,"@@ -312,24 +312,29 @@ static void handle_request(Channel *channel, msgpack_object *request)     api_clear_error(&error);     return;   }+   // Retrieve the request handler   MsgpackRpcRequestHandler handler;+  Array args = ARRAY_DICT_INIT;   msgpack_object *method = msgpack_rpc_method(request);    if (method) {     handler = msgpack_rpc_get_handler_for(method->via.bin.ptr,                                           method->via.bin.size);+    if (handler.fn == msgpack_rpc_handle_missing_method) {+      String m = method->via.bin.size > 0+        ? cbuf_to_string(method->via.bin.ptr, method->via.bin.size)+        : cstr_to_string(""<empty>"");+      ADD(args, STRING_OBJ(m));","> Also if the cost of spaghetti code is indeed lower than the cost of improving the code then absolutely it makes no sense to do the thing that's higher cost. Whether I estimated the cost correctly is a different question.This could be and indeed has been true in some cases, especially if the proper solution includes changes to event ordering or large changes of code structure, (but even then I would make sure to add a TODO comment, to make it clear it is a short-cut and not a pattern other code should intentionally reuse, and it should be changed next time this subsystem is refactored) I just disagree strongly for this specific kind of change :) Adding a new named field/parameter to an internal struct/function is not something that is supposed be seen as ""high cost"", _especially_ if the alternative is to reuse a variable that previously had a single clear purpose (unvalidated args as passed by channel), which now will lose this clarity. (rather one must now always check all code surrounding this variable to see if any special case applies)",
8740057,janlazo,https://api.github.com/repos/neovim/neovim/pulls/8405,193714310,2018-06-07T11:33:53Z,ci/build.ps1,"@@ -35,95 +45,131 @@ if ($compiler -eq 'MINGW') {     $nvimCmakeVars['USE_GCOV'] = 'ON'     $uploadToCodecov = $true   }+   # These are native MinGW builds, but they use the toolchain inside   # MSYS2, this allows using all the dependencies and tools available   # in MSYS2, but we cannot build inside the MSYS2 shell.   $cmakeGenerator = 'MinGW Makefiles'-  $cmakeGeneratorArgs = 'VERBOSE=1' -  # Add MinGW to the PATH-  $env:PATH = ""C:\msys64\mingw$bits\bin;$env:PATH""+  if ($cmakeGenerator -eq 'Ninja') {+    $cmakeGeneratorArgs = @('-v')+  }+  elseif ($cmakeGenerator -eq 'MinGW Makefiles') {+    $env:CC = 'cc'+    $cmakeGeneratorArgs = @('VERBOSE=1')+    @{+      CMAKE_SH = 'CMAKE_SH-NOTFOUND'+      CMAKE_MAKE_PROGRAM = ""C:/msys64/mingw$bits/bin/mingw32-make.exe""+    }.GetEnumerator() | ForEach-Object {+      $nvimCmakeVars[$_.Key] = $_.Value+      $depsCmakeVars[$_.Key] = $_.Value+      $cmakeGeneratorArgs += $_.Key + '=' + $_.Value+    }+  }    # Build third-party dependencies+  $mingwPackages = @('gcc', 'make', 'cmake', 'perl', 'diffutils', 'unibilium').ForEach({+    @('mingw', 'w64', $arch, $_) -join '-'","No. I was testing the pattern so I can conveniently add gcc, make, ninja. I prefer joining arrays than `'mingw-w64-' + $arch + '-' + $_` and all packages had the same naming pattern.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/7783,194272098,2018-06-10T22:13:31Z,runtime/doc/vim_diff.txt,"@@ -134,49 +145,34 @@ Options:   'tabline' %@Func@foo%X can call any function on mouse-click   'winhighlight' window-local highlights -Variables:-  |v:event|-  |v:exiting|-  |v:progpath| is always absolute (""full"")-  |v:windowid| is always available (for use by external UIs)--Commands:-  |:checkhealth|-  |:drop| is available on all platforms-  |:Man| is available by default, with many improvements such as completion-  |:tchdir| tab-local |current-directory|--Functions:-  |dictwatcheradd()| notifies a callback whenever a |Dict| is modified-  |dictwatcherdel()|-  |menu_get()|-  |msgpackdump()|, |msgpackparse()| provide msgpack de/serialization- Events:   |DirChanged|   |TabNewEntered|   |TermClose|   |TermOpen|   |TextYankPost|","`v:event` is still relevant, this list is intended to point the user to things that are different, not exhaustively list the precise intersection of how each thing differs (would be too much prose). `v:event` in Nvim still covers many more events (and will continue to expand) vs Vim.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/8455,194335964,2018-06-11T09:06:26Z,src/nvim/ui.c,"@@ -448,3 +448,15 @@ Array ui_array(void)   }   return all_uis; }++void ui_grid_resize(GridHandle grid_handle, int width, int height)+{+  ScreenGrid *grid = get_grid_by_handle(grid_handle);+  if (grid == NULL) {+    //TODO(utkarshme): error out+    abort();+    return;+  }+  grid_alloc(grid, height, width, true);","We need to trigger a redraw also. If the grid belongs to a window, can use `redraw_win_later` (probably SOME_VALID, but not sure).Actually we probably shouldn't reallocate here, redraw will always reallocate (and call `grid_resize` back)  if necessary anyway. Instead we shoud store the intended size so that futher redraws will respect it (and not overwrite it with the ""outer"" size), maybe in `internal_Rows`.",
63876,ahmedelgabri,https://api.github.com/repos/neovim/neovim/pulls/8528,194563600,2018-06-11T22:10:54Z,runtime/autoload/provider/node.vim,"@@ -41,14 +41,20 @@ function! provider#node#Detect() abort   if exists('g:node_host_prog')     return g:node_host_prog   endif-  let global_modules = get(split(system('npm root -g'), ""\n""), 0, '')-  if v:shell_error || !isdirectory(global_modules)+  let npm_global_modules = get(split(system('npm root -g'), ""\n""), 0, '')+  "" `yarn global dir` returns the root directory of the global modules+  let yarn_global_modules = get(split(system('yarn global dir'), ""\n""), 0, '') . '/node_modules'+  let is_node_modules_dir = isdirectory(npm_global_modules) || isdirectory(yarn_global_modules)+  if v:shell_error || !is_node_modules_dir     return ''","> is there not a more generic way in nodejs-land to check if a freakin' module is available? There are numerous package managers ...I don't think so or I'm not aware of any universal solution for this. But also the main package managers (covers 99%) are `npm` & `yarn`What if I do it like this instead? any drawbacks or issues?```diffdiff --git a/runtime/autoload/provider/node.vim b/runtime/autoload/provider/node.vimindex 7d4d5698a..8b8b0f901 100644--- a/runtime/autoload/provider/node.vim+++ b/runtime/autoload/provider/node.vim@@ -22,6 +22,14 @@ function! s:is_minimum_version(version, min_major, min_minor) abort     \         && str2nr(v_list[1]) >= str2nr(a:min_minor))) endfunction +function! s:get_node_client_entry(global_modules_path, cli_bin) abort+  let entry_path = glob(a:global_modules_path . a:cli_bin)+  if v:shell_error || !isdirectory(a:global_modules_path) || empty(entry_path)+    return ''+  endif+  return entry_path+endfunction+ "" Support for --inspect-brk requires node 6.12+ or 7.6+ or 8+ "" Return 1 if it is supported "" Return 0 otherwise@@ -41,20 +49,13 @@ function! provider#node#Detect() abort   if exists('g:node_host_prog')     return g:node_host_prog   endif-  let npm_global_modules = get(split(system('npm root -g'), ""\n""), 0, '')-  "" `yarn global dir` returns the root directory of the global modules-  let yarn_global_modules = get(split(system('yarn global dir'), ""\n""), 0, '') . '/node_modules'-  let is_node_modules_dir = isdirectory(npm_global_modules) || isdirectory(yarn_global_modules)-  if v:shell_error || !is_node_modules_dir-    return ''-  endif   if !s:is_minimum_version(v:null, 6, 0)     return ''   endif   let cli_bin = '/neovim/bin/cli.js'-  let entry_point = empty(glob(npm_global_modules . cli_bin))-        \ ? glob(yarn_global_modules . cli_bin)-        \ : glob(npm_global_modules . cli_bin)+  let entry_point = s:get_node_client_entry(get(split(system('npm root -g'), ""\n""), 0, ''), cli_bin)+        "" `yarn global dir` returns the root directory of the global modules+        \ || s:get_node_client_entry(get(split(system('yarn global dir'), ""\n""), 0, '') . '/node_modules', cli_bin)   if !filereadable(entry_point)     return ''   endif```",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/8528,194661839,2018-06-12T08:55:03Z,runtime/autoload/health/provider.vim,"@@ -502,10 +502,10 @@ function! s:check_node() abort     return   endif -  if !executable('node') || !executable('npm')+  if !executable('node') || !executable('npm') || !executable('yarn')","with this condition, checkhealth will warn if yarn isn't installed, even if npm is. how about:    if !executable('node') || (!executable('npm') && !executable('yarn'))",
63876,ahmedelgabri,https://api.github.com/repos/neovim/neovim/pulls/8528,194831341,2018-06-12T17:49:34Z,runtime/autoload/provider/node.vim,"@@ -41,17 +57,11 @@ function! provider#node#Detect() abort   if exists('g:node_host_prog')     return g:node_host_prog   endif-  let global_modules = get(split(system('npm root -g'), ""\n""), 0, '')-  if v:shell_error || !isdirectory(global_modules)-    return ''-  endif   if !s:is_minimum_version(v:null, 6, 0)     return ''   endif-  let entry_point = glob(global_modules . '/neovim/bin/cli.js')-  if !filereadable(entry_point)-    return ''-  endif+  let entry_point = s:get_node_client_entry('npm root -g')+  let entry_point = !empty(entry_point) ? entry_point : s:get_node_client_entry('yarn global dir')","@janlazo what do you think?```diffdiff --git a/runtime/autoload/provider/node.vim b/runtime/autoload/provider/node.vimindex 2e22e7b46..437fa6645 100644--- a/runtime/autoload/provider/node.vim+++ b/runtime/autoload/provider/node.vim@@ -22,12 +22,16 @@ function! s:is_minimum_version(version, min_major, min_minor) abort     \         && str2nr(v_list[1]) >= str2nr(a:min_minor))) endfunction -function! s:get_node_client_entry(cmd) abort+function! s:get_node_client_entry(package_manager) abort+  if !executable(a:package_manager)+    return ''+  endif   let cli_bin = '/neovim/bin/cli.js'   "" `yarn global dir` returns the root directory of the global modules   "" so we need to append the `/node_modules` part-  let yarn_extra_path = a:cmd ==# 'yarn global dir' ? '/node_modules' : ''-  let global_modules_dir = get(split(system(a:cmd), ""\n""), 0, '') . yarn_extra_path+  let yarn_extra_path = a:package_manager ==# 'yarn' ? '/node_modules' : ''+  let cmd =  a:package_manager ==# 'yarn' ? a:package_manager . ' global dir' : a:package_manager . ' root -g'+  let global_modules_dir = get(split(system(cmd), ""\n""), 0, '') . yarn_extra_path   if v:shell_error || !isdirectory(global_modules_dir)     return ''   endif@@ -60,8 +64,8 @@ function! provider#node#Detect() abort   if !s:is_minimum_version(v:null, 6, 0)     return ''   endif-  let entry_point = s:get_node_client_entry('npm root -g')-  let entry_point = !empty(entry_point) ? entry_point : s:get_node_client_entry('yarn global dir')+  let entry_point = s:get_node_client_entry('npm')+  let entry_point = !empty(entry_point) ? entry_point : s:get_node_client_entry('yarn')   return entry_point endfunction```",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/8570,195909049,2018-06-16T18:17:18Z,src/nvim/generators/gen_events.lua,"@@ -25,25 +25,22 @@ static const struct event_name { } event_names[] = {]])  for i, event in ipairs(events) do-  if i > 1 then-    comma = ',\n'-  else-    comma = '\n'+  enum_tgt:write(('\n  EVENT_%s = %u,'):format(event:upper(), i - 1))+  names_tgt:write(('\n  {%u, ""%s"", EVENT_%s},'):format(#event, event, event:upper()))+  if i == #events then  -- Last item.+    enum_tgt:write(('\n  NUM_EVENTS = %u,'):format(i))",This value should not be part of the same enum as the list of events. It is semantically incorrect and if enum is ever used for `switch()` it would force either useless `case NUM_EVENTS: assert(false);` or harmful `default:`. If you need `NUM_EVENTS` for unit tests it should be a separate anonymous `enum { NUM_EVENTS = N };`.,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/8570,195910683,2018-06-16T19:44:30Z,src/nvim/generators/gen_events.lua,"@@ -25,25 +25,22 @@ static const struct event_name { } event_names[] = {]])  for i, event in ipairs(events) do-  if i > 1 then-    comma = ',\n'-  else-    comma = '\n'+  enum_tgt:write(('\n  EVENT_%s = %u,'):format(event:upper(), i - 1))+  names_tgt:write(('\n  {%u, ""%s"", EVENT_%s},'):format(#event, event, event:upper()))+  if i == #events then  -- Last item.+    enum_tgt:write(('\n  NUM_EVENTS = %u,'):format(i))","@ZyX-I Thanks for checking. This was to eliminate PVS warnings:    fileio.c:7293   Medium  V547    Expression is always true.    fileio.c:7351   Medium  V547    Expression 'event == 100' is always false.https://github.com/neovim/doc/commit/eaddb57d6bf346da4cb53e08c478bdd3ed0f333e`event_name2nr` returns `event_T`, so (I guess) PVS infers that nothing outside ofthat range could possibly be returned.Should we just ignore the warnings using `-V547` ? Or you have another idea?> It is semantically incorrectWe use a similar pattern in other cases, e.g. `UIExtension`.",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/8570,195911484,2018-06-16T20:30:10Z,src/nvim/generators/gen_events.lua,"@@ -25,25 +25,22 @@ static const struct event_name { } event_names[] = {]])  for i, event in ipairs(events) do-  if i > 1 then-    comma = ',\n'-  else-    comma = '\n'+  enum_tgt:write(('\n  EVENT_%s = %u,'):format(event:upper(), i - 1))+  names_tgt:write(('\n  {%u, ""%s"", EVENT_%s},'):format(#event, event, event:upper()))+  if i == #events then  -- Last item.+    enum_tgt:write(('\n  NUM_EVENTS = %u,'):format(i))","`event_name2nr` should not return `NUM_EVENTS`. What happens there semantically is why a bunch of enums have things like VAR_UNKNOWN (i.e. values which state that item is uninitialized or invalid) and these all are *zero* for the sake of initialization sequences like using `memset(, 0,)` yielding something relatively safe. So it makes sense to have NUM_EVENTS still outside of enum, but make `event_name2nr` return new `EVENT_INVALID` instead which ideally should be zero (though given that `event_T` is used as an index it is easier to place at the end of enum).Though I am wondering why compiler allows NUM_EVENTS there and does not even give a warning.About UIExtension: it is still not correct semantically to use for invalid values, but it is a separate case: UIExtension is *written* enum, not generated one. You do not have length available through some compiler builtin like `enumitems(EnumType)` and there is no list to query length like `#events`. I remember moving length out of enum somewhere, but it was ugly `#define ���LEN ((size_t)LAST_ITEM+1)` with a warning to change the define at the end of the corresponding enum and AFAIR is either gone or in one of the non-merged branches (like lua to viml translator).",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/8615,197269572,2018-06-21T20:38:36Z,src/nvim/testdir/test_startup.vim,"@@ -251,3 +251,16 @@ func Test_silent_ex_mode()   let out = system(GetVimCommand() . '-u NONE -es -c''set verbose=1|h|exe ""%norm\<c-y>\<c-d>""'' -c cq')   call assert_notmatch('E315:', out) endfunc++func Test_default_term()","```vim"" Nvim 'term' is readonly.return```Let's return early here instead of skipping (AKA `throw ""skipped: ...""`), because this behavior is ""wontfix"". (Probably other ""skipped"" legacy tests should return early instead of showing up in the ""skipped"" list, for a similar reason.)",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/8621,197348922,2018-06-22T06:10:25Z,src/nvim/eval.c,"@@ -17685,6 +17685,15 @@ static void f_writefile(typval_T *argvars, typval_T *rettv, FunPtr fptr)     EMSG2(_(e_listarg), ""writefile()"");     return;   }+  const list_T *const list = argvars[0].vval.v_list;+  if (list == NULL) {+    return;+  }","This change seems to contradict the existing test `NULL list is accepted as an empty list by writefile()`. I think we can leave this out, because we don't consider it an error. cc @ZyX-I ",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/8621,197363884,2018-06-22T07:41:39Z,src/nvim/eval.c,"@@ -17685,6 +17685,15 @@ static void f_writefile(typval_T *argvars, typval_T *rettv, FunPtr fptr)     EMSG2(_(e_listarg), ""writefile()"");     return;   }+  const list_T *const list = argvars[0].vval.v_list;+  if (list == NULL) {+    return;+  }","NULL list should still create a file, it is incorrect to exit here.",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/8621,197364235,2018-06-22T07:43:09Z,src/nvim/eval.c,"@@ -17685,6 +17685,15 @@ static void f_writefile(typval_T *argvars, typval_T *rettv, FunPtr fptr)     EMSG2(_(e_listarg), ""writefile()"");     return;   }+  const list_T *const list = argvars[0].vval.v_list;+  if (list == NULL) {+    return;+  }+  TV_LIST_ITER_CONST(list, li, {+    if (tv_get_string_chk(TV_LIST_ITEM_TV(li)) == NULL) {","There is `tv_check_str_or_nr()` function now, it should be used here in place of `tv_get_string_chk()` which will do useless job of formatting number.",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/8621,197364503,2018-06-22T07:44:28Z,src/nvim/eval.c,"@@ -17685,6 +17685,15 @@ static void f_writefile(typval_T *argvars, typval_T *rettv, FunPtr fptr)     EMSG2(_(e_listarg), ""writefile()"");     return;   }+  const list_T *const list = argvars[0].vval.v_list;+  if (list == NULL) {+    return;+  }+  TV_LIST_ITER_CONST(list, li, {","TV_LIST_ITER_CONST is perfectly fine with a NULL list. Won���t execute a cycle body even once obviously, but still fine.",
8740057,janlazo,https://api.github.com/repos/neovim/neovim/pulls/8624,197435257,2018-06-22T12:49:59Z,src/nvim/testdir/test_options.vim,"@@ -339,3 +339,55 @@ func Test_copy_winopt()   call assert_equal(4,&numberwidth)   bw! endfunc++func Test_copy_winopt()",My bad. I didn't check this file when I ran vim-patch.sh. I'll mark this patch N/A.,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/8621,197632832,2018-06-24T08:54:20Z,test/functional/eval/writefile_spec.lua,"@@ -129,21 +129,21 @@ describe('writefile()', function()    it('stops writing to file after error in list', function()     local args = '[""tset""] + repeat([%s], 3), ""' .. fname .. '""'-    eq('\nE806: using Float as a String',+    eq('\nE805: Expected a Number or a String, Float found',         redir_exec(('call writefile(%s)'):format(args:format('0.0'))))-    eq('tset\n', read_file(fname))+    eq(nil, read_file(fname))     write_file(fname, 'TEST')-    eq('\nE730: using List as a String',+    eq('\nE745: Expected a Number or a String, List found',         redir_exec(('call writefile(%s)'):format(args:format('[]'))))-    eq('tset\n', read_file(fname))+    eq('TEST', read_file(fname))","It seems that this test group `it('stops writing to file after error in list'` isn't really being tested meaningfully anymore. Because the write doesn't begin at all. Maybe just change the test description, for now:    it('does not write to file if error in list', function()cc @ZyX-I ",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/8616,197649358,2018-06-24T18:54:13Z,test/functional/api/buffer_updates_spec.lua,"@@ -741,3 +742,87 @@ describe('API: buffer events:', function()   end)  end)++describe('API: buffer events:', function()+  before_each(function()+    helpers.clear()+  end)++  local function lines_subset(first, second)+    for i = 1,#first do+      if first[i] ~= second[i] then+        return false+      end+    end+    return true+  end++  local function lines_equal(f, s)+    return lines_subset(f, s) and lines_subset(s, f)+  end++  local function did_match_somewhere(buffer_lines, expected_lines)+    local msg = next_msg()++    while(msg ~= nil) do+      local event = msg[2]+      if event == ""nvim_buf_lines_event"" then+        local args = msg[3]+        local starts = args[3]+        local newlines = args[5]++        -- Size of the contained neovim instance is 23 lines, this might change+        -- with the test setup. Note updates are continguous.+        assert(#newlines <= 23)++        for i = 1,#newlines do+          buffer_lines[starts + i] = newlines[i]+        end+        -- we don't compare the msg area of the embedded nvim, it's too flakey+        buffer_lines[23] = nil++        if lines_equal(buffer_lines, expected_lines) then+          return true+        end+      end+      msg = next_msg()+    end+    return false","should `assert(false)` here, with a brief semantic message.    assert(false, 'did not match expected lines')I don't see any place where the return value of `did_match_somewhere` is actually checked.",
4117685,KillTheMule,https://api.github.com/repos/neovim/neovim/pulls/8616,197649790,2018-06-24T19:09:27Z,test/functional/api/buffer_updates_spec.lua,"@@ -741,3 +742,87 @@ describe('API: buffer events:', function()   end)  end)++describe('API: buffer events:', function()+  before_each(function()+    helpers.clear()+  end)++  local function lines_subset(first, second)+    for i = 1,#first do+      if first[i] ~= second[i] then+        return false+      end+    end+    return true+  end++  local function lines_equal(f, s)+    return lines_subset(f, s) and lines_subset(s, f)+  end++  local function did_match_somewhere(buffer_lines, expected_lines)+    local msg = next_msg()++    while(msg ~= nil) do+      local event = msg[2]+      if event == ""nvim_buf_lines_event"" then+        local args = msg[3]+        local starts = args[3]+        local newlines = args[5]++        -- Size of the contained neovim instance is 23 lines, this might change+        -- with the test setup. Note updates are continguous.+        assert(#newlines <= 23)++        for i = 1,#newlines do+          buffer_lines[starts + i] = newlines[i]+        end+        -- we don't compare the msg area of the embedded nvim, it's too flakey+        buffer_lines[23] = nil++        if lines_equal(buffer_lines, expected_lines) then+          return true+        end+      end+      msg = next_msg()+    end+    return false+  end++  it('terminal with a nested nvim instance', function()+    local buffer_lines = {}","No I meant `buffer_lines`. It's only updated in `did_match_somewhere`, not always fully set. What would happen if the `nvim_buf_lines_event` only contains 2 lines? We couldn't compare `expected_lines` then, because those contain the full expected buffer. We could of course shrink down `expected_lines` for that comparison, but than we'd be back a step in that we're looking for a `nvim_buf_lines_event` containing some specific event data, which I had problem with (probably due to screen refreshes that weren't fully deterministic between OSes).",
112971,jamessan,https://api.github.com/repos/neovim/neovim/pulls/8641,197803603,2018-06-25T13:52:03Z,src/nvim/os/env.c,"@@ -223,6 +223,13 @@ void init_homedir(void) #endif     homedir = xstrdup(var);   }+  else {+    char IObuff_signed[MAXPATHL] = """";+    if (uv_os_homedir(IObuff_signed, (size_t *)MAXPATHL)) {","`MAXPATHL` can't be passed in here.  As noted in the docs for `uv_os_homedir()`, it will change the passed in value to report how large the string actually is:> On success size is set to the string length of buffer. On UV_ENOBUFS failure size is set to the required length for buffer, including the null byte.A local variable should be used instead.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/8638,198024980,2018-06-26T06:22:52Z,third-party/cmake/BuildLuarocks.cmake,"@@ -202,7 +202,7 @@ if(USE_BUNDLED_BUSTED)   # DEPENDS on the previous module, because Luarocks breaks if parallel.   add_custom_command(OUTPUT ${HOSTDEPS_LIB_DIR}/luarocks/rocks/nvim-client     COMMAND ${LUAROCKS_BINARY}-    ARGS build nvim-client 0.1.0-1 ${LUAROCKS_BUILDARGS}+    ARGS build nvim-client-0.1.0-1.rockspec --branch=always-dump-corrupted-data ${LUAROCKS_BUILDARGS}",can point to the URL directly. try this:    ARGS build https://raw.githubusercontent.com/phodge/lua-client/0.1.0-1/nvim-client-0.1.0-1.rockspec --branch=always-dump-corrupted-data ${LUAROCKS_BUILDARGS}Then you don't need to copy `nvim-client-0.1.0-1.rockspec` to this repo.,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/8638,198026294,2018-06-26T06:29:48Z,third-party/cmake/BuildLuarocks.cmake,"@@ -202,7 +202,7 @@ if(USE_BUNDLED_BUSTED)   # DEPENDS on the previous module, because Luarocks breaks if parallel.   add_custom_command(OUTPUT ${HOSTDEPS_LIB_DIR}/luarocks/rocks/nvim-client     COMMAND ${LUAROCKS_BINARY}-    ARGS build nvim-client 0.1.0-1 ${LUAROCKS_BUILDARGS}+    ARGS build nvim-client-0.1.0-1.rockspec --branch=always-dump-corrupted-data ${LUAROCKS_BUILDARGS}","might need to change this line in your lua-client fork: https://github.com/phodge/lua-client/blob/always-dump-corrupted-data/nvim-client-0.1.0-1.rockspec#L4    url = 'https://github.com/phodge/lua-client/archive/' .. version .. '.tar.gz',",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/8638,198034084,2018-06-26T07:06:55Z,third-party/cmake/BuildLuarocks.cmake,"@@ -202,7 +202,7 @@ if(USE_BUNDLED_BUSTED)   # DEPENDS on the previous module, because Luarocks breaks if parallel.   add_custom_command(OUTPUT ${HOSTDEPS_LIB_DIR}/luarocks/rocks/nvim-client     COMMAND ${LUAROCKS_BINARY}-    ARGS build nvim-client 0.1.0-1 ${LUAROCKS_BUILDARGS}+    ARGS build https://raw.githubusercontent.com/phodge/lua-client/0.1.0-1/nvim-client-0.1.0-1.rockspec --branch=always-dump-corrupted-data ${LUAROCKS_BUILDARGS}",sorry! The URL should be:    https://raw.githubusercontent.com/phodge/lua-client/always-dump-corrupted-data/nvim-client-0.1.0-1.rockspecsince the `0.1.0-1` tag isn't relevant here.,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/8639,198570285,2018-06-27T17:04:30Z,src/nvim/eval/typval.c,"@@ -1544,6 +1554,16 @@ bool tv_dict_get_callback(dict_T *const d,   return res; } +/// Set a dictionary as the return value+void tv_dict_set(typval_T *rettv, dict_T *d)","@ZyX-I named another function `tv_list_alloc_ret`, so following that pattern perhaps this should be named `tv_dict_set_ret`. And the other `tv_list_set_ret`.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/8639,198571066,2018-06-27T17:07:08Z,src/nvim/eval/typval.c,"@@ -124,6 +124,16 @@ static listitem_T *tv_list_item_alloc(void)   return xmalloc(sizeof(listitem_T)); } +/// Set a list as the return value+void tv_list_set(typval_T *rettv, list_T *l)+{+  rettv->v_type = VAR_LIST;+  rettv->vval.v_list = l;+  if (l != NULL) {+    l->lv_refcount++;",use `tv_list_ref()`,
17451647,MichaHoffmann,https://api.github.com/repos/neovim/neovim/pulls/8651,199205381,2018-06-29T15:54:59Z,src/nvim/msgpack_rpc/helpers.c,"@@ -503,7 +510,6 @@ Object msgpack_rpc_handle_invalid_arguments(uint64_t channel_id,                                             Array args,                                             Error *error) {","I'd imagine something like this``` // check method arguments                                                                                     Array args = ARRAY_DICT_INIT;                                                                                 if (!msgpack_rpc_to_array(msgpack_rpc_args(request), &args) && !ERROR_SET(&error)) {                            api_set_error(&error, kErrorTypeException, ""Invalid method arguments"");                                     }                                                                                                                                                                                                                           // check method                                                                                               if (handler.fn == msgpack_rpc_handle_missing_method) {                                                          String m = method->via.bin.size > 0                                                                             ? cbuf_to_string(method->via.bin.ptr, method->via.bin.size)                                                   : cstr_to_string(""<empty>"");                                                                                api_set_error(&error, kErrorTypeException, ""Invalid method: %s"", STRING_OBJ(m).data.string.data);           }                                                                                                                                                                                                                           if (ERROR_SET(&error)) {                                                                                        channel_write(channel,                                                                                                      serialize_response(channel->id,                                                                                                  request_id,                                                                                                   &error,                                                                                                       NIL,                                                                                                          &out_buffer));                                                               api_clear_error(&error);                                                                                      return;                                                                                                     } ```but that fails on  ```[----------] Running tests from test/functional/ex_cmds/ctrl_c_spec.lua[ RUN      ] CTRL-C (mapped) interrupts :global```after blocking for several seconds, can you imagine why that is so?",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/8639,199305593,2018-06-30T00:18:53Z,src/nvim/eval/typval.h,"@@ -426,6 +426,18 @@ static inline void tv_list_ref(list_T *const l)   l->lv_refcount++; } +/// Set a list as the return value+///+/// @param[in] tv   Object to receive the list+/// @param[in] l    List to pass to the object","Two spaces after `]`. No alignment of parameter descriptions at all, it is hard to maintain: parameter description always starts two spaces after parameter name. List is modified, so it is `in,out` parameter. `tv` is pure `out` parameter.(Also it would be good to modify `[in]` in `tv_list_ref`, it is most likely a copy-paste error, `l` there is an `in,out` parameter.)",
6135075,timeyyy,https://api.github.com/repos/neovim/neovim/pulls/5031,199319083,2018-06-30T10:08:08Z,src/nvim/edit.c,"@@ -5323,6 +5331,9 @@ insertchar (     do_digraph(buf[i-1]);               /* may be the start of a digraph */     buf[i] = NUL;     ins_str(buf);+    extmark_col_adjust(curbuf, curwin->w_cursor.lnum,","> maybe mark_col_adjust should be the entry point around the codebase with a kExtmarkOnly flagSeems like a good idea. Could we make an issue for tracker for things that should be done after this pr is merged?>  bufhl should be integrated fully with extmarksyup, again lets track this idea on a list, extmarks should be working properly first :wink: ",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/5031,199320168,2018-06-30T11:14:00Z,src/nvim/edit.c,"@@ -5323,6 +5331,9 @@ insertchar (     do_digraph(buf[i-1]);               /* may be the start of a digraph */     buf[i] = NUL;     ins_str(buf);+    extmark_col_adjust(curbuf, curwin->w_cursor.lnum,","> Could we make an issue for tracker for things that should be done after this pr is merged?Is this really a such big change that needs deferring tho? we have already changed the signature of `mark_col_adjust` to take a flag for extmark behavior, we can just as well add a flag for ""extmark only"" at the same time.",
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/8651,199331349,2018-06-30T20:16:18Z,src/nvim/msgpack_rpc/channel.c,"@@ -313,27 +312,39 @@ static void handle_request(Channel *channel, msgpack_object *request)     return;   } -  // Retrieve the request handler   MsgpackRpcRequestHandler handler;-  Array args = ARRAY_DICT_INIT;   msgpack_object *method = msgpack_rpc_method(request);+  handler = msgpack_rpc_get_handler_for(method->via.bin.ptr,+                                        method->via.bin.size); -  if (method) {-    handler = msgpack_rpc_get_handler_for(method->via.bin.ptr,-                                          method->via.bin.size);-    if (handler.fn == msgpack_rpc_handle_missing_method) {-      String m = method->via.bin.size > 0-        ? cbuf_to_string(method->via.bin.ptr, method->via.bin.size)-        : cstr_to_string(""<empty>"");-      ADD(args, STRING_OBJ(m));-      handler.async = true;-    } else if (!msgpack_rpc_to_array(msgpack_rpc_args(request), &args)) {-      handler.fn = msgpack_rpc_handle_invalid_arguments;-      handler.async = true;-    }-  } else {-    handler.fn = msgpack_rpc_handle_missing_method;-    handler.async = true;+  // check method arguments+  Array args = ARRAY_DICT_INIT;+  if (!msgpack_rpc_to_array(msgpack_rpc_args(request), &args)+      && !ERROR_SET(&error)) {",We should switch the order of the conditions here.,
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/8651,199331699,2018-06-30T20:34:16Z,src/nvim/msgpack_rpc/channel.c,"@@ -313,27 +312,39 @@ static void handle_request(Channel *channel, msgpack_object *request)     return;   } -  // Retrieve the request handler   MsgpackRpcRequestHandler handler;-  Array args = ARRAY_DICT_INIT;   msgpack_object *method = msgpack_rpc_method(request);+  handler = msgpack_rpc_get_handler_for(method->via.bin.ptr,+                                        method->via.bin.size); -  if (method) {-    handler = msgpack_rpc_get_handler_for(method->via.bin.ptr,-                                          method->via.bin.size);-    if (handler.fn == msgpack_rpc_handle_missing_method) {-      String m = method->via.bin.size > 0-        ? cbuf_to_string(method->via.bin.ptr, method->via.bin.size)-        : cstr_to_string(""<empty>"");-      ADD(args, STRING_OBJ(m));-      handler.async = true;-    } else if (!msgpack_rpc_to_array(msgpack_rpc_args(request), &args)) {-      handler.fn = msgpack_rpc_handle_invalid_arguments;-      handler.async = true;-    }-  } else {-    handler.fn = msgpack_rpc_handle_missing_method;-    handler.async = true;+  // check method arguments+  Array args = ARRAY_DICT_INIT;+  if (!msgpack_rpc_to_array(msgpack_rpc_args(request), &args)+      && !ERROR_SET(&error)) {","> We should switch the order of the conditions here.Switching the order in this `if`:If `msgpack_rpc_get_handler()` has set an error, we don't need to call `msgpack_rpc_to_array(...)`. We just need to check for an error first. Less work.",
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/8666,199345681,2018-07-01T11:08:32Z,test/functional/fixtures/tty-test.c,"@@ -150,7 +150,12 @@ int main(int argc, char **argv)   }    if (argc > 1) {-    int count = atoi(argv[1]);+    char *endptr;+    errno = 0;+    int count = (int)strtol(argv[1], &endptr, 10);+    if (errno != 0) {+      abort();+    }","Man page says the behavior is the same as `strtol(argv[1],NULL,10);` except that errors are not detected.I would assume Covertiy complains about a size unchecked upper bound for the loop that could be too big (Did the programmer really consider what an upper bound of 10^9 would do? What about a negative value?).",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/8616,199348024,2018-07-01T12:33:51Z,test/functional/api/buffer_updates_spec.lua,"@@ -741,3 +742,90 @@ describe('API: buffer events:', function()   end)  end)++describe('API: buffer events:', function()+  before_each(function()+    helpers.clear()+  end)++  local function lines_subset(first, second)+    for i = 1,#first do+      if first[i] ~= second[i] then+        return false+      end+    end+    return true+  end++  local function lines_equal(f, s)+    return lines_subset(f, s) and lines_subset(s, f)+  end++  local function did_match_somewhere(buffer_lines, expected_lines)","I renamed this to `assert_match_somewhere` and swapped the parameter order (typically the ""expected"" value is the first parameter).",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/8665,199365700,2018-07-01T23:51:21Z,src/nvim/spell.c,"@@ -4292,23 +4290,22 @@ static void suggest_trie_walk(suginfo_T *su, langp_T *lp, char_u *fword, bool so                     && utf_iscomposing(utf_ptr2char(fword                                                     + sp->ts_fcharstart))) {                   sp->ts_score -= SCORE_SUBST - SCORE_SUBCOMP;-                } else if (!soundfold-                           && slang->sl_has_map+                } else if (!soundfold && slang->sl_has_map                            && similar_chars(slang,-                                            mb_ptr2char(tword-                                                        + sp->ts_twordlen-                                                        - sp->ts_tcharlen),-                                            mb_ptr2char(fword-                                                        + sp->ts_fcharstart))) {+                                            utf_ptr2char(tword + sp->ts_twordlen+                                                         - sp->ts_tcharlen),+                                            utf_ptr2char(fword+                                                         + sp->ts_fcharstart))+                           ) {",You should not move `)` on its own line. As far as I understand style guide you need to resolve the situation by either moving `!soundfold` (the very *first* part of condition) on its own line and indent it with +4 spaces or move `slang` (the very *first* argument) on its own line with +4 spaces. Following parts of condition or arguments should be aligned with the first one (like now).,
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/8665,199365735,2018-07-01T23:52:46Z,src/nvim/spell.c,"@@ -4292,23 +4290,22 @@ static void suggest_trie_walk(suginfo_T *su, langp_T *lp, char_u *fword, bool so                     && utf_iscomposing(utf_ptr2char(fword                                                     + sp->ts_fcharstart))) {                   sp->ts_score -= SCORE_SUBST - SCORE_SUBCOMP;-                } else if (!soundfold-                           && slang->sl_has_map+                } else if (!soundfold && slang->sl_has_map","Do not join lines like this, lengthy multipart condition is more readable when each part starts on its own line.",
1042786,ZviRackover,https://api.github.com/repos/neovim/neovim/pulls/8665,199369856,2018-07-02T01:33:22Z,src/nvim/spell.c,"@@ -4292,23 +4290,22 @@ static void suggest_trie_walk(suginfo_T *su, langp_T *lp, char_u *fword, bool so                     && utf_iscomposing(utf_ptr2char(fword                                                     + sp->ts_fcharstart))) {                   sp->ts_score -= SCORE_SUBST - SCORE_SUBCOMP;-                } else if (!soundfold-                           && slang->sl_has_map+                } else if (!soundfold && slang->sl_has_map                            && similar_chars(slang,-                                            mb_ptr2char(tword-                                                        + sp->ts_twordlen-                                                        - sp->ts_tcharlen),-                                            mb_ptr2char(fword-                                                        + sp->ts_fcharstart))) {+                                            utf_ptr2char(tword + sp->ts_twordlen+                                                         - sp->ts_tcharlen),+                                            utf_ptr2char(fword+                                                         + sp->ts_fcharstart))+                           ) {","Ok, i'll go for moving `!soundfold` to a new line. If all fails, there is a possibility of refactoring out the expression `tword + sp->ts_twordlen - sp->ts_tcharlen` as it repeats in neighboring conditions",
1042786,ZviRackover,https://api.github.com/repos/neovim/neovim/pulls/8665,199372137,2018-07-02T02:11:41Z,src/nvim/spell.c,"@@ -4292,23 +4290,22 @@ static void suggest_trie_walk(suginfo_T *su, langp_T *lp, char_u *fword, bool so                     && utf_iscomposing(utf_ptr2char(fword                                                     + sp->ts_fcharstart))) {                   sp->ts_score -= SCORE_SUBST - SCORE_SUBCOMP;-                } else if (!soundfold-                           && slang->sl_has_map+                } else if (!soundfold && slang->sl_has_map                            && similar_chars(slang,-                                            mb_ptr2char(tword-                                                        + sp->ts_twordlen-                                                        - sp->ts_tcharlen),-                                            mb_ptr2char(fword-                                                        + sp->ts_fcharstart))) {+                                            utf_ptr2char(tword + sp->ts_twordlen+                                                         - sp->ts_tcharlen),+                                            utf_ptr2char(fword+                                                         + sp->ts_fcharstart))+                           ) {","Here's what can be done following what you siggest @ZyX-I. Only problem is that the rightmost brace reaches column 81 and the linter complains only about that.Is there another possiblity for fitting this code?```                } else if (!soundfold                           && slang->sl_has_map                           && similar_chars(slang,                                            utf_ptr2char(tword                                                         + sp->ts_twordlen                                                         - sp->ts_tcharlen),                                            utf_ptr2char(fword                                                         + sp->ts_fcharstart))) {                  // For a similar character adjust score from                  // SCORE_SUBST to SCORE_SIMILAR.                  sp->ts_score -= SCORE_SUBST - SCORE_SIMILAR;                }```",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/8665,199408645,2018-07-02T07:44:53Z,src/nvim/spell.c,"@@ -4292,23 +4290,22 @@ static void suggest_trie_walk(suginfo_T *su, langp_T *lp, char_u *fword, bool so                     && utf_iscomposing(utf_ptr2char(fword                                                     + sp->ts_fcharstart))) {                   sp->ts_score -= SCORE_SUBST - SCORE_SUBCOMP;-                } else if (!soundfold-                           && slang->sl_has_map+                } else if (!soundfold && slang->sl_has_map                            && similar_chars(slang,-                                            mb_ptr2char(tword-                                                        + sp->ts_twordlen-                                                        - sp->ts_tcharlen),-                                            mb_ptr2char(fword-                                                        + sp->ts_fcharstart))) {+                                            utf_ptr2char(tword + sp->ts_twordlen+                                                         - sp->ts_tcharlen),+                                            utf_ptr2char(fword+                                                         + sp->ts_fcharstart))+                           ) {","@ZviRackover It is not what I suggested and I do not see `!soundfold` on a new line there. What I suggested is```C                } else if (                    !soundfold                    && slang->sl_has_map                    && similar_chars(slang,                                     utf_ptr2char(tword                                                  + sp->ts_twordlen                                                  - sp->ts_tcharlen),                                     utf_ptr2char(fword                                                  + sp->ts_fcharstart))) {                  // For a similar character adjust score from                  // SCORE_SUBST to SCORE_SIMILAR.                  sp->ts_score -= SCORE_SUBST - SCORE_SIMILAR;                }```Same thing may be done with `slang` as well, I think doing both would be cleaner:```C                } else if (                    !soundfold                    && slang->sl_has_map                    && similar_chars(                        slang,                        utf_ptr2char(tword + sp->ts_twordlen - sp->ts_tcharlen),                        utf_ptr2char(fword + sp->ts_fcharstart))) {                  // For a similar character adjust score from                  // SCORE_SUBST to SCORE_SIMILAR.                  sp->ts_score -= SCORE_SUBST - SCORE_SIMILAR;                }```",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/8660,200176506,2018-07-04T17:05:29Z,src/nvim/api/buffer.c,"@@ -745,10 +758,34 @@ void nvim_buf_set_name(Buffer buffer, String name, Error *err)   } } -/// Checks if a buffer is valid+/// Checks if a buffer is valid and loaded. When a buffer is+/// unloaded its file contents are freed from memory and vim+/// cannot operate on the buffer lines until it is reloaded+/// (usually by opening the buffer again in a new window). API+/// methods such as |nvim_buf_line_count()| and+/// |nvim_buf_get_lines()| will be affected.+///+/// Buffers may have been unloaded by the |:bunload| command or+/// the buffer's|'bufhidden'| option.+///+/// @param buffer Buffer handle+/// @return true if the buffer is valid and loaded, false otherwise.+Boolean nvim_buf_is_loaded(Buffer buffer)+  FUNC_API_SINCE(5)+{+  Error stub = ERROR_INIT;+  buf_T *buf = find_buffer_by_handle(buffer, &stub);+  api_clear_error(&stub);+  return buf && buf->b_ml.ml_mfp != NULL;+}++/// Checks if a buffer is valid.+///+/// @note Even if a buffer is valid it may have been unloaded. Use+///       |nvim_buf_is_loaded()| to check if a buffer is loaded. /// /// @param buffer Buffer handle-/// @return true if the buffer is valid, false otherwise+/// @return true if the buffer is valid, false otherwise. Boolean nvim_buf_is_valid(Buffer buffer)","And exactly how is this function not even _related_ to buffers? I'm not saying true is obviously objectively better _a priori_, just that if we are introducing a special case, and a _change_ of behaviour of existing input at that, I want a stronger argument than ""maybe false is more useful in a some more situations"". After all, clients can already special case 0 as they want, the _only_ functional effect of changing this now is potentially breaking code that already uses this function and didn't anticipate this change.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/8660,200200353,2018-07-04T20:56:49Z,src/nvim/api/buffer.c,"@@ -745,10 +758,34 @@ void nvim_buf_set_name(Buffer buffer, String name, Error *err)   } } -/// Checks if a buffer is valid+/// Checks if a buffer is valid and loaded. When a buffer is+/// unloaded its file contents are freed from memory and vim+/// cannot operate on the buffer lines until it is reloaded+/// (usually by opening the buffer again in a new window). API+/// methods such as |nvim_buf_line_count()| and+/// |nvim_buf_get_lines()| will be affected.+///+/// Buffers may have been unloaded by the |:bunload| command or+/// the buffer's|'bufhidden'| option.+///+/// @param buffer Buffer handle+/// @return true if the buffer is valid and loaded, false otherwise.+Boolean nvim_buf_is_loaded(Buffer buffer)+  FUNC_API_SINCE(5)+{+  Error stub = ERROR_INIT;+  buf_T *buf = find_buffer_by_handle(buffer, &stub);+  api_clear_error(&stub);+  return buf && buf->b_ml.ml_mfp != NULL;+}++/// Checks if a buffer is valid.+///+/// @note Even if a buffer is valid it may have been unloaded. Use+///       |nvim_buf_is_loaded()| to check if a buffer is loaded. /// /// @param buffer Buffer handle-/// @return true if the buffer is valid, false otherwise+/// @return true if the buffer is valid, false otherwise. Boolean nvim_buf_is_valid(Buffer buffer)","@phodge In that hypothetical situation: yes. Then most other `nvim_buf_` functions would also unconditionally throw an error in that situation. (if we _want_ such a situation to be exposed to local and remote user code is of course a different question, the programming model is simpler as long as we can avoid it)",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/8665,200494455,2018-07-05T21:26:05Z,src/nvim/spell.c,"@@ -3648,7 +3645,8 @@ static void suggest_trie_walk(suginfo_T *su, langp_T *lp, char_u *fword, bool so   bool goodword_ends; #ifdef DEBUG_TRIEWALK   // Stores the name of the change made at each level.-  char_u changename[MAXWLEN][80];+  const size_t changenameElemSize = 80;+  char_u changename[MAXWLEN][changenameElemSize];","You only removed static, this variable name is still not valid, comment is still not where it should be and additional variable is generally useless as you may just use `sizeof()`.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/8660,200613750,2018-07-06T10:28:40Z,test/functional/api/buffer_spec.lua,"@@ -35,8 +35,42 @@ describe('api/buf', function()       -- There's always at least one line       eq(1, curbuf_depr('line_count'))     end)-  end) +    it('line_count has defined behaviour for unloaded buffers', function()+      -- we'll need to know our bufnr for when it gets unloaded+      local bufnr = request('nvim_buf_get_number', 0)","`nvim_buf_get_number` is deprecated, `nvim_get_current_buf` is preferred for this, or just use `curbuf()` without args.",
1042786,ZviRackover,https://api.github.com/repos/neovim/neovim/pulls/8665,200699255,2018-07-06T16:06:29Z,src/nvim/spell.c,"@@ -4542,9 +4525,10 @@ static void suggest_trie_walk(suginfo_T *su, langp_T *lp, char_u *fword, bool so       if (c2 != NUL && TRY_DEEPER(su, stack, depth, SCORE_SWAP)) {         go_deeper(stack, depth, SCORE_SWAP); #ifdef DEBUG_TRIEWALK-        sprintf(changename[depth], ""%.*s-%s: swap %c and %c"",-            sp->ts_twordlen, tword, fword + sp->ts_fidx,-            c, c2);+        snprintf(changename[depth], sizeof changename[0],","Done. Didn't find this rule in the relevant style guide section, https://neovim.io/develop/style-guide.xml#sizeof. If it is indeed not listed, should it be added?",
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/8681,200807400,2018-07-07T09:24:58Z,src/nvim/charset.c,"@@ -370,7 +370,8 @@ size_t transstr_buf(const char *const s, char *const buf, const size_t len)   while (*p != NUL && buf_p < buf_e) {     const size_t l = (size_t)utfc_ptr2len((const char_u *)p);     if (l > 1) {-      if (buf_p + l >= buf_e) {+      //ignore lengths that do not fit the buffer+      if (buf_p + l > buf_e) {         break;       }       int pcc[MAX_MCO + 2];","`MAX_MCO+1` is not necessary for the current version of `utfc_ptr2char()`, the parameter comment is more general as it needs to be [(see)](https://github.com/neovim/neovim/pull/8218#pullrequestreview-134804360).",
9766,blueyed,https://api.github.com/repos/neovim/neovim/pulls/8708,200844323,2018-07-08T15:32:25Z,src/nvim/tui/tui.c,"@@ -459,8 +459,8 @@ static void update_attrs(UI *ui, HlAttrs attrs)   bool underline = attr & (HL_UNDERLINE), undercurl = attr & (HL_UNDERCURL);    if (unibi_get_str(data->ut, unibi_set_attributes)) {","For me this condition appears to be true always, which results in the `else` below not being reached (where standout is set).",
8740057,janlazo,https://api.github.com/repos/neovim/neovim/pulls/8710,201184087,2018-07-10T00:04:22Z,src/nvim/ex_getln.c,"@@ -194,6 +194,9 @@ static int cmd_showtail;                /* Only show path tail in lists ? */  static int new_cmdpos;          /* position set by set_cmdline_pos() */ +static int extra_char = NUL;    // extra character to display when redrawing",Will both new static variables be moved to `command_line_state` or do I simply rename `special_char` and `special_shift` and use those instead? I can add more timer-related patches in the meantime while there is no resolution on this.,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/8063,201479215,2018-07-10T20:16:15Z,src/nvim/testdir/Makefile,"@@ -35,6 +34,9 @@ SCRIPTS ?= $(SCRIPTS_DEFAULT) # Tests using runtest.vim. # Keep test_alot*.res as the last one, sort the others. NEW_TESTS ?= \+	    test_alot.res \+	    test_alot_latin.res \+	    test_alot_utf8.res \","The ""alot"" tests are an exception to the ""alphanumeric order"" rule. If in doubt, just check  the comment on line 36.",
972014,mhinz,https://api.github.com/repos/neovim/neovim/pulls/8726,201802961,2018-07-11T18:51:07Z,src/nvim/ex_cmds2.c,"@@ -1339,6 +1339,22 @@ void dialog_changed(buf_T *buf, int checkall)   } } +/// Ask the user whether to close the terminal buffer or not.+///+/// @param buf The terminal buffer.+/// @return bool Whether to close the buffer or not.+bool dialog_close_terminal(buf_T *buf)+{+  char_u buff[DIALOG_MSG_SIZE];++  dialog_msg(buff, _(""Close \""%s\""?""),+             (buf->b_fname != NULL) ? buf->b_fname : (char_u *)_(""Untitled""));","I took that directly from `dialog_changed()`: https://github.com/neovim/neovim/blob/9adb6ed74ac72f6a3a694cc1502f783426e22c4d/src/nvim/ex_cmds2.c#L1288-L1290But I agree with the ""?"". It probably never happens that the current terminal buffer's name is NULL.",
17451647,MichaHoffmann,https://api.github.com/repos/neovim/neovim/pulls/8651,201828465,2018-07-11T20:27:37Z,src/nvim/api/private/dispatch.c,"@@ -32,14 +32,20 @@ static void msgpack_rpc_add_method_handler(String method, /// @param name API method name /// @param name_len name size (includes terminating NUL) MsgpackRpcRequestHandler msgpack_rpc_get_handler_for(const char *name,-                                                     size_t name_len)+                                                     size_t name_len,+                                                     Error *error) {   String m = { .data = (char *)name, .size = name_len };   MsgpackRpcRequestHandler rv =     map_get(String, MsgpackRpcRequestHandler)(methods, m);    if (!rv.fn) {-    rv.fn = msgpack_rpc_handle_missing_method;+    String method_name = m.size > 0 ?","I get this error after the Change ( on Travis' ASAN Build ) do you have an idea how that can be related?```[1m[31m[  ERROR   ][0m[0m [1m1[0m error, listed below:[1m[31m[  ERROR   ][0m[0m [36m...d/neovim/neovim/test/functional/ui/screen_basic_spec.lua[0m @ [36m651[0m: [1mScreen resize has minimum width/height values[0mtest/functional/ui/screen.lua:307: Row 1 did not match.Expected:  |*{2:-- INS^ERT --}|  |            |Actual:  |*resize^      |  |            |```",
1042786,ZviRackover,https://api.github.com/repos/neovim/neovim/pulls/8718,202109812,2018-07-12T17:06:04Z,src/nvim/strings.c,"@@ -455,23 +455,19 @@ char_u *vim_strchr(const char_u *const string, const int c)   } } -/*- * Search for last occurrence of ""c"" in ""string"".- * Return NULL if not found.- * Does not handle multi-byte char for ""c""!- */+/// strrchr() version which does not handle multi-byte char for ""c""!+///+/// @param[in]  string  String to search in.+/// @param[in]  c  Character to search for.+///+/// @return Pointer to the last occurrence in string or NULL+///         if it was not found. NUL character is not+///         handled, use `strlen()` instead. char_u *vim_strrchr(const char_u *string, int c)",That would be the preferable choice IMO - as long as it is not exposed as an interface.,
875184,dimbleby,https://api.github.com/repos/neovim/neovim/pulls/8737,202465154,2018-07-13T20:32:04Z,src/nvim/os/pty_process_unix.c,"@@ -273,26 +273,24 @@ static void chld_handler(uv_signal_t *handle, int signum)   int stat = 0;   int pid; -  do {-    pid = waitpid(-1, &stat, WNOHANG);-  } while (pid < 0 && errno == EINTR);--  if (pid <= 0) {-    return;-  }-   Loop *loop = handle->loop->data;    kl_iter(WatcherPtr, loop->children, current) {     Process *proc = (*current)->data;-    if (proc->pid == pid) {-      if (WIFEXITED(stat)) {-        proc->status = WEXITSTATUS(stat);-      } else if (WIFSIGNALED(stat)) {-        proc->status = WTERMSIG(stat);-      }-      proc->internal_exit_cb(proc);-      break;+    do {+      pid = waitpid(proc->pid, &stat, WNOHANG);+    } while (pid < 0 && errno == EINTR);++    if (pid <= 0) {+      continue;+    }++    if (WIFEXITED(stat)) {+      proc->status = WEXITSTATUS(stat);+    } else if (WIFSIGNALED(stat)) {+      proc->status = WTERMSIG(stat);     }+    proc->internal_exit_cb(proc);+    break;","I've done some more googling and I now think that @oni-link is right all along - `SIGCHLD`s are not queued, so we might see fewer of them than terminated processes.  I'll raise a new issue and propose that the fix is simply to remove the `break`",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/8746,202533867,2018-07-15T07:29:17Z,src/nvim/channel.c,"@@ -288,7 +288,8 @@ Channel *channel_job_start(char **argv, CallbackReader on_stdout,   chan->on_stdout = on_stdout;   chan->on_stderr = on_stderr;   chan->on_exit = on_exit;-  chan->is_rpc = rpc;+  // Prevent channel_destroy_early() from freeing uninitialized rpc stuff",">  Should I add a comment further down when using channel_destroy_early() that the rpc part needs to be in its init state?This is not true, `channel_destroy_early()` doesn't need any special condition, it works the same as the ordinary channel freeing function. I don't think the _lack_ of special treatment of rpc channels needs a comment. ",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/8730,203100804,2018-07-17T16:58:25Z,src/nvim/eval.c,"@@ -16406,11 +16409,28 @@ static void get_system_output_as_rettv(typval_T *argvars, typval_T *rettv,     return;  // Already did emsg.   } +  if (p_verbose > 3) {+    char buf[NUMBUFLEN];+    verbose_enter();+    smsg(_(""Calling shell to execute: \""%s\""""), tv_get_string_buf(argvars, buf));+    smsg(_("""")); // TODO: why do I need to add this?","If I do:    git grep smsgI see that it's a common pattern, e.g.:```c    smsg(_(""Exception caught: %s""), excp->value);    msg_puts(""\n"");  // don't overwrite this either```So I think it's fine as you have it. Though perhaps change it to `msg_puts(""\n""); `.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/8730,203101599,2018-07-17T17:01:02Z,test/helpers.lua,"@@ -696,6 +699,7 @@ local module = {   mergedicts_copy = mergedicts_copy,   neq = neq,   ok = ok,+  near = near,",keep this list in alphabetical order. same for the other one.,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/8730,203103227,2018-07-17T17:06:16Z,test/functional/eval/system_spec.lua,"@@ -203,6 +203,45 @@ describe('system()', function()       ]])     end) +    it('prints verbose information', function()+      feed(':4verbose echo system(""echo hi"")<cr>')+      screen:expect([[+                                                             |+        ~                                                    |+        ~                                                    |+        ~                                                    |+        ~                                                    |+        ~                                                    |+        ~                                                    |+        ~                                                    |+                                                             |+        Calling shell to execute: ""echo hi""                  |+                                                             |+        hi                                                   |+                                                             |+        Press ENTER or type command to continue^              |+      ]])+      feed('<cr>')+    end)++    it('execution time not profiled as self time', function()+      local tempfile = helpers.tmpname()++      feed(':function! AlmostNoSelfTime()<cr>')+      feed('echo system(""sleep 2"")<cr>')","This just fails on Windows (no `sleep` command), so the comparison of `near(selftime, 0, 0.01)` is fragile.I think it's enough to just check that `:profile` ""did something"", don't need to compare times. Though the effort is appreciated, but flakey tests are something we need to avoid (more) :)1+ seconds is also a big cost for a test. So let's get rid of the `sleep`, just do:    feed([[echo system('echo ""foo""')<cr>]])",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/8779,205141103,2018-07-25T14:51:31Z,src/nvim/tui/tui.c,"@@ -802,7 +802,16 @@ static void reset_scroll_region(UI *ui) static void tui_grid_resize(UI *ui, Integer g, Integer width, Integer height) {   TUIData *data = ui->data;-  ugrid_resize(&data->grid, (int)width, (int)height);+  UGrid *grid = &data->grid;+  ugrid_resize(data, (int)width, (int)height);",why pass `data` instead of `grid` to `ugrid_resize` ?,
8445768,coditva,https://api.github.com/repos/neovim/neovim/pulls/8455,207187852,2018-08-02T11:12:36Z,src/nvim/edit.c,"@@ -1488,8 +1488,8 @@ void edit_putchar(int c, int highlight)         int fix_col = mb_fix_col(pc_col, pc_row);          if (fix_col != pc_col) {-          screen_putchar(' ', pc_row, fix_col, attr);-          --curwin->w_wcol;+          grid_putchar(&default_grid, ' ', pc_row, fix_col, attr);","I'm not sure if I should be removing `w_winrow` from this: https://github.com/UtkarshMe/neovim/blob/6313b02704e7ac357911e169c71881f5b43fcd9d/src/nvim/edit.c#L559`curwin->w_wrow` is relative to the window i.e. `w_winrow`. I don't know what this line does.Also, I should be changing `w_height`/`w_width` to `w_grid.Rows`/`w_grid.Columns` too, right?",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/8799,207714045,2018-08-04T17:05:21Z,src/nvim/syntax.c,"@@ -1620,42 +1615,37 @@ get_syntax_attr( /*  * Get syntax attributes for current_lnum, current_col.  */-static int-syn_current_attr(-    int syncing,                           // When 1: called for syncing-    int displaying,                        // result will be displayed-    bool *can_spell,                       // return: do spell checking-    int keep_state                         // keep syntax stack afterwards+static int syn_current_attr(+    const bool syncing,                   // When true: called for syncing+    const bool displaying,                // result will be displayed+    bool *const can_spell,                // return: do spell checking+    const bool keep_state                 // keep syntax stack afterwards","In the future, let's not mark non-pointer parameters with `const`. It's mostly noise.I know there's debate about it, but we need to have a clear guideline about this, and it's better if we just don't do it.",
8740057,janlazo,https://api.github.com/repos/neovim/neovim/pulls/8749,207715541,2018-08-04T18:15:30Z,src/nvim/fold.c,"@@ -1505,36 +1486,40 @@ static int getDeepestNestingRecurse(garray_T *gap) /*  * Check if a fold is closed and update the info needed to check nested folds.  */-static int-check_closed(-    win_T *win,-    fold_T *fp,-    int *use_levelp,            // TRUE: outer fold had FD_LEVEL-    int level,                  // folding depth-    int *maybe_smallp,          // TRUE: outer this had fd_small == MAYBE-    linenr_T lnum_off           // line number offset for fp->fd_top+static bool check_closed(+    win_T *const win,+    fold_T *const fp,+    bool *const use_levelp,     // true: outer fold had FD_LEVEL+    const int level,            // folding depth+    bool *const maybe_smallp,   // true: outer this had fd_small == kNone","Adding `const` to pointer value ensures that it doesn't change in the function and it's safe to pass to functions with non-const pointer params without typecast. C is mutable by default, including the params, so adding `const` gives some assurance that it doesn't change midway in a long function.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/8749,207715726,2018-08-04T18:25:03Z,src/nvim/fold.c,"@@ -1505,36 +1486,40 @@ static int getDeepestNestingRecurse(garray_T *gap) /*  * Check if a fold is closed and update the info needed to check nested folds.  */-static int-check_closed(-    win_T *win,-    fold_T *fp,-    int *use_levelp,            // TRUE: outer fold had FD_LEVEL-    int level,                  // folding depth-    int *maybe_smallp,          // TRUE: outer this had fd_small == MAYBE-    linenr_T lnum_off           // line number offset for fp->fd_top+static bool check_closed(+    win_T *const win,+    fold_T *const fp,+    bool *const use_levelp,     // true: outer fold had FD_LEVEL+    const int level,            // folding depth+    bool *const maybe_smallp,   // true: outer this had fd_small == kNone","Adding const to every local binding that happens to not change will add a lot of linenoise to the implementation. Overly long functions (so long that local vars are hard to keep track of) are the exception, they at least shouldn't determine how we write reasonably sized functions. (Didn't check this function because of on mobile)",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/8790,207722653,2018-08-05T00:47:40Z,runtime/doc/ui.txt,"@@ -89,13 +89,18 @@ Global Events							    *ui-global* 	`cursor_shape`:	""block"", ""horizontal"", ""vertical"" 	`cell_percentage`: Cell % occupied by the cursor. 	`blinkwait`, `blinkon`, `blinkoff`: See |cursor-blinking|.-	`hl_id`:	Cursor highlight group.-	`hl_lm`:	Cursor highlight group if 'langmap' is active.+	`attr_id`:	Cursor attribute id (defined by `hl_attr_define`)+	`attr_id_lm`:	Cursor attribute id for when 'langmap' is active. 	`short_name`:	Mode code name, see 'guicursor'. 	`name`:		Mode descriptive name. 	`mouse_shape`:	(To be implemented.) -	Some keys are missing in some modes.+	Some keys are missing in some modes. The following keys are deprecated:++	`hl_id`:	Cursor highlight group.+	`hl_lm`:	Cursor highlight group if 'langmap' is active.++    Use `attr_id` and `attr_id_lm` instead.",```Some keys are missing in some modes. The following keys are deprecated:`hl_id`:	Use attr_id instead.`hl_lm`:	Use attr_id_lm instead.```,
112971,jamessan,https://api.github.com/repos/neovim/neovim/pulls/8819,207755232,2018-08-06T00:44:34Z,scripts/vim-patch.sh,"@@ -312,8 +312,10 @@ submit_pr() {   pr_message=""$(printf '[RFC] vim-patch:%s\n\n%s\n' ""${pr_title#,}"" ""${pr_body}"")""    if [[ $push_first -ne 0 ]]; then-    echo ""Pushing to 'origin/${checked_out_branch}'.""-    output=""$(git push origin ""${checked_out_branch}"" 2>&1)"" &&+    local push_remote+    push_remote=""$(git config --get github.user || echo origin)""","We have some support for [hub](https://github.com/github/hub) and [git-hub](https://github.com/sociomantic-tsunami/git-hub) baked in.  Maybe checking for metadata they provide before falling back to `origin` would be a good idea.For example, git-hub sets `hub.forkremote` to the name of the user's remote and (on newer versions) `hub.upstreamremote` to the name of the project's remote.I've never used hub, but I wouldn't be surprised if it did something similar.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/8665,207975268,2018-08-06T17:46:25Z,src/nvim/charset.c,"@@ -1375,7 +1375,7 @@ void getvvcol(win_T *wp, pos_T *pos, colnr_T *start, colnr_T *cursor,     ptr = ml_get_buf(wp->w_buffer, pos->lnum, false);      if (pos->col < (colnr_T)STRLEN(ptr)) {-      int c = (*mb_ptr2char)(ptr + pos->col);+      int c = utf_ptr2char(ptr + pos->col);","Especially with a small local block there is really not much benefit to add const to a local variable binding (it just trivially repeats info already visible in the block), we should focus the effort to pointer targets (where const makes it a distinct type), and possibly bindings in really large scopes.",
8740057,janlazo,https://api.github.com/repos/neovim/neovim/pulls/8821,208104248,2018-08-07T05:44:01Z,src/nvim/testdir/test_compiler.vim,"@@ -0,0 +1,49 @@+"" Test the :compiler command++func Test_compiler()+  if !executable('perl')+    return+  endif++  e Xfoo.pl+  compiler perl+  call assert_equal('perl', b:current_compiler)+  call assert_fails('let g:current_compiler', 'E121:')++  call setline(1, ['#!/usr/bin/perl -w', 'use strict;', 'my $foo=1'])+  w!+  call feedkeys("":make\<CR>\<CR>"", 'tx')+  call assert_fails('clist', 'E42:')++  call setline(1, ['#!/usr/bin/perl -w', 'use strict;', '$foo=1'])+  w!+  call feedkeys("":make\<CR>\<CR>"", 'tx')+  let a=execute('clist')","```Caught exception in Test_compiler(): Vim(clist):E42: No Errors @ function RunTheTest[35]..Test_compiler, line 18```",
8740057,janlazo,https://api.github.com/repos/neovim/neovim/pulls/8744,208410058,2018-08-07T22:54:34Z,src/nvim/edit.c,"@@ -7475,17 +7475,23 @@ static void ins_shift(int c, int lastc)  static void ins_del(void) {-  int temp;--  if (stop_arrow() == FAIL)+  if (stop_arrow() == FAIL) {     return;-  if (gchar_cursor() == NUL) {          /* delete newline */-    temp = curwin->w_cursor.col;+  }+  if (gchar_cursor() == NUL) {          // delete newline+    const int temp = curwin->w_cursor.col;","The main intent is to `int temp = ...` on the same line. `const` is a bonus.I keep doing these things because there's too many variables at the top level when they shouldn't be and some functions are very long, sometimes with `#ifdef`, such as patch 8.0.0685. I would expect loop variables to be local to its `for` loop scope but it rarely happens in Vim codebase. There are helpers functions but they don't have `const` so I still have to go through each line when debugging. `const` is half-baked but it's preferable to note as many invariants as possible, especially on cleanup and when `goto` is used, like 8.0.0493.I like to `const` the pointer contents as well but it's hard to add it on a non-constant pointer; it could be passed to another variable or its address could be passed to a function via `&`. Think of local `const` as in-between step so that it's safer to `const` all the way across callers.",
8740057,janlazo,https://api.github.com/repos/neovim/neovim/pulls/8843,209271203,2018-08-10T14:08:12Z,src/nvim/regexp.c,"@@ -3000,9 +2999,9 @@ static int gethexchrs(int maxinputlen)  * Get and return the value of the decimal string immediately after the  * current position. Return -1 for invalid.  Consumes all digits.  */-static int getdecchrs(void)+static int64_t getdecchrs(void) {-  int nr = 0;+  int64_t nr = 0;",Vim used `long_u` here to cast it to `long` on return. I used `int64_t` to remove the need to cast. Alternative is `int32_t` and `uint32_t` to maintain the cast but that requires style changes to pass the lint build.,
1042786,ZviRackover,https://api.github.com/repos/neovim/neovim/pulls/8847,209389351,2018-08-10T21:29:43Z,src/nvim/diff.c,"@@ -1870,6 +1870,35 @@ bool diffopt_horizontal(void)   return (diff_flags & DIFF_HORIZONTAL) != 0; } +// Compare the characters at ""p1"" and ""p2"".  If they are equal (possibly+// ignoring case) return true and set ""len"" to the number of bytes.+static bool diff_equal_char(const char_u *const p1, const char_u *const p2,+                            int *const len)+{+  const int l = utfc_ptr2len(p1);++  if (l != utfc_ptr2len(p2)) {+    return false;+  }+  if (l > 1) {+    if (STRNCMP(p1, p2, l) != 0+        && (!enc_utf8",You can drop use of `enc_utf8` as there is an effort to deprecate it.,
9336514,daskol,https://api.github.com/repos/neovim/neovim/pulls/8850,209431591,2018-08-11T16:45:30Z,src/nvim/api/private/defs.h,"@@ -36,7 +36,7 @@ typedef enum { } MessageType;  /// Used as the message ID of notifications.-#define NO_RESPONSE UINT64_MAX+#define NO_RESPONSE UINT32_MAX","Yes, I thought about it. It seems that the only thing to do is conversion to wire type. But how to convert? Take message id modulo to `UINT32_MAX`? Well, this means that we still use `uint32_t`. Also, I think that long inner representation could result in some non-trivial issues if one tries to perform arithmetic and logic operations on numbers longer than 32-bits.Actully, goal of message id is to link request message and response message. Common policy of picking a message id is incrementing of per connection counter. So one just could take a random interger from `[0, UINT32_MAX]`. Since C/C++ standard declares that overflow for unsigneds is correct behaviour, it is absolutely the same as `uint64_t` modulo to `UINT32_MAX` but a bit safer. In any case the length effective window of ids is `4294967296`.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/8850,209432451,2018-08-11T17:19:13Z,src/nvim/api/private/defs.h,"@@ -36,7 +36,7 @@ typedef enum { } MessageType;  /// Used as the message ID of notifications.-#define NO_RESPONSE UINT64_MAX+#define NO_RESPONSE UINT32_MAX","> Common policy of picking a message id is incrementing of per connection counter. Question is what happens when the id gets larger than `2^32`, with `uint32_t` it would wrap around implicitly, while with `uint64_t` we would need to do this explicitly. And sometimes explicit is better...> Well, this means that we still use uint32_tNo, because we can represent sentinel values distinct from actual values (only the later sent on wire).",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/8836,209458782,2018-08-12T15:17:42Z,src/nvim/os/env.c,"@@ -187,45 +187,63 @@ void init_homedir(void)    const char *var = os_getenv(""HOME""); -#ifdef WIN32-  // Typically, $HOME is not defined on Windows, unless the user has-  // specifically defined it for Vim's sake. However, on Windows NT-  // platforms, $HOMEDRIVE and $HOMEPATH are automatically defined for-  // each user. Try constructing $HOME from these.-  if (var == NULL) {-    const char *homedrive = os_getenv(""HOMEDRIVE"");-    const char *homepath = os_getenv(""HOMEPATH"");-    if (homepath == NULL) {-      homepath = ""\\"";-    }-    if (homedrive != NULL-        && strlen(homedrive) + strlen(homepath) < MAXPATHL) {-      snprintf(os_buf, MAXPATHL, ""%s%s"", homedrive, homepath);-      if (os_buf[0] != NUL) {-        var = os_buf;+#ifdef UNIX+  // use uv_os_homedir only for unix systems+  // as uv_os_homedir checks %USERPROFILE% first then only %HOMEDRIVE%%HOMEPATH%  +  // uv_os_homedir doesn't work when a buffer initialized to NULL is passed +  // so using a local buffer","""buffer initialized to NULL"" is a long-winded way of saying ""NULL"" ?",
9336514,daskol,https://api.github.com/repos/neovim/neovim/pulls/8850,209464121,2018-08-12T18:36:42Z,src/nvim/msgpack_rpc/channel.c,"@@ -359,21 +359,17 @@ static void on_request_event(void **argv)   Channel *channel = e->channel;   MsgpackRpcRequestHandler handler = e->handler;   Array args = e->args;-  uint64_t request_id = e->request_id;+  uint32_t request_id = e->request_id;   Error error = ERROR_INIT;   Object result = handler.fn(channel->id, args, &error);-  if (request_id != NO_RESPONSE) {","Why? I do not think so.First of all, there must not be exclusively allocated `request_id` or `response_id` since it is just a way to link a response and a request. [Here](https://github.com/neovim/neovim/blob/master/src/nvim/msgpack_rpc/channel.c#L295) `request_id` is initialized in [`msgpack_rpc_validate()`](https://github.com/neovim/neovim/blob/master/src/nvim/msgpack_rpc/helpers.c#L570). It is default value is `NO_RESPONSE`. Generally, this is slightly incorrect since `request_id` is required by [`serialize_response()`](https://github.com/neovim/neovim/blob/master/src/nvim/msgpack_rpc/channel.c#L300) if validation failed. However, it could be failed due to wrong type of message (for example, array have one element instead of four elements). So, there is no valid `request_id`. If validation is successful then `request_id` value is valid.The second one reason to remove this `if` is that `request_id` is chosen by client. If client sends `UINT32_MAX - 1` messages then this `if` fails correct request.Fortunately, `request_id` value is valid bellow [this error handling `if`](https://github.com/neovim/neovim/blob/master/src/nvim/msgpack_rpc/channel.c#L315).",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/8856,210078551,2018-08-14T19:39:28Z,src/nvim/testdir/test_autocmd.vim,"@@ -248,6 +248,24 @@ func Test_augroup_warning()   au! VimEnter endfunc +func Test_BufReadCmdHelp()+  "" This used to cause access to free memory+  au BufReadCmd * e +h+  help++  helpclose+  au! BufReadCmd+endfunc++func Test_BufReadCmdHelpJump()+  "" This used to cause access to free memory+  au BufReadCmd * e +h{","    Caught exception in Test_BufReadCmdHelpJump(): Vim(help):E434: Can't find tag pattern @ function RunTheTest[35]..Test_BufReadCmdHelpJump, line 3vim patch 8.01224 makes some changes including one which expects that failure: https://github.com/vim/vim/commit/cf1ba35fc2ebd41b9a7738bbd1f026f5311560aa",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/8455,210648247,2018-08-16T15:48:11Z,src/nvim/api/ui.c,"@@ -270,6 +292,10 @@ static void remote_ui_grid_resize(UI *ui, Integer grid,   Array args = ARRAY_DICT_INIT;   if (ui->ui_ext[kUINewgrid]) {     ADD(args, INTEGER_OBJ(grid));+  } else if (grid != 1) {","do we still need this special case? I would think screen.c by itself will/should avoid inner resizes if multigrid is not active. (But If we still do, the condition should be `!ext_multigrid` and not only `!ext_newgrid` )",
8445768,coditva,https://api.github.com/repos/neovim/neovim/pulls/8455,210883656,2018-08-17T11:42:58Z,src/nvim/api/ui.c,"@@ -270,6 +292,10 @@ static void remote_ui_grid_resize(UI *ui, Integer grid,   Array args = ARRAY_DICT_INIT;   if (ui->ui_ext[kUINewgrid]) {     ADD(args, INTEGER_OBJ(grid));+  } else if (grid != 1) {","Yes, I got that. What I meant was that `grid_resize` is listed in `ext_newgrid` functions in `ui.txt`. So, I was unsure if the check should be `ext_newgrid` or `ext_multigrid`. You said it should be `!ext_multigrid` and _not only_ `!ext_newgrid` hence the confusion. Sorry... :sweat: ",
8740057,janlazo,https://api.github.com/repos/neovim/neovim/pulls/8877,211463449,2018-08-21T02:38:02Z,src/nvim/undo.c,"@@ -2035,83 +2033,97 @@ void undo_time(long step, int sec, int file, int absolute)         uhp = curbuf->b_u_newhead;       else         uhp = uhp->uh_next.ptr;-      if (uhp == NULL || uhp->uh_walk != mark-          || (uhp->uh_seq == target && !above))+      if (uhp == NULL+          || (target > 0 && uhp->uh_walk != mark)+          || (uhp->uh_seq == target && !above)) {         break;+      }       curbuf->b_u_curhead = uhp;       u_undoredo(true, true);-      uhp->uh_walk = nomark;            // don't go back down here+      if (target > 0) {+        uhp->uh_walk = nomark;          // don't go back down here+      }     } -    /*-     * And now go down the tree (redo), branching off where needed.-     */-    while (!got_int) {-      /* Do the change warning now, for the same reason as above. */-      change_warning(0);--      uhp = curbuf->b_u_curhead;-      if (uhp == NULL)-        break;+    // When back to origin, redo is not needed.+    if (target > 0) {+      // And now go down the tree (redo), branching off where needed.+      while (!got_int) {",This entire while statement and its block scope are indented and include lint changes so it shouldn't have semantic changes.,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/8891,212829934,2018-08-26T15:27:41Z,src/nvim/ex_getln.c,"@@ -2990,7 +2990,7 @@ void ui_ext_cmdline_block_append(int indent, const char *line)   memcpy(buf + indent, line, strlen(line));  // -V575    Array item = ARRAY_DICT_INIT;-  ADD(item, DICTIONARY_OBJ((Dictionary)ARRAY_DICT_INIT));+  ADD(item, INTEGER_OBJ(0));","I guess no client is using the feature currently, but in theory should this be listed on https://github.com/neovim/neovim/wiki/Following-HEAD ?",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/8891,212830303,2018-08-26T15:41:58Z,src/nvim/api/ui.c,"@@ -519,23 +517,48 @@ static void remote_ui_cmdline_show(UI *ui, Array args)     ADD(new_item, copy_object(item.items[1]));     ADD(new_contents, ARRAY_OBJ(new_item));   }-  ADD(new_args, ARRAY_OBJ(new_contents));+  return new_contents;+}++static Array translate_firstarg(UI *ui, Array args)+{+  Array new_args = ARRAY_DICT_INIT;+  Array contents = args.items[0].data.array;++  ADD(new_args, ARRAY_OBJ(translate_contents(ui, contents)));   for (size_t i = 1; i < args.size; i++) {     ADD(new_args, copy_object(args.items[i]));   }-  push_call(ui, ""cmdline_show"", new_args);+  return new_args; }  static void remote_ui_event(UI *ui, char *name, Array args, bool *args_consumed) {   if (!ui->ui_ext[kUINewgrid]) {","Sure. ""ext_grid_rev2"" is not worse than anything else. The idea is also that UIs will in the long run typically not enable this extension per-se, as it will be implied by ext_multigrid or ext_float.Once #8455, #6619 and #7466 are all merged it might also be worth declaring some kind of ""revision"" of the ""smart ui protocol"" (we could figure some better name), in form of a flag that enables everything so far. (to avoid flag mania, and to communicate some kind of message of ""this is what an modern neovim UI looks like the end of 2018"", or something)",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/6856,213559842,2018-08-29T06:36:50Z,runtime/lua/lsp/util.lua,"@@ -1,3 +1,5 @@+local util = require('neovim.util')","Use `nvim` for technical identifiers (basically everywhere except ""marketing"" material).However I don't think we're planning to have a separate `nvim` object in Lua. There's already a `vim` object, and that's where we should put our Lua stdlib IIRC. cc @KillTheMule (Just FYI, we can do a fixup after merging this PR.)",
4466899,tjdevries,https://api.github.com/repos/neovim/neovim/pulls/6856,213661842,2018-08-29T12:48:36Z,runtime/lua/lsp/util.lua,"@@ -1,3 +1,5 @@+local util = require('neovim.util')",Sounds good on both fronts. I can always just do `local util = vim.helpers` or something like that when we're further along on both PRs.,
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/8934,214084513,2018-08-30T15:49:15Z,src/nvim/os/shell.c,"@@ -466,7 +466,7 @@ static void out_data_append_to_screen(char *output, size_t *count,       //    incomplete UTF-8 sequence that could be composing with the last       //    complete sequence.       // This will be corrected when we switch to vterm based implementation-      int i = *p ? mb_ptr2len_len((char_u *)p, (int)(end-p)) : 1;+      int i = *p ? utf_ptr2len_len((char_u *)p, (int)(end-p)) : 1;",`utfc_ptr2len_len` (and similar for all `mb_ptr2len_len` replacements),
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/8948,215159829,2018-09-05T07:21:57Z,src/nvim/ex_docmd.c,"@@ -9239,6 +9239,18 @@ static int ses_do_win(win_T *wp)   return true; } +static int put_view_curpos(FILE *fd, const win_T *wp, char *spaces)+{+  int r;++  if (wp->w_curswant == MAXCOL) {+    r = fprintf(fd, ""%snormal! $"", spaces);+  } else {+    r = fprintf(fd, ""%snormal! 0%d|"", spaces, wp->w_virtcol + 1);+  }+  return r < 0 || put_eol(fd) == FAIL ? FAIL : OK;",����  We're usually in favor of parens to reduce expression ambiguity.,
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/8963,215709743,2018-09-06T17:22:19Z,runtime/autoload/provider.vim,"@@ -19,3 +33,15 @@ function! provider#Poll(argv, orig_name, log_env) abort   endtry   throw remote#host#LoadErrorForHost(a:orig_name, a:log_env) endfunction++"" Attempts to append the lines in 'data' to file at 'log_path'+""+"" returns true if the file was written to successfully+function! s:WriteLines(orig_name, log_path, job, data, event)","you will need to set `self.stderr` to `a:data` in this function, to make the existing message on early crash still work.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/8180,216170389,2018-09-09T21:19:02Z,src/nvim/bufhl_defs.h,"@@ -14,16 +14,24 @@ typedef struct {   colnr_T stop;  // last column to highlight } BufhlItem; -typedef kvec_t(BufhlItem) BufhlItemVec;++typedef struct {+  char *text;+  int hl_id;+} EolTextChunk;","If we plan to (later) support overlays at any column (not just EOL), does it make sense to name this (and other similar identifiers) ~`TextOverlayChunk`~ `VirtualTextChunk` ?(I guess it's not an ""overlay"" since it doesn't combine with the hidden text. Instead it's just ""virtual text"" or something like that. And ""virtual"" is semantically consistent with the existing concept of `'virtualedit'`.)",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/8180,216170827,2018-09-09T21:37:19Z,src/nvim/bufhl_defs.h,"@@ -14,16 +14,24 @@ typedef struct {   colnr_T stop;  // last column to highlight } BufhlItem; -typedef kvec_t(BufhlItem) BufhlItemVec;++typedef struct {+  char *text;+  int hl_id;+} EolTextChunk;","Probably, but I would start with naming the API function properly and derive everything else from there.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/8959,216625735,2018-09-11T10:51:54Z,src/nvim/terminal.c,"@@ -1186,21 +1189,29 @@ static void refresh_scrollback(Terminal *term, buf_T *buf)   int width, height;   vterm_get_size(term->vt, &height, &width); -  while (term->sb_pending > 0) {+  if (((int)buf->b_ml.ml_line_count - height) >= (int)term->sb_size) {+    // scrollback buffer is full - delete 10% from the top+    int sb_delete = (int)term->sb_size / 10;","@danielBelenky It's wrong, but it doesn't matter right now. What matters is getting it to actually work, without failing the ASan build (the first build listed in Travis CI).",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/8754,217369479,2018-09-13T12:47:31Z,src/nvim/generators/gen_api_dispatch.lua,"@@ -128,6 +128,7 @@ for i,f in ipairs(shallowcopy(functions)) do     end     newf.impl_name = f.name     newf.remote_only = true+    newf.async = f.async",Does this affect behavior somewhere or only api_info metadata ?,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/8996,217782862,2018-09-14T17:15:35Z,src/nvim/popupmnu.c,"@@ -201,9 +201,15 @@ void pum_display(pumitem_T *array, int size, int selected, bool array_changed)     }      // If there is a preview window above, avoid drawing over it.+    // Do keep at least 10 entries.     if (pvwin != NULL && pum_row < above_row && pum_height > above_row) {",in the vim patch the condition is:    if (pvwin != NULL && pum_row < above_row && pum_height > 10)did you intentionally change it?,
12577529,rpigott,https://api.github.com/repos/neovim/neovim/pulls/8996,217804460,2018-09-14T18:32:22Z,src/nvim/popupmnu.c,"@@ -201,9 +201,15 @@ void pum_display(pumitem_T *array, int size, int selected, bool array_changed)     }      // If there is a preview window above, avoid drawing over it.+    // Do keep at least 10 entries.     if (pvwin != NULL && pum_row < above_row && pum_height > above_row) {","I did not, that's a typo. `pum_height > 10` is the correct condition in this version. ",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/8180,217927049,2018-09-16T20:39:52Z,src/nvim/screen.c,"@@ -1731,6 +1740,53 @@ static int compute_foldcolumn(win_T *wp, int col)   return fdc; } +static int line_putchar(LineState *s, schar_T *dest, int maxcells, bool rl)","well, ok. But the general idea is that following a stacktrace is easier when one sees the module prefix. Sometimes the prefix is meaningless but at least one knows the module. Not a big deal though.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/8180,217927247,2018-09-16T20:43:48Z,src/nvim/screen.c,"@@ -1731,6 +1740,53 @@ static int compute_foldcolumn(win_T *wp, int col)   return fdc; } +static int line_putchar(LineState *s, schar_T *dest, int maxcells, bool rl)","True, but currently it is a semantic prefix and not a module prefix. We could of course change this, but that would be reasonably done after (or maybe in) #8455. Though that should probably then be done by splitting `screen.c` into `grid.c` and `win_draw.c` layers...",
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/9009,218145756,2018-09-17T16:50:12Z,src/nvim/os/shell.c,"@@ -80,21 +80,49 @@ char **shell_build_argv(const char *cmd, const char *extra_args) void shell_free_argv(char **argv) {   char **p = argv;-   if (p == NULL) {     // Nothing was allocated, return     return;   }-   while (*p != NULL) {     // Free each argument     xfree(*p);     p++;   }-   xfree(argv); } +/// Joins shell arguments from `argv` into a new string.+///+/// @returns[allocated] `argv` joined to a string.+char *shell_argv_to_str(char **const argv)+  FUNC_ATTR_NONNULL_ALL+{+  size_t n = 0;+  char **p = argv;+  if (p == NULL) {+    return 0;+  }++  const size_t maxsize = 256;+  char *rv = xcalloc(maxsize, sizeof(*rv));+  while (*p != NULL && n < maxsize) {+    n += xstrlcat(rv, ""'"", maxsize);+    n += xstrlcat(rv, *p, maxsize);+    n += xstrlcat(rv, (*(p + 1) == NULL) ? ""'"" : ""' "", maxsize);","Why not always add `""' ""` at the end of a string and after the loop replace the last space with `NUL` if `n` was not too big?",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/8814,218747603,2018-09-19T10:17:23Z,src/nvim/os/input.c,"@@ -88,9 +88,9 @@ static void create_cursorhold_event(void) {   // If events are enabled and the queue has any items, this function should not   // have been called(inbuf_poll would return kInputAvail)-  // TODO(tarruda): Cursorhold should be implemented as a timer set during the+  // TODO(justinmk): Cursorhold should be implemented as a timer set during the   // `state_check` callback for the states where it can be triggered.-  assert(!events_enabled || multiqueue_empty(main_loop.events));+  assert(multiqueue_empty(main_loop.events));","Why is that? is K_EVENT regarded as a dismissive key in `wait_return`? Maybe it needs to be added to the list at `messages.c:954-966` of ""allowed"" state r keys.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/8572,219447636,2018-09-21T10:06:32Z,src/nvim/tui/tui.c,"@@ -929,12 +932,25 @@ static void tui_set_mode(UI *ui, ModeShape mode)   TUIData *data = ui->data;   cursorentry_T c = data->cursor_shapes[mode]; -  if (c.id != 0 && ui->rgb) {-    int attr = syn_id2attr(c.id);-    if (attr > 0) {-      HlAttrs *aep = syn_cterm_attr2entry(attr);-      UNIBI_SET_NUM_VAR(data->params[0], aep->rgb_bg_color);-      unibi_out_ext(ui, data->unibi_ext.set_cursor_color);+  if (ui->rgb) {","This form avoids some nesting, and diff churn:```cif (c.id != 0 && ui->rgb) {  int attr = syn_id2attr(c.id);  if (attr > 0) {    HlAttrs *aep = syn_cterm_attr2entry(attr);    if (aep->rgb_ae_attr & HL_INVERSE) {      // We reset the cursor color to the default because AFAIK it is      // impossible to directly set cursor color to inverse.  Hopefully the      // user's default cursor color is inverse.      unibi_out_ext(ui, data->unibi_ext.reset_cursor_color);    } else {      UNIBI_SET_NUM_VAR(data->params[0], aep->rgb_bg_color);      unibi_out_ext(ui, data->unibi_ext.set_cursor_color);    }  }} else if (c.id == 0) {  // Reset the cursor color to default if the user does not specify cursor  // color.  unibi_out_ext(ui, data->unibi_ext.reset_cursor_color);}```",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/9052,220438086,2018-09-26T06:24:16Z,src/nvim/tui/tui.c,"@@ -1820,6 +1838,21 @@ static void augment_terminfo(TUIData *data, const char *term,       ut, ""ext.enable_mouse"", ""\x1b[?1002h\x1b[?1006h"");   data->unibi_ext.disable_mouse = (int)unibi_add_ext_str(       ut, ""ext.disable_mouse"", ""\x1b[?1002l\x1b[?1006l"");++  if ((int)unibi_add_ext_bool(ut, ""Su"", 0)) {+      data->unibi_ext.enter_undercurl_mode = (int)unibi_add_ext_str(+          ut, ""ext.enter_undercurl_mode"", ""\x1b[4:3m"");+      data->unibi_ext.exit_undercurl_mode = (int)unibi_add_ext_str(+          ut, ""ext.exit_underline_mode"", ""\x1b[4:0m"");+      // TODO: copy from setab and replace 48 with 58?","Is this TODO just to avoid code duplication? If so, don't bother :) Otherwise the linter wants `TODO(blueyed)`.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/9049,220446558,2018-09-26T07:07:18Z,runtime/doc/test_urls.vim,"@@ -0,0 +1,68 @@+"" Test for URLs in help documents.+""+"" Opens a new window with all found URLS followed by return code from curl+"" (anything other than 0 means unreachable)+""+"" Written by Christian Brabandt.++func Test_check_URLs()+  if has(""win32"")+    echoerr ""Doesn't work on MS-Windows""","`/dev/null` might be part of the problem, but also `TestURL` calls system() which invokes a shell around `curl`, and I think the exit code of cmd.exe might not be reliable. Of course, with Nvim `system()` can be called with a list to avoid invoking a shell.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/9054,220459671,2018-09-26T07:55:31Z,runtime/autoload/provider/node.vim,"@@ -22,26 +22,27 @@ function! s:is_minimum_version(version, min_major, min_minor) abort     \         && str2nr(v_list[1]) >= str2nr(a:min_minor))) endfunction -function! s:find_node_client(package_manager) abort-  if !executable(a:package_manager)-    return ''-  endif-  let is_yarn = a:package_manager ==# 'yarn'-  let cmd = is_yarn ? 'yarn global dir' : 'npm --loglevel silent root -g'-  let global_modules_dir = get(split(system(cmd), ""\n""), 0, '')-  if v:shell_error || !isdirectory(global_modules_dir)-    return ''-  endif-  "" `yarn global dir` returns the parent of '/node_modules'.-  let global_modules_dir = is_yarn ? global_modules_dir . '/node_modules' : global_modules_dir-  if !isdirectory(global_modules_dir)-    return ''-  endif-  let entry_point = global_modules_dir . '/neovim/bin/cli.js'-  if !filereadable(entry_point)-    return ''-  endif-  return entry_point+let s:NodeHandler = {}+let s:NodeHandler.result = ''+function! s:NodeHandler.on_stdout(job_id, data, event)","You can add `yarn_opts.stdout_buffered = v:true`, then this function won't be needed, and `self.stdout` will become available in `on_exit` (same format as `data`). Analogously for stderr, if you want to check it.",
9766,blueyed,https://api.github.com/repos/neovim/neovim/pulls/9052,220521862,2018-09-26T11:19:17Z,src/nvim/tui/tui.c,"@@ -1820,6 +1838,21 @@ static void augment_terminfo(TUIData *data, const char *term,       ut, ""ext.enable_mouse"", ""\x1b[?1002h\x1b[?1006h"");   data->unibi_ext.disable_mouse = (int)unibi_add_ext_str(       ut, ""ext.disable_mouse"", ""\x1b[?1002l\x1b[?1006l"");++  if ((int)unibi_add_ext_bool(ut, ""Su"", 0)) {+      data->unibi_ext.enter_undercurl_mode = (int)unibi_add_ext_str(+          ut, ""ext.enter_undercurl_mode"", ""\x1b[4:3m"");+      data->unibi_ext.exit_undercurl_mode = (int)unibi_add_ext_str(+          ut, ""ext.exit_underline_mode"", ""\x1b[4:0m"");+      // TODO: copy from setab and replace 48 with 58?","Yes, mainly to avoid duplication, but I have not really checked if it matches the other conditionals.kitty's docs just said that it works like `38`/`48`, but terminals appear to handle this differently.It is likely ok though.",
112971,jamessan,https://api.github.com/repos/neovim/neovim/pulls/9061,220880257,2018-09-27T11:01:13Z,test/helpers.lua,"@@ -1,6 +1,7 @@ local assert = require('luassert') local luv = require('luv') local lfs = require('lfs')+local relpath = require('pl.path').relpath","Do we use pl.path already, or is this a new test dependency?",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/9052,220883553,2018-09-27T11:15:02Z,src/nvim/tui/tui.c,"@@ -521,6 +530,16 @@ static void update_attrs(UI *ui, HlAttrs attrs)   if (italic) {     unibi_out(ui, unibi_enter_italics_mode);   }+  if (undercurl || (underline && data->unibi_ext.enter_undercurl_mode)) {",`underline && data->unibi_ext.enter_undercurl_mode` looks a bit weird. Is the set of terminals which support `4:3` code identical to set of terminals that supports `58` color? Regardless this could be changed to `(undercurl || underline) && data->unibi_ext.set_underline_color` (and `undercurl` only check need not be nested) in case the detection code becomes more flexible (for terminals that support one but not the other). Also shouldn't `attrs.rgb_sp_color != -1` be checked?,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/9077,221873183,2018-10-02T08:59:08Z,src/nvim/main.c,"@@ -1715,6 +1715,48 @@ static void exe_commands(mparm_T *parmp)   TIME_MSG(""executing command arguments""); } +/// Source system-wide vimrc if built with one defined+///+/// Does one of the following things, stops after whichever succeeds:+///+/// 1. Source system vimrc file from $XDG_CONFIG_DIRS/nvim/sysinit.vim+/// 2. Source system vimrc file from $VIM+static void do_system_initialization(void)+{+  char *const config_dirs = stdpaths_get_xdg_var(kXDGConfigDirs);+  if (config_dirs != NULL) {+    const void* iter = NULL;+    const char path_tail[] = {+      'n', 'v', 'i', 'm', PATHSEP,+      's', 'y', 's', 'i', 'n', 'i', 't', '.', 'v', 'i', 'm', NUL+    };+    do {+      const char *dir;+      size_t dir_len;+      iter = vim_env_iter(':', config_dirs, iter, &dir, &dir_len);+      if (dir == NULL || dir_len == 0) {+        break;+      }+      char *vimrc = xmalloc(dir_len + sizeof(path_tail) + 1);+      memcpy(vimrc, dir, dir_len);+      vimrc[dir_len] = PATHSEP;+      memcpy(vimrc + dir_len + 1, path_tail, sizeof(path_tail));+      if (do_source((char_u  *)vimrc, false, DOSO_NONE) != FAIL) {+        xfree(vimrc);+        xfree(config_dirs);+        return;+      }+      xfree(vimrc);+    } while (iter != NULL);+  }++#ifdef SYS_VIMRC_FILE+  // Get system wide defaults, if the file name is defined.+  (void) do_source((char_u *)SYS_VIMRC_FILE, false, DOSO_NONE);","Help doc says ""Otherwise"", but this looks unconditional.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/9081,222188007,2018-10-03T05:46:11Z,src/nvim/main.c,"@@ -849,9 +850,11 @@ static void command_line_scan(mparm_T *parmp)           } else if (STRICMP(argv[0] + argv_idx, ""embed"") == 0) {             embedded_mode = true;             const char *err;-            if (!channel_from_stdio(true, CALLBACK_READER_INIT, &err)) {+            if (!did_embed","We could also do `if (embedded_mode) { channel_from_stdio(...) }` in main.c, which would be more consistent with ""listen"" for example.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/9081,222271898,2018-10-03T11:21:05Z,src/nvim/main.c,"@@ -849,9 +850,11 @@ static void command_line_scan(mparm_T *parmp)           } else if (STRICMP(argv[0] + argv_idx, ""embed"") == 0) {             embedded_mode = true;             const char *err;-            if (!channel_from_stdio(true, CALLBACK_READER_INIT, &err)) {+            if (!did_embed","No, I meant a single conditional call in `main()`, just after `command_line_scan` (makes sense to do it at the same place as `server_init`)",
9766,blueyed,https://api.github.com/repos/neovim/neovim/pulls/9090,223027527,2018-10-05T14:31:47Z,src/clint.py,"@@ -3596,6 +3604,7 @@ def ParseArguments(args):     _SetCountingStyle(counting_style)     _SuppressErrorsFrom(suppress_errors_file)     _RecordErrorsTo(record_errors_file)+    _cpplint_state.stdin_filename = stdin_filename","I did not feel like adding (two) methods just for that (following the existing pattern here), but I can change it if necessary.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/6930,223185921,2018-10-06T15:43:58Z,test/functional/ui/screen.lua,"@@ -245,6 +249,21 @@ local ext_keys = { --              ignored, throw an error (use eq() or similar) to signal failure. -- any:         Lua pattern string expected to match a screen line. -- mode:        Expected mode as signaled by ""mode_change"" event+-- unchanged:   Test that the screen state remain unchanged since the previous+--              expect(...). Any flush event resulting in a different state is+--              considered an error. Not observing any events until timeout+--              is acceptable.+-- intermediate:Test that the final state is the same as the previous expect,+--              but expect an intermediate state that is different. If possible+--              it is better to use an explicit screen:expect(...) for this+--              intermediate state.+-- redraw_bang: should be used for a test that follows immediately after a+--              command(""redraw!"") or some other mechanism that will invoke+--              redraw!. This will erase the screen internally, and check the+--              entire screen got redraw from scratch.","by ""internally"" you mean ""internal to Screen.lua""? That confused me, because it's mentioned after discussion of `redraw!` being done in Nvim itself. Maybe this is clearer:> redraw_bang: Verifies that the entire screen was redrawn, after Nvim's internal screen was cleared (e.g. after `:redraw!`).(Note that we don't need to mention that Screen.lua's state is cleared, that's an implementation detail I guess.)Instead of `redraw_bang` how about `cleared` ?  While reading the tests,  `redraw_bang` looks like a command but it's actually a description of Nvim's state (IIUC). `cleared` also has a nice parallel with the `unchanged` param.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/6930,223186883,2018-10-06T16:20:41Z,test/functional/ui/screen.lua,"@@ -245,6 +249,21 @@ local ext_keys = { --              ignored, throw an error (use eq() or similar) to signal failure. -- any:         Lua pattern string expected to match a screen line. -- mode:        Expected mode as signaled by ""mode_change"" event+-- unchanged:   Test that the screen state remain unchanged since the previous+--              expect(...). Any flush event resulting in a different state is+--              considered an error. Not observing any events until timeout+--              is acceptable.+-- intermediate:Test that the final state is the same as the previous expect,+--              but expect an intermediate state that is different. If possible+--              it is better to use an explicit screen:expect(...) for this+--              intermediate state.+-- redraw_bang: should be used for a test that follows immediately after a+--              command(""redraw!"") or some other mechanism that will invoke+--              redraw!. This will erase the screen internally, and check the+--              entire screen got redraw from scratch.","No, I mean internally to the Screen in `screen.lua`, to prove that the state is in fact retransmitted, and not just left unchanged. >  While reading the tests, redraw_bang looks like a command but it's actually a description of Nvim's state (IIUC)It is a description of the expected events in _response_ to a `redraw!` command. The nvim state is identical to before (in all present examples at least, where there is no message to clear).`cleared` is a bit misleading, as a literal clear is not checked for, only that the entire screen is retransmitted (which shouldn't require `grid_clear` even for performance, `grid_line` already supports efficient clearing of unused parts of the screen, even with `winhl=Normal` which `grid_clear` doesn't handle at all).Perhaps `reset` is better, if we want a name describing the internal operation: reset the screen back to it initial state (which includes extensions, unlike clear).",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/6930,223187065,2018-10-06T16:28:09Z,test/functional/ui/screen.lua,"@@ -245,6 +249,21 @@ local ext_keys = { --              ignored, throw an error (use eq() or similar) to signal failure. -- any:         Lua pattern string expected to match a screen line. -- mode:        Expected mode as signaled by ""mode_change"" event+-- unchanged:   Test that the screen state remain unchanged since the previous+--              expect(...). Any flush event resulting in a different state is+--              considered an error. Not observing any events until timeout+--              is acceptable.+-- intermediate:Test that the final state is the same as the previous expect,+--              but expect an intermediate state that is different. If possible+--              it is better to use an explicit screen:expect(...) for this+--              intermediate state.+-- redraw_bang: should be used for a test that follows immediately after a+--              command(""redraw!"") or some other mechanism that will invoke+--              redraw!. This will erase the screen internally, and check the+--              entire screen got redraw from scratch.","> No, I mean internally to the Screen in screen.lua, to prove that the state is in fact retransmitted, and not just left unchanged.Regardless, it's not internal to `nvim`, which is what I was confused about.> It is a description of the expected events in response to a redraw! commandYes, so `redraw_bang` is confusing for the reasons I mentioned.> cleared is a bit misleading, as a literal clear is not checked for,Some other name then.  `rebuilt` ? `reconstructed` ? Or maybe just `redrawn` is unambiguous, in the context of `Screen:expect()`.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/6930,223206053,2018-10-07T09:06:04Z,test/functional/ui/screen.lua,"@@ -245,6 +249,21 @@ local ext_keys = { --              ignored, throw an error (use eq() or similar) to signal failure. -- any:         Lua pattern string expected to match a screen line. -- mode:        Expected mode as signaled by ""mode_change"" event+-- unchanged:   Test that the screen state remain unchanged since the previous+--              expect(...). Any flush event resulting in a different state is+--              considered an error. Not observing any events until timeout+--              is acceptable.+-- intermediate:Test that the final state is the same as the previous expect,+--              but expect an intermediate state that is different. If possible+--              it is better to use an explicit screen:expect(...) for this+--              intermediate state.+-- redraw_bang: should be used for a test that follows immediately after a+--              command(""redraw!"") or some other mechanism that will invoke+--              redraw!. This will erase the screen internally, and check the+--              entire screen got redraw from scratch.","> Regardless, it's not internal to nvim, which is what I was confused about. Yes, so redraw_bang is confusing for the reasons I mentioned.I just tried to explain what I meant, I never somehow denied the existing text could be confusing. > (Note that we don't need to mention that Screen.lua's state is cleared, that's an implementation detail I guess.)Except that this precisely what this flag does. I will try to make the description more clear, but explaining what the flag does without mentioning what the flag does will not reduce confusion.>  Or maybe just redrawn is unambiguous, in the context of Screen:expect().Redraw just means redraw, which can be an incremental update,  and so is unambiguously worse than anything with ""redraw!"".",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/6856,223485713,2018-10-08T20:20:20Z,runtime/autoload/lsp/util.vim,"@@ -0,0 +1,17 @@++""""+"" A function for finding the base directory containing a file+function! lsp#util#find_root_uri(pattern) abort","How about adding this to `eval.c` ? Or at least, keep it private until then. We should not be creating a VimL utility library separate from `nvim` itself--this doesn't make sense for users.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/6856,223486421,2018-10-08T20:22:59Z,runtime/lua/lsp/config/autocmds.lua,"@@ -0,0 +1,14 @@+local autocmds = require('lsp.autocmds')","`lsp/config/autocmds.lua` is too much nesting. `lsp/config.lua` should be enough--if it gets too big that suggests we didn't factor out enough common utilities into `nvim` stdlib.(But really, I secretly advocate going further: `lsp.lua` should be enough! If it gets too big, it must have lots of utilities that should be in the `nvim` stdlib.)",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/8919,224728096,2018-10-12T09:38:12Z,src/nvim/ex_cmds.c,"@@ -2201,7 +2202,12 @@ int do_ecmd(             | ((flags & ECMD_FORCEIT) ? CCGD_FORCEIT : 0)             | (eap == NULL ? 0 : CCGD_EXCMD))) {     if (fnum == 0 && other_file && ffname != NULL)-      (void)setaltfname(ffname, sfname, newlnum < 0 ? 0 : newlnum);+      savingpath = (void)setaltfname(ffname, sfname, newlnum < 0 ? 0 : newlnum);+      for (int i = 0; i < strlen(savingpath); i++) {+        if (savingpath[i] == '/' && savingpath[i+1] == '/') {+          savingpath[i] = savingpath[i+1] = '';","This line is outright incorrect, you can���t remove symbol by assigning `''` and even if you did this code removes two symbols. Also `strlen(savingpath)` must not be in cycle condition, you do such things by checking `savingpath[i]` for being zero. Assigning `void` to `char *` is never going to work too, I can see this forcing compiler to error out even without other errors (though I have not actually checked CI logs).And as I said in original issue there still is at least one case when double slash *must* be preserved in what is a regular path (not handled by `*Cmd` commands). Also not familiar with code enough to say whether files like `http://���` will trigger this code, but they definitely must not. And it does not look like a correct location for the code for regular paths either, what is displayed in statusline has something to do with `buf->b_*fname` and this is not where they are defined.",
6820152,miseran,https://api.github.com/repos/neovim/neovim/pulls/9113,224903345,2018-10-12T20:16:15Z,src/nvim/sign_defs.h,"@@ -9,17 +9,18 @@ typedef struct signlist signlist_T;  struct signlist {-    int id;             /* unique identifier for each placed sign */-    linenr_T lnum;      /* line number which has this sign */-    int typenr;         /* typenr of sign */-    signlist_T *next;   /* next signlist entry */+    int id;             // unique identifier for each placed sign+    linenr_T lnum;      // line number which has this sign+    int typenr;         // typenr of sign+    signlist_T *next;   // next signlist entry }; -/* type argument for buf_getsigntype() */-#define SIGN_ANY	0-#define SIGN_LINEHL	1-#define SIGN_ICON	2-#define SIGN_TEXT	3+// type argument for buf_getsigntype()+#define SIGN_ANY     0+#define SIGN_LINEHL  1+#define SIGN_ICON    2+#define SIGN_TEXT    3+#define SIGN_NUMHL   4","Done, although I'm not sure what the naming convention for enums is supposed to be. It's not so consistent.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/9113,224966629,2018-10-13T17:39:31Z,src/nvim/ex_cmds.c,"@@ -5920,23 +5934,35 @@ static void sign_undefine(sign_T *sp, sign_T *sp_prev)  /*  * Get highlighting attribute for sign ""typenr"".- * If ""line"" is TRUE: line highl, if FALSE: text highl.+ * Gets the highlight corresponding to ""type"", which should be+ * SIGN_TEXT, SIGN_LINEHL or SIGN_NUMHL.",One advantage of an enum is that it removes the need to list such things explicitly in docstrings. And if this only accepts a subset that should be checked with assert() or abort() instead.,
8740057,janlazo,https://api.github.com/repos/neovim/neovim/pulls/9049,224969604,2018-10-13T19:21:46Z,scripts/test_urls.vim,"@@ -0,0 +1,68 @@+"" Test for URLs in help documents.+""+"" Opens a new window with all found URLS followed by return code from curl+"" (anything other than 0 means unreachable)+""+"" Written by Christian Brabandt.++func Test_check_URLs()",It should start a job for every curl request to accomodate long downloads. I stopped the test midway when I ran the test without passing `-u NONE`.,
8740057,janlazo,https://api.github.com/repos/neovim/neovim/pulls/9049,224969650,2018-10-13T19:23:28Z,scripts/vim-patch.sh,"@@ -179,6 +179,16 @@ preprocess_patch() {   # Rename path to matchit plugin.   LC_ALL=C sed -e 's@\( [ab]/runtime\)/pack/dist/opt/matchit/\(plugin/matchit.vim\)@\1/\2@g' \     ""$file"" > ""$file"".tmp && mv ""$file"".tmp ""$file""+  LC_ALL=C sed -e 's@\( [ab]/runtime\)/pack/dist/opt/matchit/\(doc/matchit.txt\)@\1/\2@g' \+    ""$file"" > ""$file"".tmp && mv ""$file"".tmp ""$file""",I don't see that file in vim-patch surgery. Is that handled in a separate script?,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/9049,224970812,2018-10-13T20:10:14Z,scripts/vim-patch.sh,"@@ -179,6 +179,16 @@ preprocess_patch() {   # Rename path to matchit plugin.   LC_ALL=C sed -e 's@\( [ab]/runtime\)/pack/dist/opt/matchit/\(plugin/matchit.vim\)@\1/\2@g' \     ""$file"" > ""$file"".tmp && mv ""$file"".tmp ""$file""+  LC_ALL=C sed -e 's@\( [ab]/runtime\)/pack/dist/opt/matchit/\(doc/matchit.txt\)@\1/\2@g' \+    ""$file"" > ""$file"".tmp && mv ""$file"".tmp ""$file""","Try to keep the pattern less clever. E.g. instead of making `doc` a group and then referencing it with `\2`, just write `doc` literally in the replacement.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/9100,225262042,2018-10-15T18:01:10Z,src/nvim/api/window.c,"@@ -33,6 +34,44 @@ Buffer nvim_win_get_buf(Window window, Error *err)   return win->w_buffer->handle; } +/// Sets the current buffer in a window. This allows switching the buffer of+/// any window from within any other window without triggering side effects+/// usually associated with switching between windows, such as triggering+/// autocommands.+///+/// @param window   Window handle+/// @param buffer   Buffer handle+/// @param[out] err Error details, if any+void nvim_win_set_buf(Window window, Buffer buffer, Error *err)+  FUNC_API_SINCE(5)+{+  win_T *win = find_window_by_handle(window, err), *save_curwin = curwin;+  buf_T *buf = find_buffer_by_handle(buffer, err);+  tabpage_T *tab = win_find_tabpage(win), *save_curtab = curtab;++  if (!win || !buf) {+      return;+  }++  if (switch_win(&save_curwin, &save_curtab, win, tab, false) == FAIL) {+    api_set_error(err,+                  kErrorTypeException,+                  ""Failed to switch to window %d"",+                  window);","Should also test the failure modes (including the `!win || !buf` case above).  In the past we've had hidden bugs until we added test cases for failure modes.(**Edit:** I'm not sure when `Failed to switch to window %` error would happen, it might not be possible to test that.)It's easy to test the error cases using `expect_err()`. See for example: https://github.com/neovim/neovim/blob/8fd092f3ff15bf70f84ec0d716c5aaa2c7379fa1/test/functional/api/vim_spec.lua#L28                               Example:    expect_err('error message', window, 'set_buf', 99942, 23423)",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/9130,225793723,2018-10-17T06:31:43Z,third-party/cmake/BuildLuajit.cmake,"@@ -50,8 +50,15 @@ set(INSTALLCMD_UNIX ${MAKE_PRG} CFLAGS=-fPIC                                 install)  if(UNIX)+  if(CMAKE_SYSTEM_NAME STREQUAL ""Darwin"")+    set(DEPLOYMENT_TARGET ""MACOSX_DEPLOYMENT_TARGET=${CMAKE_OSX_DEPLOYMENT_TARGET}"")",add a comment:```# Set MACOSX_DEPLOYMENT_TARGET (else luajit defaults to 10.4). #9050# https://github.com/LuaJIT/LuaJIT/blob/b025b01c5b9d23f6218c7d72b7aafa3f1ab1e08a/src/Makefile#L301-L303```,
606923,mqudsi,https://api.github.com/repos/neovim/neovim/pulls/8378,226725803,2018-10-19T17:34:24Z,runtime/autoload/provider/node.vim,"@@ -65,31 +55,42 @@ function! provider#node#Detect() abort     return ''   endif -  let yarn_subpath = '/node_modules/neovim/bin/cli.js'-  let npm_subpath = '/neovim/bin/cli.js'--  "" `yarn global dir` is slow (> 250ms), try the default path first-  if filereadable('$HOME/.config/yarn/global' . yarn_subpath)-      return '$HOME/.config/yarn/global' . yarn_subpath-  end+  let npm_opts = {}+  if executable('npm')+    let npm_opts = deepcopy(s:NodeHandler)+    let npm_opts.entry_point = '/neovim/bin/cli.js'+    let npm_opts.job_id = jobstart('npm --loglevel silent root -g', npm_opts)+  endif -  "" try both npm and yarn simultaneously-  let yarn_opts = s:NodeHandler.new()-  let yarn_opts.entry_point = yarn_subpath-  let yarn_opts.job_id = jobstart(['yarn', 'global', 'dir'], yarn_opts)-  let npm_opts = s:NodeHandler.new()-  let npm_opts.entry_point = npm_subpath-  let npm_opts.job_id = jobstart(['npm', '--loglevel', 'silent', 'root', '-g'], npm_opts)+  let yarn_opts = {}+  if executable('yarn')+    let yarn_opts = deepcopy(s:NodeHandler)+    let yarn_opts.entry_point = '/node_modules/neovim/bin/cli.js'+    "" `yarn global dir` is slow (> 250ms), try the default path first+    "" XXX: The following code is not portable+    "" https://github.com/yarnpkg/yarn/issues/2049#issuecomment-263183768+    if has('unix')+      let yarn_default_path = $HOME . '/.config/yarn/global/' . yarn_opts.entry_point","fwiw it's technically not non-portable code, as it'll still run without erroring on non-unix but not wind up taking the fast path.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/9141,226810158,2018-10-20T00:46:33Z,src/nvim/tui/tui.c,"@@ -1857,7 +1857,7 @@ static void augment_terminfo(TUIData *data, const char *term,               ut, ""ext.set_underline_color"", ""\x1b[58:2:%p1%d:%p2%d:%p3%dm"");       } else {           data->unibi_ext.set_underline_color = (int)unibi_add_ext_str(-              ut, ""ext.set_underline_color"", ""\x1b[58:2:%p1%d:%p2%d:%p3%dm"");+              ut, ""ext.set_underline_color"", ""\x1b[58;2;%p1%d;%p2%d;%p3%dm"");",@blueyed I'm a bit surprised that this worked before. The terminal(s) you use support colon parameters?,
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/9146,226880882,2018-10-21T22:24:48Z,src/nvim/eval/typval_encode.c.h,"@@ -741,6 +741,7 @@ TYPVAL_ENCODE_SCOPE int _TYPVAL_ENCODE_ENCODE(       case kMPConvPartial: {         partial_T *const pt = cur_mpsv->data.p.pt;         tv = cur_mpsv->tv;+        (void)tv;         switch (cur_mpsv->data.p.stage) {           case kMPConvPartialArgs: {             TYPVAL_ENCODE_CONV_FUNC_BEFORE_ARGS(tv,","Many of those `tv` parameters are there for consistency reasons: better have and not need then not have and refactor 100500 macros definitions when next encoder appears to need them (or, rather, not them, but some other data extracted from `tv`: many of the macros accept a pair of `tv` and preextracted data). Also AFAIR they allowed putting debugging prints which is better reason for their existence as some macros simply receive `NULL` as `tv` and some are unlikely to need `tv` as you e.g. would not really need it to dump what is between list items: there hardly is any format which will require writing something like `{'foo', [3]'bar', [3]'baz'}` (where `foo` goes without array length and `bar` goes with: what else could you use `tv` for in position where you dump commas given that said `tv` points to list itself and not list entry?).",
9766,blueyed,https://api.github.com/repos/neovim/neovim/pulls/9141,226908972,2018-10-22T06:34:39Z,src/nvim/tui/tui.c,"@@ -1857,7 +1857,7 @@ static void augment_terminfo(TUIData *data, const char *term,               ut, ""ext.set_underline_color"", ""\x1b[58:2:%p1%d:%p2%d:%p3%dm"");       } else {           data->unibi_ext.set_underline_color = (int)unibi_add_ext_str(-              ut, ""ext.set_underline_color"", ""\x1b[58:2:%p1%d:%p2%d:%p3%dm"");+              ut, ""ext.set_underline_color"", ""\x1b[58;2;%p1%d;%p2%d;%p3%dm"");","@justinmk Good catch. Yes, kitty appears to use colon parameters then.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/9180,229993279,2018-11-01T10:09:29Z,src/nvim/api/buffer.c,"@@ -491,6 +491,37 @@ void nvim_buf_set_lines(uint64_t channel_id,   try_end(err); } +/// Return the byte offset for a line.+//+/// This includes the end-of-line character, depending on the 'fileformat'+/// option for the current buffer.  The first line returns 0.+/// UTF-8 encoding is used, 'fileencoding' is ignored.+/// Sending in the index just below the last line gives+/// the total byte count for the entire file. A final newline+/// will be included if it would be written, see |eol|.+///+/// Unlike |line2byte|, throws error for out-of-bounds indexing.+///+/// @param buffer     Buffer handle+/// @param index      Line index+/// @param[out] err   Error details, if any+/// @return Integer   Byte offset+Integer nvim_buf_get_offset_for_line(Buffer buffer, Integer index, Error *err)+  FUNC_API_SINCE(5)+{+  buf_T *buf = find_buffer_by_handle(buffer, err);+  if (!buf) {+    return 0;+  }++  if (index < 0 || index > buf->b_ml.ml_line_count) {+    api_set_error(err, kErrorTypeValidation, ""Index out of bounds"");",Should we also return a sentinel for unloaded buffer? https://github.com/neovim/neovim/blob/ff5ab82c55be76338f8bdfbff8047796c7b33e3c/src/nvim/api/buffer.c#L247,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/9183,230162829,2018-11-01T19:11:16Z,src/nvim/api/buffer.c,"@@ -493,11 +493,10 @@ void nvim_buf_set_lines(uint64_t channel_id,  /// Return the byte offset for a line. //-/// This includes the end-of-line character, depending on the 'fileformat'-/// option for the current buffer. The first line returns 0. UTF-8 encoding is-/// used, 'fileencoding' is ignored. Sending in the index just below the last-/// line gives the total byte count for the entire file. A final newline is-/// included if it would be written, see 'eol'.+/// The first line returns 0. UTF-8 bytes are counted, and newline counts as+/// one byte. 'fileformat' and 'fileencoding' are ignored. Sending in the","I think it's a bit ambiguous-sounding for most people who aren't used to thinking about details of line-endings. See my latest edit, I think it's worth explicitly saying what happens when fileformat is dos vs unix (which is counterintuitive to ""ignored"": the result changes when 'fileformat' changes!)",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/9183,230172023,2018-11-01T19:42:14Z,src/nvim/api/buffer.c,"@@ -493,11 +493,10 @@ void nvim_buf_set_lines(uint64_t channel_id,  /// Return the byte offset for a line. //-/// This includes the end-of-line character, depending on the 'fileformat'-/// option for the current buffer. The first line returns 0. UTF-8 encoding is-/// used, 'fileencoding' is ignored. Sending in the index just below the last-/// line gives the total byte count for the entire file. A final newline is-/// included if it would be written, see 'eol'.+/// The first line returns 0. UTF-8 bytes are counted, and newline counts as+/// one byte. 'fileformat' and 'fileencoding' are ignored. Sending in the","With this change, the function _unambiguously_ and always represents the actual state of the buffer, independently of the value of `fileformat`, or `fileencoding`, or any arbitrary transformation that `charconvert` or `BufWriteCmd` are free to do between the internal state and the written bytes on the disk.""EOL counts as one byte, thus CRLF counts as 1 byte if fileformat=dos and 2 bytes if fileformat=unix."" is misleading and irrelevant, because changing `fileformat` will never change change how this function counts bytes in a buffer. It changes what buffer contents a `:read` operation results in, and it changes what `:write` writes disk from a given buffer (together with a lot of other factors), it doesn't change how this function behaves.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/9183,230172513,2018-11-01T19:43:48Z,test/functional/api/buffer_spec.lua,"@@ -301,37 +301,37 @@ describe('api/buf', function()     end)   end) -  describe('get_offset_for_line', function()-    local get_offset_for_line = curbufmeths.get_offset_for_line+  describe('get_offset', function()+    local get_offset = curbufmeths.get_offset     it('works', function()       curbufmeths.set_lines(0,-1,true,{'Some','exa\000mple', '', 'text'})","Literal `'\r\n'` is not possible, but I could do `\r` in the middle of a line and at the end of a line.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/9197,230966337,2018-11-06T00:40:31Z,CMakeLists.txt,"@@ -368,7 +368,7 @@ include_directories(SYSTEM ${MSGPACK_INCLUDE_DIRS}) option(PREFER_LUA ""Prefer Lua over LuaJIT in the nvim executable."" OFF)  if(PREFER_LUA)-  find_package(Lua REQUIRED)+  find_package(Lua 5.1 EXACT REQUIRED)","Sigh. Well that makes `EXACT` pretty useless. There doesn't seem to be a way to specify a range.Thanks for the note, fixed in 5320eb57df01",
8740057,janlazo,https://api.github.com/repos/neovim/neovim/pulls/9245,234407314,2018-11-17T12:45:27Z,src/nvim/testdir/test_ruby.vim,"@@ -0,0 +1,59 @@+"" Tests for ruby interface++if !has('ruby')+  finish+end++func Test_ruby_change_buffer()+  call setline(line('$'), ['1 line 1'])+  ruby Vim.command(""normal /^1\n"")+  ruby $curbuf.line = ""1 changed line 1""+  call assert_equal('1 changed line 1', getline('$'))+endfunc++func Test_ruby_evaluate_list()+  call setline(line('$'), ['2 line 2'])+  ruby Vim.command(""normal /^2\n"")+  let l = [""abc"", ""def""]+  ruby << EOF+  curline = $curbuf.line_number+  l = Vim.evaluate(""l"");+  $curbuf.append(curline, l.join(""\n""))+EOF","```Caught exception in Test_ruby_evaluate_list(): Vim(return):RuntimeError: String cannot contain newlines @ function RunTheTest[35]..Test_ruby_evaluate_list[8]..provider#ruby#Call, line 17```",
8740057,janlazo,https://api.github.com/repos/neovim/neovim/pulls/9245,234407345,2018-11-17T12:46:32Z,src/nvim/testdir/test_ruby.vim,"@@ -0,0 +1,59 @@+"" Tests for ruby interface++if !has('ruby')+  finish+end++func Test_ruby_change_buffer()+  call setline(line('$'), ['1 line 1'])+  ruby Vim.command(""normal /^1\n"")+  ruby $curbuf.line = ""1 changed line 1""+  call assert_equal('1 changed line 1', getline('$'))+endfunc++func Test_ruby_evaluate_list()+  call setline(line('$'), ['2 line 2'])+  ruby Vim.command(""normal /^2\n"")+  let l = [""abc"", ""def""]+  ruby << EOF+  curline = $curbuf.line_number+  l = Vim.evaluate(""l"");+  $curbuf.append(curline, l.join(""\n""))+EOF+  normal j+  .rubydo $_ = $_.gsub(/\n/, '/')+  call assert_equal('abc/def', getline('$'))+endfunc++func Test_ruby_evaluate_dict()+  let d = {'a': 'foo', 'b': 123}+  redir => l:out+  ruby d = Vim.evaluate(""d""); print d+  redir END+  call assert_equal(['{""a""=>""foo"", ""b""=>123}'], split(l:out, ""\n""))+endfunc++func Test_rubydo()+  "" Check deleting lines does not trigger ml_get error.+  new+  call setline(1, ['one', 'two', 'three'])+  rubydo Vim.command(""%d_"")","```Caught exception in Test_rubydo(): Vim(return):RuntimeError: Index out of bounds @ function RunTheTest[35]..Test_rubydo[4]..provider#ruby#Call, line 17```",
8740057,janlazo,https://api.github.com/repos/neovim/neovim/pulls/9245,234447253,2018-11-18T14:32:37Z,src/nvim/testdir/test_ruby.vim,"@@ -0,0 +1,67 @@+"" Tests for ruby interface++if !has('ruby')+  finish+end++func Test_ruby_change_buffer()+  call setline(line('$'), ['1 line 1'])+  ruby Vim.command(""normal /^1\n"")+  ruby $curbuf.line = ""1 changed line 1""+  call assert_equal('1 changed line 1', getline('$'))+endfunc++func Test_ruby_evaluate_list()+  call setline(line('$'), ['2 line 2'])+  ruby Vim.command(""normal /^2\n"")+  let l = [""abc"", ""def""]+  ruby << EOF+  curline = $curbuf.line_number+  l = Vim.evaluate(""l"");+  $curbuf.append(curline, l.join(""\n""))+EOF+  normal j+  .rubydo $_ = $_.gsub(/\n/, '/')+  call assert_equal('abc/def', getline('$'))+endfunc++func Test_ruby_evaluate_dict()+  let d = {'a': 'foo', 'b': 123}+  redir => l:out+  ruby d = Vim.evaluate(""d""); print d+  redir END+  call assert_equal(['{""a""=>""foo"", ""b""=>123}'], split(l:out, ""\n""))+endfunc++func Test_ruby_evaluate_special_var()+  let l = [v:true, v:false, v:null, v:none]","```Found errors in Test_ruby_evaluate_special_var():Caught exception in Test_ruby_evaluate_special_var(): Vim(let):E121: Undefined variable: v:none @ function RunTheTest[35]..Test_ruby_evaluate_special_var, line 1````v:none` removed in https://github.com/neovim/neovim/pull/4131",
8740057,janlazo,https://api.github.com/repos/neovim/neovim/pulls/9245,234839398,2018-11-20T01:11:36Z,src/nvim/testdir/test_ruby.vim,"@@ -0,0 +1,59 @@+"" Tests for ruby interface++if !has('ruby')+  finish+end++func Test_ruby_change_buffer()+  call setline(line('$'), ['1 line 1'])+  ruby Vim.command(""normal /^1\n"")+  ruby $curbuf.line = ""1 changed line 1""+  call assert_equal('1 changed line 1', getline('$'))+endfunc++func Test_ruby_evaluate_list()+  call setline(line('$'), ['2 line 2'])+  ruby Vim.command(""normal /^2\n"")+  let l = [""abc"", ""def""]+  ruby << EOF+  curline = $curbuf.line_number+  l = Vim.evaluate(""l"");+  $curbuf.append(curline, l.join(""\n""))+EOF+  normal j+  .rubydo $_ = $_.gsub(/\n/, '/')+  call assert_equal('abc/def', getline('$'))+endfunc++func Test_ruby_evaluate_dict()+  let d = {'a': 'foo', 'b': 123}+  redir => l:out+  ruby d = Vim.evaluate(""d""); print d+  redir END+  call assert_equal(['{""a""=>""foo"", ""b""=>123}'], split(l:out, ""\n""))+endfunc++func Test_rubydo()+  "" Check deleting lines does not trigger ml_get error.+  new+  call setline(1, ['one', 'two', 'three'])+  rubydo Vim.command(""%d_"")",I don't know how else to reproduce this behavior. Can you check if this test changes in https://github.com/vim/vim/commit/edd6aacb010ad2402fc98f19e7f6b7c29ba2656f#diff-2fab172276514dfe2a1e9299e003e940?I can't add this patch yet. I'd rather keep the exception until all patches for `test_ruby.vim` are ready for review.,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/9257,234935414,2018-11-20T09:56:51Z,runtime/autoload/health/provider.vim,"@@ -410,28 +412,34 @@ function! s:check_python(version) abort       call health#report_warn('Python 3.3+ is recommended.')     endif -    call health#report_info('Python'.a:version.' version: ' . pyversion)+    call health#report_info('Python version: ' . pyversion)     if s:is_bad_response(status)-      call health#report_info(printf('%s-neovim version: %s (%s)', pyname, current, status))+      call health#report_info(printf('pynvim version: %s (%s)', current, status))     else-      call health#report_info(printf('%s-neovim version: %s', pyname, current))+      call health#report_info(printf('pynvim version: %s', current))+      let [module_found, _msg] = provider#pythonx#CheckForModule(python_bin,+            \ 'neovim', a:version)+      if !module_found+        call health#report_error('Importing ""neovim"" failed.',+              \ [pip .' uninstall pynvim neovim',+              \  pip .' install pynvim',+              \  pip .' install neovim # only if needed by third-party software'])","If this is part of a single ADVICE you can use newlines instead of separate items.    pip ."" uninstall pynvim neovim\n"". pip ."" install pynvim\n"" ...Separate ADVICE items are alternative, independent solutions.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/9272,236085530,2018-11-25T18:59:18Z,src/nvim/api/vim.c,"@@ -848,6 +848,24 @@ void nvim_set_current_win(Window window, Error *err)   } } +/// Create new empty buffer+///+/// @param listed whether the buffer should be listed+/// @param[out] err Error details, if any+/// @return the buffer handle or 0 when error+Buffer nvim_create_buf(Boolean listed, Error *err)+  FUNC_API_SINCE(5)+{+  try_start();+  Buffer buffer = buflist_add(NULL, listed ? BLN_LISTED : 0);","include `BLN_NOOPT` to be explicit?Also just noticed we have not merged `BLN_NEW`, maybe it's useful. It's used in Vim for `term_start`:```c        /* Create a new buffer without a window. Make it the current buffer for         * a moment to be able to do the initialisations. */                      buf = buflist_new((char_u *)"""", NULL, (linenr_T)0,                                                         BLN_NEW | BLN_LISTED);```",
189413,aktau,https://api.github.com/repos/neovim/neovim/pulls/6856,236182067,2018-11-26T09:47:21Z,runtime/lua/lsp/autocmds.lua,"@@ -0,0 +1,100 @@+-- This file contains a table of all the functions that should be fired via autocmds.+-- The table is set up such that:+-- {+--   'request/name' : {'BufWritePre', {'User', 'LSPRequestName'}}+-- }+--+-- Also has a function to setup all the autocommands++-- local requests = require('runtime.lua.lsp.request').requests+local log = require('runtime.lua.log')+local util = require('runtime.lua.builtin_util')+++local autocmd_table = {+  ['textDocument/didOpen'] = {+    -- After initialization, make sure to tell the LSP that we opened the file+    {'User', 'LSP/initialize/post'},+    'BufReadPost',+  },++  ['textDocument/didSave'] = {+    'BufWritePost',+  },++  -- TODO: Not too familiar with close autocommands+  ['textDocument/didClose'] = {+    'BufDelete',+    'BufWipeout',+  },++  ['textDocument/didChange'] = {+    'InsertLeave',+  },+}++local accepted_autocomand_postfixes = {+  pre = true,+  post = true,+}++local doautocmd = function(autocmd)+  if vim == nil or vim.api == nil then+    return nil+  end++  if type(autocmd) ~= 'string' then+    return nil+  end++  -- TODO: Was having problem with errors here... remove the silent for awhile to see why+  return vim.api.nvim_command('silent! doautocmd User ' .. autocmd)+end++local lsp_doautocmd = function(method, stage)+  if not accepted_autocomand_postfixes[stage] then+    return nil+  end++  local method_name+  if type(method) == 'string' then+    method_name = method+  elseif type(method) == 'table' then+    method_name = table.concat(method, '/')+  else+    log.info('Unknown method type: ' .. util.tostring(method))+    method_name = 'UNKNOWN'+  end++  doautocmd(method_name .. '/' .. stage)+end++local export_autocmds = function()+  local autocmd_string+  for request_name, autocmd_list in ipairs(autocmd_table) do+    for _, autocmd_item in ipairs(autocmd_list) do+      if type(autocmd_item) == 'string' then+        autocmd_string = autocmd_item .. ' *'+      elseif type(autocmd_item == 'table') then+        autocmd_string = table.concat(autocmd_item, ' ')+      else+        -- TODO: Error out here or something+        autocmd_string = ''+      end++      if #autocmd_string > 0 then+        vim.api.nvim_command(+          string.format(+            [[autocmd %s call luaeval(""require('lsp.plugin').client.request('%s')"")]],+            autocmd_string, request_name)+          )+      end+    end+  end+end++return {+  default_autocmd_table = autocmd_table,+  export_autocmds = export_autocmds,+  lsp_doautocmd = lsp_doautocmd,","You use two stylistically different method of declaring a module:1. An anonymous object containing anonymous (private) functions. And:2. A named object (like `log`) to which you directly assign functions `log.write_file`.IMHO it's better to be consistent in these things within one source tree. Some articles about different ways to do this:- https://hisham.hm/2014/01/02/how-to-write-lua-modules-in-a-post-module-world/- https://blog.separateconcerns.com/2014-01-03-lua-module-policy.html (which discusses the former article)The latter articles approach (return anon table at the end) has the following advantages:- Resists internal monkeypatching (though user can still change the actual object)- In-module calls do not need table lookup, (very) small speed increaseWhile Hisham's approach has:- More searchable module functions (e.g.: I could grep for `bar.say`, the way I would call it in users of the module too)",
189413,aktau,https://api.github.com/repos/neovim/neovim/pulls/6856,236183597,2018-11-26T09:51:41Z,runtime/lua/json.lua,"@@ -0,0 +1,383 @@+--+-- json.lua+--+-- Copyright (c) 2015 rxi+--+-- This library is free software; you can redistribute it and/or modify it+-- under the terms of the MIT license. See LICENSE for details.+--+-- Taken from: https://github.com/rxi/json.lua+--++local json = { _version = ""0.1.0"" }","One very important think to take into account: if this is just an implementation detail (and say we'd use the native nvim functionality later), we must do our best to hide this from other Lua plugins.Otherwise, people will start relying on it and we will forever be forced to carry some external Lua plugin inside of our runtime folder, which may not be desirable.Also, suppose there are small inconsistencies between the ways in which this module serialized json vs. native nvim, then users will be scratching their heads as to why it isn't the same. Which doesn't seem ideal.",
189413,aktau,https://api.github.com/repos/neovim/neovim/pulls/6856,236184911,2018-11-26T09:55:13Z,runtime/lua/lsp/client.lua,"@@ -0,0 +1,342 @@+local json = require('runtime.lua.json')+local util = require('runtime.lua.builtin_util')++local protocol = require('runtime.lua.lsp.protocol')+local message = require('runtime.lua.lsp.message')+local lsp_doautocmd = require('runtime.lua.lsp.autocmds').lsp_doautocmd+local get_callback_function = require('runtime.lua.lsp.callbacks').get_callback_function++local log = require('runtime.lua.lsp.lsp').log++local read_state = {+  init = 0,+  header = 1,+  body = 2,+}++local error_level = {+  critical = 0,+  reset_state = 1,+  info = 2,+}+++local active_jobs = {}++active_jobs.add = function(id, obj)+  active_jobs[id] = obj+end++active_jobs.remove = function(id)+  active_jobs[id] = nil+end++local client = {}+client.__index = client++client.job_stdout = function(id, data)+  if active_jobs[id] == nil then+    return+  end++  active_jobs[id]:on_stdout(data)+end+client.new = function(name, ft, cmd, args)+  log.trace('Starting new client: ' .. name)++  -- TODO: I'm a little concerned about the milliseconds after starting up the job.+  -- Not sure if we'll register ourselves faster than we will get stdin or out that we want...+  local job_id = vim.api.nvim_call_function('lsp#job#start', {cmd, args})++  local self = setmetatable({+    job_id = job_id,++    name = name,+    ft = ft,+    cmd = cmd,+    args = args,++    -- State for handling messages+    _read_state = read_state.init,+    _read_data = '',+    _current_header = {},++    -- Results & Callback handling+    --  Callbacks must take two arguments:+    --      1 - success: true if successful, false if error+    --      2 - data: corresponding data for the message+    _callbacks = {},+    _results = {},+  }, client)++  active_jobs.add(job_id, self)++  return self+end+client.initialize = function(self)","Newline between functions?Perhaps we should converge on some standard formatter so we don't get bikeshedding wars? I found two:- https://github.com/trixnz/lua-fmt- https://github.com/CurtisFenner/luafmtOf which the second seems low-dependency (only Lua itself), while the first seems a bit more mature (but written in TypeScript).The reason I suggest this is because I find gofmt very liberating when coding in Go. I haven't tried any of them, btw.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/9028,236405831,2018-11-26T20:02:33Z,src/nvim/screen.c,"@@ -3052,9 +3052,11 @@ win_line (           diff_hlf = HLF_CHD;                   // changed line         }         line_attr = win_hl_attr(wp, diff_hlf);-        // Overlay CursorLine onto diff highlight, unless it's low-priority.-        if (!line_attr_lowprio && wp->w_p_cul && lnum == wp->w_cursor.lnum) {-          line_attr = hl_combine_attr(line_attr, win_hl_attr(wp, HLF_CUL));+        // Overlay CursorLine onto diff-mode highlight.+        if (wp->w_p_cul && lnum == wp->w_cursor.lnum) {+          line_attr = 0 != line_attr_lowprio  // Low-priority CursorLine+            ? hl_combine_attr(line_attr, hl_get_underline())","@bfredl Thanks. That effectively hides the CursorLine with the use-case given above, but maybe we could do that + add underline. The idea is to have something that's visible without being unreadable.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/9028,236458987,2018-11-26T22:51:19Z,src/nvim/screen.c,"@@ -3052,9 +3052,11 @@ win_line (           diff_hlf = HLF_CHD;                   // changed line         }         line_attr = win_hl_attr(wp, diff_hlf);-        // Overlay CursorLine onto diff highlight, unless it's low-priority.-        if (!line_attr_lowprio && wp->w_p_cul && lnum == wp->w_cursor.lnum) {-          line_attr = hl_combine_attr(line_attr, win_hl_attr(wp, HLF_CUL));+        // Overlay CursorLine onto diff-mode highlight.+        if (wp->w_p_cul && lnum == wp->w_cursor.lnum) {+          line_attr = 0 != line_attr_lowprio  // Low-priority CursorLine+            ? hl_combine_attr(line_attr, hl_get_underline())"," @justinmk How could `hl_combine_attr(win_hl_attr(wp, HLF_CUL), line_attr)`  ""effectively hide underline"" in any way that `hl_combine_attr(line_attr, hl_get_underline())` doesn't? The former will include _any_ attribute that CursorLine contains.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/9291,237988819,2018-11-30T20:12:22Z,test/functional/ui/cmdline_spec.lua,"@@ -120,43 +120,43 @@ local function test_cmdline(linegrid)       screen:try_resize(50,10)       feed(':echoerr doesnotexist<cr>')       screen:expect{grid=[[-                                                          |+        ^                                                  |+        {1:~                                                 }|+        {1:~                                                 }|         {1:~                                                 }|         {1:~                                                 }|         {1:~                                                 }|         {1:~                                                 }|         {1:~                                                 }|-        {3:                                                  }|+        {3:n                                                 }|         {4:E121: Undefined variable: doesnotexist}            |-        {4:E15: Invalid expression: doesnotexist}             |-        {5:Press ENTER or type command to continue}^           |       ]]}","@bfredl are these tests still semantically valid? Looks like they don't ""scroll"" now.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/9306,239997899,2018-12-08T08:14:21Z,test/functional/diff/screen_spec.lua,"@@ -0,0 +1,515 @@+local lfs = require('lfs')+local helpers = require('test.functional.helpers')(after_each)+local Screen = require('test.functional.ui.screen')++local eq = helpers.eq+local feed = helpers.feed+local eval = helpers.eval+local clear = helpers.clear+local funcs = helpers.funcs+local nvim_prog = helpers.nvim_prog+local write_file = helpers.write_file++local function nvim_prog_abs()+  -- system(['build/bin/nvim']) does not work for whatever reason. It needs to+  -- either be executable searched in $PATH or something starting with / or ./.+  if nvim_prog:match('[/\\]') then+    return funcs.fnamemodify(nvim_prog, ':p')+  else+    return nvim_prog+  end+end++describe('Diff mode screen', function()+  describe('generic', function()+    local fname = 'Xtest-functional-diff-screen-1'+    local fname_2 = fname .. '.2'++    local withScreen = function(w, h, action)+      screen = Screen.new(w, h)+      screen:attach()+      action(screen)+      screen:detach()+    end++    local reread = function()+      feed(':e<cr><c-w>w:e<cr><c-w>w')+    end++    local verifyFillerAndInternal = function(action)+      for _, cmd in ipairs({':set diffopt=filler<cr>', ':set diffopt+=internal<cr>'}) do+        feed(cmd)+        reread()+        action()+      end+    end++    setup(function()+      clear()+      os.remove(fname)+      os.remove(fname_2)+      feed('<c-w>o:enew!<cr>')+      feed(':e ' .. fname_2 .. ' | diffthis<cr>')+      feed(':vnew ' .. fname .. ' | diffthis<cr>')+    end)++    teardown(function()+      os.remove(fname)+      os.remove(fname_2)+      feed('<c-w>o:enew!<cr>')+    end)++    it('Add a line in beginning of file 2', function()+      if helpers.pending_win32(pending) then return end+      write_file(fname, ""1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n"", false)+      write_file(fname_2, ""0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n"", false)+      withScreen(40, 16, function(screen)+        verifyFillerAndInternal(function()+          screen:sleep(1)  -- resolve ""screen not changed""","`screen:sleep(1)` doesn't resolve ""screen not changed"" neither semantically (nor technically I thought, if it does consistenty, `screen.lua` has a bug).It is better to turn this inside out: invoke`it()` for each alternative in the loop, and redo the entire test from scratch.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/9306,239997987,2018-12-08T08:19:07Z,test/functional/diff/screen_spec.lua,"@@ -0,0 +1,515 @@+local lfs = require('lfs')+local helpers = require('test.functional.helpers')(after_each)+local Screen = require('test.functional.ui.screen')++local eq = helpers.eq+local feed = helpers.feed+local eval = helpers.eval+local clear = helpers.clear+local funcs = helpers.funcs+local nvim_prog = helpers.nvim_prog+local write_file = helpers.write_file++local function nvim_prog_abs()+  -- system(['build/bin/nvim']) does not work for whatever reason. It needs to+  -- either be executable searched in $PATH or something starting with / or ./.+  if nvim_prog:match('[/\\]') then+    return funcs.fnamemodify(nvim_prog, ':p')+  else+    return nvim_prog+  end+end++describe('Diff mode screen', function()+  describe('generic', function()+    local fname = 'Xtest-functional-diff-screen-1'+    local fname_2 = fname .. '.2'++    local withScreen = function(w, h, action)+      screen = Screen.new(w, h)","Unless there is a good need for screens of different sizes (there probably isn't), use the standard pattern i e of `test/functional/ui/searchhl_spec.lua`.```  local screen  before_each(function()    clear()    screen = Screen.new(40, 16)    screen:attach()    screen:set_default_attr_ids({      [1] = {foreground = Screen.colors.DarkBlue, background = Screen.colors.WebGray},      -- et cetera    })  end)```Detach can be skipped, it is not needed. Also allocating all attrs in a `set_default_attr_ids` also makes the test easier to read: one can compare two `expects()` in the same file with a quick glance.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/9306,240015398,2018-12-08T20:21:38Z,src/nvim/CMakeLists.txt,"@@ -357,6 +357,14 @@ foreach(hfile ${NVIM_GENERATED_FOR_HEADERS})   endif() endforeach() +# Add xdiff sources to the build as-is bypassing the checks and linters+file(GLOB XDIFF_SOURCES xdiff/*.c)+file(GLOB XDIFF_HEADERS xdiff/*.h)",let's put this next to https://github.com/neovim/neovim/blob/44ee19dca540af74230009d781b76e869499e50f/src/nvim/CMakeLists.txt#L80,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/9173,240861330,2018-12-12T02:12:20Z,src/nvim/eval.c,"@@ -13042,9 +13047,24 @@ static void f_pyeval(typval_T *argvars, typval_T *rettv, FunPtr fptr)  */ static void f_py3eval(typval_T *argvars, typval_T *rettv, FunPtr fptr) {+  if (p_pyx == 0) {+      p_pyx = 3;+  }+   script_host_eval(""python3"", argvars, rettv); } +// ""pyxeval()"" function+static void f_pyxeval(typval_T *argvars, typval_T *rettv)","This is missing the `FunPtr fptr` parameter, which is why the build is broken...",
972014,mhinz,https://api.github.com/repos/neovim/neovim/pulls/9355,240958473,2018-12-12T10:29:49Z,src/nvim/eval.c,"@@ -22752,6 +22741,8 @@ bool eval_has_provider(const char *name)                       sizeof(""provider#"" #name ""#Call"") - 1, \                       false); \       has_##name = !!find_func((char_u *)""provider#"" #name ""#Call""); \+    } else { \+      return has_##name; \","Eh, yes, late night brain fart. It should have been the `else` for the _outer_ `if`. Anyway, if we do not want to touch the macro, then we could do this:```diff@@ -22770,7 +22759,19 @@ bool eval_has_provider(const char *name)     CHECK_PROVIDER(python);     return has_python;   } else if (strequal(name, ""ruby"")) {-    CHECK_PROVIDER(ruby);+    if (has_ruby == -1) {+      CHECK_PROVIDER(ruby);+      if (has_ruby == 1) {+        char *rubyhost = call_func_retstr(""provider#ruby#Detect"", 0, NULL, true);+        if (rubyhost) {+          if (*rubyhost == NUL) {+            // Invalid rubyhost executable. Gem is probably not installed.+            has_ruby = 0;+          }+          xfree(rubyhost);+        }+      }+    }     return has_ruby;   }```Only downer: Many `ifs` and we check for `has_ruby == -1` twice (the macro does it again).",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/9348,241029990,2018-12-12T14:17:26Z,src/nvim/ex_docmd.c,"@@ -8654,7 +8654,10 @@ eval_vars (       break;      case SPEC_AFILE:  // file name for autocommand-      if (autocmd_fname != NULL && !path_is_absolute(autocmd_fname)) {+      // For CmdlineEnter and related events, <afile> is not a path! #9348+      if (autocmd_fname != NULL+          && !path_is_absolute(autocmd_fname)+          && !strequal(""/"", (char *)autocmd_fname)) {","the comment should be attached to this line, it is not relevant to the other conditions ",
972014,mhinz,https://api.github.com/repos/neovim/neovim/pulls/9355,241049707,2018-12-12T15:04:07Z,src/nvim/eval.c,"@@ -22752,6 +22741,8 @@ bool eval_has_provider(const char *name)                       sizeof(""provider#"" #name ""#Call"") - 1, \                       false); \       has_##name = !!find_func((char_u *)""provider#"" #name ""#Call""); \+    } else { \+      return has_##name; \",It is needed If we don't change the macro to return early.Assume that `CHECK_PROVIDER(ruby)` sets it to 1. Then the additional code would be run every time as long as `provider#ruby#Detect()` returns 1 as well.,
972014,mhinz,https://api.github.com/repos/neovim/neovim/pulls/9355,241061495,2018-12-12T15:31:38Z,src/nvim/eval.c,"@@ -22752,6 +22741,8 @@ bool eval_has_provider(const char *name)                       sizeof(""provider#"" #name ""#Call"") - 1, \                       false); \       has_##name = !!find_func((char_u *)""provider#"" #name ""#Call""); \+    } else { \+      return has_##name; \","Hmm, ok, technically the same. In that case I'd consider the slightly more nested version to be more readable.Unless you're in strong favor of your version, I'd like to go with mine. :]",
11682285,erw7,https://api.github.com/repos/neovim/neovim/pulls/9376,242781408,2018-12-19T03:25:24Z,scripts/genappimage.sh,"@@ -62,8 +62,17 @@ delete_blacklisted # AppDir complete. Now package it as an AppImage. ######################################################################## -# No need for a fancy script. AppRun can just be a symlink to nvim.-ln -s usr/bin/nvim AppRun+# Appimage set the ARGV0 environment variable. This causes problems in zsh.+# To prevent this, we use wrapper script to unset ARGV0 as AppRun.+# See https://github.com/AppImage/AppImageKit/issues/852+#+cat << 'EOF' > AppRun+#!/bin/bash++unset ARGV0+exec ""$(dirname ""$(readlink  -f ""${0}"")"")/usr/bin/nvim"" ${@+""$@""}","https://www.gnu.org/software/bash/manual/bash.html#Shell-Parameter-Expansion> Omitting the colon results in a test only for a parameter that is unset.`${@+""$@""}` is almost the same as `${@:+""$@""}`. But when `$@` is null like `command """"`, it behaves differently. In the wrapper script, we need to use `${@+""$@""}` which omit the colon in order to pass command arguments directly to the command, taking into account the case of the null string.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/8963,243109883,2018-12-19T23:16:39Z,src/nvim/log.c,"@@ -32,6 +32,25 @@ static uv_mutex_t mutex; # include <execinfo.h> #endif +#define LOCAL_TIME_STRING_LEN 20++void get_local_time_string(char out[LOCAL_TIME_STRING_LEN])",I don't think we use array parameters anywhere. They can be misleading. Better to just use a pointer.,
3629785,phodge,https://api.github.com/repos/neovim/neovim/pulls/8963,243120603,2018-12-20T00:14:56Z,runtime/autoload/provider.vim,"@@ -3,19 +3,46 @@ "" Start the provider and perform a 'poll' request "" "" Returns a valid channel on success-function! provider#Poll(argv, orig_name, log_env) abort-  let job = {'rpc': v:true, 'stderr_buffered': v:true}+function! provider#Poll(argv, long_name, log_env) abort+  let job = {'rpc': v:true}++  "" Jobs are exptected to log errors etc using nvim_log() via the rpc api;+  "" we're just writing stderr to the log file as a courtesy to users who are+  "" trying to debug broken providers. Therefore we we log the events at+  "" ""WARNING"" level because anything coming via stderr indicates a problem+  "" with the provider.+  let job['on_stderr'] = function('s:LogEvent', [printf('%s:stderr', a:long_name), 'WARNING'])+   try+    "" attempt to start the provider+    call s:Log('INFO', printf('Starting %s: %s', a:long_name, a:argv))     let channel_id = jobstart(a:argv, job)-    if channel_id > 0 && rpcrequest(channel_id, 'poll') ==# 'ok'++    if channel_id <= 0+      throw printf('jobstart() returned %d', channel_id)+    endif++    "" check that the the provider is responding+    if rpcrequest(channel_id, 'poll') ==# 'ok'+      call s:Log('INFO', a:long_name . ' is alive')       return channel_id     endif   catch+    let err = printf('Failed starting %s: %s',  a:long_name, v:exception)     echomsg v:throwpoint-    echomsg v:exception-    for row in get(job, 'stderr', [])-      echomsg row-    endfor+    echomsg err+    call s:Log('ERROR', err)   endtry-  throw remote#host#LoadErrorForHost(a:orig_name, a:log_env)++  throw printf('Failed to load %s. Startup errors should be recorded in $NVIM_LOG_FILE'+        \ .', or possibly %s if you are using an older neovim client library.',+        \ a:long_name, a:log_env)+endfunction++function! s:Log(log_level, msg)+  call nvim_log(a:log_level, [a:msg], {'who': 'provider.vim'})+endfun++function! s:LogEvent(who, log_level, job, data, event)+  call nvim_log(a:log_level, lines, {'who': who})","Hey that should be `data`, not `lines` :-S",
3629785,phodge,https://api.github.com/repos/neovim/neovim/pulls/8963,243120745,2018-12-20T00:15:46Z,runtime/autoload/provider.vim,"@@ -3,19 +3,46 @@ "" Start the provider and perform a 'poll' request "" "" Returns a valid channel on success-function! provider#Poll(argv, orig_name, log_env) abort-  let job = {'rpc': v:true, 'stderr_buffered': v:true}+function! provider#Poll(argv, long_name, log_env) abort+  let job = {'rpc': v:true}++  "" Jobs are exptected to log errors etc using nvim_log() via the rpc api;+  "" we're just writing stderr to the log file as a courtesy to users who are+  "" trying to debug broken providers. Therefore we we log the events at+  "" ""WARNING"" level because anything coming via stderr indicates a problem+  "" with the provider.+  let job['on_stderr'] = function('s:LogEvent', [printf('%s:stderr', a:long_name), 'WARNING'])+   try+    "" attempt to start the provider+    call s:Log('INFO', printf('Starting %s: %s', a:long_name, a:argv))     let channel_id = jobstart(a:argv, job)-    if channel_id > 0 && rpcrequest(channel_id, 'poll') ==# 'ok'++    if channel_id <= 0+      throw printf('jobstart() returned %d', channel_id)+    endif++    "" check that the the provider is responding+    if rpcrequest(channel_id, 'poll') ==# 'ok'+      call s:Log('INFO', a:long_name . ' is alive')       return channel_id     endif   catch+    let err = printf('Failed starting %s: %s',  a:long_name, v:exception)     echomsg v:throwpoint-    echomsg v:exception-    for row in get(job, 'stderr', [])-      echomsg row-    endfor+    echomsg err+    call s:Log('ERROR', err)   endtry-  throw remote#host#LoadErrorForHost(a:orig_name, a:log_env)++  throw printf('Failed to load %s. Startup errors should be recorded in $NVIM_LOG_FILE'+        \ .', or possibly %s if you are using an older neovim client library.',+        \ a:long_name, a:log_env)+endfunction++function! s:Log(log_level, msg)+  call nvim_log(a:log_level, [a:msg], {'who': 'provider.vim'})+endfun++function! s:LogEvent(who, log_level, job, data, event)+  call nvim_log(a:log_level, lines, {'who': who})",And even `a:data` + `a:who` for consistency.,
3629785,phodge,https://api.github.com/repos/neovim/neovim/pulls/8963,243128489,2018-12-20T01:04:52Z,src/nvim/log.c,"@@ -137,6 +163,94 @@ bool logmsg(int log_level, const char *context, const char *func_name,   return ret; } +/// Log an array of lines to $NVIM_LOG_FILE. The only failure condition is that+/// the log file can't be opened. Any other errors are written to the log file.+bool do_log_array(char *log_level, Array lines, Dictionary opt)","The 3 options I considered were:**A)** Create an array of `char *` with pointers into the VimL Array and pass that along to a generic array logging function in `vim.c`.This is nice in that `log.c` doesn't need to know anything about VimL types, but then you have to send the error messages through in a 2nd call to the generic logging function, which introduces a race condition where another process may write to the log file in between any error lines and log lines. You can solve that by doing the locking/unlocking of the log file inside the `nvim_log()` API function and doing two consecutive calls to the generic logging function, but now you have a generic log function which relies on the caller to do the locking/unlocking, which feels untidy/unsafe.**B)** Accept that we're going to have to lock/unlock the inside the `nvim_log()` API function, but instead of allocating potentially huge `char *` arrays up front, just iterate over the VimL array and call a generic line logging function once for each line.I like that this solution avoids allocating the entire `char *` array up front, but don't like that it results in an extra function call for every single log line. This would mean regenerating the timestamp for every single line, or else you have to outsource *that* to the `nvim_log()` API function as well.**C)** Just make a function in `log.c` that takes a VimL array.This is a bit untidy in that `log.c` needs to start understanding VimL types, but it means that the locking, unlocking and timestamp generation stay within `log.c`, _and_ you don't have to allocate the `char *` array at all, _and_ the execution overhead of each log line is just the call to `fprintf()`.---The ability to handle unexpectedly huge data sets efficiently has always been one of the big selling points of Vim, so as much as possible I wanted this `nvim_log()` method to also cope well with unexpected huge log arrays, even though it's unlikely any client will ever send through anything more than maybe a 1000-line stack trace. That's why I picked option **C** above.Thoughts?",
112971,jamessan,https://api.github.com/repos/neovim/neovim/pulls/8963,243148433,2018-12-20T03:39:14Z,src/nvim/log.c,"@@ -32,6 +32,25 @@ static uv_mutex_t mutex; # include <execinfo.h> #endif +#define LOCAL_TIME_STRING_LEN 20++void get_local_time_string(char out[LOCAL_TIME_STRING_LEN])","While it's valid C syntax to declare the function as you did, it just gets collapsed down to a pointer.  Nothing enforces the length.> I was trying to avoid having `get_local_time_string()` allocate a `char[]` that needs to be freed by the caller. Is that what you had in mind? Or would you have the caller allocate the `char[]` and pass the length as a 2nd argument?It has to be one of the two. :) As long as it's clearly documented, either should be fine.  However, I would probably go with the latter.  Just make sure lengths are properly accounted for in `strftime()` and the fallback (`strlcpy()` or `strncpy()`).",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/9383,243509427,2018-12-21T07:49:55Z,runtime/plugin/rplugin.vim,"@@ -11,14 +11,8 @@ function! s:GetManifestPath() abort     return fnamemodify($NVIM_RPLUGIN_MANIFEST, ':p')   endif -  let dest = has('win32') ? '$LOCALAPPDATA' : '$XDG_DATA_HOME'-  if !exists(dest)-    let dest = has('win32') ? '~/AppData/Local' : '~/.local/share'-  endif--  let dest = fnamemodify(expand(dest), ':p')+  let dest = stdpath('data')   if !empty(dest)-    let dest .= ('/' ==# dest[-1:] ? '' : '/') . 'nvim'","Eek. We weren't using `nvim-data` on Windows, so this could be a speedbump.Let's do it after 0.3.2 is released.",
112971,jamessan,https://api.github.com/repos/neovim/neovim/pulls/9383,243591574,2018-12-21T14:15:38Z,runtime/plugin/rplugin.vim,"@@ -11,14 +11,8 @@ function! s:GetManifestPath() abort     return fnamemodify($NVIM_RPLUGIN_MANIFEST, ':p')   endif -  let dest = has('win32') ? '$LOCALAPPDATA' : '$XDG_DATA_HOME'-  if !exists(dest)-    let dest = has('win32') ? '~/AppData/Local' : '~/.local/share'-  endif--  let dest = fnamemodify(expand(dest), ':p')+  let dest = stdpath('data')   if !empty(dest)-    let dest .= ('/' ==# dest[-1:] ? '' : '/') . 'nvim'",We already have a function to migrate old data.  Could do the same here for the non-`nvim-data` paths on Windows.,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/9398,244199114,2018-12-27T17:58:47Z,ci/before_install.sh,"@@ -7,10 +7,6 @@ if [[ ""${CI_TARGET}"" == lint ]]; then   exit fi -if [[ ""${TRAVIS_OS_NAME}"" == osx ]]; then-  >/dev/null brew update",`>/dev/null` avoided the log noise. Is there a technical reason we need to use travis.yml instead?,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/9404,244332347,2018-12-28T14:26:31Z,src/nvim/bufhl_defs.h,"@@ -36,6 +36,19 @@ typedef struct { } BufhlLineInfo;  #define BUFHL_CMP(a, b) ((int)(((a)->line - (b)->line)))-KBTREE_INIT(bufhl, BufhlLine *, BUFHL_CMP, 10)  // -V512++#define KB_TYPENAME bufhl+#define KB_NAME_SUFFIX(X) X##_bufhl+#define KB_KEY_TYPE BufhlLine *+#define KB_KEY_CMP(x,y) BUFHL_CMP(x,y)+#define KB_BRANCH_FACTOR 10+#include ""nvim/lib/kbtree_impl.inc.h""",per [src/nvim/README.md](https://github.com/neovim/neovim/blob/master/src/nvim/README.md#filename-conventions) I think we would name this `kbtree.c.h`,
11682285,erw7,https://api.github.com/repos/neovim/neovim/pulls/9401,244586136,2018-12-31T13:47:49Z,src/nvim/tui/tui.c,"@@ -1555,10 +1554,6 @@ static void patch_terminfo_bugs(TUIData *data, const char *term,     unibi_set_bool(ut, unibi_back_color_erase, false);   } -  if (conemu) {-    unibi_set_bool(ut, unibi_back_color_erase, true);-  }",I think BCE will always be off in builtin terminfo(see [terminfo.c#L142](https://github.com/neovim/neovim/blob/master/src/nvim/tui/terminfo.c#L142)). ConEmu seems to have BCE so I want to enable BCE even in the case of builtin terminfo.,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/9425,244716440,2019-01-02T11:41:16Z,src/nvim/shada.c,"@@ -3990,8 +3990,7 @@ static ShaDaReadResult shada_read_next_item(ShaDaReadDef *const sd_reader,           .data = unpacked.data.via.array.ptr[i],         };         {-          msgpack_unpacked unpacked = unpacked_2;-          if (unpacked.data.type != MSGPACK_OBJECT_MAP) {+          if (unpacked_2.data.type != MSGPACK_OBJECT_MAP) {","I don't see why `unpacked = unpacked_2` would be needed, so just use `unpacked_2` directly.### EditThe macros implicitly depend on the names `unpacked` and `i`.CI stalled at this test:```[32m[2m[----------][0m[0m Running tests from [36m/home/travis/build/neovim/neovim/test/functional/shada/buffers_spec.lua[0m[32m[2m[ RUN      ][0m[0m ShaDa support code is able to dump and restore buffer list: ```",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/9425,244720087,2019-01-02T12:03:16Z,src/nvim/api/ui_events.in.h,"@@ -22,7 +22,7 @@ void mouse_on(void)   FUNC_API_SINCE(3); void mouse_off(void)   FUNC_API_SINCE(3);-void mode_change(String mode, Integer mode_idx)+void mode_change(String mode, Integer mode_idx_)",This name is exported in metadata. Better rename whatever internal variable instead.,
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/9425,244721418,2019-01-02T12:11:06Z,src/nvim/eval.c,"@@ -11493,20 +11493,20 @@ static void f_islocked(typval_T *argvars, typval_T *rettv, FunPtr fptr) ///                 a dictionary, will give an error if not. /// @param[out]  rettv  Location where result will be saved. /// @param[in]  what  What to save in rettv.-static void dict_list(typval_T *const tv, typval_T *const rettv,+static void dict_list(typval_T *const tv_, typval_T *const rettv,",Why not rename the loop variable to `tv_item` or something? In general it seems weird to corrupt a public name for the sake of not renaming a more private name.,
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/9425,244732718,2019-01-02T13:15:30Z,src/nvim/syntax.c,"@@ -6569,8 +6569,8 @@ void do_highlight(const char *line, const bool forceit, const bool init)       restore_cterm_colors();        // Clear all default highlight groups and load the defaults.-      for (int idx = 0; idx < highlight_ga.ga_len; idx++) {-        highlight_clear(idx);+      for (int idx_ = 0; idx_ < highlight_ga.ga_len; idx_++) {",why not just `int i` ?  predeclared `long i` can be moved to just before the loop where it is used.,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/9425,244755785,2019-01-02T14:54:39Z,src/nvim/syntax.c,"@@ -6569,8 +6569,8 @@ void do_highlight(const char *line, const bool forceit, const bool init)       restore_cterm_colors();        // Clear all default highlight groups and load the defaults.-      for (int idx = 0; idx < highlight_ga.ga_len; idx++) {-        highlight_clear(idx);+      for (int idx_ = 0; idx_ < highlight_ga.ga_len; idx_++) {",There's also nothing particularly bad about `idx_` .,
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/9425,244776974,2019-01-02T16:07:50Z,src/nvim/syntax.c,"@@ -6569,8 +6569,8 @@ void do_highlight(const char *line, const bool forceit, const bool init)       restore_cterm_colors();        // Clear all default highlight groups and load the defaults.-      for (int idx = 0; idx < highlight_ga.ga_len; idx++) {-        highlight_clear(idx);+      for (int idx_ = 0; idx_ < highlight_ga.ga_len; idx_++) {","It is not a big deal, but it does look uglier, especially with postfix operatorlike `idx_++` (looks like a join between `idx` and `++`), and it is harder to pronounce the difference between `x` and `x_`. `idx`, `i` and `j` is the most common pattern for multiple ""anonymous"" indexes, this would deviate from that for no particular reason. It would be better to reserve `x_` for where it actually means something (the existing cases I have seen are replacement for reserved keyword, and barebones marco hygine, of which the later only works if it is not randomly used for other stuff...).",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/8677,245518079,2019-01-06T18:48:24Z,runtime/doc/if_lua.txt,"@@ -293,7 +353,76 @@ vim.types						*lua-vim.types* 	values corresponding to `vim.types.float`, `vim.types.array` and  	`vim.types.dictionary` will not change or that `vim.types` table will  	only contain values for these three types.+------------------------------------------------------------------------------+vim.helpers.* helper functions++This modules provides lua-only helper functions to assist in writing lua+plugins.++vim.helpers.split({s}, {sep}, {plain})                       *vim.helpers.split*+	Split a given string by a separator. Returns a table containing the +	splitted components. The separator can be a lua pattern, see+		    https://www.lua.org/pil/20.2.html+	Setting {plain} to `true` turns of pattern matching, as it is passed+	to `string:find`, see +		http://lua-users.org/wiki/StringLibraryTutorial++	Parameters:~+		{s}     String: String to split+		{sep}   String: Separator pattern. If empty, split by chars.+		{plain} Boolean: If false, match {sep} verbatim++	Return:~+		Table of strings, which are the components of {s} after+		splitting	++vim.helpers.gsplit({s}, {sep}, {plain})                     *vim.helpers.gsplit*+	Split a given string by a separator. Returns an iterator of the +	splitted components. The separator can be a lua pattern, see+		    https://www.lua.org/pil/20.2.html+	Setting {plain} to `true` turns of pattern matching, as it is passed+	to `string:find`, see +		http://lua-users.org/wiki/StringLibraryTutorial++	Parameters:~+		{s}     String: String to split+		{sep}   String: Separator pattern. If empty, split by chars.+		{plain} Boolean: If false, match {sep} verbatim++	Return:~+		Iterator of strings, which are the components of {s} after+		splitting	++vim.helpers.inspect({object}, {options})                   *vim.helpers.inspect*","Most functions should live directly on `vim.`, not a sub-module `vim.helpers`. We own the `vim.*` module; the only ""forbidden"" names are those used by legacy `if_lua`:```vim:lua for k,v in pairs(vim) do print(k) endbufferopenwindowlastlinefirstlinetypelineevaldictbeeplistcommand```Any submodules that we _do_ introduce should not be named ""helpers"", but something meaningful. And they should be rare.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/9463,245522400,2019-01-06T21:03:40Z,test/functional/api/nvim_spec.lua,"@@ -0,0 +1,100 @@+local helpers = require('test.functional.helpers')(after_each)",this would go in the existing `test/functional/lua/utility_functions_spec.lua` or some other `test/functional/lua/*.lua` file. Doesn't seem to belong in `test/.../api/`.,
972014,mhinz,https://api.github.com/repos/neovim/neovim/pulls/9468,245687339,2019-01-07T15:17:28Z,runtime/autoload/health/provider.vim,"@@ -258,71 +258,56 @@ function! s:check_python(version) abort   call health#report_start('Python ' . a:version . ' provider (optional)')    let pyname = 'python'.(a:version == 2 ? '' : '3')-  let pyenv = resolve(exepath('pyenv'))-  let pyenv_root = exists('$PYENV_ROOT') ? resolve($PYENV_ROOT) : ''+  let python_exe = ''   let venv = exists('$VIRTUAL_ENV') ? resolve($VIRTUAL_ENV) : ''   let host_prog_var = pyname.'_host_prog'   let loaded_var = 'g:loaded_'.pyname.'_provider'-  let python_bin = ''",I intend to move every bigger `if`/`else` branch in `s:check_python()` to its own branch anyway in upcoming patches.It's probably better to ignore the first two patches during review right now. :>,
151598,noahfrederick,https://api.github.com/repos/neovim/neovim/pulls/9463,245723330,2019-01-07T16:53:07Z,runtime/doc/if_lua.txt,"@@ -254,11 +254,58 @@ For example, to use the ""nvim_get_current_line()"" API function, call ------------------------------------------------------------------------------ vim.* utility functions +vim.deepcopy({object})                                         *vim.deepcopy*+	Performs a deep copy of the given object, and returns that copy.+	For a non-table object, that just means a usual copy of the object,+	while for a table all subtables are copied recursively.++vim.inspect({object}, {options})                                 *vim.inspect*+	Return a human-readable representation of the passed object. See+	         https://github.com/kikito/inspect.lua+	for details and possible options.++vim.gsplit({s}, {sep}, {plain})                                  *vim.gsplit*+	Split a given string by a separator. Returns an iterator of the +	splitted components. The separator can be a lua pattern, see","```suggestion	split components. The separator can be a lua pattern, see```",
151598,noahfrederick,https://api.github.com/repos/neovim/neovim/pulls/9463,245723428,2019-01-07T16:53:24Z,runtime/doc/if_lua.txt,"@@ -254,11 +254,58 @@ For example, to use the ""nvim_get_current_line()"" API function, call ------------------------------------------------------------------------------ vim.* utility functions +vim.deepcopy({object})                                         *vim.deepcopy*+	Performs a deep copy of the given object, and returns that copy.+	For a non-table object, that just means a usual copy of the object,+	while for a table all subtables are copied recursively.++vim.inspect({object}, {options})                                 *vim.inspect*+	Return a human-readable representation of the passed object. See+	         https://github.com/kikito/inspect.lua+	for details and possible options.++vim.gsplit({s}, {sep}, {plain})                                  *vim.gsplit*+	Split a given string by a separator. Returns an iterator of the +	splitted components. The separator can be a lua pattern, see+		    https://www.lua.org/pil/20.2.html+	Setting {plain} to `true` turns of pattern matching, as it is passed","```suggestion	Setting {plain} to `true` turns off pattern matching, as it is passed```",
151598,noahfrederick,https://api.github.com/repos/neovim/neovim/pulls/9463,245723796,2019-01-07T16:54:24Z,runtime/doc/if_lua.txt,"@@ -254,11 +254,58 @@ For example, to use the ""nvim_get_current_line()"" API function, call ------------------------------------------------------------------------------ vim.* utility functions +vim.deepcopy({object})                                         *vim.deepcopy*+	Performs a deep copy of the given object, and returns that copy.+	For a non-table object, that just means a usual copy of the object,+	while for a table all subtables are copied recursively.++vim.inspect({object}, {options})                                 *vim.inspect*+	Return a human-readable representation of the passed object. See+	         https://github.com/kikito/inspect.lua+	for details and possible options.++vim.gsplit({s}, {sep}, {plain})                                  *vim.gsplit*+	Split a given string by a separator. Returns an iterator of the +	splitted components. The separator can be a lua pattern, see+		    https://www.lua.org/pil/20.2.html+	Setting {plain} to `true` turns of pattern matching, as it is passed+	to `string:find`, see +		http://lua-users.org/wiki/StringLibraryTutorial++	Parameters:~+		{s}     String: String to split+		{sep}   String: Separator pattern. If empty, split by chars.+		{plain} Boolean: If false, match {sep} verbatim++	Return:~+		Iterator of strings, which are the components of {s} after+		splitting	++vim.split({s}, {sep}, {plain})                                    *vim.split*+	Split a given string by a separator. Returns a table containing the +	splitted components. The separator can be a lua pattern, see","```suggestion	split components. The separator can be a lua pattern, see```",
151598,noahfrederick,https://api.github.com/repos/neovim/neovim/pulls/9463,245723856,2019-01-07T16:54:35Z,runtime/doc/if_lua.txt,"@@ -254,11 +254,58 @@ For example, to use the ""nvim_get_current_line()"" API function, call ------------------------------------------------------------------------------ vim.* utility functions +vim.deepcopy({object})                                         *vim.deepcopy*+	Performs a deep copy of the given object, and returns that copy.+	For a non-table object, that just means a usual copy of the object,+	while for a table all subtables are copied recursively.++vim.inspect({object}, {options})                                 *vim.inspect*+	Return a human-readable representation of the passed object. See+	         https://github.com/kikito/inspect.lua+	for details and possible options.++vim.gsplit({s}, {sep}, {plain})                                  *vim.gsplit*+	Split a given string by a separator. Returns an iterator of the +	splitted components. The separator can be a lua pattern, see+		    https://www.lua.org/pil/20.2.html+	Setting {plain} to `true` turns of pattern matching, as it is passed+	to `string:find`, see +		http://lua-users.org/wiki/StringLibraryTutorial++	Parameters:~+		{s}     String: String to split+		{sep}   String: Separator pattern. If empty, split by chars.+		{plain} Boolean: If false, match {sep} verbatim++	Return:~+		Iterator of strings, which are the components of {s} after+		splitting	++vim.split({s}, {sep}, {plain})                                    *vim.split*+	Split a given string by a separator. Returns a table containing the +	splitted components. The separator can be a lua pattern, see+		    https://www.lua.org/pil/20.2.html+	Setting {plain} to `true` turns of pattern matching, as it is passed","```suggestion	Setting {plain} to `true` turns off pattern matching, as it is passed```",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/9445,245795986,2019-01-07T21:00:35Z,src/nvim/edit.c,"@@ -4342,6 +4364,16 @@ ins_compl_next (   return num_matches; } +void pum_external_select_item(int item, bool insert, bool finish) {","`pum_ext_select_item` . We don't use ""external"" AFAICT. It's nice that ""ext"" means ""extension"" also, since ""external"" does not always make sense and we're more interested in extensibility.N.B. I would propose renaming `ui_is_external` to `ui_has`, but waiting on the big PRs to merge first.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/9445,245797107,2019-01-07T21:04:50Z,src/nvim/api/vim.c,"@@ -1916,6 +1917,31 @@ Object nvim_get_proc(Integer pid, Error *err)   return rvobj; } +/// Selects an item in the completion popupmenu+///+/// When insert completion is not active, this API call is silently ignored.+/// It is mostly useful for an external UI using |ui-popupmenu| for instance+/// to control the popupmenu with the mouse. But it can also be used in an+/// insert mode mapping, use <cmd> mapping |:map-cmd| to ensure the mapping+/// doesn't end completion mode.+///+/// @param item   Index of the item to select, starting with zero. Pass in ""-1""+///               to select no item (restore original text).+/// @param insert Whether the selection should be reflected in the buffer text.+/// @param finish If true, completion will be finished with this item, and the+///               popupmenu dissmissed. implies `insert`.+void nvim_select_popupmenu_item(Integer item, Boolean insert, Boolean finish,+                                Error *error)",should we bother to add a `opts` parameter for future extensions?,
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/9445,245805664,2019-01-07T21:35:05Z,src/nvim/edit.c,"@@ -4342,6 +4364,16 @@ ins_compl_next (   return num_matches; } +void pum_external_select_item(int item, bool insert, bool finish) {","> N.B. I would propose renaming ui_is_external to ui_has, but waiting on the big PRs to merge first.Fine by me. Just do it if you want it to happen, otherwise it will never happen. There will be outlying ""big PRs"" for quite some time, and it is not so hard to rebase fixup.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/9445,245808404,2019-01-07T21:44:46Z,src/nvim/edit.c,"@@ -184,6 +184,12 @@ static expand_T compl_xp;  static int compl_opt_refresh_always = FALSE; +static int pum_selected_item = -1;+static bool pum_request_active = false;+static int pum_request_wanted_item = -1;+static bool pum_request_insert = false;+static bool pum_request_finish = false;","I guess `want` works. It is replacement for local variables for a function that cannot be written without either greatly restructuring the code, or perhaps refactor the compl data structures to something that can be easily manipulated without code duplication. Why erase the `bool` variables specifically?",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/9445,245823881,2019-01-07T22:43:22Z,src/nvim/edit.c,"@@ -184,6 +184,12 @@ static expand_T compl_xp;  static int compl_opt_refresh_always = FALSE; +static int pum_selected_item = -1;+static bool pum_request_active = false;+static int pum_request_wanted_item = -1;+static bool pum_request_insert = false;+static bool pum_request_finish = false;","But `wanted_item` is precisely as related, it just happens to be of a different type. One could use a singleton struct `struct { ... } pum_want;`  as a grouping I guess, and avoid unnecessary bit-twiddling.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/9463,246666782,2019-01-10T08:19:09Z,src/nvim/lua/vim.lua,"@@ -118,11 +118,84 @@ local function _update_package_paths()   last_nvim_paths = cur_nvim_paths end +local function gsplit(s, sep, plain)+  assert(type(s) == ""string"")+  assert(type(sep) == ""string"")+  assert(type(plain) == ""boolean"" or type(plain) == ""nil"")++  local start = 1+  local done = false++  local function pass(i, j, ...)+    if i then+      assert(j+1 > start, ""Infinite loop detected"")+      local seg = s:sub(start, i - 1)+      start = j + 1+      return seg, ...+    else+      done = true+      return s:sub(start)+    end+  end++  return function()+    if done then+      return+    end+    if sep == '' then+      if start == #s then+        done = true+      end+      return pass(start+1, start)+    end+    return pass(s:find(sep, start, plain))+  end+end++local function split(s,sep,plain)","~~Maybe the parameter should be named `sep_pat`. Pattern behavior can be quite surprising when one was expecting a string, so having a convention that signals to users ""this has pattern behavior"" could help a lot.~~Oh, I see that the next parameter `plain` cancels that behavior. In `grep -F` this is called ""fixed"", I wonder if we should use that wording. (What does python call this?)",
4117685,KillTheMule,https://api.github.com/repos/neovim/neovim/pulls/9463,246668158,2019-01-10T08:25:05Z,src/nvim/lua/vim.lua,"@@ -118,11 +118,84 @@ local function _update_package_paths()   last_nvim_paths = cur_nvim_paths end +local function gsplit(s, sep, plain)+  assert(type(s) == ""string"")+  assert(type(sep) == ""string"")+  assert(type(plain) == ""boolean"" or type(plain) == ""nil"")++  local start = 1+  local done = false++  local function pass(i, j, ...)+    if i then+      assert(j+1 > start, ""Infinite loop detected"")+      local seg = s:sub(start, i - 1)+      start = j + 1+      return seg, ...+    else+      done = true+      return s:sub(start)+    end+  end++  return function()+    if done then+      return+    end+    if sep == '' then+      if start == #s then+        done = true+      end+      return pass(start+1, start)+    end+    return pass(s:find(sep, start, plain))+  end+end++local function split(s,sep,plain)","I'd advocate for calling it `plain`, because that's what the ""official"" lua docs call it (it stems from a parameter to `find`). See http://lua-users.org/wiki/StringLibraryTutorial.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/9478,247325238,2019-01-12T20:32:27Z,runtime/doc/term.txt,"@@ -42,34 +43,34 @@ unlike most other environment variables.    For this terminal           Set $TERM to                  |builtin-terms|   -------------------------------------------------------------------------+  anything libvte-based       vte, vte-256color                   Y+   (e.g. GNOME Terminal)      (aliases: gnome, gnome-256color)+  ConEmu                      conemu                              Y+  cygwin                      cygwin                              Y+  Interix                     interix                             Y   iTerm (original)            iterm, iTerm.app                    N   iTerm2 (new capabilities)   iterm2, iTerm2.app                  Y   Konsole                     konsole-256color                    N-  anything libvte-based       vte, vte-256color                   Y-   (e.g. GNOME Terminal)      (aliases: gnome, gnome-256color)-  tmux                        tmux, tmux-256color                 Y-  screen                      screen, screen-256color             Y+  Linux virtual terminal      linux, linux-256color               Y   PuTTY                       putty, putty-256color               Y+  rxvt                        rxvt, rxvt-256color                 Y+  screen                      screen, screen-256color             Y+  simple terminal (st)        st, st-256color                     Y   Terminal.app                nsterm                              N-  Linux virtual terminal      linux, linux-256color               Y+  tmux                        tmux, tmux-256color                 Y+  vtpcon                      vtpcon                              Y+  Windows console (cmd.exe)   win32con                            Y","@erw7 I could not find any info on `vtpcon`. Does it have a full name or other description/URL? - Is `vtpcon` the Windows 10 ""cmd.exe"" / new console component?- Is `win32con` the Windows 7 ""cmd.exe"" or legacy console?",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/9502,247511197,2019-01-14T14:28:42Z,src/nvim/edit.c,"@@ -2485,6 +2485,69 @@ void set_completion(colnr_T startcol, list_T *list) }  +void update_completion(colnr_T startcol, list_T *list)+{+  // If already doing completions stop it.","with the original code, `complete_update()` was a conservative improvement over `complete()`, now code needs to be written like `pum_active() ? complete_update(pos, list) : complete(pos, list) ` . Why do we want that?",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/9505,247587691,2019-01-14T17:38:38Z,src/nvim/lua/vim.lua,"@@ -195,6 +187,13 @@ deepcopy = function(orig)   return deepcopy_funcs[type(orig)](orig) end +local function __index(table, key)+  if key == ""inspect"" then+    table.inspect = require(""vim.inspect"")+    return table.inspect",section 2.8 in https://www.lua.org/manual/5.1/manual.html contains functionalistic descriptions for how the metatable mechanism works.,
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/9502,247821512,2019-01-15T09:44:42Z,src/nvim/edit.c,"@@ -2485,6 +2485,69 @@ void set_completion(colnr_T startcol, list_T *list) }  +void update_completion(colnr_T startcol, list_T *list)+{+  // If already doing completions stop it.","The old API was also better from two robustness standpoints:- if completion was formally aborted due to some event handling racyness, it can still continue using `complete_update()`- In a bad config two plugins might compete over the pum. In that situation `complete_update()` without pos will lead to items being interpreted at the wrong offset, leading to incorrect items. Pum flicker by itself is of course quite bad, but flicker with garbled items is a lot worse.What was the reason for the change?",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/9517,248889342,2019-01-18T00:15:56Z,runtime/lua/helpers/plugin/init.lua,"@@ -0,0 +1,20 @@+-- luacheck: globals unpack vim.api+local nvim = vim.api+local map = require('helpers.plugin.map').map+local unmap = require('helpers.plugin.map').unmap+local functions = require('helpers.plugin.map').functions++local function new_plugin(name)+  -- TODO(KillTheMule): Check assumptions about subsequent calls of this+  local ns = nvim.nvim_create_namespace(name)++  -- Should be redundant after the comment above has ben ascertained+  assert(functions[ns] == nil, ""Namspace ""..tostring(ns).."" already exists"")++  functions[ns] = {}+  return { ns = ns, name = name, map = map, unmap = unmap }","why does it return map/unmap?In its current form `new_plugin` seems unnecessary. Instead ""namespaces"" could be the primary concept, and `map()`/`unmap()` could take `ns` as their first parameter. We can add `vim.create_namespace`.Also unsure about adding stateful ""plugin objects"" which would need to be kept by plugins instead of just working with a namespace id. ",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/6917,249163270,2019-01-18T19:41:02Z,src/nvim/api/ui.c,"@@ -160,6 +168,12 @@ void nvim_ui_detach(uint64_t channel_id, Error *err)     return;   }   remote_ui_disconnect(channel_id);++  dict_T *dict = get_vim_var_dict(VV_EVENT);+  tv_dict_add_nr(dict, S_LEN(""channel_id""), (long)channel_id);","`nvim_list_uis()` uses `chan`, perhaps the same here for consistency.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/9517,249239684,2019-01-19T09:20:22Z,runtime/lua/helpers/plugin/init.lua,"@@ -0,0 +1,20 @@+-- luacheck: globals unpack vim.api+local nvim = vim.api+local map = require('helpers.plugin.map').map+local unmap = require('helpers.plugin.map').unmap+local functions = require('helpers.plugin.map').functions++local function new_plugin(name)+  -- TODO(KillTheMule): Check assumptions about subsequent calls of this+  local ns = nvim.nvim_create_namespace(name)++  -- Should be redundant after the comment above has ben ascertained+  assert(functions[ns] == nil, ""Namspace ""..tostring(ns).."" already exists"")++  functions[ns] = {}+  return { ns = ns, name = name, map = map, unmap = unmap }","There is also the aspect that good plugins are not supposed to map a huge number of user accessible keys in the global namespace anyway. A good plugin should first describe its global actions with `<Plug>(MyPlugin-Action)` maps, so the mappings defined to lua functions should primarily be on this form. And then it could possibly provide an opt-in set of default mappings, defined as ordinary expansions to the `<Plug>` form. (There are of course some exceptions, like in a buffer owned by a plugin, it can go crazy with buffer-local mappings, and ftplugins using `<LocalLeader>` prefixed mappings)",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/9429,249257224,2019-01-19T20:58:06Z,src/nvim/api/vim.c,"@@ -207,6 +211,98 @@ Integer nvim_input(String keys)   return (Integer)input_enqueue(keys); } +/// Send mouse event from GUI+///+/// The call is non-blocking. It doesn't wait on any resulting action, but+/// queues the event to be processed soon by the event loop.+///+/// @note Currently this doesn't not support ""scripting"" multiple mouse events+///       by calling it multiple times in a loop: the intermediate mouse+///       positions will be ignored. It should be used to implement real-time+///       mouse input in a GUI. The deprecated mouse support in |nvim_input()|","```suggestion///       mouse input in a GUI. The deprecated pseudokey form (e.g. ""<LeftMouse><col,row>"")```",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/9530,249279821,2019-01-20T13:50:02Z,src/nvim/ui.c,"@@ -85,21 +86,25 @@ static char uilog_last_event[1024] = { 0 }; // // See http://stackoverflow.com/a/11172679 for how it works. #ifdef _MSC_VER-# define UI_CALL(funname, ...) \+# define UI_CALL_CND(CND, funname, ...) \","condition, maybe `_IF` is better?",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/9520,250293439,2019-01-23T17:23:02Z,src/nvim/message.c,"@@ -126,29 +126,61 @@ int verb_msg(char_u *s)   int n;    verbose_enter();-  n = msg_attr_keep(s, 0, FALSE);+  n = msg_attr_keep(s, 0, false, false);   verbose_leave();    return n; } -int msg_attr(const char *s, const int attr) FUNC_ATTR_NONNULL_ARG(1)+int msg_attr(const char *s, const int attr)+  FUNC_ATTR_NONNULL_ARG(1) {-  return msg_attr_keep((char_u *)s, attr, false);+  return msg_attr_keep((char_u *)s, attr, false, false); } -int-msg_attr_keep (-    char_u *s,-    int attr,-    int keep                   /* TRUE: set keep_msg if it doesn't scroll */-)-  FUNC_ATTR_NONNULL_ARG(1)+void msg_echo_show(const char *s, int attr)","`msg_echo_show` is pretty confusing name, it is 3 synonyms to anyone without tribal knowledge. Maybe `msg_display` is an OK name, it is somewhat similar behavior as the existing `msg_puts_display`. ~~(Other suggestions: `msg_fmt`, `msg_pretty`).~~**Edit:** `msg_multiline` or `msg_expand`",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/9520,250295661,2019-01-23T17:29:05Z,src/nvim/message.c,"@@ -468,17 +505,8 @@ int emsg_not_now(void)   return FALSE; } -/*- * emsg() - display an error message- *- * Rings the bell, if appropriate, and calls message() to do the real work- * When terminal not initialized (yet) mch_errmsg(..) is used.- *- * return TRUE if wait_return not called- */-int emsg(const char_u *s_)+static int emsg_echo(const char *s, bool use_echo)","`use_echo` and the similar cases should be renamed to e.g. `pretty`. Otherwise it's too confusing, AFAICT it overlaps with other uses of the word ""echo"" (in this very same file) that do not behave like this.Thus,- `emsg_echo()` => `emsg_pretty()`- `bool use_echo` => `bool pretty`",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/9520,250320057,2019-01-23T18:36:12Z,src/nvim/message.c,"@@ -595,6 +635,28 @@ bool emsgf(const char *const fmt, ...)   return ret; } +#define MULTILINE_BUFSIZE 8192++bool emsgf_multiline(const char *const fmt, ...)+{+  bool ret;+  va_list ap;++  va_start(ap, fmt);++  static char  errbuf[MULTILINE_BUFSIZE];+  if (emsg_not_now()) {+    return true;","I checked the docs, you seem to be right. Also by the docs the `va_copy` in `api_set_error` seem to be unnecessary, one is allowed several `va_start/va_end` on the same arg list (noting in case we choose to reuse the pattern).",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/9546,250700408,2019-01-24T17:17:25Z,src/nvim/lua/executor.c,"@@ -132,6 +167,16 @@ static int nlua_state_init(lua_State *const lstate) FUNC_ATTR_NONNULL_ALL   lua_setfield(lstate, -2, ""stricmp"");    lua_setglobal(lstate, ""vim"");++  // expose main_loop's UV loop for luv+  lua_pushstring(lstate, ""uv_loop"");+  lua_pushlightuserdata(lstate, &main_loop.uv);","I think we want to avoid lightuserdata, it seems to cause trouble on some lua versions. I suppose a full userdata could be used instead?",
30594,andreypopp,https://api.github.com/repos/neovim/neovim/pulls/9546,250704602,2019-01-24T17:28:10Z,src/nvim/lua/executor.c,"@@ -132,6 +167,16 @@ static int nlua_state_init(lua_State *const lstate) FUNC_ATTR_NONNULL_ALL   lua_setfield(lstate, -2, ""stricmp"");    lua_setglobal(lstate, ""vim"");++  // expose main_loop's UV loop for luv+  lua_pushstring(lstate, ""uv_loop"");+  lua_pushlightuserdata(lstate, &main_loop.uv);","I don't think there's a way to push a preallocated pointer as userdata, as I understood `lua_pushlightuserdata` is exactly for this purpose instead. I might be wrong (no experience with Lua at all).",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/9546,250706643,2019-01-24T17:33:56Z,src/nvim/lua/executor.c,"@@ -132,6 +167,16 @@ static int nlua_state_init(lua_State *const lstate) FUNC_ATTR_NONNULL_ALL   lua_setfield(lstate, -2, ""stricmp"");    lua_setglobal(lstate, ""vim"");++  // expose main_loop's UV loop for luv+  lua_pushstring(lstate, ""uv_loop"");+  lua_pushlightuserdata(lstate, &main_loop.uv);","You would push a pointer-sized userdata, and then store the pointer at this memory. Half a year ago we removed all userdata for portability reasons #7879 #7880 , I don't think those concerns have changed.",
30594,andreypopp,https://api.github.com/repos/neovim/neovim/pulls/9546,250707605,2019-01-24T17:36:36Z,src/nvim/lua/executor.c,"@@ -132,6 +167,16 @@ static int nlua_state_init(lua_State *const lstate) FUNC_ATTR_NONNULL_ALL   lua_setfield(lstate, -2, ""stricmp"");    lua_setglobal(lstate, ""vim"");++  // expose main_loop's UV loop for luv+  lua_pushstring(lstate, ""uv_loop"");+  lua_pushlightuserdata(lstate, &main_loop.uv);","Understood, will change. Thanks for providing context and examples of transition from light userdata to userdata.",
972014,mhinz,https://api.github.com/repos/neovim/neovim/pulls/9539,251200041,2019-01-26T13:56:05Z,src/nvim/option.c,"@@ -2567,10 +2567,19 @@ did_set_string_option (     // 'ambiwidth'     if (check_opt_strings(p_ambw, p_ambw_values, false) != OK) {       errmsg = e_invarg;-    } else if (set_chars_option(&p_lcs) != NULL) {-      errmsg = (char_u *)_(""E834: Conflicts with value of 'listchars'"");-    } else if (set_chars_option(&p_fcs) != NULL) {-      errmsg = (char_u *)_(""E835: Conflicts with value of 'fillchars'"");+    } else {+      FOR_ALL_TAB_WINDOWS(tp, wp) {+        if (set_chars_option(wp, &wp->w_p_lcs) != NULL) {+          errmsg = (char_u *)_(""E834: Conflicts with value of 'listchars'"");+          goto ambw_end;+        }+        if (set_chars_option(wp, &wp->w_p_fcs) != NULL) {+          errmsg = (char_u *)_(""E835: Conflicts with value of 'fillchars'"");+          goto ambw_end;+        }+      }+ambw_end:+      {}  // clint prefers {} over ; as an empty statement",Then I get this:```/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/cc -DINCLUDE_GENERATED_DECLARATIONS -DNVIM_MSGPACK_HAS_FLOAT32 -DNVIM_UNIBI_HAS_VAR_FROM -D_GNU_SOURCE -Iconfig -I../src -Isrc/nvim/auto -Iinclude -I/usr/local/include/luajit-2.0 -isystem /usr/local/Cellar/libuv/1.25.0/include -isystem /usr/local/Cellar/msgpack/3.1.1/include -isystem /usr/local/include -isystem /usr/local/opt/gettext/include -Wshadow -Wconversion -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=1 -g   -Wall -Wextra -pedantic -Wno-unused-parameter -Wstrict-prototypes -std=gnu99 -Wimplicit-fallthrough -Wvla -fstack-protector-strong -fdiagnostics-color=auto -MD -MT src/nvim/CMakeFiles/nvim.dir/option.c.o -MF src/nvim/CMakeFiles/nvim.dir/option.c.o.d -o src/nvim/CMakeFiles/nvim.dir/option.c.o   -c ../src/nvim/option.c../src/nvim/option.c:2582:5: error: expected statement    }    ^1 error generated.```,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/9478,251210054,2019-01-26T19:30:54Z,runtime/doc/api.txt,"@@ -400,26 +442,26 @@ nvim_set_current_dir({dir})                           *nvim_set_current_dir()*                     {dir}  Directory path  nvim_get_current_line()                              *nvim_get_current_line()*-                Gets the current line+                Gets the current line.","@neovim/core 	Even though it seems to be a doxygen(?) convention to omit the period in the first sentence, it does not make sense for us, because in contexts such as Vim help docs it looks like a mistake. Also it's inconsistent: we terminate almost every other docstring, even sentence fragments in parameter descriptions ...",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/9551,251239366,2019-01-27T14:31:14Z,src/nvim/charset.c,"@@ -1022,12 +1022,12 @@ int win_lbr_chartabsize(win_T *wp, char_u *line, char_u *s, colnr_T col, int *he       && vim_isbreak(c)       && !vim_isbreak((int)s[1])       && wp->w_p_wrap-      && (wp->w_grid.Columns != 0)) {+      && (wp->w_width_inner != 0)) {","@justinmk Not really, it shouln't be `Columns` with caps either. My idea was just to reduce the use of the variable before renaming it in anyway. Perhaps we should even use `w_width_inner` for the shared redraw paths, so that these variables can be zero when the grid is not allocated.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/8325,251419093,2019-01-28T13:44:46Z,src/nvim/terminal.c,"@@ -1321,7 +1321,7 @@ static void adjust_topline(Terminal *term, buf_T *buf, long added)       if (following || (wp == curwin && is_focused(term))) {         // ""Follow"" the terminal output         wp->w_cursor.lnum = ml_end;-        set_topline(wp, MAX(wp->w_cursor.lnum - height + 1, 1));+        set_topline(wp, MAX(wp->w_cursor.lnum - wp->w_height_inner + 1, 1));","Thanks. Is there a qualitative/semantic explanation somewhere of the difference between `w_height` and `w_height_inner` (and `w_height_request`)? For a single-grid UI is `w_height` always the same as `w_height_inner`? Then it makes sense that `terminal/window_spec.lua` failed, because it has multiple grids. But I don't understand when `w_height` would ever be preferred to `w_height_inner`.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/9563,252529075,2019-01-31T04:06:38Z,runtime/doc/options.txt,"@@ -4761,14 +4761,13 @@ A jump table for the options with a short description can be found at |Q_op|. 	height with "":set scroll=0"".  						*'scrollback'* *'scbk'*-'scrollback' 'scbk'	number	(default: 10000-				 in normal buffers: -1)+'scrollback' 'scbk'	number	(default: -1) 			local to buffer 	Maximum number of lines kept beyond the visible screen. Lines at the 	top are deleted if new lines exceed this limit.-	Only in |terminal| buffers.-	-1 means ""unlimited"" for normal buffers, 100000 otherwise.-	Minimum is 1.+	Minimum is -1, maximum is 100000.+	For terminal buffers: -1 is equivalent to 10000.+	For all other buffers: Currently not implemented and ignored.","It said `Only in |terminal| buffers` already, which is more concise and less time-sensitve. We should avoid speaking about ""current status"" in documentation, it does not age well and makes stuff sound incomplete.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/9571,253156495,2019-02-01T18:42:32Z,src/nvim/ui.c,"@@ -320,11 +340,17 @@ void ui_set_ext_option(UI *ui, UIExtension ext, bool active) void ui_line(ScreenGrid *grid, int row, int startcol, int endcol, int clearcol,              int clearattr, bool wrap) {+  LineFlags flags = wrap ? kLineFlagWrap : 0;+  if (startcol == -1) {+    startcol = 0;+    flags |= kLineFlagInvalid;+  }+   size_t off = grid->line_offset[row] + (size_t)startcol; -  UI_CALL(raw_line, grid->handle, row, startcol, endcol, clearcol, clearattr,-          wrap, (const schar_T *)grid->chars + off,-          (const sattr_T *)grid->attrs + off);+  UI_CALL_IF(!ui->composed, raw_line, grid->handle, row, startcol, endcol,+             clearcol, clearattr, flags, (const schar_T *)grid->chars + off,+             (const sattr_T *)grid->attrs + off);","@justinmk But all UI calls are already if statements in for-loop, this is nothing new with compositor... Just that the condition normally just is `if (ui->method) ui->method(...)` instead of `if (ui->method && cond)` (but for no reason two if-statements, I should merge them).Also this change is from #9530, not this PR. ",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/9571,253159688,2019-02-01T18:52:16Z,src/nvim/ui.c,"@@ -85,21 +86,25 @@ static char uilog_last_event[1024] = { 0 }; // // See http://stackoverflow.com/a/11172679 for how it works. #ifdef _MSC_VER-# define UI_CALL(funname, ...) \+# define UI_CALL_IF(cond, funname, ...) \     do { \       UI_LOG(funname, 0); \       for (size_t i = 0; i < ui_count; i++) { \         UI *ui = uis[i]; \-        UI_CALL_MORE(funname, __VA_ARGS__); \+        if (cond) { \+          UI_CALL_MORE(funname, __VA_ARGS__); \","The condition depends on the for loop, otherwise the macro would be completely pointless. We could show the LOG on the first time in the loop anything was called.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/9571,253171405,2019-02-01T19:28:21Z,src/nvim/ui.c,"@@ -320,11 +340,17 @@ void ui_set_ext_option(UI *ui, UIExtension ext, bool active) void ui_line(ScreenGrid *grid, int row, int startcol, int endcol, int clearcol,              int clearattr, bool wrap) {+  LineFlags flags = wrap ? kLineFlagWrap : 0;+  if (startcol == -1) {+    startcol = 0;+    flags |= kLineFlagInvalid;+  }+   size_t off = grid->line_offset[row] + (size_t)startcol; -  UI_CALL(raw_line, grid->handle, row, startcol, endcol, clearcol, clearattr,-          wrap, (const schar_T *)grid->chars + off,-          (const sattr_T *)grid->attrs + off);+  UI_CALL_IF(!ui->composed, raw_line, grid->handle, row, startcol, endcol,+             clearcol, clearattr, flags, (const schar_T *)grid->chars + off,+             (const sattr_T *)grid->attrs + off);","Those are quite different. `if (ui->method) ui->method` is boilerplate, the other is not. Anyways your other note about the ~~side-effects~~ _per-UI_ nature of the `cond` condition explains why `UI_CALL_IF` is needed.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/6619,253322360,2019-02-03T22:19:03Z,runtime/doc/ui.txt,"@@ -636,5 +637,29 @@ Only sent if `ext_wildmenu` option is set in |ui-options| [""wildmenu_hide""] 	Hide the wildmenu. +==============================================================================+Floating window Events						      *ui-float*++Only sent if `ext_float` option is set in |ui-options|.++This extension allows the UI to draw floating windows (described at+|nvim_open_float_win|) by receieving updates on separate grids. Using this+extension implicitly activates `ext_newgrid` extension. Floats will be drawn","IMO it would be preferable to ""require"" `ext_newgrid` (error if missing), rather than implicitly enabling stuff. Otherwise the list of enabled extensions does not match the explicit list sent by the client.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/9571,254689343,2019-02-07T13:52:25Z,runtime/doc/options.txt,"@@ -4486,6 +4486,16 @@ A jump table for the options with a short description can be found at |Q_op|. 	Insert mode completion.  When zero as much space as available is used. 	|ins-completion-menu|. +						*'pumblend'* *'pb'*+'pumblend' 'pb'		number	(default 0)+			global+	Enables semi-transparency for the completion popupmenu. Valid values+	are in the range from 0 for fully opaque popupmenu (disabled) to 100+	for fully transparent background. Lower values 0-30 are typically most+	useful.++	Only takes effect in TUI with 'termguicolors' enabled.","Should it be included in `option_set` event? Then the help might be changed to:    UI-dependent. Supported by TUI with 'termguicolors' enabled.Also might be mentioned in ""Options"" section of `:h nvim-features`.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/9593,255303323,2019-02-09T16:05:02Z,src/nvim/api/vim.c,"@@ -955,23 +955,35 @@ void nvim_set_current_win(Window window, Error *err)   } } -/// Create new empty buffer+/// Creates a new, empty buffer. ///-/// @param listed whether the buffer should be listed+/// @param listed Controls 'buflisted'+/// @param scratch Creates a ""throwaway"" |scratch-buffer| for temporary work+///                (always 'nomodified') /// @param[out] err Error details, if any-/// @return the buffer handle or 0 when error-Buffer nvim_create_buf(Boolean listed, Error *err)+/// @return Buffer handle, or 0 on error+///+/// @see buf_open_scratch+Buffer nvim_create_buf(Boolean listed, Boolean scratch, Error *err)   FUNC_API_SINCE(6) {   try_start();-  Buffer buffer = buflist_add(NULL,-                              BLN_NOOPT | BLN_NEW | (listed ? BLN_LISTED : 0));-  if (!try_end(err) && buffer == 0) {+  Buffer b = buflist_add(NULL,","could use `buflist_new` to get buffer object, if we need it here.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/7466,255307798,2019-02-09T18:14:38Z,src/nvim/message.c,"@@ -1124,6 +1163,24 @@ void set_keep_msg(char_u *s, int attr)   keep_msg_attr = attr; } +void msg_set_ext_kind(const char *msg_kind)","Well, their names are not public or anything, they could be changed later. (Also it is an useful  ambiguity that `ext` also can mean ""extended"". If lua will render internal popupmenu from ""ext"" events, `ext_popupmenu` then means ""extended popupmenu"")",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/9616,257429384,2019-02-16T00:03:04Z,src/nvim/auevents.lua,"@@ -29,6 +29,7 @@ return {     'CmdWinLeave',            -- before leaving the cmdline window     'ColorScheme',            -- after loading a colorscheme     'ColorSchemePre',         -- before loading a colorscheme+    'CompleteChange',         -- after change completion item","probably should be named `CompleteChanged` (similar to `CmdLineChanged`, `TextChanged`, etc.)",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/9616,257430200,2019-02-16T00:08:57Z,runtime/doc/eval.txt,"@@ -1552,6 +1552,9 @@ v:event		Dictionary of event data for the current |autocommand|.  Valid 					operation. 			regtype		Type of register as returned by 					|getregtype()|.+			completeindex   Index of current selected complete+					item, Is `-1` when no complete item+					selected.","It's good to use `v:event`, but `v:completed_item` already exists and holds more info, so maybe it should be used instead.Also, `v:event` items can be more generic, so it could be named or `index`. Because `v:event` is context-dependent. Then the help would be like this:```index    Event-specific current index.```Note that it's also fine to set _both_ `v:event` as well as legacy `v:xx` variables if appropriate.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/9295,258359091,2019-02-20T07:24:30Z,src/nvim/buffer_defs.h,"@@ -778,7 +778,10 @@ struct file_buffer {                                  * normally points to this, but some windows                                  * may use a different synblock_T. */ -  signlist_T *b_signlist;       /* list of signs to draw */+  signlist_T *b_signlist;       // list of signs to draw+  int b_max_signs_per_line;     // cached maximum number of signs in a line+  int b_colsigns;               // last calculated maximum number of signs","let's rename these so that all signs-related fields shared the same `b_sign` prefix.- `b_max_signs_per_line` => `b_signcols_max`- `b_colsigns` => `b_signcols`I wish we didn't need `b_signcols_max`, but it looks  needed because of `comp_textwidth()` and `win_col_off()`. Maybe `b_signcols` wouldn't be needed if `b_signlist` were changed to a vector (`kvec.h`). But we shouldn't change that right now: there are upstream patches that change the signs code, those should be merged first (after this PR).",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/9616,259605785,2019-02-24T06:38:52Z,src/nvim/auevents.lua,"@@ -29,6 +29,7 @@ return {     'CmdWinLeave',            -- before leaving the cmdline window     'ColorScheme',            -- after loading a colorscheme     'ColorSchemePre',         -- before loading a colorscheme+    'PumRender',              -- after puopup menu drawn to screen",Renamed to `MenuPopupChanged` and put it alphabetically in this list.,
1106732,ilAYAli,https://api.github.com/repos/neovim/neovim/pulls/6619,259742095,2019-02-25T09:39:20Z,src/nvim/api/window.c,"@@ -432,3 +432,41 @@ Boolean nvim_win_is_valid(Window window)   return ret; } ++/// Configure window position. Currently this is only used to configure+/// floating and external windows (including changing a split window to these+/// types).+///+/// See documentation at |nvim_open_window|, for the meaning of parameters.","```suggestion/// See documentation at |nvim_open_win()|, for the meaning of parameters.```s/window/win/",
251450,chemzqm,https://api.github.com/repos/neovim/neovim/pulls/9616,261860940,2019-03-03T10:34:39Z,src/nvim/popupmnu.c,"@@ -756,3 +756,19 @@ int pum_get_height(void) {   return pum_height; }++/// Gets bounding of popup menu.+dict_T *pum_get_bounding(void)","There's a browser API called `getBoundingClientRect` that return similar properties for DOM, so how about `pum_get_bounding_rect`?",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/9667,261861133,2019-03-03T10:39:03Z,src/nvim/globals.h,"@@ -979,7 +979,9 @@ EXTERN char_u e_notopen[] INIT(= N_(""E484: Can't open file %s"")); EXTERN char_u e_notopen_2[] INIT(= N_(""E484: Can't open file %s: %s"")); EXTERN char_u e_notread[] INIT(= N_(""E485: Can't read file %s"")); EXTERN char_u e_nowrtmsg[] INIT(= N_(-        ""E37: No write since last change (add ! to override)""));+    ""E37: No write since last change (add ! to override)""));+EXTERN char_u e_nowrtmsg_api[] INIT(= N_(+    ""E37: No write since last change (use force=true to override)""));","I don't think this is a good idea. Maintaining different flavors of error messages for the API is extra work for little gain. Alternative is to document that the `force` parameter on the API method means ""!"" or bang (could also rename the param to `bang`). It's completely reasonable to expect API users to understand this instead of taking on such a burden in the codebase.Also adding a `api` parameter and codepath to `ex_win_close` is similarly unpleasant.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/9616,261865390,2019-03-03T12:41:28Z,src/nvim/auevents.lua,"@@ -29,6 +29,7 @@ return {     'CmdWinLeave',            -- before leaving the cmdline window     'ColorScheme',            -- after loading a colorscheme     'ColorSchemePre',         -- before loading a colorscheme+    'MenuPopupChanged',              -- after puopup menu drawn to screen",list must be alphabetical,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/9616,261865409,2019-03-03T12:42:01Z,runtime/doc/autocmd.txt,"@@ -577,6 +578,22 @@ ColorSchemePre			Before loading a color scheme. |:colorscheme| 				Useful to setup removing things added by a 				color scheme, before another one is loaded. +MenuPopupChanged 						*MenuPopupChanged*",should be listed after `MenuPopup`,
251450,chemzqm,https://api.github.com/repos/neovim/neovim/pulls/9616,261865617,2019-03-03T12:47:50Z,src/nvim/edit.c,"@@ -2658,6 +2658,31 @@ void ins_compl_show_pum(void)   pum_selected_item = cur;   pum_display(compl_match_array, compl_match_arraysize, cur, array_changed);   curwin->w_cursor.col = col;++  if (!has_event(EVENT_MENUPOPUPCHANGED)) {+    return;+  }+  dict_T *dict = get_vim_var_dict(VV_EVENT);+  if (cur < 0) {+    tv_dict_add_dict(dict, S_LEN(""completed_item""), tv_dict_alloc());+  } else {+    dict_T *item = ins_compl_dict_alloc(compl_curr_match);+    tv_dict_add_dict(dict, S_LEN(""completed_item""), item);+  }+  pumboundings_T *boundings = pum_get_boundings();+  if (boundings != NULL) {+    tv_dict_add_nr(dict, S_LEN(""height""), boundings->height);+    tv_dict_add_nr(dict, S_LEN(""width""), boundings->width);+    tv_dict_add_nr(dict, S_LEN(""row""), boundings->row);+    tv_dict_add_nr(dict, S_LEN(""col""), boundings->col);+    tv_dict_add_nr(dict, S_LEN(""scrollbar""), boundings->scrollbar);","The problem is I don't know how to extract data from the dict, `dict->width` doesn't work.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/9616,261866904,2019-03-03T13:17:39Z,src/nvim/auevents.lua,"@@ -29,6 +29,7 @@ return {     'CmdWinLeave',            -- before leaving the cmdline window     'ColorScheme',            -- after loading a colorscheme     'ColorSchemePre',         -- before loading a colorscheme+    'MenuPopupChanged',              -- after puopup menu drawn to screen","this still looks not alphabetical. it should be listed after MenuPopup, not ColorSchemePre.",
287744,prabirshrestha,https://api.github.com/repos/neovim/neovim/pulls/9616,261882620,2019-03-03T19:33:03Z,runtime/doc/autocmd.txt,"@@ -843,6 +844,21 @@ MenuPopup			Just before showing the popup menu (under the 					o	Operator-pending 					i	Insert 					c	Command line+MenuPopupChanged 					*MenuPopupChanged*+				After each time popup menu changed, not fired+				on popup menu hide, use |CompleteDone| for popup+				menu hide.++				Sets these |v:event| keys:+				    completed_item+				    height+				    with+				    row+				    col+				    scrollbar++				It is not allowed to change the text |textlock|.",balloonexpr seems to have the following text. Would be good to having something similar.>	It is not allowed to change text or jump to another window while	evaluating 'balloonexpr' |textlock|.,
251450,chemzqm,https://api.github.com/repos/neovim/neovim/pulls/9616,261924315,2019-03-04T05:13:20Z,runtime/doc/autocmd.txt,"@@ -843,6 +844,21 @@ MenuPopup			Just before showing the popup menu (under the 					o	Operator-pending 					i	Insert 					c	Command line+MenuPopupChanged 					*MenuPopupChanged*+				After each time popup menu changed, not fired+				on popup menu hide, use |CompleteDone| for popup+				menu hide.++				Sets these |v:event| keys:+				    completed_item+				    height+				    with+				    row+				    col+				    scrollbar++				It is not allowed to change the text |textlock|.","But `'balloonexpr'` doesn't exists on neovim, that line is copied from other similar autocmds.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/9616,262217372,2019-03-04T19:53:12Z,runtime/doc/eval.txt,"@@ -1552,6 +1552,19 @@ v:event		Dictionary of event data for the current |autocommand|.  Valid 					operation. 			regtype		Type of register as returned by 					|getregtype()|.+			completed_item    Current selected complete item on+					|MenuPopupChanged|, Is `{}` when no complete+					item selected.+			height 		Height of popup menu on |MenuPopupChanged|+			width   	width of popup menu on |MenuPopupChanged|+			row  	 	Row count of popup menu on |MenuPopupChanged|,+					relative to screen.+			col  	 	Col count of popup menu on |MenuPopupChanged|,+					relative to screen.+			size 		Total size of complete items on+					|MenuPopupChanged|.+			scrollbar 	Scrollbar exists for popup menu, is `1` when",Sounds like this should be `v:true` and `v:false`. Or is the point to preanticipate scrollbar with width larger than one (which I find unlikely)?,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/9662,263751041,2019-03-08T11:44:37Z,src/nvim/regexp.c,"@@ -3768,9 +3771,11 @@ static long bl_maxval;  * Returns FALSE when there is no match.  Leaves reginput and reglnum in an  * undefined state!  */-static int -regmatch (-    char_u *scan              /* Current node. */+static int+regmatch(+    char_u *scan,               // Current node.+    proftime_T *tm,+    int     *timed_out",original patch added documentation (comments) to these parameters. Why not include that?I will fix this in the merge-commit.,
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/9676,264013305,2019-03-09T20:24:33Z,test/functional/ui/popupmenu_spec.lua,"@@ -1198,20 +1198,20 @@ describe('builtin popupmenu', function()      command(""split"")     screen:expect([[-      xx                                      |       choice^                                  |+      {1:~                                       }|       {n:word           }{1:                         }|       {s:choice         }{4:                         }|       {n:text           }                         |-      {n:thing          }                         |+      {n:thing          }{1:                         }|       {3:[No Name] [+]                           }|       {2:-- INSERT --}                            |","""Ideally"" it should be resized immediately, but I agree fixing it is not top priority. As long as split caused by the completion mechanism itself (preview window) is working.",
7952509,Said6289,https://api.github.com/repos/neovim/neovim/pulls/9709,264177860,2019-03-11T10:52:56Z,src/nvim/fileio.c,"@@ -2792,8 +2784,8 @@ buf_write (         /*          * Isolate one directory name, using an entry in 'bdir'.          */-        (void)copy_option_part(&dirp, copybuf, BUFSIZE, "","");-        rootname = get_file_in_dir(fname, copybuf);+        (void)copy_option_part(&dirp, IObuff, IOSIZE, "","");","As far as I understand `copybuf` was being used for the copy operation which is now taken care of by libuv. That's why I removed it. It was, however, being used as an argument to `copy_option_part`, but then I found `copy_option_part` being called this way at https://github.com/Said6289/neovim/blob/master/src/nvim/fileio.c#L2911",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/9726,265291838,2019-03-13T19:17:42Z,src/nvim/api/window.c,"@@ -472,6 +472,48 @@ void nvim_win_config(Window window, Integer width, Integer height,   } } +/// Return window configuration of a window opened via |nvim_open_win()|.+///+/// Return a dictionary containing the same options that can be given to+/// |nvim_open_win()| plus the height and the width of the window.+///+/// @param window Window handle+/// @param[out] err Error details, if any+/// @return Window configuration+Dictionary nvim_win_get_config(Window window, Error *err)+  FUNC_API_SINCE(6)+{+  Dictionary rv = ARRAY_DICT_INIT;++  win_T *wp = find_window_by_handle(window, err);+  if (!wp) {+    return rv;+  }++  PUT(rv, ""height"", INTEGER_OBJ(wp->w_height));","Maybe we should change `nvim_win_set_config` to take optional width/height keys in the dict at the same time, instead of separate parameters, it would the simplest way to support this.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/9726,266179862,2019-03-16T00:19:41Z,runtime/doc/api.txt,"@@ -624,8 +625,7 @@ nvim_create_buf({listed}, {scratch})                       *nvim_create_buf()*                 Return: ~                     Buffer handle, or 0 on error -                                                             *nvim_open_win()*-nvim_open_win({buffer}, {enter}, {width}, {height}, {options})+nvim_open_win({buffer}, {enter}, {options})                  *nvim_open_win()*","`{options}` parameter should be renamed to `{config}`. Probably we should never say ""options"" anywhere if they don't set actual vim options. However `{opt}` (not `{options}`)  is ok on API functions with optional parameters. But in this particular case `nvim_win_get_config` explicitly refers to this parameter on `nvim_open_win`, so `{config}` seems appropriate.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/9726,266180572,2019-03-16T00:28:47Z,src/nvim/api/window.c,"@@ -439,39 +439,99 @@ Boolean nvim_win_is_valid(Window window) /// types). /// /// See documentation at |nvim_open_win()|, for the meaning of parameters. Pass-/// in -1 for 'witdh' and 'height' to keep exiting size.+/// in 0 for `width` and `height` to keep existing size. /// /// When reconfiguring a floating window, absent option keys will not be /// changed. The following restriction apply: `row`, `col` and `relative` /// must be reconfigured together. Only changing a subset of these is an error.-void nvim_win_config(Window window, Integer width, Integer height,-                     Dictionary options, Error *err)+///+/// @param      window  Window handle+/// @param      options Dictionary of options+/// @param[out] err     Error details, if any+void nvim_win_set_config(Window window, Dictionary options, Error *err)   FUNC_API_SINCE(6) {   win_T *win = find_window_by_handle(window, err);   if (!win) {     return;   }   bool new_float = !win->w_floating;-  width = width > 0 ? width: win->w_width;-  height = height > 0 ? height : win->w_height;   // reuse old values, if not overriden   FloatConfig config = new_float ? FLOAT_CONFIG_INIT : win->w_float_config;    if (!parse_float_config(options, &config, !new_float, err)) {     return;   }+  config.height = config.height > 0 ? config.height : win->w_height;+  config.width = config.width > 0 ? config.width : win->w_width;   if (new_float) {-    if (!win_new_float(win, (int)width, (int)height, config, err)) {+    if (!win_new_float(win, config, err)) {       return;     }     redraw_later(NOT_VALID);   } else {-    win_config_float(win, (int)width, (int)height, config);+    win_config_float(win, config);     win->w_pos_changed = true;   } } +/// Return window configuration.+///+/// Return a dictionary containing the same options that can be given to+/// |nvim_open_win()|.+///+/// `relative` will be empty for normal windows.+///+/// @param window Window handle+/// @param[out] err Error details, if any+/// @return Window configuration+Dictionary nvim_win_get_config(Window window, Error *err)+  FUNC_API_SINCE(6)+{+  Dictionary rv = ARRAY_DICT_INIT;++  win_T *wp = find_window_by_handle(window, err);+  if (!wp) {+    return rv;+  }++  PUT(rv, ""width"", INTEGER_OBJ(wp->w_float_config.width));+  PUT(rv, ""height"", INTEGER_OBJ(wp->w_float_config.height));+  PUT(rv, ""focusable"", BOOLEAN_OBJ(wp->w_float_config.focusable));+  PUT(rv, ""external"", BOOLEAN_OBJ(wp->w_float_config.external));+  PUT(rv, ""anchor"", STRING_OBJ(cstr_to_string(+      float_anchor_str[wp->w_float_config.anchor])));++  if (wp->w_float_config.relative == kFloatRelativeWindow) {+    PUT(rv, ""win"", INTEGER_OBJ(wp->w_float_config.window));+  }++  if (wp->w_float_config.external) {+    return rv;+  }++  PUT(rv, ""row"", FLOAT_OBJ(wp->w_float_config.row));+  PUT(rv, ""col"", FLOAT_OBJ(wp->w_float_config.col));++  if (wp->w_floating) {+    switch (wp->w_float_config.relative) {+      case kFloatRelativeEditor:+        PUT(rv, ""relative"", STRING_OBJ(cstr_to_string(""editor"")));+        break;+      case kFloatRelativeWindow:+        PUT(rv, ""relative"", STRING_OBJ(cstr_to_string(""win"")));+        break;+      case kFloatRelativeCursor:+        PUT(rv, ""relative"", STRING_OBJ(cstr_to_string(""cursor"")));","if there were a list similar to `float_anchor_str` then the `switch` could be eliminated:    PUT(rv, ""relative"", STRING_OBJ(cstr_to_string(float_rel_str[wp->w_float_config.relative])));",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/9607,266183848,2019-03-16T01:27:09Z,src/nvim/popupmnu.c,"@@ -95,19 +98,25 @@ void pum_display(pumitem_T *array, int size, int selected, bool array_changed)     above_row = 0;     below_row = cmdline_row; -    // anchor position: the start of the completed word-    row = curwin->w_wrow;-    if (curwin->w_p_rl) {-      col = curwin->w_width - curwin->w_wcol - 1;+    if (State == CMDLINE) {+      row = ui_has(kUICmdline) ? 0 : cmdline_row;+      col = startcol;+      pum_anchor_grid = ui_has(kUICmdline) ? -1 : DEFAULT_GRID_HANDLE;","I would maybe parameterize `row`, `col`, and `pum_anchor_grid`, and then add a wrapper function `cmdline_pum_display()` in `ex_getln.c`, to avoid some of these decisions in `pum_display()`. Then I guess another wrapper is needed, `insert_pum_display()`. Maybe it's hopeless :)",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/9726,266198359,2019-03-16T11:29:11Z,src/nvim/window.c,"@@ -4743,7 +4756,9 @@ void win_setheight_win(int height, win_T *win)    if (win->w_floating) {     if (win->w_float_config.external) {-      win_config_float(win, win->w_width, height, win->w_float_config);+      win->w_float_config.width = win->w_width;","similarly, I would expect this line to be able to be left out.",
972014,mhinz,https://api.github.com/repos/neovim/neovim/pulls/9726,266208953,2019-03-16T17:30:28Z,src/nvim/window.c,"@@ -4670,7 +4680,9 @@ int win_comp_pos(void)   // Too often, but when we support anchoring floats to split windows,   // this will be needed   for (win_T *wp = lastwin; wp && wp->w_floating; wp = wp->w_prev) {-    win_config_float(wp, wp->w_width, wp->w_height, wp->w_float_config);+    wp->w_float_config.width = wp->w_width;",Deleting that will make this test fail: https://github.com/neovim/neovim/blob/7bdb2f15d8e03e9b022b029bd44ec2bb7917df95/test/functional/ui/float_spec.lua#L588-L617```Expected:  |                                        |  |{0:~                                       }|  |*{0:~         }{1:very           }{0:               }|  |{0:~         }{1:^float          }{0:               }|  |{0:~                                       }|  |{0:~                                       }|  |                                        |Actual:  |                                        |  |{0:~                                       }|  |*{0:~         }{1:such           }{0:               }|  |{0:~         }{1:very           }{0:               }|  |{0:~         }{1:^float          }{0:               }|  |{0:~         }{2:~              }{0:               }|  |                                        |```,
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/9607,266211290,2019-03-16T18:49:27Z,src/nvim/mbyte.c,"@@ -555,6 +555,24 @@ size_t mb_string2cells(const char_u *str)   return clen; } +/// Get the number of cells occupied by string `str` with maximum length `size`+///+/// @param str The source string, may not be NULL, must be a NUL-terminated+///            string.+/// @param size maximum length of string. It will terminate on earlier NUL.+/// @return The number of cells occupied by string `str`+size_t mb_string2cells_len(const char_u *str, size_t size)","That would make it inconsistent from other mbyte functions, as well as causing a lot of unnecessary casts between different mbyte functions. If making mbyte functions `char *` is a goal, it would seem better with a dedicated PR for this with a well thought out design to minimise internal casts as well as reducing the risk of semantic errors.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/9740,266220336,2019-03-17T01:17:00Z,src/nvim/lua/vim.lua,"@@ -9,6 +9,9 @@ end  -- Gets process info from the `ps` command. -- Used by nvim_get_proc() as a fallback.+--!brief Gets the stuff for pid+--!param pid The pid+--!return A table","any idea if there are other syntaxes to choose from, besides `--!` ? (not too important, but I know doxygen has a bunch, would be nice if `--@return`  worked since that's similar to what we use in the C files.)",
972014,mhinz,https://api.github.com/repos/neovim/neovim/pulls/9754,266609241,2019-03-18T19:39:03Z,test/functional/ex_cmds/mksession_spec.lua,"@@ -47,4 +48,26 @@ describe(':mksession', function()     command('tabnext 2')     eq(cwd_dir .. get_pathsep() .. tab_dir, funcs.getcwd())   end)++  it('restores buffers when using tab-local working directories', function()+    local tmpfile_base = file_prefix .. '-tmpfile'+    local cwd_dir = funcs.getcwd()+    local session_path = cwd_dir .. get_pathsep() .. session_file++    command('edit ' .. tmpfile_base .. '1')+    command('tcd ' .. tab_dir)+    command('tabnew')+    command('edit ' .. cwd_dir .. get_pathsep() .. tmpfile_base .. '2')+    command('tabfirst')+    command('mksession ' .. session_path)++    -- Create a new test instance of Nvim.+    clear()++    command('source ' .. session_path)",```suggestion    -- Use :silent to avoid press-enter prompt due to long path    command('silent source ' .. session_path)```,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/9600,267568609,2019-03-20T22:15:40Z,runtime/doc/deprecated.txt,"@@ -63,6 +63,15 @@ Options ~ *'vi'* *'viminfo'*		Deprecated alias to 'shada' option. +UI extensions~+*ui-wildmenu*		Use `ext_cmdline` and `ext_popupmenu` instead.+			Enabled by `ext_wildmenu` |ui-options|.+			If `ext_wildmenu` is set, these events are emitted for+			backwards-compatibility:+				[""wildmenu_show"", items]+				[""wildmenu_select"", selected]+				[""wildmenu_hide""]","@bfredl I moved this to deprecated.txt, with liberal abbreviation.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/9772,267895757,2019-03-21T18:18:31Z,src/nvim/window.c,"@@ -4656,7 +4656,11 @@ void win_size_restore(garray_T *gap)     {       int i = 0;       FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {-        frame_setwidth(wp->w_frame, ((int *)gap->ga_data)[i++]);+        if (wp->w_floating) {+          win_setwidth_win(((int *)gap->ga_data)[i++], wp);",This is to save/restore state of split layout when opening temporary split. So we don't need to do anything at all for floats here.,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/9740,268456333,2019-03-24T22:23:28Z,scripts/gen_api_vimdoc.py,"@@ -43,8 +43,10 @@     sys.exit(1)  doc_filename = 'api.txt'+luadoc_filename = 'if_lua.txt' # String used to find the start of the generated part of the doc.-section_start_token = '*api-global*'+api_section_start_token = '*api-global*'+luadoc_section_start_token = '*api-lua*'","I think it's a good time to parameterize these config things.```pythonCONFIG = {  'api': {    'filename': 'api.txt',    # String used to find the start of the generated part of the doc.    'section_start_token': '*api-global*',    # Section ordering.    'section_order' : [      'vim.c',      'buffer.c',      'window.c',      'tabpage.c',      'ui.c',    ],  }  'lua': {    'filename': 'if_lua.txt'    'section_start_token': '*api-lua*',    'section_order' : [      'vim.lua',    ],  }}```",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/9740,268456640,2019-03-24T22:30:31Z,scripts/gen_api_vimdoc.py,"@@ -471,67 +492,100 @@ def gen_docs(config):                 if doc:                     filename = os.path.basename(filename)                     name = section_name.get(filename, name)-                    title = '%s Functions' % name-                    helptag = '*api-%s*' % name.lower()+                    +                    if filename.endswith('.lua'):+                        title = '%s Lua Functions' % name+                        helptag = '*lua-%s*' % name.lower()+                    else:+                        title = '%s Functions' % name+                        helptag = '*api-%s*' % name.lower()                     sections[filename] = (title, helptag, doc)      if not sections:         return -    docs = ''+    apidocs = ''+    luadocs = ''      i = 0-    for filename in section_order:+    for filename in api_section_order:         if filename not in sections:             continue         title, helptag, section_doc = sections.pop(filename)          i += 1-        docs += sep-        docs += '\n%s%s' % (title, helptag.rjust(text_width - len(title)))-        docs += section_doc-        docs += '\n\n\n'+        apidocs += sep+        apidocs += '\n%s%s' % (title, helptag.rjust(text_width - len(title)))+        apidocs += section_doc+        apidocs += '\n\n\n'++    for filename in luadoc_section_order:","Rather than trying to do everything in one pass, can we avoid this extra/duplicate code by choosing the ""mode"" at invocation time? Then this will be something like:    for filename in CONFIG[mode][""section_order""]:",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/9740,268456873,2019-03-24T22:35:35Z,scripts/gen_api_vimdoc.py,"@@ -471,67 +492,100 @@ def gen_docs(config):                 if doc:                     filename = os.path.basename(filename)                     name = section_name.get(filename, name)-                    title = '%s Functions' % name-                    helptag = '*api-%s*' % name.lower()+                    +                    if filename.endswith('.lua'):+                        title = '%s Lua Functions' % name+                        helptag = '*lua-%s*' % name.lower()+                    else:+                        title = '%s Functions' % name+                        helptag = '*api-%s*' % name.lower()                     sections[filename] = (title, helptag, doc)      if not sections:         return -    docs = ''+    apidocs = ''+    luadocs = ''      i = 0-    for filename in section_order:+    for filename in api_section_order:         if filename not in sections:             continue         title, helptag, section_doc = sections.pop(filename)          i += 1-        docs += sep-        docs += '\n%s%s' % (title, helptag.rjust(text_width - len(title)))-        docs += section_doc-        docs += '\n\n\n'+        apidocs += sep+        apidocs += '\n%s%s' % (title, helptag.rjust(text_width - len(title)))+        apidocs += section_doc+        apidocs += '\n\n\n'++    for filename in luadoc_section_order:+        if filename not in sections:+            continue+        title, helptag, section_doc = sections.pop(filename)++        i += 1+        luadocs += sep+        luadocs += '\n%s%s' % (title, helptag.rjust(text_width - len(title)))+        luadocs += section_doc+        luadocs += '\n\n\n'      if sections:         # In case new API sources are added without updating the order dict.         for title, helptag, section_doc in sections.values():             i += 1-            docs += sep-            docs += '\n%s%s' % (title, helptag.rjust(text_width - len(title)))-            docs += section_doc-            docs += '\n\n\n'--    docs = docs.rstrip() + '\n\n'-    docs += ' vim:tw=78:ts=8:ft=help:norl:\n'--    doc_file = os.path.join(base_dir, 'runtime/doc', doc_filename)-    delete_lines_below(doc_file, section_start_token)-    with open(doc_file, 'ab') as fp:-        fp.write(docs.encode('utf8'))+            apidocs += sep+            apidocs += '\n%s%s' % (title, helptag.rjust(text_width - len(title)))+            apidocs += section_doc+            apidocs += '\n\n\n'++    apidocs = apidocs.rstrip() + '\n\n'+    apidocs += ' vim:tw=78:ts=8:ft=help:norl:\n'+    luadocs = luadocs.rstrip() + '\n\n'+    luadocs += ' vim:tw=78:ts=8:ft=help:norl:\n'++    luadoc_file = os.path.join(base_dir, 'runtime/doc', luadoc_filename)+    apidoc_file = os.path.join(base_dir, 'runtime/doc', doc_filename)++    delete_lines_below(apidoc_file, api_section_start_token)+    with open(apidoc_file, 'ab') as fp:+        fp.write(apidocs.encode('utf8'))++    delete_lines_below(luadoc_file, luadoc_section_start_token)+    with open(luadoc_file, 'ab') as fp:+        fp.write(luadocs.encode('utf8'))     shutil.rmtree(out_dir)   def filter_source(filename):-    """"""Filters the source to fix macros that confuse Doxygen.""""""-    with open(filename, 'rt') as fp:-        print(re.sub(r'^(ArrayOf|DictionaryOf)(\(.*?\))',-                     lambda m: m.group(1)+'_'.join(-                         re.split(r'[^\w]+', m.group(2))),-                     fp.read(), flags=re.M))+    name, extension = os.path.splitext(filename)+    if extension == '.lua':+        p = subprocess.run([lua2dox_filter, filename], stdout=subprocess.PIPE)+        op = ('?' if 0 != p.returncode else p.stdout.decode('utf-8'))+        print(op)+    else:+        """"""Filters the source to fix macros that confuse Doxygen.""""""+        with open(filename, 'rt') as fp:+            print(re.sub(r'^(ArrayOf|DictionaryOf)(\(.*?\))',+                         lambda m: m.group(1)+'_'.join(+                             re.split(r'[^\w]+', m.group(2))),+                         fp.read(), flags=re.M))   # Doxygen Config {{{ Doxyfile = ''' OUTPUT_DIRECTORY       = {output} INPUT                  = {input} INPUT_ENCODING         = UTF-8-FILE_PATTERNS          = *.h *.c+FILE_PATTERNS          = *.h *.c *.lua","Might want to set this based on the ""mode"". Thus:    FILE_PATTERNS             = ""{file_patterns}""    ...    then later in `gen_docs()` ...```    p.communicate(config.format(input=src_dir, output=out_dir,                                file_patterns=CONFIG[mode][""file_patterns""],                                filter=filter_cmd).encode('utf8')) ```",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/9788,268792129,2019-03-25T18:30:44Z,src/nvim/buffer.c,"@@ -5084,17 +5083,16 @@ static int sign_compare(const void *a1, const void *a2)     if (s1->id < s2->id) {         return -1;     }-     return 0; } -int buf_signcols(buf_T *buf)+int buf_signcols(buf_T *buf, int max_signs)",Don't need the long name. Sign width is by definition per-line.,
9766,blueyed,https://api.github.com/repos/neovim/neovim/pulls/9788,268872986,2019-03-25T22:08:55Z,src/nvim/buffer_defs.h,"@@ -781,6 +781,7 @@ struct file_buffer {   signlist_T *b_signlist;       // list of signs to draw   int b_signcols_max;           // cached maximum number of sign columns   int b_signcols;               // last calculated number of sign columns+  int b_signcols_cells;         // number of cells used for sign columns","count != cols, max/b_signcols holds the count.https://github.com/blueyed/neovim/blob/6d5f8c7addcc4b276a436531e75cb3b620fe513e/src/nvim/buffer.c#L5163-L5167But it certainly should at least use ""cols"" (effective).I might be missing something here though.",
1418660,gelguy,https://api.github.com/repos/neovim/neovim/pulls/9790,269569033,2019-03-27T13:46:59Z,src/nvim/message.c,"@@ -615,7 +626,13 @@ static bool emsg_multiline(const char *s, bool multiline)    // Display the error message itself.   msg_nowait = false;  // Wait for this msg.-  return msg_attr_keep((char_u *)s, attr, false, multiline);+  int ret = msg_attr_keep((char_u *)s, attr, false, multiline);++  if (State & CMDLINE) {+    redrawcmdline();","I see 2 cases where the condition can be true, first from a `Cmdline*` autocmd, and second from a timer callback.In the autocmd case, the redraw will be done by the next iteration so we are doing an additional `redrawcmdline` which will be cleared by the redraw. In the timer case, it is possible that no redraw will be called, so we have to call the redraw here.Prior to this, the `redrawcmdline` is called by the `K_EVENT` handler, so it was not necessary.For multiple error messages in a row, the cmdline will be drawn in between each of them. This should be the same as the current behavior.",
1418660,gelguy,https://api.github.com/repos/neovim/neovim/pulls/9790,269569080,2019-03-27T13:47:04Z,src/nvim/ex_docmd.c,"@@ -7802,11 +7802,59 @@ static void ex_redraw(exarg_T *eap)   if (eap->forceit) {     redraw_all_later(NOT_VALID);   }-  update_screen(eap->forceit ? NOT_VALID-                : VIsual_active ? INVERTED : 0);++  // When NOT_VALID windows are redrawn, they lose incsearch highlighting since+  // the last search pattern is reset.+  // With display+=msg_sep, windows covered by the messages are NOT_VALID.+  int need_redraw_highlight = (State & CMDLINE)+      && ((p_is+           && msg_scrolled > 0+           && (dy_flags & DY_MSGSEP))","For the case with `display-=msgsep`, the windows which are above the messages have `w_redr_status` set to `REDRAW_TOP`, which appears to not clear the `incsearch` highlighting. You are correct regarding the other windows, they will lose the `incsearch` highlighting as well. I think this means `p_is && msg_scrolled > 0` should be the condition.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/9709,269612566,2019-03-27T15:07:57Z,test/functional/core/fileio_spec.lua,"@@ -64,5 +66,25 @@ describe('fileio', function()     command('write')     eq(4, request('nvim__stats').fsync)   end)++  it('creates a backup', function()+    clear({ args={ '-i', 'Xtest_startup_shada',+                   '--cmd', 'set directory=Xtest_startup_swapdir' } })++    command('write Xtest_startup_file1')+    feed('ifoo<esc>')+    command('set backup')+    command('set backupcopy=yes')+    command('write')+    feed('Abar<esc>')+    command('write')++    local foo_contents = read_file('Xtest_startup_file1')+    local bar_contents = read_file('Xtest_startup_file1~')++    eq('foobar\n', foo_contents);+    eq('foo\n', bar_contents);","on Windows lines end with `\r\n`. To make this test cross-platform, could just trim whitespace. There is a trim() function in `test/unit/helpers.lua`: https://github.com/neovim/neovim/blob/230a4fc2c327a24bd9515304c9197f8fb91313c7/test/unit/helpers.lua#L123                                                   We need to lift that up into `test/helpers.lua` so that functional tests can use it.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/9790,269921837,2019-03-28T09:44:19Z,src/nvim/message.c,"@@ -615,7 +626,13 @@ static bool emsg_multiline(const char *s, bool multiline)    // Display the error message itself.   msg_nowait = false;  // Wait for this msg.-  return msg_attr_keep((char_u *)s, attr, false, multiline);+  int ret = msg_attr_keep((char_u *)s, attr, false, multiline);++  if (State & CMDLINE) {+    redrawcmdline();","> For multiple error messages in a row, the cmdline will be drawn in between each of them. This should be the same as the current behavior.Not necessarily. Consider a function invoked by a timer or autocmd. It could call `:echoerr` twice in a row (or an internal error condition could easily `emsg()` twice in a row)  . The cmdline should then only be drawn after both error messages, not between them.",
972014,mhinz,https://api.github.com/repos/neovim/neovim/pulls/9805,270096546,2019-03-28T16:43:07Z,src/nvim/mark.c,"@@ -163,6 +163,15 @@ int setmark_pos(int c, pos_T *pos, int fnum)  * jump list.  */ void setpcmark(void)+{+  setpcmark_jl(true);","If the function contains `jl` already, it shouldn't also be an argument. The fastidious person in me thinks that this is backwards. It should be:```cvoid setpcmark(bool jumplist) {   ...}void setpcmark_jl(void) {  setpcmark(true);}```But obviously you don't want to change every occurrence of `setpcmark()`. And I think we don't use variadic arguments in Neovim.Since it's kind of a standard pattern, some functions are called `XXX_ext`. So, maybe change `setpcmark_jl()` to `setpcmark_ext()`, in case we ever have to add even more arguments.",
972014,mhinz,https://api.github.com/repos/neovim/neovim/pulls/9805,270098237,2019-03-28T16:46:47Z,src/nvim/mark.c,"@@ -163,6 +163,15 @@ int setmark_pos(int c, pos_T *pos, int fnum)  * jump list.  */ void setpcmark(void)+{+  setpcmark_jl(true);+}++/*+ * Set the previous context mark to the current position and add it to the+ * jump list if ""jumplist"" is true.+ */","This should use Doxygen style:```c/// Set the previous context mark to the current position.////// @param jumplist Add current position to jumplist, if true.void setpcmark......```",
20467669,abdelhakeem,https://api.github.com/repos/neovim/neovim/pulls/9792,270366995,2019-03-29T11:13:03Z,src/nvim/option.c,"@@ -1958,8 +1958,8 @@ static char_u *illegal_char(char_u *errbuf, size_t errbuflen, int c)   if (errbuf == NULL) {     return (char_u *)"""";   }-  snprintf((char *)errbuf, errbuflen, _(""E539: Illegal character <%s>""),-           (char *)transchar(c));+  vim_snprintf((char *)errbuf, errbuflen, _(""E539: Illegal character <%s>""),+               (char *)transchar(c));",I would use `snprintf` but used this for consistency since I found it already being used like here:https://github.com/neovim/neovim/blob/dfb7f6b3492edfd60583f76ee064ac76b1b913d8/src/nvim/option.c#L4405-L4406,
972014,mhinz,https://api.github.com/repos/neovim/neovim/pulls/9808,270434565,2019-03-29T14:32:12Z,src/nvim/ex_eval.c,"@@ -569,11 +569,16 @@ static void discard_exception(except_T *excp, int was_finished)  */ void discard_current_exception(void) {-  discard_exception(current_exception, false);+  if (current_exception != NULL)+  {",This `{` belongs at the end of the previous line.,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/9810,270596046,2019-03-29T23:02:53Z,runtime/doc/intro.txt,"@@ -373,8 +373,10 @@ notation	meaning		    equivalent	decimal value(s)	~ <kMinus>	keypad -			*keypad-minus* <kMultiply>	keypad *			*keypad-multiply* <kDivide>	keypad /			*keypad-divide*-<kEnter>	keypad Enter			*keypad-enter* <kPoint>	keypad Decimal point		*keypad-point*+<kComma>	keypad comma key		*keypad-comma*+<kEqual>	keypad equal key		*keypad-equal*","following the pattern from above, these would be:```<kComma>	keypad ,		*keypad-comma*<kEqual>	keypad =		*keypad-equal*```",
11682285,erw7,https://api.github.com/repos/neovim/neovim/pulls/9516,270814145,2019-04-01T10:58:02Z,test/functional/eval/executable_spec.lua,"@@ -136,21 +136,62 @@ describe('executable() (Windows)', function()     eq(1, call('executable', '.\\test_executable_zzz'))   end) -  it('returns 1 for any existing filename', function()+  it('returns 1 for any existing filename, when a Unix-shell like \'shell\'', function()     clear({env={PATHEXT=''}})+    command('set shell=sh')     for _,ext in ipairs(exts) do       eq(1, call('executable', 'test_executable_'..ext..'.'..ext))     end     eq(1, call('executable', 'test_executable_zzz.zzz'))   end) -  it('returns 1 for any existing path (backslashes)', function()+  it('returns 1 for any existing path, when a Unix-shell like \'shell\' (backslashes)', function()     clear({env={PATHEXT=''}})+    command('set shell=bash.exe')     for _,ext in ipairs(exts) do       eq(1, call('executable', '.\\test_executable_'..ext..'.'..ext))       eq(1, call('executable', './test_executable_'..ext..'.'..ext))     end     eq(1, call('executable', '.\\test_executable_zzz.zzz'))     eq(1, call('executable', './test_executable_zzz.zzz'))   end)++  it('returns 1 for any existing filename, when $PATHEXT contain dot itself', function()+    clear({env={PATHEXT='.;.zzz'}})+    command('set shell=sh')+    for _,ext in ipairs(exts) do+      eq(1, call('executable', 'test_executable_'..ext..'.'..ext))+    end+    eq(1, call('executable', 'test_executable_zzz.zzz'))+    clear({env={PATHEXT='.zzz;.'}})","It is strange to do set shell, so it was fixed. If we put it in a loop, I don't like to do that because I don't know which pattern failed.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/9835,271474557,2019-04-02T20:07:06Z,src/nvim/ex_getln.c,"@@ -1342,6 +1344,7 @@ static int command_line_handle_key(CommandLineState *s)    case Ctrl_R:                        // insert register     putcmdline('""', true);+    extra_char = '""';","We already have `ccline.special_char` in nvim for this, but it needs to be made unconditional in `putcmdline`",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/9856,272851995,2019-04-07T21:04:50Z,test/functional/terminal/api_spec.lua,"@@ -66,5 +66,47 @@ describe('api', function()      socket_session1:request(""nvim_command"", ""qa!"")   end)++  it(""stopinsert RPC request during insert-mode"", function()+    -- Start the socket from the child nvim.+    child_session.feed_data("":echo serverstart('""..socket_name..""')\n"")","`child_session.feed_data` is a hack for when we need to test a child Nvim (i.e. `nvim` running inside `:terminal`). I don't think that's needed for testing this change, using a regular session will avoid a lot of complexity.I would move the test to `test/functional/terminal/ex_terminal_spec.lua` and probably the screen tests aren't needed, only need to check `nvim_get_mode`.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/9873,273498554,2019-04-09T13:44:43Z,src/nvim/window.c,"@@ -4019,24 +4019,25 @@ tabpage_T *win_find_tabpage(win_T *win)   return NULL; } -/*- * Move to window above or below ""count"" times.- */-static void -win_goto_ver (-    int up,                         /* TRUE to go to win above */-    long count-)+/// Get the above or below neighbor window of the specified window.+///+/// Returns the specified window if the neighbor is not found.+/// Returns the previous window if the specifiecied window is a floating window.+///+/// @param up     true for the above neighbor+/// @param count  nth neighbor window+///+/// @return       found window+win_T *win_vert_neighbor(tabpage_T *tp, win_T *wp, bool up, long count) {   frame_T     *fr;   frame_T     *nfr;   frame_T     *foundfr; -  foundfr = curwin->w_frame;+  foundfr = wp->w_frame; -  if (curwin->w_floating) {-    win_goto(prevwin);-    return;+  if (wp->w_floating) {+    return prevwin;","We might need a check the prevwin is still valid, I fixed such a big before.",
972014,mhinz,https://api.github.com/repos/neovim/neovim/pulls/9873,273501897,2019-04-09T13:51:23Z,src/nvim/window.c,"@@ -4019,24 +4019,25 @@ tabpage_T *win_find_tabpage(win_T *win)   return NULL; } -/*- * Move to window above or below ""count"" times.- */-static void -win_goto_ver (-    int up,                         /* TRUE to go to win above */-    long count-)+/// Get the above or below neighbor window of the specified window.+///+/// Returns the specified window if the neighbor is not found.+/// Returns the previous window if the specifiecied window is a floating window.+///+/// @param up     true for the above neighbor+/// @param count  nth neighbor window+///+/// @return       found window+win_T *win_vert_neighbor(tabpage_T *tp, win_T *wp, bool up, long count) {   frame_T     *fr;   frame_T     *nfr;   frame_T     *foundfr; -  foundfr = curwin->w_frame;+  foundfr = wp->w_frame; -  if (curwin->w_floating) {-    win_goto(prevwin);-    return;+  if (wp->w_floating) {+    return prevwin;","Ok, but `win_valid(float_win)` will return `true` as well, right?I mean.. as far as I see there's no technical reason for returning the previous window, so.. speaks anything against doing the same as when no neighbor could be found, that is just returning the specified window instead?```c  if (wp->w_floating) {    return wp;  }```Currently, `winnr('l')` in a floating window will return the same as `winnr('#')`. Is this really the intended behaviour?",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/8850,274722731,2019-04-12T00:09:55Z,src/nvim/msgpack_rpc/channel.c,"@@ -359,21 +359,17 @@ static void on_request_event(void **argv)   Channel *channel = e->channel;   MsgpackRpcRequestHandler handler = e->handler;   Array args = e->args;-  uint64_t request_id = e->request_id;+  uint32_t request_id = e->request_id;   Error error = ERROR_INIT;   Object result = handler.fn(channel->id, args, &error);-  if (request_id != NO_RESPONSE) {","as @bfredl said, this check is needed because the message-type may be ""notification"" which must not send a response. Much of the naming is confusing so I tried to improve it in https://github.com/neovim/neovim/pull/9887 . That also eliminates NO_RESPONSE.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/9804,275330852,2019-04-15T12:15:04Z,test/functional/ui/cmdline_spec.lua,"@@ -733,6 +735,74 @@ local function test_cmdline(linegrid)  end +describe('cmdline', function()+  before_each(function()+    clear()+    screen = Screen.new(25, 5)+    screen:attach({rgb=true})+    screen:set_default_attr_ids({+      [1] = {bold = true, foreground = Screen.colors.Blue1},+      [2] = {reverse = true},+      [3] = {bold = true, reverse = true},+      [4] = {foreground = Screen.colors.Grey100, background = Screen.colors.Red},+      [5] = {bold = true, foreground = Screen.colors.SeaGreen4},+    })+  end)++  after_each(function()+    screen:detach()+  end)++  describe('with timer', function()+    it('draws correctly', function()+      feed(':012345678901234567890123456789')++      screen:expect{grid=[[+                               |+      {1:~                        }|+      {3:                         }|+      :012345678901234567890123|+      456789^                   |+      ]]}++      command('call timer_start(0, {-> 1})')",What would be be the purpose of adding `run()`? Bare `run()` shouldn't be used in a screen test as it discards redraw events. Use `timeout` param to `screen:expect{}` if the purpose is to wait longer.,
972014,mhinz,https://api.github.com/repos/neovim/neovim/pulls/9924,276569032,2019-04-18T08:41:31Z,src/nvim/api/vim.c,"@@ -1245,6 +1245,88 @@ ArrayOf(Dictionary) nvim_get_keymap(String mode)   return keymap_array(mode, NULL); } +/// Sets a |mapping| for the given mode.+///+/// Note that isn't possible to specify a target buffer when map_args contains+/// ""<buffer>""; like with |:map-<buffer>|, only the current buffer will be+/// affected.+///+/// @param  map_cmd   |:map-command| for this mapping, e.g. :nmap, :unmap!,+///                   :vnoremap, etc.+/// @param  map_args  |:map-arguments| like ""<buffer>"", ""<nowait>"", etc.+///                   concatenated into a single string.+/// @param  lhs   Left-hand-side |{lhs}| of the mapping.+/// @param  rhs   Right-hand-side |{rhs}| of the mapping.+///+/// @returns Zero on success, nonzero on failure.+Integer nvim_set_keymap(String map_cmd, String map_args,+                        String lhs, String rhs)",You could add `Error *err` to the list of arguments. Then use `api_set_error()` later.,
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/9924,277177445,2019-04-21T18:28:37Z,src/nvim/api/vim.c,"@@ -1245,6 +1245,225 @@ ArrayOf(Dictionary) nvim_get_keymap(String mode)   return keymap_array(mode, NULL); } +/// Sets a |mapping| for the given mode.+///+/// Note that isn't possible to specify a target buffer when {opts} contains+/// the key `""buffer""`; like with |:map-<buffer>|, only the current buffer will+/// be affected.+///+/// @param  mode  Mode short-name (the first character of an map command,+///               e.g. ""n"", ""i"", ""v"", ""x"", etc.) OR the string ""!"" (for+///               |:map!|). |:map| can be represented with an empty string, a+///               single space "" "", or ""m"".+/// @param  maptype   Whether to |:map|, |:unmap|, or |:noremap|, represented by+///                   an empty string, ""u"", and ""n"", respectively.+/// @param  lhs   Left-hand-side |{lhs}| of the mapping.+/// @param  rhs   Right-hand-side |{rhs}| of the mapping.+/// @param  opts  Optional parameters. Includes all |:map-arguments| as keys.+///               Values should all be Booleans. Unrecognized keys will result+///               in an error.+/// @param[out]   err   Error details, if any.+///+/// @returns  Zero on success, nonzero on failure.+Integer nvim_set_keymap(String mode, String maptype, String lhs, String rhs,+                        Dictionary opts, Error *err)+  FUNC_API_SINCE(6)+{+  // maximum possible size of the args-string we pass to do_map()+  // allocate memory right away, before any calls to free+  static const size_t kMaxSpecialArgSize =+      sizeof(""<buffer> <nowait> <silent> <script> <expr> <unique>"");+  // leave room for spaces around lhs, rhs; and null character+  const size_t kMaxArgSize = kMaxSpecialArgSize + lhs.size + rhs.size + 3;+  char_u *args = (char_u *)xcalloc(kMaxArgSize, sizeof(char_u));++  char *err_msg = NULL;  // the error message to report, if any+  char *err_arg = NULL;  // argument for the error message format string+  ErrorType err_type = kErrorTypeNone;++  // make sure that lhs and rhs aren't purely whitespace, and don't contain","`rhs` and `lhs` should ideally allow whitespace, this is really just a parsing issue of `do_map`.  A strategy could be to split `do_map` after the parsing, probaly after the `if (maptype == 1 !haskey) {` condition. Then this API function could skip the whitespace parsing entirely, and send in lhs/rhs with whitespace in it (which then means the same as `<space>`) . Though maybe `\n` should still be forbidden, it litteraly is the same as `<c-j>` but many users would probably expect it to be mean `<cr>`",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/9923,277379992,2019-04-22T18:14:05Z,src/nvim/options.lua,"@@ -819,6 +819,13 @@ return {       varname='p_fixeol',       defaults={if_true={vi=true}}     },+    {+      full_name='floatblend', abbreviation='fb',",`winfloatblend` or even just `winblend` makes this discoverable by `:set win<tab>` (which shows a list of several other options). And `winblend` is analogous to `pumblend`.,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/9934,277596020,2019-04-23T09:42:05Z,src/nvim/testdir/test_timers.vim,"@@ -235,6 +235,24 @@ func Test_timer_catch_error()   call assert_equal(4, g:call_count) endfunc +func FuncWithError(timer)+  let g:call_count += 1+  if g:call_count == 4+    return+  endif+  doesnotexist+endfunc++func Test_timer_errors()+  let g:call_count = 0+  let timer = timer_start(10, 'FuncWithError', {'repeat': -1})+  "" Timer will be stopped after failing 3 out of 3 times.+  call WaitFor('g:call_count == 3')+  sleep 50m+  call assert_equal(3, g:call_count)+endfunc",can just delete all changes to this file. These are duplicates.,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/9884,279183464,2019-04-28T08:26:23Z,src/nvim/tui/input.c,"@@ -49,15 +49,7 @@ void tinput_init(TermInput *input, Loop *loop)   int curflags = termkey_get_canonflags(input->tk);   termkey_set_canonflags(input->tk, curflags | TERMKEY_CANON_DELBS);   // setup input handle-#ifdef WIN32-  uv_tty_init(&loop->uv, &input->tty_in, 0, 1);-  uv_tty_set_mode(&input->tty_in, UV_TTY_MODE_RAW);-  rstream_init_stream(&input->read_stream,-                      (uv_stream_t *)&input->tty_in,-                      0xfff);",`tty_in` field is no longer used. I guess it could be removed from `struct term_input`Also looks like `rstream_init_stream()` is no longer used. I guess we should keep it though.,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/9955,279299581,2019-04-29T09:52:47Z,src/nvim/eval.c,"@@ -10474,6 +10474,14 @@ static void f_win_screenpos(typval_T *argvars, typval_T *rettv, FunPtr fptr)   tv_list_append_number(rettv->vval.v_list, wp == NULL ? 0 : wp->w_wincol + 1); } +// ""getwinpos({timeout})"" function+static void f_getwinpos(typval_T *argvars, typval_T *rettv, FunPtr fptr)+{+  tv_list_alloc_ret(rettv, 2);+  tv_list_append_number(rettv->vval.v_list, -1);+  tv_list_append_number(rettv->vval.v_list, -1);",For Nvim `getwinpos()` doesn't make sense because there can be multiple UIs. Would need to add a `{ui}` parameter and then make a RPC request to that UI.,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/9969,280703686,2019-05-03T08:56:50Z,src/nvim/testdir/test_autocmd.vim,"@@ -786,7 +786,6 @@ endfunc "" Test for autocommand that deletes the current buffer on BufLeave event. "" Also test deleting the last buffer, should give a new, empty buffer. func Test_BufLeave_Wipe()-  throw 'skipped: TODO: '","see 66f5e5c7d7ce762db71886b72e759a745c2b41ce for explanation (and its parent, 9af9ea6099d109982d642885c6b7fc5e5082c3f8 for a similar case). The bug was already present, but I didn't want it to block merging of many related patches.  Maybe when we  are fully caught up to 8.0.1223 the bug will be fixed. Else we will need to look more closely.",
8740057,janlazo,https://api.github.com/repos/neovim/neovim/pulls/9969,281030156,2019-05-05T17:00:39Z,src/nvim/testdir/Makefile,"@@ -34,14 +34,12 @@ NEW_TESTS_ALOT := test_alot_utf8 test_alot NEW_TESTS_IN_ALOT := $(shell sed '/^source/ s/^source //;s/\.vim$$//' test_alot*.vim) # Ignored tests. # test_alot_latin: Nvim does not allow setting encoding.-# test_arglist: ported to Lua, but kept for easier merging. # test_autochdir: ported to Lua, but kept for easier merging. # test_eval_func: used as include in old-style test (test_eval.in). # test_listlbr: Nvim does not allow setting encoding. # test_largefile: uses too much resources to run on CI. NEW_TESTS_IGNORE := $(NEW_TESTS_IN_ALOT) $(NEW_TESTS_ALOT) \   test_alot_latin \-  test_arglist \","```From test_arglist.vim:Found errors in Test_argv():Caught exception in Test_argv(): Vim(call):E118: Too many arguments for function: argc @ function RunTheTest[35]..Test_argv, line 20```",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/9990,282582530,2019-05-09T17:16:51Z,runtime/tutor/en/vim-01-beginner.tutor,"@@ -159,9 +159,9 @@ There is also some text missing here.   2. At the shell prompt type this command: ~~~ sh-     $ vim tutor+     $ nvim tutor ~~~-    'vim' is the command to start the Vim editor, 'tutor' is the name of+    'nvim' is the command to start the Vim editor (it is NeoVim, but we call it as Vim sometimes), 'tutor' is the name of","""Neovim"" not ""NeoVim"". The edited line is very long, it should probably be hard-wrapped at column 80.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/9924,282817516,2019-05-10T09:46:00Z,src/nvim/api/buffer.c,"@@ -575,6 +576,157 @@ ArrayOf(Dictionary) nvim_buf_get_keymap(Buffer buffer, String mode, Error *err)   return keymap_array(mode, buf); } +/// Like |nvim_set_keymap|, but for a specific buffer.+///+/// @param  buffer  Buffer handle, or 0 for the current buffer.+Integer nvim_buf_set_keymap(Buffer buffer, String mode, String maptype,+                            String lhs, String rhs, Dictionary opts, Error *err)+  FUNC_API_SINCE(6)+{+  char *err_msg = NULL;  // the error message to report, if any+  char *err_arg = NULL;  // argument for the error message format string+  ErrorType err_type = kErrorTypeNone;++  char_u *lhs_buf = NULL;+  char_u *rhs_buf = NULL;++  // internal nvim code can signal global behavior by passing -1 as first+  // param, but user code cannot+  bool global = (buffer == -1);+  if (global) {+    buffer = 0;+  }+  buf_T *buf = find_buffer_by_handle(buffer, err);++  MapArguments parsed_args;+  memset(&parsed_args, 0, sizeof(parsed_args));+  if (parse_keymap_opts(opts, &parsed_args, err)) {+    goto FAIL_AND_FREE;+  }+  parsed_args.buffer = !global;++  set_maparg_lhs_rhs((char_u *)lhs.data, lhs.size,+                     (char_u *)rhs.data, rhs.size,+                     CPO_TO_CPO_FLAGS, &parsed_args);++  if (parsed_args.lhs_len > MAXMAPLEN) {+    err_msg = ""LHS exceeds maximum map length: %s"";+    err_arg = lhs.data;+    err_type = kErrorTypeValidation;+    goto FAIL_WITH_MESSAGE;+  }++  if (mode.size > 1) {+    err_msg = ""Given shortname is too long: %s"";","    ""shortname is too long: %s""(""given"" is implied)",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/9993,283101181,2019-05-11T15:38:31Z,test/functional/ui/screen.lua,"@@ -413,26 +414,23 @@ screen:redraw_debug() to show all intermediate screen states.  ]])       end     end -    -- Extension features. The default expectations should cover the case of+    -- UI extensions. The default expectations should cover the case of     -- the ext_ feature being disabled, or the feature currently not activated-    -- (for instance no external cmdline visible). Some extensions require+    -- (e.g. no external cmdline visible). Some extensions require     -- preprocessing to represent highlights in a reproducible way.     local extstate = self:_extstate_repr(attr_state)--    -- convert assertion errors into invalid screen state descriptions-    local status, res = pcall(function()-      for _, k in ipairs(ext_keys) do-        -- Empty states is considered the default and need not be mentioned-        if not (expected[k] == nil and isempty(extstate[k])) then-          eq(expected[k], extstate[k], k)+    if expected['mode'] ~= nil then+      extstate['mode'] = self.mode+    end+    -- Convert assertion errors into invalid screen state descriptions.+    for _, k in ipairs(concat_tables(ext_keys, {'mode'})) do+      -- Empty states are considered the default and need not be mentioned.+      if (not (expected[k] == nil and isempty(extstate[k]))) then+        local status, res = pcall(eq, expected[k], extstate[k], k)+        if not status then+          return (tostring(res)..'\nHint: full state of ""'..k..'"":\n  '..inspect(extstate[k]))","luassert prints `{ ... }` if the dictionary is too nested, and there's no parameter to change that behavior. So this prints the `inspect()` result.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/9943,285133674,2019-05-17T13:48:35Z,src/nvim/channel.h,"@@ -130,5 +140,28 @@ static inline Stream *channel_outstream(Channel *chan)   abort(); } +static inline Channel *acquire_asynccall_channel(void)","as discussed in chat, I think we should avoid managing a pool. On a warm system spawning a new `nvim` costs ~10 milliseconds (as long as it doesn't load user config).",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/10037,285511031,2019-05-20T09:52:04Z,runtime/pack/dist/opt/termdebug/plugin/termdebug.vim,"@@ -564,7 +564,8 @@ func s:HandleEvaluate(msg)     else       let s:evalFromBalloonExprResult .= ' = ' . value     endif-    call s:OpenHoverPreview([s:evalFromBalloonExprResult], v:null)+    let s:evalFromBalloonExprResult = split(s:evalFromBalloonExprResult, '\\n')+    call s:OpenHoverPreview(s:evalFromBalloonExprResult, v:null)","the screenshot in #10020 shows lines with `\n`, but here the pattern is `'\\n'` which would only match `\\n`, because single-quotes in VimL are literal strings (escaping has no effect).",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/10037,285530367,2019-05-20T10:43:43Z,runtime/pack/dist/opt/termdebug/plugin/termdebug.vim,"@@ -564,7 +564,8 @@ func s:HandleEvaluate(msg)     else       let s:evalFromBalloonExprResult .= ' = ' . value     endif-    call s:OpenHoverPreview([s:evalFromBalloonExprResult], v:null)+    let s:evalFromBalloonExprResult = split(s:evalFromBalloonExprResult, '\\n')+    call s:OpenHoverPreview(s:evalFromBalloonExprResult, v:null)","Actually it's my mistake, I didn't realize that `split()` takes a pattern, not a  literal.",
8740057,janlazo,https://api.github.com/repos/neovim/neovim/pulls/10038,285704079,2019-05-20T17:54:03Z,src/nvim/eval.c,"@@ -9547,6 +9547,40 @@ static void f_getbufvar(typval_T *argvars, typval_T *rettv, FunPtr fptr)   } } +// ""getchangelist()"" function+static void f_getchangelist(typval_T *argvars, typval_T *rettv, FunPtr fptr)+{+  tv_list_alloc_ret(rettv, 2);+  (void)tv_get_number(&argvars[0]);  // issue errmsg if type error",Is this actually required for Neovim to issue an error message? This PR is WIP because of this and the compiler warning from gcc for an unused return value.,
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/10046,286377787,2019-05-22T08:48:04Z,src/nvim/lib/kvec.h,"@@ -58,7 +58,7 @@     }  #define kv_init(v) ((v).size = (v).capacity = 0, (v).items = 0)-#define kv_destroy(v) xfree((v).items)+#define kv_destroy(v) XFREE_CLEAR((v).items)","it seems weird to only reset the pointer and not the other fields: the data structure is now in an inconsistent state. Maybe `(xfree((v).items), kv_init(v))`.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/9943,286400567,2019-05-22T09:38:10Z,src/nvim/eval.c,"@@ -7419,6 +7419,105 @@ static void f_call(typval_T *argvars, typval_T *rettv, FunPtr fptr)   func_call(func, &argvars[1], partial, selfdict, rettv); } +/// ""call_async(callee, args, opts[, callback])"" function+static void f_call_async(typval_T *argvars, typval_T *rettv, FunPtr fptr)+{+  rettv->v_type = VAR_NUMBER;+  rettv->vval.v_number = -1;++  typval_T *callee = NULL;+  typval_T *args = NULL;+  typval_T *opts = NULL;+  Callback callback = CALLBACK_NONE;++  // TODO(abdelhakeem): support artibrary user-defined functions+  callee = &argvars[0];+  if (callee->v_type != VAR_STRING) {+    EMSG2(_(e_invarg2),+          ""First argument of async_invoke() must be a string"");+    return;+  }++  args = &argvars[1];+  if (args->v_type != VAR_LIST) {+    EMSG2(_(e_invarg2),+          ""Second argument of async_invoke() must be a list"");+    return;+  }++  opts = &argvars[2];+  if (opts->v_type != VAR_DICT) {+    EMSG2(_(e_invarg2),+          ""Third argument of async_invoke() must be a dictionary"");+    return;+  }++  // TODO(abdelhakeem): serialize and send context data as specified by ""opts""++  if (argvars[3].v_type != VAR_UNKNOWN+      && !callback_from_typval(&callback, &argvars[3])) {+    EMSG2(_(e_invarg2),+          ""Fourth argument of async_invoke() ""+          ""must be a function name or funcref"");+    return;+  }++  Channel *chan = acquire_asynccall_channel();+  if (!chan) {+    return;+  }++  chan->async_call = (AsyncCall *)xmalloc(sizeof(AsyncCall));+  chan->async_call->callback = callback;++  Array async_invoke_args = ARRAY_DICT_INIT;+  ADD(async_invoke_args, vim_to_object(callee));+  ADD(async_invoke_args, STRING_OBJ(cstr_to_string("""")));+  ADD(async_invoke_args, vim_to_object(args));++  if (!rpc_send_event(chan->id, ""nvim__async_invoke"", async_invoke_args)) {+    release_asynccall_channel(chan);+    return;+  }++  rettv->vval.v_number = chan->id;+}++/// ""call_wait(ids[, timeout])"" function+static void f_call_wait(typval_T *argvars, typval_T *rettv, FunPtr fptr)","This seems like another case where we could avoid a bunch of C code in favor of Lua. Perhaps the `job_results` list should be a Lua table, then it's easier to work with.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/9547,287573695,2019-05-25T20:03:04Z,test/functional/api/server_requests_spec.lua,"@@ -221,8 +221,8 @@ describe('server -> client', function()     end)      it('returns an error if the request failed', function()-      expect_err('Vim:Invalid method: does%-not%-exist',-                 eval, ""rpcrequest(vim, 'does-not-exist')"")+      eq({false, ""Vim:Error when invoking 'does-not-exist' on channel 3:\nInvalid method: does-not-exist"" },+         meth_pcall(eval, ""rpcrequest(vim, 'does-not-exist')""))",I guess we need a non-pattern variant of `expect_err()`..,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/9547,287596402,2019-05-26T12:43:52Z,test/functional/provider/python3_spec.lua,"@@ -40,8 +40,8 @@ describe('python3 provider', function()     -- mostly bogus.     local very_long_symbol = string.rep('a', 1200)     feed_command(':silent! py3 print('..very_long_symbol..' b)')-    -- Truncated error message would not contain this (last) line.-    eq('SyntaxError: invalid syntax', eval('v:errmsg'))+    -- Error message will contain this (last) line.+    eq('Error when invoking \'python_execute\' on channel 3 (python3-script-host):\n  File ""<string>"", line 1\n    print(aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa b)\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^\nSyntaxError: invalid syntax', eval('v:errmsg'))",could use `string.rep()` instead of  the literal string.The purpose of this test was to check very long symbol names.,
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/9170,288031607,2019-05-28T10:22:37Z,src/nvim/buffer.c,"@@ -1770,6 +1770,8 @@ buf_T * buflist_new(char_u *ffname, char_u *sfname, linenr_T lnum, int flags)   buf->b_p_bl = (flags & BLN_LISTED) ? true : false;    // init 'buflisted'   kv_destroy(buf->update_channels);   kv_init(buf->update_channels);+  kv_destroy(buf->update_callbacks);+  kv_init(buf->update_callbacks);","I'm not sure it does, the implementation and semantics would both be vastly different. For `ui.c`, treating internal callback as `RemoteUI` doesn't make any sense (none of the code there is needed for internal callback), having separate `LuiUI` type to implement the same interface would be much simpler. In this module, we could code golf away the separate array by storing callbacks as negative numbers or something. But it wouldn't make callbacks to be channels, just storing a union of both types in the same array.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/10097,289555492,2019-05-31T21:25:24Z,runtime/doc/channel.txt,"@@ -43,59 +43,66 @@ functions like |chansend()| consume channel ids. ============================================================================== 2. Reading and writing raw bytes			      *channel-bytes* -By default, channels opened by vimscript functions will operate with raw-bytes. Additionally, for a job channel using rpc, bytes can still be-read over its stderr. Similarily, only bytes can be written to nvim's own stderr.--			*channel-callback* *on_stdout* *on_stderr* *on_stdin* *on_data*-Scripts can react to channel activity (received data) via callback functions-assigned to the `on_stdout`, `on_stderr`, `on_stdin`, and `on_data` options.-Callbacks should be fast, avoid potentially slow/expensive work.+Channels opened by Vimscript functions operate with raw bytes by default. For+a job channel using RPC, bytes can still be read over its stderr. Similarily,+only bytes can be written to Nvim's own stderr.++						*channel-callback*+on_stdout({chan-id}, {data}, {name})		*on_stdout* +on_stderr({chan-id}, {data}, {name})		*on_stderr* +on_stdin({chan-id}, {data}, {name})		*on_stdin* +on_data({chan-id}, {data}, {name})		*on_data*+    Scripts can react to channel activity (received data) via callback+    functions assigned to the `on_stdout`, `on_stderr`, `on_stdin`, or+    `on_data` option keys. Callbacks should be fast: avoid potentially+    slow/expensive work.++    Parameters: ~+      {chan-id}     Channel handle. |channel-id|+      {data}	    Raw data (|readfile()|-style list of strings) read from+		    the channel. EOF is a single-item list: `['']`.+		    First and last items may be incomplete! |channel-lines|","""incomplete"" without quantifier presupposes the interpretation of items as output lines. maybe ""First and last items might be incomplete lines of the output""",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/10102,289619765,2019-06-01T22:10:45Z,src/nvim/fileio.c,"@@ -2310,6 +2310,10 @@ buf_write (   char_u          *fenc_tofree = NULL;   /* allocated ""fenc"" */ #ifdef HAS_BW_FLAGS   int wb_flags = 0;+#endif+  char_u *fname_res = NULL; // De-symlinked filename+#ifdef HAVE_READLINK+  char_u fname_res_buf[MAXPATHL];","good thought, but `NameBuff` cannot be used in `buf_write`:https://github.com/neovim/neovim/blob/2e171a6fd163e0d74c80d21a893cb6a3c3394b1f/src/nvim/fileio.c#L2241",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/7202,289788723,2019-06-03T10:52:37Z,test/functional/core/job_spec.lua,"@@ -32,6 +32,9 @@ describe('jobs', function()    before_each(function()     clear()++    assert:set_parameter('TableFormatLevel', 1000000)",Ah didn't know about this. That's why I added this: https://github.com/neovim/neovim/commit/3d1ed7c959017dc8664497b26c86c9ffabf02891#diff-75e5cc780c1d61f0c237fc0c0055711bR431Update: now documented in [test/README.md](https://github.com/neovim/neovim/blob/master/test/README.md#configuration),
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/9829,290145423,2019-06-04T06:37:07Z,src/nvim/tui/input.c,"@@ -48,6 +48,21 @@ void tinput_init(TermInput *input, Loop *loop)    int curflags = termkey_get_canonflags(input->tk);   termkey_set_canonflags(input->tk, curflags | TERMKEY_CANON_DELBS);+#ifdef WIN32+  if (!os_isatty(0)) {+      const HANDLE conin_handle = CreateFile(""CONIN$"",+                                             GENERIC_READ | GENERIC_WRITE,+                                             FILE_SHARE_READ | FILE_SHARE_WRITE,+                                             (LPSECURITY_ATTRIBUTES)NULL,+                                             OPEN_EXISTING, 0, (HANDLE)NULL);",is `FILE_SHARE_WRITE` needed? We do not specify it in https://github.com/neovim/neovim/blob/16b1e8f9c070ad853c6c63b43591e297bf512662/src/nvim/main.c#L1156,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/9943,290496800,2019-06-04T21:04:46Z,src/nvim/ex_docmd.c,"@@ -2423,9 +2423,14 @@ static char_u *find_command(exarg_T *eap, int *full)       while (ASCII_ISALNUM(*p))         ++p; -    /* check for non-alpha command */-    if (p == eap->cmd && vim_strchr((char_u *)""@!=><&~#"", *p) != NULL)-      ++p;+    // check for non-alpha command+    if (p == eap->cmd) {+      if (p[0] == '&' && p[1] == ':') {+        p = p + 2;+      } else if (vim_strchr((char_u *)""@!=><&~#"", *p) != NULL) {+        p++;+      }+    }","Other way to handle ambiguity:- add a new function like `ex_sub_or_async` which decides whether to call `ex_substitute` or `ex_async`.   -  use `skipwhite()`  to check if the next char is `:`. - in `ex_cmds.lua`,   - set `func='ex_sub_or_async'` for the `&` command.  - add `NOTRLCOM`Not sure if that's better, can just leave it for now.",
20467669,abdelhakeem,https://api.github.com/repos/neovim/neovim/pulls/9943,290513794,2019-06-04T21:58:07Z,src/nvim/ex_docmd.c,"@@ -2423,9 +2423,14 @@ static char_u *find_command(exarg_T *eap, int *full)       while (ASCII_ISALNUM(*p))         ++p; -    /* check for non-alpha command */-    if (p == eap->cmd && vim_strchr((char_u *)""@!=><&~#"", *p) != NULL)-      ++p;+    // check for non-alpha command+    if (p == eap->cmd) {+      if (p[0] == '&' && p[1] == ':') {+        p = p + 2;+      } else if (vim_strchr((char_u *)""@!=><&~#"", *p) != NULL) {+        p++;+      }+    }","Hmmm...I didn't want to change the `&` command mainly because semantically our new async command is not a special case of substitution.Concerning `&:vimgrep` handler, I need to modify it so that it can handle paths more properly just like `vimgrep`, currently it just search `glob(path, v:true, v:true)` of whatever path given, so paths like `**/*.h **/*.c` will not work unlike `vimgrep`, not a big deal to parse I guess.Not sure about the next step, maybe I'll add similar async equivalents to `vimgrepadd`, `lvimgrep`, and `lvimgrepadd` for now.I'm open to any kind of feedback, once we settle we can start working on the more interesting stuff like context handling and async calls of user-defined functions (which could be just making the called function part of the sent context and then call it as usual).",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/9943,290521427,2019-06-04T22:27:58Z,src/nvim/ex_docmd.c,"@@ -2423,9 +2423,14 @@ static char_u *find_command(exarg_T *eap, int *full)       while (ASCII_ISALNUM(*p))         ++p; -    /* check for non-alpha command */-    if (p == eap->cmd && vim_strchr((char_u *)""@!=><&~#"", *p) != NULL)-      ++p;+    // check for non-alpha command+    if (p == eap->cmd) {+      if (p[0] == '&' && p[1] == ':') {+        p = p + 2;+      } else if (vim_strchr((char_u *)""@!=><&~#"", *p) != NULL) {+        p++;+      }+    }","> Not sure about the next step, maybe I'll add similar async equivalents to `vimgrepadd`, `lvimgrep`, and `lvimgrepadd` for now.Yes, implementing a few more cases will help to start seeing a pattern (and see what's painful/boilerplate/brittle). Then we can start to form a best-practice for adding this functionality. ",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/10071,291357408,2019-06-06T20:27:12Z,src/nvim/api/ui_events.in.h,"@@ -11,79 +11,79 @@ #include ""nvim/ui.h""  void mode_info_set(Boolean enabled, Array cursor_styles)-  FUNC_API_SINCE(3);+  FUNC_API_SINCE(3) FUNC_API_REDRAW;","What we can do later on is to instead put a tag on the events that are _not_ implemented in the client, to convey the same information with less tags (as client should support almost all events, essentially everything but the events we already have deprecated). ",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/10071,291404775,2019-06-06T23:09:19Z,src/nvim/generators/gen_api_ui_events.lua,"@@ -80,6 +80,77 @@ function call_ui_event_method(output, ev)   output:write(');\n') end +function make_raw_line_and_call(output)+  -- arg_1 = grid, arg_2 = row, arg_3 = startcol, arg_4 = cells, arg_5 = endcol, arg_6 = clearcol, arg_7 = clearattr+  +  output:write([[+  Integer arg_5, arg_6, arg_7;","we try to avoid having big chunks of C code in the generator. If possible, put most of the C code in a `.c` file which then includes a generated `.h` file. _Assuming_ that doesn't make things even more convoluted :)",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/10071,291667322,2019-06-07T16:33:33Z,src/nvim/generators/gen_api_ui_events.lua,"@@ -50,6 +51,106 @@ function write_arglist(output, ev, need_copy)   end end +function extract_and_write_arglist(output, ev)+  local hlattrs_args_count = 0+  for j = 1, #ev.parameters do+    local param = ev.parameters[j]+    local kind = param[1]+    output:write('  '..kind..' arg_'..j..' = ')+    if kind == 'HlAttrs' then+      -- The first HlAttrs argument is rgb_attrs and second is cterm_attrs+      output:write('dict2hlattrs(args.items['..(j-1)..'].data.dictionary, '..(hlattrs_args_count == 0 and 'true' or 'false')..');\n')+      hlattrs_args_count = hlattrs_args_count + 1+    elseif kind == 'Object' then+      output:write('args.items['..(j-1)..'];\n')+    else+      output:write('args.items['..(j-1)..'].data.'..string.lower(kind)..';\n')+    end+  end+end++function call_ui_event_method(output, ev)+  output:write('  ui_call_'..ev.name..'(')+  for j = 1, #ev.parameters do+    output:write('arg_'..j)+    if j ~= #ev.parameters then+      output:write(', ')+    end+  end+  output:write(');\n')+end++function make_raw_line_and_call(output)+  -- arg_1 = grid, arg_2 = row, arg_3 = startcol, arg_4 = cells, arg_5 = endcol, arg_6 = clearcol, arg_7 = clearattr+  +  output:write([[+  Integer arg_5, arg_6, arg_7;+  LineFlags lineflags = kLineFlagWrap;+  schar_T *chunk;+  sattr_T *attrs;+  size_t size_of_cells = arg_4.size;+  size_t no_of_cells = size_of_cells;+  arg_5 = arg_3;++  // checking if clearcol > endcol+  if (!STRCMP(arg_4.items[size_of_cells-1].data.array.items[0].data.string.data, "" "")) {+    no_of_cells = size_of_cells - 1;+  }++  // getting endcol+  for (size_t i = 0; i < no_of_cells; i++) {+    arg_5++;+    if (arg_4.items[i].data.array.size == 3) {+      arg_5 += arg_4.items[i].data.array.items[2].data.integer - 1;+    }+  }++  size_t ncells = (size_t)(arg_5 - arg_3);+  chunk = xmalloc(ncells * sizeof(schar_T) + 1);+  attrs = xmalloc(ncells * sizeof(sattr_T) + 1);++  size_t j = 0;+  size_t k = 0;+  for (size_t i = 0; i < no_of_cells; i++) {+    STRCPY(chunk[j++], arg_4.items[i].data.array.items[0].data.string.data);+    if (arg_4.items[i].data.array.size == 3) {+      // repeat present+      for (size_t i_intr = 1; i_intr < (size_t)arg_4.items[i].data.array.items[2].data.integer; i_intr++) {+        STRCPY(chunk[j++], arg_4.items[i].data.array.items[0].data.string.data);+        attrs[k++] = (sattr_T)arg_4.items[i].data.array.items[1].data.integer;+      }+    } else if (arg_4.items[i].data.array.size == 2) {+      // repeat = 1 but attrs != last_hl+      attrs[k++] = (sattr_T)arg_4.items[i].data.array.items[1].data.integer;+    }+    if (j > k) {+      // attrs == last_hl+      attrs[k] = attrs[k-1];+      k++;+    }+  }++  if (!STRCMP(arg_4.items[size_of_cells-1].data.array.items[0].data.string.data, "" "")) { +    arg_7 = arg_4.items[size_of_cells-1].data.array.items[1].data.integer;","it is not guaranteed that `arg_4.items[size_of_cells-1].data.array` has three items even if the text is`"" ""`, need to check this.",
9766,blueyed,https://api.github.com/repos/neovim/neovim/pulls/10147,291804012,2019-06-08T11:33:09Z,src/nvim/ex_cmds2.c,"@@ -1791,18 +1791,17 @@ void ex_args(exarg_T *eap)   } else if (eap->cmdidx == CMD_args) {     // "":args"": list arguments.     if (ARGCOUNT > 0) {-      // Overwrite the command, for a short list there is no scrolling-      // required and no wait_return().-      gotocmdline(true);-      for (int i = 0; i < ARGCOUNT; i++) {-        if (i == curwin->w_arg_idx) {-          msg_putchar('[');+      char **items = (char **)xmalloc(sizeof(char *) * ARGCOUNT);","```../src/nvim/ex_cmds2.c: In function ���ex_args���:../src/nvim/ex_cmds2.c:1794:54: error: conversion to ���long unsigned int��� from ���int��� may change the sign of the result [-Werror=sign-conversion]       char **items = (char **)xmalloc(sizeof(char *) * ARGCOUNT);                                                      ^../src/nvim/ex_cmds2.c:1803:9: error: implicit declaration of function ���list_in_columns��� [-Werror=implicit-function-declaration]         list_in_columns(items, ARGCOUNT, curwin->w_arg_idx);         ^```What to do here?",
9766,blueyed,https://api.github.com/repos/neovim/neovim/pulls/10137,291804728,2019-06-08T12:04:23Z,scripts/vim-patch.sh,"@@ -392,7 +401,8 @@ list_missing_vimpatches() {       continue     fi -    if vim_tag=""$(git -C ""${VIM_SOURCE_DIR}"" describe --tags --exact-match ""${vim_commit}"" 2>/dev/null)""; then+    vim_tag=""${vim_commit_tags[$vim_commit]-}""","> ${parameter-default} and ${parameter:-default} are almost equivalent. The extra : makes a difference only when parameter has been declared, but is null.(via https://www.tldp.org/LDP/abs/html/parameter-substitution.html)",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/10098,291805441,2019-06-08T12:36:28Z,src/nvim/main.c,"@@ -738,22 +738,17 @@ static void init_locale(void)   setlocale(LC_NUMERIC, ""C""); # endif -# ifdef LOCALE_INSTALL_DIR    // gnu/linux standard: $prefix/share/locale-  bindtextdomain(PROJECT_NAME, LOCALE_INSTALL_DIR);-# else                        // old vim style: $runtime/lang-  {-    char_u  *p;--    // expand_env() doesn't work yet, because g_chartab[] is not-    // initialized yet, call vim_getenv() directly-    p = (char_u *)vim_getenv(""VIMRUNTIME"");-    if (p != NULL && *p != NUL) {-      vim_snprintf((char *)NameBuff, MAXPATHL, ""%s/lang"", p);-      bindtextdomain(PROJECT_NAME, (char *)NameBuff);-    }-    xfree(p);+  char localepath[MAXPATHL] = { 0 };+  char *exepath = localepath;+  size_t exepathlen = MAXPATHL;+  if (os_exepath(exepath, &exepathlen) != 0) {+    path_guess_exepath(argv0 ? argv0 : ""nvim"", exepath, sizeof(exepath));   }-# endif+  char *tail = (char *)path_tail_with_sep((char_u *)exepath);+  *tail = NUL;+  tail = (char *)path_tail((char_u *)exepath);+  xstrlcpy(tail, ""share/locale"", sizeof(localepath) - (tail - localepath));+  bindtextdomain(PROJECT_NAME, localepath);",does not regress 1a15cf84c29c984d600f438122edc70be2ac91a1 as long as we assume `@CMAKE_INSTALL_FULL_LOCALEDIR@` would always be in this form.I wonder if this conforms with BSD conventions.,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/10163,291838565,2019-06-09T14:25:50Z,src/nvim/testdir/test_startup.vim,"@@ -227,6 +227,81 @@ func Test_o_arg()   call delete('Xtestout') endfunc +func Test_invalid_args()+  if !has('unix') || has('gui_running')+    "" can't get output of Vim.+    return+  endif++  for opt in ['-Y', '--does-not-exist']+    let out = split(system(GetVimCommand() .. ' ' .. opt), ""\n"")+    call assert_equal(1, v:shell_error)+    call assert_equal('nvim: Unknown option argument: ""' .. opt .. '""', out[0])+    call assert_equal('More info with ""nvim -h""',                       out[1])+  endfor++  for opt in ['-c', '-i', '-s', '-t', '-u', '-U', '-w', '-W', '--cmd', '--startuptime']+    let out = split(system(GetVimCommand() .. ' '  .. opt), ""\n"")+    call assert_equal(1, v:shell_error)+    call assert_equal('nvim: Argument missing after: ""' .. opt .. '""', out[0])+    call assert_equal('More info with ""nvim -h""',                      out[1])+  endfor++  if has('clientserver')+    "" FIXME: need to add --servername to this list+    "" but it causes vim-8.1.1282 to crash!+    for opt in ['--remote', '--remote-send', '--remote-silent', '--remote-expr',+          \     '--remote-tab', '--remote-tab-wait',+          \     '--remote-tab-wait-silent', '--remote-tab-silent',+          \     '--remote-wait', '--remote-wait-silent',+          \    ]+      let out = split(system(GetVimCommand() .. ' '  .. opt), ""\n"")+      call assert_equal(1, v:shell_error)+      call assert_match('^VIM - Vi IMproved .* (.*)$',             out[0])+      call assert_equal('Argument missing after: ""' .. opt .. '""', out[1])+      call assert_equal('More info with: ""vim -h""',                out[2])+    endfor+  endif++  "" FIXME: commented out as this causes vim-8.1.1282 to crash!+  ""if has('clipboard')+  ""  let out = split(system(GetVimCommand() .. ' --display'), ""\n"")+  ""  call assert_equal(1, v:shell_error)+  ""  call assert_match('^VIM - Vi IMproved .* (.*)$',         out[0])+  ""  call assert_equal('Argument missing after: ""--display""', out[1])+  ""  call assert_equal('More info with: ""vim -h""',            out[2])+  ""endif++  let out = split(system(GetVimCommand() .. ' -ix'), ""\n"")+  call assert_equal(1, v:shell_error)+  call assert_equal('nvim: Garbage after option argument: ""-ix""', out[0])+  call assert_equal('More info with ""nvim -h""',                   out[1])++  "" XXX: nvim opens xxx here!?+  "" let out = split(system(GetVimCommand() .. ' - xxx'), ""\n"")","yes, this is a Nvim feature. Vim only allows one ""edit argument"" (one of the four listed at `:h vim-arguments`). Nvim allows `-` to be specified while _also_ supporting one of `-t`, `-q`, or `[file ...]`.So this is not an error in Nvim. See also https://vimways.org/2018/vims-social-life/ ���� Can leave this commented-out, but maybe change the comment to:    "" Not an error in Nvim.  The ""-"" file is allowed with -t, -q, or [file].",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/10123,291851035,2019-06-09T21:24:59Z,test/functional/lua/uv_spec.lua,"@@ -0,0 +1,53 @@+-- Test suite for testing interactions with API bindings+local helpers = require('test.functional.helpers')(after_each)+local funcs = helpers.funcs+local meths = helpers.meths+local clear = helpers.clear+local sleep = helpers.sleep+local eq = helpers.eq++before_each(clear)++describe('vim.uv', function()++  it('version', function()+    eq(72961, funcs.luaeval('vim.uv.version()'))+    eq(""1.29.1"", funcs.luaeval('vim.uv.version_string()'))",hard coding the version here is probably not so useful. Maybe could check it matches a regex (or lua pattern) for semver-like version.,
542599,zhaozg,https://api.github.com/repos/neovim/neovim/pulls/10123,291857981,2019-06-10T01:05:55Z,test/functional/lua/uv_spec.lua,"@@ -0,0 +1,53 @@+-- Test suite for testing interactions with API bindings+local helpers = require('test.functional.helpers')(after_each)+local funcs = helpers.funcs+local meths = helpers.meths+local clear = helpers.clear+local sleep = helpers.sleep+local eq = helpers.eq++before_each(clear)++describe('vim.uv', function()++  it('version', function()+    eq(72961, funcs.luaeval('vim.uv.version()'))+    eq(""1.29.1"", funcs.luaeval('vim.uv.version_string()'))","~~This just to check nvim use right luv/uv version, this should be changed after luv update every time.  Widening inspection conditions is good choice?~~",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/10171,292048935,2019-06-10T14:59:32Z,src/nvim/change.c,"@@ -0,0 +1,1805 @@+// This is an open source non-commercial project. Dear PVS-Studio, please check+// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com++/// change.c: functions related to changing text++#include ""nvim/assert.h""+#include ""nvim/buffer.h""+#include ""nvim/buffer_updates.h""+#include ""nvim/change.h""+#include ""nvim/charset.h""+#include ""nvim/cursor.h""+#include ""nvim/diff.h""+#include ""nvim/edit.h""+#include ""nvim/eval.h""+#include ""nvim/fileio.h""+#include ""nvim/fold.h""+#include ""nvim/indent.h""+#include ""nvim/indent_c.h""+#include ""nvim/mark.h""+#include ""nvim/memline.h""+#include ""nvim/misc1.h""+#include ""nvim/move.h""+#include ""nvim/option.h""+#include ""nvim/screen.h""+#include ""nvim/search.h""+#include ""nvim/state.h""+#include ""nvim/ui.h""+#include ""nvim/undo.h""++#ifdef INCLUDE_GENERATED_DECLARATIONS+# include ""change.c.generated.h""+#endif++/// If the file is readonly, give a warning message with the first change.+/// Don't do this for autocommands.+/// Doesn't use emsg(), because it flushes the macro buffer.+/// If we have undone all changes b_changed will be false, but ""b_did_warn""+/// will be true.+/// ""col"" is the column for the message; non-zero when in insert mode and+/// 'showmode' is on.+/// Careful: may trigger autocommands that reload the buffer.+void change_warning(int col)+{+  static char *w_readonly = N_(""W10: Warning: Changing a readonly file"");++  if (curbuf->b_did_warn == false+      && curbufIsChanged() == 0+      && !autocmd_busy+      && curbuf->b_p_ro) {+    curbuf_lock++;+    apply_autocmds(EVENT_FILECHANGEDRO, NULL, NULL, false, curbuf);+    curbuf_lock--;+    if (!curbuf->b_p_ro) {+        return;+    }+    // Do what msg() does, but with a column offset if the warning should+    // be after the mode message.+    msg_start();+    if (msg_row == Rows - 1) {+        msg_col = col;+    }+    msg_source(HL_ATTR(HLF_W));+    msg_ext_set_kind(""wmsg"");+    MSG_PUTS_ATTR(_(w_readonly), HL_ATTR(HLF_W) | MSG_HIST);+    set_vim_var_string(VV_WARNINGMSG, _(w_readonly), -1);+    msg_clr_eos();+    (void)msg_end();+    if (msg_silent == 0 && !silent_mode && ui_active()) {+      ui_flush();+      os_delay(1000L, true);  // give the user time to think about it+    }+    curbuf->b_did_warn = true;+    redraw_cmdline = false;  // don't redraw and erase the message+    if (msg_row < Rows - 1) {+        showmode();+    }+  }+}++/// Call this function when something in the current buffer is changed.+///+/// Most often called through changed_bytes() and changed_lines(), which also+/// mark the area of the display to be redrawn.+///+/// Careful: may trigger autocommands that reload the buffer.+void changed(void)+{+  if (!curbuf->b_changed) {+    int save_msg_scroll = msg_scroll;++    // Give a warning about changing a read-only file.  This may also+    // check-out the file, thus change ""curbuf""!+    change_warning(0);++    // Create a swap file if that is wanted.+    // Don't do this for ""nofile"" and ""nowrite"" buffer types.+    if (curbuf->b_may_swap+        && !bt_dontwrite(curbuf)+        ) {+      int save_need_wait_return = need_wait_return;++      need_wait_return = false;+      ml_open_file(curbuf);++      // The ml_open_file() can cause an ATTENTION message.+      // Wait two seconds, to make sure the user reads this unexpected+      // message.  Since we could be anywhere, call wait_return() now,+      // and don't let the emsg() set msg_scroll.+      if (need_wait_return && emsg_silent == 0) {+        ui_flush();+        os_delay(2000L, true);+        wait_return(true);+        msg_scroll = save_msg_scroll;+      } else {+        need_wait_return = save_need_wait_return;+      }+    }+    changed_internal();+  }+  buf_inc_changedtick(curbuf);++  // If a pattern is highlighted, the position may now be invalid.+  highlight_match = false;+}++/// Internal part of changed(), no user interaction.+/// Also used for recovery.+void changed_internal(void)+{+  curbuf->b_changed = true;+  ml_setflags(curbuf);+  check_status(curbuf);+  redraw_tabline = true;+  need_maketitle = true;  // set window title later+}++/// Common code for when a change was made.+/// See changed_lines() for the arguments.+/// Careful: may trigger autocommands that reload the buffer.+static void changed_common(linenr_T lnum, colnr_T col, linenr_T lnume,+                           long xtra)+{+  int i;+  int cols;+  pos_T       *p;+  int add;++  // mark the buffer as modified+  changed();++  if (curwin->w_p_diff && diff_internal()) {+    curtab->tp_diff_update = true;+  }++  // set the '. mark+  if (!cmdmod.keepjumps) {+    RESET_FMARK(&curbuf->b_last_change, ((pos_T) { lnum, col, 0 }), 0);++    // Create a new entry if a new undo-able change was started or we+    // don't have an entry yet.+    if (curbuf->b_new_change || curbuf->b_changelistlen == 0) {+      if (curbuf->b_changelistlen == 0) {+          add = true;+      } else {+        // Don't create a new entry when the line number is the same+        // as the last one and the column is not too far away.  Avoids+        // creating many entries for typing ""xxxxx"".+        p = &curbuf->b_changelist[curbuf->b_changelistlen - 1].mark;+        if (p->lnum != lnum) {+            add = true;+        } else {+          cols = comp_textwidth(false);+          if (cols == 0) {+              cols = 79;+          }+          add = (p->col + cols < col || col + cols < p->col);+        }+      }+      if (add) {+        // This is the first of a new sequence of undo-able changes+        // and it's at some distance of the last change.  Use a new+        // position in the changelist.+        curbuf->b_new_change = false;++        if (curbuf->b_changelistlen == JUMPLISTSIZE) {+          // changelist is full: remove oldest entry+          curbuf->b_changelistlen = JUMPLISTSIZE - 1;+          memmove(curbuf->b_changelist, curbuf->b_changelist + 1,+                  sizeof(curbuf->b_changelist[0]) * (JUMPLISTSIZE - 1));+          FOR_ALL_TAB_WINDOWS(tp, wp) {+            // Correct position in changelist for other windows on+            // this buffer.+            if (wp->w_buffer == curbuf && wp->w_changelistidx > 0) {+              wp->w_changelistidx--;+            }+          }+        }+        FOR_ALL_TAB_WINDOWS(tp, wp) {+          // For other windows, if the position in the changelist is+          // at the end it stays at the end.+          if (wp->w_buffer == curbuf+              && wp->w_changelistidx == curbuf->b_changelistlen) {+            wp->w_changelistidx++;+          }+        }+        curbuf->b_changelistlen++;+      }+    }+    curbuf->b_changelist[curbuf->b_changelistlen - 1] =+      curbuf->b_last_change;+    // The current window is always after the last change, so that ""g,""+    // takes you back to it.+    curwin->w_changelistidx = curbuf->b_changelistlen;+  }++  FOR_ALL_TAB_WINDOWS(tp, wp) {+    if (wp->w_buffer == curbuf) {+      // Mark this window to be redrawn later.+      if (wp->w_redr_type < VALID) {+          wp->w_redr_type = VALID;+      }++      // Check if a change in the buffer has invalidated the cached+      // values for the cursor.+      // Update the folds for this window.  Can't postpone this, because+      // a following operator might work on the whole fold: "">>dd"".+      foldUpdate(wp, lnum, lnume + xtra - 1);++      // The change may cause lines above or below the change to become+      // included in a fold.  Set lnum/lnume to the first/last line that+      // might be displayed differently.+      // Set w_cline_folded here as an efficient way to update it when+      // inserting lines just above a closed fold. */+      bool folded = hasFoldingWin(wp, lnum, &lnum, NULL, false, NULL);+      if (wp->w_cursor.lnum == lnum) {+          wp->w_cline_folded = folded;+      }+      folded = hasFoldingWin(wp, lnume, NULL, &lnume, false, NULL);+      if (wp->w_cursor.lnum == lnume) {+          wp->w_cline_folded = folded;+      }++      // If the changed line is in a range of previously folded lines,+      // compare with the first line in that range.+      if (wp->w_cursor.lnum <= lnum) {+        i = find_wl_entry(wp, lnum);+        if (i >= 0 && wp->w_cursor.lnum > wp->w_lines[i].wl_lnum) {+            changed_line_abv_curs_win(wp);+        }+      }++      if (wp->w_cursor.lnum > lnum) {+          changed_line_abv_curs_win(wp);+      } else if (wp->w_cursor.lnum == lnum && wp->w_cursor.col >= col) {+          changed_cline_bef_curs_win(wp);+      }+      if (wp->w_botline >= lnum) {+        // Assume that botline doesn't change (inserted lines make+        // other lines scroll down below botline).+        approximate_botline_win(wp);+      }++      // Check if any w_lines[] entries have become invalid.+      // For entries below the change: Correct the lnums for+      // inserted/deleted lines.  Makes it possible to stop displaying+      // after the change.+      for (i = 0; i < wp->w_lines_valid; i++) {+        if (wp->w_lines[i].wl_valid) {+          if (wp->w_lines[i].wl_lnum >= lnum) {+            if (wp->w_lines[i].wl_lnum < lnume) {+              // line included in change+              wp->w_lines[i].wl_valid = false;+            } else if (xtra != 0) {+              // line below change+              wp->w_lines[i].wl_lnum += xtra;+              wp->w_lines[i].wl_lastlnum += xtra;+            }+          } else if (wp->w_lines[i].wl_lastlnum >= lnum) {+            // change somewhere inside this range of folded lines,+            // may need to be redrawn+            wp->w_lines[i].wl_valid = false;+          }+        }+      }++      // Take care of side effects for setting w_topline when folds have+      // changed.  Esp. when the buffer was changed in another window.+      if (hasAnyFolding(wp)) {+        set_topline(wp, wp->w_topline);+      }++      // relative numbering may require updating more+      if (wp->w_p_rnu) {+        redraw_win_later(wp, SOME_VALID);+      }+    }+  }++  // Call update_screen() later, which checks out what needs to be redrawn,+  // since it notices b_mod_set and then uses b_mod_*.+  if (must_redraw < VALID) {+    must_redraw = VALID;+  }++  // when the cursor line is changed always trigger CursorMoved+  if (lnum <= curwin->w_cursor.lnum+      && lnume + (xtra < 0 ? -xtra : xtra) > curwin->w_cursor.lnum) {+    curwin->w_last_cursormoved.lnum = 0;+  }+}++static void changedOneline(buf_T *buf, linenr_T lnum)+{+  if (buf->b_mod_set) {+    // find the maximum area that must be redisplayed+    if (lnum < buf->b_mod_top) {+        buf->b_mod_top = lnum;+    } else if (lnum >= buf->b_mod_bot) {+        buf->b_mod_bot = lnum + 1;+    }+  } else {+    // set the area that must be redisplayed to one line+    buf->b_mod_set = true;+    buf->b_mod_top = lnum;+    buf->b_mod_bot = lnum + 1;+    buf->b_mod_xlines = 0;+  }+}++/// Changed bytes within a single line for the current buffer.+/// - marks the windows on this buffer to be redisplayed+/// - marks the buffer changed by calling changed()+/// - invalidates cached values+/// Careful: may trigger autocommands that reload the buffer.+void changed_bytes(linenr_T lnum, colnr_T col)+{+  changedOneline(curbuf, lnum);+  changed_common(lnum, col, lnum + 1, 0L);+  // notify any channels that are watching+  buf_updates_send_changes(curbuf, lnum, 1, 1, true);++  // Diff highlighting in other diff windows may need to be updated too.+  if (curwin->w_p_diff) {+    linenr_T wlnum;++    FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {+      if (wp->w_p_diff && wp != curwin) {+        redraw_win_later(wp, VALID);+        wlnum = diff_lnum_win(lnum, wp);+        if (wlnum > 0) {+            changedOneline(wp->w_buffer, wlnum);+        }+      }+    }+  }+}++/// Appended ""count"" lines below line ""lnum"" in the current buffer.+/// Must be called AFTER the change and after mark_adjust().+/// Takes care of marking the buffer to be redrawn and sets the changed flag.+void appended_lines(linenr_T lnum, long count)+{+  changed_lines(lnum + 1, 0, lnum + 1, count, true);+}++/// Like appended_lines(), but adjust marks first.+void appended_lines_mark(linenr_T lnum, long count)+{+  // Skip mark_adjust when adding a line after the last one, there can't+  // be marks there. But it's still needed in diff mode.+  if (lnum + count < curbuf->b_ml.ml_line_count || curwin->w_p_diff) {+    mark_adjust(lnum + 1, (linenr_T)MAXLNUM, count, 0L, false);+  }+  changed_lines(lnum + 1, 0, lnum + 1, count, true);+}++/// Deleted ""count"" lines at line ""lnum"" in the current buffer.+/// Must be called AFTER the change and after mark_adjust().+/// Takes care of marking the buffer to be redrawn and sets the changed flag.+void deleted_lines(linenr_T lnum, long count)+{+  changed_lines(lnum, 0, lnum + count, -count, true);+}++/// Like deleted_lines(), but adjust marks first.+/// Make sure the cursor is on a valid line before calling, a GUI callback may+/// be triggered to display the cursor.+void deleted_lines_mark(linenr_T lnum, long count)+{+  mark_adjust(lnum, (linenr_T)(lnum + count - 1), (long)MAXLNUM, -count, false);+  changed_lines(lnum, 0, lnum + count, -count, true);+}++/// Marks the area to be redrawn after a change.+///+/// @param buf the buffer where lines were changed+/// @param lnum first line with change+/// @param lnume line below last changed line+/// @param xtra number of extra lines (negative when deleting)+void changed_lines_buf(buf_T *buf, linenr_T lnum, linenr_T lnume, long xtra)+{+  if (buf->b_mod_set) {+    // find the maximum area that must be redisplayed+    if (lnum < buf->b_mod_top) {+      buf->b_mod_top = lnum;+    }+    if (lnum < buf->b_mod_bot) {+      // adjust old bot position for xtra lines+      buf->b_mod_bot += xtra;+      if (buf->b_mod_bot < lnum) {+        buf->b_mod_bot = lnum;+      }+    }+    if (lnume + xtra > buf->b_mod_bot) {+      buf->b_mod_bot = lnume + xtra;+    }+    buf->b_mod_xlines += xtra;+  } else {+    // set the area that must be redisplayed+    buf->b_mod_set = true;+    buf->b_mod_top = lnum;+    buf->b_mod_bot = lnume + xtra;+    buf->b_mod_xlines = xtra;+  }+}++/// Changed lines for the current buffer.+/// Must be called AFTER the change and after mark_adjust().+/// - mark the buffer changed by calling changed()+/// - mark the windows on this buffer to be redisplayed+/// - invalidate cached values+/// ""lnum"" is the first line that needs displaying, ""lnume"" the first line+/// below the changed lines (BEFORE the change).+/// When only inserting lines, ""lnum"" and ""lnume"" are equal.+/// Takes care of calling changed() and updating b_mod_*.+/// Careful: may trigger autocommands that reload the buffer.+void+changed_lines(+    linenr_T lnum,        // first line with change+    colnr_T col,          // column in first line with change+    linenr_T lnume,       // line below last changed line+    long xtra,            // number of extra lines (negative when deleting)+    bool do_buf_event  // some callers like undo/redo call changed_lines()+                       // and then increment changedtick *again*. This flag+                       // allows these callers to send the nvim_buf_lines_event+                       // events after they're done modifying changedtick.+)+{+  changed_lines_buf(curbuf, lnum, lnume, xtra);++  if (xtra == 0 && curwin->w_p_diff && !diff_internal()) {+    // When the number of lines doesn't change then mark_adjust() isn't+    // called and other diff buffers still need to be marked for+    // displaying.+    linenr_T wlnum;++    FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {+      if (wp->w_p_diff && wp != curwin) {+        redraw_win_later(wp, VALID);+        wlnum = diff_lnum_win(lnum, wp);+        if (wlnum > 0) {+          changed_lines_buf(wp->w_buffer, wlnum,+                            lnume - lnum + wlnum, 0L);+        }+      }+    }+  }++  changed_common(lnum, col, lnume, xtra);++  if (do_buf_event) {+    int64_t num_added = (int64_t)(lnume + xtra - lnum);+    int64_t num_removed = lnume - lnum;+    buf_updates_send_changes(curbuf, lnum, num_added, num_removed, true);+  }+}++/// Called when the changed flag must be reset for buffer ""buf"".+/// When ""ff"" is true also reset 'fileformat'.+void unchanged(buf_T *buf, int ff)+{+  if (buf->b_changed || (ff && file_ff_differs(buf, false))) {+    buf->b_changed = false;+    ml_setflags(buf);+    if (ff) {+      save_file_ff(buf);+    }+    check_status(buf);+    redraw_tabline = true;+    need_maketitle = true;  // set window title later+  }+  buf_inc_changedtick(buf);+}++/// Insert string ""p"" at the cursor position.  Stops at a NUL byte.+/// Handles Replace mode and multi-byte characters.+void ins_bytes(char_u *p)+{+  ins_bytes_len(p, STRLEN(p));+}++/// Insert string ""p"" with length ""len"" at the cursor position.+/// Handles Replace mode and multi-byte characters.+void ins_bytes_len(char_u *p, size_t len)+{+  if (has_mbyte) {+    size_t n;+    for (size_t i = 0; i < len; i += n) {+      if (enc_utf8) {+        // avoid reading past p[len]+        n = (size_t)utfc_ptr2len_len(p + i, (int)(len - i));+      } else {+        n = (size_t)(*mb_ptr2len)(p + i);+      }+      ins_char_bytes(p + i, n);+    }+  } else {+    for (size_t i = 0; i < len; i++) {+      ins_char(p[i]);+    }+  }+}++/// Insert or replace a single character at the cursor position.+/// When in REPLACE or VREPLACE mode, replace any existing character.+/// Caller must have prepared for undo.+/// For multi-byte characters we get the whole character, the caller must+/// convert bytes to a character.+void ins_char(int c)+{+  char_u buf[MB_MAXBYTES + 1];+  size_t n = (size_t)utf_char2bytes(c, buf);++  // When ""c"" is 0x100, 0x200, etc. we don't want to insert a NUL byte.+  // Happens for CTRL-Vu9900.+  if (buf[0] == 0) {+    buf[0] = '\n';+  }+  ins_char_bytes(buf, n);+}++void ins_char_bytes(char_u *buf, size_t charlen)+{+  // Break tabs if needed.+  if (virtual_active() && curwin->w_cursor.coladd > 0) {+    coladvance_force(getviscol());+  }++  size_t col = (size_t)curwin->w_cursor.col;+  linenr_T lnum = curwin->w_cursor.lnum;+  char_u *oldp = ml_get(lnum);+  size_t linelen = STRLEN(oldp) + 1;  // length of old line including NUL++  // The lengths default to the values for when not replacing.+  size_t oldlen = 0;        // nr of bytes inserted+  size_t newlen = charlen;  // nr of bytes deleted (0 when not replacing)++  if (State & REPLACE_FLAG) {+    if (State & VREPLACE_FLAG) {+      // Disable 'list' temporarily, unless 'cpo' contains the 'L' flag.+      // Returns the old value of list, so when finished,+      // curwin->w_p_list should be set back to this.+      int old_list = curwin->w_p_list;+      if (old_list && vim_strchr(p_cpo, CPO_LISTWM) == NULL) {+        curwin->w_p_list = false;+      }+      // In virtual replace mode each character may replace one or more+      // characters (zero if it's a TAB).  Count the number of bytes to+      // be deleted to make room for the new character, counting screen+      // cells.  May result in adding spaces to fill a gap.+      colnr_T vcol;+      getvcol(curwin, &curwin->w_cursor, NULL, &vcol, NULL);+      colnr_T new_vcol = vcol + chartabsize(buf, vcol);+      while (oldp[col + oldlen] != NUL && vcol < new_vcol) {+        vcol += chartabsize(oldp + col + oldlen, vcol);+        // Don't need to remove a TAB that takes us to the right+        // position.+        if (vcol > new_vcol && oldp[col + oldlen] == TAB) {+          break;+        }+        oldlen += (size_t)(*mb_ptr2len)(oldp + col + oldlen);+        // Deleted a bit too much, insert spaces.+        if (vcol > new_vcol) {+          newlen += (size_t)(vcol - new_vcol);+        }+      }+      curwin->w_p_list = old_list;+    } else if (oldp[col] != NUL)  {+      // normal replace+      oldlen = (size_t)(*mb_ptr2len)(oldp + col);+    }+++    // Push the replaced bytes onto the replace stack, so that they can be+    // put back when BS is used.  The bytes of a multi-byte character are+    // done the other way around, so that the first byte is popped off+    // first (it tells the byte length of the character).+    replace_push(NUL);+    for (size_t i = 0; i < oldlen; i++) {+      if (has_mbyte) {+        i += (size_t)replace_push_mb(oldp + col + i) - 1;+      } else {+        replace_push(oldp[col + i]);+      }+    }+  }++  char_u *newp = xmalloc((size_t)(linelen + newlen - oldlen));++  // Copy bytes before the cursor.+  if (col > 0) {+    memmove(newp, oldp, (size_t)col);+  }++  // Copy bytes after the changed character(s).+  char_u *p = newp + col;+  if (linelen > col + oldlen) {+    memmove(p + newlen, oldp + col + oldlen,+            (size_t)(linelen - col - oldlen));+  }++  // Insert or overwrite the new character.+  memmove(p, buf, charlen);++  // Fill with spaces when necessary.+  for (size_t i = charlen; i < newlen; i++) {+    p[i] = ' ';+  }++  // Replace the line in the buffer.+  ml_replace(lnum, newp, false);++  // mark the buffer as changed and prepare for displaying+  changed_bytes(lnum, (colnr_T)col);++  // If we're in Insert or Replace mode and 'showmatch' is set, then briefly+  // show the match for right parens and braces.+  if (p_sm && (State & INSERT)+      && msg_silent == 0+      && !ins_compl_active()+      ) {+    showmatch(utf_ptr2char(buf));+  }++  if (!p_ri || (State & REPLACE_FLAG)) {+    // Normal insert: move cursor right+    curwin->w_cursor.col += (int)charlen;+  }+  // TODO(Bram): should try to update w_row here, to avoid recomputing it later.+}++/// Insert a string at the cursor position.+/// Note: Does NOT handle Replace mode.+/// Caller must have prepared for undo.+void ins_str(char_u *s)+{+  char_u      *oldp, *newp;+  int newlen = (int)STRLEN(s);+  int oldlen;+  colnr_T col;+  linenr_T lnum = curwin->w_cursor.lnum;++  if (virtual_active() && curwin->w_cursor.coladd > 0) {+    coladvance_force(getviscol());+  }++  col = curwin->w_cursor.col;+  oldp = ml_get(lnum);+  oldlen = (int)STRLEN(oldp);++  newp = (char_u *)xmalloc((size_t)(oldlen + newlen + 1));+  if (col > 0) {+    memmove(newp, oldp, (size_t)col);+  }+  memmove(newp + col, s, (size_t)newlen);+  memmove(newp + col + newlen, oldp + col, (size_t)(oldlen - col + 1));+  ml_replace(lnum, newp, false);+  changed_bytes(lnum, col);+  curwin->w_cursor.col += newlen;+}++// Delete one character under the cursor.+// If ""fixpos"" is true, don't leave the cursor on the NUL after the line.+// Caller must have prepared for undo.+//+// return FAIL for failure, OK otherwise+int del_char(bool fixpos)+{+  if (has_mbyte) {+    // Make sure the cursor is at the start of a character.+    mb_adjust_cursor();+    if (*get_cursor_pos_ptr() == NUL) {+      return FAIL;+    }+    return del_chars(1L, fixpos);+  }+  return del_bytes(1, fixpos, true);+}++/// Like del_bytes(), but delete characters instead of bytes.+int del_chars(long count, int fixpos)+{+  int bytes = 0;+  long i;+  char_u      *p;+  int l;++  p = get_cursor_pos_ptr();+  for (i = 0; i < count && *p != NUL; i++) {+    l = (*mb_ptr2len)(p);+    bytes += l;+    p += l;+  }+  return del_bytes(bytes, fixpos, true);+}++/// Delete ""count"" bytes under the cursor.+/// If ""fixpos"" is true, don't leave the cursor on the NUL after the line.+/// Caller must have prepared for undo.+///+/// @param  count           number of bytes to be deleted+/// @param  fixpos_arg      leave the cursor on the NUL after the line+/// @param  use_delcombine  'delcombine' option applies+///+/// @return FAIL for failure, OK otherwise+int del_bytes(colnr_T count, bool fixpos_arg, bool use_delcombine)+{+  linenr_T lnum = curwin->w_cursor.lnum;+  colnr_T col = curwin->w_cursor.col;+  bool fixpos = fixpos_arg;+  char_u *oldp = ml_get(lnum);+  colnr_T oldlen = (colnr_T)STRLEN(oldp);++  // Can't do anything when the cursor is on the NUL after the line.+  if (col >= oldlen) {+    return FAIL;+  }+  // If ""count"" is zero there is nothing to do.+  if (count == 0) {+    return OK;+  }+  // If ""count"" is negative the caller must be doing something wrong.+  if (count < 1) {+    IEMSGN(""E950: Invalid count for del_bytes(): %ld"", count);+    return FAIL;+  }++  // If 'delcombine' is set and deleting (less than) one character, only+  // delete the last combining character.+  if (p_deco && use_delcombine && enc_utf8+      && utfc_ptr2len(oldp + col) >= count) {+    int cc[MAX_MCO];+    int n;++    (void)utfc_ptr2char(oldp + col, cc);+    if (cc[0] != NUL) {+      // Find the last composing char, there can be several.+      n = col;+      do {+        col = n;+        count = utf_ptr2len(oldp + n);+        n += count;+      } while (UTF_COMPOSINGLIKE(oldp + col, oldp + n));+      fixpos = false;+    }+  }++  // When count is too big, reduce it.+  int movelen = oldlen - col - count + 1;  // includes trailing NUL+  if (movelen <= 1) {+     // If we just took off the last character of a non-blank line, and+     // fixpos is true, we don't want to end up positioned at the NUL,+     // unless ""restart_edit"" is set or 'virtualedit' contains ""onemore"".+    if (col > 0 && fixpos && restart_edit == 0+        && (ve_flags & VE_ONEMORE) == 0+        ) {+      curwin->w_cursor.col--;+      curwin->w_cursor.coladd = 0;+      curwin->w_cursor.col -= utf_head_off(oldp, oldp + curwin->w_cursor.col);+    }+    count = oldlen - col;+    movelen = 1;+  }++  // If the old line has been allocated the deletion can be done in the+  // existing line. Otherwise a new line has to be allocated.+  bool was_alloced = ml_line_alloced();     // check if oldp was allocated+  char_u *newp;+  if (was_alloced) {+    newp = oldp;                            // use same allocated memory+  } else {                                  // need to allocate a new line+    newp = xmalloc((size_t)(oldlen + 1 - count));+    memmove(newp, oldp, (size_t)col);+  }+  memmove(newp + col, oldp + col + count, (size_t)movelen);+  if (!was_alloced) {+    ml_replace(lnum, newp, false);+  }++  // mark the buffer as changed and prepare for displaying+  changed_bytes(lnum, curwin->w_cursor.col);++  return OK;+}++/// Copy the indent from ptr to the current line (and fill to size).+/// Leaves the cursor on the first non-blank in the line.+/// @return true if the line was changed.+int copy_indent(int size, char_u *src)+{+  char_u *p = NULL;+  char_u *line = NULL;+  char_u *s;+  int todo;+  int ind_len;+  int line_len = 0;+  int tab_pad;+  int ind_done;+  int round;++  // Round 1: compute the number of characters needed for the indent+  // Round 2: copy the characters.+  for (round = 1; round <= 2; round++) {+    todo = size;+    ind_len = 0;+    ind_done = 0;+    s = src;++    // Count/copy the usable portion of the source line.+    while (todo > 0 && ascii_iswhite(*s)) {+      if (*s == TAB) {+        tab_pad = (int)curbuf->b_p_ts+                  - (ind_done % (int)curbuf->b_p_ts);++        // Stop if this tab will overshoot the target.+        if (todo < tab_pad) {+          break;+        }+        todo -= tab_pad;+        ind_done += tab_pad;+      } else {+        todo--;+        ind_done++;+      }+      ind_len++;++      if (p != NULL) {+        *p++ = *s;+      }+      s++;+    }++    // Fill to next tabstop with a tab, if possible.+    tab_pad = (int)curbuf->b_p_ts - (ind_done % (int)curbuf->b_p_ts);++    if ((todo >= tab_pad) && !curbuf->b_p_et) {+      todo -= tab_pad;+      ind_len++;++      if (p != NULL) {+        *p++ = TAB;+      }+    }++    // Add tabs required for indent.+    while (todo >= (int)curbuf->b_p_ts && !curbuf->b_p_et) {+      todo -= (int)curbuf->b_p_ts;+      ind_len++;++      if (p != NULL) {+        *p++ = TAB;+      }+    }++    // Count/add spaces required for indent.+    while (todo > 0) {+      todo--;+      ind_len++;++      if (p != NULL) {+        *p++ = ' ';+      }+    }++    if (p == NULL) {+      // Allocate memory for the result: the copied indent, new indent+      // and the rest of the line.+      line_len = (int)STRLEN(get_cursor_line_ptr()) + 1;+      assert(ind_len + line_len >= 0);+      size_t line_size;+      STRICT_ADD(ind_len, line_len, &line_size, size_t);+      line = xmalloc(line_size);+      p = line;+    }+  }++  // Append the original line+  memmove(p, get_cursor_line_ptr(), (size_t)line_len);++  // Replace the line+  ml_replace(curwin->w_cursor.lnum, line, false);++  // Put the cursor after the indent.+  curwin->w_cursor.col = ind_len;+  return true;+}++/// open_line: Add a new line below or above the current line.+///+/// For VREPLACE mode, we only add a new line when we get to the end of the+/// file, otherwise we just start replacing the next line.+///+/// Caller must take care of undo.  Since VREPLACE may affect any number of+/// lines however, it may call u_save_cursor() again when starting to change a+/// new line.+/// ""flags"": OPENLINE_DELSPACES delete spaces after cursor+///          OPENLINE_DO_COM    format comments+///          OPENLINE_KEEPTRAIL keep trailing spaces+///          OPENLINE_MARKFIX   adjust mark positions after the line break+///          OPENLINE_COM_LIST  format comments with list or 2nd line indent+///+/// ""second_line_indent"": indent for after ^^D in Insert mode or if flag+///                       OPENLINE_COM_LIST+///+/// @return true on success, false on failure","Just ignore it for now. When we merge to master, the linter will update its list of ignored lines.",
9766,blueyed,https://api.github.com/repos/neovim/neovim/pulls/10162,292390054,2019-06-11T10:40:32Z,src/nvim/testdir/test_usercommands.vim,"@@ -88,6 +179,8 @@ func Test_Ambiguous()   Do   call assert_equal('also', g:didthat)   delcommand Dothat++  call assert_fails(""\x4ei\041"", ' you demand a ')","> I am still confused by not finding ""shrubbery"" in Vim's sources though.���Mystery solved thanks to osse on `#vim`: https://github.com/vim/vim/blob/12ee7ff00b91d852e060bb24951d1c94239863eb/src/ex_docmd.c#L1909-L1914https://github.com/vim/vim/blob/12ee7ff00b91d852e060bb24951d1c94239863eb/src/usercmd.c#L547-L560 The `:Ni!` easter egg was removed in 87e107d92.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/10162,292415578,2019-06-11T11:54:45Z,src/nvim/testdir/test_usercommands.vim,"@@ -88,6 +179,8 @@ func Test_Ambiguous()   Do   call assert_equal('also', g:didthat)   delcommand Dothat++  call assert_fails(""\x4ei\041"", ' you demand a ')","Yeah. That's pretty silly though. ~~If we can adjust the test to use `:checkhealth` then that would be preferred. Otherwise  restore the easter egg.~~ That easter is (relatively) a lot of code for something useless, and it's also _obfuscated_, which is atrocious. ",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/10171,292419112,2019-06-11T12:05:09Z,src/nvim/api/buffer.c,"@@ -14,6 +14,7 @@ #include ""nvim/api/private/defs.h"" #include ""nvim/vim.h"" #include ""nvim/buffer.h""+#include ""nvim/change.h""","I wouldn't bother until we finish removing `misc1.c` completely (would be a nice milestone--we removed `misc2.c` years ago, but `misc1.c` has been clinging to life for too long :) ",
9766,blueyed,https://api.github.com/repos/neovim/neovim/pulls/6911,293916811,2019-06-14T17:59:12Z,src/nvim/lua/vim.lua,"@@ -38,8 +38,8 @@ -- Returns: --    {errcode}, {output} local function _system(cmd)-  local out = vim.api.nvim_call_function('system', { cmd })-  local err = vim.api.nvim_get_vvar('shell_error')+  local out = vim.api.nvim_call_function('system', { cmd }) --luacheck: ignore 113+  local err = vim.api.nvim_get_vvar('shell_error') --luacheck: ignore 113",See https://github.com/awesomewm/awesome/blob/3e3c34bdd194cf75cc16a87e82b11f8df3e7c5de/.luacheckrc for more ideas.,
9766,blueyed,https://api.github.com/repos/neovim/neovim/pulls/10229,294036344,2019-06-15T06:06:00Z,test/functional/terminal/tui_spec.lua,"@@ -871,14 +871,22 @@ describe('TUI background color', function()     screen:expect{any='did OptionSet, yay!'}   end) +  local last_bg   local function assert_bg(colorspace, color, bg)     it('handles '..color..' as '..bg, function()++      -- Ensure the opposite of the expected bg is active.+      if bg == last_bg then+        command('set bg=' .. (bg == 'dark' and 'light' or 'dark'))+      end+      last_bg = bg+       feed_data('\027]11;'..colorspace..':'..color..'\007')       -- Retry until the terminal response is handled.       retry(100, nil, function()         feed_data(':echo &background\n')         screen:expect({-          timeout=40,+          timeout=20,","Why does this need `screen:expect` in the first place?I.e. what is missing with just `eq('&bg', bg')`?  Could redrawing the screen be triggered explicitly somehow?(not wanting to change this necessarily, but just out of curiosity)",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/10229,294038974,2019-06-15T08:03:11Z,test/functional/terminal/tui_spec.lua,"@@ -871,14 +871,22 @@ describe('TUI background color', function()     screen:expect{any='did OptionSet, yay!'}   end) +  local last_bg   local function assert_bg(colorspace, color, bg)     it('handles '..color..' as '..bg, function()++      -- Ensure the opposite of the expected bg is active.+      if bg == last_bg then+        command('set bg=' .. (bg == 'dark' and 'light' or 'dark'))","similarly, I think this should use `feed_data(':set bg=' ... '\n')`",
9766,blueyed,https://api.github.com/repos/neovim/neovim/pulls/10229,294090155,2019-06-16T15:47:20Z,test/functional/terminal/tui_spec.lua,"@@ -871,14 +871,22 @@ describe('TUI background color', function()     screen:expect{any='did OptionSet, yay!'}   end) +  local last_bg   local function assert_bg(colorspace, color, bg)     it('handles '..color..' as '..bg, function()++      -- Ensure the opposite of the expected bg is active.+      if bg == last_bg then+        command('set bg=' .. (bg == 'dark' and 'light' or 'dark'))",Just for reference: this does not work due to the option then being considered to be set already (https://github.com/blueyed/neovim/blob/d2e34b3ee048dd5333516cc0fe1a7819412f4771/src/nvim/tui/input.c#L374).,
9766,blueyed,https://api.github.com/repos/neovim/neovim/pulls/10250,294327822,2019-06-17T14:32:10Z,test/functional/eval/null_spec.lua,"@@ -61,7 +61,7 @@ describe('NULL', function()     null_expr_test('does not crash append()', 'append(1, L)', 0, 0, function()       eq({''}, curbufmeths.get_lines(0, -1, false))     end)-    null_expr_test('does not crash setline()', 'setline(1, L)', 0, 0, function()+    null_expr_test('does not crash setline()', 'setline(1, L)', 0, 1, function()","It changes the behavior of `:echo setline(1, v:_null_list)` - which is fine I guess, and rather constructed, isn't it?",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/10250,294356651,2019-06-17T15:28:46Z,test/functional/eval/null_spec.lua,"@@ -61,7 +61,7 @@ describe('NULL', function()     null_expr_test('does not crash append()', 'append(1, L)', 0, 0, function()       eq({''}, curbufmeths.get_lines(0, -1, false))     end)-    null_expr_test('does not crash setline()', 'setline(1, L)', 0, 0, function()+    null_expr_test('does not crash setline()', 'setline(1, L)', 0, 1, function()","changes it from what to what? Ideally, a null list should behave like a (locked) empty list.",
9766,blueyed,https://api.github.com/repos/neovim/neovim/pulls/10250,294373343,2019-06-17T16:03:23Z,test/functional/eval/null_spec.lua,"@@ -61,7 +61,7 @@ describe('NULL', function()     null_expr_test('does not crash append()', 'append(1, L)', 0, 0, function()       eq({''}, curbufmeths.get_lines(0, -1, false))     end)-    null_expr_test('does not crash setline()', 'setline(1, L)', 0, 0, function()+    null_expr_test('does not crash setline()', 'setline(1, L)', 0, 1, function()","From 0 to 1 - i.e. it returns ""error"" instead of ""ok"".> Ideally, a null list should behave like a (locked) empty list.Ok, but that's behavior different from Vim then.Due to the check in https://github.com/neovim/neovim/pull/10250/files#diff-deb695d507653839019814f54242d47bR14878.",
9766,blueyed,https://api.github.com/repos/neovim/neovim/pulls/10250,294374558,2019-06-17T16:06:24Z,test/functional/eval/null_spec.lua,"@@ -61,7 +61,7 @@ describe('NULL', function()     null_expr_test('does not crash append()', 'append(1, L)', 0, 0, function()       eq({''}, curbufmeths.get_lines(0, -1, false))     end)-    null_expr_test('does not crash setline()', 'setline(1, L)', 0, 0, function()+    null_expr_test('does not crash setline()', 'setline(1, L)', 0, 1, function()","Previously it was using `if (argvars[1].v_type == VAR_LIST) {`.Happy to keep it (and forward it to Vim), but it's the first I hear about null-lists.. :)",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/10250,294377244,2019-06-17T16:12:59Z,test/functional/eval/null_spec.lua,"@@ -61,7 +61,7 @@ describe('NULL', function()     null_expr_test('does not crash append()', 'append(1, L)', 0, 0, function()       eq({''}, curbufmeths.get_lines(0, -1, false))     end)-    null_expr_test('does not crash setline()', 'setline(1, L)', 0, 0, function()+    null_expr_test('does not crash setline()', 'setline(1, L)', 0, 1, function()","> Ok, but that's behavior different from Vim then.We shouldn't regress from improvements made in nvim. Vim displays ""null"" list as if they were empty lists, which is their intentional behavior. The only reason one needs to ""hear"" about null list is because it behaves differently in some edge cases for no principal reason.",
9766,blueyed,https://api.github.com/repos/neovim/neovim/pulls/10250,294379309,2019-06-17T16:18:18Z,test/functional/eval/null_spec.lua,"@@ -61,7 +61,7 @@ describe('NULL', function()     null_expr_test('does not crash append()', 'append(1, L)', 0, 0, function()       eq({''}, curbufmeths.get_lines(0, -1, false))     end)-    null_expr_test('does not crash setline()', 'setline(1, L)', 0, 0, function()+    null_expr_test('does not crash setline()', 'setline(1, L)', 0, 1, function()","> Vim displays ""null"" list as if they were empty listsBut here it will cause a failure, i.e. it is not handled as if it is an empty list at least.So it could be considered a bug there then.As for the behavior in nvim it looks more like a side effect of not crashing on them.check ceb45a088 / f572bd7e4e. (https://github.com/neovim/neovim/pull/10250/commits/b7584360705ef53a1555a2b7b5410c8339f9e08c)",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/10250,294385392,2019-06-17T16:33:01Z,test/functional/eval/null_spec.lua,"@@ -61,7 +61,7 @@ describe('NULL', function()     null_expr_test('does not crash append()', 'append(1, L)', 0, 0, function()       eq({''}, curbufmeths.get_lines(0, -1, false))     end)-    null_expr_test('does not crash setline()', 'setline(1, L)', 0, 0, function()+    null_expr_test('does not crash setline()', 'setline(1, L)', 0, 1, function()","> As for the behavior in nvim it looks more like a side effect of not crashing on them.What does this even mean? In what way is accepting the list more ""a side effect of not crashing"" than throwing an error would be? How would this motivate one (non-crashing) behavior over another?",
9766,blueyed,https://api.github.com/repos/neovim/neovim/pulls/10250,294387453,2019-06-17T16:38:27Z,test/functional/eval/null_spec.lua,"@@ -61,7 +61,7 @@ describe('NULL', function()     null_expr_test('does not crash append()', 'append(1, L)', 0, 0, function()       eq({''}, curbufmeths.get_lines(0, -1, false))     end)-    null_expr_test('does not crash setline()', 'setline(1, L)', 0, 0, function()+    null_expr_test('does not crash setline()', 'setline(1, L)', 0, 1, function()","From @ZyX-I's commits it looked like he first refactored it, and when it crashed fixed that - but not using the condition that Vim had originally.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/10250,294395380,2019-06-17T16:58:37Z,test/functional/eval/null_spec.lua,"@@ -61,7 +61,7 @@ describe('NULL', function()     null_expr_test('does not crash append()', 'append(1, L)', 0, 0, function()       eq({''}, curbufmeths.get_lines(0, -1, false))     end)-    null_expr_test('does not crash setline()', 'setline(1, L)', 0, 0, function()+    null_expr_test('does not crash setline()', 'setline(1, L)', 0, 1, function()","Sure, but the general strategy he followed was to make null list behave consistently like locked empty lists, rather than just pick any non-crashing behavior arbitrarily.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/10239,295094507,2019-06-19T02:01:33Z,cmake/RunTests.cmake,"@@ -24,32 +24,37 @@ if(BUSTED_OUTPUT_TYPE STREQUAL junit)   set(EXTRA_ARGS OUTPUT_FILE ${BUILD_DIR}/${TEST_TYPE}test-junit.xml) endif() +set(BUSTED_ARGS $ENV{BUSTED_ARGS})+separate_arguments(BUSTED_ARGS)+ if(DEFINED ENV{TEST_TAG} AND NOT ""$ENV{TEST_TAG}"" STREQUAL """")-  set(TEST_TAG ""--tags=$ENV{TEST_TAG}"")+  list(APPEND BUSTED_ARGS ""--tags='$ENV{TEST_TAG}'"") endif()  if(DEFINED ENV{TEST_FILTER} AND NOT ""$ENV{TEST_FILTER}"" STREQUAL """")-  set(TEST_FILTER ""--filter=$ENV{TEST_FILTER}"")+  list(APPEND BUSTED_ARGS ""--filter='$ENV{TEST_FILTER}'"") endif() -execute_process(COMMAND ${CMAKE_COMMAND} -E make_directory ${WORKING_DIR}/Xtest-tmpdir)-set(ENV{TMPDIR} ${WORKING_DIR}/Xtest-tmpdir)+# TMPDIR: use relative test path (for parallel test runs / isolation).+file(RELATIVE_PATH rel_test_path ""${TEST_DIR}"" ""${TEST_PATH}"")+set(ENV{TMPDIR} ""${BUILD_DIR}/Xtest_tmpdir/${rel_test_path}"")+execute_process(COMMAND ${CMAKE_COMMAND} -E make_directory $ENV{TMPDIR})+ set(ENV{SYSTEM_NAME} ${SYSTEM_NAME}) execute_process(-  COMMAND ${BUSTED_PRG} ${TEST_TAG} ${TEST_FILTER} -v -o ${BUSTED_OUTPUT_TYPE}+  COMMAND ${BUSTED_PRG} -v -o ${BUSTED_OUTPUT_TYPE}     --lua=${LUA_PRG} --lazy --helper=${TEST_DIR}/${TEST_TYPE}/preload.lua     --lpath=${BUILD_DIR}/?.lua     --lpath=${WORKING_DIR}/runtime/lua/?.lua     --lpath=?.lua+    ${BUSTED_ARGS}     ${TEST_PATH}   WORKING_DIRECTORY ${WORKING_DIR}   ERROR_VARIABLE err   RESULT_VARIABLE res   ${EXTRA_ARGS}) -file(REMOVE ${WORKING_DIR}/Xtest_rplugin_manifest)-file(REMOVE_RECURSE ${WORKING_DIR}/Xtest_xdg)-file(REMOVE_RECURSE ${WORKING_DIR}/Xtest-tmpdir)+file(REMOVE_RECURSE ${BUILD_DIR}/Xtest_*)",I assume you tested this but I could not find a reference about `file` command supporting wildcards. Generally cmake expects `GLOB` or `GLOB_RECURSE` to be used then stored in a list which is then passed as an argument.,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/10239,295096995,2019-06-19T02:16:46Z,cmake/RunTests.cmake,"@@ -24,32 +24,37 @@ if(BUSTED_OUTPUT_TYPE STREQUAL junit)   set(EXTRA_ARGS OUTPUT_FILE ${BUILD_DIR}/${TEST_TYPE}test-junit.xml) endif() +set(BUSTED_ARGS $ENV{BUSTED_ARGS})+separate_arguments(BUSTED_ARGS)+ if(DEFINED ENV{TEST_TAG} AND NOT ""$ENV{TEST_TAG}"" STREQUAL """")-  set(TEST_TAG ""--tags=$ENV{TEST_TAG}"")+  list(APPEND BUSTED_ARGS ""--tags='$ENV{TEST_TAG}'"") endif()  if(DEFINED ENV{TEST_FILTER} AND NOT ""$ENV{TEST_FILTER}"" STREQUAL """")-  set(TEST_FILTER ""--filter=$ENV{TEST_FILTER}"")+  list(APPEND BUSTED_ARGS ""--filter='$ENV{TEST_FILTER}'"")","I would guess that single-quotes won't work on Windows if cmd.exe is involved somehow. Try this instead:    list(APPEND BUSTED_ARGS --filter=""$ENV{TEST_FILTER}"")",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/10239,295099477,2019-06-19T02:33:20Z,cmake/RunTests.cmake,"@@ -24,32 +24,37 @@ if(BUSTED_OUTPUT_TYPE STREQUAL junit)   set(EXTRA_ARGS OUTPUT_FILE ${BUILD_DIR}/${TEST_TYPE}test-junit.xml) endif() +set(BUSTED_ARGS $ENV{BUSTED_ARGS})+separate_arguments(BUSTED_ARGS)+ if(DEFINED ENV{TEST_TAG} AND NOT ""$ENV{TEST_TAG}"" STREQUAL """")-  set(TEST_TAG ""--tags=$ENV{TEST_TAG}"")+  list(APPEND BUSTED_ARGS ""--tags='$ENV{TEST_TAG}'"") endif()  if(DEFINED ENV{TEST_FILTER} AND NOT ""$ENV{TEST_FILTER}"" STREQUAL """")-  set(TEST_FILTER ""--filter=$ENV{TEST_FILTER}"")+  list(APPEND BUSTED_ARGS ""--filter='$ENV{TEST_FILTER}'"")","Actually, I bet it works without any quotes at all:     list(APPEND BUSTED_ARGS --filter=$ENV{TEST_FILTER})",
9766,blueyed,https://api.github.com/repos/neovim/neovim/pulls/10239,295102722,2019-06-19T02:54:18Z,cmake/RunTests.cmake,"@@ -24,32 +24,37 @@ if(BUSTED_OUTPUT_TYPE STREQUAL junit)   set(EXTRA_ARGS OUTPUT_FILE ${BUILD_DIR}/${TEST_TYPE}test-junit.xml) endif() +set(BUSTED_ARGS $ENV{BUSTED_ARGS})+separate_arguments(BUSTED_ARGS)+ if(DEFINED ENV{TEST_TAG} AND NOT ""$ENV{TEST_TAG}"" STREQUAL """")-  set(TEST_TAG ""--tags=$ENV{TEST_TAG}"")+  list(APPEND BUSTED_ARGS ""--tags='$ENV{TEST_TAG}'"") endif()  if(DEFINED ENV{TEST_FILTER} AND NOT ""$ENV{TEST_FILTER}"" STREQUAL """")-  set(TEST_FILTER ""--filter=$ENV{TEST_FILTER}"")+  list(APPEND BUSTED_ARGS ""--filter='$ENV{TEST_FILTER}'"")","Yeah, might be true given that is a list now.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/10228,295265809,2019-06-19T12:19:15Z,ci/before_install.sh,"@@ -7,28 +7,34 @@ if [[ ""${CI_TARGET}"" == lint ]]; then   exit fi -echo 'python info:'+echo 'Python info:' (-  2>&1 python --version || true-  2>&1 python2 --version || true-  2>&1 python3 --version || true-  2>&1 pip --version || true-  2>&1 pip2 --version || true-  2>&1 pip3 --version || true-  echo 'pyenv versions:'-  2>&1 pyenv versions || true-) | sed 's/^/  /'--if [[ ""${TRAVIS_OS_NAME}"" == osx ]]; then-  echo ""Upgrade Python 3 pip""-  python3 -m pip -q install --user --upgrade pip-else-  echo ""Upgrade Python 2 pip""-  python2.7 -m pip -q install --user --upgrade pip-  echo ""Upgrade Python 3 pip""-  # Allow failure. pyenv pip3 on travis is broken:-  # https://github.com/travis-ci/travis-ci/issues/8363-  python3 -m pip -q install --user --upgrade pip || true+  set -x+  python3 --version+  python2 --version+  python --version+  pip3 --version+  pip2 --version+  pip --version+  pyenv versions+) 2>&1 | sed 's/^/  /' || true++# Use pyenv, but not for OSX on Travis, where it only has the ""system"" version.+if [[ ""${TRAVIS_OS_NAME}"" != osx ]] && command -v pyenv; then+  echo 'Setting Python versions via pyenv'+  # Prefer python2 as python for /usr/bin/asan_symbolize-4.0.+  pyenv global 2.7.15:3.7","More straightfoward how? `python -m pip` is the python-recommended way of invoking `pip[3]`. Using `pip[3]` directly is deprecated, and it is imprecise because different versions of python may exist on a system.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/10228,295266859,2019-06-19T12:22:03Z,ci/install.sh,"@@ -11,18 +11,11 @@ if [[ ""${TRAVIS_OS_NAME}"" == osx ]]; then   export PATH=""/usr/local/opt/ccache/libexec:$PATH"" fi +# Use default CC to avoid compilation problems when installing Python modules. echo ""Install neovim module for Python 3.""-# Allow failure. pyenv pip3 on travis is broken:-# https://github.com/travis-ci/travis-ci/issues/8363-CC=cc python3 -m pip -q install --user --upgrade neovim || true--if ! [ ""${TRAVIS_OS_NAME}"" = osx ] ; then-  # Update PATH for pip.-  export PATH=""$(python2.7 -c 'import site; print(site.getuserbase())')/bin:$PATH""-  # Use default CC to avoid compilation problems when installing Python modules.-  echo ""Install neovim module for Python 2.""-  CC=cc python2.7 -m pip -q install --user --upgrade neovim-fi+CC=cc pip3 -q install --user --upgrade neovim+echo ""Install neovim module for Python 2.""+CC=cc pip2 -q install --user --upgrade neovim","`python -m pip` is the python-recommended way of invoking `pip[3]`. Using `pip[3]` directly is deprecated, and  imprecise because different versions of python may exist on a system.When reverting changes that were made previously (see `git log`) it is good to at least discuss it explicitly with the previous author.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/10228,295270151,2019-06-19T12:30:25Z,ci/before_install.sh,"@@ -7,28 +7,34 @@ if [[ ""${CI_TARGET}"" == lint ]]; then   exit fi -echo 'python info:'+echo 'Python info:' (-  2>&1 python --version || true-  2>&1 python2 --version || true-  2>&1 python3 --version || true-  2>&1 pip --version || true-  2>&1 pip2 --version || true-  2>&1 pip3 --version || true-  echo 'pyenv versions:'-  2>&1 pyenv versions || true-) | sed 's/^/  /'--if [[ ""${TRAVIS_OS_NAME}"" == osx ]]; then-  echo ""Upgrade Python 3 pip""-  python3 -m pip -q install --user --upgrade pip-else-  echo ""Upgrade Python 2 pip""-  python2.7 -m pip -q install --user --upgrade pip-  echo ""Upgrade Python 3 pip""-  # Allow failure. pyenv pip3 on travis is broken:-  # https://github.com/travis-ci/travis-ci/issues/8363-  python3 -m pip -q install --user --upgrade pip || true+  set -x+  python3 --version+  python2 --version+  python --version+  pip3 --version+  pip2 --version+  pip --version+  pyenv versions+) 2>&1 | sed 's/^/  /' || true++# Use pyenv, but not for OSX on Travis, where it only has the ""system"" version.+if [[ ""${TRAVIS_OS_NAME}"" != osx ]] && command -v pyenv; then+  echo 'Setting Python versions via pyenv'+  # Prefer python2 as python for /usr/bin/asan_symbolize-4.0.+  pyenv global 2.7.15:3.7",> I will be more passive here in the future I guess.It's good to be active but when reverting previous change we usually try to get signoff by the previous author. Otherwise it causes circular changes.,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/10269,295448783,2019-06-19T18:38:31Z,src/nvim/testdir/test_python3.vim,"@@ -2,7 +2,7 @@ "" TODO: move tests from test88.in here.  if !has('python3')-  finish+  throw 'Skipped: does not have +python3'","`+python{2,3}` never exists. The feature is called `python{2,3}` (without `+`). Full list of features is at `:h feature-list` (well, it's missing ""ruby""...).",
9766,blueyed,https://api.github.com/repos/neovim/neovim/pulls/10269,295552718,2019-06-19T22:41:19Z,src/nvim/testdir/test_python3.vim,"@@ -2,7 +2,7 @@ "" TODO: move tests from test88.in here.  if !has('python3')-  finish+  throw 'Skipped: does not have +python3'","Yes, that's only for naming, but I agree that is confusing - only temporary though.I do not get why it is not available during tests, but before - i.e. the tests gets skipped, but I'd expect them to run (and fail).",
8740057,janlazo,https://api.github.com/repos/neovim/neovim/pulls/10294,296461165,2019-06-23T00:36:23Z,src/nvim/eval.c,"@@ -8891,6 +8913,7 @@ static void filter_map(typval_T *argvars, typval_T *rettv, int map)       }       hash_unlock(ht);     } else {+      // argvars[0].v_type == VAR_LIST",Why is this comment instead of an assert or `} else if { /* code for list type */ } else { /* throw error */ }`?,
8740057,janlazo,https://api.github.com/repos/neovim/neovim/pulls/10294,296504093,2019-06-23T23:58:58Z,src/nvim/eval.c,"@@ -955,6 +955,88 @@ eval_to_bool(   return retval; } +// Call eval1() and give an error message if not done at a lower level.+static int eval1_emsg(char_u **arg, typval_T *rettv, bool evaluate)+  FUNC_ATTR_NONNULL_ARG(1, 2)+{+  const int did_emsg_before = did_emsg;+  const int called_emsg_before = called_emsg;++  const int ret = eval1(arg, rettv, evaluate);+  if (ret == FAIL) {+    // Report the invalid expression unless the expression evaluation has+    // been cancelled due to an aborting error, an interrupt, or an+    // exception, or we already gave a more specific error.+    // Also check called_emsg for when using assert_fails().+    if (!aborting()+        && did_emsg == did_emsg_before+        && called_emsg == called_emsg_before) {+      emsgf(_(e_invexpr2), arg);","This was `semsg` in the patch but we don't have one and the implementation looks similar to `emsgf`. For 8.1.0743,  porting `semsg` as a macro or inline function to `emsgf` should suffice.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/10330,297192754,2019-06-25T13:38:52Z,third-party/CMakeLists.txt,"@@ -6,7 +6,7 @@ project(NVIM_DEPS) include(CheckCCompilerFlag)  # Point CMake at any custom modules we may ship-list(APPEND CMAKE_MODULE_PATH ""${PROJECT_SOURCE_DIR}/cmake"")+list(APPEND CMAKE_MODULE_PATH ""${PROJECT_SOURCE_DIR}/cmake"" ""${PROJECT_SOURCE_DIR}/../cmake"")","~~if user has `cmake/` directory next to the `neovim/` directory could this accidentally add that?~~ No, the ""project"" here is the `third-party` sub-project.LGTM ",
9766,blueyed,https://api.github.com/repos/neovim/neovim/pulls/10348,297900784,2019-06-26T23:06:56Z,Makefile,"@@ -14,10 +14,25 @@ CMAKE_EXTRA_FLAGS ?= # CMAKE_INSTALL_PREFIX #   - May be passed directly or as part of CMAKE_EXTRA_FLAGS. #   - `checkprefix` target checks that it matches the CMake-cached value. #9615+ifeq (,$(CMAKE_EXTRA_FLAGS))+CMAKE_INSTALL_PREFIX ?=+else CMAKE_INSTALL_PREFIX ?= $(shell echo $(CMAKE_EXTRA_FLAGS) | 2>/dev/null \     grep -o 'CMAKE_INSTALL_PREFIX=[^ ]\+' | cut -d '=' -f2)+endif","Which extra stuff?This avoids the `$(shell)` for when no extra flags are used.  A small optimization, but just more simple when not needing the complexity (I've noticed all this initially with `make -n`).",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/9219,298043857,2019-06-27T07:38:44Z,third-party/CMakeLists.txt,"@@ -181,6 +182,21 @@ set(GETTEXT_SHA256 ff942af0e438ced4a8b0ea4b0b6e0d6d657157c5e2364de57baa279c1c125 set(LIBICONV_URL https://ftp.gnu.org/pub/gnu/libiconv/libiconv-1.15.tar.gz) set(LIBICONV_SHA256 ccf536620a45458d26ba83887a983b96827001e92a13847b45e4925cc8913178) ++#set(TREESITTER_URL https://github.com/tree-sitter/tree-sitter/archive/f30485f.tar.gz)+#set(TREESITTER_SHA256 cfe00c0b6f423adb082d6a5747d62eef96aab3d4aa9bd3f694524f0639ab272b)","#10124 is the PR that will be merged first. I will clean-up/rebase this one after that (or probably open a new one, as github interface breaks with long issues/PRs).",
9766,blueyed,https://api.github.com/repos/neovim/neovim/pulls/10348,298254120,2019-06-27T16:03:34Z,Makefile,"@@ -14,10 +14,25 @@ CMAKE_EXTRA_FLAGS ?= # CMAKE_INSTALL_PREFIX #   - May be passed directly or as part of CMAKE_EXTRA_FLAGS. #   - `checkprefix` target checks that it matches the CMake-cached value. #9615+ifeq (,$(CMAKE_EXTRA_FLAGS))+CMAKE_INSTALL_PREFIX ?=+else CMAKE_INSTALL_PREFIX ?= $(shell echo $(CMAKE_EXTRA_FLAGS) | 2>/dev/null \     grep -o 'CMAKE_INSTALL_PREFIX=[^ ]\+' | cut -d '=' -f2)+endif ifneq (,$(CMAKE_INSTALL_PREFIX))-  CMAKE_FLAGS += -DCMAKE_INSTALL_PREFIX=$(CMAKE_INSTALL_PREFIX)+  CMAKE_EXTRA_FLAGS += -DCMAKE_INSTALL_PREFIX=$(CMAKE_INSTALL_PREFIX)++checkprefix:+	@if [ -f build/.ran-cmake ]; then \+	  cached_prefix=$(shell $(CMAKE_PRG) -L -N build | 2>/dev/null grep 'CMAKE_INSTALL_PREFIX' | cut -d '=' -f2); \+	  if ! [ ""$(CMAKE_INSTALL_PREFIX)"" = ""$$cached_prefix"" ]; then \+	    echo ""Re-running CMake for changed CMAKE_INSTALL_PREFIX.""; \",I think it is good to have this in a single line to indicate action and reason belong together.,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/10348,298264267,2019-06-27T16:28:21Z,Makefile,"@@ -14,10 +14,25 @@ CMAKE_EXTRA_FLAGS ?= # CMAKE_INSTALL_PREFIX #   - May be passed directly or as part of CMAKE_EXTRA_FLAGS. #   - `checkprefix` target checks that it matches the CMake-cached value. #9615+ifeq (,$(CMAKE_EXTRA_FLAGS))+CMAKE_INSTALL_PREFIX ?=+else CMAKE_INSTALL_PREFIX ?= $(shell echo $(CMAKE_EXTRA_FLAGS) | 2>/dev/null \     grep -o 'CMAKE_INSTALL_PREFIX=[^ ]\+' | cut -d '=' -f2)+endif","There is no need to optimize  for `make -n` at the cost of extra code. The shell command performance cost is negligible. Code readability dominates the priorities here, the Makefile is already too big.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/10349,298347129,2019-06-27T20:03:43Z,src/nvim/buffer.c,"@@ -2605,14 +2605,22 @@ void buflist_list(exarg_T *eap)       continue;     } +    const int changed_char = (buf->b_flags & BF_READERR)+      ? 'x'+      : (bufIsChanged(buf) ? '+' : ' ');+    const int ro_char = !MODIFIABLE(buf)+      ? '-'+      : (buf->b_p_ro ? '=' : ' ');","It should be possible to show R or F here, using similar approach as `f_jobpid`. #10370",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/10229,298814384,2019-06-30T00:28:36Z,test/functional/terminal/tui_spec.lua,"@@ -905,62 +905,80 @@ describe('TUI background color', function()           ]], bg)         })       end)-    end)-  end+      last_bg = bg+    end++    local function assert_bg(colorspace, color, bg)+      -- Ensure the opposite of the expected bg is active.+      local other_bg = (bg == 'dark' and 'light' or 'dark')+      -- eq(bg, other_bg, 'assert_bg should be used with cycling bgs')+      if last_bg ~= other_bg then+        if other_bg == 'light' then+          feed_data('\027]11;rgb:f/f/f\007')+        else+          feed_data('\027]11;rgb:0/0/0\007')","would prefer ternary here, to avoid nesting.```luafeed_data(other_bg == 'light' and ...                              or ...)```",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/10071,298842415,2019-06-30T17:19:02Z,src/nvim/tui/tui.c,"@@ -542,18 +545,26 @@ void tui_io_driven_loop(void **argv){     loop_poll_events(&main_loop, -1);  // tui_loop.events is never processed     // LOOP_PROCESS_EVENTS(&main_loop, main_loop.events, 0);   }-   TUIData *data = ui->data;   tinput_destroy(&data->input);   signal_watcher_stop(&data->cont_handle);   signal_watcher_close(&data->cont_handle, NULL);   signal_watcher_close(&data->winch_handle, NULL);+}++void tui_data_destroy(void **argv) {+  UI *ui = argv[0];+  TUIData *data = ui->data;   kv_destroy(data->invalid_regions);   kv_destroy(data->attrs);   xfree(data->space_buf);   xfree(data); } +argv_callback tui_get_data_destroy_callback(void) {","not needed, `main.c` can just use `tui_data_destroy` directly. (same for the two `callback` functions below)",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/10382,298846145,2019-06-30T19:23:36Z,src/nvim/eval.c,"@@ -10767,6 +10767,25 @@ static void f_getwininfo(typval_T *argvars, typval_T *rettv, FunPtr fptr)   } } +/// ""waituntil(condition, timeout)"" function","maybe `timeout` should go first, since the condition/lambda/etc is often somewhat long. OTOH this forces `timeout` to always be specified, but it's probably good to force that decision anyways: waiting ""forever"" is probably not common.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/10382,298846524,2019-06-30T19:34:03Z,src/nvim/eval.c,"@@ -10767,6 +10767,25 @@ static void f_getwininfo(typval_T *argvars, typval_T *rettv, FunPtr fptr)   } } +/// ""waituntil(condition, timeout)"" function","> But we can use 0 to indicate that.yes, although I would suggest `-1` since that is consistent with `timer_start(...,{'repeat':-1})` . And `0` means ""check without waiting"" in `jobwait()`. Not sure if that would ever be useful for `wait()`, but seems good to keep the semantics the same.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/10382,299144220,2019-07-01T17:26:11Z,runtime/doc/eval.txt,"@@ -8788,6 +8789,17 @@ visualmode([expr])						*visualmode()* 		a non-empty String, then the Visual mode will be cleared and 		the old value is returned.  See |non-zero-arg|. +wait({timeout}, {condition})			*wait()*+		Waits until {condition} is satisfied, where {condition} is a+		|Funcref| or a |string| containing an expression.+		{timeout} is the maximum number of milliseconds to wait.++		Returns one of the following:+			* 0 if the condition was satisfied before the timeout+			* 1 if the timeout was exceeded+			* 2 if an error occurred+			* 3 if the function was interrupted",In analogy with `jobwait()` these should be:```*  0 condition satisfied before timeout* -1 timeout was exceeded* -2 function was interrupted* -3 error```,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/10377,299584313,2019-07-02T16:53:29Z,test/functional/autocmd/termclose_spec.lua,"@@ -20,8 +20,8 @@ describe('TermClose event', function()   it('triggers when fast-exiting terminal job stops', function()     command('autocmd TermClose * let g:test_termclose = 23')     command('terminal')-    command('call jobstop(b:terminal_job_id)')     retry(nil, nil, function() eq(23, eval('g:test_termclose')) end)+    assert(-1 ~= eval('jobwait([&channel], 0)[0]'))","should go above line 23 (in a `retry()`), to verify the semantics of the `g:test_termclose` assert.Then the `retry()` is not needed around the `g:test_termclose` assert.",
9766,blueyed,https://api.github.com/repos/neovim/neovim/pulls/10395,299598869,2019-07-02T17:29:06Z,CMakeLists.txt,"@@ -440,7 +440,7 @@ if(FEAT_TUI) endif()  find_package(LibVterm REQUIRED)-include_directories(SYSTEM ${LIBVTERM_INCLUDE_DIRS})+include_directories(SYSTEM ${LibVterm_INCLUDE_DIRS})","It is a side-effect of using the library.Yes.We could still set it manually, or have an option/flag for it to be done in LibFindMacros - but after all it would have avoided the recent confusion with REQUIRED not being handled due to case etc.While it adds a bit more noise (and might affect distributions/users), it is good to have it more consistent.I plan to use LibFindMacros for the other Find modules, so this will have an effect there also.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/10222,299875280,2019-07-03T09:57:56Z,runtime/lua/lsp/builtin_callbacks.lua,"@@ -0,0 +1,349 @@+-- luacheck: globals vim+-- Implements the following default callbacks:+--  textDocument/publishDiagnostics++--  IN PROGRESS: textDocument/completion+--  TODO: completionItem/resolve++--  textDocument/hover+--  TODO: textDocument/signatureHelp+--  textDocument/references+--  TODO: textDocument/documentHighlight+--  TODO: textDocument/documentSymbol+--  TODO: textDocument/formatting+--  TODO: textDocument/rangeFormatting+--  TODO: textDocument/onTypeFormatting+--  textDocument/definition+--  TODO: textDocument/codeAction+--  TODO: textDocument/codeLens+--  TODO: textDocument/documentLink+--  TODO: textDocument/rename++--  TODO: codeLens/resolve++--  TODO: documentLink/resolve++local log = require('lsp.log')+local protocol = require('lsp.protocol')+local errorCodes = protocol.errorCodes++local QuickFix = require('nvim.quickfix_list')+local LocationList = require('nvim.location_list')+local handle_completion = require('lsp.handle.completion')+local handle_workspace = require('lsp.handle.workspace')+++-- Callback definition section+local add_callback = function(callback_mapping, callback_object, name, callback, options)+  callback_object_instance = callback_object.new(name, options)+  callback_object_instance:add_callback(callback)+  callback_mapping[name] = callback_object_instance+end++-- 3 nvim/error_callback+local add_nvim_error_callback = function(callback_mapping, callback_object)+  add_callback(callback_mapping, callback_object, 'nvim/error_callback', function(original, error_message)+    local message = ''+    if error_message.message ~= nil and type(error_message.message) == 'string' then+      message = error_message.message+    elseif rawget(errorCodes, error_message.code) ~= nil then+      message = string.format('[%s] %s',+        error_message.code, errorCodes[error_message.code]+      )+    end++    vim.api.nvim_err_writeln(string.format('[LSP:%s] Error: %s', original.method, message))++    return+  end)+end++-- 3 textDocument/publishDiagnostics+local add_text_document_publish_diagnostics_callback = function(callback_mapping, callback_object)+  add_callback(callback_mapping, callback_object, 'textDocument/publishDiagnostics', function(self, data)","having an extra layer of ""adder"" functions seems a bit clumsy. Can't be just have a table of default callbacks and then write`default_callbacks[""textDocument/publishDiagnostics""] = function(self,data) ... end`. Then `add_all_callbacks` can just loop over the table. Or the user can add a subset by `add_callbacks{'textDocument/publishDiagnostics', 'textDocument/completion', ...}` . ",
9766,blueyed,https://api.github.com/repos/neovim/neovim/pulls/10412,300393418,2019-07-04T13:14:30Z,.travis.yml,"@@ -47,60 +47,62 @@ env:     - CCACHE_SLOPPINESS=time_macros,file_macro     - CCACHE_BASEDIR=""$TRAVIS_BUILD_DIR"" +anchors:+  envs:+    - &common-job-env+      # Do not fall back to cache for ""master"" for PR on ""release"" branch.+      _FOR_TRAVIS_CACHE=$TRAVIS_BRANCH+ jobs:   include:     - stage: baseline       os: linux       compiler: clang-4.0       # Use Lua so that ASAN can test our embedded Lua support. 8fec4d53d0f6       env: >+        *common-job-env         CLANG_SANITIZER=ASAN_UBSAN         CMAKE_FLAGS=""$CMAKE_FLAGS -DPREFER_LUA=ON""         ASAN_SYMBOLIZE=asan_symbolize-4.0-        _FOR_TRAVIS_CACHE=$TRAVIS_BRANCH     - os: linux       compiler: gcc       env: >+        *common-job-env         FUNCTIONALTEST=functionaltest-lua         CMAKE_FLAGS=""$CMAKE_FLAGS -DPREFER_LUA=ON""         DEPS_CMAKE_FLAGS=""$DEPS_CMAKE_FLAGS -DUSE_BUNDLED_LUAJIT=OFF""-        _FOR_TRAVIS_CACHE=$TRAVIS_BRANCH     - os: linux       # Travis creates a cache per compiler. Set a different value here to       # store 32-bit dependencies in a separate cache.       compiler: gcc       env: >+        *common-job-env         BUILD_32BIT=ON-        _FOR_TRAVIS_CACHE=$TRAVIS_BRANCH     - if: branch = master AND commit_message !~ /\[skip.lint\]/       os: linux-      env: >-        CI_TARGET=lint","Only accidentally, restored it.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/10421,300461032,2019-07-04T16:31:39Z,test/helpers.lua,"@@ -15,7 +15,13 @@ local function shell_quote(str)   end end -local function argss_to_cmd(...)+local REMOVE_THIS = {}++local global_helpers = {","ctags does not drive our choices, and in any case the function names are usually quasi-unique. I've never had a problem with e.g.:    :tag argss_to_cmd`module` is a good pattern and helps new devs understand good practices and the intent.Also ctags won't be needed once we have LSP and/or treesitter helping us.",
9766,blueyed,https://api.github.com/repos/neovim/neovim/pulls/10422,300517277,2019-07-05T01:22:48Z,.travis.yml,"@@ -46,47 +46,71 @@ env:     - CCACHE_COMPRESS=1     - CCACHE_SLOPPINESS=time_macros,file_macro     - CCACHE_BASEDIR=""$TRAVIS_BUILD_DIR""+    # Indirection for shorter / more distinct entry in job's env listing.+    - _TCB_=$TRAVIS_BRANCH++anchors:+  envs: &common-job-env+    # Do not fall back to cache for ""master"" for PR on ""release"" branch.+    _TCB_: $_TCB_  jobs:   include:     - stage: normal builds       os: linux       compiler: clang-4.0       # Use Lua so that ASAN can test our embedded Lua support. 8fec4d53d0f6-      env: >-        CLANG_SANITIZER=ASAN_UBSAN-        CMAKE_FLAGS=""$CMAKE_FLAGS -DPREFER_LUA=ON""-        ASAN_SYMBOLIZE=asan_symbolize-4.0+      env:+        <<: *common-job-env+        CLANG_SANITIZER: ASAN_UBSAN+        CMAKE_FLAGS: ""$CMAKE_FLAGS -DPREFER_LUA=ON""+        ASAN_SYMBOLIZE: asan_symbolize-4.0",Because it became a hash.  Now it's a list (to have it in the end).,
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/10090,300780442,2019-07-05T19:33:10Z,src/nvim/screen.c,"@@ -1495,8 +1495,9 @@ static void win_update(win_T *wp)      // make sure the rest of the screen is blank     // write the 'eob' character to rows that aren't part of the file.-    win_draw_end(wp, wp->w_p_fcs_chars.eob, ' ', false, row, wp->w_grid.Rows,-                 HLF_EOB);+    bool minimal = wp->w_float_config.minimal;+    win_draw_end(wp, minimal ? ' ' : wp->w_p_fcs_chars.eob, ' ', false, row, wp->w_grid.Rows,+                 minimal ? 0 : HLF_EOB);","All options this concerns are window-local, otherwise it would no point of including them. I did it this way for `fcs` because I didn't like going in and string-edit a specific flag in a larger user option. ",
9766,blueyed,https://api.github.com/repos/neovim/neovim/pulls/10434,300826307,2019-07-06T09:40:48Z,src/nvim/terminal.c,"@@ -331,7 +331,10 @@ void terminal_close(Terminal *term, char *msg)   }    if (buf) {+    aco_save_T aco;+    aucmd_prepbuf(&aco, buf);     apply_autocmds(EVENT_TERMCLOSE, NULL, NULL, false, buf);+    aucmd_restbuf(&aco);","I think the pattern would be to use `bufref_valid` instead, as with https://github.com/vim/vim/blob/b4d9b893d3c7af24b5adf4ae0475ada32d36f5ad/src/buffer.c#L563-L573 (NOTE: requires missing Vim patches to get to this)",
9766,blueyed,https://api.github.com/repos/neovim/neovim/pulls/10438,300962953,2019-07-08T07:52:16Z,third-party/cmake/BuildLuv.cmake,"@@ -62,13 +62,18 @@ set(LUV_INCLUDE_FLAGS set(LUV_PATCH_COMMAND     ${CMAKE_COMMAND} -E copy_directory ${LUV_SRC_DIR}/rockspecs ${LUV_SRC_DIR}) +if(NOT LUV_LUA_ENGINE)","Yes, `PREFER_LUA` is a bit unspecific / undefined currently (and only for the main project).I think it might make sense to factor out the handling of it into a shared cmake file, and then also use it for third-party.  Related code: https://github.com/neovim/neovim/blob/38342d75f64e0825505bbb6ff6e1a67b12bf3f17/CMakeLists.txt#L392-L402(not necessarily controlling it through `PREFER_LUA`, but could work similar as with BuildLuarocks)As for the issue at hand: `-DWITH_LUA_ENGINE` should be set to `Lua` maybe with `-`USE_BUNDLED_LUAJIT=0` / `USE_BUNDLED_LUA=1` (is this what you are using, or do you want to use the system Lua?)```diffdiff --git i/third-party/cmake/BuildLuv.cmake w/third-party/cmake/BuildLuv.cmakeindex 9f8e4bbc4..967e0a171 100644--- i/third-party/cmake/BuildLuv.cmake+++ w/third-party/cmake/BuildLuv.cmake@@ -71,6 +71,19 @@ set(LUV_CONFIGURE_COMMAND_COMMON   -DBUILD_SHARED_LIBS=OFF   -DBUILD_MODULE=OFF)+if(USE_BUNDLED_LUAJIT)+  list(APPEND LUV_CONFIGURE_COMMAND_COMMON -DWITH_LUA_ENGINE=LuaJit)+elseif(USE_BUNDLED_LUA)+  list(APPEND LUV_CONFIGURE_COMMAND_COMMON -DWITH_LUA_ENGINE=Lua)+else()+  find_package(LuaJit)+  if(LUAJIT_FOUND)+    list(APPEND LUV_CONFIGURE_COMMAND_COMMON -DWITH_LUA_ENGINE=LuaJit)+  else()+    list(APPEND LUV_CONFIGURE_COMMAND_COMMON -DWITH_LUA_ENGINE=Lua)+  endif()+endif()+ if(USE_BUNDLED_LIBUV)   set(LUV_CONFIGURE_COMMAND_COMMON     ${LUV_CONFIGURE_COMMAND_COMMON}```",
8843736,bartop,https://api.github.com/repos/neovim/neovim/pulls/10446,301407145,2019-07-09T05:58:04Z,src/nvim/eval.c,"@@ -15850,11 +15850,10 @@ static void f_sign_getplaced(typval_T *argvars, typval_T *rettv, FunPtr fptr)       }       if ((di = tv_dict_find(dict, ""lnum"", -1)) != NULL) {         // get signs placed at this line-        lnum = (linenr_T)tv_get_number_chk(&di->di_tv, &notanum);-        if (notanum) {+        lnum = tv_get_lnum(&di->di_tv);+        if (lnum <= 0) {",Docstring says tv_get_lnum returns line number or 0 or 1.https://github.com/neovim/neovim/blob/7d604a1e6158cda79f7ac485e0ef0e349014f8bf/src/nvim/eval/typval.c#L2761Are you sure that only -1 check is fine?,
9766,blueyed,https://api.github.com/repos/neovim/neovim/pulls/10391,302075704,2019-07-10T13:50:46Z,src/nvim/testdir/shared.vim,"@@ -262,6 +266,12 @@ func! Screenline(lnum)   return matchstr(line, '^.\{-}\ze\s*$') endfunc -func CanRunGui()-  return has('gui') && ($DISPLAY != """" || has('gui_running'))+"" Gets the text of a terminal line, using term_scrape()+func Get_terminal_text(bufnr, row)+  let list = term_scrape(a:bufnr, a:row)+  let text = ''+  for item in list+    let text .= item.chars+  endfor+  return text endfunc","We should not add `Get_terminal_text` (unused, and removed in Vim via ""patch 8.1.0769: :stop is covered in two tests"" later).  Merged already via https://github.com/neovim/neovim/pull/10157.",
112971,jamessan,https://api.github.com/repos/neovim/neovim/pulls/6252,303058678,2019-07-12T16:32:19Z,src/nvim/globals.h,"@@ -556,7 +556,6 @@ EXTERN win_T    *prevwin INIT(= NULL);  /* previous window */   FOR_ALL_TABS(tp) \     FOR_ALL_WINDOWS_IN_TAB(wp, tp) -# define FOR_ALL_WINDOWS(wp) for (wp = firstwin; wp != NULL; wp = wp->w_next)","It's been over two years since I did this.  I don't remember the reasoning.  My guess would be that it seemed like unnecessary duplication.  `FOR_ALL_WINDOWS_IN_TAB` covers all cases that `FOR_ALL_WINDOWS` does.The only ""problem"" is that the compiler warns about the comparison, since it doesn't know about the macro.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/10459,303160185,2019-07-12T21:51:01Z,src/nvim/sign.c,"@@ -1374,16 +1365,15 @@ void sign_getlist(const char_u *name, list_T *retlist) list_T *get_buffer_signs(buf_T *buf)   FUNC_ATTR_NONNULL_RET FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT {-  signlist_T  *sign;-  dict_T  *d;-  list_T *const l = tv_list_alloc(kListLenMayKnow);+  signlist_T *sign;+  dict_T *dict;+  list_T *const list = tv_list_alloc(kListLenMayKnow);","3 reasons not to rename things like this:1. The scope is very small. Using long names for small scopes is more harmful than useful.2. It is unidiomatic for the Vim/Nvim codebase. We are not going to rename every `d` to `dict`, and it doesn't add useful information anyway. `d` is almost always a dict. `l` is very often a list.3. We are not making significant changes to the sign code. If someone does so they can make that decision, but meanwhile renaming things is just churn.",
8843736,bartop,https://api.github.com/repos/neovim/neovim/pulls/10459,303199006,2019-07-13T09:43:53Z,src/nvim/sign.c,"@@ -1374,16 +1365,15 @@ void sign_getlist(const char_u *name, list_T *retlist) list_T *get_buffer_signs(buf_T *buf)   FUNC_ATTR_NONNULL_RET FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT {-  signlist_T  *sign;-  dict_T  *d;-  list_T *const l = tv_list_alloc(kListLenMayKnow);+  signlist_T *sign;+  dict_T *dict;+  list_T *const list = tv_list_alloc(kListLenMayKnow);","@justinmk Ok, I am not fully convinced (entering codebase with variable `d` vs `dict` makes difference for me), but I reverted the naming changes ;)",
18271144,ngortheone,https://api.github.com/repos/neovim/neovim/pulls/10495,303214073,2019-07-13T18:15:05Z,src/nvim/ugrid.c,"@@ -72,8 +73,10 @@ void ugrid_scroll(UGrid *grid, int top, int bot, int left, int right, int count)   for (i = start; i != stop; i += step) {     UCell *target_row = grid->cells[i] + left;     UCell *source_row = grid->cells[i + count] + left;+    size_t bytes;",```right = -3left = -1````assert(right >= left)` the condition holds and we still get  negative value here `right - left + 1`  that will be cast to unsigned. I know that this situation is unlikely but I think being more defensive with memory operations will not be misplaced here.We could check that both operands are positive to avoid this  `assert(right >= left && left >= 0)` Or maybe  `assert(right >= left && right >= 0)`  if  `left` could be negative,
11682285,erw7,https://api.github.com/repos/neovim/neovim/pulls/10475,303234134,2019-07-14T08:52:56Z,src/nvim/popupmnu.c,"@@ -136,7 +136,10 @@ void pum_display(pumitem_T *array, int size, int selected, bool array_changed,       } else {         ui_call_popupmenu_select(selected);       }-      return;+      pum_height = ui_pum_height();","@bfredl For now, I changed `pum_get_height()` to call `ui_pum_get_height()`. I think that there is a problem if `<PageUp>` etc. call `pum_get_height()` before the UI calls `nvim_ui_pum_set_height()`. How do I synchronize? Can you give me some implementation hint? Should I call `LOOP_PROCESS_EVENTS_UNTIL(&main_loop, NULL, -1, is_pum_set_height_done())` with `pum_get_height()`? A deadlock occurred when trying to synchronize using the above method immediately after `ui_call_popupmenu_show()`.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/10475,303239116,2019-07-14T11:17:46Z,src/nvim/popupmnu.c,"@@ -136,7 +136,10 @@ void pum_display(pumitem_T *array, int size, int selected, bool array_changed,       } else {         ui_call_popupmenu_select(selected);       }-      return;+      pum_height = ui_pum_height();","There should be no need to synchronize anything. As long as the UI sends the `nvim_ui_pum_set_height()`  before `nvim_input('<PageUp>')` it should be processed before. If an indirect mapping or something uses a slightly outdated value, it is not a catastrophe. Let's not make it more complicated than needed.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/10475,303239327,2019-07-14T11:23:17Z,src/nvim/popupmnu.c,"@@ -852,7 +855,8 @@ void pum_recompose(void) /// Only valid when pum_visible() returns TRUE! int pum_get_height(void) {-  return pum_height;+  int ui_pum_height = ui_pum_get_height();+  return ui_pum_height ? ui_pum_height : pum_height;",use `pum_external && ui_pum_height` as the condition.,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/10507,303340840,2019-07-15T09:00:33Z,src/nvim/ops.c,"@@ -3085,8 +3085,10 @@ void do_put(int regname, yankreg_T *reg, int dir, long count, int flags)       memset(ptr, ' ', (size_t)bd.endspaces);       ptr += bd.endspaces;       // move the text after the cursor to the end of the line.-      memmove(ptr, oldp + bd.textcol + delcount,-              (size_t)((int)oldlen - bd.textcol - delcount + 1));+      size_t columns;+      STRICT_SUB(oldlen, bd.textcol, &columns, size_t);+      STRICT_SUB(columns, delcount +1, &columns, size_t);","> This entire change is not at all readable. Can't we have something like `STRICT_CAST((int)oldlen - bd.textcol - delcount + 1, size_t)` (first assert the int is >= 0, then cast to size_t).As long as we know the result fits in `int`, sure",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/10190,303382595,2019-07-15T11:04:13Z,src/nvim/api/buffer.c,"@@ -142,6 +142,13 @@ Boolean nvim_buf_attach(uint64_t channel_id,       }       cb.on_lines = v->data.luaref;       v->data.integer = LUA_NOREF;+    } else if (is_lua && strequal(""on_bytes"", k.data)) {",Would on_data be an incorrect name? We use that elsewhere.,
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/10190,303387202,2019-07-15T11:19:25Z,src/nvim/api/buffer.c,"@@ -142,6 +142,13 @@ Boolean nvim_buf_attach(uint64_t channel_id,       }       cb.on_lines = v->data.luaref;       v->data.integer = LUA_NOREF;+    } else if (is_lua && strequal(""on_bytes"", k.data)) {","This entire API is subject to change, this is just the lazy ""what misc1.c does internally"" hack. Probably, for consumers that opt-in to byte resolution, there should be a singe event with `pos_T start, pos_T old_end, pos_T new_end` values (+ total byte count of the deleted region, though actually we should do that first, I will open a separate PR).",
18271144,ngortheone,https://api.github.com/repos/neovim/neovim/pulls/10507,303444207,2019-07-15T13:48:28Z,src/nvim/ops.c,"@@ -3085,8 +3085,10 @@ void do_put(int regname, yankreg_T *reg, int dir, long count, int flags)       memset(ptr, ' ', (size_t)bd.endspaces);       ptr += bd.endspaces;       // move the text after the cursor to the end of the line.-      memmove(ptr, oldp + bd.textcol + delcount,-              (size_t)((int)oldlen - bd.textcol - delcount + 1));+      size_t columns;+      STRICT_SUB(oldlen, bd.textcol, &columns, size_t);+      STRICT_SUB(columns, delcount +1, &columns, size_t);","So the `int columns = (int)oldlen - bd.textcol - delcount + 1` will remove PVS warning as there is no casting of a result anymore (only operands).On one hand I agree with @bfredl - this code is more readable. I've seen emacs codebase, it is totally unreadable because of macros. On the other hand `STRICT_ADD/SUB` feels like a safer way.I don't know how strong are the guarantees that `oldlen` fits into `int`In the vacuum the problem with suggested solution is that this:`int columns = (int)oldlen - bd.textcol - delcount + 1` +  `assert(columns >= 0)` can pass assertion in case of double overflow, if numbers are big enough. Not sure how real this is in given codebase.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/10505,303677927,2019-07-15T23:33:45Z,src/nvim/ops.c,"@@ -2602,8 +2602,9 @@ static void op_yank_reg(oparg_T *oap, bool message, yankreg_T *reg, bool append)  static void yank_copy_line(yankreg_T *reg, struct block_def *bd, size_t y_idx) {-  char_u *pnew = xmallocz((size_t)(bd->startspaces + bd->endspaces-                                   + bd->textlen));+  assert(bd->startspaces >= 0 && bd->endspaces >= 0 && bd->textlen >= 0);+  char_u *pnew = xmallocz((size_t)bd->startspaces + (size_t)bd->endspaces+                          + (size_t)bd->textlen);",Probably it makes sense to use similar approach as https://github.com/neovim/neovim/pull/10507#discussion_r303278571 : ```cint size = bd->startspaces + bd->endspaces + bd->textlen;assert(size >= 0);char_u *pnew = xmallocz((size_t)size);```,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/3758,303679050,2019-07-15T23:39:36Z,test/functional/autocmd/cursorhold_spec.lua,"@@ -0,0 +1,31 @@+local helpers = require('test.functional.helpers')(after_each)++local clear = helpers.clear+local eq = helpers.eq+local eval = helpers.eval+local feed = helpers.feed+local retry = helpers.retry+local source = helpers.source+local sleep = helpers.sleep++describe('CursorHoldI', function()+  before_each(clear)++  -- NOTE: since this test uses RPC it is not necessary to trigger the initial+  --       issue (#3757) via timer's or RPC callbacks in the first place.+  it('is triggered after input', function()",i would put this test in https://github.com/neovim/neovim/blob/31f879983f5effb94a8d62c3073576511131bf6e/test/functional/api/vim_spec.lua#L613,
9766,blueyed,https://api.github.com/repos/neovim/neovim/pulls/10514,303694394,2019-07-16T01:10:12Z,test/functional/fixtures/shell-test.c,"@@ -71,8 +70,12 @@ int main(int argc, char **argv)         fprintf(stderr, ""Not enough REP arguments\n"");         return 4;       }-      uint8_t number = (uint8_t) *argv[2];-      for (uint8_t i = 0; i < number; i++) {+      int count = 0;+      if (sscanf(argv[2], ""%d"", &count) != 1) {",JFI: `cppcheck` also warns about it:> [test/functional/fixtures/shell-test.c:107]: (warning) sscanf() without field width limits can crash with huge input data.,
8740057,janlazo,https://api.github.com/repos/neovim/neovim/pulls/10059,303714972,2019-07-16T03:25:15Z,src/nvim/sign.c,"@@ -0,0 +1,1746 @@+// This is an open source non-commercial project. Dear PVS-Studio, please check+// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com++//+// sign.c: functions for managing with signs+//+++#include ""nvim/vim.h""+#include ""nvim/sign.h""+#include ""nvim/ascii.h""+#include ""nvim/buffer.h""+#include ""nvim/charset.h""+#include ""nvim/cursor.h""+#include ""nvim/ex_docmd.h""+#include ""nvim/edit.h""+#include ""nvim/fold.h""+#include ""nvim/move.h""+#include ""nvim/screen.h""+#include ""nvim/syntax.h""++/// Struct to hold the sign properties.+typedef struct sign sign_T;++struct sign+{+    sign_T      *sn_next;       // next sign in list+    int         sn_typenr;      // type number of sign+    char_u      *sn_name;       // name of sign+    char_u      *sn_icon;       // name of pixmap+# ifdef FEAT_SIGN_ICONS",Where is this defined? I can't find `#define FEAT_SIGN_ICONS` in the codebase so I assume this is dead code.,
11682285,erw7,https://api.github.com/repos/neovim/neovim/pulls/10475,303716201,2019-07-16T03:33:48Z,src/nvim/popupmnu.c,"@@ -852,7 +855,8 @@ void pum_recompose(void) /// Only valid when pum_visible() returns TRUE! int pum_get_height(void) {-  return pum_height;+  int ui_pum_height = ui_pum_get_height();+  return ui_pum_height ? ui_pum_height : pum_height;","@bfredl Please tell me the reason to change the condition so. The reasons I think are:1. When a `UI` that does not support `ext_popupmenu` uses `nvim_pum_set_height()`, it does not use its `pum_height`.1.  To avoid unnecessary calls to `ui_pum_get_height()`.1. To clarify the meaning of the code when others see this code in the future.If it is 1, check that `ui->ui_ext[kUIpopupmenu]` is true in `nvim_set_pum_height()`.In case of 2, change as follows:```Diff--- a/src/nvim/popupmnu.c+++ b/src/nvim/popupmnu.c@@ -855,8 +855,8 @@ void pum_recompose(void) /// Only valid when pum_visible() returns TRUE! int pum_get_height(void) {-  int ui_pum_height = ui_pum_get_height();-  return pum_external && ui_pum_height ? ui_pum_height : pum_height;+  int ui_pum_height = pum_extara ? ui_pum_get_height() : 0;+  return ui_pum_height ? ui_pum_height : pum_height; } void pum_set_boundings(dict_T *dict)```In the case of 3, write an appropriate comment. I think the above is more appropriate than changing the conditions.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/10519,303816449,2019-07-16T09:40:53Z,src/nvim/ex_docmd.c,"@@ -1156,13 +1156,24 @@ static void get_wincmd_addr_type(char_u *arg, exarg_T *eap)     case Ctrl_I:     case 'd':     case Ctrl_D:-      /* window size or any count */+    case Ctrl_Z:+    case 'z':+    case 'P':+    case 't':+    case Ctrl_T:+    case 'b':+    case Ctrl_B:+    case 'p':+    case Ctrl_P:+    case '=':+    case CAR:+      // window size or any count       eap->addr_type = ADDR_LINES;","This is different semantically that ""no count"", which we've now lost as a hint/documentation.This particular PVS warning is really annoying. I wish we could find a way to disable some warnings project-wide.In this case I don't think this is a good change.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/10541,305283310,2019-07-19T09:48:15Z,src/nvim/ex_getln.c,"@@ -3598,7 +3611,8 @@ nextwild (   }    i = (int)(xp->xp_pattern - ccline.cmdbuff);-  xp->xp_pattern_len = ccline.cmdpos - i;+  assert(ccline.cmdpos >= i);+  xp->xp_pattern_len = (size_t)(ccline.cmdpos - i);",PVS might complain.```suggestion  xp->xp_pattern_len = (size_t)ccline.cmdpos - i;```,